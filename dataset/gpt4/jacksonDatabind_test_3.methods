@Override [EOL] public Object findInjectableValueId(AnnotatedMember m) { [EOL]     JacksonInject ann = m.getAnnotation(JacksonInject.class); [EOL]     if (ann == null) { [EOL]         return null; [EOL]     } [EOL]     String id = ann.value(); [EOL]     if (id.length() == 0) { [EOL]         if (!(m instanceof AnnotatedMethod)) { [EOL]             return m.getRawType().getName(); [EOL]         } [EOL]         AnnotatedMethod am = (AnnotatedMethod) m; [EOL]         if (am.getParameterCount() == 0) { [EOL]             return m.getRawType().getName(); [EOL]         } [EOL]         return am.getRawParameterType(0).getName(); [EOL]     } [EOL]     return id; [EOL] }
@Override [EOL] public Object findInjectableValueId(AnnotatedMember m) { [EOL]     JacksonInject ann = m.getAnnotation(JacksonInject.class); [EOL]     if (ann == null) { [EOL]         return null; [EOL]     } [EOL]     String id = ann.value(); [EOL]     if (id.length() == 0) { [EOL]         if (!(m instanceof AnnotatedMethod)) { [EOL]             return m.getRawType().getName(); [EOL]         } [EOL]         AnnotatedMethod am = (AnnotatedMethod) m; [EOL]         if (am.getParameterCount() == 0) { [EOL]             return m.getRawType().getName(); [EOL]         } [EOL]         return am.getRawParameterType(0).getName(); [EOL]     } [EOL]     return id; [EOL] }
@Override [EOL] public Object findInjectableValueId(AnnotatedMember m) { [EOL]     JacksonInject ann = m.getAnnotation(JacksonInject.class); [EOL]     if (ann == null) { [EOL]         return null; [EOL]     } [EOL]     String id = ann.value(); [EOL]     if (id.length() == 0) { [EOL]         if (!(m instanceof AnnotatedMethod)) { [EOL]             return m.getRawType().getName(); [EOL]         } [EOL]         AnnotatedMethod am = (AnnotatedMethod) m; [EOL]         if (am.getParameterCount() == 0) { [EOL]             return m.getRawType().getName(); [EOL]         } [EOL]         return am.getRawParameterType(0).getName(); [EOL]     } [EOL]     return id; [EOL] }
@Override [EOL] public Object findInjectableValueId(AnnotatedMember m) { [EOL]     JacksonInject ann = m.getAnnotation(JacksonInject.class); [EOL]     if (ann == null) { [EOL]         return null; [EOL]     } [EOL]     String id = ann.value(); [EOL]     if (id.length() == 0) { [EOL]         if (!(m instanceof AnnotatedMethod)) { [EOL]             return m.getRawType().getName(); [EOL]         } [EOL]         AnnotatedMethod am = (AnnotatedMethod) m; [EOL]         if (am.getParameterCount() == 0) { [EOL]             return m.getRawType().getName(); [EOL]         } [EOL]         return am.getRawParameterType(0).getName(); [EOL]     } [EOL]     return id; [EOL] }
@Override [EOL] public Class<? extends KeyDeserializer> findKeyDeserializer(Annotated a) { [EOL]     JsonDeserialize ann = a.getAnnotation(JsonDeserialize.class); [EOL]     if (ann != null) { [EOL]         Class<? extends KeyDeserializer> deserClass = ann.keyUsing(); [EOL]         if (deserClass != KeyDeserializer.None.class) { [EOL]             return deserClass; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Class<? extends KeyDeserializer> findKeyDeserializer(Annotated a) { [EOL]     JsonDeserialize ann = a.getAnnotation(JsonDeserialize.class); [EOL]     if (ann != null) { [EOL]         Class<? extends KeyDeserializer> deserClass = ann.keyUsing(); [EOL]         if (deserClass != KeyDeserializer.None.class) { [EOL]             return deserClass; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Class<? extends KeyDeserializer> findKeyDeserializer(Annotated a) { [EOL]     JsonDeserialize ann = a.getAnnotation(JsonDeserialize.class); [EOL]     if (ann != null) { [EOL]         Class<? extends KeyDeserializer> deserClass = ann.keyUsing(); [EOL]         if (deserClass != KeyDeserializer.None.class) { [EOL]             return deserClass; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Class<?> findDeserializationKeyType(Annotated am, JavaType baseKeyType) { [EOL]     JsonDeserialize ann = am.getAnnotation(JsonDeserialize.class); [EOL]     if (ann != null) { [EOL]         Class<?> cls = ann.keyAs(); [EOL]         if (cls != NoClass.class) { [EOL]             return cls; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Class<?> findDeserializationKeyType(Annotated am, JavaType baseKeyType) { [EOL]     JsonDeserialize ann = am.getAnnotation(JsonDeserialize.class); [EOL]     if (ann != null) { [EOL]         Class<?> cls = ann.keyAs(); [EOL]         if (cls != NoClass.class) { [EOL]             return cls; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public String findDeserializationName(AnnotatedMethod am) { [EOL]     JsonSetter ann = am.getAnnotation(JsonSetter.class); [EOL]     if (ann != null) { [EOL]         return ann.value(); [EOL]     } [EOL]     JsonProperty pann = am.getAnnotation(JsonProperty.class); [EOL]     if (pann != null) { [EOL]         return pann.value(); [EOL]     } [EOL]     if (am.hasAnnotation(JsonDeserialize.class) || am.hasAnnotation(JsonView.class) || am.hasAnnotation(JsonBackReference.class) || am.hasAnnotation(JsonManagedReference.class)) { [EOL]         return ""; [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public String findDeserializationName(AnnotatedMethod am) { [EOL]     JsonSetter ann = am.getAnnotation(JsonSetter.class); [EOL]     if (ann != null) { [EOL]         return ann.value(); [EOL]     } [EOL]     JsonProperty pann = am.getAnnotation(JsonProperty.class); [EOL]     if (pann != null) { [EOL]         return pann.value(); [EOL]     } [EOL]     if (am.hasAnnotation(JsonDeserialize.class) || am.hasAnnotation(JsonView.class) || am.hasAnnotation(JsonBackReference.class) || am.hasAnnotation(JsonManagedReference.class)) { [EOL]         return ""; [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public String findDeserializationName(AnnotatedMethod am) { [EOL]     JsonSetter ann = am.getAnnotation(JsonSetter.class); [EOL]     if (ann != null) { [EOL]         return ann.value(); [EOL]     } [EOL]     JsonProperty pann = am.getAnnotation(JsonProperty.class); [EOL]     if (pann != null) { [EOL]         return pann.value(); [EOL]     } [EOL]     if (am.hasAnnotation(JsonDeserialize.class) || am.hasAnnotation(JsonView.class) || am.hasAnnotation(JsonBackReference.class) || am.hasAnnotation(JsonManagedReference.class)) { [EOL]         return ""; [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public String findDeserializationName(AnnotatedMethod am) { [EOL]     JsonSetter ann = am.getAnnotation(JsonSetter.class); [EOL]     if (ann != null) { [EOL]         return ann.value(); [EOL]     } [EOL]     JsonProperty pann = am.getAnnotation(JsonProperty.class); [EOL]     if (pann != null) { [EOL]         return pann.value(); [EOL]     } [EOL]     if (am.hasAnnotation(JsonDeserialize.class) || am.hasAnnotation(JsonView.class) || am.hasAnnotation(JsonBackReference.class) || am.hasAnnotation(JsonManagedReference.class)) { [EOL]         return ""; [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public String findDeserializationName(AnnotatedField af) { [EOL]     JsonProperty pann = af.getAnnotation(JsonProperty.class); [EOL]     if (pann != null) { [EOL]         return pann.value(); [EOL]     } [EOL]     if (af.hasAnnotation(JsonDeserialize.class) || af.hasAnnotation(JsonView.class) || af.hasAnnotation(JsonBackReference.class) || af.hasAnnotation(JsonManagedReference.class)) { [EOL]         return ""; [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public String findDeserializationName(AnnotatedField af) { [EOL]     JsonProperty pann = af.getAnnotation(JsonProperty.class); [EOL]     if (pann != null) { [EOL]         return pann.value(); [EOL]     } [EOL]     if (af.hasAnnotation(JsonDeserialize.class) || af.hasAnnotation(JsonView.class) || af.hasAnnotation(JsonBackReference.class) || af.hasAnnotation(JsonManagedReference.class)) { [EOL]         return ""; [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public String findDeserializationName(AnnotatedField af) { [EOL]     JsonProperty pann = af.getAnnotation(JsonProperty.class); [EOL]     if (pann != null) { [EOL]         return pann.value(); [EOL]     } [EOL]     if (af.hasAnnotation(JsonDeserialize.class) || af.hasAnnotation(JsonView.class) || af.hasAnnotation(JsonBackReference.class) || af.hasAnnotation(JsonManagedReference.class)) { [EOL]         return ""; [EOL]     } [EOL]     return null; [EOL] }
protected DeserializationContext(DeserializationContext src, DeserializationConfig config, JsonParser jp, InjectableValues injectableValues) { [EOL]     _cache = src._cache; [EOL]     _factory = src._factory; [EOL]     _config = config; [EOL]     _featureFlags = config.getDeserializationFeatures(); [EOL]     _view = config.getActiveView(); [EOL]     _parser = jp; [EOL]     _injectableValues = injectableValues; [EOL] }
@Override [EOL] public DeserializationConfig getConfig() { [EOL]     return _config; [EOL] }
@Override [EOL] public final AnnotationIntrospector getAnnotationIntrospector() { [EOL]     return _config.getAnnotationIntrospector(); [EOL] }
public final JsonParser getParser() { [EOL]     return _parser; [EOL] }
public final Object findInjectableValue(Object valueId, BeanProperty forProperty, Object beanInstance) { [EOL]     if (_injectableValues == null) { [EOL]         throw new IllegalStateException("No 'injectableValues' configured, can not inject value with id [" + valueId + "]"); [EOL]     } [EOL]     return _injectableValues.findInjectableValue(valueId, this, forProperty, beanInstance); [EOL] }
public final Object findInjectableValue(Object valueId, BeanProperty forProperty, Object beanInstance) { [EOL]     if (_injectableValues == null) { [EOL]         throw new IllegalStateException("No 'injectableValues' configured, can not inject value with id [" + valueId + "]"); [EOL]     } [EOL]     return _injectableValues.findInjectableValue(valueId, this, forProperty, beanInstance); [EOL] }
public final Base64Variant getBase64Variant() { [EOL]     return _config.getBase64Variant(); [EOL] }
@SuppressWarnings("unchecked") [EOL] public final JsonDeserializer<Object> findRootValueDeserializer(JavaType type) throws JsonMappingException { [EOL]     JsonDeserializer<Object> deser = _cache.findValueDeserializer(this, _factory, type); [EOL]     if (deser == null) { [EOL]         return null; [EOL]     } [EOL]     if (deser instanceof ContextualDeserializer) { [EOL]         deser = (JsonDeserializer<Object>) ((ContextualDeserializer) deser).createContextual(this, null); [EOL]     } [EOL]     TypeDeserializer typeDeser = _factory.findTypeDeserializer(_config, type); [EOL]     if (typeDeser != null) { [EOL]         typeDeser = typeDeser.forProperty(null); [EOL]         return new TypeWrappedDeserializer(typeDeser, deser); [EOL]     } [EOL]     return deser; [EOL] }
@SuppressWarnings("unchecked") [EOL] public final JsonDeserializer<Object> findRootValueDeserializer(JavaType type) throws JsonMappingException { [EOL]     JsonDeserializer<Object> deser = _cache.findValueDeserializer(this, _factory, type); [EOL]     if (deser == null) { [EOL]         return null; [EOL]     } [EOL]     if (deser instanceof ContextualDeserializer) { [EOL]         deser = (JsonDeserializer<Object>) ((ContextualDeserializer) deser).createContextual(this, null); [EOL]     } [EOL]     TypeDeserializer typeDeser = _factory.findTypeDeserializer(_config, type); [EOL]     if (typeDeser != null) { [EOL]         typeDeser = typeDeser.forProperty(null); [EOL]         return new TypeWrappedDeserializer(typeDeser, deser); [EOL]     } [EOL]     return deser; [EOL] }
@SuppressWarnings("unchecked") [EOL] public final JsonDeserializer<Object> findRootValueDeserializer(JavaType type) throws JsonMappingException { [EOL]     JsonDeserializer<Object> deser = _cache.findValueDeserializer(this, _factory, type); [EOL]     if (deser == null) { [EOL]         return null; [EOL]     } [EOL]     if (deser instanceof ContextualDeserializer) { [EOL]         deser = (JsonDeserializer<Object>) ((ContextualDeserializer) deser).createContextual(this, null); [EOL]     } [EOL]     TypeDeserializer typeDeser = _factory.findTypeDeserializer(_config, type); [EOL]     if (typeDeser != null) { [EOL]         typeDeser = typeDeser.forProperty(null); [EOL]         return new TypeWrappedDeserializer(typeDeser, deser); [EOL]     } [EOL]     return deser; [EOL] }
public JsonMappingException mappingException(Class<?> targetClass) { [EOL]     return mappingException(targetClass, _parser.getCurrentToken()); [EOL] }
public JsonMappingException mappingException(Class<?> targetClass, JsonToken token) { [EOL]     String clsName = _calcName(targetClass); [EOL]     return JsonMappingException.from(_parser, "Can not deserialize instance of " + clsName + " out of " + token + " token"); [EOL] }
public JsonMappingException mappingException(Class<?> targetClass, JsonToken token) { [EOL]     String clsName = _calcName(targetClass); [EOL]     return JsonMappingException.from(_parser, "Can not deserialize instance of " + clsName + " out of " + token + " token"); [EOL] }
public JsonMappingException mappingException(Class<?> targetClass, JsonToken token) { [EOL]     String clsName = _calcName(targetClass); [EOL]     return JsonMappingException.from(_parser, "Can not deserialize instance of " + clsName + " out of " + token + " token"); [EOL] }
public JsonMappingException mappingException(Class<?> targetClass, JsonToken token) { [EOL]     String clsName = _calcName(targetClass); [EOL]     return JsonMappingException.from(_parser, "Can not deserialize instance of " + clsName + " out of " + token + " token"); [EOL] }
public JsonMappingException mappingException(String message) { [EOL]     return JsonMappingException.from(getParser(), message); [EOL] }
public JsonMappingException mappingException(String message) { [EOL]     return JsonMappingException.from(getParser(), message); [EOL] }
public JsonMappingException mappingException(String message) { [EOL]     return JsonMappingException.from(getParser(), message); [EOL] }
protected String _calcName(Class<?> cls) { [EOL]     if (cls.isArray()) { [EOL]         return _calcName(cls.getComponentType()) + "[]"; [EOL]     } [EOL]     return cls.getName(); [EOL] }
protected String _calcName(Class<?> cls) { [EOL]     if (cls.isArray()) { [EOL]         return _calcName(cls.getComponentType()) + "[]"; [EOL]     } [EOL]     return cls.getName(); [EOL] }
protected DefaultDeserializationContext(DefaultDeserializationContext src, DeserializationConfig config, JsonParser jp, InjectableValues values) { [EOL]     super(src, config, jp, values); [EOL] }
@Override [EOL] public ReadableObjectId findObjectId(Object id, ObjectIdGenerator<?> generator) { [EOL]     final ObjectIdGenerator.IdKey key = generator.key(id); [EOL]     if (_objectIds == null) { [EOL]         _objectIds = new LinkedHashMap<ObjectIdGenerator.IdKey, ReadableObjectId>(); [EOL]     } else { [EOL]         ReadableObjectId entry = _objectIds.get(key); [EOL]         if (entry != null) { [EOL]             return entry; [EOL]         } [EOL]     } [EOL]     ReadableObjectId entry = new ReadableObjectId(id); [EOL]     _objectIds.put(key, entry); [EOL]     return entry; [EOL] }
@Override [EOL] public ReadableObjectId findObjectId(Object id, ObjectIdGenerator<?> generator) { [EOL]     final ObjectIdGenerator.IdKey key = generator.key(id); [EOL]     if (_objectIds == null) { [EOL]         _objectIds = new LinkedHashMap<ObjectIdGenerator.IdKey, ReadableObjectId>(); [EOL]     } else { [EOL]         ReadableObjectId entry = _objectIds.get(key); [EOL]         if (entry != null) { [EOL]             return entry; [EOL]         } [EOL]     } [EOL]     ReadableObjectId entry = new ReadableObjectId(id); [EOL]     _objectIds.put(key, entry); [EOL]     return entry; [EOL] }
protected Impl(Impl src, DeserializationConfig config, JsonParser jp, InjectableValues values) { [EOL]     super(src, config, jp, values); [EOL] }
@Override [EOL] public DefaultDeserializationContext createInstance(DeserializationConfig config, JsonParser jp, InjectableValues values) { [EOL]     return new Impl(this, config, jp, values); [EOL] }
@Override [EOL] public DefaultDeserializationContext createInstance(DeserializationConfig config, JsonParser jp, InjectableValues values) { [EOL]     return new Impl(this, config, jp, values); [EOL] }
protected PropertyBasedCreator(ValueInstantiator valueInstantiator, SettableBeanProperty[] creatorProps, Object[] defaultValues) { [EOL]     _valueInstantiator = valueInstantiator; [EOL]     _properties = new HashMap<String, SettableBeanProperty>(); [EOL]     SettableBeanProperty[] propertiesWithInjectables = null; [EOL]     final int len = creatorProps.length; [EOL]     _propertyCount = len; [EOL]     for (int i = 0; i < len; ++i) { [EOL]         SettableBeanProperty prop = creatorProps[i]; [EOL]         _properties.put(prop.getName(), prop); [EOL]         Object injectableValueId = prop.getInjectableValueId(); [EOL]         if (injectableValueId != null) { [EOL]             if (propertiesWithInjectables == null) { [EOL]                 propertiesWithInjectables = new SettableBeanProperty[len]; [EOL]             } [EOL]             propertiesWithInjectables[i] = prop; [EOL]         } [EOL]     } [EOL]     _defaultValues = defaultValues; [EOL]     _propertiesWithInjectables = propertiesWithInjectables; [EOL] }
protected PropertyBasedCreator(ValueInstantiator valueInstantiator, SettableBeanProperty[] creatorProps, Object[] defaultValues) { [EOL]     _valueInstantiator = valueInstantiator; [EOL]     _properties = new HashMap<String, SettableBeanProperty>(); [EOL]     SettableBeanProperty[] propertiesWithInjectables = null; [EOL]     final int len = creatorProps.length; [EOL]     _propertyCount = len; [EOL]     for (int i = 0; i < len; ++i) { [EOL]         SettableBeanProperty prop = creatorProps[i]; [EOL]         _properties.put(prop.getName(), prop); [EOL]         Object injectableValueId = prop.getInjectableValueId(); [EOL]         if (injectableValueId != null) { [EOL]             if (propertiesWithInjectables == null) { [EOL]                 propertiesWithInjectables = new SettableBeanProperty[len]; [EOL]             } [EOL]             propertiesWithInjectables[i] = prop; [EOL]         } [EOL]     } [EOL]     _defaultValues = defaultValues; [EOL]     _propertiesWithInjectables = propertiesWithInjectables; [EOL] }
protected PropertyBasedCreator(ValueInstantiator valueInstantiator, SettableBeanProperty[] creatorProps, Object[] defaultValues) { [EOL]     _valueInstantiator = valueInstantiator; [EOL]     _properties = new HashMap<String, SettableBeanProperty>(); [EOL]     SettableBeanProperty[] propertiesWithInjectables = null; [EOL]     final int len = creatorProps.length; [EOL]     _propertyCount = len; [EOL]     for (int i = 0; i < len; ++i) { [EOL]         SettableBeanProperty prop = creatorProps[i]; [EOL]         _properties.put(prop.getName(), prop); [EOL]         Object injectableValueId = prop.getInjectableValueId(); [EOL]         if (injectableValueId != null) { [EOL]             if (propertiesWithInjectables == null) { [EOL]                 propertiesWithInjectables = new SettableBeanProperty[len]; [EOL]             } [EOL]             propertiesWithInjectables[i] = prop; [EOL]         } [EOL]     } [EOL]     _defaultValues = defaultValues; [EOL]     _propertiesWithInjectables = propertiesWithInjectables; [EOL] }
public PropertyValueBuffer startBuilding(JsonParser jp, DeserializationContext ctxt, ObjectIdReader oir) { [EOL]     PropertyValueBuffer buffer = new PropertyValueBuffer(jp, ctxt, _propertyCount, oir); [EOL]     if (_propertiesWithInjectables != null) { [EOL]         buffer.inject(_propertiesWithInjectables); [EOL]     } [EOL]     return buffer; [EOL] }
public PropertyValueBuffer startBuilding(JsonParser jp, DeserializationContext ctxt, ObjectIdReader oir) { [EOL]     PropertyValueBuffer buffer = new PropertyValueBuffer(jp, ctxt, _propertyCount, oir); [EOL]     if (_propertiesWithInjectables != null) { [EOL]         buffer.inject(_propertiesWithInjectables); [EOL]     } [EOL]     return buffer; [EOL] }
public Std() { [EOL]     this(new HashMap<String, Object>()); [EOL] }
public Std(Map<String, Object> values) { [EOL]     _values = values; [EOL] }
public Std(Map<String, Object> values) { [EOL]     _values = values; [EOL] }
public Std(Map<String, Object> values) { [EOL]     _values = values; [EOL] }
public Std addValue(String key, Object value) { [EOL]     _values.put(key, value); [EOL]     return this; [EOL] }
public Std addValue(String key, Object value) { [EOL]     _values.put(key, value); [EOL]     return this; [EOL] }
public Std addValue(String key, Object value) { [EOL]     _values.put(key, value); [EOL]     return this; [EOL] }
public Std addValue(Class<?> classKey, Object value) { [EOL]     _values.put(classKey.getName(), value); [EOL]     return this; [EOL] }
public Std addValue(Class<?> classKey, Object value) { [EOL]     _values.put(classKey.getName(), value); [EOL]     return this; [EOL] }
public Std addValue(Class<?> classKey, Object value) { [EOL]     _values.put(classKey.getName(), value); [EOL]     return this; [EOL] }
@Override [EOL] public Object findInjectableValue(Object valueId, DeserializationContext ctxt, BeanProperty forProperty, Object beanInstance) { [EOL]     if (!(valueId instanceof String)) { [EOL]         String type = (valueId == null) ? "[null]" : valueId.getClass().getName(); [EOL]         throw new IllegalArgumentException("Unrecognized inject value id type (" + type + "), expecting String"); [EOL]     } [EOL]     String key = (String) valueId; [EOL]     Object ob = _values.get(key); [EOL]     if (ob == null && !_values.containsKey(key)) { [EOL]         throw new IllegalArgumentException("No injectable id with value '" + key + "' found (for property '" + forProperty.getName() + "')"); [EOL]     } [EOL]     return ob; [EOL] }
@Override [EOL] public Object findInjectableValue(Object valueId, DeserializationContext ctxt, BeanProperty forProperty, Object beanInstance) { [EOL]     if (!(valueId instanceof String)) { [EOL]         String type = (valueId == null) ? "[null]" : valueId.getClass().getName(); [EOL]         throw new IllegalArgumentException("Unrecognized inject value id type (" + type + "), expecting String"); [EOL]     } [EOL]     String key = (String) valueId; [EOL]     Object ob = _values.get(key); [EOL]     if (ob == null && !_values.containsKey(key)) { [EOL]         throw new IllegalArgumentException("No injectable id with value '" + key + "' found (for property '" + forProperty.getName() + "')"); [EOL]     } [EOL]     return ob; [EOL] }
@Override [EOL] public Object findInjectableValue(Object valueId, DeserializationContext ctxt, BeanProperty forProperty, Object beanInstance) { [EOL]     if (!(valueId instanceof String)) { [EOL]         String type = (valueId == null) ? "[null]" : valueId.getClass().getName(); [EOL]         throw new IllegalArgumentException("Unrecognized inject value id type (" + type + "), expecting String"); [EOL]     } [EOL]     String key = (String) valueId; [EOL]     Object ob = _values.get(key); [EOL]     if (ob == null && !_values.containsKey(key)) { [EOL]         throw new IllegalArgumentException("No injectable id with value '" + key + "' found (for property '" + forProperty.getName() + "')"); [EOL]     } [EOL]     return ob; [EOL] }
@Override [EOL] public Object findInjectableValue(Object valueId, DeserializationContext ctxt, BeanProperty forProperty, Object beanInstance) { [EOL]     if (!(valueId instanceof String)) { [EOL]         String type = (valueId == null) ? "[null]" : valueId.getClass().getName(); [EOL]         throw new IllegalArgumentException("Unrecognized inject value id type (" + type + "), expecting String"); [EOL]     } [EOL]     String key = (String) valueId; [EOL]     Object ob = _values.get(key); [EOL]     if (ob == null && !_values.containsKey(key)) { [EOL]         throw new IllegalArgumentException("No injectable id with value '" + key + "' found (for property '" + forProperty.getName() + "')"); [EOL]     } [EOL]     return ob; [EOL] }
public boolean isIntegralNumber() { [EOL]     return false; [EOL] }
public boolean isInt() { [EOL]     return false; [EOL] }
public final boolean isBoolean() { [EOL]     return getNodeType() == JsonNodeType.BOOLEAN; [EOL] }
public final boolean isBoolean() { [EOL]     return getNodeType() == JsonNodeType.BOOLEAN; [EOL] }
public boolean booleanValue() { [EOL]     return false; [EOL] }
public boolean has(int index) { [EOL]     return get(index) != null; [EOL] }
public boolean has(int index) { [EOL]     return get(index) != null; [EOL] }
public boolean has(int index) { [EOL]     return get(index) != null; [EOL] }
public boolean hasNonNull(String fieldName) { [EOL]     JsonNode n = get(fieldName); [EOL]     return (n != null) && !n.isNull(); [EOL] }
public boolean hasNonNull(String fieldName) { [EOL]     JsonNode n = get(fieldName); [EOL]     return (n != null) && !n.isNull(); [EOL] }
public boolean hasNonNull(String fieldName) { [EOL]     JsonNode n = get(fieldName); [EOL]     return (n != null) && !n.isNull(); [EOL] }
public boolean hasNonNull(int index) { [EOL]     JsonNode n = get(index); [EOL]     return (n != null) && !n.isNull(); [EOL] }
public boolean hasNonNull(int index) { [EOL]     JsonNode n = get(index); [EOL]     return (n != null) && !n.isNull(); [EOL] }
public boolean hasNonNull(int index) { [EOL]     JsonNode n = get(index); [EOL]     return (n != null) && !n.isNull(); [EOL] }
public boolean hasNonNull(int index) { [EOL]     JsonNode n = get(index); [EOL]     return (n != null) && !n.isNull(); [EOL] }
public JsonNode with(String propertyName) { [EOL]     throw new UnsupportedOperationException("JsonNode not of type ObjectNode (but " + getClass().getName() + "), can not call with() on it"); [EOL] }
public JsonNode withArray(String propertyName) { [EOL]     throw new UnsupportedOperationException("JsonNode not of type ObjectNode (but " + getClass().getName() + "), can not call withArray() on it"); [EOL] }
private static void _addSuperTypes(Class<?> cls, Class<?> endBefore, Collection<Class<?>> result, boolean addClassItself) { [EOL]     if (cls == endBefore || cls == null || cls == Object.class) { [EOL]         return; [EOL]     } [EOL]     if (addClassItself) { [EOL]         if (result.contains(cls)) { [EOL]             return; [EOL]         } [EOL]         result.add(cls); [EOL]     } [EOL]     for (Class<?> intCls : cls.getInterfaces()) { [EOL]         _addSuperTypes(intCls, endBefore, result, true); [EOL]     } [EOL]     _addSuperTypes(cls.getSuperclass(), endBefore, result, true); [EOL] }
private static void _addSuperTypes(Class<?> cls, Class<?> endBefore, Collection<Class<?>> result, boolean addClassItself) { [EOL]     if (cls == endBefore || cls == null || cls == Object.class) { [EOL]         return; [EOL]     } [EOL]     if (addClassItself) { [EOL]         if (result.contains(cls)) { [EOL]             return; [EOL]         } [EOL]         result.add(cls); [EOL]     } [EOL]     for (Class<?> intCls : cls.getInterfaces()) { [EOL]         _addSuperTypes(intCls, endBefore, result, true); [EOL]     } [EOL]     _addSuperTypes(cls.getSuperclass(), endBefore, result, true); [EOL] }
private static void _addSuperTypes(Class<?> cls, Class<?> endBefore, Collection<Class<?>> result, boolean addClassItself) { [EOL]     if (cls == endBefore || cls == null || cls == Object.class) { [EOL]         return; [EOL]     } [EOL]     if (addClassItself) { [EOL]         if (result.contains(cls)) { [EOL]             return; [EOL]         } [EOL]         result.add(cls); [EOL]     } [EOL]     for (Class<?> intCls : cls.getInterfaces()) { [EOL]         _addSuperTypes(intCls, endBefore, result, true); [EOL]     } [EOL]     _addSuperTypes(cls.getSuperclass(), endBefore, result, true); [EOL] }
private static void _addSuperTypes(Class<?> cls, Class<?> endBefore, Collection<Class<?>> result, boolean addClassItself) { [EOL]     if (cls == endBefore || cls == null || cls == Object.class) { [EOL]         return; [EOL]     } [EOL]     if (addClassItself) { [EOL]         if (result.contains(cls)) { [EOL]             return; [EOL]         } [EOL]         result.add(cls); [EOL]     } [EOL]     for (Class<?> intCls : cls.getInterfaces()) { [EOL]         _addSuperTypes(intCls, endBefore, result, true); [EOL]     } [EOL]     _addSuperTypes(cls.getSuperclass(), endBefore, result, true); [EOL] }
private static void _addSuperTypes(Class<?> cls, Class<?> endBefore, Collection<Class<?>> result, boolean addClassItself) { [EOL]     if (cls == endBefore || cls == null || cls == Object.class) { [EOL]         return; [EOL]     } [EOL]     if (addClassItself) { [EOL]         if (result.contains(cls)) { [EOL]             return; [EOL]         } [EOL]         result.add(cls); [EOL]     } [EOL]     for (Class<?> intCls : cls.getInterfaces()) { [EOL]         _addSuperTypes(intCls, endBefore, result, true); [EOL]     } [EOL]     _addSuperTypes(cls.getSuperclass(), endBefore, result, true); [EOL] }
private static void _addSuperTypes(Class<?> cls, Class<?> endBefore, Collection<Class<?>> result, boolean addClassItself) { [EOL]     if (cls == endBefore || cls == null || cls == Object.class) { [EOL]         return; [EOL]     } [EOL]     if (addClassItself) { [EOL]         if (result.contains(cls)) { [EOL]             return; [EOL]         } [EOL]         result.add(cls); [EOL]     } [EOL]     for (Class<?> intCls : cls.getInterfaces()) { [EOL]         _addSuperTypes(intCls, endBefore, result, true); [EOL]     } [EOL]     _addSuperTypes(cls.getSuperclass(), endBefore, result, true); [EOL] }
private static void _addSuperTypes(Class<?> cls, Class<?> endBefore, Collection<Class<?>> result, boolean addClassItself) { [EOL]     if (cls == endBefore || cls == null || cls == Object.class) { [EOL]         return; [EOL]     } [EOL]     if (addClassItself) { [EOL]         if (result.contains(cls)) { [EOL]             return; [EOL]         } [EOL]         result.add(cls); [EOL]     } [EOL]     for (Class<?> intCls : cls.getInterfaces()) { [EOL]         _addSuperTypes(intCls, endBefore, result, true); [EOL]     } [EOL]     _addSuperTypes(cls.getSuperclass(), endBefore, result, true); [EOL] }
public static Class<?> getOuterClass(Class<?> type) { [EOL]     try { [EOL]         if (type.getEnclosingMethod() != null) { [EOL]             return null; [EOL]         } [EOL]         if (!Modifier.isStatic(type.getModifiers())) { [EOL]             return type.getEnclosingClass(); [EOL]         } [EOL]     } catch (SecurityException e) { [EOL]     } catch (NullPointerException e) { [EOL]     } [EOL]     return null; [EOL] }
public static Class<?> getOuterClass(Class<?> type) { [EOL]     try { [EOL]         if (type.getEnclosingMethod() != null) { [EOL]             return null; [EOL]         } [EOL]         if (!Modifier.isStatic(type.getModifiers())) { [EOL]             return type.getEnclosingClass(); [EOL]         } [EOL]     } catch (SecurityException e) { [EOL]     } catch (NullPointerException e) { [EOL]     } [EOL]     return null; [EOL] }
public static Class<?> getOuterClass(Class<?> type) { [EOL]     try { [EOL]         if (type.getEnclosingMethod() != null) { [EOL]             return null; [EOL]         } [EOL]         if (!Modifier.isStatic(type.getModifiers())) { [EOL]             return type.getEnclosingClass(); [EOL]         } [EOL]     } catch (SecurityException e) { [EOL]     } catch (NullPointerException e) { [EOL]     } [EOL]     return null; [EOL] }
public static Class<?> getOuterClass(Class<?> type) { [EOL]     try { [EOL]         if (type.getEnclosingMethod() != null) { [EOL]             return null; [EOL]         } [EOL]         if (!Modifier.isStatic(type.getModifiers())) { [EOL]             return type.getEnclosingClass(); [EOL]         } [EOL]     } catch (SecurityException e) { [EOL]     } catch (NullPointerException e) { [EOL]     } [EOL]     return null; [EOL] }
public static Class<?> getOuterClass(Class<?> type) { [EOL]     try { [EOL]         if (type.getEnclosingMethod() != null) { [EOL]             return null; [EOL]         } [EOL]         if (!Modifier.isStatic(type.getModifiers())) { [EOL]             return type.getEnclosingClass(); [EOL]         } [EOL]     } catch (SecurityException e) { [EOL]     } catch (NullPointerException e) { [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public JavaType narrowContentsBy(Class<?> contentClass) { [EOL]     if (contentClass == _elementType.getRawClass()) { [EOL]         return this; [EOL]     } [EOL]     return new CollectionType(_class, _elementType.narrowBy(contentClass), _valueHandler, _typeHandler, _asStatic); [EOL] }
@Override [EOL] public JavaType narrowContentsBy(Class<?> contentClass) { [EOL]     if (contentClass == _elementType.getRawClass()) { [EOL]         return this; [EOL]     } [EOL]     return new CollectionType(_class, _elementType.narrowBy(contentClass), _valueHandler, _typeHandler, _asStatic); [EOL] }
@Override [EOL] public CollectionType withContentValueHandler(Object h) { [EOL]     return new CollectionType(_class, _elementType.withValueHandler(h), _valueHandler, _typeHandler, _asStatic); [EOL] }
@Override [EOL] public CollectionType withContentValueHandler(Object h) { [EOL]     return new CollectionType(_class, _elementType.withValueHandler(h), _valueHandler, _typeHandler, _asStatic); [EOL] }
@Override [EOL] public CollectionType withStaticTyping() { [EOL]     if (_asStatic) { [EOL]         return this; [EOL]     } [EOL]     return new CollectionType(_class, _elementType.withStaticTyping(), _valueHandler, _typeHandler, true); [EOL] }
@Override [EOL] public CollectionType withStaticTyping() { [EOL]     if (_asStatic) { [EOL]         return this; [EOL]     } [EOL]     return new CollectionType(_class, _elementType.withStaticTyping(), _valueHandler, _typeHandler, true); [EOL] }
public AnnotationIntrospector.ReferenceProperty findReferenceType() { [EOL]     return null; [EOL] }
public boolean isRequired() { [EOL]     return false; [EOL] }
public EnumMapSerializer(JavaType valueType, boolean staticTyping, EnumValues keyEnums, TypeSerializer vts, JsonSerializer<Object> valueSerializer) { [EOL]     super(EnumMap.class, false); [EOL]     _property = null; [EOL]     _staticTyping = staticTyping || (valueType != null && valueType.isFinal()); [EOL]     _valueType = valueType; [EOL]     _keyEnums = keyEnums; [EOL]     _valueTypeSerializer = vts; [EOL]     _valueSerializer = valueSerializer; [EOL] }
public EnumMapSerializer(JavaType valueType, boolean staticTyping, EnumValues keyEnums, TypeSerializer vts, JsonSerializer<Object> valueSerializer) { [EOL]     super(EnumMap.class, false); [EOL]     _property = null; [EOL]     _staticTyping = staticTyping || (valueType != null && valueType.isFinal()); [EOL]     _valueType = valueType; [EOL]     _keyEnums = keyEnums; [EOL]     _valueTypeSerializer = vts; [EOL]     _valueSerializer = valueSerializer; [EOL] }
public EnumMapSerializer(JavaType valueType, boolean staticTyping, EnumValues keyEnums, TypeSerializer vts, JsonSerializer<Object> valueSerializer) { [EOL]     super(EnumMap.class, false); [EOL]     _property = null; [EOL]     _staticTyping = staticTyping || (valueType != null && valueType.isFinal()); [EOL]     _valueType = valueType; [EOL]     _keyEnums = keyEnums; [EOL]     _valueTypeSerializer = vts; [EOL]     _valueSerializer = valueSerializer; [EOL] }
@SuppressWarnings("unchecked") [EOL] public EnumMapSerializer(EnumMapSerializer src, BeanProperty property, JsonSerializer<?> ser) { [EOL]     super(src); [EOL]     _property = property; [EOL]     _staticTyping = src._staticTyping; [EOL]     _valueType = src._valueType; [EOL]     _keyEnums = src._keyEnums; [EOL]     _valueTypeSerializer = src._valueTypeSerializer; [EOL]     _valueSerializer = (JsonSerializer<Object>) ser; [EOL] }
public EnumMapSerializer withValueSerializer(BeanProperty prop, JsonSerializer<?> ser) { [EOL]     if (_property == prop && ser == _valueSerializer) { [EOL]         return this; [EOL]     } [EOL]     return new EnumMapSerializer(this, prop, ser); [EOL] }
public EnumMapSerializer withValueSerializer(BeanProperty prop, JsonSerializer<?> ser) { [EOL]     if (_property == prop && ser == _valueSerializer) { [EOL]         return this; [EOL]     } [EOL]     return new EnumMapSerializer(this, prop, ser); [EOL] }
public EnumMapSerializer withValueSerializer(BeanProperty prop, JsonSerializer<?> ser) { [EOL]     if (_property == prop && ser == _valueSerializer) { [EOL]         return this; [EOL]     } [EOL]     return new EnumMapSerializer(this, prop, ser); [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     JsonSerializer<?> ser = null; [EOL]     if (property != null) { [EOL]         AnnotatedMember m = property.getMember(); [EOL]         if (m != null) { [EOL]             Object serDef = provider.getAnnotationIntrospector().findContentSerializer(m); [EOL]             if (serDef != null) { [EOL]                 ser = provider.serializerInstance(m, serDef); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         ser = _valueSerializer; [EOL]     } [EOL]     ser = findConvertingContentSerializer(provider, property, ser); [EOL]     if (ser == null) { [EOL]         if (_staticTyping) { [EOL]             return withValueSerializer(property, provider.findValueSerializer(_valueType, property)); [EOL]         } [EOL]     } else if (_valueSerializer instanceof ContextualSerializer) { [EOL]         ser = ((ContextualSerializer) ser).createContextual(provider, property); [EOL]     } [EOL]     if (ser != _valueSerializer) { [EOL]         return withValueSerializer(property, ser); [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     JsonSerializer<?> ser = null; [EOL]     if (property != null) { [EOL]         AnnotatedMember m = property.getMember(); [EOL]         if (m != null) { [EOL]             Object serDef = provider.getAnnotationIntrospector().findContentSerializer(m); [EOL]             if (serDef != null) { [EOL]                 ser = provider.serializerInstance(m, serDef); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         ser = _valueSerializer; [EOL]     } [EOL]     ser = findConvertingContentSerializer(provider, property, ser); [EOL]     if (ser == null) { [EOL]         if (_staticTyping) { [EOL]             return withValueSerializer(property, provider.findValueSerializer(_valueType, property)); [EOL]         } [EOL]     } else if (_valueSerializer instanceof ContextualSerializer) { [EOL]         ser = ((ContextualSerializer) ser).createContextual(provider, property); [EOL]     } [EOL]     if (ser != _valueSerializer) { [EOL]         return withValueSerializer(property, ser); [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     JsonSerializer<?> ser = null; [EOL]     if (property != null) { [EOL]         AnnotatedMember m = property.getMember(); [EOL]         if (m != null) { [EOL]             Object serDef = provider.getAnnotationIntrospector().findContentSerializer(m); [EOL]             if (serDef != null) { [EOL]                 ser = provider.serializerInstance(m, serDef); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         ser = _valueSerializer; [EOL]     } [EOL]     ser = findConvertingContentSerializer(provider, property, ser); [EOL]     if (ser == null) { [EOL]         if (_staticTyping) { [EOL]             return withValueSerializer(property, provider.findValueSerializer(_valueType, property)); [EOL]         } [EOL]     } else if (_valueSerializer instanceof ContextualSerializer) { [EOL]         ser = ((ContextualSerializer) ser).createContextual(provider, property); [EOL]     } [EOL]     if (ser != _valueSerializer) { [EOL]         return withValueSerializer(property, ser); [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     JsonSerializer<?> ser = null; [EOL]     if (property != null) { [EOL]         AnnotatedMember m = property.getMember(); [EOL]         if (m != null) { [EOL]             Object serDef = provider.getAnnotationIntrospector().findContentSerializer(m); [EOL]             if (serDef != null) { [EOL]                 ser = provider.serializerInstance(m, serDef); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         ser = _valueSerializer; [EOL]     } [EOL]     ser = findConvertingContentSerializer(provider, property, ser); [EOL]     if (ser == null) { [EOL]         if (_staticTyping) { [EOL]             return withValueSerializer(property, provider.findValueSerializer(_valueType, property)); [EOL]         } [EOL]     } else if (_valueSerializer instanceof ContextualSerializer) { [EOL]         ser = ((ContextualSerializer) ser).createContextual(provider, property); [EOL]     } [EOL]     if (ser != _valueSerializer) { [EOL]         return withValueSerializer(property, ser); [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     JsonSerializer<?> ser = null; [EOL]     if (property != null) { [EOL]         AnnotatedMember m = property.getMember(); [EOL]         if (m != null) { [EOL]             Object serDef = provider.getAnnotationIntrospector().findContentSerializer(m); [EOL]             if (serDef != null) { [EOL]                 ser = provider.serializerInstance(m, serDef); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         ser = _valueSerializer; [EOL]     } [EOL]     ser = findConvertingContentSerializer(provider, property, ser); [EOL]     if (ser == null) { [EOL]         if (_staticTyping) { [EOL]             return withValueSerializer(property, provider.findValueSerializer(_valueType, property)); [EOL]         } [EOL]     } else if (_valueSerializer instanceof ContextualSerializer) { [EOL]         ser = ((ContextualSerializer) ser).createContextual(provider, property); [EOL]     } [EOL]     if (ser != _valueSerializer) { [EOL]         return withValueSerializer(property, ser); [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public void serialize(EnumMap<? extends Enum<?>, ?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     jgen.writeStartObject(); [EOL]     if (!value.isEmpty()) { [EOL]         serializeContents(value, jgen, provider); [EOL]     } [EOL]     jgen.writeEndObject(); [EOL] }
@Override [EOL] public void serialize(EnumMap<? extends Enum<?>, ?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     jgen.writeStartObject(); [EOL]     if (!value.isEmpty()) { [EOL]         serializeContents(value, jgen, provider); [EOL]     } [EOL]     jgen.writeEndObject(); [EOL] }
protected void serializeContents(EnumMap<? extends Enum<?>, ?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (_valueSerializer != null) { [EOL]         serializeContentsUsing(value, jgen, provider, _valueSerializer); [EOL]         return; [EOL]     } [EOL]     JsonSerializer<Object> prevSerializer = null; [EOL]     Class<?> prevClass = null; [EOL]     EnumValues keyEnums = _keyEnums; [EOL]     final boolean skipNulls = !provider.isEnabled(SerializationFeature.WRITE_NULL_MAP_VALUES); [EOL]     final TypeSerializer vts = _valueTypeSerializer; [EOL]     for (Map.Entry<? extends Enum<?>, ?> entry : value.entrySet()) { [EOL]         final Object valueElem = entry.getValue(); [EOL]         if (skipNulls && valueElem == null) { [EOL]             continue; [EOL]         } [EOL]         Enum<?> key = entry.getKey(); [EOL]         if (keyEnums == null) { [EOL]             StdSerializer<?> ser = (StdSerializer<?>) provider.findValueSerializer(key.getDeclaringClass(), _property); [EOL]             keyEnums = ((EnumSerializer) ser).getEnumValues(); [EOL]         } [EOL]         jgen.writeFieldName(keyEnums.serializedValueFor(key)); [EOL]         if (valueElem == null) { [EOL]             provider.defaultSerializeNull(jgen); [EOL]             continue; [EOL]         } [EOL]         Class<?> cc = valueElem.getClass(); [EOL]         JsonSerializer<Object> currSerializer; [EOL]         if (cc == prevClass) { [EOL]             currSerializer = prevSerializer; [EOL]         } else { [EOL]             currSerializer = provider.findValueSerializer(cc, _property); [EOL]             prevSerializer = currSerializer; [EOL]             prevClass = cc; [EOL]         } [EOL]         try { [EOL]             if (vts == null) { [EOL]                 currSerializer.serialize(valueElem, jgen, provider); [EOL]             } else { [EOL]                 currSerializer.serializeWithType(valueElem, jgen, provider, vts); [EOL]             } [EOL]         } catch (Exception e) { [EOL]             wrapAndThrow(provider, e, value, entry.getKey().name()); [EOL]         } [EOL]     } [EOL] }
public SerializerFactoryConfig withAdditionalKeySerializers(Serializers additional) { [EOL]     if (additional == null) { [EOL]         throw new IllegalArgumentException("Can not pass null Serializers"); [EOL]     } [EOL]     Serializers[] all = ArrayBuilders.insertInListNoDup(_additionalKeySerializers, additional); [EOL]     return new SerializerFactoryConfig(_additionalSerializers, all, _modifiers); [EOL] }
public SerializerFactoryConfig withAdditionalKeySerializers(Serializers additional) { [EOL]     if (additional == null) { [EOL]         throw new IllegalArgumentException("Can not pass null Serializers"); [EOL]     } [EOL]     Serializers[] all = ArrayBuilders.insertInListNoDup(_additionalKeySerializers, additional); [EOL]     return new SerializerFactoryConfig(_additionalSerializers, all, _modifiers); [EOL] }
public Iterable<Serializers> keySerializers() { [EOL]     return ArrayBuilders.arrayAsIterable(_additionalKeySerializers); [EOL] }
public Iterable<Serializers> keySerializers() { [EOL]     return ArrayBuilders.arrayAsIterable(_additionalKeySerializers); [EOL] }
@Override [EOL] public JsonSerializer<?> findSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc) { [EOL]     Class<?> cls = type.getRawClass(); [EOL]     ClassKey key = new ClassKey(cls); [EOL]     JsonSerializer<?> ser = null; [EOL]     if (cls.isInterface()) { [EOL]         if (_interfaceMappings != null) { [EOL]             ser = _interfaceMappings.get(key); [EOL]             if (ser != null) { [EOL]                 return ser; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (_classMappings != null) { [EOL]             ser = _classMappings.get(key); [EOL]             if (ser != null) { [EOL]                 return ser; [EOL]             } [EOL]             for (Class<?> curr = cls; (curr != null); curr = curr.getSuperclass()) { [EOL]                 key.reset(curr); [EOL]                 ser = _classMappings.get(key); [EOL]                 if (ser != null) { [EOL]                     return ser; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     if (_interfaceMappings != null) { [EOL]         ser = _findInterfaceMapping(cls, key); [EOL]         if (ser != null) { [EOL]             return ser; [EOL]         } [EOL]         if (!cls.isInterface()) { [EOL]             while ((cls = cls.getSuperclass()) != null) { [EOL]                 ser = _findInterfaceMapping(cls, key); [EOL]                 if (ser != null) { [EOL]                     return ser; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public JsonSerializer<?> findSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc) { [EOL]     Class<?> cls = type.getRawClass(); [EOL]     ClassKey key = new ClassKey(cls); [EOL]     JsonSerializer<?> ser = null; [EOL]     if (cls.isInterface()) { [EOL]         if (_interfaceMappings != null) { [EOL]             ser = _interfaceMappings.get(key); [EOL]             if (ser != null) { [EOL]                 return ser; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (_classMappings != null) { [EOL]             ser = _classMappings.get(key); [EOL]             if (ser != null) { [EOL]                 return ser; [EOL]             } [EOL]             for (Class<?> curr = cls; (curr != null); curr = curr.getSuperclass()) { [EOL]                 key.reset(curr); [EOL]                 ser = _classMappings.get(key); [EOL]                 if (ser != null) { [EOL]                     return ser; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     if (_interfaceMappings != null) { [EOL]         ser = _findInterfaceMapping(cls, key); [EOL]         if (ser != null) { [EOL]             return ser; [EOL]         } [EOL]         if (!cls.isInterface()) { [EOL]             while ((cls = cls.getSuperclass()) != null) { [EOL]                 ser = _findInterfaceMapping(cls, key); [EOL]                 if (ser != null) { [EOL]                     return ser; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public JsonSerializer<?> findSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc) { [EOL]     Class<?> cls = type.getRawClass(); [EOL]     ClassKey key = new ClassKey(cls); [EOL]     JsonSerializer<?> ser = null; [EOL]     if (cls.isInterface()) { [EOL]         if (_interfaceMappings != null) { [EOL]             ser = _interfaceMappings.get(key); [EOL]             if (ser != null) { [EOL]                 return ser; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (_classMappings != null) { [EOL]             ser = _classMappings.get(key); [EOL]             if (ser != null) { [EOL]                 return ser; [EOL]             } [EOL]             for (Class<?> curr = cls; (curr != null); curr = curr.getSuperclass()) { [EOL]                 key.reset(curr); [EOL]                 ser = _classMappings.get(key); [EOL]                 if (ser != null) { [EOL]                     return ser; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     if (_interfaceMappings != null) { [EOL]         ser = _findInterfaceMapping(cls, key); [EOL]         if (ser != null) { [EOL]             return ser; [EOL]         } [EOL]         if (!cls.isInterface()) { [EOL]             while ((cls = cls.getSuperclass()) != null) { [EOL]                 ser = _findInterfaceMapping(cls, key); [EOL]                 if (ser != null) { [EOL]                     return ser; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public JsonSerializer<?> findSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc) { [EOL]     Class<?> cls = type.getRawClass(); [EOL]     ClassKey key = new ClassKey(cls); [EOL]     JsonSerializer<?> ser = null; [EOL]     if (cls.isInterface()) { [EOL]         if (_interfaceMappings != null) { [EOL]             ser = _interfaceMappings.get(key); [EOL]             if (ser != null) { [EOL]                 return ser; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (_classMappings != null) { [EOL]             ser = _classMappings.get(key); [EOL]             if (ser != null) { [EOL]                 return ser; [EOL]             } [EOL]             for (Class<?> curr = cls; (curr != null); curr = curr.getSuperclass()) { [EOL]                 key.reset(curr); [EOL]                 ser = _classMappings.get(key); [EOL]                 if (ser != null) { [EOL]                     return ser; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     if (_interfaceMappings != null) { [EOL]         ser = _findInterfaceMapping(cls, key); [EOL]         if (ser != null) { [EOL]             return ser; [EOL]         } [EOL]         if (!cls.isInterface()) { [EOL]             while ((cls = cls.getSuperclass()) != null) { [EOL]                 ser = _findInterfaceMapping(cls, key); [EOL]                 if (ser != null) { [EOL]                     return ser; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
protected JsonSerializer<?> _findInterfaceMapping(Class<?> cls, ClassKey key) { [EOL]     for (Class<?> iface : cls.getInterfaces()) { [EOL]         key.reset(iface); [EOL]         JsonSerializer<?> ser = _interfaceMappings.get(key); [EOL]         if (ser != null) { [EOL]             return ser; [EOL]         } [EOL]         ser = _findInterfaceMapping(iface, key); [EOL]         if (ser != null) { [EOL]             return ser; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
protected JsonSerializer<?> _findInterfaceMapping(Class<?> cls, ClassKey key) { [EOL]     for (Class<?> iface : cls.getInterfaces()) { [EOL]         key.reset(iface); [EOL]         JsonSerializer<?> ser = _interfaceMappings.get(key); [EOL]         if (ser != null) { [EOL]             return ser; [EOL]         } [EOL]         ser = _findInterfaceMapping(iface, key); [EOL]         if (ser != null) { [EOL]             return ser; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
protected JsonSerializer<?> _findInterfaceMapping(Class<?> cls, ClassKey key) { [EOL]     for (Class<?> iface : cls.getInterfaces()) { [EOL]         key.reset(iface); [EOL]         JsonSerializer<?> ser = _interfaceMappings.get(key); [EOL]         if (ser != null) { [EOL]             return ser; [EOL]         } [EOL]         ser = _findInterfaceMapping(iface, key); [EOL]         if (ser != null) { [EOL]             return ser; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     TypeSerializer typeSer = _valueTypeSerializer; [EOL]     if (typeSer != null) { [EOL]         typeSer = typeSer.forProperty(property); [EOL]     } [EOL]     JsonSerializer<?> ser = null; [EOL]     if (property != null) { [EOL]         AnnotatedMember m = property.getMember(); [EOL]         if (m != null) { [EOL]             Object serDef = provider.getAnnotationIntrospector().findContentSerializer(m); [EOL]             if (serDef != null) { [EOL]                 ser = provider.serializerInstance(m, serDef); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         ser = _elementSerializer; [EOL]     } [EOL]     ser = findConvertingContentSerializer(provider, property, ser); [EOL]     if (ser == null) { [EOL]         if (ser == null) { [EOL]             if (_elementType != null) { [EOL]                 if (_staticTyping || hasContentTypeAnnotation(provider, property)) { [EOL]                     ser = provider.findValueSerializer(_elementType, property); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (ser instanceof ContextualSerializer) { [EOL]             ser = ((ContextualSerializer) ser).createContextual(provider, property); [EOL]         } [EOL]     } [EOL]     if ((ser != _elementSerializer) || (property != _property) || _valueTypeSerializer != typeSer) { [EOL]         return withResolved(property, typeSer, ser); [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     TypeSerializer typeSer = _valueTypeSerializer; [EOL]     if (typeSer != null) { [EOL]         typeSer = typeSer.forProperty(property); [EOL]     } [EOL]     JsonSerializer<?> ser = null; [EOL]     if (property != null) { [EOL]         AnnotatedMember m = property.getMember(); [EOL]         if (m != null) { [EOL]             Object serDef = provider.getAnnotationIntrospector().findContentSerializer(m); [EOL]             if (serDef != null) { [EOL]                 ser = provider.serializerInstance(m, serDef); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         ser = _elementSerializer; [EOL]     } [EOL]     ser = findConvertingContentSerializer(provider, property, ser); [EOL]     if (ser == null) { [EOL]         if (ser == null) { [EOL]             if (_elementType != null) { [EOL]                 if (_staticTyping || hasContentTypeAnnotation(provider, property)) { [EOL]                     ser = provider.findValueSerializer(_elementType, property); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (ser instanceof ContextualSerializer) { [EOL]             ser = ((ContextualSerializer) ser).createContextual(provider, property); [EOL]         } [EOL]     } [EOL]     if ((ser != _elementSerializer) || (property != _property) || _valueTypeSerializer != typeSer) { [EOL]         return withResolved(property, typeSer, ser); [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     TypeSerializer typeSer = _valueTypeSerializer; [EOL]     if (typeSer != null) { [EOL]         typeSer = typeSer.forProperty(property); [EOL]     } [EOL]     JsonSerializer<?> ser = null; [EOL]     if (property != null) { [EOL]         AnnotatedMember m = property.getMember(); [EOL]         if (m != null) { [EOL]             Object serDef = provider.getAnnotationIntrospector().findContentSerializer(m); [EOL]             if (serDef != null) { [EOL]                 ser = provider.serializerInstance(m, serDef); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         ser = _elementSerializer; [EOL]     } [EOL]     ser = findConvertingContentSerializer(provider, property, ser); [EOL]     if (ser == null) { [EOL]         if (ser == null) { [EOL]             if (_elementType != null) { [EOL]                 if (_staticTyping || hasContentTypeAnnotation(provider, property)) { [EOL]                     ser = provider.findValueSerializer(_elementType, property); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (ser instanceof ContextualSerializer) { [EOL]             ser = ((ContextualSerializer) ser).createContextual(provider, property); [EOL]         } [EOL]     } [EOL]     if ((ser != _elementSerializer) || (property != _property) || _valueTypeSerializer != typeSer) { [EOL]         return withResolved(property, typeSer, ser); [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     TypeSerializer typeSer = _valueTypeSerializer; [EOL]     if (typeSer != null) { [EOL]         typeSer = typeSer.forProperty(property); [EOL]     } [EOL]     JsonSerializer<?> ser = null; [EOL]     if (property != null) { [EOL]         AnnotatedMember m = property.getMember(); [EOL]         if (m != null) { [EOL]             Object serDef = provider.getAnnotationIntrospector().findContentSerializer(m); [EOL]             if (serDef != null) { [EOL]                 ser = provider.serializerInstance(m, serDef); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         ser = _elementSerializer; [EOL]     } [EOL]     ser = findConvertingContentSerializer(provider, property, ser); [EOL]     if (ser == null) { [EOL]         if (ser == null) { [EOL]             if (_elementType != null) { [EOL]                 if (_staticTyping || hasContentTypeAnnotation(provider, property)) { [EOL]                     ser = provider.findValueSerializer(_elementType, property); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (ser instanceof ContextualSerializer) { [EOL]             ser = ((ContextualSerializer) ser).createContextual(provider, property); [EOL]         } [EOL]     } [EOL]     if ((ser != _elementSerializer) || (property != _property) || _valueTypeSerializer != typeSer) { [EOL]         return withResolved(property, typeSer, ser); [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     TypeSerializer typeSer = _valueTypeSerializer; [EOL]     if (typeSer != null) { [EOL]         typeSer = typeSer.forProperty(property); [EOL]     } [EOL]     JsonSerializer<?> ser = null; [EOL]     if (property != null) { [EOL]         AnnotatedMember m = property.getMember(); [EOL]         if (m != null) { [EOL]             Object serDef = provider.getAnnotationIntrospector().findContentSerializer(m); [EOL]             if (serDef != null) { [EOL]                 ser = provider.serializerInstance(m, serDef); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         ser = _elementSerializer; [EOL]     } [EOL]     ser = findConvertingContentSerializer(provider, property, ser); [EOL]     if (ser == null) { [EOL]         if (ser == null) { [EOL]             if (_elementType != null) { [EOL]                 if (_staticTyping || hasContentTypeAnnotation(provider, property)) { [EOL]                     ser = provider.findValueSerializer(_elementType, property); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (ser instanceof ContextualSerializer) { [EOL]             ser = ((ContextualSerializer) ser).createContextual(provider, property); [EOL]         } [EOL]     } [EOL]     if ((ser != _elementSerializer) || (property != _property) || _valueTypeSerializer != typeSer) { [EOL]         return withResolved(property, typeSer, ser); [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     TypeSerializer typeSer = _valueTypeSerializer; [EOL]     if (typeSer != null) { [EOL]         typeSer = typeSer.forProperty(property); [EOL]     } [EOL]     JsonSerializer<?> ser = null; [EOL]     if (property != null) { [EOL]         AnnotatedMember m = property.getMember(); [EOL]         if (m != null) { [EOL]             Object serDef = provider.getAnnotationIntrospector().findContentSerializer(m); [EOL]             if (serDef != null) { [EOL]                 ser = provider.serializerInstance(m, serDef); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         ser = _elementSerializer; [EOL]     } [EOL]     ser = findConvertingContentSerializer(provider, property, ser); [EOL]     if (ser == null) { [EOL]         if (ser == null) { [EOL]             if (_elementType != null) { [EOL]                 if (_staticTyping || hasContentTypeAnnotation(provider, property)) { [EOL]                     ser = provider.findValueSerializer(_elementType, property); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (ser instanceof ContextualSerializer) { [EOL]             ser = ((ContextualSerializer) ser).createContextual(provider, property); [EOL]         } [EOL]     } [EOL]     if ((ser != _elementSerializer) || (property != _property) || _valueTypeSerializer != typeSer) { [EOL]         return withResolved(property, typeSer, ser); [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     TypeSerializer typeSer = _valueTypeSerializer; [EOL]     if (typeSer != null) { [EOL]         typeSer = typeSer.forProperty(property); [EOL]     } [EOL]     JsonSerializer<?> ser = null; [EOL]     if (property != null) { [EOL]         AnnotatedMember m = property.getMember(); [EOL]         if (m != null) { [EOL]             Object serDef = provider.getAnnotationIntrospector().findContentSerializer(m); [EOL]             if (serDef != null) { [EOL]                 ser = provider.serializerInstance(m, serDef); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         ser = _elementSerializer; [EOL]     } [EOL]     ser = findConvertingContentSerializer(provider, property, ser); [EOL]     if (ser == null) { [EOL]         if (ser == null) { [EOL]             if (_elementType != null) { [EOL]                 if (_staticTyping || hasContentTypeAnnotation(provider, property)) { [EOL]                     ser = provider.findValueSerializer(_elementType, property); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (ser instanceof ContextualSerializer) { [EOL]             ser = ((ContextualSerializer) ser).createContextual(provider, property); [EOL]         } [EOL]     } [EOL]     if ((ser != _elementSerializer) || (property != _property) || _valueTypeSerializer != typeSer) { [EOL]         return withResolved(property, typeSer, ser); [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     TypeSerializer typeSer = _valueTypeSerializer; [EOL]     if (typeSer != null) { [EOL]         typeSer = typeSer.forProperty(property); [EOL]     } [EOL]     JsonSerializer<?> ser = null; [EOL]     if (property != null) { [EOL]         AnnotatedMember m = property.getMember(); [EOL]         if (m != null) { [EOL]             Object serDef = provider.getAnnotationIntrospector().findContentSerializer(m); [EOL]             if (serDef != null) { [EOL]                 ser = provider.serializerInstance(m, serDef); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         ser = _elementSerializer; [EOL]     } [EOL]     ser = findConvertingContentSerializer(provider, property, ser); [EOL]     if (ser == null) { [EOL]         if (ser == null) { [EOL]             if (_elementType != null) { [EOL]                 if (_staticTyping || hasContentTypeAnnotation(provider, property)) { [EOL]                     ser = provider.findValueSerializer(_elementType, property); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (ser instanceof ContextualSerializer) { [EOL]             ser = ((ContextualSerializer) ser).createContextual(provider, property); [EOL]         } [EOL]     } [EOL]     if ((ser != _elementSerializer) || (property != _property) || _valueTypeSerializer != typeSer) { [EOL]         return withResolved(property, typeSer, ser); [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public final void serialize(T value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (provider.isEnabled(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED) && hasSingleElement(value)) { [EOL]         serializeContents(value, jgen, provider); [EOL]         return; [EOL]     } [EOL]     jgen.writeStartArray(); [EOL]     serializeContents(value, jgen, provider); [EOL]     jgen.writeEndArray(); [EOL] }
@Override [EOL] public final void serialize(T value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (provider.isEnabled(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED) && hasSingleElement(value)) { [EOL]         serializeContents(value, jgen, provider); [EOL]         return; [EOL]     } [EOL]     jgen.writeStartArray(); [EOL]     serializeContents(value, jgen, provider); [EOL]     jgen.writeEndArray(); [EOL] }
@Override [EOL] public final void serialize(T value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (provider.isEnabled(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED) && hasSingleElement(value)) { [EOL]         serializeContents(value, jgen, provider); [EOL]         return; [EOL]     } [EOL]     jgen.writeStartArray(); [EOL]     serializeContents(value, jgen, provider); [EOL]     jgen.writeEndArray(); [EOL] }
@Override [EOL] public DeserializationConfig with(MapperFeature... features) { [EOL]     int newMapperFlags = _mapperFeatures; [EOL]     for (MapperFeature f : features) { [EOL]         newMapperFlags |= f.getMask(); [EOL]     } [EOL]     return (newMapperFlags == _mapperFeatures) ? this : new DeserializationConfig(this, newMapperFlags, _deserFeatures); [EOL] }
@Override [EOL] public DeserializationConfig with(MapperFeature... features) { [EOL]     int newMapperFlags = _mapperFeatures; [EOL]     for (MapperFeature f : features) { [EOL]         newMapperFlags |= f.getMask(); [EOL]     } [EOL]     return (newMapperFlags == _mapperFeatures) ? this : new DeserializationConfig(this, newMapperFlags, _deserFeatures); [EOL] }
@Override [EOL] public DeserializationConfig with(MapperFeature... features) { [EOL]     int newMapperFlags = _mapperFeatures; [EOL]     for (MapperFeature f : features) { [EOL]         newMapperFlags |= f.getMask(); [EOL]     } [EOL]     return (newMapperFlags == _mapperFeatures) ? this : new DeserializationConfig(this, newMapperFlags, _deserFeatures); [EOL] }
@Override [EOL] public DeserializationConfig with(Base64Variant base64) { [EOL]     return _withBase(_base.with(base64)); [EOL] }
@Override [EOL] public AnnotationIntrospector getAnnotationIntrospector() { [EOL]     if (isEnabled(MapperFeature.USE_ANNOTATIONS)) { [EOL]         return super.getAnnotationIntrospector(); [EOL]     } [EOL]     return NopAnnotationIntrospector.instance; [EOL] }
@Override [EOL] public AnnotationIntrospector getAnnotationIntrospector() { [EOL]     if (isEnabled(MapperFeature.USE_ANNOTATIONS)) { [EOL]         return super.getAnnotationIntrospector(); [EOL]     } [EOL]     return NopAnnotationIntrospector.instance; [EOL] }
@Override [EOL] public BeanDescription introspectClassAnnotations(JavaType type) { [EOL]     return getClassIntrospector().forClassAnnotations(this, type, this); [EOL] }
@Override [EOL] public BeanDescription introspectClassAnnotations(JavaType type) { [EOL]     return getClassIntrospector().forClassAnnotations(this, type, this); [EOL] }
@Override [EOL] public VisibilityChecker<?> getDefaultVisibilityChecker() { [EOL]     VisibilityChecker<?> vchecker = super.getDefaultVisibilityChecker(); [EOL]     if (!isEnabled(MapperFeature.AUTO_DETECT_SETTERS)) { [EOL]         vchecker = vchecker.withSetterVisibility(Visibility.NONE); [EOL]     } [EOL]     if (!isEnabled(MapperFeature.AUTO_DETECT_CREATORS)) { [EOL]         vchecker = vchecker.withCreatorVisibility(Visibility.NONE); [EOL]     } [EOL]     if (!isEnabled(MapperFeature.AUTO_DETECT_FIELDS)) { [EOL]         vchecker = vchecker.withFieldVisibility(Visibility.NONE); [EOL]     } [EOL]     return vchecker; [EOL] }
@Override [EOL] public VisibilityChecker<?> getDefaultVisibilityChecker() { [EOL]     VisibilityChecker<?> vchecker = super.getDefaultVisibilityChecker(); [EOL]     if (!isEnabled(MapperFeature.AUTO_DETECT_SETTERS)) { [EOL]         vchecker = vchecker.withSetterVisibility(Visibility.NONE); [EOL]     } [EOL]     if (!isEnabled(MapperFeature.AUTO_DETECT_CREATORS)) { [EOL]         vchecker = vchecker.withCreatorVisibility(Visibility.NONE); [EOL]     } [EOL]     if (!isEnabled(MapperFeature.AUTO_DETECT_FIELDS)) { [EOL]         vchecker = vchecker.withFieldVisibility(Visibility.NONE); [EOL]     } [EOL]     return vchecker; [EOL] }
@Override [EOL] public VisibilityChecker<?> getDefaultVisibilityChecker() { [EOL]     VisibilityChecker<?> vchecker = super.getDefaultVisibilityChecker(); [EOL]     if (!isEnabled(MapperFeature.AUTO_DETECT_SETTERS)) { [EOL]         vchecker = vchecker.withSetterVisibility(Visibility.NONE); [EOL]     } [EOL]     if (!isEnabled(MapperFeature.AUTO_DETECT_CREATORS)) { [EOL]         vchecker = vchecker.withCreatorVisibility(Visibility.NONE); [EOL]     } [EOL]     if (!isEnabled(MapperFeature.AUTO_DETECT_FIELDS)) { [EOL]         vchecker = vchecker.withFieldVisibility(Visibility.NONE); [EOL]     } [EOL]     return vchecker; [EOL] }
@Override [EOL] public VisibilityChecker<?> getDefaultVisibilityChecker() { [EOL]     VisibilityChecker<?> vchecker = super.getDefaultVisibilityChecker(); [EOL]     if (!isEnabled(MapperFeature.AUTO_DETECT_SETTERS)) { [EOL]         vchecker = vchecker.withSetterVisibility(Visibility.NONE); [EOL]     } [EOL]     if (!isEnabled(MapperFeature.AUTO_DETECT_CREATORS)) { [EOL]         vchecker = vchecker.withCreatorVisibility(Visibility.NONE); [EOL]     } [EOL]     if (!isEnabled(MapperFeature.AUTO_DETECT_FIELDS)) { [EOL]         vchecker = vchecker.withFieldVisibility(Visibility.NONE); [EOL]     } [EOL]     return vchecker; [EOL] }
@Override [EOL] public VisibilityChecker<?> getDefaultVisibilityChecker() { [EOL]     VisibilityChecker<?> vchecker = super.getDefaultVisibilityChecker(); [EOL]     if (!isEnabled(MapperFeature.AUTO_DETECT_SETTERS)) { [EOL]         vchecker = vchecker.withSetterVisibility(Visibility.NONE); [EOL]     } [EOL]     if (!isEnabled(MapperFeature.AUTO_DETECT_CREATORS)) { [EOL]         vchecker = vchecker.withCreatorVisibility(Visibility.NONE); [EOL]     } [EOL]     if (!isEnabled(MapperFeature.AUTO_DETECT_FIELDS)) { [EOL]         vchecker = vchecker.withFieldVisibility(Visibility.NONE); [EOL]     } [EOL]     return vchecker; [EOL] }
public final int getDeserializationFeatures() { [EOL]     return _deserFeatures; [EOL] }
@SuppressWarnings("unchecked") [EOL] public <T extends BeanDescription> T introspect(JavaType type) { [EOL]     return (T) getClassIntrospector().forDeserialization(this, type, this); [EOL] }
protected JavaType parseType(MyTokenizer tokens) throws IllegalArgumentException { [EOL]     if (!tokens.hasMoreTokens()) { [EOL]         throw _problem(tokens, "Unexpected end-of-string"); [EOL]     } [EOL]     Class<?> base = findClass(tokens.nextToken(), tokens); [EOL]     if (tokens.hasMoreTokens()) { [EOL]         String token = tokens.nextToken(); [EOL]         if ("<".equals(token)) { [EOL]             return _factory._fromParameterizedClass(base, parseTypes(tokens)); [EOL]         } [EOL]         tokens.pushBack(token); [EOL]     } [EOL]     return _factory._fromClass(base, null); [EOL] }
protected JavaType parseType(MyTokenizer tokens) throws IllegalArgumentException { [EOL]     if (!tokens.hasMoreTokens()) { [EOL]         throw _problem(tokens, "Unexpected end-of-string"); [EOL]     } [EOL]     Class<?> base = findClass(tokens.nextToken(), tokens); [EOL]     if (tokens.hasMoreTokens()) { [EOL]         String token = tokens.nextToken(); [EOL]         if ("<".equals(token)) { [EOL]             return _factory._fromParameterizedClass(base, parseTypes(tokens)); [EOL]         } [EOL]         tokens.pushBack(token); [EOL]     } [EOL]     return _factory._fromClass(base, null); [EOL] }
protected JavaType parseType(MyTokenizer tokens) throws IllegalArgumentException { [EOL]     if (!tokens.hasMoreTokens()) { [EOL]         throw _problem(tokens, "Unexpected end-of-string"); [EOL]     } [EOL]     Class<?> base = findClass(tokens.nextToken(), tokens); [EOL]     if (tokens.hasMoreTokens()) { [EOL]         String token = tokens.nextToken(); [EOL]         if ("<".equals(token)) { [EOL]             return _factory._fromParameterizedClass(base, parseTypes(tokens)); [EOL]         } [EOL]         tokens.pushBack(token); [EOL]     } [EOL]     return _factory._fromClass(base, null); [EOL] }
protected JavaType parseType(MyTokenizer tokens) throws IllegalArgumentException { [EOL]     if (!tokens.hasMoreTokens()) { [EOL]         throw _problem(tokens, "Unexpected end-of-string"); [EOL]     } [EOL]     Class<?> base = findClass(tokens.nextToken(), tokens); [EOL]     if (tokens.hasMoreTokens()) { [EOL]         String token = tokens.nextToken(); [EOL]         if ("<".equals(token)) { [EOL]             return _factory._fromParameterizedClass(base, parseTypes(tokens)); [EOL]         } [EOL]         tokens.pushBack(token); [EOL]     } [EOL]     return _factory._fromClass(base, null); [EOL] }
protected List<JavaType> parseTypes(MyTokenizer tokens) throws IllegalArgumentException { [EOL]     ArrayList<JavaType> types = new ArrayList<JavaType>(); [EOL]     while (tokens.hasMoreTokens()) { [EOL]         types.add(parseType(tokens)); [EOL]         if (!tokens.hasMoreTokens()) [EOL]             break; [EOL]         String token = tokens.nextToken(); [EOL]         if (">".equals(token)) [EOL]             return types; [EOL]         if (!",".equals(token)) { [EOL]             throw _problem(tokens, "Unexpected token '" + token + "', expected ',' or '>')"); [EOL]         } [EOL]     } [EOL]     throw _problem(tokens, "Unexpected end-of-string"); [EOL] }
protected List<JavaType> parseTypes(MyTokenizer tokens) throws IllegalArgumentException { [EOL]     ArrayList<JavaType> types = new ArrayList<JavaType>(); [EOL]     while (tokens.hasMoreTokens()) { [EOL]         types.add(parseType(tokens)); [EOL]         if (!tokens.hasMoreTokens()) [EOL]             break; [EOL]         String token = tokens.nextToken(); [EOL]         if (">".equals(token)) [EOL]             return types; [EOL]         if (!",".equals(token)) { [EOL]             throw _problem(tokens, "Unexpected token '" + token + "', expected ',' or '>')"); [EOL]         } [EOL]     } [EOL]     throw _problem(tokens, "Unexpected end-of-string"); [EOL] }
@Override [EOL] public String nextToken() { [EOL]     String token; [EOL]     if (_pushbackToken != null) { [EOL]         token = _pushbackToken; [EOL]         _pushbackToken = null; [EOL]     } else { [EOL]         token = super.nextToken(); [EOL]     } [EOL]     _index += token.length(); [EOL]     return token; [EOL] }
@Override [EOL] public String nextToken() { [EOL]     String token; [EOL]     if (_pushbackToken != null) { [EOL]         token = _pushbackToken; [EOL]         _pushbackToken = null; [EOL]     } else { [EOL]         token = super.nextToken(); [EOL]     } [EOL]     _index += token.length(); [EOL]     return token; [EOL] }
public void pushBack(String token) { [EOL]     _pushbackToken = token; [EOL]     _index -= token.length(); [EOL] }
public void pushBack(String token) { [EOL]     _pushbackToken = token; [EOL]     _index -= token.length(); [EOL] }
@Override [EOL] public String deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     String text = jp.getValueAsString(); [EOL]     if (text != null) { [EOL]         return text; [EOL]     } [EOL]     JsonToken curr = jp.getCurrentToken(); [EOL]     if (curr == JsonToken.VALUE_EMBEDDED_OBJECT) { [EOL]         Object ob = jp.getEmbeddedObject(); [EOL]         if (ob == null) { [EOL]             return null; [EOL]         } [EOL]         if (ob instanceof byte[]) { [EOL]             return Base64Variants.getDefaultVariant().encode((byte[]) ob, false); [EOL]         } [EOL]         return ob.toString(); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, curr); [EOL] }
@Override [EOL] public String deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     String text = jp.getValueAsString(); [EOL]     if (text != null) { [EOL]         return text; [EOL]     } [EOL]     JsonToken curr = jp.getCurrentToken(); [EOL]     if (curr == JsonToken.VALUE_EMBEDDED_OBJECT) { [EOL]         Object ob = jp.getEmbeddedObject(); [EOL]         if (ob == null) { [EOL]             return null; [EOL]         } [EOL]         if (ob instanceof byte[]) { [EOL]             return Base64Variants.getDefaultVariant().encode((byte[]) ob, false); [EOL]         } [EOL]         return ob.toString(); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, curr); [EOL] }
@Override [EOL] public String deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     String text = jp.getValueAsString(); [EOL]     if (text != null) { [EOL]         return text; [EOL]     } [EOL]     JsonToken curr = jp.getCurrentToken(); [EOL]     if (curr == JsonToken.VALUE_EMBEDDED_OBJECT) { [EOL]         Object ob = jp.getEmbeddedObject(); [EOL]         if (ob == null) { [EOL]             return null; [EOL]         } [EOL]         if (ob instanceof byte[]) { [EOL]             return Base64Variants.getDefaultVariant().encode((byte[]) ob, false); [EOL]         } [EOL]         return ob.toString(); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, curr); [EOL] }
@Override [EOL] public String deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     String text = jp.getValueAsString(); [EOL]     if (text != null) { [EOL]         return text; [EOL]     } [EOL]     JsonToken curr = jp.getCurrentToken(); [EOL]     if (curr == JsonToken.VALUE_EMBEDDED_OBJECT) { [EOL]         Object ob = jp.getEmbeddedObject(); [EOL]         if (ob == null) { [EOL]             return null; [EOL]         } [EOL]         if (ob instanceof byte[]) { [EOL]             return Base64Variants.getDefaultVariant().encode((byte[]) ob, false); [EOL]         } [EOL]         return ob.toString(); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, curr); [EOL] }
@Override [EOL] public String deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     String text = jp.getValueAsString(); [EOL]     if (text != null) { [EOL]         return text; [EOL]     } [EOL]     JsonToken curr = jp.getCurrentToken(); [EOL]     if (curr == JsonToken.VALUE_EMBEDDED_OBJECT) { [EOL]         Object ob = jp.getEmbeddedObject(); [EOL]         if (ob == null) { [EOL]             return null; [EOL]         } [EOL]         if (ob instanceof byte[]) { [EOL]             return Base64Variants.getDefaultVariant().encode((byte[]) ob, false); [EOL]         } [EOL]         return ob.toString(); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, curr); [EOL] }
@Override [EOL] public Object deserializeTypedFromScalar(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     return _deserialize(jp, ctxt); [EOL] }
@Override [EOL] public Class<?> getRawType() { [EOL]     if (_type instanceof Class<?>) { [EOL]         return (Class<?>) _type; [EOL]     } [EOL]     JavaType t = TypeFactory.defaultInstance().constructType(_type); [EOL]     return t.getRawClass(); [EOL] }
@Override [EOL] public Class<?> getRawType() { [EOL]     if (_type instanceof Class<?>) { [EOL]         return (Class<?>) _type; [EOL]     } [EOL]     JavaType t = TypeFactory.defaultInstance().constructType(_type); [EOL]     return t.getRawClass(); [EOL] }
@Override [EOL] public StdDateFormat clone() { [EOL]     return new StdDateFormat(); [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
@Override [EOL] public StdDateFormat clone() { [EOL]     return new StdDateFormat(); [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
@Override [EOL] public StdDateFormat clone() { [EOL]     return new StdDateFormat(); [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
@Override [EOL] public StdDateFormat clone() { [EOL]     return new StdDateFormat(); [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
@Override [EOL] public StdDateFormat clone() { [EOL]     return new StdDateFormat(); [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
@Override [EOL] public StdDateFormat clone() { [EOL]     return new StdDateFormat(); [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
@Override [EOL] public StdDateFormat clone() { [EOL]     return new StdDateFormat(); [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
@Override [EOL] public StdDateFormat clone() { [EOL]     return new StdDateFormat(); [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
@Override [EOL] public StdDateFormat clone() { [EOL]     return new StdDateFormat(); [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
@Override [EOL] public StdDateFormat clone() { [EOL]     return new StdDateFormat(); [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
@Override [EOL] public StdDateFormat clone() { [EOL]     return new StdDateFormat(); [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
@Override [EOL] public StdDateFormat clone() { [EOL]     return new StdDateFormat(); [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
@Override [EOL] public StdDateFormat clone() { [EOL]     return new StdDateFormat(); [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
@Override [EOL] public StdDateFormat clone() { [EOL]     return new StdDateFormat(); [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
@Override [EOL] public StdDateFormat clone() { [EOL]     return new StdDateFormat(); [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
@Override [EOL] public StdDateFormat clone() { [EOL]     return new StdDateFormat(); [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
@Override [EOL] public StdDateFormat clone() { [EOL]     return new StdDateFormat(); [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
@Override [EOL] public StdDateFormat clone() { [EOL]     return new StdDateFormat(); [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
@Override [EOL] public StdDateFormat clone() { [EOL]     return new StdDateFormat(); [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
@Override [EOL] public Date parse(String dateStr) throws ParseException { [EOL]     dateStr = dateStr.trim(); [EOL]     ParsePosition pos = new ParsePosition(0); [EOL]     Date result = parse(dateStr, pos); [EOL]     if (result != null) { [EOL]         return result; [EOL]     } [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (String f : ALL_FORMATS) { [EOL]         if (sb.length() > 0) { [EOL]             sb.append("\", \""); [EOL]         } else { [EOL]             sb.append('"'); [EOL]         } [EOL]         sb.append(f); [EOL]     } [EOL]     sb.append('"'); [EOL]     throw new ParseException(String.format("Can not parse date \"%s\": not compatible with any of standard forms (%s)", dateStr, sb.toString()), pos.getErrorIndex()); [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
@Override [EOL] public Date parse(String dateStr) throws ParseException { [EOL]     dateStr = dateStr.trim(); [EOL]     ParsePosition pos = new ParsePosition(0); [EOL]     Date result = parse(dateStr, pos); [EOL]     if (result != null) { [EOL]         return result; [EOL]     } [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (String f : ALL_FORMATS) { [EOL]         if (sb.length() > 0) { [EOL]             sb.append("\", \""); [EOL]         } else { [EOL]             sb.append('"'); [EOL]         } [EOL]         sb.append(f); [EOL]     } [EOL]     sb.append('"'); [EOL]     throw new ParseException(String.format("Can not parse date \"%s\": not compatible with any of standard forms (%s)", dateStr, sb.toString()), pos.getErrorIndex()); [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
@Override [EOL] public Date parse(String dateStr) throws ParseException { [EOL]     dateStr = dateStr.trim(); [EOL]     ParsePosition pos = new ParsePosition(0); [EOL]     Date result = parse(dateStr, pos); [EOL]     if (result != null) { [EOL]         return result; [EOL]     } [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (String f : ALL_FORMATS) { [EOL]         if (sb.length() > 0) { [EOL]             sb.append("\", \""); [EOL]         } else { [EOL]             sb.append('"'); [EOL]         } [EOL]         sb.append(f); [EOL]     } [EOL]     sb.append('"'); [EOL]     throw new ParseException(String.format("Can not parse date \"%s\": not compatible with any of standard forms (%s)", dateStr, sb.toString()), pos.getErrorIndex()); [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
@Override [EOL] public Date parse(String dateStr) throws ParseException { [EOL]     dateStr = dateStr.trim(); [EOL]     ParsePosition pos = new ParsePosition(0); [EOL]     Date result = parse(dateStr, pos); [EOL]     if (result != null) { [EOL]         return result; [EOL]     } [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (String f : ALL_FORMATS) { [EOL]         if (sb.length() > 0) { [EOL]             sb.append("\", \""); [EOL]         } else { [EOL]             sb.append('"'); [EOL]         } [EOL]         sb.append(f); [EOL]     } [EOL]     sb.append('"'); [EOL]     throw new ParseException(String.format("Can not parse date \"%s\": not compatible with any of standard forms (%s)", dateStr, sb.toString()), pos.getErrorIndex()); [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
@Override [EOL] public Date parse(String dateStr) throws ParseException { [EOL]     dateStr = dateStr.trim(); [EOL]     ParsePosition pos = new ParsePosition(0); [EOL]     Date result = parse(dateStr, pos); [EOL]     if (result != null) { [EOL]         return result; [EOL]     } [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (String f : ALL_FORMATS) { [EOL]         if (sb.length() > 0) { [EOL]             sb.append("\", \""); [EOL]         } else { [EOL]             sb.append('"'); [EOL]         } [EOL]         sb.append(f); [EOL]     } [EOL]     sb.append('"'); [EOL]     throw new ParseException(String.format("Can not parse date \"%s\": not compatible with any of standard forms (%s)", dateStr, sb.toString()), pos.getErrorIndex()); [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
@Override [EOL] public Date parse(String dateStr, ParsePosition pos) { [EOL]     if (looksLikeISO8601(dateStr)) { [EOL]         return parseAsISO8601(dateStr, pos); [EOL]     } [EOL]     int i = dateStr.length(); [EOL]     while (--i >= 0) { [EOL]         char ch = dateStr.charAt(i); [EOL]         if (ch < '0' || ch > '9') [EOL]             break; [EOL]     } [EOL]     if (i < 0) { [EOL]         if (NumberInput.inLongRange(dateStr, false)) { [EOL]             return new Date(Long.parseLong(dateStr)); [EOL]         } [EOL]     } [EOL]     return parseAsRFC1123(dateStr, pos); [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
@Override [EOL] public Date parse(String dateStr, ParsePosition pos) { [EOL]     if (looksLikeISO8601(dateStr)) { [EOL]         return parseAsISO8601(dateStr, pos); [EOL]     } [EOL]     int i = dateStr.length(); [EOL]     while (--i >= 0) { [EOL]         char ch = dateStr.charAt(i); [EOL]         if (ch < '0' || ch > '9') [EOL]             break; [EOL]     } [EOL]     if (i < 0) { [EOL]         if (NumberInput.inLongRange(dateStr, false)) { [EOL]             return new Date(Long.parseLong(dateStr)); [EOL]         } [EOL]     } [EOL]     return parseAsRFC1123(dateStr, pos); [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
@Override [EOL] public Date parse(String dateStr, ParsePosition pos) { [EOL]     if (looksLikeISO8601(dateStr)) { [EOL]         return parseAsISO8601(dateStr, pos); [EOL]     } [EOL]     int i = dateStr.length(); [EOL]     while (--i >= 0) { [EOL]         char ch = dateStr.charAt(i); [EOL]         if (ch < '0' || ch > '9') [EOL]             break; [EOL]     } [EOL]     if (i < 0) { [EOL]         if (NumberInput.inLongRange(dateStr, false)) { [EOL]             return new Date(Long.parseLong(dateStr)); [EOL]         } [EOL]     } [EOL]     return parseAsRFC1123(dateStr, pos); [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
@Override [EOL] public Date parse(String dateStr, ParsePosition pos) { [EOL]     if (looksLikeISO8601(dateStr)) { [EOL]         return parseAsISO8601(dateStr, pos); [EOL]     } [EOL]     int i = dateStr.length(); [EOL]     while (--i >= 0) { [EOL]         char ch = dateStr.charAt(i); [EOL]         if (ch < '0' || ch > '9') [EOL]             break; [EOL]     } [EOL]     if (i < 0) { [EOL]         if (NumberInput.inLongRange(dateStr, false)) { [EOL]             return new Date(Long.parseLong(dateStr)); [EOL]         } [EOL]     } [EOL]     return parseAsRFC1123(dateStr, pos); [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
protected boolean looksLikeISO8601(String dateStr) { [EOL]     if (dateStr.length() >= 5 && Character.isDigit(dateStr.charAt(0)) && Character.isDigit(dateStr.charAt(3)) && dateStr.charAt(4) == '-') { [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
protected boolean looksLikeISO8601(String dateStr) { [EOL]     if (dateStr.length() >= 5 && Character.isDigit(dateStr.charAt(0)) && Character.isDigit(dateStr.charAt(3)) && dateStr.charAt(4) == '-') { [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
protected boolean looksLikeISO8601(String dateStr) { [EOL]     if (dateStr.length() >= 5 && Character.isDigit(dateStr.charAt(0)) && Character.isDigit(dateStr.charAt(3)) && dateStr.charAt(4) == '-') { [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
protected boolean looksLikeISO8601(String dateStr) { [EOL]     if (dateStr.length() >= 5 && Character.isDigit(dateStr.charAt(0)) && Character.isDigit(dateStr.charAt(3)) && dateStr.charAt(4) == '-') { [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
protected Date parseAsISO8601(String dateStr, ParsePosition pos) { [EOL]     int len = dateStr.length(); [EOL]     char c = dateStr.charAt(len - 1); [EOL]     DateFormat df; [EOL]     if (len <= 10 && Character.isDigit(c)) { [EOL]         df = _formatPlain; [EOL]         if (df == null) { [EOL]             df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN); [EOL]         } [EOL]     } else if (c == 'Z') { [EOL]         df = _formatISO8601_z; [EOL]         if (df == null) { [EOL]             df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z); [EOL]         } [EOL]         if (dateStr.charAt(len - 4) == ':') { [EOL]             StringBuilder sb = new StringBuilder(dateStr); [EOL]             sb.insert(len - 1, ".000"); [EOL]             dateStr = sb.toString(); [EOL]         } [EOL]     } else { [EOL]         if (hasTimeZone(dateStr)) { [EOL]             c = dateStr.charAt(len - 3); [EOL]             if (c == ':') { [EOL]                 StringBuilder sb = new StringBuilder(dateStr); [EOL]                 sb.delete(len - 3, len - 2); [EOL]                 dateStr = sb.toString(); [EOL]             } else if (c == '+' || c == '-') { [EOL]                 dateStr += "00"; [EOL]             } [EOL]             len = dateStr.length(); [EOL]             c = dateStr.charAt(len - 9); [EOL]             if (Character.isDigit(c)) { [EOL]                 StringBuilder sb = new StringBuilder(dateStr); [EOL]                 sb.insert(len - 5, ".000"); [EOL]                 dateStr = sb.toString(); [EOL]             } [EOL]             df = _formatISO8601; [EOL]             if (_formatISO8601 == null) { [EOL]                 df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601); [EOL]             } [EOL]         } else { [EOL]             StringBuilder sb = new StringBuilder(dateStr); [EOL]             int timeLen = len - dateStr.lastIndexOf('T') - 1; [EOL]             if (timeLen <= 8) { [EOL]                 sb.append(".000"); [EOL]             } [EOL]             sb.append('Z'); [EOL]             dateStr = sb.toString(); [EOL]             df = _formatISO8601_z; [EOL]             if (df == null) { [EOL]                 df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z); [EOL]             } [EOL]         } [EOL]     } [EOL]     return df.parse(dateStr, pos); [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
protected Date parseAsISO8601(String dateStr, ParsePosition pos) { [EOL]     int len = dateStr.length(); [EOL]     char c = dateStr.charAt(len - 1); [EOL]     DateFormat df; [EOL]     if (len <= 10 && Character.isDigit(c)) { [EOL]         df = _formatPlain; [EOL]         if (df == null) { [EOL]             df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN); [EOL]         } [EOL]     } else if (c == 'Z') { [EOL]         df = _formatISO8601_z; [EOL]         if (df == null) { [EOL]             df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z); [EOL]         } [EOL]         if (dateStr.charAt(len - 4) == ':') { [EOL]             StringBuilder sb = new StringBuilder(dateStr); [EOL]             sb.insert(len - 1, ".000"); [EOL]             dateStr = sb.toString(); [EOL]         } [EOL]     } else { [EOL]         if (hasTimeZone(dateStr)) { [EOL]             c = dateStr.charAt(len - 3); [EOL]             if (c == ':') { [EOL]                 StringBuilder sb = new StringBuilder(dateStr); [EOL]                 sb.delete(len - 3, len - 2); [EOL]                 dateStr = sb.toString(); [EOL]             } else if (c == '+' || c == '-') { [EOL]                 dateStr += "00"; [EOL]             } [EOL]             len = dateStr.length(); [EOL]             c = dateStr.charAt(len - 9); [EOL]             if (Character.isDigit(c)) { [EOL]                 StringBuilder sb = new StringBuilder(dateStr); [EOL]                 sb.insert(len - 5, ".000"); [EOL]                 dateStr = sb.toString(); [EOL]             } [EOL]             df = _formatISO8601; [EOL]             if (_formatISO8601 == null) { [EOL]                 df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601); [EOL]             } [EOL]         } else { [EOL]             StringBuilder sb = new StringBuilder(dateStr); [EOL]             int timeLen = len - dateStr.lastIndexOf('T') - 1; [EOL]             if (timeLen <= 8) { [EOL]                 sb.append(".000"); [EOL]             } [EOL]             sb.append('Z'); [EOL]             dateStr = sb.toString(); [EOL]             df = _formatISO8601_z; [EOL]             if (df == null) { [EOL]                 df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z); [EOL]             } [EOL]         } [EOL]     } [EOL]     return df.parse(dateStr, pos); [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
protected Date parseAsISO8601(String dateStr, ParsePosition pos) { [EOL]     int len = dateStr.length(); [EOL]     char c = dateStr.charAt(len - 1); [EOL]     DateFormat df; [EOL]     if (len <= 10 && Character.isDigit(c)) { [EOL]         df = _formatPlain; [EOL]         if (df == null) { [EOL]             df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN); [EOL]         } [EOL]     } else if (c == 'Z') { [EOL]         df = _formatISO8601_z; [EOL]         if (df == null) { [EOL]             df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z); [EOL]         } [EOL]         if (dateStr.charAt(len - 4) == ':') { [EOL]             StringBuilder sb = new StringBuilder(dateStr); [EOL]             sb.insert(len - 1, ".000"); [EOL]             dateStr = sb.toString(); [EOL]         } [EOL]     } else { [EOL]         if (hasTimeZone(dateStr)) { [EOL]             c = dateStr.charAt(len - 3); [EOL]             if (c == ':') { [EOL]                 StringBuilder sb = new StringBuilder(dateStr); [EOL]                 sb.delete(len - 3, len - 2); [EOL]                 dateStr = sb.toString(); [EOL]             } else if (c == '+' || c == '-') { [EOL]                 dateStr += "00"; [EOL]             } [EOL]             len = dateStr.length(); [EOL]             c = dateStr.charAt(len - 9); [EOL]             if (Character.isDigit(c)) { [EOL]                 StringBuilder sb = new StringBuilder(dateStr); [EOL]                 sb.insert(len - 5, ".000"); [EOL]                 dateStr = sb.toString(); [EOL]             } [EOL]             df = _formatISO8601; [EOL]             if (_formatISO8601 == null) { [EOL]                 df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601); [EOL]             } [EOL]         } else { [EOL]             StringBuilder sb = new StringBuilder(dateStr); [EOL]             int timeLen = len - dateStr.lastIndexOf('T') - 1; [EOL]             if (timeLen <= 8) { [EOL]                 sb.append(".000"); [EOL]             } [EOL]             sb.append('Z'); [EOL]             dateStr = sb.toString(); [EOL]             df = _formatISO8601_z; [EOL]             if (df == null) { [EOL]                 df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z); [EOL]             } [EOL]         } [EOL]     } [EOL]     return df.parse(dateStr, pos); [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
protected Date parseAsISO8601(String dateStr, ParsePosition pos) { [EOL]     int len = dateStr.length(); [EOL]     char c = dateStr.charAt(len - 1); [EOL]     DateFormat df; [EOL]     if (len <= 10 && Character.isDigit(c)) { [EOL]         df = _formatPlain; [EOL]         if (df == null) { [EOL]             df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN); [EOL]         } [EOL]     } else if (c == 'Z') { [EOL]         df = _formatISO8601_z; [EOL]         if (df == null) { [EOL]             df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z); [EOL]         } [EOL]         if (dateStr.charAt(len - 4) == ':') { [EOL]             StringBuilder sb = new StringBuilder(dateStr); [EOL]             sb.insert(len - 1, ".000"); [EOL]             dateStr = sb.toString(); [EOL]         } [EOL]     } else { [EOL]         if (hasTimeZone(dateStr)) { [EOL]             c = dateStr.charAt(len - 3); [EOL]             if (c == ':') { [EOL]                 StringBuilder sb = new StringBuilder(dateStr); [EOL]                 sb.delete(len - 3, len - 2); [EOL]                 dateStr = sb.toString(); [EOL]             } else if (c == '+' || c == '-') { [EOL]                 dateStr += "00"; [EOL]             } [EOL]             len = dateStr.length(); [EOL]             c = dateStr.charAt(len - 9); [EOL]             if (Character.isDigit(c)) { [EOL]                 StringBuilder sb = new StringBuilder(dateStr); [EOL]                 sb.insert(len - 5, ".000"); [EOL]                 dateStr = sb.toString(); [EOL]             } [EOL]             df = _formatISO8601; [EOL]             if (_formatISO8601 == null) { [EOL]                 df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601); [EOL]             } [EOL]         } else { [EOL]             StringBuilder sb = new StringBuilder(dateStr); [EOL]             int timeLen = len - dateStr.lastIndexOf('T') - 1; [EOL]             if (timeLen <= 8) { [EOL]                 sb.append(".000"); [EOL]             } [EOL]             sb.append('Z'); [EOL]             dateStr = sb.toString(); [EOL]             df = _formatISO8601_z; [EOL]             if (df == null) { [EOL]                 df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z); [EOL]             } [EOL]         } [EOL]     } [EOL]     return df.parse(dateStr, pos); [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
protected Date parseAsISO8601(String dateStr, ParsePosition pos) { [EOL]     int len = dateStr.length(); [EOL]     char c = dateStr.charAt(len - 1); [EOL]     DateFormat df; [EOL]     if (len <= 10 && Character.isDigit(c)) { [EOL]         df = _formatPlain; [EOL]         if (df == null) { [EOL]             df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN); [EOL]         } [EOL]     } else if (c == 'Z') { [EOL]         df = _formatISO8601_z; [EOL]         if (df == null) { [EOL]             df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z); [EOL]         } [EOL]         if (dateStr.charAt(len - 4) == ':') { [EOL]             StringBuilder sb = new StringBuilder(dateStr); [EOL]             sb.insert(len - 1, ".000"); [EOL]             dateStr = sb.toString(); [EOL]         } [EOL]     } else { [EOL]         if (hasTimeZone(dateStr)) { [EOL]             c = dateStr.charAt(len - 3); [EOL]             if (c == ':') { [EOL]                 StringBuilder sb = new StringBuilder(dateStr); [EOL]                 sb.delete(len - 3, len - 2); [EOL]                 dateStr = sb.toString(); [EOL]             } else if (c == '+' || c == '-') { [EOL]                 dateStr += "00"; [EOL]             } [EOL]             len = dateStr.length(); [EOL]             c = dateStr.charAt(len - 9); [EOL]             if (Character.isDigit(c)) { [EOL]                 StringBuilder sb = new StringBuilder(dateStr); [EOL]                 sb.insert(len - 5, ".000"); [EOL]                 dateStr = sb.toString(); [EOL]             } [EOL]             df = _formatISO8601; [EOL]             if (_formatISO8601 == null) { [EOL]                 df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601); [EOL]             } [EOL]         } else { [EOL]             StringBuilder sb = new StringBuilder(dateStr); [EOL]             int timeLen = len - dateStr.lastIndexOf('T') - 1; [EOL]             if (timeLen <= 8) { [EOL]                 sb.append(".000"); [EOL]             } [EOL]             sb.append('Z'); [EOL]             dateStr = sb.toString(); [EOL]             df = _formatISO8601_z; [EOL]             if (df == null) { [EOL]                 df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z); [EOL]             } [EOL]         } [EOL]     } [EOL]     return df.parse(dateStr, pos); [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
protected Date parseAsISO8601(String dateStr, ParsePosition pos) { [EOL]     int len = dateStr.length(); [EOL]     char c = dateStr.charAt(len - 1); [EOL]     DateFormat df; [EOL]     if (len <= 10 && Character.isDigit(c)) { [EOL]         df = _formatPlain; [EOL]         if (df == null) { [EOL]             df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN); [EOL]         } [EOL]     } else if (c == 'Z') { [EOL]         df = _formatISO8601_z; [EOL]         if (df == null) { [EOL]             df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z); [EOL]         } [EOL]         if (dateStr.charAt(len - 4) == ':') { [EOL]             StringBuilder sb = new StringBuilder(dateStr); [EOL]             sb.insert(len - 1, ".000"); [EOL]             dateStr = sb.toString(); [EOL]         } [EOL]     } else { [EOL]         if (hasTimeZone(dateStr)) { [EOL]             c = dateStr.charAt(len - 3); [EOL]             if (c == ':') { [EOL]                 StringBuilder sb = new StringBuilder(dateStr); [EOL]                 sb.delete(len - 3, len - 2); [EOL]                 dateStr = sb.toString(); [EOL]             } else if (c == '+' || c == '-') { [EOL]                 dateStr += "00"; [EOL]             } [EOL]             len = dateStr.length(); [EOL]             c = dateStr.charAt(len - 9); [EOL]             if (Character.isDigit(c)) { [EOL]                 StringBuilder sb = new StringBuilder(dateStr); [EOL]                 sb.insert(len - 5, ".000"); [EOL]                 dateStr = sb.toString(); [EOL]             } [EOL]             df = _formatISO8601; [EOL]             if (_formatISO8601 == null) { [EOL]                 df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601); [EOL]             } [EOL]         } else { [EOL]             StringBuilder sb = new StringBuilder(dateStr); [EOL]             int timeLen = len - dateStr.lastIndexOf('T') - 1; [EOL]             if (timeLen <= 8) { [EOL]                 sb.append(".000"); [EOL]             } [EOL]             sb.append('Z'); [EOL]             dateStr = sb.toString(); [EOL]             df = _formatISO8601_z; [EOL]             if (df == null) { [EOL]                 df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z); [EOL]             } [EOL]         } [EOL]     } [EOL]     return df.parse(dateStr, pos); [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
protected Date parseAsISO8601(String dateStr, ParsePosition pos) { [EOL]     int len = dateStr.length(); [EOL]     char c = dateStr.charAt(len - 1); [EOL]     DateFormat df; [EOL]     if (len <= 10 && Character.isDigit(c)) { [EOL]         df = _formatPlain; [EOL]         if (df == null) { [EOL]             df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN); [EOL]         } [EOL]     } else if (c == 'Z') { [EOL]         df = _formatISO8601_z; [EOL]         if (df == null) { [EOL]             df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z); [EOL]         } [EOL]         if (dateStr.charAt(len - 4) == ':') { [EOL]             StringBuilder sb = new StringBuilder(dateStr); [EOL]             sb.insert(len - 1, ".000"); [EOL]             dateStr = sb.toString(); [EOL]         } [EOL]     } else { [EOL]         if (hasTimeZone(dateStr)) { [EOL]             c = dateStr.charAt(len - 3); [EOL]             if (c == ':') { [EOL]                 StringBuilder sb = new StringBuilder(dateStr); [EOL]                 sb.delete(len - 3, len - 2); [EOL]                 dateStr = sb.toString(); [EOL]             } else if (c == '+' || c == '-') { [EOL]                 dateStr += "00"; [EOL]             } [EOL]             len = dateStr.length(); [EOL]             c = dateStr.charAt(len - 9); [EOL]             if (Character.isDigit(c)) { [EOL]                 StringBuilder sb = new StringBuilder(dateStr); [EOL]                 sb.insert(len - 5, ".000"); [EOL]                 dateStr = sb.toString(); [EOL]             } [EOL]             df = _formatISO8601; [EOL]             if (_formatISO8601 == null) { [EOL]                 df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601); [EOL]             } [EOL]         } else { [EOL]             StringBuilder sb = new StringBuilder(dateStr); [EOL]             int timeLen = len - dateStr.lastIndexOf('T') - 1; [EOL]             if (timeLen <= 8) { [EOL]                 sb.append(".000"); [EOL]             } [EOL]             sb.append('Z'); [EOL]             dateStr = sb.toString(); [EOL]             df = _formatISO8601_z; [EOL]             if (df == null) { [EOL]                 df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z); [EOL]             } [EOL]         } [EOL]     } [EOL]     return df.parse(dateStr, pos); [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
private final static boolean hasTimeZone(String str) { [EOL]     int len = str.length(); [EOL]     if (len >= 6) { [EOL]         char c = str.charAt(len - 6); [EOL]         if (c == '+' || c == '-') [EOL]             return true; [EOL]         c = str.charAt(len - 5); [EOL]         if (c == '+' || c == '-') [EOL]             return true; [EOL]         c = str.charAt(len - 3); [EOL]         if (c == '+' || c == '-') [EOL]             return true; [EOL]     } [EOL]     return false; [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
private final static boolean hasTimeZone(String str) { [EOL]     int len = str.length(); [EOL]     if (len >= 6) { [EOL]         char c = str.charAt(len - 6); [EOL]         if (c == '+' || c == '-') [EOL]             return true; [EOL]         c = str.charAt(len - 5); [EOL]         if (c == '+' || c == '-') [EOL]             return true; [EOL]         c = str.charAt(len - 3); [EOL]         if (c == '+' || c == '-') [EOL]             return true; [EOL]     } [EOL]     return false; [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
private final static boolean hasTimeZone(String str) { [EOL]     int len = str.length(); [EOL]     if (len >= 6) { [EOL]         char c = str.charAt(len - 6); [EOL]         if (c == '+' || c == '-') [EOL]             return true; [EOL]         c = str.charAt(len - 5); [EOL]         if (c == '+' || c == '-') [EOL]             return true; [EOL]         c = str.charAt(len - 3); [EOL]         if (c == '+' || c == '-') [EOL]             return true; [EOL]     } [EOL]     return false; [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
private final static boolean hasTimeZone(String str) { [EOL]     int len = str.length(); [EOL]     if (len >= 6) { [EOL]         char c = str.charAt(len - 6); [EOL]         if (c == '+' || c == '-') [EOL]             return true; [EOL]         c = str.charAt(len - 5); [EOL]         if (c == '+' || c == '-') [EOL]             return true; [EOL]         c = str.charAt(len - 3); [EOL]         if (c == '+' || c == '-') [EOL]             return true; [EOL]     } [EOL]     return false; [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
private final static boolean hasTimeZone(String str) { [EOL]     int len = str.length(); [EOL]     if (len >= 6) { [EOL]         char c = str.charAt(len - 6); [EOL]         if (c == '+' || c == '-') [EOL]             return true; [EOL]         c = str.charAt(len - 5); [EOL]         if (c == '+' || c == '-') [EOL]             return true; [EOL]         c = str.charAt(len - 3); [EOL]         if (c == '+' || c == '-') [EOL]             return true; [EOL]     } [EOL]     return false; [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
private final static boolean hasTimeZone(String str) { [EOL]     int len = str.length(); [EOL]     if (len >= 6) { [EOL]         char c = str.charAt(len - 6); [EOL]         if (c == '+' || c == '-') [EOL]             return true; [EOL]         c = str.charAt(len - 5); [EOL]         if (c == '+' || c == '-') [EOL]             return true; [EOL]         c = str.charAt(len - 3); [EOL]         if (c == '+' || c == '-') [EOL]             return true; [EOL]     } [EOL]     return false; [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
private final static boolean hasTimeZone(String str) { [EOL]     int len = str.length(); [EOL]     if (len >= 6) { [EOL]         char c = str.charAt(len - 6); [EOL]         if (c == '+' || c == '-') [EOL]             return true; [EOL]         c = str.charAt(len - 5); [EOL]         if (c == '+' || c == '-') [EOL]             return true; [EOL]         c = str.charAt(len - 3); [EOL]         if (c == '+' || c == '-') [EOL]             return true; [EOL]     } [EOL]     return false; [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
protected SettableBeanProperty(String propName, JavaType type, PropertyName wrapper, TypeDeserializer typeDeser, Annotations contextAnnotations, boolean isRequired) { [EOL]     if (propName == null || propName.length() == 0) { [EOL]         _propName = ""; [EOL]     } else { [EOL]         _propName = InternCache.instance.intern(propName); [EOL]     } [EOL]     _type = type; [EOL]     _wrapperName = wrapper; [EOL]     _isRequired = isRequired; [EOL]     _contextAnnotations = contextAnnotations; [EOL]     _viewMatcher = null; [EOL]     if (typeDeser != null) { [EOL]         typeDeser = typeDeser.forProperty(this); [EOL]     } [EOL]     _valueTypeDeserializer = typeDeser; [EOL]     _valueDeserializer = MISSING_VALUE_DESERIALIZER; [EOL] }
protected SettableBeanProperty(String propName, JavaType type, PropertyName wrapper, TypeDeserializer typeDeser, Annotations contextAnnotations, boolean isRequired) { [EOL]     if (propName == null || propName.length() == 0) { [EOL]         _propName = ""; [EOL]     } else { [EOL]         _propName = InternCache.instance.intern(propName); [EOL]     } [EOL]     _type = type; [EOL]     _wrapperName = wrapper; [EOL]     _isRequired = isRequired; [EOL]     _contextAnnotations = contextAnnotations; [EOL]     _viewMatcher = null; [EOL]     if (typeDeser != null) { [EOL]         typeDeser = typeDeser.forProperty(this); [EOL]     } [EOL]     _valueTypeDeserializer = typeDeser; [EOL]     _valueDeserializer = MISSING_VALUE_DESERIALIZER; [EOL] }
protected SettableBeanProperty(String propName, JavaType type, PropertyName wrapper, TypeDeserializer typeDeser, Annotations contextAnnotations, boolean isRequired) { [EOL]     if (propName == null || propName.length() == 0) { [EOL]         _propName = ""; [EOL]     } else { [EOL]         _propName = InternCache.instance.intern(propName); [EOL]     } [EOL]     _type = type; [EOL]     _wrapperName = wrapper; [EOL]     _isRequired = isRequired; [EOL]     _contextAnnotations = contextAnnotations; [EOL]     _viewMatcher = null; [EOL]     if (typeDeser != null) { [EOL]         typeDeser = typeDeser.forProperty(this); [EOL]     } [EOL]     _valueTypeDeserializer = typeDeser; [EOL]     _valueDeserializer = MISSING_VALUE_DESERIALIZER; [EOL] }
public ThrowableDeserializer(BeanDeserializer baseDeserializer) { [EOL]     super(baseDeserializer); [EOL]     _vanillaProcessing = false; [EOL] }
@Override [EOL] public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_propertyBasedCreator != null) { [EOL]         return _deserializeUsingPropertyBased(jp, ctxt); [EOL]     } [EOL]     if (_delegateDeserializer != null) { [EOL]         return _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]     } [EOL]     if (_beanType.isAbstract()) { [EOL]         throw JsonMappingException.from(jp, "Can not instantiate abstract type " + _beanType + " (need to add/enable type information?)"); [EOL]     } [EOL]     boolean hasStringCreator = _valueInstantiator.canCreateFromString(); [EOL]     boolean hasDefaultCtor = _valueInstantiator.canCreateUsingDefault(); [EOL]     if (!hasStringCreator && !hasDefaultCtor) { [EOL]         throw new JsonMappingException("Can not deserialize Throwable of type " + _beanType + " without having a default contructor, a single-String-arg constructor; or explicit @JsonCreator"); [EOL]     } [EOL]     Object throwable = null; [EOL]     Object[] pending = null; [EOL]     int pendingIx = 0; [EOL]     for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         jp.nextToken(); [EOL]         if (prop != null) { [EOL]             if (throwable != null) { [EOL]                 prop.deserializeAndSet(jp, ctxt, throwable); [EOL]                 continue; [EOL]             } [EOL]             if (pending == null) { [EOL]                 int len = _beanProperties.size(); [EOL]                 pending = new Object[len + len]; [EOL]             } [EOL]             pending[pendingIx++] = prop; [EOL]             pending[pendingIx++] = prop.deserialize(jp, ctxt); [EOL]             continue; [EOL]         } [EOL]         if (PROP_NAME_MESSAGE.equals(propName)) { [EOL]             if (hasStringCreator) { [EOL]                 throwable = _valueInstantiator.createFromString(ctxt, jp.getText()); [EOL]                 if (pending != null) { [EOL]                     for (int i = 0, len = pendingIx; i < len; i += 2) { [EOL]                         prop = (SettableBeanProperty) pending[i]; [EOL]                         prop.set(throwable, pending[i + 1]); [EOL]                     } [EOL]                     pending = null; [EOL]                 } [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]             continue; [EOL]         } [EOL]         if (_anySetter != null) { [EOL]             _anySetter.deserializeAndSet(jp, ctxt, throwable, propName); [EOL]             continue; [EOL]         } [EOL]         handleUnknownProperty(jp, ctxt, throwable, propName); [EOL]     } [EOL]     if (throwable == null) { [EOL]         if (hasStringCreator) { [EOL]             throwable = _valueInstantiator.createFromString(ctxt, null); [EOL]         } else { [EOL]             throwable = _valueInstantiator.createUsingDefault(ctxt); [EOL]         } [EOL]         if (pending != null) { [EOL]             for (int i = 0, len = pendingIx; i < len; i += 2) { [EOL]                 SettableBeanProperty prop = (SettableBeanProperty) pending[i]; [EOL]                 prop.set(throwable, pending[i + 1]); [EOL]             } [EOL]         } [EOL]     } [EOL]     return throwable; [EOL] }
@Override [EOL] public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_propertyBasedCreator != null) { [EOL]         return _deserializeUsingPropertyBased(jp, ctxt); [EOL]     } [EOL]     if (_delegateDeserializer != null) { [EOL]         return _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]     } [EOL]     if (_beanType.isAbstract()) { [EOL]         throw JsonMappingException.from(jp, "Can not instantiate abstract type " + _beanType + " (need to add/enable type information?)"); [EOL]     } [EOL]     boolean hasStringCreator = _valueInstantiator.canCreateFromString(); [EOL]     boolean hasDefaultCtor = _valueInstantiator.canCreateUsingDefault(); [EOL]     if (!hasStringCreator && !hasDefaultCtor) { [EOL]         throw new JsonMappingException("Can not deserialize Throwable of type " + _beanType + " without having a default contructor, a single-String-arg constructor; or explicit @JsonCreator"); [EOL]     } [EOL]     Object throwable = null; [EOL]     Object[] pending = null; [EOL]     int pendingIx = 0; [EOL]     for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         jp.nextToken(); [EOL]         if (prop != null) { [EOL]             if (throwable != null) { [EOL]                 prop.deserializeAndSet(jp, ctxt, throwable); [EOL]                 continue; [EOL]             } [EOL]             if (pending == null) { [EOL]                 int len = _beanProperties.size(); [EOL]                 pending = new Object[len + len]; [EOL]             } [EOL]             pending[pendingIx++] = prop; [EOL]             pending[pendingIx++] = prop.deserialize(jp, ctxt); [EOL]             continue; [EOL]         } [EOL]         if (PROP_NAME_MESSAGE.equals(propName)) { [EOL]             if (hasStringCreator) { [EOL]                 throwable = _valueInstantiator.createFromString(ctxt, jp.getText()); [EOL]                 if (pending != null) { [EOL]                     for (int i = 0, len = pendingIx; i < len; i += 2) { [EOL]                         prop = (SettableBeanProperty) pending[i]; [EOL]                         prop.set(throwable, pending[i + 1]); [EOL]                     } [EOL]                     pending = null; [EOL]                 } [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]             continue; [EOL]         } [EOL]         if (_anySetter != null) { [EOL]             _anySetter.deserializeAndSet(jp, ctxt, throwable, propName); [EOL]             continue; [EOL]         } [EOL]         handleUnknownProperty(jp, ctxt, throwable, propName); [EOL]     } [EOL]     if (throwable == null) { [EOL]         if (hasStringCreator) { [EOL]             throwable = _valueInstantiator.createFromString(ctxt, null); [EOL]         } else { [EOL]             throwable = _valueInstantiator.createUsingDefault(ctxt); [EOL]         } [EOL]         if (pending != null) { [EOL]             for (int i = 0, len = pendingIx; i < len; i += 2) { [EOL]                 SettableBeanProperty prop = (SettableBeanProperty) pending[i]; [EOL]                 prop.set(throwable, pending[i + 1]); [EOL]             } [EOL]         } [EOL]     } [EOL]     return throwable; [EOL] }
@Override [EOL] public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_propertyBasedCreator != null) { [EOL]         return _deserializeUsingPropertyBased(jp, ctxt); [EOL]     } [EOL]     if (_delegateDeserializer != null) { [EOL]         return _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]     } [EOL]     if (_beanType.isAbstract()) { [EOL]         throw JsonMappingException.from(jp, "Can not instantiate abstract type " + _beanType + " (need to add/enable type information?)"); [EOL]     } [EOL]     boolean hasStringCreator = _valueInstantiator.canCreateFromString(); [EOL]     boolean hasDefaultCtor = _valueInstantiator.canCreateUsingDefault(); [EOL]     if (!hasStringCreator && !hasDefaultCtor) { [EOL]         throw new JsonMappingException("Can not deserialize Throwable of type " + _beanType + " without having a default contructor, a single-String-arg constructor; or explicit @JsonCreator"); [EOL]     } [EOL]     Object throwable = null; [EOL]     Object[] pending = null; [EOL]     int pendingIx = 0; [EOL]     for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         jp.nextToken(); [EOL]         if (prop != null) { [EOL]             if (throwable != null) { [EOL]                 prop.deserializeAndSet(jp, ctxt, throwable); [EOL]                 continue; [EOL]             } [EOL]             if (pending == null) { [EOL]                 int len = _beanProperties.size(); [EOL]                 pending = new Object[len + len]; [EOL]             } [EOL]             pending[pendingIx++] = prop; [EOL]             pending[pendingIx++] = prop.deserialize(jp, ctxt); [EOL]             continue; [EOL]         } [EOL]         if (PROP_NAME_MESSAGE.equals(propName)) { [EOL]             if (hasStringCreator) { [EOL]                 throwable = _valueInstantiator.createFromString(ctxt, jp.getText()); [EOL]                 if (pending != null) { [EOL]                     for (int i = 0, len = pendingIx; i < len; i += 2) { [EOL]                         prop = (SettableBeanProperty) pending[i]; [EOL]                         prop.set(throwable, pending[i + 1]); [EOL]                     } [EOL]                     pending = null; [EOL]                 } [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]             continue; [EOL]         } [EOL]         if (_anySetter != null) { [EOL]             _anySetter.deserializeAndSet(jp, ctxt, throwable, propName); [EOL]             continue; [EOL]         } [EOL]         handleUnknownProperty(jp, ctxt, throwable, propName); [EOL]     } [EOL]     if (throwable == null) { [EOL]         if (hasStringCreator) { [EOL]             throwable = _valueInstantiator.createFromString(ctxt, null); [EOL]         } else { [EOL]             throwable = _valueInstantiator.createUsingDefault(ctxt); [EOL]         } [EOL]         if (pending != null) { [EOL]             for (int i = 0, len = pendingIx; i < len; i += 2) { [EOL]                 SettableBeanProperty prop = (SettableBeanProperty) pending[i]; [EOL]                 prop.set(throwable, pending[i + 1]); [EOL]             } [EOL]         } [EOL]     } [EOL]     return throwable; [EOL] }
@Override [EOL] public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_propertyBasedCreator != null) { [EOL]         return _deserializeUsingPropertyBased(jp, ctxt); [EOL]     } [EOL]     if (_delegateDeserializer != null) { [EOL]         return _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]     } [EOL]     if (_beanType.isAbstract()) { [EOL]         throw JsonMappingException.from(jp, "Can not instantiate abstract type " + _beanType + " (need to add/enable type information?)"); [EOL]     } [EOL]     boolean hasStringCreator = _valueInstantiator.canCreateFromString(); [EOL]     boolean hasDefaultCtor = _valueInstantiator.canCreateUsingDefault(); [EOL]     if (!hasStringCreator && !hasDefaultCtor) { [EOL]         throw new JsonMappingException("Can not deserialize Throwable of type " + _beanType + " without having a default contructor, a single-String-arg constructor; or explicit @JsonCreator"); [EOL]     } [EOL]     Object throwable = null; [EOL]     Object[] pending = null; [EOL]     int pendingIx = 0; [EOL]     for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         jp.nextToken(); [EOL]         if (prop != null) { [EOL]             if (throwable != null) { [EOL]                 prop.deserializeAndSet(jp, ctxt, throwable); [EOL]                 continue; [EOL]             } [EOL]             if (pending == null) { [EOL]                 int len = _beanProperties.size(); [EOL]                 pending = new Object[len + len]; [EOL]             } [EOL]             pending[pendingIx++] = prop; [EOL]             pending[pendingIx++] = prop.deserialize(jp, ctxt); [EOL]             continue; [EOL]         } [EOL]         if (PROP_NAME_MESSAGE.equals(propName)) { [EOL]             if (hasStringCreator) { [EOL]                 throwable = _valueInstantiator.createFromString(ctxt, jp.getText()); [EOL]                 if (pending != null) { [EOL]                     for (int i = 0, len = pendingIx; i < len; i += 2) { [EOL]                         prop = (SettableBeanProperty) pending[i]; [EOL]                         prop.set(throwable, pending[i + 1]); [EOL]                     } [EOL]                     pending = null; [EOL]                 } [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]             continue; [EOL]         } [EOL]         if (_anySetter != null) { [EOL]             _anySetter.deserializeAndSet(jp, ctxt, throwable, propName); [EOL]             continue; [EOL]         } [EOL]         handleUnknownProperty(jp, ctxt, throwable, propName); [EOL]     } [EOL]     if (throwable == null) { [EOL]         if (hasStringCreator) { [EOL]             throwable = _valueInstantiator.createFromString(ctxt, null); [EOL]         } else { [EOL]             throwable = _valueInstantiator.createUsingDefault(ctxt); [EOL]         } [EOL]         if (pending != null) { [EOL]             for (int i = 0, len = pendingIx; i < len; i += 2) { [EOL]                 SettableBeanProperty prop = (SettableBeanProperty) pending[i]; [EOL]                 prop.set(throwable, pending[i + 1]); [EOL]             } [EOL]         } [EOL]     } [EOL]     return throwable; [EOL] }
@Override [EOL] public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_propertyBasedCreator != null) { [EOL]         return _deserializeUsingPropertyBased(jp, ctxt); [EOL]     } [EOL]     if (_delegateDeserializer != null) { [EOL]         return _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]     } [EOL]     if (_beanType.isAbstract()) { [EOL]         throw JsonMappingException.from(jp, "Can not instantiate abstract type " + _beanType + " (need to add/enable type information?)"); [EOL]     } [EOL]     boolean hasStringCreator = _valueInstantiator.canCreateFromString(); [EOL]     boolean hasDefaultCtor = _valueInstantiator.canCreateUsingDefault(); [EOL]     if (!hasStringCreator && !hasDefaultCtor) { [EOL]         throw new JsonMappingException("Can not deserialize Throwable of type " + _beanType + " without having a default contructor, a single-String-arg constructor; or explicit @JsonCreator"); [EOL]     } [EOL]     Object throwable = null; [EOL]     Object[] pending = null; [EOL]     int pendingIx = 0; [EOL]     for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         jp.nextToken(); [EOL]         if (prop != null) { [EOL]             if (throwable != null) { [EOL]                 prop.deserializeAndSet(jp, ctxt, throwable); [EOL]                 continue; [EOL]             } [EOL]             if (pending == null) { [EOL]                 int len = _beanProperties.size(); [EOL]                 pending = new Object[len + len]; [EOL]             } [EOL]             pending[pendingIx++] = prop; [EOL]             pending[pendingIx++] = prop.deserialize(jp, ctxt); [EOL]             continue; [EOL]         } [EOL]         if (PROP_NAME_MESSAGE.equals(propName)) { [EOL]             if (hasStringCreator) { [EOL]                 throwable = _valueInstantiator.createFromString(ctxt, jp.getText()); [EOL]                 if (pending != null) { [EOL]                     for (int i = 0, len = pendingIx; i < len; i += 2) { [EOL]                         prop = (SettableBeanProperty) pending[i]; [EOL]                         prop.set(throwable, pending[i + 1]); [EOL]                     } [EOL]                     pending = null; [EOL]                 } [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]             continue; [EOL]         } [EOL]         if (_anySetter != null) { [EOL]             _anySetter.deserializeAndSet(jp, ctxt, throwable, propName); [EOL]             continue; [EOL]         } [EOL]         handleUnknownProperty(jp, ctxt, throwable, propName); [EOL]     } [EOL]     if (throwable == null) { [EOL]         if (hasStringCreator) { [EOL]             throwable = _valueInstantiator.createFromString(ctxt, null); [EOL]         } else { [EOL]             throwable = _valueInstantiator.createUsingDefault(ctxt); [EOL]         } [EOL]         if (pending != null) { [EOL]             for (int i = 0, len = pendingIx; i < len; i += 2) { [EOL]                 SettableBeanProperty prop = (SettableBeanProperty) pending[i]; [EOL]                 prop.set(throwable, pending[i + 1]); [EOL]             } [EOL]         } [EOL]     } [EOL]     return throwable; [EOL] }
@Override [EOL] public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_propertyBasedCreator != null) { [EOL]         return _deserializeUsingPropertyBased(jp, ctxt); [EOL]     } [EOL]     if (_delegateDeserializer != null) { [EOL]         return _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]     } [EOL]     if (_beanType.isAbstract()) { [EOL]         throw JsonMappingException.from(jp, "Can not instantiate abstract type " + _beanType + " (need to add/enable type information?)"); [EOL]     } [EOL]     boolean hasStringCreator = _valueInstantiator.canCreateFromString(); [EOL]     boolean hasDefaultCtor = _valueInstantiator.canCreateUsingDefault(); [EOL]     if (!hasStringCreator && !hasDefaultCtor) { [EOL]         throw new JsonMappingException("Can not deserialize Throwable of type " + _beanType + " without having a default contructor, a single-String-arg constructor; or explicit @JsonCreator"); [EOL]     } [EOL]     Object throwable = null; [EOL]     Object[] pending = null; [EOL]     int pendingIx = 0; [EOL]     for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         jp.nextToken(); [EOL]         if (prop != null) { [EOL]             if (throwable != null) { [EOL]                 prop.deserializeAndSet(jp, ctxt, throwable); [EOL]                 continue; [EOL]             } [EOL]             if (pending == null) { [EOL]                 int len = _beanProperties.size(); [EOL]                 pending = new Object[len + len]; [EOL]             } [EOL]             pending[pendingIx++] = prop; [EOL]             pending[pendingIx++] = prop.deserialize(jp, ctxt); [EOL]             continue; [EOL]         } [EOL]         if (PROP_NAME_MESSAGE.equals(propName)) { [EOL]             if (hasStringCreator) { [EOL]                 throwable = _valueInstantiator.createFromString(ctxt, jp.getText()); [EOL]                 if (pending != null) { [EOL]                     for (int i = 0, len = pendingIx; i < len; i += 2) { [EOL]                         prop = (SettableBeanProperty) pending[i]; [EOL]                         prop.set(throwable, pending[i + 1]); [EOL]                     } [EOL]                     pending = null; [EOL]                 } [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]             continue; [EOL]         } [EOL]         if (_anySetter != null) { [EOL]             _anySetter.deserializeAndSet(jp, ctxt, throwable, propName); [EOL]             continue; [EOL]         } [EOL]         handleUnknownProperty(jp, ctxt, throwable, propName); [EOL]     } [EOL]     if (throwable == null) { [EOL]         if (hasStringCreator) { [EOL]             throwable = _valueInstantiator.createFromString(ctxt, null); [EOL]         } else { [EOL]             throwable = _valueInstantiator.createUsingDefault(ctxt); [EOL]         } [EOL]         if (pending != null) { [EOL]             for (int i = 0, len = pendingIx; i < len; i += 2) { [EOL]                 SettableBeanProperty prop = (SettableBeanProperty) pending[i]; [EOL]                 prop.set(throwable, pending[i + 1]); [EOL]             } [EOL]         } [EOL]     } [EOL]     return throwable; [EOL] }
@Override [EOL] public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_propertyBasedCreator != null) { [EOL]         return _deserializeUsingPropertyBased(jp, ctxt); [EOL]     } [EOL]     if (_delegateDeserializer != null) { [EOL]         return _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]     } [EOL]     if (_beanType.isAbstract()) { [EOL]         throw JsonMappingException.from(jp, "Can not instantiate abstract type " + _beanType + " (need to add/enable type information?)"); [EOL]     } [EOL]     boolean hasStringCreator = _valueInstantiator.canCreateFromString(); [EOL]     boolean hasDefaultCtor = _valueInstantiator.canCreateUsingDefault(); [EOL]     if (!hasStringCreator && !hasDefaultCtor) { [EOL]         throw new JsonMappingException("Can not deserialize Throwable of type " + _beanType + " without having a default contructor, a single-String-arg constructor; or explicit @JsonCreator"); [EOL]     } [EOL]     Object throwable = null; [EOL]     Object[] pending = null; [EOL]     int pendingIx = 0; [EOL]     for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         jp.nextToken(); [EOL]         if (prop != null) { [EOL]             if (throwable != null) { [EOL]                 prop.deserializeAndSet(jp, ctxt, throwable); [EOL]                 continue; [EOL]             } [EOL]             if (pending == null) { [EOL]                 int len = _beanProperties.size(); [EOL]                 pending = new Object[len + len]; [EOL]             } [EOL]             pending[pendingIx++] = prop; [EOL]             pending[pendingIx++] = prop.deserialize(jp, ctxt); [EOL]             continue; [EOL]         } [EOL]         if (PROP_NAME_MESSAGE.equals(propName)) { [EOL]             if (hasStringCreator) { [EOL]                 throwable = _valueInstantiator.createFromString(ctxt, jp.getText()); [EOL]                 if (pending != null) { [EOL]                     for (int i = 0, len = pendingIx; i < len; i += 2) { [EOL]                         prop = (SettableBeanProperty) pending[i]; [EOL]                         prop.set(throwable, pending[i + 1]); [EOL]                     } [EOL]                     pending = null; [EOL]                 } [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]             continue; [EOL]         } [EOL]         if (_anySetter != null) { [EOL]             _anySetter.deserializeAndSet(jp, ctxt, throwable, propName); [EOL]             continue; [EOL]         } [EOL]         handleUnknownProperty(jp, ctxt, throwable, propName); [EOL]     } [EOL]     if (throwable == null) { [EOL]         if (hasStringCreator) { [EOL]             throwable = _valueInstantiator.createFromString(ctxt, null); [EOL]         } else { [EOL]             throwable = _valueInstantiator.createUsingDefault(ctxt); [EOL]         } [EOL]         if (pending != null) { [EOL]             for (int i = 0, len = pendingIx; i < len; i += 2) { [EOL]                 SettableBeanProperty prop = (SettableBeanProperty) pending[i]; [EOL]                 prop.set(throwable, pending[i + 1]); [EOL]             } [EOL]         } [EOL]     } [EOL]     return throwable; [EOL] }
@Override [EOL] public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_propertyBasedCreator != null) { [EOL]         return _deserializeUsingPropertyBased(jp, ctxt); [EOL]     } [EOL]     if (_delegateDeserializer != null) { [EOL]         return _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]     } [EOL]     if (_beanType.isAbstract()) { [EOL]         throw JsonMappingException.from(jp, "Can not instantiate abstract type " + _beanType + " (need to add/enable type information?)"); [EOL]     } [EOL]     boolean hasStringCreator = _valueInstantiator.canCreateFromString(); [EOL]     boolean hasDefaultCtor = _valueInstantiator.canCreateUsingDefault(); [EOL]     if (!hasStringCreator && !hasDefaultCtor) { [EOL]         throw new JsonMappingException("Can not deserialize Throwable of type " + _beanType + " without having a default contructor, a single-String-arg constructor; or explicit @JsonCreator"); [EOL]     } [EOL]     Object throwable = null; [EOL]     Object[] pending = null; [EOL]     int pendingIx = 0; [EOL]     for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         jp.nextToken(); [EOL]         if (prop != null) { [EOL]             if (throwable != null) { [EOL]                 prop.deserializeAndSet(jp, ctxt, throwable); [EOL]                 continue; [EOL]             } [EOL]             if (pending == null) { [EOL]                 int len = _beanProperties.size(); [EOL]                 pending = new Object[len + len]; [EOL]             } [EOL]             pending[pendingIx++] = prop; [EOL]             pending[pendingIx++] = prop.deserialize(jp, ctxt); [EOL]             continue; [EOL]         } [EOL]         if (PROP_NAME_MESSAGE.equals(propName)) { [EOL]             if (hasStringCreator) { [EOL]                 throwable = _valueInstantiator.createFromString(ctxt, jp.getText()); [EOL]                 if (pending != null) { [EOL]                     for (int i = 0, len = pendingIx; i < len; i += 2) { [EOL]                         prop = (SettableBeanProperty) pending[i]; [EOL]                         prop.set(throwable, pending[i + 1]); [EOL]                     } [EOL]                     pending = null; [EOL]                 } [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]             continue; [EOL]         } [EOL]         if (_anySetter != null) { [EOL]             _anySetter.deserializeAndSet(jp, ctxt, throwable, propName); [EOL]             continue; [EOL]         } [EOL]         handleUnknownProperty(jp, ctxt, throwable, propName); [EOL]     } [EOL]     if (throwable == null) { [EOL]         if (hasStringCreator) { [EOL]             throwable = _valueInstantiator.createFromString(ctxt, null); [EOL]         } else { [EOL]             throwable = _valueInstantiator.createUsingDefault(ctxt); [EOL]         } [EOL]         if (pending != null) { [EOL]             for (int i = 0, len = pendingIx; i < len; i += 2) { [EOL]                 SettableBeanProperty prop = (SettableBeanProperty) pending[i]; [EOL]                 prop.set(throwable, pending[i + 1]); [EOL]             } [EOL]         } [EOL]     } [EOL]     return throwable; [EOL] }
@Override [EOL] public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_propertyBasedCreator != null) { [EOL]         return _deserializeUsingPropertyBased(jp, ctxt); [EOL]     } [EOL]     if (_delegateDeserializer != null) { [EOL]         return _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]     } [EOL]     if (_beanType.isAbstract()) { [EOL]         throw JsonMappingException.from(jp, "Can not instantiate abstract type " + _beanType + " (need to add/enable type information?)"); [EOL]     } [EOL]     boolean hasStringCreator = _valueInstantiator.canCreateFromString(); [EOL]     boolean hasDefaultCtor = _valueInstantiator.canCreateUsingDefault(); [EOL]     if (!hasStringCreator && !hasDefaultCtor) { [EOL]         throw new JsonMappingException("Can not deserialize Throwable of type " + _beanType + " without having a default contructor, a single-String-arg constructor; or explicit @JsonCreator"); [EOL]     } [EOL]     Object throwable = null; [EOL]     Object[] pending = null; [EOL]     int pendingIx = 0; [EOL]     for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         jp.nextToken(); [EOL]         if (prop != null) { [EOL]             if (throwable != null) { [EOL]                 prop.deserializeAndSet(jp, ctxt, throwable); [EOL]                 continue; [EOL]             } [EOL]             if (pending == null) { [EOL]                 int len = _beanProperties.size(); [EOL]                 pending = new Object[len + len]; [EOL]             } [EOL]             pending[pendingIx++] = prop; [EOL]             pending[pendingIx++] = prop.deserialize(jp, ctxt); [EOL]             continue; [EOL]         } [EOL]         if (PROP_NAME_MESSAGE.equals(propName)) { [EOL]             if (hasStringCreator) { [EOL]                 throwable = _valueInstantiator.createFromString(ctxt, jp.getText()); [EOL]                 if (pending != null) { [EOL]                     for (int i = 0, len = pendingIx; i < len; i += 2) { [EOL]                         prop = (SettableBeanProperty) pending[i]; [EOL]                         prop.set(throwable, pending[i + 1]); [EOL]                     } [EOL]                     pending = null; [EOL]                 } [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]             continue; [EOL]         } [EOL]         if (_anySetter != null) { [EOL]             _anySetter.deserializeAndSet(jp, ctxt, throwable, propName); [EOL]             continue; [EOL]         } [EOL]         handleUnknownProperty(jp, ctxt, throwable, propName); [EOL]     } [EOL]     if (throwable == null) { [EOL]         if (hasStringCreator) { [EOL]             throwable = _valueInstantiator.createFromString(ctxt, null); [EOL]         } else { [EOL]             throwable = _valueInstantiator.createUsingDefault(ctxt); [EOL]         } [EOL]         if (pending != null) { [EOL]             for (int i = 0, len = pendingIx; i < len; i += 2) { [EOL]                 SettableBeanProperty prop = (SettableBeanProperty) pending[i]; [EOL]                 prop.set(throwable, pending[i + 1]); [EOL]             } [EOL]         } [EOL]     } [EOL]     return throwable; [EOL] }
@Override [EOL] public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_propertyBasedCreator != null) { [EOL]         return _deserializeUsingPropertyBased(jp, ctxt); [EOL]     } [EOL]     if (_delegateDeserializer != null) { [EOL]         return _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]     } [EOL]     if (_beanType.isAbstract()) { [EOL]         throw JsonMappingException.from(jp, "Can not instantiate abstract type " + _beanType + " (need to add/enable type information?)"); [EOL]     } [EOL]     boolean hasStringCreator = _valueInstantiator.canCreateFromString(); [EOL]     boolean hasDefaultCtor = _valueInstantiator.canCreateUsingDefault(); [EOL]     if (!hasStringCreator && !hasDefaultCtor) { [EOL]         throw new JsonMappingException("Can not deserialize Throwable of type " + _beanType + " without having a default contructor, a single-String-arg constructor; or explicit @JsonCreator"); [EOL]     } [EOL]     Object throwable = null; [EOL]     Object[] pending = null; [EOL]     int pendingIx = 0; [EOL]     for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         jp.nextToken(); [EOL]         if (prop != null) { [EOL]             if (throwable != null) { [EOL]                 prop.deserializeAndSet(jp, ctxt, throwable); [EOL]                 continue; [EOL]             } [EOL]             if (pending == null) { [EOL]                 int len = _beanProperties.size(); [EOL]                 pending = new Object[len + len]; [EOL]             } [EOL]             pending[pendingIx++] = prop; [EOL]             pending[pendingIx++] = prop.deserialize(jp, ctxt); [EOL]             continue; [EOL]         } [EOL]         if (PROP_NAME_MESSAGE.equals(propName)) { [EOL]             if (hasStringCreator) { [EOL]                 throwable = _valueInstantiator.createFromString(ctxt, jp.getText()); [EOL]                 if (pending != null) { [EOL]                     for (int i = 0, len = pendingIx; i < len; i += 2) { [EOL]                         prop = (SettableBeanProperty) pending[i]; [EOL]                         prop.set(throwable, pending[i + 1]); [EOL]                     } [EOL]                     pending = null; [EOL]                 } [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]             continue; [EOL]         } [EOL]         if (_anySetter != null) { [EOL]             _anySetter.deserializeAndSet(jp, ctxt, throwable, propName); [EOL]             continue; [EOL]         } [EOL]         handleUnknownProperty(jp, ctxt, throwable, propName); [EOL]     } [EOL]     if (throwable == null) { [EOL]         if (hasStringCreator) { [EOL]             throwable = _valueInstantiator.createFromString(ctxt, null); [EOL]         } else { [EOL]             throwable = _valueInstantiator.createUsingDefault(ctxt); [EOL]         } [EOL]         if (pending != null) { [EOL]             for (int i = 0, len = pendingIx; i < len; i += 2) { [EOL]                 SettableBeanProperty prop = (SettableBeanProperty) pending[i]; [EOL]                 prop.set(throwable, pending[i + 1]); [EOL]             } [EOL]         } [EOL]     } [EOL]     return throwable; [EOL] }
@Override [EOL] public Object getValue(Object pojo) throws IllegalArgumentException { [EOL]     try { [EOL]         return _field.get(pojo); [EOL]     } catch (IllegalAccessException e) { [EOL]         throw new IllegalArgumentException("Failed to getValue() for field " + getFullName() + ": " + e.getMessage(), e); [EOL]     } [EOL] }
@Override [EOL] public Object getValue(Object pojo) throws IllegalArgumentException { [EOL]     try { [EOL]         return _field.get(pojo); [EOL]     } catch (IllegalAccessException e) { [EOL]         throw new IllegalArgumentException("Failed to getValue() for field " + getFullName() + ": " + e.getMessage(), e); [EOL]     } [EOL] }
public ManagedReferenceProperty(SettableBeanProperty forward, String refName, SettableBeanProperty backward, Annotations contextAnnotations, boolean isContainer) { [EOL]     super(forward.getName(), forward.getType(), forward.getWrapperName(), forward.getValueTypeDeserializer(), contextAnnotations, forward.isRequired()); [EOL]     _referenceName = refName; [EOL]     _managedProperty = forward; [EOL]     _backProperty = backward; [EOL]     _isContainer = isContainer; [EOL] }
public ManagedReferenceProperty(SettableBeanProperty forward, String refName, SettableBeanProperty backward, Annotations contextAnnotations, boolean isContainer) { [EOL]     super(forward.getName(), forward.getType(), forward.getWrapperName(), forward.getValueTypeDeserializer(), contextAnnotations, forward.isRequired()); [EOL]     _referenceName = refName; [EOL]     _managedProperty = forward; [EOL]     _backProperty = backward; [EOL]     _isContainer = isContainer; [EOL] }
@Override [EOL] public AnnotatedMember getMember() { [EOL]     return _managedProperty.getMember(); [EOL] }
@Override [EOL] public AnnotatedMember getMember() { [EOL]     return _managedProperty.getMember(); [EOL] }
@Override [EOL] public void deserializeAndSet(JsonParser jp, DeserializationContext ctxt, Object instance) throws IOException, JsonProcessingException { [EOL]     set(instance, _managedProperty.deserialize(jp, ctxt)); [EOL] }
@Override [EOL] public void deserializeAndSet(JsonParser jp, DeserializationContext ctxt, Object instance) throws IOException, JsonProcessingException { [EOL]     set(instance, _managedProperty.deserialize(jp, ctxt)); [EOL] }
@Override [EOL] public final void set(Object instance, Object value) throws IOException { [EOL]     setAndReturn(instance, value); [EOL] }
@Override [EOL] public final void set(Object instance, Object value) throws IOException { [EOL]     setAndReturn(instance, value); [EOL] }
@Override [EOL] public final void set(Object instance, Object value) throws IOException { [EOL]     setAndReturn(instance, value); [EOL] }
@Override [EOL] public Object setAndReturn(Object instance, Object value) throws IOException { [EOL]     Object result = _managedProperty.setAndReturn(instance, value); [EOL]     if (value != null) { [EOL]         if (_isContainer) { [EOL]             if (value instanceof Object[]) { [EOL]                 for (Object ob : (Object[]) value) { [EOL]                     if (ob != null) { [EOL]                         _backProperty.set(ob, instance); [EOL]                     } [EOL]                 } [EOL]             } else if (value instanceof Collection<?>) { [EOL]                 for (Object ob : (Collection<?>) value) { [EOL]                     if (ob != null) { [EOL]                         _backProperty.set(ob, instance); [EOL]                     } [EOL]                 } [EOL]             } else if (value instanceof Map<?, ?>) { [EOL]                 for (Object ob : ((Map<?, ?>) value).values()) { [EOL]                     if (ob != null) { [EOL]                         _backProperty.set(ob, instance); [EOL]                     } [EOL]                 } [EOL]             } else { [EOL]                 throw new IllegalStateException("Unsupported container type (" + value.getClass().getName() + ") when resolving reference '" + _referenceName + "'"); [EOL]             } [EOL]         } else { [EOL]             _backProperty.set(value, instance); [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
@Override [EOL] public Object setAndReturn(Object instance, Object value) throws IOException { [EOL]     Object result = _managedProperty.setAndReturn(instance, value); [EOL]     if (value != null) { [EOL]         if (_isContainer) { [EOL]             if (value instanceof Object[]) { [EOL]                 for (Object ob : (Object[]) value) { [EOL]                     if (ob != null) { [EOL]                         _backProperty.set(ob, instance); [EOL]                     } [EOL]                 } [EOL]             } else if (value instanceof Collection<?>) { [EOL]                 for (Object ob : (Collection<?>) value) { [EOL]                     if (ob != null) { [EOL]                         _backProperty.set(ob, instance); [EOL]                     } [EOL]                 } [EOL]             } else if (value instanceof Map<?, ?>) { [EOL]                 for (Object ob : ((Map<?, ?>) value).values()) { [EOL]                     if (ob != null) { [EOL]                         _backProperty.set(ob, instance); [EOL]                     } [EOL]                 } [EOL]             } else { [EOL]                 throw new IllegalStateException("Unsupported container type (" + value.getClass().getName() + ") when resolving reference '" + _referenceName + "'"); [EOL]             } [EOL]         } else { [EOL]             _backProperty.set(value, instance); [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
@Override [EOL] public Object setAndReturn(Object instance, Object value) throws IOException { [EOL]     Object result = _managedProperty.setAndReturn(instance, value); [EOL]     if (value != null) { [EOL]         if (_isContainer) { [EOL]             if (value instanceof Object[]) { [EOL]                 for (Object ob : (Object[]) value) { [EOL]                     if (ob != null) { [EOL]                         _backProperty.set(ob, instance); [EOL]                     } [EOL]                 } [EOL]             } else if (value instanceof Collection<?>) { [EOL]                 for (Object ob : (Collection<?>) value) { [EOL]                     if (ob != null) { [EOL]                         _backProperty.set(ob, instance); [EOL]                     } [EOL]                 } [EOL]             } else if (value instanceof Map<?, ?>) { [EOL]                 for (Object ob : ((Map<?, ?>) value).values()) { [EOL]                     if (ob != null) { [EOL]                         _backProperty.set(ob, instance); [EOL]                     } [EOL]                 } [EOL]             } else { [EOL]                 throw new IllegalStateException("Unsupported container type (" + value.getClass().getName() + ") when resolving reference '" + _referenceName + "'"); [EOL]             } [EOL]         } else { [EOL]             _backProperty.set(value, instance); [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
@Override [EOL] public Object setAndReturn(Object instance, Object value) throws IOException { [EOL]     Object result = _managedProperty.setAndReturn(instance, value); [EOL]     if (value != null) { [EOL]         if (_isContainer) { [EOL]             if (value instanceof Object[]) { [EOL]                 for (Object ob : (Object[]) value) { [EOL]                     if (ob != null) { [EOL]                         _backProperty.set(ob, instance); [EOL]                     } [EOL]                 } [EOL]             } else if (value instanceof Collection<?>) { [EOL]                 for (Object ob : (Collection<?>) value) { [EOL]                     if (ob != null) { [EOL]                         _backProperty.set(ob, instance); [EOL]                     } [EOL]                 } [EOL]             } else if (value instanceof Map<?, ?>) { [EOL]                 for (Object ob : ((Map<?, ?>) value).values()) { [EOL]                     if (ob != null) { [EOL]                         _backProperty.set(ob, instance); [EOL]                     } [EOL]                 } [EOL]             } else { [EOL]                 throw new IllegalStateException("Unsupported container type (" + value.getClass().getName() + ") when resolving reference '" + _referenceName + "'"); [EOL]             } [EOL]         } else { [EOL]             _backProperty.set(value, instance); [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
@Override [EOL] public Object setAndReturn(Object instance, Object value) throws IOException { [EOL]     Object result = _managedProperty.setAndReturn(instance, value); [EOL]     if (value != null) { [EOL]         if (_isContainer) { [EOL]             if (value instanceof Object[]) { [EOL]                 for (Object ob : (Object[]) value) { [EOL]                     if (ob != null) { [EOL]                         _backProperty.set(ob, instance); [EOL]                     } [EOL]                 } [EOL]             } else if (value instanceof Collection<?>) { [EOL]                 for (Object ob : (Collection<?>) value) { [EOL]                     if (ob != null) { [EOL]                         _backProperty.set(ob, instance); [EOL]                     } [EOL]                 } [EOL]             } else if (value instanceof Map<?, ?>) { [EOL]                 for (Object ob : ((Map<?, ?>) value).values()) { [EOL]                     if (ob != null) { [EOL]                         _backProperty.set(ob, instance); [EOL]                     } [EOL]                 } [EOL]             } else { [EOL]                 throw new IllegalStateException("Unsupported container type (" + value.getClass().getName() + ") when resolving reference '" + _referenceName + "'"); [EOL]             } [EOL]         } else { [EOL]             _backProperty.set(value, instance); [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
@Override [EOL] public Object setAndReturn(Object instance, Object value) throws IOException { [EOL]     Object result = _managedProperty.setAndReturn(instance, value); [EOL]     if (value != null) { [EOL]         if (_isContainer) { [EOL]             if (value instanceof Object[]) { [EOL]                 for (Object ob : (Object[]) value) { [EOL]                     if (ob != null) { [EOL]                         _backProperty.set(ob, instance); [EOL]                     } [EOL]                 } [EOL]             } else if (value instanceof Collection<?>) { [EOL]                 for (Object ob : (Collection<?>) value) { [EOL]                     if (ob != null) { [EOL]                         _backProperty.set(ob, instance); [EOL]                     } [EOL]                 } [EOL]             } else if (value instanceof Map<?, ?>) { [EOL]                 for (Object ob : ((Map<?, ?>) value).values()) { [EOL]                     if (ob != null) { [EOL]                         _backProperty.set(ob, instance); [EOL]                     } [EOL]                 } [EOL]             } else { [EOL]                 throw new IllegalStateException("Unsupported container type (" + value.getClass().getName() + ") when resolving reference '" + _referenceName + "'"); [EOL]             } [EOL]         } else { [EOL]             _backProperty.set(value, instance); [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
public BeanSerializer(JavaType type, BeanSerializerBuilder builder, BeanPropertyWriter[] properties, BeanPropertyWriter[] filteredProperties) { [EOL]     super(type, builder, properties, filteredProperties); [EOL] }
public BeanSerializer(JavaType type, BeanSerializerBuilder builder, BeanPropertyWriter[] properties, BeanPropertyWriter[] filteredProperties) { [EOL]     super(type, builder, properties, filteredProperties); [EOL] }
public static BeanSerializer createDummy(JavaType forType) { [EOL]     return new BeanSerializer(forType, null, NO_PROPS, null); [EOL] }
public static BeanSerializer createDummy(JavaType forType) { [EOL]     return new BeanSerializer(forType, null, NO_PROPS, null); [EOL] }
@Override [EOL] public JsonSerializer<Object> unwrappingSerializer(NameTransformer unwrapper) { [EOL]     return new UnwrappingBeanSerializer(this, unwrapper); [EOL] }
@Override [EOL] public JsonSerializer<Object> unwrappingSerializer(NameTransformer unwrapper) { [EOL]     return new UnwrappingBeanSerializer(this, unwrapper); [EOL] }
@Override [EOL] public final void serialize(Object bean, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (_objectIdWriter != null) { [EOL]         _serializeWithObjectId(bean, jgen, provider, true); [EOL]         return; [EOL]     } [EOL]     jgen.writeStartObject(); [EOL]     if (_propertyFilterId != null) { [EOL]         serializeFieldsFiltered(bean, jgen, provider); [EOL]     } else { [EOL]         serializeFields(bean, jgen, provider); [EOL]     } [EOL]     jgen.writeEndObject(); [EOL] }
public boolean handleTypePropertyValue(JsonParser jp, DeserializationContext ctxt, String propName, Object bean) throws IOException, JsonProcessingException { [EOL]     Integer I = _nameToPropertyIndex.get(propName); [EOL]     if (I == null) { [EOL]         return false; [EOL]     } [EOL]     int index = I.intValue(); [EOL]     ExtTypedProperty prop = _properties[index]; [EOL]     if (!prop.hasTypePropertyName(propName)) { [EOL]         return false; [EOL]     } [EOL]     String typeId = jp.getText(); [EOL]     boolean canDeserialize = (bean != null) && (_tokens[index] != null); [EOL]     if (canDeserialize) { [EOL]         _deserializeAndSet(jp, ctxt, bean, index, typeId); [EOL]         _tokens[index] = null; [EOL]     } else { [EOL]         _typeIds[index] = typeId; [EOL]     } [EOL]     return true; [EOL] }
public boolean handleTypePropertyValue(JsonParser jp, DeserializationContext ctxt, String propName, Object bean) throws IOException, JsonProcessingException { [EOL]     Integer I = _nameToPropertyIndex.get(propName); [EOL]     if (I == null) { [EOL]         return false; [EOL]     } [EOL]     int index = I.intValue(); [EOL]     ExtTypedProperty prop = _properties[index]; [EOL]     if (!prop.hasTypePropertyName(propName)) { [EOL]         return false; [EOL]     } [EOL]     String typeId = jp.getText(); [EOL]     boolean canDeserialize = (bean != null) && (_tokens[index] != null); [EOL]     if (canDeserialize) { [EOL]         _deserializeAndSet(jp, ctxt, bean, index, typeId); [EOL]         _tokens[index] = null; [EOL]     } else { [EOL]         _typeIds[index] = typeId; [EOL]     } [EOL]     return true; [EOL] }
public boolean handleTypePropertyValue(JsonParser jp, DeserializationContext ctxt, String propName, Object bean) throws IOException, JsonProcessingException { [EOL]     Integer I = _nameToPropertyIndex.get(propName); [EOL]     if (I == null) { [EOL]         return false; [EOL]     } [EOL]     int index = I.intValue(); [EOL]     ExtTypedProperty prop = _properties[index]; [EOL]     if (!prop.hasTypePropertyName(propName)) { [EOL]         return false; [EOL]     } [EOL]     String typeId = jp.getText(); [EOL]     boolean canDeserialize = (bean != null) && (_tokens[index] != null); [EOL]     if (canDeserialize) { [EOL]         _deserializeAndSet(jp, ctxt, bean, index, typeId); [EOL]         _tokens[index] = null; [EOL]     } else { [EOL]         _typeIds[index] = typeId; [EOL]     } [EOL]     return true; [EOL] }
public boolean handleTypePropertyValue(JsonParser jp, DeserializationContext ctxt, String propName, Object bean) throws IOException, JsonProcessingException { [EOL]     Integer I = _nameToPropertyIndex.get(propName); [EOL]     if (I == null) { [EOL]         return false; [EOL]     } [EOL]     int index = I.intValue(); [EOL]     ExtTypedProperty prop = _properties[index]; [EOL]     if (!prop.hasTypePropertyName(propName)) { [EOL]         return false; [EOL]     } [EOL]     String typeId = jp.getText(); [EOL]     boolean canDeserialize = (bean != null) && (_tokens[index] != null); [EOL]     if (canDeserialize) { [EOL]         _deserializeAndSet(jp, ctxt, bean, index, typeId); [EOL]         _tokens[index] = null; [EOL]     } else { [EOL]         _typeIds[index] = typeId; [EOL]     } [EOL]     return true; [EOL] }
public Base64Variant getBase64Variant() { [EOL]     return _base.getBase64Variant(); [EOL] }
public Base64Variant getBase64Variant() { [EOL]     return _base.getBase64Variant(); [EOL] }
public Object nullValue(DeserializationContext ctxt) throws JsonProcessingException { [EOL]     if (_isPrimitive && ctxt.isEnabled(DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES)) { [EOL]         throw ctxt.mappingException("Can not map JSON null into type " + _rawType.getName() + " (set DeserializationConfig.DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES to 'false' to allow)"); [EOL]     } [EOL]     return _nullValue; [EOL] }
public Object nullValue(DeserializationContext ctxt) throws JsonProcessingException { [EOL]     if (_isPrimitive && ctxt.isEnabled(DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES)) { [EOL]         throw ctxt.mappingException("Can not map JSON null into type " + _rawType.getName() + " (set DeserializationConfig.DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES to 'false' to allow)"); [EOL]     } [EOL]     return _nullValue; [EOL] }
public Object nullValue(DeserializationContext ctxt) throws JsonProcessingException { [EOL]     if (_isPrimitive && ctxt.isEnabled(DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES)) { [EOL]         throw ctxt.mappingException("Can not map JSON null into type " + _rawType.getName() + " (set DeserializationConfig.DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES to 'false' to allow)"); [EOL]     } [EOL]     return _nullValue; [EOL] }
@Override [EOL] public String toString() { [EOL]     return asText(); [EOL] }
@Override [EOL] public final JsonNode findValue(String fieldName) { [EOL]     return null; [EOL] }
@Override [EOL] public final ObjectNode findParent(String fieldName) { [EOL]     return null; [EOL] }
@Override [EOL] public Collection<NamedType> collectAndResolveSubtypes(AnnotatedMember property, MapperConfig<?> config, AnnotationIntrospector ai, JavaType baseType) { [EOL]     Class<?> rawBase = (baseType == null) ? property.getRawType() : baseType.getRawClass(); [EOL]     HashMap<NamedType, NamedType> collected = new HashMap<NamedType, NamedType>(); [EOL]     if (_registeredSubtypes != null) { [EOL]         for (NamedType subtype : _registeredSubtypes) { [EOL]             if (rawBase.isAssignableFrom(subtype.getType())) { [EOL]                 AnnotatedClass curr = AnnotatedClass.constructWithoutSuperTypes(subtype.getType(), ai, config); [EOL]                 _collectAndResolve(curr, subtype, config, ai, collected); [EOL]             } [EOL]         } [EOL]     } [EOL]     Collection<NamedType> st = ai.findSubtypes(property); [EOL]     if (st != null) { [EOL]         for (NamedType nt : st) { [EOL]             AnnotatedClass ac = AnnotatedClass.constructWithoutSuperTypes(nt.getType(), ai, config); [EOL]             _collectAndResolve(ac, nt, config, ai, collected); [EOL]         } [EOL]     } [EOL]     NamedType rootType = new NamedType(rawBase, null); [EOL]     AnnotatedClass ac = AnnotatedClass.constructWithoutSuperTypes(rawBase, ai, config); [EOL]     _collectAndResolve(ac, rootType, config, ai, collected); [EOL]     return new ArrayList<NamedType>(collected.values()); [EOL] }
@Override [EOL] public Collection<NamedType> collectAndResolveSubtypes(AnnotatedMember property, MapperConfig<?> config, AnnotationIntrospector ai, JavaType baseType) { [EOL]     Class<?> rawBase = (baseType == null) ? property.getRawType() : baseType.getRawClass(); [EOL]     HashMap<NamedType, NamedType> collected = new HashMap<NamedType, NamedType>(); [EOL]     if (_registeredSubtypes != null) { [EOL]         for (NamedType subtype : _registeredSubtypes) { [EOL]             if (rawBase.isAssignableFrom(subtype.getType())) { [EOL]                 AnnotatedClass curr = AnnotatedClass.constructWithoutSuperTypes(subtype.getType(), ai, config); [EOL]                 _collectAndResolve(curr, subtype, config, ai, collected); [EOL]             } [EOL]         } [EOL]     } [EOL]     Collection<NamedType> st = ai.findSubtypes(property); [EOL]     if (st != null) { [EOL]         for (NamedType nt : st) { [EOL]             AnnotatedClass ac = AnnotatedClass.constructWithoutSuperTypes(nt.getType(), ai, config); [EOL]             _collectAndResolve(ac, nt, config, ai, collected); [EOL]         } [EOL]     } [EOL]     NamedType rootType = new NamedType(rawBase, null); [EOL]     AnnotatedClass ac = AnnotatedClass.constructWithoutSuperTypes(rawBase, ai, config); [EOL]     _collectAndResolve(ac, rootType, config, ai, collected); [EOL]     return new ArrayList<NamedType>(collected.values()); [EOL] }
@Override [EOL] public Collection<NamedType> collectAndResolveSubtypes(AnnotatedMember property, MapperConfig<?> config, AnnotationIntrospector ai, JavaType baseType) { [EOL]     Class<?> rawBase = (baseType == null) ? property.getRawType() : baseType.getRawClass(); [EOL]     HashMap<NamedType, NamedType> collected = new HashMap<NamedType, NamedType>(); [EOL]     if (_registeredSubtypes != null) { [EOL]         for (NamedType subtype : _registeredSubtypes) { [EOL]             if (rawBase.isAssignableFrom(subtype.getType())) { [EOL]                 AnnotatedClass curr = AnnotatedClass.constructWithoutSuperTypes(subtype.getType(), ai, config); [EOL]                 _collectAndResolve(curr, subtype, config, ai, collected); [EOL]             } [EOL]         } [EOL]     } [EOL]     Collection<NamedType> st = ai.findSubtypes(property); [EOL]     if (st != null) { [EOL]         for (NamedType nt : st) { [EOL]             AnnotatedClass ac = AnnotatedClass.constructWithoutSuperTypes(nt.getType(), ai, config); [EOL]             _collectAndResolve(ac, nt, config, ai, collected); [EOL]         } [EOL]     } [EOL]     NamedType rootType = new NamedType(rawBase, null); [EOL]     AnnotatedClass ac = AnnotatedClass.constructWithoutSuperTypes(rawBase, ai, config); [EOL]     _collectAndResolve(ac, rootType, config, ai, collected); [EOL]     return new ArrayList<NamedType>(collected.values()); [EOL] }
@Override [EOL] public Collection<NamedType> collectAndResolveSubtypes(AnnotatedMember property, MapperConfig<?> config, AnnotationIntrospector ai, JavaType baseType) { [EOL]     Class<?> rawBase = (baseType == null) ? property.getRawType() : baseType.getRawClass(); [EOL]     HashMap<NamedType, NamedType> collected = new HashMap<NamedType, NamedType>(); [EOL]     if (_registeredSubtypes != null) { [EOL]         for (NamedType subtype : _registeredSubtypes) { [EOL]             if (rawBase.isAssignableFrom(subtype.getType())) { [EOL]                 AnnotatedClass curr = AnnotatedClass.constructWithoutSuperTypes(subtype.getType(), ai, config); [EOL]                 _collectAndResolve(curr, subtype, config, ai, collected); [EOL]             } [EOL]         } [EOL]     } [EOL]     Collection<NamedType> st = ai.findSubtypes(property); [EOL]     if (st != null) { [EOL]         for (NamedType nt : st) { [EOL]             AnnotatedClass ac = AnnotatedClass.constructWithoutSuperTypes(nt.getType(), ai, config); [EOL]             _collectAndResolve(ac, nt, config, ai, collected); [EOL]         } [EOL]     } [EOL]     NamedType rootType = new NamedType(rawBase, null); [EOL]     AnnotatedClass ac = AnnotatedClass.constructWithoutSuperTypes(rawBase, ai, config); [EOL]     _collectAndResolve(ac, rootType, config, ai, collected); [EOL]     return new ArrayList<NamedType>(collected.values()); [EOL] }
@Override [EOL] public ArrayType withTypeHandler(Object h) { [EOL]     if (h == _typeHandler) { [EOL]         return this; [EOL]     } [EOL]     return new ArrayType(_componentType, _emptyArray, _valueHandler, h, _asStatic); [EOL] }
@Override [EOL] public ArrayType withTypeHandler(Object h) { [EOL]     if (h == _typeHandler) { [EOL]         return this; [EOL]     } [EOL]     return new ArrayType(_componentType, _emptyArray, _valueHandler, h, _asStatic); [EOL] }
@Override [EOL] public boolean hasGenericTypes() { [EOL]     return _componentType.hasGenericTypes(); [EOL] }
@Override [EOL] public boolean hasGenericTypes() { [EOL]     return _componentType.hasGenericTypes(); [EOL] }
@Override [EOL] public void serialize(Short value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     jgen.writeNumber(value.shortValue()); [EOL] }
@Override [EOL] public void serialize(Short value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     jgen.writeNumber(value.shortValue()); [EOL] }
@Override [EOL] public void serialize(Number value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     jgen.writeNumber(value.intValue()); [EOL] }
@Override [EOL] public void serialize(Number value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     jgen.writeNumber(value.intValue()); [EOL] }
@Override [EOL] public void serialize(Float value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     jgen.writeNumber(value.floatValue()); [EOL] }
@Override [EOL] public void serialize(Float value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     jgen.writeNumber(value.floatValue()); [EOL] }
@Override [EOL] public void serialize(Double value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     jgen.writeNumber(value.doubleValue()); [EOL] }
@Override [EOL] public void serialize(Double value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     jgen.writeNumber(value.doubleValue()); [EOL] }
@Override [EOL] public void serialize(Number value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (value instanceof BigDecimal) { [EOL]         if (provider.isEnabled(SerializationFeature.WRITE_BIGDECIMAL_AS_PLAIN)) { [EOL]             jgen.writeNumber(((BigDecimal) value).toPlainString()); [EOL]         } else { [EOL]             jgen.writeNumber((BigDecimal) value); [EOL]         } [EOL]     } else if (value instanceof BigInteger) { [EOL]         jgen.writeNumber((BigInteger) value); [EOL]     } else if (value instanceof Integer) { [EOL]         jgen.writeNumber(value.intValue()); [EOL]     } else if (value instanceof Long) { [EOL]         jgen.writeNumber(value.longValue()); [EOL]     } else if (value instanceof Double) { [EOL]         jgen.writeNumber(value.doubleValue()); [EOL]     } else if (value instanceof Float) { [EOL]         jgen.writeNumber(value.floatValue()); [EOL]     } else if ((value instanceof Byte) || (value instanceof Short)) { [EOL]         jgen.writeNumber(value.intValue()); [EOL]     } else { [EOL]         jgen.writeNumber(value.toString()); [EOL]     } [EOL] }
@Override [EOL] public void serialize(Number value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (value instanceof BigDecimal) { [EOL]         if (provider.isEnabled(SerializationFeature.WRITE_BIGDECIMAL_AS_PLAIN)) { [EOL]             jgen.writeNumber(((BigDecimal) value).toPlainString()); [EOL]         } else { [EOL]             jgen.writeNumber((BigDecimal) value); [EOL]         } [EOL]     } else if (value instanceof BigInteger) { [EOL]         jgen.writeNumber((BigInteger) value); [EOL]     } else if (value instanceof Integer) { [EOL]         jgen.writeNumber(value.intValue()); [EOL]     } else if (value instanceof Long) { [EOL]         jgen.writeNumber(value.longValue()); [EOL]     } else if (value instanceof Double) { [EOL]         jgen.writeNumber(value.doubleValue()); [EOL]     } else if (value instanceof Float) { [EOL]         jgen.writeNumber(value.floatValue()); [EOL]     } else if ((value instanceof Byte) || (value instanceof Short)) { [EOL]         jgen.writeNumber(value.intValue()); [EOL]     } else { [EOL]         jgen.writeNumber(value.toString()); [EOL]     } [EOL] }
@Override [EOL] public void serialize(Number value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (value instanceof BigDecimal) { [EOL]         if (provider.isEnabled(SerializationFeature.WRITE_BIGDECIMAL_AS_PLAIN)) { [EOL]             jgen.writeNumber(((BigDecimal) value).toPlainString()); [EOL]         } else { [EOL]             jgen.writeNumber((BigDecimal) value); [EOL]         } [EOL]     } else if (value instanceof BigInteger) { [EOL]         jgen.writeNumber((BigInteger) value); [EOL]     } else if (value instanceof Integer) { [EOL]         jgen.writeNumber(value.intValue()); [EOL]     } else if (value instanceof Long) { [EOL]         jgen.writeNumber(value.longValue()); [EOL]     } else if (value instanceof Double) { [EOL]         jgen.writeNumber(value.doubleValue()); [EOL]     } else if (value instanceof Float) { [EOL]         jgen.writeNumber(value.floatValue()); [EOL]     } else if ((value instanceof Byte) || (value instanceof Short)) { [EOL]         jgen.writeNumber(value.intValue()); [EOL]     } else { [EOL]         jgen.writeNumber(value.toString()); [EOL]     } [EOL] }
@Override [EOL] public void serialize(Number value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (value instanceof BigDecimal) { [EOL]         if (provider.isEnabled(SerializationFeature.WRITE_BIGDECIMAL_AS_PLAIN)) { [EOL]             jgen.writeNumber(((BigDecimal) value).toPlainString()); [EOL]         } else { [EOL]             jgen.writeNumber((BigDecimal) value); [EOL]         } [EOL]     } else if (value instanceof BigInteger) { [EOL]         jgen.writeNumber((BigInteger) value); [EOL]     } else if (value instanceof Integer) { [EOL]         jgen.writeNumber(value.intValue()); [EOL]     } else if (value instanceof Long) { [EOL]         jgen.writeNumber(value.longValue()); [EOL]     } else if (value instanceof Double) { [EOL]         jgen.writeNumber(value.doubleValue()); [EOL]     } else if (value instanceof Float) { [EOL]         jgen.writeNumber(value.floatValue()); [EOL]     } else if ((value instanceof Byte) || (value instanceof Short)) { [EOL]         jgen.writeNumber(value.intValue()); [EOL]     } else { [EOL]         jgen.writeNumber(value.toString()); [EOL]     } [EOL] }
@Override [EOL] public void serialize(Number value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (value instanceof BigDecimal) { [EOL]         if (provider.isEnabled(SerializationFeature.WRITE_BIGDECIMAL_AS_PLAIN)) { [EOL]             jgen.writeNumber(((BigDecimal) value).toPlainString()); [EOL]         } else { [EOL]             jgen.writeNumber((BigDecimal) value); [EOL]         } [EOL]     } else if (value instanceof BigInteger) { [EOL]         jgen.writeNumber((BigInteger) value); [EOL]     } else if (value instanceof Integer) { [EOL]         jgen.writeNumber(value.intValue()); [EOL]     } else if (value instanceof Long) { [EOL]         jgen.writeNumber(value.longValue()); [EOL]     } else if (value instanceof Double) { [EOL]         jgen.writeNumber(value.doubleValue()); [EOL]     } else if (value instanceof Float) { [EOL]         jgen.writeNumber(value.floatValue()); [EOL]     } else if ((value instanceof Byte) || (value instanceof Short)) { [EOL]         jgen.writeNumber(value.intValue()); [EOL]     } else { [EOL]         jgen.writeNumber(value.toString()); [EOL]     } [EOL] }
@Override [EOL] public void serialize(Number value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (value instanceof BigDecimal) { [EOL]         if (provider.isEnabled(SerializationFeature.WRITE_BIGDECIMAL_AS_PLAIN)) { [EOL]             jgen.writeNumber(((BigDecimal) value).toPlainString()); [EOL]         } else { [EOL]             jgen.writeNumber((BigDecimal) value); [EOL]         } [EOL]     } else if (value instanceof BigInteger) { [EOL]         jgen.writeNumber((BigInteger) value); [EOL]     } else if (value instanceof Integer) { [EOL]         jgen.writeNumber(value.intValue()); [EOL]     } else if (value instanceof Long) { [EOL]         jgen.writeNumber(value.longValue()); [EOL]     } else if (value instanceof Double) { [EOL]         jgen.writeNumber(value.doubleValue()); [EOL]     } else if (value instanceof Float) { [EOL]         jgen.writeNumber(value.floatValue()); [EOL]     } else if ((value instanceof Byte) || (value instanceof Short)) { [EOL]         jgen.writeNumber(value.intValue()); [EOL]     } else { [EOL]         jgen.writeNumber(value.toString()); [EOL]     } [EOL] }
@Override [EOL] public void serialize(Number value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (value instanceof BigDecimal) { [EOL]         if (provider.isEnabled(SerializationFeature.WRITE_BIGDECIMAL_AS_PLAIN)) { [EOL]             jgen.writeNumber(((BigDecimal) value).toPlainString()); [EOL]         } else { [EOL]             jgen.writeNumber((BigDecimal) value); [EOL]         } [EOL]     } else if (value instanceof BigInteger) { [EOL]         jgen.writeNumber((BigInteger) value); [EOL]     } else if (value instanceof Integer) { [EOL]         jgen.writeNumber(value.intValue()); [EOL]     } else if (value instanceof Long) { [EOL]         jgen.writeNumber(value.longValue()); [EOL]     } else if (value instanceof Double) { [EOL]         jgen.writeNumber(value.doubleValue()); [EOL]     } else if (value instanceof Float) { [EOL]         jgen.writeNumber(value.floatValue()); [EOL]     } else if ((value instanceof Byte) || (value instanceof Short)) { [EOL]         jgen.writeNumber(value.intValue()); [EOL]     } else { [EOL]         jgen.writeNumber(value.toString()); [EOL]     } [EOL] }
@Override [EOL] public void serialize(Number value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (value instanceof BigDecimal) { [EOL]         if (provider.isEnabled(SerializationFeature.WRITE_BIGDECIMAL_AS_PLAIN)) { [EOL]             jgen.writeNumber(((BigDecimal) value).toPlainString()); [EOL]         } else { [EOL]             jgen.writeNumber((BigDecimal) value); [EOL]         } [EOL]     } else if (value instanceof BigInteger) { [EOL]         jgen.writeNumber((BigInteger) value); [EOL]     } else if (value instanceof Integer) { [EOL]         jgen.writeNumber(value.intValue()); [EOL]     } else if (value instanceof Long) { [EOL]         jgen.writeNumber(value.longValue()); [EOL]     } else if (value instanceof Double) { [EOL]         jgen.writeNumber(value.doubleValue()); [EOL]     } else if (value instanceof Float) { [EOL]         jgen.writeNumber(value.floatValue()); [EOL]     } else if ((value instanceof Byte) || (value instanceof Short)) { [EOL]         jgen.writeNumber(value.intValue()); [EOL]     } else { [EOL]         jgen.writeNumber(value.toString()); [EOL]     } [EOL] }
@Override [EOL] public void serialize(Number value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (value instanceof BigDecimal) { [EOL]         if (provider.isEnabled(SerializationFeature.WRITE_BIGDECIMAL_AS_PLAIN)) { [EOL]             jgen.writeNumber(((BigDecimal) value).toPlainString()); [EOL]         } else { [EOL]             jgen.writeNumber((BigDecimal) value); [EOL]         } [EOL]     } else if (value instanceof BigInteger) { [EOL]         jgen.writeNumber((BigInteger) value); [EOL]     } else if (value instanceof Integer) { [EOL]         jgen.writeNumber(value.intValue()); [EOL]     } else if (value instanceof Long) { [EOL]         jgen.writeNumber(value.longValue()); [EOL]     } else if (value instanceof Double) { [EOL]         jgen.writeNumber(value.doubleValue()); [EOL]     } else if (value instanceof Float) { [EOL]         jgen.writeNumber(value.floatValue()); [EOL]     } else if ((value instanceof Byte) || (value instanceof Short)) { [EOL]         jgen.writeNumber(value.intValue()); [EOL]     } else { [EOL]         jgen.writeNumber(value.toString()); [EOL]     } [EOL] }
@Override [EOL] public void serialize(Number value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (value instanceof BigDecimal) { [EOL]         if (provider.isEnabled(SerializationFeature.WRITE_BIGDECIMAL_AS_PLAIN)) { [EOL]             jgen.writeNumber(((BigDecimal) value).toPlainString()); [EOL]         } else { [EOL]             jgen.writeNumber((BigDecimal) value); [EOL]         } [EOL]     } else if (value instanceof BigInteger) { [EOL]         jgen.writeNumber((BigInteger) value); [EOL]     } else if (value instanceof Integer) { [EOL]         jgen.writeNumber(value.intValue()); [EOL]     } else if (value instanceof Long) { [EOL]         jgen.writeNumber(value.longValue()); [EOL]     } else if (value instanceof Double) { [EOL]         jgen.writeNumber(value.doubleValue()); [EOL]     } else if (value instanceof Float) { [EOL]         jgen.writeNumber(value.floatValue()); [EOL]     } else if ((value instanceof Byte) || (value instanceof Short)) { [EOL]         jgen.writeNumber(value.intValue()); [EOL]     } else { [EOL]         jgen.writeNumber(value.toString()); [EOL]     } [EOL] }
@Override [EOL] public boolean hasSingleElement(String[] value) { [EOL]     return (value.length == 1); [EOL] }
@Override [EOL] public boolean hasSingleElement(String[] value) { [EOL]     return (value.length == 1); [EOL] }
@Override [EOL] public boolean hasSingleElement(String[] value) { [EOL]     return (value.length == 1); [EOL] }
public static TextNode valueOf(String v) { [EOL]     if (v == null) { [EOL]         return null; [EOL]     } [EOL]     if (v.length() == 0) { [EOL]         return EMPTY_STRING_NODE; [EOL]     } [EOL]     return new TextNode(v); [EOL] }
public static TextNode valueOf(String v) { [EOL]     if (v == null) { [EOL]         return null; [EOL]     } [EOL]     if (v.length() == 0) { [EOL]         return EMPTY_STRING_NODE; [EOL]     } [EOL]     return new TextNode(v); [EOL] }
public static TextNode valueOf(String v) { [EOL]     if (v == null) { [EOL]         return null; [EOL]     } [EOL]     if (v.length() == 0) { [EOL]         return EMPTY_STRING_NODE; [EOL]     } [EOL]     return new TextNode(v); [EOL] }
@Override [EOL] public JsonToken asToken() { [EOL]     return JsonToken.VALUE_STRING; [EOL] }
@Override [EOL] public int asInt(int defaultValue) { [EOL]     return NumberInput.parseAsInt(_value, defaultValue); [EOL] }
@Override [EOL] public int asInt(int defaultValue) { [EOL]     return NumberInput.parseAsInt(_value, defaultValue); [EOL] }
@Override [EOL] public int asInt(int defaultValue) { [EOL]     return NumberInput.parseAsInt(_value, defaultValue); [EOL] }
@Override [EOL] public long asLong(long defaultValue) { [EOL]     return NumberInput.parseAsLong(_value, defaultValue); [EOL] }
@Override [EOL] public long asLong(long defaultValue) { [EOL]     return NumberInput.parseAsLong(_value, defaultValue); [EOL] }
@Override [EOL] public long asLong(long defaultValue) { [EOL]     return NumberInput.parseAsLong(_value, defaultValue); [EOL] }
@Override [EOL] public double asDouble(double defaultValue) { [EOL]     return NumberInput.parseAsDouble(_value, defaultValue); [EOL] }
@Override [EOL] public double asDouble(double defaultValue) { [EOL]     return NumberInput.parseAsDouble(_value, defaultValue); [EOL] }
@Override [EOL] public double asDouble(double defaultValue) { [EOL]     return NumberInput.parseAsDouble(_value, defaultValue); [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) { [EOL]         return false; [EOL]     } [EOL]     return ((TextNode) o)._value.equals(_value); [EOL] }
@Override [EOL] public int hashCode() { [EOL]     return _value.hashCode(); [EOL] }
@Override [EOL] public int hashCode() { [EOL]     return _value.hashCode(); [EOL] }
@Override [EOL] public String toString() { [EOL]     int len = _value.length(); [EOL]     len = len + 2 + (len >> 4); [EOL]     StringBuilder sb = new StringBuilder(len); [EOL]     appendQuoted(sb, _value); [EOL]     return sb.toString(); [EOL] }
@Override [EOL] public String toString() { [EOL]     int len = _value.length(); [EOL]     len = len + 2 + (len >> 4); [EOL]     StringBuilder sb = new StringBuilder(len); [EOL]     appendQuoted(sb, _value); [EOL]     return sb.toString(); [EOL] }
@Override [EOL] public String toString() { [EOL]     int len = _value.length(); [EOL]     len = len + 2 + (len >> 4); [EOL]     StringBuilder sb = new StringBuilder(len); [EOL]     appendQuoted(sb, _value); [EOL]     return sb.toString(); [EOL] }
protected static void appendQuoted(StringBuilder sb, String content) { [EOL]     sb.append('"'); [EOL]     CharTypes.appendQuoted(sb, content); [EOL]     sb.append('"'); [EOL] }
protected static void appendQuoted(StringBuilder sb, String content) { [EOL]     sb.append('"'); [EOL]     CharTypes.appendQuoted(sb, content); [EOL]     sb.append('"'); [EOL] }
protected static void appendQuoted(StringBuilder sb, String content) { [EOL]     sb.append('"'); [EOL]     CharTypes.appendQuoted(sb, content); [EOL]     sb.append('"'); [EOL] }
@Override [EOL] public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException { [EOL]     JsonDeserializer<?> deser = _elementDeserializer; [EOL]     deser = findConvertingContentDeserializer(ctxt, property, deser); [EOL]     if (deser == null) { [EOL]         deser = ctxt.findContextualValueDeserializer(ctxt.constructType(String.class), property); [EOL]     } else { [EOL]         if (deser instanceof ContextualDeserializer) { [EOL]             deser = ((ContextualDeserializer) deser).createContextual(ctxt, property); [EOL]         } [EOL]     } [EOL]     if (deser != null && this.isDefaultDeserializer(deser)) { [EOL]         deser = null; [EOL]     } [EOL]     if (_elementDeserializer != deser) { [EOL]         return new StringArrayDeserializer(deser); [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException { [EOL]     JsonDeserializer<?> deser = _elementDeserializer; [EOL]     deser = findConvertingContentDeserializer(ctxt, property, deser); [EOL]     if (deser == null) { [EOL]         deser = ctxt.findContextualValueDeserializer(ctxt.constructType(String.class), property); [EOL]     } else { [EOL]         if (deser instanceof ContextualDeserializer) { [EOL]             deser = ((ContextualDeserializer) deser).createContextual(ctxt, property); [EOL]         } [EOL]     } [EOL]     if (deser != null && this.isDefaultDeserializer(deser)) { [EOL]         deser = null; [EOL]     } [EOL]     if (_elementDeserializer != deser) { [EOL]         return new StringArrayDeserializer(deser); [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException { [EOL]     JsonDeserializer<?> deser = _elementDeserializer; [EOL]     deser = findConvertingContentDeserializer(ctxt, property, deser); [EOL]     if (deser == null) { [EOL]         deser = ctxt.findContextualValueDeserializer(ctxt.constructType(String.class), property); [EOL]     } else { [EOL]         if (deser instanceof ContextualDeserializer) { [EOL]             deser = ((ContextualDeserializer) deser).createContextual(ctxt, property); [EOL]         } [EOL]     } [EOL]     if (deser != null && this.isDefaultDeserializer(deser)) { [EOL]         deser = null; [EOL]     } [EOL]     if (_elementDeserializer != deser) { [EOL]         return new StringArrayDeserializer(deser); [EOL]     } [EOL]     return this; [EOL] }
private HierarchicType(Type actualType, Class<?> rawClass, ParameterizedType genericType, HierarchicType superType, HierarchicType subType) { [EOL]     _actualType = actualType; [EOL]     _rawClass = rawClass; [EOL]     _genericType = genericType; [EOL]     _superType = superType; [EOL]     _subType = subType; [EOL] }
public HierarchicType deepCloneWithoutSubtype() { [EOL]     HierarchicType sup = (_superType == null) ? null : _superType.deepCloneWithoutSubtype(); [EOL]     HierarchicType result = new HierarchicType(_actualType, _rawClass, _genericType, sup, null); [EOL]     if (sup != null) { [EOL]         sup.setSubType(result); [EOL]     } [EOL]     return result; [EOL] }
public HierarchicType deepCloneWithoutSubtype() { [EOL]     HierarchicType sup = (_superType == null) ? null : _superType.deepCloneWithoutSubtype(); [EOL]     HierarchicType result = new HierarchicType(_actualType, _rawClass, _genericType, sup, null); [EOL]     if (sup != null) { [EOL]         sup.setSubType(result); [EOL]     } [EOL]     return result; [EOL] }
public InetAddressSerializer() { [EOL]     super(InetAddress.class); [EOL] }
@Override [EOL] public void serialize(InetAddress value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     String str = value.toString().trim(); [EOL]     int ix = str.indexOf('/'); [EOL]     if (ix >= 0) { [EOL]         if (ix == 0) { [EOL]             str = str.substring(1); [EOL]         } else { [EOL]             str = str.substring(0, ix); [EOL]         } [EOL]     } [EOL]     jgen.writeString(str); [EOL] }
@Override [EOL] public void serialize(InetAddress value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     String str = value.toString().trim(); [EOL]     int ix = str.indexOf('/'); [EOL]     if (ix >= 0) { [EOL]         if (ix == 0) { [EOL]             str = str.substring(1); [EOL]         } else { [EOL]             str = str.substring(0, ix); [EOL]         } [EOL]     } [EOL]     jgen.writeString(str); [EOL] }
@Override [EOL] public void serialize(InetAddress value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     String str = value.toString().trim(); [EOL]     int ix = str.indexOf('/'); [EOL]     if (ix >= 0) { [EOL]         if (ix == 0) { [EOL]             str = str.substring(1); [EOL]         } else { [EOL]             str = str.substring(0, ix); [EOL]         } [EOL]     } [EOL]     jgen.writeString(str); [EOL] }
public SimpleModule addSerializer(JsonSerializer<?> ser) { [EOL]     if (_serializers == null) { [EOL]         _serializers = new SimpleSerializers(); [EOL]     } [EOL]     _serializers.addSerializer(ser); [EOL]     return this; [EOL] }
public SimpleModule addSerializer(JsonSerializer<?> ser) { [EOL]     if (_serializers == null) { [EOL]         _serializers = new SimpleSerializers(); [EOL]     } [EOL]     _serializers.addSerializer(ser); [EOL]     return this; [EOL] }
public <T> SimpleModule addKeySerializer(Class<? extends T> type, JsonSerializer<T> ser) { [EOL]     if (_keySerializers == null) { [EOL]         _keySerializers = new SimpleSerializers(); [EOL]     } [EOL]     _keySerializers.addSerializer(type, ser); [EOL]     return this; [EOL] }
public <T> SimpleModule addKeySerializer(Class<? extends T> type, JsonSerializer<T> ser) { [EOL]     if (_keySerializers == null) { [EOL]         _keySerializers = new SimpleSerializers(); [EOL]     } [EOL]     _keySerializers.addSerializer(type, ser); [EOL]     return this; [EOL] }
public SimpleModule addValueInstantiator(Class<?> beanType, ValueInstantiator inst) { [EOL]     if (_valueInstantiators == null) { [EOL]         _valueInstantiators = new SimpleValueInstantiators(); [EOL]     } [EOL]     _valueInstantiators = _valueInstantiators.addValueInstantiator(beanType, inst); [EOL]     return this; [EOL] }
public SimpleModule addValueInstantiator(Class<?> beanType, ValueInstantiator inst) { [EOL]     if (_valueInstantiators == null) { [EOL]         _valueInstantiators = new SimpleValueInstantiators(); [EOL]     } [EOL]     _valueInstantiators = _valueInstantiators.addValueInstantiator(beanType, inst); [EOL]     return this; [EOL] }
@Override [EOL] public void setupModule(SetupContext context) { [EOL]     if (_serializers != null) { [EOL]         context.addSerializers(_serializers); [EOL]     } [EOL]     if (_deserializers != null) { [EOL]         context.addDeserializers(_deserializers); [EOL]     } [EOL]     if (_keySerializers != null) { [EOL]         context.addKeySerializers(_keySerializers); [EOL]     } [EOL]     if (_keyDeserializers != null) { [EOL]         context.addKeyDeserializers(_keyDeserializers); [EOL]     } [EOL]     if (_abstractTypes != null) { [EOL]         context.addAbstractTypeResolver(_abstractTypes); [EOL]     } [EOL]     if (_valueInstantiators != null) { [EOL]         context.addValueInstantiators(_valueInstantiators); [EOL]     } [EOL]     if (_deserializerModifier != null) { [EOL]         context.addBeanDeserializerModifier(_deserializerModifier); [EOL]     } [EOL]     if (_serializerModifier != null) { [EOL]         context.addBeanSerializerModifier(_serializerModifier); [EOL]     } [EOL]     if (_subtypes != null && _subtypes.size() > 0) { [EOL]         context.registerSubtypes(_subtypes.toArray(new NamedType[_subtypes.size()])); [EOL]     } [EOL]     if (_mixins != null) { [EOL]         for (Map.Entry<Class<?>, Class<?>> entry : _mixins.entrySet()) { [EOL]             context.setMixInAnnotations(entry.getKey(), entry.getValue()); [EOL]         } [EOL]     } [EOL] }
@Override [EOL] public void setupModule(SetupContext context) { [EOL]     if (_serializers != null) { [EOL]         context.addSerializers(_serializers); [EOL]     } [EOL]     if (_deserializers != null) { [EOL]         context.addDeserializers(_deserializers); [EOL]     } [EOL]     if (_keySerializers != null) { [EOL]         context.addKeySerializers(_keySerializers); [EOL]     } [EOL]     if (_keyDeserializers != null) { [EOL]         context.addKeyDeserializers(_keyDeserializers); [EOL]     } [EOL]     if (_abstractTypes != null) { [EOL]         context.addAbstractTypeResolver(_abstractTypes); [EOL]     } [EOL]     if (_valueInstantiators != null) { [EOL]         context.addValueInstantiators(_valueInstantiators); [EOL]     } [EOL]     if (_deserializerModifier != null) { [EOL]         context.addBeanDeserializerModifier(_deserializerModifier); [EOL]     } [EOL]     if (_serializerModifier != null) { [EOL]         context.addBeanSerializerModifier(_serializerModifier); [EOL]     } [EOL]     if (_subtypes != null && _subtypes.size() > 0) { [EOL]         context.registerSubtypes(_subtypes.toArray(new NamedType[_subtypes.size()])); [EOL]     } [EOL]     if (_mixins != null) { [EOL]         for (Map.Entry<Class<?>, Class<?>> entry : _mixins.entrySet()) { [EOL]             context.setMixInAnnotations(entry.getKey(), entry.getValue()); [EOL]         } [EOL]     } [EOL] }
@Override [EOL] public void setupModule(SetupContext context) { [EOL]     if (_serializers != null) { [EOL]         context.addSerializers(_serializers); [EOL]     } [EOL]     if (_deserializers != null) { [EOL]         context.addDeserializers(_deserializers); [EOL]     } [EOL]     if (_keySerializers != null) { [EOL]         context.addKeySerializers(_keySerializers); [EOL]     } [EOL]     if (_keyDeserializers != null) { [EOL]         context.addKeyDeserializers(_keyDeserializers); [EOL]     } [EOL]     if (_abstractTypes != null) { [EOL]         context.addAbstractTypeResolver(_abstractTypes); [EOL]     } [EOL]     if (_valueInstantiators != null) { [EOL]         context.addValueInstantiators(_valueInstantiators); [EOL]     } [EOL]     if (_deserializerModifier != null) { [EOL]         context.addBeanDeserializerModifier(_deserializerModifier); [EOL]     } [EOL]     if (_serializerModifier != null) { [EOL]         context.addBeanSerializerModifier(_serializerModifier); [EOL]     } [EOL]     if (_subtypes != null && _subtypes.size() > 0) { [EOL]         context.registerSubtypes(_subtypes.toArray(new NamedType[_subtypes.size()])); [EOL]     } [EOL]     if (_mixins != null) { [EOL]         for (Map.Entry<Class<?>, Class<?>> entry : _mixins.entrySet()) { [EOL]             context.setMixInAnnotations(entry.getKey(), entry.getValue()); [EOL]         } [EOL]     } [EOL] }
@Override [EOL] public void setupModule(SetupContext context) { [EOL]     if (_serializers != null) { [EOL]         context.addSerializers(_serializers); [EOL]     } [EOL]     if (_deserializers != null) { [EOL]         context.addDeserializers(_deserializers); [EOL]     } [EOL]     if (_keySerializers != null) { [EOL]         context.addKeySerializers(_keySerializers); [EOL]     } [EOL]     if (_keyDeserializers != null) { [EOL]         context.addKeyDeserializers(_keyDeserializers); [EOL]     } [EOL]     if (_abstractTypes != null) { [EOL]         context.addAbstractTypeResolver(_abstractTypes); [EOL]     } [EOL]     if (_valueInstantiators != null) { [EOL]         context.addValueInstantiators(_valueInstantiators); [EOL]     } [EOL]     if (_deserializerModifier != null) { [EOL]         context.addBeanDeserializerModifier(_deserializerModifier); [EOL]     } [EOL]     if (_serializerModifier != null) { [EOL]         context.addBeanSerializerModifier(_serializerModifier); [EOL]     } [EOL]     if (_subtypes != null && _subtypes.size() > 0) { [EOL]         context.registerSubtypes(_subtypes.toArray(new NamedType[_subtypes.size()])); [EOL]     } [EOL]     if (_mixins != null) { [EOL]         for (Map.Entry<Class<?>, Class<?>> entry : _mixins.entrySet()) { [EOL]             context.setMixInAnnotations(entry.getKey(), entry.getValue()); [EOL]         } [EOL]     } [EOL] }
public static SimpleType constructUnsafe(Class<?> raw) { [EOL]     return new SimpleType(raw, null, null, null, null, false); [EOL] }
public static SimpleType constructUnsafe(Class<?> raw) { [EOL]     return new SimpleType(raw, null, null, null, null, false); [EOL] }
@Override [EOL] protected String buildCanonicalName() { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     sb.append(_class.getName()); [EOL]     if (_typeParameters != null && _typeParameters.length > 0) { [EOL]         sb.append('<'); [EOL]         boolean first = true; [EOL]         for (JavaType t : _typeParameters) { [EOL]             if (first) { [EOL]                 first = false; [EOL]             } else { [EOL]                 sb.append(','); [EOL]             } [EOL]             sb.append(t.toCanonical()); [EOL]         } [EOL]         sb.append('>'); [EOL]     } [EOL]     return sb.toString(); [EOL] }
@Override [EOL] protected String buildCanonicalName() { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     sb.append(_class.getName()); [EOL]     if (_typeParameters != null && _typeParameters.length > 0) { [EOL]         sb.append('<'); [EOL]         boolean first = true; [EOL]         for (JavaType t : _typeParameters) { [EOL]             if (first) { [EOL]                 first = false; [EOL]             } else { [EOL]                 sb.append(','); [EOL]             } [EOL]             sb.append(t.toCanonical()); [EOL]         } [EOL]         sb.append('>'); [EOL]     } [EOL]     return sb.toString(); [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) [EOL]         return false; [EOL]     SimpleType other = (SimpleType) o; [EOL]     if (other._class != this._class) [EOL]         return false; [EOL]     JavaType[] p1 = _typeParameters; [EOL]     JavaType[] p2 = other._typeParameters; [EOL]     if (p1 == null) { [EOL]         return (p2 == null) || p2.length == 0; [EOL]     } [EOL]     if (p2 == null) [EOL]         return false; [EOL]     if (p1.length != p2.length) [EOL]         return false; [EOL]     for (int i = 0, len = p1.length; i < len; ++i) { [EOL]         if (!p1[i].equals(p2[i])) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) [EOL]         return false; [EOL]     SimpleType other = (SimpleType) o; [EOL]     if (other._class != this._class) [EOL]         return false; [EOL]     JavaType[] p1 = _typeParameters; [EOL]     JavaType[] p2 = other._typeParameters; [EOL]     if (p1 == null) { [EOL]         return (p2 == null) || p2.length == 0; [EOL]     } [EOL]     if (p2 == null) [EOL]         return false; [EOL]     if (p1.length != p2.length) [EOL]         return false; [EOL]     for (int i = 0, len = p1.length; i < len; ++i) { [EOL]         if (!p1[i].equals(p2[i])) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) [EOL]         return false; [EOL]     SimpleType other = (SimpleType) o; [EOL]     if (other._class != this._class) [EOL]         return false; [EOL]     JavaType[] p1 = _typeParameters; [EOL]     JavaType[] p2 = other._typeParameters; [EOL]     if (p1 == null) { [EOL]         return (p2 == null) || p2.length == 0; [EOL]     } [EOL]     if (p2 == null) [EOL]         return false; [EOL]     if (p1.length != p2.length) [EOL]         return false; [EOL]     for (int i = 0, len = p1.length; i < len; ++i) { [EOL]         if (!p1[i].equals(p2[i])) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) [EOL]         return false; [EOL]     SimpleType other = (SimpleType) o; [EOL]     if (other._class != this._class) [EOL]         return false; [EOL]     JavaType[] p1 = _typeParameters; [EOL]     JavaType[] p2 = other._typeParameters; [EOL]     if (p1 == null) { [EOL]         return (p2 == null) || p2.length == 0; [EOL]     } [EOL]     if (p2 == null) [EOL]         return false; [EOL]     if (p1.length != p2.length) [EOL]         return false; [EOL]     for (int i = 0, len = p1.length; i < len; ++i) { [EOL]         if (!p1[i].equals(p2[i])) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) [EOL]         return false; [EOL]     SimpleType other = (SimpleType) o; [EOL]     if (other._class != this._class) [EOL]         return false; [EOL]     JavaType[] p1 = _typeParameters; [EOL]     JavaType[] p2 = other._typeParameters; [EOL]     if (p1 == null) { [EOL]         return (p2 == null) || p2.length == 0; [EOL]     } [EOL]     if (p2 == null) [EOL]         return false; [EOL]     if (p1.length != p2.length) [EOL]         return false; [EOL]     for (int i = 0, len = p1.length; i < len; ++i) { [EOL]         if (!p1[i].equals(p2[i])) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) [EOL]         return false; [EOL]     SimpleType other = (SimpleType) o; [EOL]     if (other._class != this._class) [EOL]         return false; [EOL]     JavaType[] p1 = _typeParameters; [EOL]     JavaType[] p2 = other._typeParameters; [EOL]     if (p1 == null) { [EOL]         return (p2 == null) || p2.length == 0; [EOL]     } [EOL]     if (p2 == null) [EOL]         return false; [EOL]     if (p1.length != p2.length) [EOL]         return false; [EOL]     for (int i = 0, len = p1.length; i < len; ++i) { [EOL]         if (!p1[i].equals(p2[i])) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) [EOL]         return false; [EOL]     SimpleType other = (SimpleType) o; [EOL]     if (other._class != this._class) [EOL]         return false; [EOL]     JavaType[] p1 = _typeParameters; [EOL]     JavaType[] p2 = other._typeParameters; [EOL]     if (p1 == null) { [EOL]         return (p2 == null) || p2.length == 0; [EOL]     } [EOL]     if (p2 == null) [EOL]         return false; [EOL]     if (p1.length != p2.length) [EOL]         return false; [EOL]     for (int i = 0, len = p1.length; i < len; ++i) { [EOL]         if (!p1[i].equals(p2[i])) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) [EOL]         return false; [EOL]     SimpleType other = (SimpleType) o; [EOL]     if (other._class != this._class) [EOL]         return false; [EOL]     JavaType[] p1 = _typeParameters; [EOL]     JavaType[] p2 = other._typeParameters; [EOL]     if (p1 == null) { [EOL]         return (p2 == null) || p2.length == 0; [EOL]     } [EOL]     if (p2 == null) [EOL]         return false; [EOL]     if (p1.length != p2.length) [EOL]         return false; [EOL]     for (int i = 0, len = p1.length; i < len; ++i) { [EOL]         if (!p1[i].equals(p2[i])) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) [EOL]         return false; [EOL]     SimpleType other = (SimpleType) o; [EOL]     if (other._class != this._class) [EOL]         return false; [EOL]     JavaType[] p1 = _typeParameters; [EOL]     JavaType[] p2 = other._typeParameters; [EOL]     if (p1 == null) { [EOL]         return (p2 == null) || p2.length == 0; [EOL]     } [EOL]     if (p2 == null) [EOL]         return false; [EOL]     if (p1.length != p2.length) [EOL]         return false; [EOL]     for (int i = 0, len = p1.length; i < len; ++i) { [EOL]         if (!p1[i].equals(p2[i])) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public static TypeFactory defaultInstance() { [EOL]     return instance; [EOL] }
public JavaType constructSpecializedType(JavaType baseType, Class<?> subclass) { [EOL]     if (baseType instanceof SimpleType) { [EOL]         if (subclass.isArray() || Map.class.isAssignableFrom(subclass) || Collection.class.isAssignableFrom(subclass)) { [EOL]             if (!baseType.getRawClass().isAssignableFrom(subclass)) { [EOL]                 throw new IllegalArgumentException("Class " + subclass.getClass().getName() + " not subtype of " + baseType); [EOL]             } [EOL]             JavaType subtype = _fromClass(subclass, new TypeBindings(this, baseType.getRawClass())); [EOL]             Object h = baseType.getValueHandler(); [EOL]             if (h != null) { [EOL]                 subtype = subtype.withValueHandler(h); [EOL]             } [EOL]             h = baseType.getTypeHandler(); [EOL]             if (h != null) { [EOL]                 subtype = subtype.withTypeHandler(h); [EOL]             } [EOL]             return subtype; [EOL]         } [EOL]     } [EOL]     return baseType.narrowBy(subclass); [EOL] }
public JavaType constructSpecializedType(JavaType baseType, Class<?> subclass) { [EOL]     if (baseType instanceof SimpleType) { [EOL]         if (subclass.isArray() || Map.class.isAssignableFrom(subclass) || Collection.class.isAssignableFrom(subclass)) { [EOL]             if (!baseType.getRawClass().isAssignableFrom(subclass)) { [EOL]                 throw new IllegalArgumentException("Class " + subclass.getClass().getName() + " not subtype of " + baseType); [EOL]             } [EOL]             JavaType subtype = _fromClass(subclass, new TypeBindings(this, baseType.getRawClass())); [EOL]             Object h = baseType.getValueHandler(); [EOL]             if (h != null) { [EOL]                 subtype = subtype.withValueHandler(h); [EOL]             } [EOL]             h = baseType.getTypeHandler(); [EOL]             if (h != null) { [EOL]                 subtype = subtype.withTypeHandler(h); [EOL]             } [EOL]             return subtype; [EOL]         } [EOL]     } [EOL]     return baseType.narrowBy(subclass); [EOL] }
public JavaType constructSpecializedType(JavaType baseType, Class<?> subclass) { [EOL]     if (baseType instanceof SimpleType) { [EOL]         if (subclass.isArray() || Map.class.isAssignableFrom(subclass) || Collection.class.isAssignableFrom(subclass)) { [EOL]             if (!baseType.getRawClass().isAssignableFrom(subclass)) { [EOL]                 throw new IllegalArgumentException("Class " + subclass.getClass().getName() + " not subtype of " + baseType); [EOL]             } [EOL]             JavaType subtype = _fromClass(subclass, new TypeBindings(this, baseType.getRawClass())); [EOL]             Object h = baseType.getValueHandler(); [EOL]             if (h != null) { [EOL]                 subtype = subtype.withValueHandler(h); [EOL]             } [EOL]             h = baseType.getTypeHandler(); [EOL]             if (h != null) { [EOL]                 subtype = subtype.withTypeHandler(h); [EOL]             } [EOL]             return subtype; [EOL]         } [EOL]     } [EOL]     return baseType.narrowBy(subclass); [EOL] }
public JavaType constructSpecializedType(JavaType baseType, Class<?> subclass) { [EOL]     if (baseType instanceof SimpleType) { [EOL]         if (subclass.isArray() || Map.class.isAssignableFrom(subclass) || Collection.class.isAssignableFrom(subclass)) { [EOL]             if (!baseType.getRawClass().isAssignableFrom(subclass)) { [EOL]                 throw new IllegalArgumentException("Class " + subclass.getClass().getName() + " not subtype of " + baseType); [EOL]             } [EOL]             JavaType subtype = _fromClass(subclass, new TypeBindings(this, baseType.getRawClass())); [EOL]             Object h = baseType.getValueHandler(); [EOL]             if (h != null) { [EOL]                 subtype = subtype.withValueHandler(h); [EOL]             } [EOL]             h = baseType.getTypeHandler(); [EOL]             if (h != null) { [EOL]                 subtype = subtype.withTypeHandler(h); [EOL]             } [EOL]             return subtype; [EOL]         } [EOL]     } [EOL]     return baseType.narrowBy(subclass); [EOL] }
public JavaType constructFromCanonical(String canonical) throws IllegalArgumentException { [EOL]     return _parser.parse(canonical); [EOL] }
public JavaType constructFromCanonical(String canonical) throws IllegalArgumentException { [EOL]     return _parser.parse(canonical); [EOL] }
public JavaType constructFromCanonical(String canonical) throws IllegalArgumentException { [EOL]     return _parser.parse(canonical); [EOL] }
public JavaType[] findTypeParameters(Class<?> clz, Class<?> expType) { [EOL]     return findTypeParameters(clz, expType, new TypeBindings(this, clz)); [EOL] }
public JavaType[] findTypeParameters(Class<?> clz, Class<?> expType) { [EOL]     return findTypeParameters(clz, expType, new TypeBindings(this, clz)); [EOL] }
public JavaType[] findTypeParameters(Class<?> clz, Class<?> expType) { [EOL]     return findTypeParameters(clz, expType, new TypeBindings(this, clz)); [EOL] }
public JavaType[] findTypeParameters(Class<?> clz, Class<?> expType, TypeBindings bindings) { [EOL]     HierarchicType subType = _findSuperTypeChain(clz, expType); [EOL]     if (subType == null) { [EOL]         throw new IllegalArgumentException("Class " + clz.getName() + " is not a subtype of " + expType.getName()); [EOL]     } [EOL]     HierarchicType superType = subType; [EOL]     while (superType.getSuperType() != null) { [EOL]         superType = superType.getSuperType(); [EOL]         Class<?> raw = superType.getRawClass(); [EOL]         TypeBindings newBindings = new TypeBindings(this, raw); [EOL]         if (superType.isGeneric()) { [EOL]             ParameterizedType pt = superType.asGeneric(); [EOL]             Type[] actualTypes = pt.getActualTypeArguments(); [EOL]             TypeVariable<?>[] vars = raw.getTypeParameters(); [EOL]             int len = actualTypes.length; [EOL]             for (int i = 0; i < len; ++i) { [EOL]                 String name = vars[i].getName(); [EOL]                 JavaType type = _constructType(actualTypes[i], bindings); [EOL]                 newBindings.addBinding(name, type); [EOL]             } [EOL]         } [EOL]         bindings = newBindings; [EOL]     } [EOL]     if (!superType.isGeneric()) { [EOL]         return null; [EOL]     } [EOL]     return bindings.typesAsArray(); [EOL] }
public JavaType[] findTypeParameters(Class<?> clz, Class<?> expType, TypeBindings bindings) { [EOL]     HierarchicType subType = _findSuperTypeChain(clz, expType); [EOL]     if (subType == null) { [EOL]         throw new IllegalArgumentException("Class " + clz.getName() + " is not a subtype of " + expType.getName()); [EOL]     } [EOL]     HierarchicType superType = subType; [EOL]     while (superType.getSuperType() != null) { [EOL]         superType = superType.getSuperType(); [EOL]         Class<?> raw = superType.getRawClass(); [EOL]         TypeBindings newBindings = new TypeBindings(this, raw); [EOL]         if (superType.isGeneric()) { [EOL]             ParameterizedType pt = superType.asGeneric(); [EOL]             Type[] actualTypes = pt.getActualTypeArguments(); [EOL]             TypeVariable<?>[] vars = raw.getTypeParameters(); [EOL]             int len = actualTypes.length; [EOL]             for (int i = 0; i < len; ++i) { [EOL]                 String name = vars[i].getName(); [EOL]                 JavaType type = _constructType(actualTypes[i], bindings); [EOL]                 newBindings.addBinding(name, type); [EOL]             } [EOL]         } [EOL]         bindings = newBindings; [EOL]     } [EOL]     if (!superType.isGeneric()) { [EOL]         return null; [EOL]     } [EOL]     return bindings.typesAsArray(); [EOL] }
public JavaType[] findTypeParameters(Class<?> clz, Class<?> expType, TypeBindings bindings) { [EOL]     HierarchicType subType = _findSuperTypeChain(clz, expType); [EOL]     if (subType == null) { [EOL]         throw new IllegalArgumentException("Class " + clz.getName() + " is not a subtype of " + expType.getName()); [EOL]     } [EOL]     HierarchicType superType = subType; [EOL]     while (superType.getSuperType() != null) { [EOL]         superType = superType.getSuperType(); [EOL]         Class<?> raw = superType.getRawClass(); [EOL]         TypeBindings newBindings = new TypeBindings(this, raw); [EOL]         if (superType.isGeneric()) { [EOL]             ParameterizedType pt = superType.asGeneric(); [EOL]             Type[] actualTypes = pt.getActualTypeArguments(); [EOL]             TypeVariable<?>[] vars = raw.getTypeParameters(); [EOL]             int len = actualTypes.length; [EOL]             for (int i = 0; i < len; ++i) { [EOL]                 String name = vars[i].getName(); [EOL]                 JavaType type = _constructType(actualTypes[i], bindings); [EOL]                 newBindings.addBinding(name, type); [EOL]             } [EOL]         } [EOL]         bindings = newBindings; [EOL]     } [EOL]     if (!superType.isGeneric()) { [EOL]         return null; [EOL]     } [EOL]     return bindings.typesAsArray(); [EOL] }
public JavaType constructType(Type type) { [EOL]     return _constructType(type, null); [EOL] }
protected JavaType _constructType(Type type, TypeBindings context) { [EOL]     JavaType resultType; [EOL]     if (type instanceof Class<?>) { [EOL]         Class<?> cls = (Class<?>) type; [EOL]         resultType = _fromClass(cls, context); [EOL]     } else if (type instanceof ParameterizedType) { [EOL]         resultType = _fromParamType((ParameterizedType) type, context); [EOL]     } else if (type instanceof JavaType) { [EOL]         return (JavaType) type; [EOL]     } else if (type instanceof GenericArrayType) { [EOL]         resultType = _fromArrayType((GenericArrayType) type, context); [EOL]     } else if (type instanceof TypeVariable<?>) { [EOL]         resultType = _fromVariable((TypeVariable<?>) type, context); [EOL]     } else if (type instanceof WildcardType) { [EOL]         resultType = _fromWildcard((WildcardType) type, context); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Unrecognized Type: " + ((type == null) ? "[null]" : type.toString())); [EOL]     } [EOL]     if (_modifiers != null && !resultType.isContainerType()) { [EOL]         for (TypeModifier mod : _modifiers) { [EOL]             resultType = mod.modifyType(resultType, type, context, this); [EOL]         } [EOL]     } [EOL]     return resultType; [EOL] }
protected JavaType _constructType(Type type, TypeBindings context) { [EOL]     JavaType resultType; [EOL]     if (type instanceof Class<?>) { [EOL]         Class<?> cls = (Class<?>) type; [EOL]         resultType = _fromClass(cls, context); [EOL]     } else if (type instanceof ParameterizedType) { [EOL]         resultType = _fromParamType((ParameterizedType) type, context); [EOL]     } else if (type instanceof JavaType) { [EOL]         return (JavaType) type; [EOL]     } else if (type instanceof GenericArrayType) { [EOL]         resultType = _fromArrayType((GenericArrayType) type, context); [EOL]     } else if (type instanceof TypeVariable<?>) { [EOL]         resultType = _fromVariable((TypeVariable<?>) type, context); [EOL]     } else if (type instanceof WildcardType) { [EOL]         resultType = _fromWildcard((WildcardType) type, context); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Unrecognized Type: " + ((type == null) ? "[null]" : type.toString())); [EOL]     } [EOL]     if (_modifiers != null && !resultType.isContainerType()) { [EOL]         for (TypeModifier mod : _modifiers) { [EOL]             resultType = mod.modifyType(resultType, type, context, this); [EOL]         } [EOL]     } [EOL]     return resultType; [EOL] }
protected JavaType _constructType(Type type, TypeBindings context) { [EOL]     JavaType resultType; [EOL]     if (type instanceof Class<?>) { [EOL]         Class<?> cls = (Class<?>) type; [EOL]         resultType = _fromClass(cls, context); [EOL]     } else if (type instanceof ParameterizedType) { [EOL]         resultType = _fromParamType((ParameterizedType) type, context); [EOL]     } else if (type instanceof JavaType) { [EOL]         return (JavaType) type; [EOL]     } else if (type instanceof GenericArrayType) { [EOL]         resultType = _fromArrayType((GenericArrayType) type, context); [EOL]     } else if (type instanceof TypeVariable<?>) { [EOL]         resultType = _fromVariable((TypeVariable<?>) type, context); [EOL]     } else if (type instanceof WildcardType) { [EOL]         resultType = _fromWildcard((WildcardType) type, context); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Unrecognized Type: " + ((type == null) ? "[null]" : type.toString())); [EOL]     } [EOL]     if (_modifiers != null && !resultType.isContainerType()) { [EOL]         for (TypeModifier mod : _modifiers) { [EOL]             resultType = mod.modifyType(resultType, type, context, this); [EOL]         } [EOL]     } [EOL]     return resultType; [EOL] }
protected JavaType _constructType(Type type, TypeBindings context) { [EOL]     JavaType resultType; [EOL]     if (type instanceof Class<?>) { [EOL]         Class<?> cls = (Class<?>) type; [EOL]         resultType = _fromClass(cls, context); [EOL]     } else if (type instanceof ParameterizedType) { [EOL]         resultType = _fromParamType((ParameterizedType) type, context); [EOL]     } else if (type instanceof JavaType) { [EOL]         return (JavaType) type; [EOL]     } else if (type instanceof GenericArrayType) { [EOL]         resultType = _fromArrayType((GenericArrayType) type, context); [EOL]     } else if (type instanceof TypeVariable<?>) { [EOL]         resultType = _fromVariable((TypeVariable<?>) type, context); [EOL]     } else if (type instanceof WildcardType) { [EOL]         resultType = _fromWildcard((WildcardType) type, context); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Unrecognized Type: " + ((type == null) ? "[null]" : type.toString())); [EOL]     } [EOL]     if (_modifiers != null && !resultType.isContainerType()) { [EOL]         for (TypeModifier mod : _modifiers) { [EOL]             resultType = mod.modifyType(resultType, type, context, this); [EOL]         } [EOL]     } [EOL]     return resultType; [EOL] }
protected JavaType _constructType(Type type, TypeBindings context) { [EOL]     JavaType resultType; [EOL]     if (type instanceof Class<?>) { [EOL]         Class<?> cls = (Class<?>) type; [EOL]         resultType = _fromClass(cls, context); [EOL]     } else if (type instanceof ParameterizedType) { [EOL]         resultType = _fromParamType((ParameterizedType) type, context); [EOL]     } else if (type instanceof JavaType) { [EOL]         return (JavaType) type; [EOL]     } else if (type instanceof GenericArrayType) { [EOL]         resultType = _fromArrayType((GenericArrayType) type, context); [EOL]     } else if (type instanceof TypeVariable<?>) { [EOL]         resultType = _fromVariable((TypeVariable<?>) type, context); [EOL]     } else if (type instanceof WildcardType) { [EOL]         resultType = _fromWildcard((WildcardType) type, context); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Unrecognized Type: " + ((type == null) ? "[null]" : type.toString())); [EOL]     } [EOL]     if (_modifiers != null && !resultType.isContainerType()) { [EOL]         for (TypeModifier mod : _modifiers) { [EOL]             resultType = mod.modifyType(resultType, type, context, this); [EOL]         } [EOL]     } [EOL]     return resultType; [EOL] }
protected JavaType _constructType(Type type, TypeBindings context) { [EOL]     JavaType resultType; [EOL]     if (type instanceof Class<?>) { [EOL]         Class<?> cls = (Class<?>) type; [EOL]         resultType = _fromClass(cls, context); [EOL]     } else if (type instanceof ParameterizedType) { [EOL]         resultType = _fromParamType((ParameterizedType) type, context); [EOL]     } else if (type instanceof JavaType) { [EOL]         return (JavaType) type; [EOL]     } else if (type instanceof GenericArrayType) { [EOL]         resultType = _fromArrayType((GenericArrayType) type, context); [EOL]     } else if (type instanceof TypeVariable<?>) { [EOL]         resultType = _fromVariable((TypeVariable<?>) type, context); [EOL]     } else if (type instanceof WildcardType) { [EOL]         resultType = _fromWildcard((WildcardType) type, context); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Unrecognized Type: " + ((type == null) ? "[null]" : type.toString())); [EOL]     } [EOL]     if (_modifiers != null && !resultType.isContainerType()) { [EOL]         for (TypeModifier mod : _modifiers) { [EOL]             resultType = mod.modifyType(resultType, type, context, this); [EOL]         } [EOL]     } [EOL]     return resultType; [EOL] }
protected JavaType _constructType(Type type, TypeBindings context) { [EOL]     JavaType resultType; [EOL]     if (type instanceof Class<?>) { [EOL]         Class<?> cls = (Class<?>) type; [EOL]         resultType = _fromClass(cls, context); [EOL]     } else if (type instanceof ParameterizedType) { [EOL]         resultType = _fromParamType((ParameterizedType) type, context); [EOL]     } else if (type instanceof JavaType) { [EOL]         return (JavaType) type; [EOL]     } else if (type instanceof GenericArrayType) { [EOL]         resultType = _fromArrayType((GenericArrayType) type, context); [EOL]     } else if (type instanceof TypeVariable<?>) { [EOL]         resultType = _fromVariable((TypeVariable<?>) type, context); [EOL]     } else if (type instanceof WildcardType) { [EOL]         resultType = _fromWildcard((WildcardType) type, context); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Unrecognized Type: " + ((type == null) ? "[null]" : type.toString())); [EOL]     } [EOL]     if (_modifiers != null && !resultType.isContainerType()) { [EOL]         for (TypeModifier mod : _modifiers) { [EOL]             resultType = mod.modifyType(resultType, type, context, this); [EOL]         } [EOL]     } [EOL]     return resultType; [EOL] }
public MapType constructMapType(Class<? extends Map> mapClass, Class<?> keyClass, Class<?> valueClass) { [EOL]     return MapType.construct(mapClass, constructType(keyClass), constructType(valueClass)); [EOL] }
public MapType constructMapType(Class<? extends Map> mapClass, Class<?> keyClass, Class<?> valueClass) { [EOL]     return MapType.construct(mapClass, constructType(keyClass), constructType(valueClass)); [EOL] }
public MapType constructMapType(Class<? extends Map> mapClass, Class<?> keyClass, Class<?> valueClass) { [EOL]     return MapType.construct(mapClass, constructType(keyClass), constructType(valueClass)); [EOL] }
public MapType constructMapType(Class<? extends Map> mapClass, Class<?> keyClass, Class<?> valueClass) { [EOL]     return MapType.construct(mapClass, constructType(keyClass), constructType(valueClass)); [EOL] }
public CollectionType constructRawCollectionType(Class<? extends Collection> collectionClass) { [EOL]     return CollectionType.construct(collectionClass, unknownType()); [EOL] }
public CollectionType constructRawCollectionType(Class<? extends Collection> collectionClass) { [EOL]     return CollectionType.construct(collectionClass, unknownType()); [EOL] }
public CollectionLikeType constructRawCollectionLikeType(Class<?> collectionClass) { [EOL]     return CollectionLikeType.construct(collectionClass, unknownType()); [EOL] }
public CollectionLikeType constructRawCollectionLikeType(Class<?> collectionClass) { [EOL]     return CollectionLikeType.construct(collectionClass, unknownType()); [EOL] }
protected JavaType _fromClass(Class<?> clz, TypeBindings context) { [EOL]     if (clz == String.class) [EOL]         return CORE_TYPE_STRING; [EOL]     if (clz == Boolean.TYPE) [EOL]         return CORE_TYPE_BOOL; [EOL]     if (clz == Integer.TYPE) [EOL]         return CORE_TYPE_INT; [EOL]     if (clz == Long.TYPE) [EOL]         return CORE_TYPE_LONG; [EOL]     ClassKey key = new ClassKey(clz); [EOL]     JavaType result; [EOL]     synchronized (_typeCache) { [EOL]         result = _typeCache.get(key); [EOL]     } [EOL]     if (result != null) { [EOL]         return result; [EOL]     } [EOL]     if (clz.isArray()) { [EOL]         result = ArrayType.construct(_constructType(clz.getComponentType(), null), null, null); [EOL]     } else if (clz.isEnum()) { [EOL]         result = new SimpleType(clz); [EOL]     } else if (Map.class.isAssignableFrom(clz)) { [EOL]         result = _mapType(clz); [EOL]     } else if (Collection.class.isAssignableFrom(clz)) { [EOL]         result = _collectionType(clz); [EOL]     } else { [EOL]         result = new SimpleType(clz); [EOL]     } [EOL]     synchronized (_typeCache) { [EOL]         _typeCache.put(key, result); [EOL]     } [EOL]     return result; [EOL] }
protected JavaType _fromClass(Class<?> clz, TypeBindings context) { [EOL]     if (clz == String.class) [EOL]         return CORE_TYPE_STRING; [EOL]     if (clz == Boolean.TYPE) [EOL]         return CORE_TYPE_BOOL; [EOL]     if (clz == Integer.TYPE) [EOL]         return CORE_TYPE_INT; [EOL]     if (clz == Long.TYPE) [EOL]         return CORE_TYPE_LONG; [EOL]     ClassKey key = new ClassKey(clz); [EOL]     JavaType result; [EOL]     synchronized (_typeCache) { [EOL]         result = _typeCache.get(key); [EOL]     } [EOL]     if (result != null) { [EOL]         return result; [EOL]     } [EOL]     if (clz.isArray()) { [EOL]         result = ArrayType.construct(_constructType(clz.getComponentType(), null), null, null); [EOL]     } else if (clz.isEnum()) { [EOL]         result = new SimpleType(clz); [EOL]     } else if (Map.class.isAssignableFrom(clz)) { [EOL]         result = _mapType(clz); [EOL]     } else if (Collection.class.isAssignableFrom(clz)) { [EOL]         result = _collectionType(clz); [EOL]     } else { [EOL]         result = new SimpleType(clz); [EOL]     } [EOL]     synchronized (_typeCache) { [EOL]         _typeCache.put(key, result); [EOL]     } [EOL]     return result; [EOL] }
protected JavaType _fromClass(Class<?> clz, TypeBindings context) { [EOL]     if (clz == String.class) [EOL]         return CORE_TYPE_STRING; [EOL]     if (clz == Boolean.TYPE) [EOL]         return CORE_TYPE_BOOL; [EOL]     if (clz == Integer.TYPE) [EOL]         return CORE_TYPE_INT; [EOL]     if (clz == Long.TYPE) [EOL]         return CORE_TYPE_LONG; [EOL]     ClassKey key = new ClassKey(clz); [EOL]     JavaType result; [EOL]     synchronized (_typeCache) { [EOL]         result = _typeCache.get(key); [EOL]     } [EOL]     if (result != null) { [EOL]         return result; [EOL]     } [EOL]     if (clz.isArray()) { [EOL]         result = ArrayType.construct(_constructType(clz.getComponentType(), null), null, null); [EOL]     } else if (clz.isEnum()) { [EOL]         result = new SimpleType(clz); [EOL]     } else if (Map.class.isAssignableFrom(clz)) { [EOL]         result = _mapType(clz); [EOL]     } else if (Collection.class.isAssignableFrom(clz)) { [EOL]         result = _collectionType(clz); [EOL]     } else { [EOL]         result = new SimpleType(clz); [EOL]     } [EOL]     synchronized (_typeCache) { [EOL]         _typeCache.put(key, result); [EOL]     } [EOL]     return result; [EOL] }
protected JavaType _fromClass(Class<?> clz, TypeBindings context) { [EOL]     if (clz == String.class) [EOL]         return CORE_TYPE_STRING; [EOL]     if (clz == Boolean.TYPE) [EOL]         return CORE_TYPE_BOOL; [EOL]     if (clz == Integer.TYPE) [EOL]         return CORE_TYPE_INT; [EOL]     if (clz == Long.TYPE) [EOL]         return CORE_TYPE_LONG; [EOL]     ClassKey key = new ClassKey(clz); [EOL]     JavaType result; [EOL]     synchronized (_typeCache) { [EOL]         result = _typeCache.get(key); [EOL]     } [EOL]     if (result != null) { [EOL]         return result; [EOL]     } [EOL]     if (clz.isArray()) { [EOL]         result = ArrayType.construct(_constructType(clz.getComponentType(), null), null, null); [EOL]     } else if (clz.isEnum()) { [EOL]         result = new SimpleType(clz); [EOL]     } else if (Map.class.isAssignableFrom(clz)) { [EOL]         result = _mapType(clz); [EOL]     } else if (Collection.class.isAssignableFrom(clz)) { [EOL]         result = _collectionType(clz); [EOL]     } else { [EOL]         result = new SimpleType(clz); [EOL]     } [EOL]     synchronized (_typeCache) { [EOL]         _typeCache.put(key, result); [EOL]     } [EOL]     return result; [EOL] }
protected JavaType _fromClass(Class<?> clz, TypeBindings context) { [EOL]     if (clz == String.class) [EOL]         return CORE_TYPE_STRING; [EOL]     if (clz == Boolean.TYPE) [EOL]         return CORE_TYPE_BOOL; [EOL]     if (clz == Integer.TYPE) [EOL]         return CORE_TYPE_INT; [EOL]     if (clz == Long.TYPE) [EOL]         return CORE_TYPE_LONG; [EOL]     ClassKey key = new ClassKey(clz); [EOL]     JavaType result; [EOL]     synchronized (_typeCache) { [EOL]         result = _typeCache.get(key); [EOL]     } [EOL]     if (result != null) { [EOL]         return result; [EOL]     } [EOL]     if (clz.isArray()) { [EOL]         result = ArrayType.construct(_constructType(clz.getComponentType(), null), null, null); [EOL]     } else if (clz.isEnum()) { [EOL]         result = new SimpleType(clz); [EOL]     } else if (Map.class.isAssignableFrom(clz)) { [EOL]         result = _mapType(clz); [EOL]     } else if (Collection.class.isAssignableFrom(clz)) { [EOL]         result = _collectionType(clz); [EOL]     } else { [EOL]         result = new SimpleType(clz); [EOL]     } [EOL]     synchronized (_typeCache) { [EOL]         _typeCache.put(key, result); [EOL]     } [EOL]     return result; [EOL] }
protected JavaType _fromClass(Class<?> clz, TypeBindings context) { [EOL]     if (clz == String.class) [EOL]         return CORE_TYPE_STRING; [EOL]     if (clz == Boolean.TYPE) [EOL]         return CORE_TYPE_BOOL; [EOL]     if (clz == Integer.TYPE) [EOL]         return CORE_TYPE_INT; [EOL]     if (clz == Long.TYPE) [EOL]         return CORE_TYPE_LONG; [EOL]     ClassKey key = new ClassKey(clz); [EOL]     JavaType result; [EOL]     synchronized (_typeCache) { [EOL]         result = _typeCache.get(key); [EOL]     } [EOL]     if (result != null) { [EOL]         return result; [EOL]     } [EOL]     if (clz.isArray()) { [EOL]         result = ArrayType.construct(_constructType(clz.getComponentType(), null), null, null); [EOL]     } else if (clz.isEnum()) { [EOL]         result = new SimpleType(clz); [EOL]     } else if (Map.class.isAssignableFrom(clz)) { [EOL]         result = _mapType(clz); [EOL]     } else if (Collection.class.isAssignableFrom(clz)) { [EOL]         result = _collectionType(clz); [EOL]     } else { [EOL]         result = new SimpleType(clz); [EOL]     } [EOL]     synchronized (_typeCache) { [EOL]         _typeCache.put(key, result); [EOL]     } [EOL]     return result; [EOL] }
protected JavaType _fromClass(Class<?> clz, TypeBindings context) { [EOL]     if (clz == String.class) [EOL]         return CORE_TYPE_STRING; [EOL]     if (clz == Boolean.TYPE) [EOL]         return CORE_TYPE_BOOL; [EOL]     if (clz == Integer.TYPE) [EOL]         return CORE_TYPE_INT; [EOL]     if (clz == Long.TYPE) [EOL]         return CORE_TYPE_LONG; [EOL]     ClassKey key = new ClassKey(clz); [EOL]     JavaType result; [EOL]     synchronized (_typeCache) { [EOL]         result = _typeCache.get(key); [EOL]     } [EOL]     if (result != null) { [EOL]         return result; [EOL]     } [EOL]     if (clz.isArray()) { [EOL]         result = ArrayType.construct(_constructType(clz.getComponentType(), null), null, null); [EOL]     } else if (clz.isEnum()) { [EOL]         result = new SimpleType(clz); [EOL]     } else if (Map.class.isAssignableFrom(clz)) { [EOL]         result = _mapType(clz); [EOL]     } else if (Collection.class.isAssignableFrom(clz)) { [EOL]         result = _collectionType(clz); [EOL]     } else { [EOL]         result = new SimpleType(clz); [EOL]     } [EOL]     synchronized (_typeCache) { [EOL]         _typeCache.put(key, result); [EOL]     } [EOL]     return result; [EOL] }
protected JavaType _fromClass(Class<?> clz, TypeBindings context) { [EOL]     if (clz == String.class) [EOL]         return CORE_TYPE_STRING; [EOL]     if (clz == Boolean.TYPE) [EOL]         return CORE_TYPE_BOOL; [EOL]     if (clz == Integer.TYPE) [EOL]         return CORE_TYPE_INT; [EOL]     if (clz == Long.TYPE) [EOL]         return CORE_TYPE_LONG; [EOL]     ClassKey key = new ClassKey(clz); [EOL]     JavaType result; [EOL]     synchronized (_typeCache) { [EOL]         result = _typeCache.get(key); [EOL]     } [EOL]     if (result != null) { [EOL]         return result; [EOL]     } [EOL]     if (clz.isArray()) { [EOL]         result = ArrayType.construct(_constructType(clz.getComponentType(), null), null, null); [EOL]     } else if (clz.isEnum()) { [EOL]         result = new SimpleType(clz); [EOL]     } else if (Map.class.isAssignableFrom(clz)) { [EOL]         result = _mapType(clz); [EOL]     } else if (Collection.class.isAssignableFrom(clz)) { [EOL]         result = _collectionType(clz); [EOL]     } else { [EOL]         result = new SimpleType(clz); [EOL]     } [EOL]     synchronized (_typeCache) { [EOL]         _typeCache.put(key, result); [EOL]     } [EOL]     return result; [EOL] }
protected JavaType _fromClass(Class<?> clz, TypeBindings context) { [EOL]     if (clz == String.class) [EOL]         return CORE_TYPE_STRING; [EOL]     if (clz == Boolean.TYPE) [EOL]         return CORE_TYPE_BOOL; [EOL]     if (clz == Integer.TYPE) [EOL]         return CORE_TYPE_INT; [EOL]     if (clz == Long.TYPE) [EOL]         return CORE_TYPE_LONG; [EOL]     ClassKey key = new ClassKey(clz); [EOL]     JavaType result; [EOL]     synchronized (_typeCache) { [EOL]         result = _typeCache.get(key); [EOL]     } [EOL]     if (result != null) { [EOL]         return result; [EOL]     } [EOL]     if (clz.isArray()) { [EOL]         result = ArrayType.construct(_constructType(clz.getComponentType(), null), null, null); [EOL]     } else if (clz.isEnum()) { [EOL]         result = new SimpleType(clz); [EOL]     } else if (Map.class.isAssignableFrom(clz)) { [EOL]         result = _mapType(clz); [EOL]     } else if (Collection.class.isAssignableFrom(clz)) { [EOL]         result = _collectionType(clz); [EOL]     } else { [EOL]         result = new SimpleType(clz); [EOL]     } [EOL]     synchronized (_typeCache) { [EOL]         _typeCache.put(key, result); [EOL]     } [EOL]     return result; [EOL] }
protected JavaType _fromClass(Class<?> clz, TypeBindings context) { [EOL]     if (clz == String.class) [EOL]         return CORE_TYPE_STRING; [EOL]     if (clz == Boolean.TYPE) [EOL]         return CORE_TYPE_BOOL; [EOL]     if (clz == Integer.TYPE) [EOL]         return CORE_TYPE_INT; [EOL]     if (clz == Long.TYPE) [EOL]         return CORE_TYPE_LONG; [EOL]     ClassKey key = new ClassKey(clz); [EOL]     JavaType result; [EOL]     synchronized (_typeCache) { [EOL]         result = _typeCache.get(key); [EOL]     } [EOL]     if (result != null) { [EOL]         return result; [EOL]     } [EOL]     if (clz.isArray()) { [EOL]         result = ArrayType.construct(_constructType(clz.getComponentType(), null), null, null); [EOL]     } else if (clz.isEnum()) { [EOL]         result = new SimpleType(clz); [EOL]     } else if (Map.class.isAssignableFrom(clz)) { [EOL]         result = _mapType(clz); [EOL]     } else if (Collection.class.isAssignableFrom(clz)) { [EOL]         result = _collectionType(clz); [EOL]     } else { [EOL]         result = new SimpleType(clz); [EOL]     } [EOL]     synchronized (_typeCache) { [EOL]         _typeCache.put(key, result); [EOL]     } [EOL]     return result; [EOL] }
protected JavaType _fromParameterizedClass(Class<?> clz, List<JavaType> paramTypes) { [EOL]     if (clz.isArray()) { [EOL]         return ArrayType.construct(_constructType(clz.getComponentType(), null), null, null); [EOL]     } [EOL]     if (clz.isEnum()) { [EOL]         return new SimpleType(clz); [EOL]     } [EOL]     if (Map.class.isAssignableFrom(clz)) { [EOL]         JavaType keyType, contentType; [EOL]         if (paramTypes.size() > 0) { [EOL]             keyType = paramTypes.get(0); [EOL]             contentType = (paramTypes.size() >= 2) ? paramTypes.get(1) : _unknownType(); [EOL]             return MapType.construct(clz, keyType, contentType); [EOL]         } [EOL]         return _mapType(clz); [EOL]     } [EOL]     if (Collection.class.isAssignableFrom(clz)) { [EOL]         if (paramTypes.size() >= 1) { [EOL]             return CollectionType.construct(clz, paramTypes.get(0)); [EOL]         } [EOL]         return _collectionType(clz); [EOL]     } [EOL]     if (paramTypes.size() == 0) { [EOL]         return new SimpleType(clz); [EOL]     } [EOL]     JavaType[] pt = paramTypes.toArray(new JavaType[paramTypes.size()]); [EOL]     return constructSimpleType(clz, pt); [EOL] }
protected JavaType _fromParameterizedClass(Class<?> clz, List<JavaType> paramTypes) { [EOL]     if (clz.isArray()) { [EOL]         return ArrayType.construct(_constructType(clz.getComponentType(), null), null, null); [EOL]     } [EOL]     if (clz.isEnum()) { [EOL]         return new SimpleType(clz); [EOL]     } [EOL]     if (Map.class.isAssignableFrom(clz)) { [EOL]         JavaType keyType, contentType; [EOL]         if (paramTypes.size() > 0) { [EOL]             keyType = paramTypes.get(0); [EOL]             contentType = (paramTypes.size() >= 2) ? paramTypes.get(1) : _unknownType(); [EOL]             return MapType.construct(clz, keyType, contentType); [EOL]         } [EOL]         return _mapType(clz); [EOL]     } [EOL]     if (Collection.class.isAssignableFrom(clz)) { [EOL]         if (paramTypes.size() >= 1) { [EOL]             return CollectionType.construct(clz, paramTypes.get(0)); [EOL]         } [EOL]         return _collectionType(clz); [EOL]     } [EOL]     if (paramTypes.size() == 0) { [EOL]         return new SimpleType(clz); [EOL]     } [EOL]     JavaType[] pt = paramTypes.toArray(new JavaType[paramTypes.size()]); [EOL]     return constructSimpleType(clz, pt); [EOL] }
protected JavaType _fromParameterizedClass(Class<?> clz, List<JavaType> paramTypes) { [EOL]     if (clz.isArray()) { [EOL]         return ArrayType.construct(_constructType(clz.getComponentType(), null), null, null); [EOL]     } [EOL]     if (clz.isEnum()) { [EOL]         return new SimpleType(clz); [EOL]     } [EOL]     if (Map.class.isAssignableFrom(clz)) { [EOL]         JavaType keyType, contentType; [EOL]         if (paramTypes.size() > 0) { [EOL]             keyType = paramTypes.get(0); [EOL]             contentType = (paramTypes.size() >= 2) ? paramTypes.get(1) : _unknownType(); [EOL]             return MapType.construct(clz, keyType, contentType); [EOL]         } [EOL]         return _mapType(clz); [EOL]     } [EOL]     if (Collection.class.isAssignableFrom(clz)) { [EOL]         if (paramTypes.size() >= 1) { [EOL]             return CollectionType.construct(clz, paramTypes.get(0)); [EOL]         } [EOL]         return _collectionType(clz); [EOL]     } [EOL]     if (paramTypes.size() == 0) { [EOL]         return new SimpleType(clz); [EOL]     } [EOL]     JavaType[] pt = paramTypes.toArray(new JavaType[paramTypes.size()]); [EOL]     return constructSimpleType(clz, pt); [EOL] }
protected JavaType _fromParameterizedClass(Class<?> clz, List<JavaType> paramTypes) { [EOL]     if (clz.isArray()) { [EOL]         return ArrayType.construct(_constructType(clz.getComponentType(), null), null, null); [EOL]     } [EOL]     if (clz.isEnum()) { [EOL]         return new SimpleType(clz); [EOL]     } [EOL]     if (Map.class.isAssignableFrom(clz)) { [EOL]         JavaType keyType, contentType; [EOL]         if (paramTypes.size() > 0) { [EOL]             keyType = paramTypes.get(0); [EOL]             contentType = (paramTypes.size() >= 2) ? paramTypes.get(1) : _unknownType(); [EOL]             return MapType.construct(clz, keyType, contentType); [EOL]         } [EOL]         return _mapType(clz); [EOL]     } [EOL]     if (Collection.class.isAssignableFrom(clz)) { [EOL]         if (paramTypes.size() >= 1) { [EOL]             return CollectionType.construct(clz, paramTypes.get(0)); [EOL]         } [EOL]         return _collectionType(clz); [EOL]     } [EOL]     if (paramTypes.size() == 0) { [EOL]         return new SimpleType(clz); [EOL]     } [EOL]     JavaType[] pt = paramTypes.toArray(new JavaType[paramTypes.size()]); [EOL]     return constructSimpleType(clz, pt); [EOL] }
protected JavaType _fromParameterizedClass(Class<?> clz, List<JavaType> paramTypes) { [EOL]     if (clz.isArray()) { [EOL]         return ArrayType.construct(_constructType(clz.getComponentType(), null), null, null); [EOL]     } [EOL]     if (clz.isEnum()) { [EOL]         return new SimpleType(clz); [EOL]     } [EOL]     if (Map.class.isAssignableFrom(clz)) { [EOL]         JavaType keyType, contentType; [EOL]         if (paramTypes.size() > 0) { [EOL]             keyType = paramTypes.get(0); [EOL]             contentType = (paramTypes.size() >= 2) ? paramTypes.get(1) : _unknownType(); [EOL]             return MapType.construct(clz, keyType, contentType); [EOL]         } [EOL]         return _mapType(clz); [EOL]     } [EOL]     if (Collection.class.isAssignableFrom(clz)) { [EOL]         if (paramTypes.size() >= 1) { [EOL]             return CollectionType.construct(clz, paramTypes.get(0)); [EOL]         } [EOL]         return _collectionType(clz); [EOL]     } [EOL]     if (paramTypes.size() == 0) { [EOL]         return new SimpleType(clz); [EOL]     } [EOL]     JavaType[] pt = paramTypes.toArray(new JavaType[paramTypes.size()]); [EOL]     return constructSimpleType(clz, pt); [EOL] }
protected JavaType _fromParameterizedClass(Class<?> clz, List<JavaType> paramTypes) { [EOL]     if (clz.isArray()) { [EOL]         return ArrayType.construct(_constructType(clz.getComponentType(), null), null, null); [EOL]     } [EOL]     if (clz.isEnum()) { [EOL]         return new SimpleType(clz); [EOL]     } [EOL]     if (Map.class.isAssignableFrom(clz)) { [EOL]         JavaType keyType, contentType; [EOL]         if (paramTypes.size() > 0) { [EOL]             keyType = paramTypes.get(0); [EOL]             contentType = (paramTypes.size() >= 2) ? paramTypes.get(1) : _unknownType(); [EOL]             return MapType.construct(clz, keyType, contentType); [EOL]         } [EOL]         return _mapType(clz); [EOL]     } [EOL]     if (Collection.class.isAssignableFrom(clz)) { [EOL]         if (paramTypes.size() >= 1) { [EOL]             return CollectionType.construct(clz, paramTypes.get(0)); [EOL]         } [EOL]         return _collectionType(clz); [EOL]     } [EOL]     if (paramTypes.size() == 0) { [EOL]         return new SimpleType(clz); [EOL]     } [EOL]     JavaType[] pt = paramTypes.toArray(new JavaType[paramTypes.size()]); [EOL]     return constructSimpleType(clz, pt); [EOL] }
protected JavaType _fromParameterizedClass(Class<?> clz, List<JavaType> paramTypes) { [EOL]     if (clz.isArray()) { [EOL]         return ArrayType.construct(_constructType(clz.getComponentType(), null), null, null); [EOL]     } [EOL]     if (clz.isEnum()) { [EOL]         return new SimpleType(clz); [EOL]     } [EOL]     if (Map.class.isAssignableFrom(clz)) { [EOL]         JavaType keyType, contentType; [EOL]         if (paramTypes.size() > 0) { [EOL]             keyType = paramTypes.get(0); [EOL]             contentType = (paramTypes.size() >= 2) ? paramTypes.get(1) : _unknownType(); [EOL]             return MapType.construct(clz, keyType, contentType); [EOL]         } [EOL]         return _mapType(clz); [EOL]     } [EOL]     if (Collection.class.isAssignableFrom(clz)) { [EOL]         if (paramTypes.size() >= 1) { [EOL]             return CollectionType.construct(clz, paramTypes.get(0)); [EOL]         } [EOL]         return _collectionType(clz); [EOL]     } [EOL]     if (paramTypes.size() == 0) { [EOL]         return new SimpleType(clz); [EOL]     } [EOL]     JavaType[] pt = paramTypes.toArray(new JavaType[paramTypes.size()]); [EOL]     return constructSimpleType(clz, pt); [EOL] }
protected JavaType _fromParameterizedClass(Class<?> clz, List<JavaType> paramTypes) { [EOL]     if (clz.isArray()) { [EOL]         return ArrayType.construct(_constructType(clz.getComponentType(), null), null, null); [EOL]     } [EOL]     if (clz.isEnum()) { [EOL]         return new SimpleType(clz); [EOL]     } [EOL]     if (Map.class.isAssignableFrom(clz)) { [EOL]         JavaType keyType, contentType; [EOL]         if (paramTypes.size() > 0) { [EOL]             keyType = paramTypes.get(0); [EOL]             contentType = (paramTypes.size() >= 2) ? paramTypes.get(1) : _unknownType(); [EOL]             return MapType.construct(clz, keyType, contentType); [EOL]         } [EOL]         return _mapType(clz); [EOL]     } [EOL]     if (Collection.class.isAssignableFrom(clz)) { [EOL]         if (paramTypes.size() >= 1) { [EOL]             return CollectionType.construct(clz, paramTypes.get(0)); [EOL]         } [EOL]         return _collectionType(clz); [EOL]     } [EOL]     if (paramTypes.size() == 0) { [EOL]         return new SimpleType(clz); [EOL]     } [EOL]     JavaType[] pt = paramTypes.toArray(new JavaType[paramTypes.size()]); [EOL]     return constructSimpleType(clz, pt); [EOL] }
protected JavaType _fromVariable(TypeVariable<?> type, TypeBindings context) { [EOL]     if (context == null) { [EOL]         return _unknownType(); [EOL]     } [EOL]     String name = type.getName(); [EOL]     JavaType actualType = context.findType(name); [EOL]     if (actualType != null) { [EOL]         return actualType; [EOL]     } [EOL]     Type[] bounds = type.getBounds(); [EOL]     context._addPlaceholder(name); [EOL]     return _constructType(bounds[0], context); [EOL] }
protected JavaType _fromVariable(TypeVariable<?> type, TypeBindings context) { [EOL]     if (context == null) { [EOL]         return _unknownType(); [EOL]     } [EOL]     String name = type.getName(); [EOL]     JavaType actualType = context.findType(name); [EOL]     if (actualType != null) { [EOL]         return actualType; [EOL]     } [EOL]     Type[] bounds = type.getBounds(); [EOL]     context._addPlaceholder(name); [EOL]     return _constructType(bounds[0], context); [EOL] }
protected JavaType _fromVariable(TypeVariable<?> type, TypeBindings context) { [EOL]     if (context == null) { [EOL]         return _unknownType(); [EOL]     } [EOL]     String name = type.getName(); [EOL]     JavaType actualType = context.findType(name); [EOL]     if (actualType != null) { [EOL]         return actualType; [EOL]     } [EOL]     Type[] bounds = type.getBounds(); [EOL]     context._addPlaceholder(name); [EOL]     return _constructType(bounds[0], context); [EOL] }
protected JavaType _fromWildcard(WildcardType type, TypeBindings context) { [EOL]     return _constructType(type.getUpperBounds()[0], context); [EOL] }
private JavaType _mapType(Class<?> rawClass) { [EOL]     JavaType[] typeParams = findTypeParameters(rawClass, Map.class); [EOL]     if (typeParams == null) { [EOL]         return MapType.construct(rawClass, _unknownType(), _unknownType()); [EOL]     } [EOL]     if (typeParams.length != 2) { [EOL]         throw new IllegalArgumentException("Strange Map type " + rawClass.getName() + ": can not determine type parameters"); [EOL]     } [EOL]     return MapType.construct(rawClass, typeParams[0], typeParams[1]); [EOL] }
private JavaType _mapType(Class<?> rawClass) { [EOL]     JavaType[] typeParams = findTypeParameters(rawClass, Map.class); [EOL]     if (typeParams == null) { [EOL]         return MapType.construct(rawClass, _unknownType(), _unknownType()); [EOL]     } [EOL]     if (typeParams.length != 2) { [EOL]         throw new IllegalArgumentException("Strange Map type " + rawClass.getName() + ": can not determine type parameters"); [EOL]     } [EOL]     return MapType.construct(rawClass, typeParams[0], typeParams[1]); [EOL] }
private JavaType _mapType(Class<?> rawClass) { [EOL]     JavaType[] typeParams = findTypeParameters(rawClass, Map.class); [EOL]     if (typeParams == null) { [EOL]         return MapType.construct(rawClass, _unknownType(), _unknownType()); [EOL]     } [EOL]     if (typeParams.length != 2) { [EOL]         throw new IllegalArgumentException("Strange Map type " + rawClass.getName() + ": can not determine type parameters"); [EOL]     } [EOL]     return MapType.construct(rawClass, typeParams[0], typeParams[1]); [EOL] }
private JavaType _collectionType(Class<?> rawClass) { [EOL]     JavaType[] typeParams = findTypeParameters(rawClass, Collection.class); [EOL]     if (typeParams == null) { [EOL]         return CollectionType.construct(rawClass, _unknownType()); [EOL]     } [EOL]     if (typeParams.length != 1) { [EOL]         throw new IllegalArgumentException("Strange Collection type " + rawClass.getName() + ": can not determine type parameters"); [EOL]     } [EOL]     return CollectionType.construct(rawClass, typeParams[0]); [EOL] }
private JavaType _collectionType(Class<?> rawClass) { [EOL]     JavaType[] typeParams = findTypeParameters(rawClass, Collection.class); [EOL]     if (typeParams == null) { [EOL]         return CollectionType.construct(rawClass, _unknownType()); [EOL]     } [EOL]     if (typeParams.length != 1) { [EOL]         throw new IllegalArgumentException("Strange Collection type " + rawClass.getName() + ": can not determine type parameters"); [EOL]     } [EOL]     return CollectionType.construct(rawClass, typeParams[0]); [EOL] }
private JavaType _collectionType(Class<?> rawClass) { [EOL]     JavaType[] typeParams = findTypeParameters(rawClass, Collection.class); [EOL]     if (typeParams == null) { [EOL]         return CollectionType.construct(rawClass, _unknownType()); [EOL]     } [EOL]     if (typeParams.length != 1) { [EOL]         throw new IllegalArgumentException("Strange Collection type " + rawClass.getName() + ": can not determine type parameters"); [EOL]     } [EOL]     return CollectionType.construct(rawClass, typeParams[0]); [EOL] }
protected HierarchicType _findSuperTypeChain(Class<?> subtype, Class<?> supertype) { [EOL]     if (supertype.isInterface()) { [EOL]         return _findSuperInterfaceChain(subtype, supertype); [EOL]     } [EOL]     return _findSuperClassChain(subtype, supertype); [EOL] }
protected HierarchicType _findSuperInterfaceChain(Type currentType, Class<?> target) { [EOL]     HierarchicType current = new HierarchicType(currentType); [EOL]     Class<?> raw = current.getRawClass(); [EOL]     if (raw == target) { [EOL]         return new HierarchicType(currentType); [EOL]     } [EOL]     if (raw == HashMap.class) { [EOL]         if (target == Map.class) { [EOL]             return _hashMapSuperInterfaceChain(current); [EOL]         } [EOL]     } [EOL]     if (raw == ArrayList.class) { [EOL]         if (target == List.class) { [EOL]             return _arrayListSuperInterfaceChain(current); [EOL]         } [EOL]     } [EOL]     return _doFindSuperInterfaceChain(current, target); [EOL] }
protected HierarchicType _doFindSuperInterfaceChain(HierarchicType current, Class<?> target) { [EOL]     Class<?> raw = current.getRawClass(); [EOL]     Type[] parents = raw.getGenericInterfaces(); [EOL]     if (parents != null) { [EOL]         for (Type parent : parents) { [EOL]             HierarchicType sup = _findSuperInterfaceChain(parent, target); [EOL]             if (sup != null) { [EOL]                 sup.setSubType(current); [EOL]                 current.setSuperType(sup); [EOL]                 return current; [EOL]             } [EOL]         } [EOL]     } [EOL]     Type parent = raw.getGenericSuperclass(); [EOL]     if (parent != null) { [EOL]         HierarchicType sup = _findSuperInterfaceChain(parent, target); [EOL]         if (sup != null) { [EOL]             sup.setSubType(current); [EOL]             current.setSuperType(sup); [EOL]             return current; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
protected synchronized HierarchicType _hashMapSuperInterfaceChain(HierarchicType current) { [EOL]     if (_cachedHashMapType == null) { [EOL]         HierarchicType base = current.deepCloneWithoutSubtype(); [EOL]         _doFindSuperInterfaceChain(base, Map.class); [EOL]         _cachedHashMapType = base.getSuperType(); [EOL]     } [EOL]     HierarchicType t = _cachedHashMapType.deepCloneWithoutSubtype(); [EOL]     current.setSuperType(t); [EOL]     t.setSubType(current); [EOL]     return current; [EOL] }
protected synchronized HierarchicType _hashMapSuperInterfaceChain(HierarchicType current) { [EOL]     if (_cachedHashMapType == null) { [EOL]         HierarchicType base = current.deepCloneWithoutSubtype(); [EOL]         _doFindSuperInterfaceChain(base, Map.class); [EOL]         _cachedHashMapType = base.getSuperType(); [EOL]     } [EOL]     HierarchicType t = _cachedHashMapType.deepCloneWithoutSubtype(); [EOL]     current.setSuperType(t); [EOL]     t.setSubType(current); [EOL]     return current; [EOL] }
@Override [EOL] public Object deserializeTypedFromAny(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (jp.getCurrentToken() == JsonToken.START_ARRAY) { [EOL]         return super.deserializeTypedFromArray(jp, ctxt); [EOL]     } [EOL]     return deserializeTypedFromObject(jp, ctxt); [EOL] }
@Override [EOL] public Object deserializeTypedFromAny(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (jp.getCurrentToken() == JsonToken.START_ARRAY) { [EOL]         return super.deserializeTypedFromArray(jp, ctxt); [EOL]     } [EOL]     return deserializeTypedFromObject(jp, ctxt); [EOL] }
protected MapperConfigBase(MapperConfigBase<CFG, T> src) { [EOL]     super(src); [EOL]     _mixInAnnotations = src._mixInAnnotations; [EOL]     _subtypeResolver = src._subtypeResolver; [EOL]     _rootName = src._rootName; [EOL]     _view = src._view; [EOL] }
@Override [EOL] public void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             writeStartObject(); [EOL]             break; [EOL]         case END_OBJECT: [EOL]             writeEndObject(); [EOL]             break; [EOL]         case START_ARRAY: [EOL]             writeStartArray(); [EOL]             break; [EOL]         case END_ARRAY: [EOL]             writeEndArray(); [EOL]             break; [EOL]         case FIELD_NAME: [EOL]             writeFieldName(jp.getCurrentName()); [EOL]             break; [EOL]         case VALUE_STRING: [EOL]             if (jp.hasTextCharacters()) { [EOL]                 writeString(jp.getTextCharacters(), jp.getTextOffset(), jp.getTextLength()); [EOL]             } else { [EOL]                 writeString(jp.getText()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_INT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case INT: [EOL]                     writeNumber(jp.getIntValue()); [EOL]                     break; [EOL]                 case BIG_INTEGER: [EOL]                     writeNumber(jp.getBigIntegerValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getLongValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case BIG_DECIMAL: [EOL]                     writeNumber(jp.getDecimalValue()); [EOL]                     break; [EOL]                 case FLOAT: [EOL]                     writeNumber(jp.getFloatValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getDoubleValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_TRUE: [EOL]             writeBoolean(true); [EOL]             break; [EOL]         case VALUE_FALSE: [EOL]             writeBoolean(false); [EOL]             break; [EOL]         case VALUE_NULL: [EOL]             writeNull(); [EOL]             break; [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             writeObject(jp.getEmbeddedObject()); [EOL]             break; [EOL]         default: [EOL]             throw new RuntimeException("Internal error: should never end up through this code path"); [EOL]     } [EOL] }
@Override [EOL] public void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             writeStartObject(); [EOL]             break; [EOL]         case END_OBJECT: [EOL]             writeEndObject(); [EOL]             break; [EOL]         case START_ARRAY: [EOL]             writeStartArray(); [EOL]             break; [EOL]         case END_ARRAY: [EOL]             writeEndArray(); [EOL]             break; [EOL]         case FIELD_NAME: [EOL]             writeFieldName(jp.getCurrentName()); [EOL]             break; [EOL]         case VALUE_STRING: [EOL]             if (jp.hasTextCharacters()) { [EOL]                 writeString(jp.getTextCharacters(), jp.getTextOffset(), jp.getTextLength()); [EOL]             } else { [EOL]                 writeString(jp.getText()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_INT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case INT: [EOL]                     writeNumber(jp.getIntValue()); [EOL]                     break; [EOL]                 case BIG_INTEGER: [EOL]                     writeNumber(jp.getBigIntegerValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getLongValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case BIG_DECIMAL: [EOL]                     writeNumber(jp.getDecimalValue()); [EOL]                     break; [EOL]                 case FLOAT: [EOL]                     writeNumber(jp.getFloatValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getDoubleValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_TRUE: [EOL]             writeBoolean(true); [EOL]             break; [EOL]         case VALUE_FALSE: [EOL]             writeBoolean(false); [EOL]             break; [EOL]         case VALUE_NULL: [EOL]             writeNull(); [EOL]             break; [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             writeObject(jp.getEmbeddedObject()); [EOL]             break; [EOL]         default: [EOL]             throw new RuntimeException("Internal error: should never end up through this code path"); [EOL]     } [EOL] }
@Override [EOL] public void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             writeStartObject(); [EOL]             break; [EOL]         case END_OBJECT: [EOL]             writeEndObject(); [EOL]             break; [EOL]         case START_ARRAY: [EOL]             writeStartArray(); [EOL]             break; [EOL]         case END_ARRAY: [EOL]             writeEndArray(); [EOL]             break; [EOL]         case FIELD_NAME: [EOL]             writeFieldName(jp.getCurrentName()); [EOL]             break; [EOL]         case VALUE_STRING: [EOL]             if (jp.hasTextCharacters()) { [EOL]                 writeString(jp.getTextCharacters(), jp.getTextOffset(), jp.getTextLength()); [EOL]             } else { [EOL]                 writeString(jp.getText()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_INT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case INT: [EOL]                     writeNumber(jp.getIntValue()); [EOL]                     break; [EOL]                 case BIG_INTEGER: [EOL]                     writeNumber(jp.getBigIntegerValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getLongValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case BIG_DECIMAL: [EOL]                     writeNumber(jp.getDecimalValue()); [EOL]                     break; [EOL]                 case FLOAT: [EOL]                     writeNumber(jp.getFloatValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getDoubleValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_TRUE: [EOL]             writeBoolean(true); [EOL]             break; [EOL]         case VALUE_FALSE: [EOL]             writeBoolean(false); [EOL]             break; [EOL]         case VALUE_NULL: [EOL]             writeNull(); [EOL]             break; [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             writeObject(jp.getEmbeddedObject()); [EOL]             break; [EOL]         default: [EOL]             throw new RuntimeException("Internal error: should never end up through this code path"); [EOL]     } [EOL] }
@Override [EOL] public void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             writeStartObject(); [EOL]             break; [EOL]         case END_OBJECT: [EOL]             writeEndObject(); [EOL]             break; [EOL]         case START_ARRAY: [EOL]             writeStartArray(); [EOL]             break; [EOL]         case END_ARRAY: [EOL]             writeEndArray(); [EOL]             break; [EOL]         case FIELD_NAME: [EOL]             writeFieldName(jp.getCurrentName()); [EOL]             break; [EOL]         case VALUE_STRING: [EOL]             if (jp.hasTextCharacters()) { [EOL]                 writeString(jp.getTextCharacters(), jp.getTextOffset(), jp.getTextLength()); [EOL]             } else { [EOL]                 writeString(jp.getText()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_INT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case INT: [EOL]                     writeNumber(jp.getIntValue()); [EOL]                     break; [EOL]                 case BIG_INTEGER: [EOL]                     writeNumber(jp.getBigIntegerValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getLongValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case BIG_DECIMAL: [EOL]                     writeNumber(jp.getDecimalValue()); [EOL]                     break; [EOL]                 case FLOAT: [EOL]                     writeNumber(jp.getFloatValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getDoubleValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_TRUE: [EOL]             writeBoolean(true); [EOL]             break; [EOL]         case VALUE_FALSE: [EOL]             writeBoolean(false); [EOL]             break; [EOL]         case VALUE_NULL: [EOL]             writeNull(); [EOL]             break; [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             writeObject(jp.getEmbeddedObject()); [EOL]             break; [EOL]         default: [EOL]             throw new RuntimeException("Internal error: should never end up through this code path"); [EOL]     } [EOL] }
@Override [EOL] public void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             writeStartObject(); [EOL]             break; [EOL]         case END_OBJECT: [EOL]             writeEndObject(); [EOL]             break; [EOL]         case START_ARRAY: [EOL]             writeStartArray(); [EOL]             break; [EOL]         case END_ARRAY: [EOL]             writeEndArray(); [EOL]             break; [EOL]         case FIELD_NAME: [EOL]             writeFieldName(jp.getCurrentName()); [EOL]             break; [EOL]         case VALUE_STRING: [EOL]             if (jp.hasTextCharacters()) { [EOL]                 writeString(jp.getTextCharacters(), jp.getTextOffset(), jp.getTextLength()); [EOL]             } else { [EOL]                 writeString(jp.getText()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_INT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case INT: [EOL]                     writeNumber(jp.getIntValue()); [EOL]                     break; [EOL]                 case BIG_INTEGER: [EOL]                     writeNumber(jp.getBigIntegerValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getLongValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case BIG_DECIMAL: [EOL]                     writeNumber(jp.getDecimalValue()); [EOL]                     break; [EOL]                 case FLOAT: [EOL]                     writeNumber(jp.getFloatValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getDoubleValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_TRUE: [EOL]             writeBoolean(true); [EOL]             break; [EOL]         case VALUE_FALSE: [EOL]             writeBoolean(false); [EOL]             break; [EOL]         case VALUE_NULL: [EOL]             writeNull(); [EOL]             break; [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             writeObject(jp.getEmbeddedObject()); [EOL]             break; [EOL]         default: [EOL]             throw new RuntimeException("Internal error: should never end up through this code path"); [EOL]     } [EOL] }
@Override [EOL] public void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             writeStartObject(); [EOL]             break; [EOL]         case END_OBJECT: [EOL]             writeEndObject(); [EOL]             break; [EOL]         case START_ARRAY: [EOL]             writeStartArray(); [EOL]             break; [EOL]         case END_ARRAY: [EOL]             writeEndArray(); [EOL]             break; [EOL]         case FIELD_NAME: [EOL]             writeFieldName(jp.getCurrentName()); [EOL]             break; [EOL]         case VALUE_STRING: [EOL]             if (jp.hasTextCharacters()) { [EOL]                 writeString(jp.getTextCharacters(), jp.getTextOffset(), jp.getTextLength()); [EOL]             } else { [EOL]                 writeString(jp.getText()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_INT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case INT: [EOL]                     writeNumber(jp.getIntValue()); [EOL]                     break; [EOL]                 case BIG_INTEGER: [EOL]                     writeNumber(jp.getBigIntegerValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getLongValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case BIG_DECIMAL: [EOL]                     writeNumber(jp.getDecimalValue()); [EOL]                     break; [EOL]                 case FLOAT: [EOL]                     writeNumber(jp.getFloatValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getDoubleValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_TRUE: [EOL]             writeBoolean(true); [EOL]             break; [EOL]         case VALUE_FALSE: [EOL]             writeBoolean(false); [EOL]             break; [EOL]         case VALUE_NULL: [EOL]             writeNull(); [EOL]             break; [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             writeObject(jp.getEmbeddedObject()); [EOL]             break; [EOL]         default: [EOL]             throw new RuntimeException("Internal error: should never end up through this code path"); [EOL]     } [EOL] }
@Override [EOL] public void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             writeStartObject(); [EOL]             break; [EOL]         case END_OBJECT: [EOL]             writeEndObject(); [EOL]             break; [EOL]         case START_ARRAY: [EOL]             writeStartArray(); [EOL]             break; [EOL]         case END_ARRAY: [EOL]             writeEndArray(); [EOL]             break; [EOL]         case FIELD_NAME: [EOL]             writeFieldName(jp.getCurrentName()); [EOL]             break; [EOL]         case VALUE_STRING: [EOL]             if (jp.hasTextCharacters()) { [EOL]                 writeString(jp.getTextCharacters(), jp.getTextOffset(), jp.getTextLength()); [EOL]             } else { [EOL]                 writeString(jp.getText()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_INT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case INT: [EOL]                     writeNumber(jp.getIntValue()); [EOL]                     break; [EOL]                 case BIG_INTEGER: [EOL]                     writeNumber(jp.getBigIntegerValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getLongValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case BIG_DECIMAL: [EOL]                     writeNumber(jp.getDecimalValue()); [EOL]                     break; [EOL]                 case FLOAT: [EOL]                     writeNumber(jp.getFloatValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getDoubleValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_TRUE: [EOL]             writeBoolean(true); [EOL]             break; [EOL]         case VALUE_FALSE: [EOL]             writeBoolean(false); [EOL]             break; [EOL]         case VALUE_NULL: [EOL]             writeNull(); [EOL]             break; [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             writeObject(jp.getEmbeddedObject()); [EOL]             break; [EOL]         default: [EOL]             throw new RuntimeException("Internal error: should never end up through this code path"); [EOL]     } [EOL] }
@Override [EOL] public void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             writeStartObject(); [EOL]             break; [EOL]         case END_OBJECT: [EOL]             writeEndObject(); [EOL]             break; [EOL]         case START_ARRAY: [EOL]             writeStartArray(); [EOL]             break; [EOL]         case END_ARRAY: [EOL]             writeEndArray(); [EOL]             break; [EOL]         case FIELD_NAME: [EOL]             writeFieldName(jp.getCurrentName()); [EOL]             break; [EOL]         case VALUE_STRING: [EOL]             if (jp.hasTextCharacters()) { [EOL]                 writeString(jp.getTextCharacters(), jp.getTextOffset(), jp.getTextLength()); [EOL]             } else { [EOL]                 writeString(jp.getText()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_INT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case INT: [EOL]                     writeNumber(jp.getIntValue()); [EOL]                     break; [EOL]                 case BIG_INTEGER: [EOL]                     writeNumber(jp.getBigIntegerValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getLongValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case BIG_DECIMAL: [EOL]                     writeNumber(jp.getDecimalValue()); [EOL]                     break; [EOL]                 case FLOAT: [EOL]                     writeNumber(jp.getFloatValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getDoubleValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_TRUE: [EOL]             writeBoolean(true); [EOL]             break; [EOL]         case VALUE_FALSE: [EOL]             writeBoolean(false); [EOL]             break; [EOL]         case VALUE_NULL: [EOL]             writeNull(); [EOL]             break; [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             writeObject(jp.getEmbeddedObject()); [EOL]             break; [EOL]         default: [EOL]             throw new RuntimeException("Internal error: should never end up through this code path"); [EOL]     } [EOL] }
@Override [EOL] public void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             writeStartObject(); [EOL]             break; [EOL]         case END_OBJECT: [EOL]             writeEndObject(); [EOL]             break; [EOL]         case START_ARRAY: [EOL]             writeStartArray(); [EOL]             break; [EOL]         case END_ARRAY: [EOL]             writeEndArray(); [EOL]             break; [EOL]         case FIELD_NAME: [EOL]             writeFieldName(jp.getCurrentName()); [EOL]             break; [EOL]         case VALUE_STRING: [EOL]             if (jp.hasTextCharacters()) { [EOL]                 writeString(jp.getTextCharacters(), jp.getTextOffset(), jp.getTextLength()); [EOL]             } else { [EOL]                 writeString(jp.getText()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_INT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case INT: [EOL]                     writeNumber(jp.getIntValue()); [EOL]                     break; [EOL]                 case BIG_INTEGER: [EOL]                     writeNumber(jp.getBigIntegerValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getLongValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case BIG_DECIMAL: [EOL]                     writeNumber(jp.getDecimalValue()); [EOL]                     break; [EOL]                 case FLOAT: [EOL]                     writeNumber(jp.getFloatValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getDoubleValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_TRUE: [EOL]             writeBoolean(true); [EOL]             break; [EOL]         case VALUE_FALSE: [EOL]             writeBoolean(false); [EOL]             break; [EOL]         case VALUE_NULL: [EOL]             writeNull(); [EOL]             break; [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             writeObject(jp.getEmbeddedObject()); [EOL]             break; [EOL]         default: [EOL]             throw new RuntimeException("Internal error: should never end up through this code path"); [EOL]     } [EOL] }
@Override [EOL] public void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             writeStartObject(); [EOL]             break; [EOL]         case END_OBJECT: [EOL]             writeEndObject(); [EOL]             break; [EOL]         case START_ARRAY: [EOL]             writeStartArray(); [EOL]             break; [EOL]         case END_ARRAY: [EOL]             writeEndArray(); [EOL]             break; [EOL]         case FIELD_NAME: [EOL]             writeFieldName(jp.getCurrentName()); [EOL]             break; [EOL]         case VALUE_STRING: [EOL]             if (jp.hasTextCharacters()) { [EOL]                 writeString(jp.getTextCharacters(), jp.getTextOffset(), jp.getTextLength()); [EOL]             } else { [EOL]                 writeString(jp.getText()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_INT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case INT: [EOL]                     writeNumber(jp.getIntValue()); [EOL]                     break; [EOL]                 case BIG_INTEGER: [EOL]                     writeNumber(jp.getBigIntegerValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getLongValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case BIG_DECIMAL: [EOL]                     writeNumber(jp.getDecimalValue()); [EOL]                     break; [EOL]                 case FLOAT: [EOL]                     writeNumber(jp.getFloatValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getDoubleValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_TRUE: [EOL]             writeBoolean(true); [EOL]             break; [EOL]         case VALUE_FALSE: [EOL]             writeBoolean(false); [EOL]             break; [EOL]         case VALUE_NULL: [EOL]             writeNull(); [EOL]             break; [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             writeObject(jp.getEmbeddedObject()); [EOL]             break; [EOL]         default: [EOL]             throw new RuntimeException("Internal error: should never end up through this code path"); [EOL]     } [EOL] }
@Override [EOL] public void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             writeStartObject(); [EOL]             break; [EOL]         case END_OBJECT: [EOL]             writeEndObject(); [EOL]             break; [EOL]         case START_ARRAY: [EOL]             writeStartArray(); [EOL]             break; [EOL]         case END_ARRAY: [EOL]             writeEndArray(); [EOL]             break; [EOL]         case FIELD_NAME: [EOL]             writeFieldName(jp.getCurrentName()); [EOL]             break; [EOL]         case VALUE_STRING: [EOL]             if (jp.hasTextCharacters()) { [EOL]                 writeString(jp.getTextCharacters(), jp.getTextOffset(), jp.getTextLength()); [EOL]             } else { [EOL]                 writeString(jp.getText()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_INT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case INT: [EOL]                     writeNumber(jp.getIntValue()); [EOL]                     break; [EOL]                 case BIG_INTEGER: [EOL]                     writeNumber(jp.getBigIntegerValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getLongValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case BIG_DECIMAL: [EOL]                     writeNumber(jp.getDecimalValue()); [EOL]                     break; [EOL]                 case FLOAT: [EOL]                     writeNumber(jp.getFloatValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getDoubleValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_TRUE: [EOL]             writeBoolean(true); [EOL]             break; [EOL]         case VALUE_FALSE: [EOL]             writeBoolean(false); [EOL]             break; [EOL]         case VALUE_NULL: [EOL]             writeNull(); [EOL]             break; [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             writeObject(jp.getEmbeddedObject()); [EOL]             break; [EOL]         default: [EOL]             throw new RuntimeException("Internal error: should never end up through this code path"); [EOL]     } [EOL] }
@Override [EOL] public void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             writeStartObject(); [EOL]             break; [EOL]         case END_OBJECT: [EOL]             writeEndObject(); [EOL]             break; [EOL]         case START_ARRAY: [EOL]             writeStartArray(); [EOL]             break; [EOL]         case END_ARRAY: [EOL]             writeEndArray(); [EOL]             break; [EOL]         case FIELD_NAME: [EOL]             writeFieldName(jp.getCurrentName()); [EOL]             break; [EOL]         case VALUE_STRING: [EOL]             if (jp.hasTextCharacters()) { [EOL]                 writeString(jp.getTextCharacters(), jp.getTextOffset(), jp.getTextLength()); [EOL]             } else { [EOL]                 writeString(jp.getText()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_INT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case INT: [EOL]                     writeNumber(jp.getIntValue()); [EOL]                     break; [EOL]                 case BIG_INTEGER: [EOL]                     writeNumber(jp.getBigIntegerValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getLongValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case BIG_DECIMAL: [EOL]                     writeNumber(jp.getDecimalValue()); [EOL]                     break; [EOL]                 case FLOAT: [EOL]                     writeNumber(jp.getFloatValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getDoubleValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_TRUE: [EOL]             writeBoolean(true); [EOL]             break; [EOL]         case VALUE_FALSE: [EOL]             writeBoolean(false); [EOL]             break; [EOL]         case VALUE_NULL: [EOL]             writeNull(); [EOL]             break; [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             writeObject(jp.getEmbeddedObject()); [EOL]             break; [EOL]         default: [EOL]             throw new RuntimeException("Internal error: should never end up through this code path"); [EOL]     } [EOL] }
@Override [EOL] public void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             writeStartObject(); [EOL]             break; [EOL]         case END_OBJECT: [EOL]             writeEndObject(); [EOL]             break; [EOL]         case START_ARRAY: [EOL]             writeStartArray(); [EOL]             break; [EOL]         case END_ARRAY: [EOL]             writeEndArray(); [EOL]             break; [EOL]         case FIELD_NAME: [EOL]             writeFieldName(jp.getCurrentName()); [EOL]             break; [EOL]         case VALUE_STRING: [EOL]             if (jp.hasTextCharacters()) { [EOL]                 writeString(jp.getTextCharacters(), jp.getTextOffset(), jp.getTextLength()); [EOL]             } else { [EOL]                 writeString(jp.getText()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_INT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case INT: [EOL]                     writeNumber(jp.getIntValue()); [EOL]                     break; [EOL]                 case BIG_INTEGER: [EOL]                     writeNumber(jp.getBigIntegerValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getLongValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case BIG_DECIMAL: [EOL]                     writeNumber(jp.getDecimalValue()); [EOL]                     break; [EOL]                 case FLOAT: [EOL]                     writeNumber(jp.getFloatValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getDoubleValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_TRUE: [EOL]             writeBoolean(true); [EOL]             break; [EOL]         case VALUE_FALSE: [EOL]             writeBoolean(false); [EOL]             break; [EOL]         case VALUE_NULL: [EOL]             writeNull(); [EOL]             break; [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             writeObject(jp.getEmbeddedObject()); [EOL]             break; [EOL]         default: [EOL]             throw new RuntimeException("Internal error: should never end up through this code path"); [EOL]     } [EOL] }
@Override [EOL] public void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             writeStartObject(); [EOL]             break; [EOL]         case END_OBJECT: [EOL]             writeEndObject(); [EOL]             break; [EOL]         case START_ARRAY: [EOL]             writeStartArray(); [EOL]             break; [EOL]         case END_ARRAY: [EOL]             writeEndArray(); [EOL]             break; [EOL]         case FIELD_NAME: [EOL]             writeFieldName(jp.getCurrentName()); [EOL]             break; [EOL]         case VALUE_STRING: [EOL]             if (jp.hasTextCharacters()) { [EOL]                 writeString(jp.getTextCharacters(), jp.getTextOffset(), jp.getTextLength()); [EOL]             } else { [EOL]                 writeString(jp.getText()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_INT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case INT: [EOL]                     writeNumber(jp.getIntValue()); [EOL]                     break; [EOL]                 case BIG_INTEGER: [EOL]                     writeNumber(jp.getBigIntegerValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getLongValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case BIG_DECIMAL: [EOL]                     writeNumber(jp.getDecimalValue()); [EOL]                     break; [EOL]                 case FLOAT: [EOL]                     writeNumber(jp.getFloatValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getDoubleValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_TRUE: [EOL]             writeBoolean(true); [EOL]             break; [EOL]         case VALUE_FALSE: [EOL]             writeBoolean(false); [EOL]             break; [EOL]         case VALUE_NULL: [EOL]             writeNull(); [EOL]             break; [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             writeObject(jp.getEmbeddedObject()); [EOL]             break; [EOL]         default: [EOL]             throw new RuntimeException("Internal error: should never end up through this code path"); [EOL]     } [EOL] }
@Override [EOL] public void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             writeStartObject(); [EOL]             break; [EOL]         case END_OBJECT: [EOL]             writeEndObject(); [EOL]             break; [EOL]         case START_ARRAY: [EOL]             writeStartArray(); [EOL]             break; [EOL]         case END_ARRAY: [EOL]             writeEndArray(); [EOL]             break; [EOL]         case FIELD_NAME: [EOL]             writeFieldName(jp.getCurrentName()); [EOL]             break; [EOL]         case VALUE_STRING: [EOL]             if (jp.hasTextCharacters()) { [EOL]                 writeString(jp.getTextCharacters(), jp.getTextOffset(), jp.getTextLength()); [EOL]             } else { [EOL]                 writeString(jp.getText()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_INT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case INT: [EOL]                     writeNumber(jp.getIntValue()); [EOL]                     break; [EOL]                 case BIG_INTEGER: [EOL]                     writeNumber(jp.getBigIntegerValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getLongValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case BIG_DECIMAL: [EOL]                     writeNumber(jp.getDecimalValue()); [EOL]                     break; [EOL]                 case FLOAT: [EOL]                     writeNumber(jp.getFloatValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getDoubleValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_TRUE: [EOL]             writeBoolean(true); [EOL]             break; [EOL]         case VALUE_FALSE: [EOL]             writeBoolean(false); [EOL]             break; [EOL]         case VALUE_NULL: [EOL]             writeNull(); [EOL]             break; [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             writeObject(jp.getEmbeddedObject()); [EOL]             break; [EOL]         default: [EOL]             throw new RuntimeException("Internal error: should never end up through this code path"); [EOL]     } [EOL] }
@Override [EOL] public void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             writeStartObject(); [EOL]             break; [EOL]         case END_OBJECT: [EOL]             writeEndObject(); [EOL]             break; [EOL]         case START_ARRAY: [EOL]             writeStartArray(); [EOL]             break; [EOL]         case END_ARRAY: [EOL]             writeEndArray(); [EOL]             break; [EOL]         case FIELD_NAME: [EOL]             writeFieldName(jp.getCurrentName()); [EOL]             break; [EOL]         case VALUE_STRING: [EOL]             if (jp.hasTextCharacters()) { [EOL]                 writeString(jp.getTextCharacters(), jp.getTextOffset(), jp.getTextLength()); [EOL]             } else { [EOL]                 writeString(jp.getText()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_INT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case INT: [EOL]                     writeNumber(jp.getIntValue()); [EOL]                     break; [EOL]                 case BIG_INTEGER: [EOL]                     writeNumber(jp.getBigIntegerValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getLongValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case BIG_DECIMAL: [EOL]                     writeNumber(jp.getDecimalValue()); [EOL]                     break; [EOL]                 case FLOAT: [EOL]                     writeNumber(jp.getFloatValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getDoubleValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_TRUE: [EOL]             writeBoolean(true); [EOL]             break; [EOL]         case VALUE_FALSE: [EOL]             writeBoolean(false); [EOL]             break; [EOL]         case VALUE_NULL: [EOL]             writeNull(); [EOL]             break; [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             writeObject(jp.getEmbeddedObject()); [EOL]             break; [EOL]         default: [EOL]             throw new RuntimeException("Internal error: should never end up through this code path"); [EOL]     } [EOL] }
@Override [EOL] public void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             writeStartObject(); [EOL]             break; [EOL]         case END_OBJECT: [EOL]             writeEndObject(); [EOL]             break; [EOL]         case START_ARRAY: [EOL]             writeStartArray(); [EOL]             break; [EOL]         case END_ARRAY: [EOL]             writeEndArray(); [EOL]             break; [EOL]         case FIELD_NAME: [EOL]             writeFieldName(jp.getCurrentName()); [EOL]             break; [EOL]         case VALUE_STRING: [EOL]             if (jp.hasTextCharacters()) { [EOL]                 writeString(jp.getTextCharacters(), jp.getTextOffset(), jp.getTextLength()); [EOL]             } else { [EOL]                 writeString(jp.getText()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_INT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case INT: [EOL]                     writeNumber(jp.getIntValue()); [EOL]                     break; [EOL]                 case BIG_INTEGER: [EOL]                     writeNumber(jp.getBigIntegerValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getLongValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case BIG_DECIMAL: [EOL]                     writeNumber(jp.getDecimalValue()); [EOL]                     break; [EOL]                 case FLOAT: [EOL]                     writeNumber(jp.getFloatValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getDoubleValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_TRUE: [EOL]             writeBoolean(true); [EOL]             break; [EOL]         case VALUE_FALSE: [EOL]             writeBoolean(false); [EOL]             break; [EOL]         case VALUE_NULL: [EOL]             writeNull(); [EOL]             break; [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             writeObject(jp.getEmbeddedObject()); [EOL]             break; [EOL]         default: [EOL]             throw new RuntimeException("Internal error: should never end up through this code path"); [EOL]     } [EOL] }
@Override [EOL] public void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             writeStartObject(); [EOL]             break; [EOL]         case END_OBJECT: [EOL]             writeEndObject(); [EOL]             break; [EOL]         case START_ARRAY: [EOL]             writeStartArray(); [EOL]             break; [EOL]         case END_ARRAY: [EOL]             writeEndArray(); [EOL]             break; [EOL]         case FIELD_NAME: [EOL]             writeFieldName(jp.getCurrentName()); [EOL]             break; [EOL]         case VALUE_STRING: [EOL]             if (jp.hasTextCharacters()) { [EOL]                 writeString(jp.getTextCharacters(), jp.getTextOffset(), jp.getTextLength()); [EOL]             } else { [EOL]                 writeString(jp.getText()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_INT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case INT: [EOL]                     writeNumber(jp.getIntValue()); [EOL]                     break; [EOL]                 case BIG_INTEGER: [EOL]                     writeNumber(jp.getBigIntegerValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getLongValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case BIG_DECIMAL: [EOL]                     writeNumber(jp.getDecimalValue()); [EOL]                     break; [EOL]                 case FLOAT: [EOL]                     writeNumber(jp.getFloatValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getDoubleValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_TRUE: [EOL]             writeBoolean(true); [EOL]             break; [EOL]         case VALUE_FALSE: [EOL]             writeBoolean(false); [EOL]             break; [EOL]         case VALUE_NULL: [EOL]             writeNull(); [EOL]             break; [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             writeObject(jp.getEmbeddedObject()); [EOL]             break; [EOL]         default: [EOL]             throw new RuntimeException("Internal error: should never end up through this code path"); [EOL]     } [EOL] }
@Override [EOL] public boolean hasTextCharacters() { [EOL]     return false; [EOL] }
@Override [EOL] public boolean isConcrete() { [EOL]     int mod = _class.getModifiers(); [EOL]     if ((mod & (Modifier.INTERFACE | Modifier.ABSTRACT)) == 0) { [EOL]         return true; [EOL]     } [EOL]     if (_class.isPrimitive()) { [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] }
@Override [EOL] public boolean isConcrete() { [EOL]     int mod = _class.getModifiers(); [EOL]     if ((mod & (Modifier.INTERFACE | Modifier.ABSTRACT)) == 0) { [EOL]         return true; [EOL]     } [EOL]     if (_class.isPrimitive()) { [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] }
@Override [EOL] public boolean isConcrete() { [EOL]     int mod = _class.getModifiers(); [EOL]     if ((mod & (Modifier.INTERFACE | Modifier.ABSTRACT)) == 0) { [EOL]         return true; [EOL]     } [EOL]     if (_class.isPrimitive()) { [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] }
@Override [EOL] public boolean isCollectionLikeType() { [EOL]     return false; [EOL] }
@Override [EOL] public boolean isMapLikeType() { [EOL]     return false; [EOL] }
@Override [EOL] public boolean hasGenericTypes() { [EOL]     return containedTypeCount() > 0; [EOL] }
@Override [EOL] public boolean hasGenericTypes() { [EOL]     return containedTypeCount() > 0; [EOL] }
@Override [EOL] public JavaType getKeyType() { [EOL]     return null; [EOL] }
@Override [EOL] public void serialize(Date value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (_useTimestamp) { [EOL]         jgen.writeNumber(_timestamp(value)); [EOL]     } else if (_customFormat != null) { [EOL]         synchronized (_customFormat) { [EOL]             jgen.writeString(_customFormat.format(value)); [EOL]         } [EOL]     } else { [EOL]         provider.defaultSerializeDateValue(value, jgen); [EOL]     } [EOL] }
@Override [EOL] public void serialize(Date value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (_useTimestamp) { [EOL]         jgen.writeNumber(_timestamp(value)); [EOL]     } else if (_customFormat != null) { [EOL]         synchronized (_customFormat) { [EOL]             jgen.writeString(_customFormat.format(value)); [EOL]         } [EOL]     } else { [EOL]         provider.defaultSerializeDateValue(value, jgen); [EOL]     } [EOL] }
@Override [EOL] public void serialize(Date value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (_useTimestamp) { [EOL]         jgen.writeNumber(_timestamp(value)); [EOL]     } else if (_customFormat != null) { [EOL]         synchronized (_customFormat) { [EOL]             jgen.writeString(_customFormat.format(value)); [EOL]         } [EOL]     } else { [EOL]         provider.defaultSerializeDateValue(value, jgen); [EOL]     } [EOL] }
protected boolean hasContentTypeAnnotation(SerializerProvider provider, BeanProperty property) { [EOL]     if (property != null) { [EOL]         AnnotationIntrospector intr = provider.getAnnotationIntrospector(); [EOL]         if (intr != null) { [EOL]             if (intr.findSerializationContentType(property.getMember(), property.getType()) != null) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
protected boolean hasContentTypeAnnotation(SerializerProvider provider, BeanProperty property) { [EOL]     if (property != null) { [EOL]         AnnotationIntrospector intr = provider.getAnnotationIntrospector(); [EOL]         if (intr != null) { [EOL]             if (intr.findSerializationContentType(property.getMember(), property.getType()) != null) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
protected boolean hasContentTypeAnnotation(SerializerProvider provider, BeanProperty property) { [EOL]     if (property != null) { [EOL]         AnnotationIntrospector intr = provider.getAnnotationIntrospector(); [EOL]         if (intr != null) { [EOL]             if (intr.findSerializationContentType(property.getMember(), property.getType()) != null) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
protected boolean hasContentTypeAnnotation(SerializerProvider provider, BeanProperty property) { [EOL]     if (property != null) { [EOL]         AnnotationIntrospector intr = provider.getAnnotationIntrospector(); [EOL]         if (intr != null) { [EOL]             if (intr.findSerializationContentType(property.getMember(), property.getType()) != null) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
@Override [EOL] public TypeDeserializer buildTypeDeserializer(DeserializationConfig config, JavaType baseType, Collection<NamedType> subtypes) { [EOL]     return useForType(baseType) ? super.buildTypeDeserializer(config, baseType, subtypes) : null; [EOL] }
@Override [EOL] public TypeDeserializer buildTypeDeserializer(DeserializationConfig config, JavaType baseType, Collection<NamedType> subtypes) { [EOL]     return useForType(baseType) ? super.buildTypeDeserializer(config, baseType, subtypes) : null; [EOL] }
public boolean useForType(JavaType t) { [EOL]     switch(_appliesFor) { [EOL]         case NON_CONCRETE_AND_ARRAYS: [EOL]             while (t.isArrayType()) { [EOL]                 t = t.getContentType(); [EOL]             } [EOL]         case OBJECT_AND_NON_CONCRETE: [EOL]             return (t.getRawClass() == Object.class) || !t.isConcrete(); [EOL]         case NON_FINAL: [EOL]             while (t.isArrayType()) { [EOL]                 t = t.getContentType(); [EOL]             } [EOL]             return !t.isFinal(); [EOL]         default: [EOL]             return (t.getRawClass() == Object.class); [EOL]     } [EOL] }
public ObjectMapper registerModule(Module module) { [EOL]     String name = module.getModuleName(); [EOL]     if (name == null) { [EOL]         throw new IllegalArgumentException("Module without defined name"); [EOL]     } [EOL]     Version version = module.version(); [EOL]     if (version == null) { [EOL]         throw new IllegalArgumentException("Module without defined version"); [EOL]     } [EOL]     final ObjectMapper mapper = this; [EOL]     module.setupModule(new Module.SetupContext() { [EOL]  [EOL]         @Override [EOL]         public Version getMapperVersion() { [EOL]             return version(); [EOL]         } [EOL]  [EOL]         @SuppressWarnings("unchecked") [EOL]         @Override [EOL]         public <C extends ObjectCodec> C getOwner() { [EOL]             return (C) mapper; [EOL]         } [EOL]  [EOL]         @Override [EOL]         public TypeFactory getTypeFactory() { [EOL]             return _typeFactory; [EOL]         } [EOL]  [EOL]         @Override [EOL]         public boolean isEnabled(MapperFeature f) { [EOL]             return mapper.isEnabled(f); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public boolean isEnabled(DeserializationFeature f) { [EOL]             return mapper.isEnabled(f); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public boolean isEnabled(SerializationFeature f) { [EOL]             return mapper.isEnabled(f); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public boolean isEnabled(JsonFactory.Feature f) { [EOL]             return mapper.isEnabled(f); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public boolean isEnabled(JsonParser.Feature f) { [EOL]             return mapper.isEnabled(f); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public boolean isEnabled(JsonGenerator.Feature f) { [EOL]             return mapper.isEnabled(f); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void addDeserializers(Deserializers d) { [EOL]             DeserializerFactory df = mapper._deserializationContext._factory.withAdditionalDeserializers(d); [EOL]             mapper._deserializationContext = mapper._deserializationContext.with(df); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void addKeyDeserializers(KeyDeserializers d) { [EOL]             DeserializerFactory df = mapper._deserializationContext._factory.withAdditionalKeyDeserializers(d); [EOL]             mapper._deserializationContext = mapper._deserializationContext.with(df); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void addBeanDeserializerModifier(BeanDeserializerModifier modifier) { [EOL]             DeserializerFactory df = mapper._deserializationContext._factory.withDeserializerModifier(modifier); [EOL]             mapper._deserializationContext = mapper._deserializationContext.with(df); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void addSerializers(Serializers s) { [EOL]             mapper._serializerFactory = mapper._serializerFactory.withAdditionalSerializers(s); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void addKeySerializers(Serializers s) { [EOL]             mapper._serializerFactory = mapper._serializerFactory.withAdditionalKeySerializers(s); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void addBeanSerializerModifier(BeanSerializerModifier modifier) { [EOL]             mapper._serializerFactory = mapper._serializerFactory.withSerializerModifier(modifier); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void addAbstractTypeResolver(AbstractTypeResolver resolver) { [EOL]             DeserializerFactory df = mapper._deserializationContext._factory.withAbstractTypeResolver(resolver); [EOL]             mapper._deserializationContext = mapper._deserializationContext.with(df); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void addTypeModifier(TypeModifier modifier) { [EOL]             TypeFactory f = mapper._typeFactory; [EOL]             f = f.withModifier(modifier); [EOL]             mapper.setTypeFactory(f); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void addValueInstantiators(ValueInstantiators instantiators) { [EOL]             DeserializerFactory df = mapper._deserializationContext._factory.withValueInstantiators(instantiators); [EOL]             mapper._deserializationContext = mapper._deserializationContext.with(df); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void setClassIntrospector(ClassIntrospector ci) { [EOL]             mapper._deserializationConfig = mapper._deserializationConfig.with(ci); [EOL]             mapper._serializationConfig = mapper._serializationConfig.with(ci); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void insertAnnotationIntrospector(AnnotationIntrospector ai) { [EOL]             mapper._deserializationConfig = mapper._deserializationConfig.withInsertedAnnotationIntrospector(ai); [EOL]             mapper._serializationConfig = mapper._serializationConfig.withInsertedAnnotationIntrospector(ai); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void appendAnnotationIntrospector(AnnotationIntrospector ai) { [EOL]             mapper._deserializationConfig = mapper._deserializationConfig.withAppendedAnnotationIntrospector(ai); [EOL]             mapper._serializationConfig = mapper._serializationConfig.withAppendedAnnotationIntrospector(ai); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void registerSubtypes(Class<?>... subtypes) { [EOL]             mapper.registerSubtypes(subtypes); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void registerSubtypes(NamedType... subtypes) { [EOL]             mapper.registerSubtypes(subtypes); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void setMixInAnnotations(Class<?> target, Class<?> mixinSource) { [EOL]             mapper.addMixInAnnotations(target, mixinSource); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void addDeserializationProblemHandler(DeserializationProblemHandler handler) { [EOL]             mapper.addHandler(handler); [EOL]         } [EOL]     }); [EOL]     return this; [EOL] }
public ObjectMapper setSerializationInclusion(JsonInclude.Include incl) { [EOL]     _serializationConfig = _serializationConfig.withSerializationInclusion(incl); [EOL]     return this; [EOL] }
public ObjectMapper setSerializationInclusion(JsonInclude.Include incl) { [EOL]     _serializationConfig = _serializationConfig.withSerializationInclusion(incl); [EOL]     return this; [EOL] }
public ObjectMapper enableDefaultTyping() { [EOL]     return enableDefaultTyping(DefaultTyping.OBJECT_AND_NON_CONCRETE); [EOL] }
public ObjectMapper enableDefaultTyping(DefaultTyping dti) { [EOL]     return enableDefaultTyping(dti, JsonTypeInfo.As.WRAPPER_ARRAY); [EOL] }
public ObjectMapper enableDefaultTyping(DefaultTyping dti) { [EOL]     return enableDefaultTyping(dti, JsonTypeInfo.As.WRAPPER_ARRAY); [EOL] }
public ObjectMapper enableDefaultTyping(DefaultTyping applicability, JsonTypeInfo.As includeAs) { [EOL]     TypeResolverBuilder<?> typer = new DefaultTypeResolverBuilder(applicability); [EOL]     typer = typer.init(JsonTypeInfo.Id.CLASS, null); [EOL]     typer = typer.inclusion(includeAs); [EOL]     return setDefaultTyping(typer); [EOL] }
public ObjectMapper enableDefaultTyping(DefaultTyping applicability, JsonTypeInfo.As includeAs) { [EOL]     TypeResolverBuilder<?> typer = new DefaultTypeResolverBuilder(applicability); [EOL]     typer = typer.init(JsonTypeInfo.Id.CLASS, null); [EOL]     typer = typer.inclusion(includeAs); [EOL]     return setDefaultTyping(typer); [EOL] }
public ObjectMapper setInjectableValues(InjectableValues injectableValues) { [EOL]     _injectableValues = injectableValues; [EOL]     return this; [EOL] }
public ObjectMapper setInjectableValues(InjectableValues injectableValues) { [EOL]     _injectableValues = injectableValues; [EOL]     return this; [EOL] }
@Override [EOL] @SuppressWarnings("unchecked") [EOL] public <T> T readValue(JsonParser jp, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException { [EOL]     return (T) _readValue(getDeserializationConfig(), jp, _typeFactory.constructType(valueType)); [EOL] }
@Override [EOL] public <T extends TreeNode> T readTree(JsonParser jp) throws IOException, JsonProcessingException { [EOL]     DeserializationConfig cfg = getDeserializationConfig(); [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == null) { [EOL]         t = jp.nextToken(); [EOL]         if (t == null) { [EOL]             return null; [EOL]         } [EOL]     } [EOL]     JsonNode n = (JsonNode) _readValue(cfg, jp, JSON_NODE_TYPE); [EOL]     if (n == null) { [EOL]         n = getNodeFactory().nullNode(); [EOL]     } [EOL]     @SuppressWarnings("unchecked") [EOL]     T result = (T) n; [EOL]     return result; [EOL] }
@Override [EOL] public <T extends TreeNode> T readTree(JsonParser jp) throws IOException, JsonProcessingException { [EOL]     DeserializationConfig cfg = getDeserializationConfig(); [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == null) { [EOL]         t = jp.nextToken(); [EOL]         if (t == null) { [EOL]             return null; [EOL]         } [EOL]     } [EOL]     JsonNode n = (JsonNode) _readValue(cfg, jp, JSON_NODE_TYPE); [EOL]     if (n == null) { [EOL]         n = getNodeFactory().nullNode(); [EOL]     } [EOL]     @SuppressWarnings("unchecked") [EOL]     T result = (T) n; [EOL]     return result; [EOL] }
@Override [EOL] public <T extends TreeNode> T readTree(JsonParser jp) throws IOException, JsonProcessingException { [EOL]     DeserializationConfig cfg = getDeserializationConfig(); [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == null) { [EOL]         t = jp.nextToken(); [EOL]         if (t == null) { [EOL]             return null; [EOL]         } [EOL]     } [EOL]     JsonNode n = (JsonNode) _readValue(cfg, jp, JSON_NODE_TYPE); [EOL]     if (n == null) { [EOL]         n = getNodeFactory().nullNode(); [EOL]     } [EOL]     @SuppressWarnings("unchecked") [EOL]     T result = (T) n; [EOL]     return result; [EOL] }
@Override [EOL] public <T extends TreeNode> T readTree(JsonParser jp) throws IOException, JsonProcessingException { [EOL]     DeserializationConfig cfg = getDeserializationConfig(); [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == null) { [EOL]         t = jp.nextToken(); [EOL]         if (t == null) { [EOL]             return null; [EOL]         } [EOL]     } [EOL]     JsonNode n = (JsonNode) _readValue(cfg, jp, JSON_NODE_TYPE); [EOL]     if (n == null) { [EOL]         n = getNodeFactory().nullNode(); [EOL]     } [EOL]     @SuppressWarnings("unchecked") [EOL]     T result = (T) n; [EOL]     return result; [EOL] }
@Override [EOL] public void writeValue(JsonGenerator jgen, Object value) throws IOException, JsonGenerationException, JsonMappingException { [EOL]     SerializationConfig config = getSerializationConfig(); [EOL]     if (config.isEnabled(SerializationFeature.INDENT_OUTPUT)) { [EOL]         jgen.useDefaultPrettyPrinter(); [EOL]     } [EOL]     if (config.isEnabled(SerializationFeature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) { [EOL]         _writeCloseableValue(jgen, value, config); [EOL]     } else { [EOL]         _serializerProvider(config).serializeValue(jgen, value); [EOL]         if (config.isEnabled(SerializationFeature.FLUSH_AFTER_WRITE_VALUE)) { [EOL]             jgen.flush(); [EOL]         } [EOL]     } [EOL] }
@Override [EOL] public void writeValue(JsonGenerator jgen, Object value) throws IOException, JsonGenerationException, JsonMappingException { [EOL]     SerializationConfig config = getSerializationConfig(); [EOL]     if (config.isEnabled(SerializationFeature.INDENT_OUTPUT)) { [EOL]         jgen.useDefaultPrettyPrinter(); [EOL]     } [EOL]     if (config.isEnabled(SerializationFeature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) { [EOL]         _writeCloseableValue(jgen, value, config); [EOL]     } else { [EOL]         _serializerProvider(config).serializeValue(jgen, value); [EOL]         if (config.isEnabled(SerializationFeature.FLUSH_AFTER_WRITE_VALUE)) { [EOL]             jgen.flush(); [EOL]         } [EOL]     } [EOL] }
@Override [EOL] public void writeValue(JsonGenerator jgen, Object value) throws IOException, JsonGenerationException, JsonMappingException { [EOL]     SerializationConfig config = getSerializationConfig(); [EOL]     if (config.isEnabled(SerializationFeature.INDENT_OUTPUT)) { [EOL]         jgen.useDefaultPrettyPrinter(); [EOL]     } [EOL]     if (config.isEnabled(SerializationFeature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) { [EOL]         _writeCloseableValue(jgen, value, config); [EOL]     } else { [EOL]         _serializerProvider(config).serializeValue(jgen, value); [EOL]         if (config.isEnabled(SerializationFeature.FLUSH_AFTER_WRITE_VALUE)) { [EOL]             jgen.flush(); [EOL]         } [EOL]     } [EOL] }
@Override [EOL] public void writeValue(JsonGenerator jgen, Object value) throws IOException, JsonGenerationException, JsonMappingException { [EOL]     SerializationConfig config = getSerializationConfig(); [EOL]     if (config.isEnabled(SerializationFeature.INDENT_OUTPUT)) { [EOL]         jgen.useDefaultPrettyPrinter(); [EOL]     } [EOL]     if (config.isEnabled(SerializationFeature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) { [EOL]         _writeCloseableValue(jgen, value, config); [EOL]     } else { [EOL]         _serializerProvider(config).serializeValue(jgen, value); [EOL]         if (config.isEnabled(SerializationFeature.FLUSH_AFTER_WRITE_VALUE)) { [EOL]             jgen.flush(); [EOL]         } [EOL]     } [EOL] }
@Override [EOL] public ArrayNode createArrayNode() { [EOL]     return _deserializationConfig.getNodeFactory().arrayNode(); [EOL] }
@Override [EOL] public JsonParser treeAsTokens(TreeNode n) { [EOL]     return new TreeTraversingParser((JsonNode) n, this); [EOL] }
@SuppressWarnings("unchecked") [EOL] @Override [EOL] public <T> T treeToValue(TreeNode n, Class<T> valueType) throws JsonProcessingException { [EOL]     try { [EOL]         if (valueType != Object.class && valueType.isAssignableFrom(n.getClass())) { [EOL]             return (T) n; [EOL]         } [EOL]         return readValue(treeAsTokens(n), valueType); [EOL]     } catch (JsonProcessingException e) { [EOL]         throw e; [EOL]     } catch (IOException e) { [EOL]         throw new IllegalArgumentException(e.getMessage(), e); [EOL]     } [EOL] }
@SuppressWarnings("unchecked") [EOL] @Override [EOL] public <T> T treeToValue(TreeNode n, Class<T> valueType) throws JsonProcessingException { [EOL]     try { [EOL]         if (valueType != Object.class && valueType.isAssignableFrom(n.getClass())) { [EOL]             return (T) n; [EOL]         } [EOL]         return readValue(treeAsTokens(n), valueType); [EOL]     } catch (JsonProcessingException e) { [EOL]         throw e; [EOL]     } catch (IOException e) { [EOL]         throw new IllegalArgumentException(e.getMessage(), e); [EOL]     } [EOL] }
@SuppressWarnings("unchecked") [EOL] @Override [EOL] public <T> T treeToValue(TreeNode n, Class<T> valueType) throws JsonProcessingException { [EOL]     try { [EOL]         if (valueType != Object.class && valueType.isAssignableFrom(n.getClass())) { [EOL]             return (T) n; [EOL]         } [EOL]         return readValue(treeAsTokens(n), valueType); [EOL]     } catch (JsonProcessingException e) { [EOL]         throw e; [EOL]     } catch (IOException e) { [EOL]         throw new IllegalArgumentException(e.getMessage(), e); [EOL]     } [EOL] }
@SuppressWarnings("unchecked") [EOL] public <T> T readValue(byte[] src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException { [EOL]     return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueType)); [EOL] }
@SuppressWarnings("unchecked") [EOL] public <T> T readValue(byte[] src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException { [EOL]     return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueType)); [EOL] }
@SuppressWarnings("unchecked") [EOL] public <T> T readValue(byte[] src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException { [EOL]     return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueType)); [EOL] }
@SuppressWarnings("unchecked") [EOL] public <T> T readValue(byte[] src, Class<T> valueType) throws IOException, JsonParseException, JsonMappingException { [EOL]     return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueType)); [EOL] }
public void writeValue(OutputStream out, Object value) throws IOException, JsonGenerationException, JsonMappingException { [EOL]     _configAndWriteValue(_jsonFactory.createGenerator(out, JsonEncoding.UTF8), value); [EOL] }
public void writeValue(OutputStream out, Object value) throws IOException, JsonGenerationException, JsonMappingException { [EOL]     _configAndWriteValue(_jsonFactory.createGenerator(out, JsonEncoding.UTF8), value); [EOL] }
public byte[] writeValueAsBytes(Object value) throws JsonProcessingException { [EOL]     ByteArrayBuilder bb = new ByteArrayBuilder(_jsonFactory._getBufferRecycler()); [EOL]     try { [EOL]         _configAndWriteValue(_jsonFactory.createGenerator(bb, JsonEncoding.UTF8), value); [EOL]     } catch (JsonProcessingException e) { [EOL]         throw e; [EOL]     } catch (IOException e) { [EOL]         throw JsonMappingException.fromUnexpectedIOE(e); [EOL]     } [EOL]     byte[] result = bb.toByteArray(); [EOL]     bb.release(); [EOL]     return result; [EOL] }
public byte[] writeValueAsBytes(Object value) throws JsonProcessingException { [EOL]     ByteArrayBuilder bb = new ByteArrayBuilder(_jsonFactory._getBufferRecycler()); [EOL]     try { [EOL]         _configAndWriteValue(_jsonFactory.createGenerator(bb, JsonEncoding.UTF8), value); [EOL]     } catch (JsonProcessingException e) { [EOL]         throw e; [EOL]     } catch (IOException e) { [EOL]         throw JsonMappingException.fromUnexpectedIOE(e); [EOL]     } [EOL]     byte[] result = bb.toByteArray(); [EOL]     bb.release(); [EOL]     return result; [EOL] }
public byte[] writeValueAsBytes(Object value) throws JsonProcessingException { [EOL]     ByteArrayBuilder bb = new ByteArrayBuilder(_jsonFactory._getBufferRecycler()); [EOL]     try { [EOL]         _configAndWriteValue(_jsonFactory.createGenerator(bb, JsonEncoding.UTF8), value); [EOL]     } catch (JsonProcessingException e) { [EOL]         throw e; [EOL]     } catch (IOException e) { [EOL]         throw JsonMappingException.fromUnexpectedIOE(e); [EOL]     } [EOL]     byte[] result = bb.toByteArray(); [EOL]     bb.release(); [EOL]     return result; [EOL] }
public ObjectWriter writer(SerializationFeature feature) { [EOL]     return new ObjectWriter(this, getSerializationConfig().with(feature)); [EOL] }
public ObjectWriter writer(SerializationFeature feature) { [EOL]     return new ObjectWriter(this, getSerializationConfig().with(feature)); [EOL] }
public ObjectWriter writer(DateFormat df) { [EOL]     return new ObjectWriter(this, getSerializationConfig().with(df)); [EOL] }
public ObjectWriter writer(DateFormat df) { [EOL]     return new ObjectWriter(this, getSerializationConfig().with(df)); [EOL] }
public ObjectWriter writerWithDefaultPrettyPrinter() { [EOL]     return new ObjectWriter(this, getSerializationConfig(), null, _defaultPrettyPrinter()); [EOL] }
@SuppressWarnings("unchecked") [EOL] public <T> T convertValue(Object fromValue, Class<T> toValueType) throws IllegalArgumentException { [EOL]     if (fromValue == null) [EOL]         return null; [EOL]     return (T) _convert(fromValue, _typeFactory.constructType(toValueType)); [EOL] }
@SuppressWarnings("unchecked") [EOL] public <T> T convertValue(Object fromValue, Class<T> toValueType) throws IllegalArgumentException { [EOL]     if (fromValue == null) [EOL]         return null; [EOL]     return (T) _convert(fromValue, _typeFactory.constructType(toValueType)); [EOL] }
protected Object _convert(Object fromValue, JavaType toValueType) throws IllegalArgumentException { [EOL]     Class<?> targetType = toValueType.getRawClass(); [EOL]     if (targetType != Object.class && !toValueType.hasGenericTypes() && targetType.isAssignableFrom(fromValue.getClass())) { [EOL]         return fromValue; [EOL]     } [EOL]     TokenBuffer buf = new TokenBuffer(this); [EOL]     try { [EOL]         SerializationConfig config = getSerializationConfig().without(SerializationFeature.WRAP_ROOT_VALUE); [EOL]         _serializerProvider(config).serializeValue(buf, fromValue); [EOL]         final JsonParser jp = buf.asParser(); [EOL]         Object result; [EOL]         final DeserializationConfig deserConfig = getDeserializationConfig(); [EOL]         JsonToken t = _initForReading(jp); [EOL]         if (t == JsonToken.VALUE_NULL) { [EOL]             DeserializationContext ctxt = createDeserializationContext(jp, deserConfig); [EOL]             result = _findRootDeserializer(ctxt, toValueType).getNullValue(); [EOL]         } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) { [EOL]             result = null; [EOL]         } else { [EOL]             DeserializationContext ctxt = createDeserializationContext(jp, deserConfig); [EOL]             JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, toValueType); [EOL]             result = deser.deserialize(jp, ctxt); [EOL]         } [EOL]         jp.close(); [EOL]         return result; [EOL]     } catch (IOException e) { [EOL]         throw new IllegalArgumentException(e.getMessage(), e); [EOL]     } [EOL] }
protected Object _convert(Object fromValue, JavaType toValueType) throws IllegalArgumentException { [EOL]     Class<?> targetType = toValueType.getRawClass(); [EOL]     if (targetType != Object.class && !toValueType.hasGenericTypes() && targetType.isAssignableFrom(fromValue.getClass())) { [EOL]         return fromValue; [EOL]     } [EOL]     TokenBuffer buf = new TokenBuffer(this); [EOL]     try { [EOL]         SerializationConfig config = getSerializationConfig().without(SerializationFeature.WRAP_ROOT_VALUE); [EOL]         _serializerProvider(config).serializeValue(buf, fromValue); [EOL]         final JsonParser jp = buf.asParser(); [EOL]         Object result; [EOL]         final DeserializationConfig deserConfig = getDeserializationConfig(); [EOL]         JsonToken t = _initForReading(jp); [EOL]         if (t == JsonToken.VALUE_NULL) { [EOL]             DeserializationContext ctxt = createDeserializationContext(jp, deserConfig); [EOL]             result = _findRootDeserializer(ctxt, toValueType).getNullValue(); [EOL]         } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) { [EOL]             result = null; [EOL]         } else { [EOL]             DeserializationContext ctxt = createDeserializationContext(jp, deserConfig); [EOL]             JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, toValueType); [EOL]             result = deser.deserialize(jp, ctxt); [EOL]         } [EOL]         jp.close(); [EOL]         return result; [EOL]     } catch (IOException e) { [EOL]         throw new IllegalArgumentException(e.getMessage(), e); [EOL]     } [EOL] }
protected Object _convert(Object fromValue, JavaType toValueType) throws IllegalArgumentException { [EOL]     Class<?> targetType = toValueType.getRawClass(); [EOL]     if (targetType != Object.class && !toValueType.hasGenericTypes() && targetType.isAssignableFrom(fromValue.getClass())) { [EOL]         return fromValue; [EOL]     } [EOL]     TokenBuffer buf = new TokenBuffer(this); [EOL]     try { [EOL]         SerializationConfig config = getSerializationConfig().without(SerializationFeature.WRAP_ROOT_VALUE); [EOL]         _serializerProvider(config).serializeValue(buf, fromValue); [EOL]         final JsonParser jp = buf.asParser(); [EOL]         Object result; [EOL]         final DeserializationConfig deserConfig = getDeserializationConfig(); [EOL]         JsonToken t = _initForReading(jp); [EOL]         if (t == JsonToken.VALUE_NULL) { [EOL]             DeserializationContext ctxt = createDeserializationContext(jp, deserConfig); [EOL]             result = _findRootDeserializer(ctxt, toValueType).getNullValue(); [EOL]         } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) { [EOL]             result = null; [EOL]         } else { [EOL]             DeserializationContext ctxt = createDeserializationContext(jp, deserConfig); [EOL]             JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, toValueType); [EOL]             result = deser.deserialize(jp, ctxt); [EOL]         } [EOL]         jp.close(); [EOL]         return result; [EOL]     } catch (IOException e) { [EOL]         throw new IllegalArgumentException(e.getMessage(), e); [EOL]     } [EOL] }
protected Object _convert(Object fromValue, JavaType toValueType) throws IllegalArgumentException { [EOL]     Class<?> targetType = toValueType.getRawClass(); [EOL]     if (targetType != Object.class && !toValueType.hasGenericTypes() && targetType.isAssignableFrom(fromValue.getClass())) { [EOL]         return fromValue; [EOL]     } [EOL]     TokenBuffer buf = new TokenBuffer(this); [EOL]     try { [EOL]         SerializationConfig config = getSerializationConfig().without(SerializationFeature.WRAP_ROOT_VALUE); [EOL]         _serializerProvider(config).serializeValue(buf, fromValue); [EOL]         final JsonParser jp = buf.asParser(); [EOL]         Object result; [EOL]         final DeserializationConfig deserConfig = getDeserializationConfig(); [EOL]         JsonToken t = _initForReading(jp); [EOL]         if (t == JsonToken.VALUE_NULL) { [EOL]             DeserializationContext ctxt = createDeserializationContext(jp, deserConfig); [EOL]             result = _findRootDeserializer(ctxt, toValueType).getNullValue(); [EOL]         } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) { [EOL]             result = null; [EOL]         } else { [EOL]             DeserializationContext ctxt = createDeserializationContext(jp, deserConfig); [EOL]             JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, toValueType); [EOL]             result = deser.deserialize(jp, ctxt); [EOL]         } [EOL]         jp.close(); [EOL]         return result; [EOL]     } catch (IOException e) { [EOL]         throw new IllegalArgumentException(e.getMessage(), e); [EOL]     } [EOL] }
protected Object _convert(Object fromValue, JavaType toValueType) throws IllegalArgumentException { [EOL]     Class<?> targetType = toValueType.getRawClass(); [EOL]     if (targetType != Object.class && !toValueType.hasGenericTypes() && targetType.isAssignableFrom(fromValue.getClass())) { [EOL]         return fromValue; [EOL]     } [EOL]     TokenBuffer buf = new TokenBuffer(this); [EOL]     try { [EOL]         SerializationConfig config = getSerializationConfig().without(SerializationFeature.WRAP_ROOT_VALUE); [EOL]         _serializerProvider(config).serializeValue(buf, fromValue); [EOL]         final JsonParser jp = buf.asParser(); [EOL]         Object result; [EOL]         final DeserializationConfig deserConfig = getDeserializationConfig(); [EOL]         JsonToken t = _initForReading(jp); [EOL]         if (t == JsonToken.VALUE_NULL) { [EOL]             DeserializationContext ctxt = createDeserializationContext(jp, deserConfig); [EOL]             result = _findRootDeserializer(ctxt, toValueType).getNullValue(); [EOL]         } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) { [EOL]             result = null; [EOL]         } else { [EOL]             DeserializationContext ctxt = createDeserializationContext(jp, deserConfig); [EOL]             JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, toValueType); [EOL]             result = deser.deserialize(jp, ctxt); [EOL]         } [EOL]         jp.close(); [EOL]         return result; [EOL]     } catch (IOException e) { [EOL]         throw new IllegalArgumentException(e.getMessage(), e); [EOL]     } [EOL] }
protected Object _convert(Object fromValue, JavaType toValueType) throws IllegalArgumentException { [EOL]     Class<?> targetType = toValueType.getRawClass(); [EOL]     if (targetType != Object.class && !toValueType.hasGenericTypes() && targetType.isAssignableFrom(fromValue.getClass())) { [EOL]         return fromValue; [EOL]     } [EOL]     TokenBuffer buf = new TokenBuffer(this); [EOL]     try { [EOL]         SerializationConfig config = getSerializationConfig().without(SerializationFeature.WRAP_ROOT_VALUE); [EOL]         _serializerProvider(config).serializeValue(buf, fromValue); [EOL]         final JsonParser jp = buf.asParser(); [EOL]         Object result; [EOL]         final DeserializationConfig deserConfig = getDeserializationConfig(); [EOL]         JsonToken t = _initForReading(jp); [EOL]         if (t == JsonToken.VALUE_NULL) { [EOL]             DeserializationContext ctxt = createDeserializationContext(jp, deserConfig); [EOL]             result = _findRootDeserializer(ctxt, toValueType).getNullValue(); [EOL]         } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) { [EOL]             result = null; [EOL]         } else { [EOL]             DeserializationContext ctxt = createDeserializationContext(jp, deserConfig); [EOL]             JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, toValueType); [EOL]             result = deser.deserialize(jp, ctxt); [EOL]         } [EOL]         jp.close(); [EOL]         return result; [EOL]     } catch (IOException e) { [EOL]         throw new IllegalArgumentException(e.getMessage(), e); [EOL]     } [EOL] }
@SuppressWarnings("deprecation") [EOL] public com.fasterxml.jackson.databind.jsonschema.JsonSchema generateJsonSchema(Class<?> t) throws JsonMappingException { [EOL]     return _serializerProvider(getSerializationConfig()).generateJsonSchema(t); [EOL] }
@SuppressWarnings("deprecation") [EOL] public com.fasterxml.jackson.databind.jsonschema.JsonSchema generateJsonSchema(Class<?> t) throws JsonMappingException { [EOL]     return _serializerProvider(getSerializationConfig()).generateJsonSchema(t); [EOL] }
@SuppressWarnings("deprecation") [EOL] public com.fasterxml.jackson.databind.jsonschema.JsonSchema generateJsonSchema(Class<?> t) throws JsonMappingException { [EOL]     return _serializerProvider(getSerializationConfig()).generateJsonSchema(t); [EOL] }
protected PrettyPrinter _defaultPrettyPrinter() { [EOL]     return _defaultPrettyPrinter; [EOL] }
protected final void _configAndWriteValue(JsonGenerator jgen, Object value) throws IOException, JsonGenerationException, JsonMappingException { [EOL]     SerializationConfig cfg = getSerializationConfig(); [EOL]     if (cfg.isEnabled(SerializationFeature.INDENT_OUTPUT)) { [EOL]         jgen.useDefaultPrettyPrinter(); [EOL]     } [EOL]     if (cfg.isEnabled(SerializationFeature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) { [EOL]         _configAndWriteCloseable(jgen, value, cfg); [EOL]         return; [EOL]     } [EOL]     boolean closed = false; [EOL]     try { [EOL]         _serializerProvider(cfg).serializeValue(jgen, value); [EOL]         closed = true; [EOL]         jgen.close(); [EOL]     } finally { [EOL]         if (!closed) { [EOL]             try { [EOL]                 jgen.close(); [EOL]             } catch (IOException ioe) { [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected final void _configAndWriteValue(JsonGenerator jgen, Object value) throws IOException, JsonGenerationException, JsonMappingException { [EOL]     SerializationConfig cfg = getSerializationConfig(); [EOL]     if (cfg.isEnabled(SerializationFeature.INDENT_OUTPUT)) { [EOL]         jgen.useDefaultPrettyPrinter(); [EOL]     } [EOL]     if (cfg.isEnabled(SerializationFeature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) { [EOL]         _configAndWriteCloseable(jgen, value, cfg); [EOL]         return; [EOL]     } [EOL]     boolean closed = false; [EOL]     try { [EOL]         _serializerProvider(cfg).serializeValue(jgen, value); [EOL]         closed = true; [EOL]         jgen.close(); [EOL]     } finally { [EOL]         if (!closed) { [EOL]             try { [EOL]                 jgen.close(); [EOL]             } catch (IOException ioe) { [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected final void _configAndWriteValue(JsonGenerator jgen, Object value) throws IOException, JsonGenerationException, JsonMappingException { [EOL]     SerializationConfig cfg = getSerializationConfig(); [EOL]     if (cfg.isEnabled(SerializationFeature.INDENT_OUTPUT)) { [EOL]         jgen.useDefaultPrettyPrinter(); [EOL]     } [EOL]     if (cfg.isEnabled(SerializationFeature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) { [EOL]         _configAndWriteCloseable(jgen, value, cfg); [EOL]         return; [EOL]     } [EOL]     boolean closed = false; [EOL]     try { [EOL]         _serializerProvider(cfg).serializeValue(jgen, value); [EOL]         closed = true; [EOL]         jgen.close(); [EOL]     } finally { [EOL]         if (!closed) { [EOL]             try { [EOL]                 jgen.close(); [EOL]             } catch (IOException ioe) { [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected final void _configAndWriteValue(JsonGenerator jgen, Object value) throws IOException, JsonGenerationException, JsonMappingException { [EOL]     SerializationConfig cfg = getSerializationConfig(); [EOL]     if (cfg.isEnabled(SerializationFeature.INDENT_OUTPUT)) { [EOL]         jgen.useDefaultPrettyPrinter(); [EOL]     } [EOL]     if (cfg.isEnabled(SerializationFeature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) { [EOL]         _configAndWriteCloseable(jgen, value, cfg); [EOL]         return; [EOL]     } [EOL]     boolean closed = false; [EOL]     try { [EOL]         _serializerProvider(cfg).serializeValue(jgen, value); [EOL]         closed = true; [EOL]         jgen.close(); [EOL]     } finally { [EOL]         if (!closed) { [EOL]             try { [EOL]                 jgen.close(); [EOL]             } catch (IOException ioe) { [EOL]             } [EOL]         } [EOL]     } [EOL] }
private final void _configAndWriteCloseable(JsonGenerator jgen, Object value, SerializationConfig cfg) throws IOException, JsonGenerationException, JsonMappingException { [EOL]     Closeable toClose = (Closeable) value; [EOL]     try { [EOL]         _serializerProvider(cfg).serializeValue(jgen, value); [EOL]         JsonGenerator tmpJgen = jgen; [EOL]         jgen = null; [EOL]         tmpJgen.close(); [EOL]         Closeable tmpToClose = toClose; [EOL]         toClose = null; [EOL]         tmpToClose.close(); [EOL]     } finally { [EOL]         if (jgen != null) { [EOL]             try { [EOL]                 jgen.close(); [EOL]             } catch (IOException ioe) { [EOL]             } [EOL]         } [EOL]         if (toClose != null) { [EOL]             try { [EOL]                 toClose.close(); [EOL]             } catch (IOException ioe) { [EOL]             } [EOL]         } [EOL]     } [EOL] }
private final void _configAndWriteCloseable(JsonGenerator jgen, Object value, SerializationConfig cfg) throws IOException, JsonGenerationException, JsonMappingException { [EOL]     Closeable toClose = (Closeable) value; [EOL]     try { [EOL]         _serializerProvider(cfg).serializeValue(jgen, value); [EOL]         JsonGenerator tmpJgen = jgen; [EOL]         jgen = null; [EOL]         tmpJgen.close(); [EOL]         Closeable tmpToClose = toClose; [EOL]         toClose = null; [EOL]         tmpToClose.close(); [EOL]     } finally { [EOL]         if (jgen != null) { [EOL]             try { [EOL]                 jgen.close(); [EOL]             } catch (IOException ioe) { [EOL]             } [EOL]         } [EOL]         if (toClose != null) { [EOL]             try { [EOL]                 toClose.close(); [EOL]             } catch (IOException ioe) { [EOL]             } [EOL]         } [EOL]     } [EOL] }
private final void _configAndWriteCloseable(JsonGenerator jgen, Object value, SerializationConfig cfg) throws IOException, JsonGenerationException, JsonMappingException { [EOL]     Closeable toClose = (Closeable) value; [EOL]     try { [EOL]         _serializerProvider(cfg).serializeValue(jgen, value); [EOL]         JsonGenerator tmpJgen = jgen; [EOL]         jgen = null; [EOL]         tmpJgen.close(); [EOL]         Closeable tmpToClose = toClose; [EOL]         toClose = null; [EOL]         tmpToClose.close(); [EOL]     } finally { [EOL]         if (jgen != null) { [EOL]             try { [EOL]                 jgen.close(); [EOL]             } catch (IOException ioe) { [EOL]             } [EOL]         } [EOL]         if (toClose != null) { [EOL]             try { [EOL]                 toClose.close(); [EOL]             } catch (IOException ioe) { [EOL]             } [EOL]         } [EOL]     } [EOL] }
private final void _configAndWriteCloseable(JsonGenerator jgen, Object value, SerializationConfig cfg) throws IOException, JsonGenerationException, JsonMappingException { [EOL]     Closeable toClose = (Closeable) value; [EOL]     try { [EOL]         _serializerProvider(cfg).serializeValue(jgen, value); [EOL]         JsonGenerator tmpJgen = jgen; [EOL]         jgen = null; [EOL]         tmpJgen.close(); [EOL]         Closeable tmpToClose = toClose; [EOL]         toClose = null; [EOL]         tmpToClose.close(); [EOL]     } finally { [EOL]         if (jgen != null) { [EOL]             try { [EOL]                 jgen.close(); [EOL]             } catch (IOException ioe) { [EOL]             } [EOL]         } [EOL]         if (toClose != null) { [EOL]             try { [EOL]                 toClose.close(); [EOL]             } catch (IOException ioe) { [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected Object _readValue(DeserializationConfig cfg, JsonParser jp, JavaType valueType) throws IOException, JsonParseException, JsonMappingException { [EOL]     Object result; [EOL]     JsonToken t = _initForReading(jp); [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         DeserializationContext ctxt = createDeserializationContext(jp, cfg); [EOL]         result = _findRootDeserializer(ctxt, valueType).getNullValue(); [EOL]     } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) { [EOL]         result = null; [EOL]     } else { [EOL]         DeserializationContext ctxt = createDeserializationContext(jp, cfg); [EOL]         JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, valueType); [EOL]         if (cfg.useRootWrapping()) { [EOL]             result = _unwrapAndDeserialize(jp, ctxt, cfg, valueType, deser); [EOL]         } else { [EOL]             result = deser.deserialize(jp, ctxt); [EOL]         } [EOL]     } [EOL]     jp.clearCurrentToken(); [EOL]     return result; [EOL] }
protected Object _readValue(DeserializationConfig cfg, JsonParser jp, JavaType valueType) throws IOException, JsonParseException, JsonMappingException { [EOL]     Object result; [EOL]     JsonToken t = _initForReading(jp); [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         DeserializationContext ctxt = createDeserializationContext(jp, cfg); [EOL]         result = _findRootDeserializer(ctxt, valueType).getNullValue(); [EOL]     } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) { [EOL]         result = null; [EOL]     } else { [EOL]         DeserializationContext ctxt = createDeserializationContext(jp, cfg); [EOL]         JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, valueType); [EOL]         if (cfg.useRootWrapping()) { [EOL]             result = _unwrapAndDeserialize(jp, ctxt, cfg, valueType, deser); [EOL]         } else { [EOL]             result = deser.deserialize(jp, ctxt); [EOL]         } [EOL]     } [EOL]     jp.clearCurrentToken(); [EOL]     return result; [EOL] }
protected Object _readValue(DeserializationConfig cfg, JsonParser jp, JavaType valueType) throws IOException, JsonParseException, JsonMappingException { [EOL]     Object result; [EOL]     JsonToken t = _initForReading(jp); [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         DeserializationContext ctxt = createDeserializationContext(jp, cfg); [EOL]         result = _findRootDeserializer(ctxt, valueType).getNullValue(); [EOL]     } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) { [EOL]         result = null; [EOL]     } else { [EOL]         DeserializationContext ctxt = createDeserializationContext(jp, cfg); [EOL]         JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, valueType); [EOL]         if (cfg.useRootWrapping()) { [EOL]             result = _unwrapAndDeserialize(jp, ctxt, cfg, valueType, deser); [EOL]         } else { [EOL]             result = deser.deserialize(jp, ctxt); [EOL]         } [EOL]     } [EOL]     jp.clearCurrentToken(); [EOL]     return result; [EOL] }
protected Object _readValue(DeserializationConfig cfg, JsonParser jp, JavaType valueType) throws IOException, JsonParseException, JsonMappingException { [EOL]     Object result; [EOL]     JsonToken t = _initForReading(jp); [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         DeserializationContext ctxt = createDeserializationContext(jp, cfg); [EOL]         result = _findRootDeserializer(ctxt, valueType).getNullValue(); [EOL]     } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) { [EOL]         result = null; [EOL]     } else { [EOL]         DeserializationContext ctxt = createDeserializationContext(jp, cfg); [EOL]         JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, valueType); [EOL]         if (cfg.useRootWrapping()) { [EOL]             result = _unwrapAndDeserialize(jp, ctxt, cfg, valueType, deser); [EOL]         } else { [EOL]             result = deser.deserialize(jp, ctxt); [EOL]         } [EOL]     } [EOL]     jp.clearCurrentToken(); [EOL]     return result; [EOL] }
protected Object _readMapAndClose(JsonParser jp, JavaType valueType) throws IOException, JsonParseException, JsonMappingException { [EOL]     try { [EOL]         Object result; [EOL]         JsonToken t = _initForReading(jp); [EOL]         if (t == JsonToken.VALUE_NULL) { [EOL]             DeserializationContext ctxt = createDeserializationContext(jp, getDeserializationConfig()); [EOL]             result = _findRootDeserializer(ctxt, valueType).getNullValue(); [EOL]         } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) { [EOL]             result = null; [EOL]         } else { [EOL]             DeserializationConfig cfg = getDeserializationConfig(); [EOL]             DeserializationContext ctxt = createDeserializationContext(jp, cfg); [EOL]             JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, valueType); [EOL]             if (cfg.useRootWrapping()) { [EOL]                 result = _unwrapAndDeserialize(jp, ctxt, cfg, valueType, deser); [EOL]             } else { [EOL]                 result = deser.deserialize(jp, ctxt); [EOL]             } [EOL]         } [EOL]         jp.clearCurrentToken(); [EOL]         return result; [EOL]     } finally { [EOL]         try { [EOL]             jp.close(); [EOL]         } catch (IOException ioe) { [EOL]         } [EOL]     } [EOL] }
public boolean canCreateFromObjectWith() { [EOL]     return false; [EOL] }
public SettableBeanProperty[] getFromObjectArguments(DeserializationConfig config) { [EOL]     return null; [EOL] }
public SettableBeanProperty[] getFromObjectArguments(DeserializationConfig config) { [EOL]     return null; [EOL] }
public AnnotatedParameter getIncompleteParameter() { [EOL]     return null; [EOL] }
public static BooleanNode getFalse() { [EOL]     return FALSE; [EOL] }
@Override [EOL] public long asLong(long defaultValue) { [EOL]     return _value ? 1L : 0L; [EOL] }
@Override [EOL] public long asLong(long defaultValue) { [EOL]     return _value ? 1L : 0L; [EOL] }
@Override [EOL] public double asDouble(double defaultValue) { [EOL]     return _value ? 1.0 : 0.0; [EOL] }
@Override [EOL] public double asDouble(double defaultValue) { [EOL]     return _value ? 1.0 : 0.0; [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) { [EOL]         return false; [EOL]     } [EOL]     return (_value == ((BooleanNode) o)._value); [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) { [EOL]         return false; [EOL]     } [EOL]     return (_value == ((BooleanNode) o)._value); [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) { [EOL]         return false; [EOL]     } [EOL]     return (_value == ((BooleanNode) o)._value); [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) { [EOL]         return false; [EOL]     } [EOL]     return (_value == ((BooleanNode) o)._value); [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) { [EOL]         return false; [EOL]     } [EOL]     return (_value == ((BooleanNode) o)._value); [EOL] }
public static NameTransformer simpleTransformer(final String prefix, final String suffix) { [EOL]     boolean hasPrefix = (prefix != null) && (prefix.length() > 0); [EOL]     boolean hasSuffix = (suffix != null) && (suffix.length() > 0); [EOL]     if (hasPrefix) { [EOL]         if (hasSuffix) { [EOL]             return new NameTransformer() { [EOL]  [EOL]                 @Override [EOL]                 public String transform(String name) { [EOL]                     return prefix + name + suffix; [EOL]                 } [EOL]  [EOL]                 @Override [EOL]                 public String reverse(String transformed) { [EOL]                     if (transformed.startsWith(prefix)) { [EOL]                         String str = transformed.substring(prefix.length()); [EOL]                         if (str.endsWith(suffix)) { [EOL]                             return str.substring(0, str.length() - suffix.length()); [EOL]                         } [EOL]                     } [EOL]                     return null; [EOL]                 } [EOL]  [EOL]                 @Override [EOL]                 public String toString() { [EOL]                     return "[PreAndSuffixTransformer('" + prefix + "','" + suffix + "')]"; [EOL]                 } [EOL]             }; [EOL]         } [EOL]         return new NameTransformer() { [EOL]  [EOL]             @Override [EOL]             public String transform(String name) { [EOL]                 return prefix + name; [EOL]             } [EOL]  [EOL]             @Override [EOL]             public String reverse(String transformed) { [EOL]                 if (transformed.startsWith(prefix)) { [EOL]                     return transformed.substring(prefix.length()); [EOL]                 } [EOL]                 return null; [EOL]             } [EOL]  [EOL]             @Override [EOL]             public String toString() { [EOL]                 return "[PrefixTransformer('" + prefix + "')]"; [EOL]             } [EOL]         }; [EOL]     } [EOL]     if (hasSuffix) { [EOL]         return new NameTransformer() { [EOL]  [EOL]             @Override [EOL]             public String transform(String name) { [EOL]                 return name + suffix; [EOL]             } [EOL]  [EOL]             @Override [EOL]             public String reverse(String transformed) { [EOL]                 if (transformed.endsWith(suffix)) { [EOL]                     return transformed.substring(0, transformed.length() - suffix.length()); [EOL]                 } [EOL]                 return null; [EOL]             } [EOL]  [EOL]             @Override [EOL]             public String toString() { [EOL]                 return "[SuffixTransformer('" + suffix + "')]"; [EOL]             } [EOL]         }; [EOL]     } [EOL]     return NOP; [EOL] } protected NameTransformer(); public Chained(NameTransformer t1, NameTransformer t2); public String transform(String name); public String reverse(String transformed); public String transform(String name); public String reverse(String transformed); public String toString(); public String transform(String name); public String reverse(String transformed); public String toString(); public String transform(String name); public String reverse(String transformed); public String toString(); public static NameTransformer simpleTransformer(final String prefix, final String suffix); public static NameTransformer chainedTransformer(NameTransformer t1, NameTransformer t2); public abstract String transform(String name); public abstract String reverse(String transformed); public String transform(String name); public String reverse(String transformed); public String toString(); NameTransformer NOP=Optional[new NameTransformer() {; ;     @Override;     public String transform(String name) {;         return name;;     }; ;     @Override;     public String reverse(String transformed) {;         // identity transformation is always reversible:;         return transformed;;     }; }
public static NameTransformer simpleTransformer(final String prefix, final String suffix) { [EOL]     boolean hasPrefix = (prefix != null) && (prefix.length() > 0); [EOL]     boolean hasSuffix = (suffix != null) && (suffix.length() > 0); [EOL]     if (hasPrefix) { [EOL]         if (hasSuffix) { [EOL]             return new NameTransformer() { [EOL]  [EOL]                 @Override [EOL]                 public String transform(String name) { [EOL]                     return prefix + name + suffix; [EOL]                 } [EOL]  [EOL]                 @Override [EOL]                 public String reverse(String transformed) { [EOL]                     if (transformed.startsWith(prefix)) { [EOL]                         String str = transformed.substring(prefix.length()); [EOL]                         if (str.endsWith(suffix)) { [EOL]                             return str.substring(0, str.length() - suffix.length()); [EOL]                         } [EOL]                     } [EOL]                     return null; [EOL]                 } [EOL]  [EOL]                 @Override [EOL]                 public String toString() { [EOL]                     return "[PreAndSuffixTransformer('" + prefix + "','" + suffix + "')]"; [EOL]                 } [EOL]             }; [EOL]         } [EOL]         return new NameTransformer() { [EOL]  [EOL]             @Override [EOL]             public String transform(String name) { [EOL]                 return prefix + name; [EOL]             } [EOL]  [EOL]             @Override [EOL]             public String reverse(String transformed) { [EOL]                 if (transformed.startsWith(prefix)) { [EOL]                     return transformed.substring(prefix.length()); [EOL]                 } [EOL]                 return null; [EOL]             } [EOL]  [EOL]             @Override [EOL]             public String toString() { [EOL]                 return "[PrefixTransformer('" + prefix + "')]"; [EOL]             } [EOL]         }; [EOL]     } [EOL]     if (hasSuffix) { [EOL]         return new NameTransformer() { [EOL]  [EOL]             @Override [EOL]             public String transform(String name) { [EOL]                 return name + suffix; [EOL]             } [EOL]  [EOL]             @Override [EOL]             public String reverse(String transformed) { [EOL]                 if (transformed.endsWith(suffix)) { [EOL]                     return transformed.substring(0, transformed.length() - suffix.length()); [EOL]                 } [EOL]                 return null; [EOL]             } [EOL]  [EOL]             @Override [EOL]             public String toString() { [EOL]                 return "[SuffixTransformer('" + suffix + "')]"; [EOL]             } [EOL]         }; [EOL]     } [EOL]     return NOP; [EOL] } protected NameTransformer(); public Chained(NameTransformer t1, NameTransformer t2); public String transform(String name); public String reverse(String transformed); public String transform(String name); public String reverse(String transformed); public String toString(); public String transform(String name); public String reverse(String transformed); public String toString(); public String transform(String name); public String reverse(String transformed); public String toString(); public static NameTransformer simpleTransformer(final String prefix, final String suffix); public static NameTransformer chainedTransformer(NameTransformer t1, NameTransformer t2); public abstract String transform(String name); public abstract String reverse(String transformed); public String transform(String name); public String reverse(String transformed); public String toString(); NameTransformer NOP=Optional[new NameTransformer() {; ;     @Override;     public String transform(String name) {;         return name;;     }; ;     @Override;     public String reverse(String transformed) {;         // identity transformation is always reversible:;         return transformed;;     }; }
public static NameTransformer simpleTransformer(final String prefix, final String suffix) { [EOL]     boolean hasPrefix = (prefix != null) && (prefix.length() > 0); [EOL]     boolean hasSuffix = (suffix != null) && (suffix.length() > 0); [EOL]     if (hasPrefix) { [EOL]         if (hasSuffix) { [EOL]             return new NameTransformer() { [EOL]  [EOL]                 @Override [EOL]                 public String transform(String name) { [EOL]                     return prefix + name + suffix; [EOL]                 } [EOL]  [EOL]                 @Override [EOL]                 public String reverse(String transformed) { [EOL]                     if (transformed.startsWith(prefix)) { [EOL]                         String str = transformed.substring(prefix.length()); [EOL]                         if (str.endsWith(suffix)) { [EOL]                             return str.substring(0, str.length() - suffix.length()); [EOL]                         } [EOL]                     } [EOL]                     return null; [EOL]                 } [EOL]  [EOL]                 @Override [EOL]                 public String toString() { [EOL]                     return "[PreAndSuffixTransformer('" + prefix + "','" + suffix + "')]"; [EOL]                 } [EOL]             }; [EOL]         } [EOL]         return new NameTransformer() { [EOL]  [EOL]             @Override [EOL]             public String transform(String name) { [EOL]                 return prefix + name; [EOL]             } [EOL]  [EOL]             @Override [EOL]             public String reverse(String transformed) { [EOL]                 if (transformed.startsWith(prefix)) { [EOL]                     return transformed.substring(prefix.length()); [EOL]                 } [EOL]                 return null; [EOL]             } [EOL]  [EOL]             @Override [EOL]             public String toString() { [EOL]                 return "[PrefixTransformer('" + prefix + "')]"; [EOL]             } [EOL]         }; [EOL]     } [EOL]     if (hasSuffix) { [EOL]         return new NameTransformer() { [EOL]  [EOL]             @Override [EOL]             public String transform(String name) { [EOL]                 return name + suffix; [EOL]             } [EOL]  [EOL]             @Override [EOL]             public String reverse(String transformed) { [EOL]                 if (transformed.endsWith(suffix)) { [EOL]                     return transformed.substring(0, transformed.length() - suffix.length()); [EOL]                 } [EOL]                 return null; [EOL]             } [EOL]  [EOL]             @Override [EOL]             public String toString() { [EOL]                 return "[SuffixTransformer('" + suffix + "')]"; [EOL]             } [EOL]         }; [EOL]     } [EOL]     return NOP; [EOL] } protected NameTransformer(); public Chained(NameTransformer t1, NameTransformer t2); public String transform(String name); public String reverse(String transformed); public String transform(String name); public String reverse(String transformed); public String toString(); public String transform(String name); public String reverse(String transformed); public String toString(); public String transform(String name); public String reverse(String transformed); public String toString(); public static NameTransformer simpleTransformer(final String prefix, final String suffix); public static NameTransformer chainedTransformer(NameTransformer t1, NameTransformer t2); public abstract String transform(String name); public abstract String reverse(String transformed); public String transform(String name); public String reverse(String transformed); public String toString(); NameTransformer NOP=Optional[new NameTransformer() {; ;     @Override;     public String transform(String name) {;         return name;;     }; ;     @Override;     public String reverse(String transformed) {;         // identity transformation is always reversible:;         return transformed;;     }; }
public static NameTransformer simpleTransformer(final String prefix, final String suffix) { [EOL]     boolean hasPrefix = (prefix != null) && (prefix.length() > 0); [EOL]     boolean hasSuffix = (suffix != null) && (suffix.length() > 0); [EOL]     if (hasPrefix) { [EOL]         if (hasSuffix) { [EOL]             return new NameTransformer() { [EOL]  [EOL]                 @Override [EOL]                 public String transform(String name) { [EOL]                     return prefix + name + suffix; [EOL]                 } [EOL]  [EOL]                 @Override [EOL]                 public String reverse(String transformed) { [EOL]                     if (transformed.startsWith(prefix)) { [EOL]                         String str = transformed.substring(prefix.length()); [EOL]                         if (str.endsWith(suffix)) { [EOL]                             return str.substring(0, str.length() - suffix.length()); [EOL]                         } [EOL]                     } [EOL]                     return null; [EOL]                 } [EOL]  [EOL]                 @Override [EOL]                 public String toString() { [EOL]                     return "[PreAndSuffixTransformer('" + prefix + "','" + suffix + "')]"; [EOL]                 } [EOL]             }; [EOL]         } [EOL]         return new NameTransformer() { [EOL]  [EOL]             @Override [EOL]             public String transform(String name) { [EOL]                 return prefix + name; [EOL]             } [EOL]  [EOL]             @Override [EOL]             public String reverse(String transformed) { [EOL]                 if (transformed.startsWith(prefix)) { [EOL]                     return transformed.substring(prefix.length()); [EOL]                 } [EOL]                 return null; [EOL]             } [EOL]  [EOL]             @Override [EOL]             public String toString() { [EOL]                 return "[PrefixTransformer('" + prefix + "')]"; [EOL]             } [EOL]         }; [EOL]     } [EOL]     if (hasSuffix) { [EOL]         return new NameTransformer() { [EOL]  [EOL]             @Override [EOL]             public String transform(String name) { [EOL]                 return name + suffix; [EOL]             } [EOL]  [EOL]             @Override [EOL]             public String reverse(String transformed) { [EOL]                 if (transformed.endsWith(suffix)) { [EOL]                     return transformed.substring(0, transformed.length() - suffix.length()); [EOL]                 } [EOL]                 return null; [EOL]             } [EOL]  [EOL]             @Override [EOL]             public String toString() { [EOL]                 return "[SuffixTransformer('" + suffix + "')]"; [EOL]             } [EOL]         }; [EOL]     } [EOL]     return NOP; [EOL] } protected NameTransformer(); public Chained(NameTransformer t1, NameTransformer t2); public String transform(String name); public String reverse(String transformed); public String transform(String name); public String reverse(String transformed); public String toString(); public String transform(String name); public String reverse(String transformed); public String toString(); public String transform(String name); public String reverse(String transformed); public String toString(); public static NameTransformer simpleTransformer(final String prefix, final String suffix); public static NameTransformer chainedTransformer(NameTransformer t1, NameTransformer t2); public abstract String transform(String name); public abstract String reverse(String transformed); public String transform(String name); public String reverse(String transformed); public String toString(); NameTransformer NOP=Optional[new NameTransformer() {; ;     @Override;     public String transform(String name) {;         return name;;     }; ;     @Override;     public String reverse(String transformed) {;         // identity transformation is always reversible:;         return transformed;;     }; }
protected StdDeserializer(Class<?> vc) { [EOL]     _valueClass = vc; [EOL] }
protected final Boolean _parseBoolean(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_TRUE) { [EOL]         return Boolean.TRUE; [EOL]     } [EOL]     if (t == JsonToken.VALUE_FALSE) { [EOL]         return Boolean.FALSE; [EOL]     } [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (jp.getNumberType() == NumberType.INT) { [EOL]             return (jp.getIntValue() == 0) ? Boolean.FALSE : Boolean.TRUE; [EOL]         } [EOL]         return Boolean.valueOf(_parseBooleanFromNumber(jp, ctxt)); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Boolean) getNullValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if ("true".equals(text)) { [EOL]             return Boolean.TRUE; [EOL]         } [EOL]         if ("false".equals(text)) { [EOL]             return Boolean.FALSE; [EOL]         } [EOL]         if (text.length() == 0) { [EOL]             return (Boolean) getEmptyValue(); [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "only \"true\" or \"false\" recognized"); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final Boolean _parseBoolean(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_TRUE) { [EOL]         return Boolean.TRUE; [EOL]     } [EOL]     if (t == JsonToken.VALUE_FALSE) { [EOL]         return Boolean.FALSE; [EOL]     } [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (jp.getNumberType() == NumberType.INT) { [EOL]             return (jp.getIntValue() == 0) ? Boolean.FALSE : Boolean.TRUE; [EOL]         } [EOL]         return Boolean.valueOf(_parseBooleanFromNumber(jp, ctxt)); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Boolean) getNullValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if ("true".equals(text)) { [EOL]             return Boolean.TRUE; [EOL]         } [EOL]         if ("false".equals(text)) { [EOL]             return Boolean.FALSE; [EOL]         } [EOL]         if (text.length() == 0) { [EOL]             return (Boolean) getEmptyValue(); [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "only \"true\" or \"false\" recognized"); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final Boolean _parseBoolean(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_TRUE) { [EOL]         return Boolean.TRUE; [EOL]     } [EOL]     if (t == JsonToken.VALUE_FALSE) { [EOL]         return Boolean.FALSE; [EOL]     } [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (jp.getNumberType() == NumberType.INT) { [EOL]             return (jp.getIntValue() == 0) ? Boolean.FALSE : Boolean.TRUE; [EOL]         } [EOL]         return Boolean.valueOf(_parseBooleanFromNumber(jp, ctxt)); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Boolean) getNullValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if ("true".equals(text)) { [EOL]             return Boolean.TRUE; [EOL]         } [EOL]         if ("false".equals(text)) { [EOL]             return Boolean.FALSE; [EOL]         } [EOL]         if (text.length() == 0) { [EOL]             return (Boolean) getEmptyValue(); [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "only \"true\" or \"false\" recognized"); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final Boolean _parseBoolean(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_TRUE) { [EOL]         return Boolean.TRUE; [EOL]     } [EOL]     if (t == JsonToken.VALUE_FALSE) { [EOL]         return Boolean.FALSE; [EOL]     } [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (jp.getNumberType() == NumberType.INT) { [EOL]             return (jp.getIntValue() == 0) ? Boolean.FALSE : Boolean.TRUE; [EOL]         } [EOL]         return Boolean.valueOf(_parseBooleanFromNumber(jp, ctxt)); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Boolean) getNullValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if ("true".equals(text)) { [EOL]             return Boolean.TRUE; [EOL]         } [EOL]         if ("false".equals(text)) { [EOL]             return Boolean.FALSE; [EOL]         } [EOL]         if (text.length() == 0) { [EOL]             return (Boolean) getEmptyValue(); [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "only \"true\" or \"false\" recognized"); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final Boolean _parseBoolean(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_TRUE) { [EOL]         return Boolean.TRUE; [EOL]     } [EOL]     if (t == JsonToken.VALUE_FALSE) { [EOL]         return Boolean.FALSE; [EOL]     } [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (jp.getNumberType() == NumberType.INT) { [EOL]             return (jp.getIntValue() == 0) ? Boolean.FALSE : Boolean.TRUE; [EOL]         } [EOL]         return Boolean.valueOf(_parseBooleanFromNumber(jp, ctxt)); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Boolean) getNullValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if ("true".equals(text)) { [EOL]             return Boolean.TRUE; [EOL]         } [EOL]         if ("false".equals(text)) { [EOL]             return Boolean.FALSE; [EOL]         } [EOL]         if (text.length() == 0) { [EOL]             return (Boolean) getEmptyValue(); [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "only \"true\" or \"false\" recognized"); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final Boolean _parseBoolean(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_TRUE) { [EOL]         return Boolean.TRUE; [EOL]     } [EOL]     if (t == JsonToken.VALUE_FALSE) { [EOL]         return Boolean.FALSE; [EOL]     } [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (jp.getNumberType() == NumberType.INT) { [EOL]             return (jp.getIntValue() == 0) ? Boolean.FALSE : Boolean.TRUE; [EOL]         } [EOL]         return Boolean.valueOf(_parseBooleanFromNumber(jp, ctxt)); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Boolean) getNullValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if ("true".equals(text)) { [EOL]             return Boolean.TRUE; [EOL]         } [EOL]         if ("false".equals(text)) { [EOL]             return Boolean.FALSE; [EOL]         } [EOL]         if (text.length() == 0) { [EOL]             return (Boolean) getEmptyValue(); [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "only \"true\" or \"false\" recognized"); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final Boolean _parseBoolean(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_TRUE) { [EOL]         return Boolean.TRUE; [EOL]     } [EOL]     if (t == JsonToken.VALUE_FALSE) { [EOL]         return Boolean.FALSE; [EOL]     } [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (jp.getNumberType() == NumberType.INT) { [EOL]             return (jp.getIntValue() == 0) ? Boolean.FALSE : Boolean.TRUE; [EOL]         } [EOL]         return Boolean.valueOf(_parseBooleanFromNumber(jp, ctxt)); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Boolean) getNullValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if ("true".equals(text)) { [EOL]             return Boolean.TRUE; [EOL]         } [EOL]         if ("false".equals(text)) { [EOL]             return Boolean.FALSE; [EOL]         } [EOL]         if (text.length() == 0) { [EOL]             return (Boolean) getEmptyValue(); [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "only \"true\" or \"false\" recognized"); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final Boolean _parseBoolean(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_TRUE) { [EOL]         return Boolean.TRUE; [EOL]     } [EOL]     if (t == JsonToken.VALUE_FALSE) { [EOL]         return Boolean.FALSE; [EOL]     } [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (jp.getNumberType() == NumberType.INT) { [EOL]             return (jp.getIntValue() == 0) ? Boolean.FALSE : Boolean.TRUE; [EOL]         } [EOL]         return Boolean.valueOf(_parseBooleanFromNumber(jp, ctxt)); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Boolean) getNullValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if ("true".equals(text)) { [EOL]             return Boolean.TRUE; [EOL]         } [EOL]         if ("false".equals(text)) { [EOL]             return Boolean.FALSE; [EOL]         } [EOL]         if (text.length() == 0) { [EOL]             return (Boolean) getEmptyValue(); [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "only \"true\" or \"false\" recognized"); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final Boolean _parseBoolean(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_TRUE) { [EOL]         return Boolean.TRUE; [EOL]     } [EOL]     if (t == JsonToken.VALUE_FALSE) { [EOL]         return Boolean.FALSE; [EOL]     } [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (jp.getNumberType() == NumberType.INT) { [EOL]             return (jp.getIntValue() == 0) ? Boolean.FALSE : Boolean.TRUE; [EOL]         } [EOL]         return Boolean.valueOf(_parseBooleanFromNumber(jp, ctxt)); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Boolean) getNullValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if ("true".equals(text)) { [EOL]             return Boolean.TRUE; [EOL]         } [EOL]         if ("false".equals(text)) { [EOL]             return Boolean.FALSE; [EOL]         } [EOL]         if (text.length() == 0) { [EOL]             return (Boolean) getEmptyValue(); [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "only \"true\" or \"false\" recognized"); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final Boolean _parseBoolean(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_TRUE) { [EOL]         return Boolean.TRUE; [EOL]     } [EOL]     if (t == JsonToken.VALUE_FALSE) { [EOL]         return Boolean.FALSE; [EOL]     } [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (jp.getNumberType() == NumberType.INT) { [EOL]             return (jp.getIntValue() == 0) ? Boolean.FALSE : Boolean.TRUE; [EOL]         } [EOL]         return Boolean.valueOf(_parseBooleanFromNumber(jp, ctxt)); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Boolean) getNullValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if ("true".equals(text)) { [EOL]             return Boolean.TRUE; [EOL]         } [EOL]         if ("false".equals(text)) { [EOL]             return Boolean.FALSE; [EOL]         } [EOL]         if (text.length() == 0) { [EOL]             return (Boolean) getEmptyValue(); [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "only \"true\" or \"false\" recognized"); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final Boolean _parseBoolean(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_TRUE) { [EOL]         return Boolean.TRUE; [EOL]     } [EOL]     if (t == JsonToken.VALUE_FALSE) { [EOL]         return Boolean.FALSE; [EOL]     } [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (jp.getNumberType() == NumberType.INT) { [EOL]             return (jp.getIntValue() == 0) ? Boolean.FALSE : Boolean.TRUE; [EOL]         } [EOL]         return Boolean.valueOf(_parseBooleanFromNumber(jp, ctxt)); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Boolean) getNullValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if ("true".equals(text)) { [EOL]             return Boolean.TRUE; [EOL]         } [EOL]         if ("false".equals(text)) { [EOL]             return Boolean.FALSE; [EOL]         } [EOL]         if (text.length() == 0) { [EOL]             return (Boolean) getEmptyValue(); [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "only \"true\" or \"false\" recognized"); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected Byte _parseByte(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getByteValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         int value; [EOL]         try { [EOL]             int len = text.length(); [EOL]             if (len == 0) { [EOL]                 return (Byte) getEmptyValue(); [EOL]             } [EOL]             value = NumberInput.parseInt(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "not a valid Byte value"); [EOL]         } [EOL]         if (value < Byte.MIN_VALUE || value > 255) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "overflow, value can not be represented as 8-bit value"); [EOL]         } [EOL]         return Byte.valueOf((byte) value); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Byte) getNullValue(); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected Byte _parseByte(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getByteValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         int value; [EOL]         try { [EOL]             int len = text.length(); [EOL]             if (len == 0) { [EOL]                 return (Byte) getEmptyValue(); [EOL]             } [EOL]             value = NumberInput.parseInt(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "not a valid Byte value"); [EOL]         } [EOL]         if (value < Byte.MIN_VALUE || value > 255) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "overflow, value can not be represented as 8-bit value"); [EOL]         } [EOL]         return Byte.valueOf((byte) value); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Byte) getNullValue(); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected Byte _parseByte(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getByteValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         int value; [EOL]         try { [EOL]             int len = text.length(); [EOL]             if (len == 0) { [EOL]                 return (Byte) getEmptyValue(); [EOL]             } [EOL]             value = NumberInput.parseInt(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "not a valid Byte value"); [EOL]         } [EOL]         if (value < Byte.MIN_VALUE || value > 255) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "overflow, value can not be represented as 8-bit value"); [EOL]         } [EOL]         return Byte.valueOf((byte) value); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Byte) getNullValue(); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected Byte _parseByte(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getByteValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         int value; [EOL]         try { [EOL]             int len = text.length(); [EOL]             if (len == 0) { [EOL]                 return (Byte) getEmptyValue(); [EOL]             } [EOL]             value = NumberInput.parseInt(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "not a valid Byte value"); [EOL]         } [EOL]         if (value < Byte.MIN_VALUE || value > 255) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "overflow, value can not be represented as 8-bit value"); [EOL]         } [EOL]         return Byte.valueOf((byte) value); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Byte) getNullValue(); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected Byte _parseByte(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getByteValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         int value; [EOL]         try { [EOL]             int len = text.length(); [EOL]             if (len == 0) { [EOL]                 return (Byte) getEmptyValue(); [EOL]             } [EOL]             value = NumberInput.parseInt(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "not a valid Byte value"); [EOL]         } [EOL]         if (value < Byte.MIN_VALUE || value > 255) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "overflow, value can not be represented as 8-bit value"); [EOL]         } [EOL]         return Byte.valueOf((byte) value); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Byte) getNullValue(); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected Byte _parseByte(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getByteValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         int value; [EOL]         try { [EOL]             int len = text.length(); [EOL]             if (len == 0) { [EOL]                 return (Byte) getEmptyValue(); [EOL]             } [EOL]             value = NumberInput.parseInt(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "not a valid Byte value"); [EOL]         } [EOL]         if (value < Byte.MIN_VALUE || value > 255) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "overflow, value can not be represented as 8-bit value"); [EOL]         } [EOL]         return Byte.valueOf((byte) value); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Byte) getNullValue(); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected Byte _parseByte(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getByteValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         int value; [EOL]         try { [EOL]             int len = text.length(); [EOL]             if (len == 0) { [EOL]                 return (Byte) getEmptyValue(); [EOL]             } [EOL]             value = NumberInput.parseInt(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "not a valid Byte value"); [EOL]         } [EOL]         if (value < Byte.MIN_VALUE || value > 255) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "overflow, value can not be represented as 8-bit value"); [EOL]         } [EOL]         return Byte.valueOf((byte) value); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Byte) getNullValue(); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected Byte _parseByte(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getByteValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         int value; [EOL]         try { [EOL]             int len = text.length(); [EOL]             if (len == 0) { [EOL]                 return (Byte) getEmptyValue(); [EOL]             } [EOL]             value = NumberInput.parseInt(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "not a valid Byte value"); [EOL]         } [EOL]         if (value < Byte.MIN_VALUE || value > 255) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "overflow, value can not be represented as 8-bit value"); [EOL]         } [EOL]         return Byte.valueOf((byte) value); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Byte) getNullValue(); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final Integer _parseInteger(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return Integer.valueOf(jp.getIntValue()); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         try { [EOL]             int len = text.length(); [EOL]             if (len > 9) { [EOL]                 long l = Long.parseLong(text); [EOL]                 if (l < Integer.MIN_VALUE || l > Integer.MAX_VALUE) { [EOL]                     throw ctxt.weirdStringException(text, _valueClass, "Overflow: numeric value (" + text + ") out of range of Integer (" + Integer.MIN_VALUE + " - " + Integer.MAX_VALUE + ")"); [EOL]                 } [EOL]                 return Integer.valueOf((int) l); [EOL]             } [EOL]             if (len == 0) { [EOL]                 return (Integer) getEmptyValue(); [EOL]             } [EOL]             return Integer.valueOf(NumberInput.parseInt(text)); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "not a valid Integer value"); [EOL]         } [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Integer) getNullValue(); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final Float _parseFloat(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getFloatValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if (text.length() == 0) { [EOL]             return (Float) getEmptyValue(); [EOL]         } [EOL]         switch(text.charAt(0)) { [EOL]             case 'I': [EOL]                 if ("Infinity".equals(text) || "INF".equals(text)) { [EOL]                     return Float.POSITIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]             case 'N': [EOL]                 if ("NaN".equals(text)) { [EOL]                     return Float.NaN; [EOL]                 } [EOL]                 break; [EOL]             case '-': [EOL]                 if ("-Infinity".equals(text) || "-INF".equals(text)) { [EOL]                     return Float.NEGATIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         try { [EOL]             return Float.parseFloat(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "not a valid Float value"); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Float) getNullValue(); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final Float _parseFloat(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getFloatValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if (text.length() == 0) { [EOL]             return (Float) getEmptyValue(); [EOL]         } [EOL]         switch(text.charAt(0)) { [EOL]             case 'I': [EOL]                 if ("Infinity".equals(text) || "INF".equals(text)) { [EOL]                     return Float.POSITIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]             case 'N': [EOL]                 if ("NaN".equals(text)) { [EOL]                     return Float.NaN; [EOL]                 } [EOL]                 break; [EOL]             case '-': [EOL]                 if ("-Infinity".equals(text) || "-INF".equals(text)) { [EOL]                     return Float.NEGATIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         try { [EOL]             return Float.parseFloat(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "not a valid Float value"); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Float) getNullValue(); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final Float _parseFloat(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getFloatValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if (text.length() == 0) { [EOL]             return (Float) getEmptyValue(); [EOL]         } [EOL]         switch(text.charAt(0)) { [EOL]             case 'I': [EOL]                 if ("Infinity".equals(text) || "INF".equals(text)) { [EOL]                     return Float.POSITIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]             case 'N': [EOL]                 if ("NaN".equals(text)) { [EOL]                     return Float.NaN; [EOL]                 } [EOL]                 break; [EOL]             case '-': [EOL]                 if ("-Infinity".equals(text) || "-INF".equals(text)) { [EOL]                     return Float.NEGATIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         try { [EOL]             return Float.parseFloat(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "not a valid Float value"); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Float) getNullValue(); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final Float _parseFloat(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getFloatValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if (text.length() == 0) { [EOL]             return (Float) getEmptyValue(); [EOL]         } [EOL]         switch(text.charAt(0)) { [EOL]             case 'I': [EOL]                 if ("Infinity".equals(text) || "INF".equals(text)) { [EOL]                     return Float.POSITIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]             case 'N': [EOL]                 if ("NaN".equals(text)) { [EOL]                     return Float.NaN; [EOL]                 } [EOL]                 break; [EOL]             case '-': [EOL]                 if ("-Infinity".equals(text) || "-INF".equals(text)) { [EOL]                     return Float.NEGATIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         try { [EOL]             return Float.parseFloat(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "not a valid Float value"); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Float) getNullValue(); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final Float _parseFloat(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getFloatValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if (text.length() == 0) { [EOL]             return (Float) getEmptyValue(); [EOL]         } [EOL]         switch(text.charAt(0)) { [EOL]             case 'I': [EOL]                 if ("Infinity".equals(text) || "INF".equals(text)) { [EOL]                     return Float.POSITIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]             case 'N': [EOL]                 if ("NaN".equals(text)) { [EOL]                     return Float.NaN; [EOL]                 } [EOL]                 break; [EOL]             case '-': [EOL]                 if ("-Infinity".equals(text) || "-INF".equals(text)) { [EOL]                     return Float.NEGATIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         try { [EOL]             return Float.parseFloat(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "not a valid Float value"); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Float) getNullValue(); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final Float _parseFloat(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getFloatValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if (text.length() == 0) { [EOL]             return (Float) getEmptyValue(); [EOL]         } [EOL]         switch(text.charAt(0)) { [EOL]             case 'I': [EOL]                 if ("Infinity".equals(text) || "INF".equals(text)) { [EOL]                     return Float.POSITIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]             case 'N': [EOL]                 if ("NaN".equals(text)) { [EOL]                     return Float.NaN; [EOL]                 } [EOL]                 break; [EOL]             case '-': [EOL]                 if ("-Infinity".equals(text) || "-INF".equals(text)) { [EOL]                     return Float.NEGATIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         try { [EOL]             return Float.parseFloat(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "not a valid Float value"); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Float) getNullValue(); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final Float _parseFloat(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getFloatValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if (text.length() == 0) { [EOL]             return (Float) getEmptyValue(); [EOL]         } [EOL]         switch(text.charAt(0)) { [EOL]             case 'I': [EOL]                 if ("Infinity".equals(text) || "INF".equals(text)) { [EOL]                     return Float.POSITIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]             case 'N': [EOL]                 if ("NaN".equals(text)) { [EOL]                     return Float.NaN; [EOL]                 } [EOL]                 break; [EOL]             case '-': [EOL]                 if ("-Infinity".equals(text) || "-INF".equals(text)) { [EOL]                     return Float.NEGATIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         try { [EOL]             return Float.parseFloat(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "not a valid Float value"); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Float) getNullValue(); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final Float _parseFloat(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getFloatValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if (text.length() == 0) { [EOL]             return (Float) getEmptyValue(); [EOL]         } [EOL]         switch(text.charAt(0)) { [EOL]             case 'I': [EOL]                 if ("Infinity".equals(text) || "INF".equals(text)) { [EOL]                     return Float.POSITIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]             case 'N': [EOL]                 if ("NaN".equals(text)) { [EOL]                     return Float.NaN; [EOL]                 } [EOL]                 break; [EOL]             case '-': [EOL]                 if ("-Infinity".equals(text) || "-INF".equals(text)) { [EOL]                     return Float.NEGATIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         try { [EOL]             return Float.parseFloat(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "not a valid Float value"); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Float) getNullValue(); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final Float _parseFloat(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getFloatValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if (text.length() == 0) { [EOL]             return (Float) getEmptyValue(); [EOL]         } [EOL]         switch(text.charAt(0)) { [EOL]             case 'I': [EOL]                 if ("Infinity".equals(text) || "INF".equals(text)) { [EOL]                     return Float.POSITIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]             case 'N': [EOL]                 if ("NaN".equals(text)) { [EOL]                     return Float.NaN; [EOL]                 } [EOL]                 break; [EOL]             case '-': [EOL]                 if ("-Infinity".equals(text) || "-INF".equals(text)) { [EOL]                     return Float.NEGATIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         try { [EOL]             return Float.parseFloat(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "not a valid Float value"); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Float) getNullValue(); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final Float _parseFloat(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getFloatValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if (text.length() == 0) { [EOL]             return (Float) getEmptyValue(); [EOL]         } [EOL]         switch(text.charAt(0)) { [EOL]             case 'I': [EOL]                 if ("Infinity".equals(text) || "INF".equals(text)) { [EOL]                     return Float.POSITIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]             case 'N': [EOL]                 if ("NaN".equals(text)) { [EOL]                     return Float.NaN; [EOL]                 } [EOL]                 break; [EOL]             case '-': [EOL]                 if ("-Infinity".equals(text) || "-INF".equals(text)) { [EOL]                     return Float.NEGATIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         try { [EOL]             return Float.parseFloat(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "not a valid Float value"); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Float) getNullValue(); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final Double _parseDouble(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getDoubleValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if (text.length() == 0) { [EOL]             return (Double) getEmptyValue(); [EOL]         } [EOL]         switch(text.charAt(0)) { [EOL]             case 'I': [EOL]                 if ("Infinity".equals(text) || "INF".equals(text)) { [EOL]                     return Double.POSITIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]             case 'N': [EOL]                 if ("NaN".equals(text)) { [EOL]                     return Double.NaN; [EOL]                 } [EOL]                 break; [EOL]             case '-': [EOL]                 if ("-Infinity".equals(text) || "-INF".equals(text)) { [EOL]                     return Double.NEGATIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         try { [EOL]             return parseDouble(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "not a valid Double value"); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Double) getNullValue(); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final Double _parseDouble(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getDoubleValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if (text.length() == 0) { [EOL]             return (Double) getEmptyValue(); [EOL]         } [EOL]         switch(text.charAt(0)) { [EOL]             case 'I': [EOL]                 if ("Infinity".equals(text) || "INF".equals(text)) { [EOL]                     return Double.POSITIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]             case 'N': [EOL]                 if ("NaN".equals(text)) { [EOL]                     return Double.NaN; [EOL]                 } [EOL]                 break; [EOL]             case '-': [EOL]                 if ("-Infinity".equals(text) || "-INF".equals(text)) { [EOL]                     return Double.NEGATIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         try { [EOL]             return parseDouble(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "not a valid Double value"); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Double) getNullValue(); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final Double _parseDouble(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getDoubleValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if (text.length() == 0) { [EOL]             return (Double) getEmptyValue(); [EOL]         } [EOL]         switch(text.charAt(0)) { [EOL]             case 'I': [EOL]                 if ("Infinity".equals(text) || "INF".equals(text)) { [EOL]                     return Double.POSITIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]             case 'N': [EOL]                 if ("NaN".equals(text)) { [EOL]                     return Double.NaN; [EOL]                 } [EOL]                 break; [EOL]             case '-': [EOL]                 if ("-Infinity".equals(text) || "-INF".equals(text)) { [EOL]                     return Double.NEGATIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         try { [EOL]             return parseDouble(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "not a valid Double value"); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Double) getNullValue(); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final Double _parseDouble(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getDoubleValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if (text.length() == 0) { [EOL]             return (Double) getEmptyValue(); [EOL]         } [EOL]         switch(text.charAt(0)) { [EOL]             case 'I': [EOL]                 if ("Infinity".equals(text) || "INF".equals(text)) { [EOL]                     return Double.POSITIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]             case 'N': [EOL]                 if ("NaN".equals(text)) { [EOL]                     return Double.NaN; [EOL]                 } [EOL]                 break; [EOL]             case '-': [EOL]                 if ("-Infinity".equals(text) || "-INF".equals(text)) { [EOL]                     return Double.NEGATIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         try { [EOL]             return parseDouble(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "not a valid Double value"); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Double) getNullValue(); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final Double _parseDouble(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getDoubleValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if (text.length() == 0) { [EOL]             return (Double) getEmptyValue(); [EOL]         } [EOL]         switch(text.charAt(0)) { [EOL]             case 'I': [EOL]                 if ("Infinity".equals(text) || "INF".equals(text)) { [EOL]                     return Double.POSITIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]             case 'N': [EOL]                 if ("NaN".equals(text)) { [EOL]                     return Double.NaN; [EOL]                 } [EOL]                 break; [EOL]             case '-': [EOL]                 if ("-Infinity".equals(text) || "-INF".equals(text)) { [EOL]                     return Double.NEGATIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         try { [EOL]             return parseDouble(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "not a valid Double value"); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Double) getNullValue(); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final Double _parseDouble(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getDoubleValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if (text.length() == 0) { [EOL]             return (Double) getEmptyValue(); [EOL]         } [EOL]         switch(text.charAt(0)) { [EOL]             case 'I': [EOL]                 if ("Infinity".equals(text) || "INF".equals(text)) { [EOL]                     return Double.POSITIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]             case 'N': [EOL]                 if ("NaN".equals(text)) { [EOL]                     return Double.NaN; [EOL]                 } [EOL]                 break; [EOL]             case '-': [EOL]                 if ("-Infinity".equals(text) || "-INF".equals(text)) { [EOL]                     return Double.NEGATIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         try { [EOL]             return parseDouble(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "not a valid Double value"); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Double) getNullValue(); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final Double _parseDouble(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getDoubleValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if (text.length() == 0) { [EOL]             return (Double) getEmptyValue(); [EOL]         } [EOL]         switch(text.charAt(0)) { [EOL]             case 'I': [EOL]                 if ("Infinity".equals(text) || "INF".equals(text)) { [EOL]                     return Double.POSITIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]             case 'N': [EOL]                 if ("NaN".equals(text)) { [EOL]                     return Double.NaN; [EOL]                 } [EOL]                 break; [EOL]             case '-': [EOL]                 if ("-Infinity".equals(text) || "-INF".equals(text)) { [EOL]                     return Double.NEGATIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         try { [EOL]             return parseDouble(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "not a valid Double value"); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Double) getNullValue(); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final Double _parseDouble(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getDoubleValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if (text.length() == 0) { [EOL]             return (Double) getEmptyValue(); [EOL]         } [EOL]         switch(text.charAt(0)) { [EOL]             case 'I': [EOL]                 if ("Infinity".equals(text) || "INF".equals(text)) { [EOL]                     return Double.POSITIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]             case 'N': [EOL]                 if ("NaN".equals(text)) { [EOL]                     return Double.NaN; [EOL]                 } [EOL]                 break; [EOL]             case '-': [EOL]                 if ("-Infinity".equals(text) || "-INF".equals(text)) { [EOL]                     return Double.NEGATIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         try { [EOL]             return parseDouble(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "not a valid Double value"); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Double) getNullValue(); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final Double _parseDouble(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getDoubleValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if (text.length() == 0) { [EOL]             return (Double) getEmptyValue(); [EOL]         } [EOL]         switch(text.charAt(0)) { [EOL]             case 'I': [EOL]                 if ("Infinity".equals(text) || "INF".equals(text)) { [EOL]                     return Double.POSITIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]             case 'N': [EOL]                 if ("NaN".equals(text)) { [EOL]                     return Double.NaN; [EOL]                 } [EOL]                 break; [EOL]             case '-': [EOL]                 if ("-Infinity".equals(text) || "-INF".equals(text)) { [EOL]                     return Double.NEGATIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         try { [EOL]             return parseDouble(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "not a valid Double value"); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Double) getNullValue(); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final double _parseDoublePrimitive(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getDoubleValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if (text.length() == 0) { [EOL]             return 0.0; [EOL]         } [EOL]         switch(text.charAt(0)) { [EOL]             case 'I': [EOL]                 if ("Infinity".equals(text) || "INF".equals(text)) { [EOL]                     return Double.POSITIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]             case 'N': [EOL]                 if ("NaN".equals(text)) { [EOL]                     return Double.NaN; [EOL]                 } [EOL]                 break; [EOL]             case '-': [EOL]                 if ("-Infinity".equals(text) || "-INF".equals(text)) { [EOL]                     return Double.NEGATIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         try { [EOL]             return parseDouble(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "not a valid double value"); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return 0.0; [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected java.util.Date _parseDate(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         return new java.util.Date(jp.getLongValue()); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (java.util.Date) getNullValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String value = null; [EOL]         try { [EOL]             value = jp.getText().trim(); [EOL]             if (value.length() == 0) { [EOL]                 return (Date) getEmptyValue(); [EOL]             } [EOL]             return ctxt.parseDate(value); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw ctxt.weirdStringException(value, _valueClass, "not a valid representation (error: " + iae.getMessage() + ")"); [EOL]         } [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected java.util.Date _parseDate(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         return new java.util.Date(jp.getLongValue()); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (java.util.Date) getNullValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String value = null; [EOL]         try { [EOL]             value = jp.getText().trim(); [EOL]             if (value.length() == 0) { [EOL]                 return (Date) getEmptyValue(); [EOL]             } [EOL]             return ctxt.parseDate(value); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw ctxt.weirdStringException(value, _valueClass, "not a valid representation (error: " + iae.getMessage() + ")"); [EOL]         } [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected java.util.Date _parseDate(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         return new java.util.Date(jp.getLongValue()); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (java.util.Date) getNullValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String value = null; [EOL]         try { [EOL]             value = jp.getText().trim(); [EOL]             if (value.length() == 0) { [EOL]                 return (Date) getEmptyValue(); [EOL]             } [EOL]             return ctxt.parseDate(value); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw ctxt.weirdStringException(value, _valueClass, "not a valid representation (error: " + iae.getMessage() + ")"); [EOL]         } [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected java.util.Date _parseDate(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         return new java.util.Date(jp.getLongValue()); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (java.util.Date) getNullValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String value = null; [EOL]         try { [EOL]             value = jp.getText().trim(); [EOL]             if (value.length() == 0) { [EOL]                 return (Date) getEmptyValue(); [EOL]             } [EOL]             return ctxt.parseDate(value); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw ctxt.weirdStringException(value, _valueClass, "not a valid representation (error: " + iae.getMessage() + ")"); [EOL]         } [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected java.util.Date _parseDate(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         return new java.util.Date(jp.getLongValue()); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (java.util.Date) getNullValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String value = null; [EOL]         try { [EOL]             value = jp.getText().trim(); [EOL]             if (value.length() == 0) { [EOL]                 return (Date) getEmptyValue(); [EOL]             } [EOL]             return ctxt.parseDate(value); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw ctxt.weirdStringException(value, _valueClass, "not a valid representation (error: " + iae.getMessage() + ")"); [EOL]         } [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected java.util.Date _parseDate(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         return new java.util.Date(jp.getLongValue()); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (java.util.Date) getNullValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String value = null; [EOL]         try { [EOL]             value = jp.getText().trim(); [EOL]             if (value.length() == 0) { [EOL]                 return (Date) getEmptyValue(); [EOL]             } [EOL]             return ctxt.parseDate(value); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw ctxt.weirdStringException(value, _valueClass, "not a valid representation (error: " + iae.getMessage() + ")"); [EOL]         } [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected JsonDeserializer<?> findConvertingContentDeserializer(DeserializationContext ctxt, BeanProperty prop, JsonDeserializer<?> existingDeserializer) throws JsonMappingException { [EOL]     final AnnotationIntrospector intr = ctxt.getAnnotationIntrospector(); [EOL]     if (intr != null && prop != null) { [EOL]         Object convDef = intr.findDeserializationContentConverter(prop.getMember()); [EOL]         if (convDef != null) { [EOL]             Converter<Object, Object> conv = ctxt.converterInstance(prop.getMember(), convDef); [EOL]             JavaType delegateType = conv.getInputType(ctxt.getTypeFactory()); [EOL]             if (existingDeserializer == null) { [EOL]                 existingDeserializer = ctxt.findContextualValueDeserializer(delegateType, prop); [EOL]             } [EOL]             return new StdDelegatingDeserializer<Object>(conv, delegateType, existingDeserializer); [EOL]         } [EOL]     } [EOL]     return existingDeserializer; [EOL] }
protected JsonDeserializer<?> findConvertingContentDeserializer(DeserializationContext ctxt, BeanProperty prop, JsonDeserializer<?> existingDeserializer) throws JsonMappingException { [EOL]     final AnnotationIntrospector intr = ctxt.getAnnotationIntrospector(); [EOL]     if (intr != null && prop != null) { [EOL]         Object convDef = intr.findDeserializationContentConverter(prop.getMember()); [EOL]         if (convDef != null) { [EOL]             Converter<Object, Object> conv = ctxt.converterInstance(prop.getMember(), convDef); [EOL]             JavaType delegateType = conv.getInputType(ctxt.getTypeFactory()); [EOL]             if (existingDeserializer == null) { [EOL]                 existingDeserializer = ctxt.findContextualValueDeserializer(delegateType, prop); [EOL]             } [EOL]             return new StdDelegatingDeserializer<Object>(conv, delegateType, existingDeserializer); [EOL]         } [EOL]     } [EOL]     return existingDeserializer; [EOL] }
protected JsonDeserializer<?> findConvertingContentDeserializer(DeserializationContext ctxt, BeanProperty prop, JsonDeserializer<?> existingDeserializer) throws JsonMappingException { [EOL]     final AnnotationIntrospector intr = ctxt.getAnnotationIntrospector(); [EOL]     if (intr != null && prop != null) { [EOL]         Object convDef = intr.findDeserializationContentConverter(prop.getMember()); [EOL]         if (convDef != null) { [EOL]             Converter<Object, Object> conv = ctxt.converterInstance(prop.getMember(), convDef); [EOL]             JavaType delegateType = conv.getInputType(ctxt.getTypeFactory()); [EOL]             if (existingDeserializer == null) { [EOL]                 existingDeserializer = ctxt.findContextualValueDeserializer(delegateType, prop); [EOL]             } [EOL]             return new StdDelegatingDeserializer<Object>(conv, delegateType, existingDeserializer); [EOL]         } [EOL]     } [EOL]     return existingDeserializer; [EOL] }
protected JsonDeserializer<?> findConvertingContentDeserializer(DeserializationContext ctxt, BeanProperty prop, JsonDeserializer<?> existingDeserializer) throws JsonMappingException { [EOL]     final AnnotationIntrospector intr = ctxt.getAnnotationIntrospector(); [EOL]     if (intr != null && prop != null) { [EOL]         Object convDef = intr.findDeserializationContentConverter(prop.getMember()); [EOL]         if (convDef != null) { [EOL]             Converter<Object, Object> conv = ctxt.converterInstance(prop.getMember(), convDef); [EOL]             JavaType delegateType = conv.getInputType(ctxt.getTypeFactory()); [EOL]             if (existingDeserializer == null) { [EOL]                 existingDeserializer = ctxt.findContextualValueDeserializer(delegateType, prop); [EOL]             } [EOL]             return new StdDelegatingDeserializer<Object>(conv, delegateType, existingDeserializer); [EOL]         } [EOL]     } [EOL]     return existingDeserializer; [EOL] }
protected JsonDeserializer<?> findConvertingContentDeserializer(DeserializationContext ctxt, BeanProperty prop, JsonDeserializer<?> existingDeserializer) throws JsonMappingException { [EOL]     final AnnotationIntrospector intr = ctxt.getAnnotationIntrospector(); [EOL]     if (intr != null && prop != null) { [EOL]         Object convDef = intr.findDeserializationContentConverter(prop.getMember()); [EOL]         if (convDef != null) { [EOL]             Converter<Object, Object> conv = ctxt.converterInstance(prop.getMember(), convDef); [EOL]             JavaType delegateType = conv.getInputType(ctxt.getTypeFactory()); [EOL]             if (existingDeserializer == null) { [EOL]                 existingDeserializer = ctxt.findContextualValueDeserializer(delegateType, prop); [EOL]             } [EOL]             return new StdDelegatingDeserializer<Object>(conv, delegateType, existingDeserializer); [EOL]         } [EOL]     } [EOL]     return existingDeserializer; [EOL] }
@Override [EOL] public final JsonNodeType getNodeType() { [EOL]     return JsonNodeType.NUMBER; [EOL] }
@Override [EOL] public final int asInt() { [EOL]     return intValue(); [EOL] }
@Override [EOL] public final int asInt(int defaultValue) { [EOL]     return intValue(); [EOL] }
@Override [EOL] public final int asInt(int defaultValue) { [EOL]     return intValue(); [EOL] }
@Override [EOL] public final long asLong() { [EOL]     return longValue(); [EOL] }
@Override [EOL] public final long asLong() { [EOL]     return longValue(); [EOL] }
@Override [EOL] public final long asLong() { [EOL]     return longValue(); [EOL] }
@Override [EOL] public final long asLong(long defaultValue) { [EOL]     return longValue(); [EOL] }
@Override [EOL] public final long asLong(long defaultValue) { [EOL]     return longValue(); [EOL] }
@Override [EOL] public final double asDouble() { [EOL]     return doubleValue(); [EOL] }
@Override [EOL] public final double asDouble() { [EOL]     return doubleValue(); [EOL] }
@Override [EOL] public final double asDouble() { [EOL]     return doubleValue(); [EOL] }
@Override [EOL] public final double asDouble(double defaultValue) { [EOL]     return doubleValue(); [EOL] }
@Override [EOL] public final double asDouble(double defaultValue) { [EOL]     return doubleValue(); [EOL] }
private SerializationConfig(SerializationConfig src, JsonInclude.Include incl) { [EOL]     super(src); [EOL]     _serFeatures = src._serFeatures; [EOL]     _serializationInclusion = incl; [EOL]     _filterProvider = src._filterProvider; [EOL] }
private SerializationConfig(SerializationConfig src, JsonInclude.Include incl) { [EOL]     super(src); [EOL]     _serFeatures = src._serFeatures; [EOL]     _serializationInclusion = incl; [EOL]     _filterProvider = src._filterProvider; [EOL] }
@Override [EOL] public SerializationConfig with(MapperFeature... features) { [EOL]     int newMapperFlags = _mapperFeatures; [EOL]     for (MapperFeature f : features) { [EOL]         newMapperFlags |= f.getMask(); [EOL]     } [EOL]     return (newMapperFlags == _mapperFeatures) ? this : new SerializationConfig(this, newMapperFlags, _serFeatures); [EOL] }
@Override [EOL] public SerializationConfig with(MapperFeature... features) { [EOL]     int newMapperFlags = _mapperFeatures; [EOL]     for (MapperFeature f : features) { [EOL]         newMapperFlags |= f.getMask(); [EOL]     } [EOL]     return (newMapperFlags == _mapperFeatures) ? this : new SerializationConfig(this, newMapperFlags, _serFeatures); [EOL] }
@Override [EOL] public SerializationConfig with(MapperFeature... features) { [EOL]     int newMapperFlags = _mapperFeatures; [EOL]     for (MapperFeature f : features) { [EOL]         newMapperFlags |= f.getMask(); [EOL]     } [EOL]     return (newMapperFlags == _mapperFeatures) ? this : new SerializationConfig(this, newMapperFlags, _serFeatures); [EOL] }
@Override [EOL] public SerializationConfig with(DateFormat df) { [EOL]     SerializationConfig cfg = new SerializationConfig(this, _base.withDateFormat(df)); [EOL]     if (df == null) { [EOL]         cfg = cfg.with(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS); [EOL]     } else { [EOL]         cfg = cfg.without(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS); [EOL]     } [EOL]     return cfg; [EOL] }
@Override [EOL] public SerializationConfig with(DateFormat df) { [EOL]     SerializationConfig cfg = new SerializationConfig(this, _base.withDateFormat(df)); [EOL]     if (df == null) { [EOL]         cfg = cfg.with(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS); [EOL]     } else { [EOL]         cfg = cfg.without(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS); [EOL]     } [EOL]     return cfg; [EOL] }
public SerializationConfig without(SerializationFeature feature) { [EOL]     int newSerFeatures = _serFeatures & ~feature.getMask(); [EOL]     return (newSerFeatures == _serFeatures) ? this : new SerializationConfig(this, _mapperFeatures, newSerFeatures); [EOL] }
public SerializationConfig without(SerializationFeature feature) { [EOL]     int newSerFeatures = _serFeatures & ~feature.getMask(); [EOL]     return (newSerFeatures == _serFeatures) ? this : new SerializationConfig(this, _mapperFeatures, newSerFeatures); [EOL] }
public SerializationConfig withSerializationInclusion(JsonInclude.Include incl) { [EOL]     return (_serializationInclusion == incl) ? this : new SerializationConfig(this, incl); [EOL] }
public SerializationConfig withSerializationInclusion(JsonInclude.Include incl) { [EOL]     return (_serializationInclusion == incl) ? this : new SerializationConfig(this, incl); [EOL] }
public JsonInclude.Include getSerializationInclusion() { [EOL]     if (_serializationInclusion != null) { [EOL]         return _serializationInclusion; [EOL]     } [EOL]     return JsonInclude.Include.ALWAYS; [EOL] }
public JsonInclude.Include getSerializationInclusion() { [EOL]     if (_serializationInclusion != null) { [EOL]         return _serializationInclusion; [EOL]     } [EOL]     return JsonInclude.Include.ALWAYS; [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (!_classNames.contains(clsName)) { [EOL]         return null; [EOL]     } [EOL]     if (rawType == URI.class) { [EOL]         return URIDeserializer.instance; [EOL]     } [EOL]     if (rawType == URL.class) { [EOL]         return URLDeserializer.instance; [EOL]     } [EOL]     if (rawType == File.class) { [EOL]         return FileDeserializer.instance; [EOL]     } [EOL]     if (rawType == UUID.class) { [EOL]         return UUIDDeserializer.instance; [EOL]     } [EOL]     if (rawType == Currency.class) { [EOL]         return CurrencyDeserializer.instance; [EOL]     } [EOL]     if (rawType == Pattern.class) { [EOL]         return PatternDeserializer.instance; [EOL]     } [EOL]     if (rawType == Locale.class) { [EOL]         return LocaleDeserializer.instance; [EOL]     } [EOL]     if (rawType == InetAddress.class) { [EOL]         return InetAddressDeserializer.instance; [EOL]     } [EOL]     if (rawType == Charset.class) { [EOL]         return CharsetDeserializer.instance; [EOL]     } [EOL]     if (rawType == Class.class) { [EOL]         return ClassDeserializer.instance; [EOL]     } [EOL]     if (rawType == StackTraceElement.class) { [EOL]         return StackTraceElementDeserializer.instance; [EOL]     } [EOL]     if (rawType == AtomicBoolean.class) { [EOL]         return AtomicBooleanDeserializer.instance; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + clsName); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (!_classNames.contains(clsName)) { [EOL]         return null; [EOL]     } [EOL]     if (rawType == URI.class) { [EOL]         return URIDeserializer.instance; [EOL]     } [EOL]     if (rawType == URL.class) { [EOL]         return URLDeserializer.instance; [EOL]     } [EOL]     if (rawType == File.class) { [EOL]         return FileDeserializer.instance; [EOL]     } [EOL]     if (rawType == UUID.class) { [EOL]         return UUIDDeserializer.instance; [EOL]     } [EOL]     if (rawType == Currency.class) { [EOL]         return CurrencyDeserializer.instance; [EOL]     } [EOL]     if (rawType == Pattern.class) { [EOL]         return PatternDeserializer.instance; [EOL]     } [EOL]     if (rawType == Locale.class) { [EOL]         return LocaleDeserializer.instance; [EOL]     } [EOL]     if (rawType == InetAddress.class) { [EOL]         return InetAddressDeserializer.instance; [EOL]     } [EOL]     if (rawType == Charset.class) { [EOL]         return CharsetDeserializer.instance; [EOL]     } [EOL]     if (rawType == Class.class) { [EOL]         return ClassDeserializer.instance; [EOL]     } [EOL]     if (rawType == StackTraceElement.class) { [EOL]         return StackTraceElementDeserializer.instance; [EOL]     } [EOL]     if (rawType == AtomicBoolean.class) { [EOL]         return AtomicBooleanDeserializer.instance; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + clsName); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (!_classNames.contains(clsName)) { [EOL]         return null; [EOL]     } [EOL]     if (rawType == URI.class) { [EOL]         return URIDeserializer.instance; [EOL]     } [EOL]     if (rawType == URL.class) { [EOL]         return URLDeserializer.instance; [EOL]     } [EOL]     if (rawType == File.class) { [EOL]         return FileDeserializer.instance; [EOL]     } [EOL]     if (rawType == UUID.class) { [EOL]         return UUIDDeserializer.instance; [EOL]     } [EOL]     if (rawType == Currency.class) { [EOL]         return CurrencyDeserializer.instance; [EOL]     } [EOL]     if (rawType == Pattern.class) { [EOL]         return PatternDeserializer.instance; [EOL]     } [EOL]     if (rawType == Locale.class) { [EOL]         return LocaleDeserializer.instance; [EOL]     } [EOL]     if (rawType == InetAddress.class) { [EOL]         return InetAddressDeserializer.instance; [EOL]     } [EOL]     if (rawType == Charset.class) { [EOL]         return CharsetDeserializer.instance; [EOL]     } [EOL]     if (rawType == Class.class) { [EOL]         return ClassDeserializer.instance; [EOL]     } [EOL]     if (rawType == StackTraceElement.class) { [EOL]         return StackTraceElementDeserializer.instance; [EOL]     } [EOL]     if (rawType == AtomicBoolean.class) { [EOL]         return AtomicBooleanDeserializer.instance; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + clsName); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (!_classNames.contains(clsName)) { [EOL]         return null; [EOL]     } [EOL]     if (rawType == URI.class) { [EOL]         return URIDeserializer.instance; [EOL]     } [EOL]     if (rawType == URL.class) { [EOL]         return URLDeserializer.instance; [EOL]     } [EOL]     if (rawType == File.class) { [EOL]         return FileDeserializer.instance; [EOL]     } [EOL]     if (rawType == UUID.class) { [EOL]         return UUIDDeserializer.instance; [EOL]     } [EOL]     if (rawType == Currency.class) { [EOL]         return CurrencyDeserializer.instance; [EOL]     } [EOL]     if (rawType == Pattern.class) { [EOL]         return PatternDeserializer.instance; [EOL]     } [EOL]     if (rawType == Locale.class) { [EOL]         return LocaleDeserializer.instance; [EOL]     } [EOL]     if (rawType == InetAddress.class) { [EOL]         return InetAddressDeserializer.instance; [EOL]     } [EOL]     if (rawType == Charset.class) { [EOL]         return CharsetDeserializer.instance; [EOL]     } [EOL]     if (rawType == Class.class) { [EOL]         return ClassDeserializer.instance; [EOL]     } [EOL]     if (rawType == StackTraceElement.class) { [EOL]         return StackTraceElementDeserializer.instance; [EOL]     } [EOL]     if (rawType == AtomicBoolean.class) { [EOL]         return AtomicBooleanDeserializer.instance; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + clsName); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (!_classNames.contains(clsName)) { [EOL]         return null; [EOL]     } [EOL]     if (rawType == URI.class) { [EOL]         return URIDeserializer.instance; [EOL]     } [EOL]     if (rawType == URL.class) { [EOL]         return URLDeserializer.instance; [EOL]     } [EOL]     if (rawType == File.class) { [EOL]         return FileDeserializer.instance; [EOL]     } [EOL]     if (rawType == UUID.class) { [EOL]         return UUIDDeserializer.instance; [EOL]     } [EOL]     if (rawType == Currency.class) { [EOL]         return CurrencyDeserializer.instance; [EOL]     } [EOL]     if (rawType == Pattern.class) { [EOL]         return PatternDeserializer.instance; [EOL]     } [EOL]     if (rawType == Locale.class) { [EOL]         return LocaleDeserializer.instance; [EOL]     } [EOL]     if (rawType == InetAddress.class) { [EOL]         return InetAddressDeserializer.instance; [EOL]     } [EOL]     if (rawType == Charset.class) { [EOL]         return CharsetDeserializer.instance; [EOL]     } [EOL]     if (rawType == Class.class) { [EOL]         return ClassDeserializer.instance; [EOL]     } [EOL]     if (rawType == StackTraceElement.class) { [EOL]         return StackTraceElementDeserializer.instance; [EOL]     } [EOL]     if (rawType == AtomicBoolean.class) { [EOL]         return AtomicBooleanDeserializer.instance; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + clsName); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (!_classNames.contains(clsName)) { [EOL]         return null; [EOL]     } [EOL]     if (rawType == URI.class) { [EOL]         return URIDeserializer.instance; [EOL]     } [EOL]     if (rawType == URL.class) { [EOL]         return URLDeserializer.instance; [EOL]     } [EOL]     if (rawType == File.class) { [EOL]         return FileDeserializer.instance; [EOL]     } [EOL]     if (rawType == UUID.class) { [EOL]         return UUIDDeserializer.instance; [EOL]     } [EOL]     if (rawType == Currency.class) { [EOL]         return CurrencyDeserializer.instance; [EOL]     } [EOL]     if (rawType == Pattern.class) { [EOL]         return PatternDeserializer.instance; [EOL]     } [EOL]     if (rawType == Locale.class) { [EOL]         return LocaleDeserializer.instance; [EOL]     } [EOL]     if (rawType == InetAddress.class) { [EOL]         return InetAddressDeserializer.instance; [EOL]     } [EOL]     if (rawType == Charset.class) { [EOL]         return CharsetDeserializer.instance; [EOL]     } [EOL]     if (rawType == Class.class) { [EOL]         return ClassDeserializer.instance; [EOL]     } [EOL]     if (rawType == StackTraceElement.class) { [EOL]         return StackTraceElementDeserializer.instance; [EOL]     } [EOL]     if (rawType == AtomicBoolean.class) { [EOL]         return AtomicBooleanDeserializer.instance; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + clsName); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (!_classNames.contains(clsName)) { [EOL]         return null; [EOL]     } [EOL]     if (rawType == URI.class) { [EOL]         return URIDeserializer.instance; [EOL]     } [EOL]     if (rawType == URL.class) { [EOL]         return URLDeserializer.instance; [EOL]     } [EOL]     if (rawType == File.class) { [EOL]         return FileDeserializer.instance; [EOL]     } [EOL]     if (rawType == UUID.class) { [EOL]         return UUIDDeserializer.instance; [EOL]     } [EOL]     if (rawType == Currency.class) { [EOL]         return CurrencyDeserializer.instance; [EOL]     } [EOL]     if (rawType == Pattern.class) { [EOL]         return PatternDeserializer.instance; [EOL]     } [EOL]     if (rawType == Locale.class) { [EOL]         return LocaleDeserializer.instance; [EOL]     } [EOL]     if (rawType == InetAddress.class) { [EOL]         return InetAddressDeserializer.instance; [EOL]     } [EOL]     if (rawType == Charset.class) { [EOL]         return CharsetDeserializer.instance; [EOL]     } [EOL]     if (rawType == Class.class) { [EOL]         return ClassDeserializer.instance; [EOL]     } [EOL]     if (rawType == StackTraceElement.class) { [EOL]         return StackTraceElementDeserializer.instance; [EOL]     } [EOL]     if (rawType == AtomicBoolean.class) { [EOL]         return AtomicBooleanDeserializer.instance; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + clsName); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (!_classNames.contains(clsName)) { [EOL]         return null; [EOL]     } [EOL]     if (rawType == URI.class) { [EOL]         return URIDeserializer.instance; [EOL]     } [EOL]     if (rawType == URL.class) { [EOL]         return URLDeserializer.instance; [EOL]     } [EOL]     if (rawType == File.class) { [EOL]         return FileDeserializer.instance; [EOL]     } [EOL]     if (rawType == UUID.class) { [EOL]         return UUIDDeserializer.instance; [EOL]     } [EOL]     if (rawType == Currency.class) { [EOL]         return CurrencyDeserializer.instance; [EOL]     } [EOL]     if (rawType == Pattern.class) { [EOL]         return PatternDeserializer.instance; [EOL]     } [EOL]     if (rawType == Locale.class) { [EOL]         return LocaleDeserializer.instance; [EOL]     } [EOL]     if (rawType == InetAddress.class) { [EOL]         return InetAddressDeserializer.instance; [EOL]     } [EOL]     if (rawType == Charset.class) { [EOL]         return CharsetDeserializer.instance; [EOL]     } [EOL]     if (rawType == Class.class) { [EOL]         return ClassDeserializer.instance; [EOL]     } [EOL]     if (rawType == StackTraceElement.class) { [EOL]         return StackTraceElementDeserializer.instance; [EOL]     } [EOL]     if (rawType == AtomicBoolean.class) { [EOL]         return AtomicBooleanDeserializer.instance; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + clsName); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (!_classNames.contains(clsName)) { [EOL]         return null; [EOL]     } [EOL]     if (rawType == URI.class) { [EOL]         return URIDeserializer.instance; [EOL]     } [EOL]     if (rawType == URL.class) { [EOL]         return URLDeserializer.instance; [EOL]     } [EOL]     if (rawType == File.class) { [EOL]         return FileDeserializer.instance; [EOL]     } [EOL]     if (rawType == UUID.class) { [EOL]         return UUIDDeserializer.instance; [EOL]     } [EOL]     if (rawType == Currency.class) { [EOL]         return CurrencyDeserializer.instance; [EOL]     } [EOL]     if (rawType == Pattern.class) { [EOL]         return PatternDeserializer.instance; [EOL]     } [EOL]     if (rawType == Locale.class) { [EOL]         return LocaleDeserializer.instance; [EOL]     } [EOL]     if (rawType == InetAddress.class) { [EOL]         return InetAddressDeserializer.instance; [EOL]     } [EOL]     if (rawType == Charset.class) { [EOL]         return CharsetDeserializer.instance; [EOL]     } [EOL]     if (rawType == Class.class) { [EOL]         return ClassDeserializer.instance; [EOL]     } [EOL]     if (rawType == StackTraceElement.class) { [EOL]         return StackTraceElementDeserializer.instance; [EOL]     } [EOL]     if (rawType == AtomicBoolean.class) { [EOL]         return AtomicBooleanDeserializer.instance; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + clsName); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (!_classNames.contains(clsName)) { [EOL]         return null; [EOL]     } [EOL]     if (rawType == URI.class) { [EOL]         return URIDeserializer.instance; [EOL]     } [EOL]     if (rawType == URL.class) { [EOL]         return URLDeserializer.instance; [EOL]     } [EOL]     if (rawType == File.class) { [EOL]         return FileDeserializer.instance; [EOL]     } [EOL]     if (rawType == UUID.class) { [EOL]         return UUIDDeserializer.instance; [EOL]     } [EOL]     if (rawType == Currency.class) { [EOL]         return CurrencyDeserializer.instance; [EOL]     } [EOL]     if (rawType == Pattern.class) { [EOL]         return PatternDeserializer.instance; [EOL]     } [EOL]     if (rawType == Locale.class) { [EOL]         return LocaleDeserializer.instance; [EOL]     } [EOL]     if (rawType == InetAddress.class) { [EOL]         return InetAddressDeserializer.instance; [EOL]     } [EOL]     if (rawType == Charset.class) { [EOL]         return CharsetDeserializer.instance; [EOL]     } [EOL]     if (rawType == Class.class) { [EOL]         return ClassDeserializer.instance; [EOL]     } [EOL]     if (rawType == StackTraceElement.class) { [EOL]         return StackTraceElementDeserializer.instance; [EOL]     } [EOL]     if (rawType == AtomicBoolean.class) { [EOL]         return AtomicBooleanDeserializer.instance; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + clsName); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (!_classNames.contains(clsName)) { [EOL]         return null; [EOL]     } [EOL]     if (rawType == URI.class) { [EOL]         return URIDeserializer.instance; [EOL]     } [EOL]     if (rawType == URL.class) { [EOL]         return URLDeserializer.instance; [EOL]     } [EOL]     if (rawType == File.class) { [EOL]         return FileDeserializer.instance; [EOL]     } [EOL]     if (rawType == UUID.class) { [EOL]         return UUIDDeserializer.instance; [EOL]     } [EOL]     if (rawType == Currency.class) { [EOL]         return CurrencyDeserializer.instance; [EOL]     } [EOL]     if (rawType == Pattern.class) { [EOL]         return PatternDeserializer.instance; [EOL]     } [EOL]     if (rawType == Locale.class) { [EOL]         return LocaleDeserializer.instance; [EOL]     } [EOL]     if (rawType == InetAddress.class) { [EOL]         return InetAddressDeserializer.instance; [EOL]     } [EOL]     if (rawType == Charset.class) { [EOL]         return CharsetDeserializer.instance; [EOL]     } [EOL]     if (rawType == Class.class) { [EOL]         return ClassDeserializer.instance; [EOL]     } [EOL]     if (rawType == StackTraceElement.class) { [EOL]         return StackTraceElementDeserializer.instance; [EOL]     } [EOL]     if (rawType == AtomicBoolean.class) { [EOL]         return AtomicBooleanDeserializer.instance; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + clsName); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (!_classNames.contains(clsName)) { [EOL]         return null; [EOL]     } [EOL]     if (rawType == URI.class) { [EOL]         return URIDeserializer.instance; [EOL]     } [EOL]     if (rawType == URL.class) { [EOL]         return URLDeserializer.instance; [EOL]     } [EOL]     if (rawType == File.class) { [EOL]         return FileDeserializer.instance; [EOL]     } [EOL]     if (rawType == UUID.class) { [EOL]         return UUIDDeserializer.instance; [EOL]     } [EOL]     if (rawType == Currency.class) { [EOL]         return CurrencyDeserializer.instance; [EOL]     } [EOL]     if (rawType == Pattern.class) { [EOL]         return PatternDeserializer.instance; [EOL]     } [EOL]     if (rawType == Locale.class) { [EOL]         return LocaleDeserializer.instance; [EOL]     } [EOL]     if (rawType == InetAddress.class) { [EOL]         return InetAddressDeserializer.instance; [EOL]     } [EOL]     if (rawType == Charset.class) { [EOL]         return CharsetDeserializer.instance; [EOL]     } [EOL]     if (rawType == Class.class) { [EOL]         return ClassDeserializer.instance; [EOL]     } [EOL]     if (rawType == StackTraceElement.class) { [EOL]         return StackTraceElementDeserializer.instance; [EOL]     } [EOL]     if (rawType == AtomicBoolean.class) { [EOL]         return AtomicBooleanDeserializer.instance; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + clsName); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (!_classNames.contains(clsName)) { [EOL]         return null; [EOL]     } [EOL]     if (rawType == URI.class) { [EOL]         return URIDeserializer.instance; [EOL]     } [EOL]     if (rawType == URL.class) { [EOL]         return URLDeserializer.instance; [EOL]     } [EOL]     if (rawType == File.class) { [EOL]         return FileDeserializer.instance; [EOL]     } [EOL]     if (rawType == UUID.class) { [EOL]         return UUIDDeserializer.instance; [EOL]     } [EOL]     if (rawType == Currency.class) { [EOL]         return CurrencyDeserializer.instance; [EOL]     } [EOL]     if (rawType == Pattern.class) { [EOL]         return PatternDeserializer.instance; [EOL]     } [EOL]     if (rawType == Locale.class) { [EOL]         return LocaleDeserializer.instance; [EOL]     } [EOL]     if (rawType == InetAddress.class) { [EOL]         return InetAddressDeserializer.instance; [EOL]     } [EOL]     if (rawType == Charset.class) { [EOL]         return CharsetDeserializer.instance; [EOL]     } [EOL]     if (rawType == Class.class) { [EOL]         return ClassDeserializer.instance; [EOL]     } [EOL]     if (rawType == StackTraceElement.class) { [EOL]         return StackTraceElementDeserializer.instance; [EOL]     } [EOL]     if (rawType == AtomicBoolean.class) { [EOL]         return AtomicBooleanDeserializer.instance; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + clsName); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (!_classNames.contains(clsName)) { [EOL]         return null; [EOL]     } [EOL]     if (rawType == URI.class) { [EOL]         return URIDeserializer.instance; [EOL]     } [EOL]     if (rawType == URL.class) { [EOL]         return URLDeserializer.instance; [EOL]     } [EOL]     if (rawType == File.class) { [EOL]         return FileDeserializer.instance; [EOL]     } [EOL]     if (rawType == UUID.class) { [EOL]         return UUIDDeserializer.instance; [EOL]     } [EOL]     if (rawType == Currency.class) { [EOL]         return CurrencyDeserializer.instance; [EOL]     } [EOL]     if (rawType == Pattern.class) { [EOL]         return PatternDeserializer.instance; [EOL]     } [EOL]     if (rawType == Locale.class) { [EOL]         return LocaleDeserializer.instance; [EOL]     } [EOL]     if (rawType == InetAddress.class) { [EOL]         return InetAddressDeserializer.instance; [EOL]     } [EOL]     if (rawType == Charset.class) { [EOL]         return CharsetDeserializer.instance; [EOL]     } [EOL]     if (rawType == Class.class) { [EOL]         return ClassDeserializer.instance; [EOL]     } [EOL]     if (rawType == StackTraceElement.class) { [EOL]         return StackTraceElementDeserializer.instance; [EOL]     } [EOL]     if (rawType == AtomicBoolean.class) { [EOL]         return AtomicBooleanDeserializer.instance; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + clsName); [EOL] }
public AtomicReferenceDeserializer(JavaType referencedType) { [EOL]     this(referencedType, null); [EOL] }
public AtomicReferenceDeserializer(JavaType referencedType) { [EOL]     this(referencedType, null); [EOL] }
public AtomicReferenceDeserializer(JavaType referencedType, JsonDeserializer<?> deser) { [EOL]     super(AtomicReference.class); [EOL]     _referencedType = referencedType; [EOL]     _valueDeserializer = deser; [EOL] }
@Override [EOL] public AtomicReference<?> deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     return new AtomicReference<Object>(_valueDeserializer.deserialize(jp, ctxt)); [EOL] }
@Override [EOL] public AtomicReference<?> deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     return new AtomicReference<Object>(_valueDeserializer.deserialize(jp, ctxt)); [EOL] }
@Override [EOL] public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException { [EOL]     JsonDeserializer<?> deser = _valueDeserializer; [EOL]     if (deser != null) { [EOL]         return this; [EOL]     } [EOL]     return new AtomicReferenceDeserializer(_referencedType, ctxt.findContextualValueDeserializer(_referencedType, property)); [EOL] }
@Override [EOL] public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException { [EOL]     JsonDeserializer<?> deser = _valueDeserializer; [EOL]     if (deser != null) { [EOL]         return this; [EOL]     } [EOL]     return new AtomicReferenceDeserializer(_referencedType, ctxt.findContextualValueDeserializer(_referencedType, property)); [EOL] }
public StackTraceElementDeserializer() { [EOL]     super(StackTraceElement.class); [EOL] }
@Override [EOL] public AsPropertyTypeSerializer forProperty(BeanProperty prop) { [EOL]     if (_property == prop) [EOL]         return this; [EOL]     return new AsPropertyTypeSerializer(this._idResolver, prop, this._typePropertyName); [EOL] }
@Override [EOL] public AsPropertyTypeSerializer forProperty(BeanProperty prop) { [EOL]     if (_property == prop) [EOL]         return this; [EOL]     return new AsPropertyTypeSerializer(this._idResolver, prop, this._typePropertyName); [EOL] }
@Override [EOL] public void writeCustomTypePrefixForObject(Object value, JsonGenerator jgen, String typeId) throws IOException, JsonProcessingException { [EOL]     jgen.writeStartObject(); [EOL]     jgen.writeStringField(_typePropertyName, typeId); [EOL] }
@Override [EOL] public void writeCustomTypeSuffixForObject(Object value, JsonGenerator jgen, String typeId) throws IOException, JsonProcessingException { [EOL]     jgen.writeEndObject(); [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider prov, BeanProperty property) throws JsonMappingException { [EOL]     if (property != null) { [EOL]         JsonFormat.Value format = prov.getAnnotationIntrospector().findFormat((Annotated) property.getMember()); [EOL]         if (format != null) { [EOL]             if (format.getShape().isNumeric()) { [EOL]                 return withFormat(true, null); [EOL]             } [EOL]             TimeZone tz = format.getTimeZone(); [EOL]             String pattern = format.getPattern(); [EOL]             if (pattern.length() > 0) { [EOL]                 Locale loc = format.getLocale(); [EOL]                 if (loc == null) { [EOL]                     loc = prov.getLocale(); [EOL]                 } [EOL]                 SimpleDateFormat df = new SimpleDateFormat(pattern, loc); [EOL]                 if (tz == null) { [EOL]                     tz = prov.getTimeZone(); [EOL]                 } [EOL]                 df.setTimeZone(tz); [EOL]                 return withFormat(false, df); [EOL]             } [EOL]             if (tz != null) { [EOL]                 DateFormat df = prov.getConfig().getDateFormat(); [EOL]                 if (df.getClass() == StdDateFormat.class) { [EOL]                     df = StdDateFormat.getISO8601Format(tz); [EOL]                 } else { [EOL]                     df = (DateFormat) df.clone(); [EOL]                     df.setTimeZone(tz); [EOL]                 } [EOL]                 return withFormat(false, df); [EOL]             } [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider prov, BeanProperty property) throws JsonMappingException { [EOL]     if (property != null) { [EOL]         JsonFormat.Value format = prov.getAnnotationIntrospector().findFormat((Annotated) property.getMember()); [EOL]         if (format != null) { [EOL]             if (format.getShape().isNumeric()) { [EOL]                 return withFormat(true, null); [EOL]             } [EOL]             TimeZone tz = format.getTimeZone(); [EOL]             String pattern = format.getPattern(); [EOL]             if (pattern.length() > 0) { [EOL]                 Locale loc = format.getLocale(); [EOL]                 if (loc == null) { [EOL]                     loc = prov.getLocale(); [EOL]                 } [EOL]                 SimpleDateFormat df = new SimpleDateFormat(pattern, loc); [EOL]                 if (tz == null) { [EOL]                     tz = prov.getTimeZone(); [EOL]                 } [EOL]                 df.setTimeZone(tz); [EOL]                 return withFormat(false, df); [EOL]             } [EOL]             if (tz != null) { [EOL]                 DateFormat df = prov.getConfig().getDateFormat(); [EOL]                 if (df.getClass() == StdDateFormat.class) { [EOL]                     df = StdDateFormat.getISO8601Format(tz); [EOL]                 } else { [EOL]                     df = (DateFormat) df.clone(); [EOL]                     df.setTimeZone(tz); [EOL]                 } [EOL]                 return withFormat(false, df); [EOL]             } [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider prov, BeanProperty property) throws JsonMappingException { [EOL]     if (property != null) { [EOL]         JsonFormat.Value format = prov.getAnnotationIntrospector().findFormat((Annotated) property.getMember()); [EOL]         if (format != null) { [EOL]             if (format.getShape().isNumeric()) { [EOL]                 return withFormat(true, null); [EOL]             } [EOL]             TimeZone tz = format.getTimeZone(); [EOL]             String pattern = format.getPattern(); [EOL]             if (pattern.length() > 0) { [EOL]                 Locale loc = format.getLocale(); [EOL]                 if (loc == null) { [EOL]                     loc = prov.getLocale(); [EOL]                 } [EOL]                 SimpleDateFormat df = new SimpleDateFormat(pattern, loc); [EOL]                 if (tz == null) { [EOL]                     tz = prov.getTimeZone(); [EOL]                 } [EOL]                 df.setTimeZone(tz); [EOL]                 return withFormat(false, df); [EOL]             } [EOL]             if (tz != null) { [EOL]                 DateFormat df = prov.getConfig().getDateFormat(); [EOL]                 if (df.getClass() == StdDateFormat.class) { [EOL]                     df = StdDateFormat.getISO8601Format(tz); [EOL]                 } else { [EOL]                     df = (DateFormat) df.clone(); [EOL]                     df.setTimeZone(tz); [EOL]                 } [EOL]                 return withFormat(false, df); [EOL]             } [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider prov, BeanProperty property) throws JsonMappingException { [EOL]     if (property != null) { [EOL]         JsonFormat.Value format = prov.getAnnotationIntrospector().findFormat((Annotated) property.getMember()); [EOL]         if (format != null) { [EOL]             if (format.getShape().isNumeric()) { [EOL]                 return withFormat(true, null); [EOL]             } [EOL]             TimeZone tz = format.getTimeZone(); [EOL]             String pattern = format.getPattern(); [EOL]             if (pattern.length() > 0) { [EOL]                 Locale loc = format.getLocale(); [EOL]                 if (loc == null) { [EOL]                     loc = prov.getLocale(); [EOL]                 } [EOL]                 SimpleDateFormat df = new SimpleDateFormat(pattern, loc); [EOL]                 if (tz == null) { [EOL]                     tz = prov.getTimeZone(); [EOL]                 } [EOL]                 df.setTimeZone(tz); [EOL]                 return withFormat(false, df); [EOL]             } [EOL]             if (tz != null) { [EOL]                 DateFormat df = prov.getConfig().getDateFormat(); [EOL]                 if (df.getClass() == StdDateFormat.class) { [EOL]                     df = StdDateFormat.getISO8601Format(tz); [EOL]                 } else { [EOL]                     df = (DateFormat) df.clone(); [EOL]                     df.setTimeZone(tz); [EOL]                 } [EOL]                 return withFormat(false, df); [EOL]             } [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider prov, BeanProperty property) throws JsonMappingException { [EOL]     if (property != null) { [EOL]         JsonFormat.Value format = prov.getAnnotationIntrospector().findFormat((Annotated) property.getMember()); [EOL]         if (format != null) { [EOL]             if (format.getShape().isNumeric()) { [EOL]                 return withFormat(true, null); [EOL]             } [EOL]             TimeZone tz = format.getTimeZone(); [EOL]             String pattern = format.getPattern(); [EOL]             if (pattern.length() > 0) { [EOL]                 Locale loc = format.getLocale(); [EOL]                 if (loc == null) { [EOL]                     loc = prov.getLocale(); [EOL]                 } [EOL]                 SimpleDateFormat df = new SimpleDateFormat(pattern, loc); [EOL]                 if (tz == null) { [EOL]                     tz = prov.getTimeZone(); [EOL]                 } [EOL]                 df.setTimeZone(tz); [EOL]                 return withFormat(false, df); [EOL]             } [EOL]             if (tz != null) { [EOL]                 DateFormat df = prov.getConfig().getDateFormat(); [EOL]                 if (df.getClass() == StdDateFormat.class) { [EOL]                     df = StdDateFormat.getISO8601Format(tz); [EOL]                 } else { [EOL]                     df = (DateFormat) df.clone(); [EOL]                     df.setTimeZone(tz); [EOL]                 } [EOL]                 return withFormat(false, df); [EOL]             } [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public Object deserializeSetAndReturn(JsonParser jp, DeserializationContext ctxt, Object instance) throws IOException, JsonProcessingException { [EOL]     return setAndReturn(instance, deserialize(jp, ctxt)); [EOL] }
@Override [EOL] public Object deserializeSetAndReturn(JsonParser jp, DeserializationContext ctxt, Object instance) throws IOException, JsonProcessingException { [EOL]     return setAndReturn(instance, deserialize(jp, ctxt)); [EOL] }
@Override [EOL] public Object deserializeSetAndReturn(JsonParser jp, DeserializationContext ctxt, Object instance) throws IOException, JsonProcessingException { [EOL]     return setAndReturn(instance, deserialize(jp, ctxt)); [EOL] }
protected BeanDeserializerBase(BeanDeserializerBase src, NameTransformer unwrapper) { [EOL]     super(src._beanType); [EOL]     _classAnnotations = src._classAnnotations; [EOL]     _beanType = src._beanType; [EOL]     _valueInstantiator = src._valueInstantiator; [EOL]     _delegateDeserializer = src._delegateDeserializer; [EOL]     _propertyBasedCreator = src._propertyBasedCreator; [EOL]     _backRefs = src._backRefs; [EOL]     _ignorableProps = src._ignorableProps; [EOL]     _ignoreAllUnknown = (unwrapper != null) || src._ignoreAllUnknown; [EOL]     _anySetter = src._anySetter; [EOL]     _injectables = src._injectables; [EOL]     _objectIdReader = src._objectIdReader; [EOL]     _nonStandardCreation = src._nonStandardCreation; [EOL]     _unwrappedPropertyHandler = src._unwrappedPropertyHandler; [EOL]     if (unwrapper != null) { [EOL]         if (_unwrappedPropertyHandler != null) { [EOL]             _unwrappedPropertyHandler.renameAll(unwrapper); [EOL]         } [EOL]         _beanProperties = src._beanProperties.renameAll(unwrapper); [EOL]     } else { [EOL]         _beanProperties = src._beanProperties; [EOL]     } [EOL]     _needViewProcesing = src._needViewProcesing; [EOL]     _serializationShape = src._serializationShape; [EOL]     _vanillaProcessing = false; [EOL] }
protected BeanDeserializerBase(BeanDeserializerBase src, NameTransformer unwrapper) { [EOL]     super(src._beanType); [EOL]     _classAnnotations = src._classAnnotations; [EOL]     _beanType = src._beanType; [EOL]     _valueInstantiator = src._valueInstantiator; [EOL]     _delegateDeserializer = src._delegateDeserializer; [EOL]     _propertyBasedCreator = src._propertyBasedCreator; [EOL]     _backRefs = src._backRefs; [EOL]     _ignorableProps = src._ignorableProps; [EOL]     _ignoreAllUnknown = (unwrapper != null) || src._ignoreAllUnknown; [EOL]     _anySetter = src._anySetter; [EOL]     _injectables = src._injectables; [EOL]     _objectIdReader = src._objectIdReader; [EOL]     _nonStandardCreation = src._nonStandardCreation; [EOL]     _unwrappedPropertyHandler = src._unwrappedPropertyHandler; [EOL]     if (unwrapper != null) { [EOL]         if (_unwrappedPropertyHandler != null) { [EOL]             _unwrappedPropertyHandler.renameAll(unwrapper); [EOL]         } [EOL]         _beanProperties = src._beanProperties.renameAll(unwrapper); [EOL]     } else { [EOL]         _beanProperties = src._beanProperties; [EOL]     } [EOL]     _needViewProcesing = src._needViewProcesing; [EOL]     _serializationShape = src._serializationShape; [EOL]     _vanillaProcessing = false; [EOL] }
public BeanDeserializerBase(BeanDeserializerBase src, ObjectIdReader oir) { [EOL]     super(src._beanType); [EOL]     _classAnnotations = src._classAnnotations; [EOL]     _beanType = src._beanType; [EOL]     _valueInstantiator = src._valueInstantiator; [EOL]     _delegateDeserializer = src._delegateDeserializer; [EOL]     _propertyBasedCreator = src._propertyBasedCreator; [EOL]     _backRefs = src._backRefs; [EOL]     _ignorableProps = src._ignorableProps; [EOL]     _ignoreAllUnknown = src._ignoreAllUnknown; [EOL]     _anySetter = src._anySetter; [EOL]     _injectables = src._injectables; [EOL]     _nonStandardCreation = src._nonStandardCreation; [EOL]     _unwrappedPropertyHandler = src._unwrappedPropertyHandler; [EOL]     _needViewProcesing = src._needViewProcesing; [EOL]     _serializationShape = src._serializationShape; [EOL]     _vanillaProcessing = src._vanillaProcessing; [EOL]     _objectIdReader = oir; [EOL]     if (oir == null) { [EOL]         _beanProperties = src._beanProperties; [EOL]     } else { [EOL]         ObjectIdValueProperty idProp = new ObjectIdValueProperty(oir, true); [EOL]         _beanProperties = src._beanProperties.withProperty(idProp); [EOL]     } [EOL] }
public BeanDeserializerBase(BeanDeserializerBase src, ObjectIdReader oir) { [EOL]     super(src._beanType); [EOL]     _classAnnotations = src._classAnnotations; [EOL]     _beanType = src._beanType; [EOL]     _valueInstantiator = src._valueInstantiator; [EOL]     _delegateDeserializer = src._delegateDeserializer; [EOL]     _propertyBasedCreator = src._propertyBasedCreator; [EOL]     _backRefs = src._backRefs; [EOL]     _ignorableProps = src._ignorableProps; [EOL]     _ignoreAllUnknown = src._ignoreAllUnknown; [EOL]     _anySetter = src._anySetter; [EOL]     _injectables = src._injectables; [EOL]     _nonStandardCreation = src._nonStandardCreation; [EOL]     _unwrappedPropertyHandler = src._unwrappedPropertyHandler; [EOL]     _needViewProcesing = src._needViewProcesing; [EOL]     _serializationShape = src._serializationShape; [EOL]     _vanillaProcessing = src._vanillaProcessing; [EOL]     _objectIdReader = oir; [EOL]     if (oir == null) { [EOL]         _beanProperties = src._beanProperties; [EOL]     } else { [EOL]         ObjectIdValueProperty idProp = new ObjectIdValueProperty(oir, true); [EOL]         _beanProperties = src._beanProperties.withProperty(idProp); [EOL]     } [EOL] }
public BeanDeserializerBase(BeanDeserializerBase src, HashSet<String> ignorableProps) { [EOL]     super(src._beanType); [EOL]     _classAnnotations = src._classAnnotations; [EOL]     _beanType = src._beanType; [EOL]     _valueInstantiator = src._valueInstantiator; [EOL]     _delegateDeserializer = src._delegateDeserializer; [EOL]     _propertyBasedCreator = src._propertyBasedCreator; [EOL]     _backRefs = src._backRefs; [EOL]     _ignorableProps = ignorableProps; [EOL]     _ignoreAllUnknown = src._ignoreAllUnknown; [EOL]     _anySetter = src._anySetter; [EOL]     _injectables = src._injectables; [EOL]     _nonStandardCreation = src._nonStandardCreation; [EOL]     _unwrappedPropertyHandler = src._unwrappedPropertyHandler; [EOL]     _needViewProcesing = src._needViewProcesing; [EOL]     _serializationShape = src._serializationShape; [EOL]     _vanillaProcessing = src._vanillaProcessing; [EOL]     _objectIdReader = src._objectIdReader; [EOL]     _beanProperties = src._beanProperties; [EOL] }
public BeanDeserializerBase(BeanDeserializerBase src, HashSet<String> ignorableProps) { [EOL]     super(src._beanType); [EOL]     _classAnnotations = src._classAnnotations; [EOL]     _beanType = src._beanType; [EOL]     _valueInstantiator = src._valueInstantiator; [EOL]     _delegateDeserializer = src._delegateDeserializer; [EOL]     _propertyBasedCreator = src._propertyBasedCreator; [EOL]     _backRefs = src._backRefs; [EOL]     _ignorableProps = ignorableProps; [EOL]     _ignoreAllUnknown = src._ignoreAllUnknown; [EOL]     _anySetter = src._anySetter; [EOL]     _injectables = src._injectables; [EOL]     _nonStandardCreation = src._nonStandardCreation; [EOL]     _unwrappedPropertyHandler = src._unwrappedPropertyHandler; [EOL]     _needViewProcesing = src._needViewProcesing; [EOL]     _serializationShape = src._serializationShape; [EOL]     _vanillaProcessing = src._vanillaProcessing; [EOL]     _objectIdReader = src._objectIdReader; [EOL]     _beanProperties = src._beanProperties; [EOL] }
@Override [EOL] public void resolve(DeserializationContext ctxt) throws JsonMappingException { [EOL]     ExternalTypeHandler.Builder extTypes = null; [EOL]     if (_valueInstantiator.canCreateFromObjectWith()) { [EOL]         SettableBeanProperty[] creatorProps = _valueInstantiator.getFromObjectArguments(ctxt.getConfig()); [EOL]         _propertyBasedCreator = PropertyBasedCreator.construct(ctxt, _valueInstantiator, creatorProps); [EOL]         for (SettableBeanProperty prop : _propertyBasedCreator.properties()) { [EOL]             if (prop.hasValueTypeDeserializer()) { [EOL]                 TypeDeserializer typeDeser = prop.getValueTypeDeserializer(); [EOL]                 if (typeDeser.getTypeInclusion() == JsonTypeInfo.As.EXTERNAL_PROPERTY) { [EOL]                     if (extTypes == null) { [EOL]                         extTypes = new ExternalTypeHandler.Builder(); [EOL]                     } [EOL]                     extTypes.addExternal(prop, typeDeser); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     UnwrappedPropertyHandler unwrapped = null; [EOL]     for (SettableBeanProperty origProp : _beanProperties) { [EOL]         SettableBeanProperty prop = origProp; [EOL]         if (!prop.hasValueDeserializer()) { [EOL]             JsonDeserializer<?> deser = findConvertingDeserializer(ctxt, prop); [EOL]             if (deser == null) { [EOL]                 deser = findDeserializer(ctxt, prop.getType(), prop); [EOL]             } [EOL]             prop = prop.withValueDeserializer(deser); [EOL]         } else { [EOL]             JsonDeserializer<Object> deser = prop.getValueDeserializer(); [EOL]             if (deser instanceof ContextualDeserializer) { [EOL]                 JsonDeserializer<?> cd = ((ContextualDeserializer) deser).createContextual(ctxt, prop); [EOL]                 if (cd != deser) { [EOL]                     prop = prop.withValueDeserializer(cd); [EOL]                 } [EOL]             } [EOL]         } [EOL]         prop = _resolveManagedReferenceProperty(ctxt, prop); [EOL]         SettableBeanProperty u = _resolveUnwrappedProperty(ctxt, prop); [EOL]         if (u != null) { [EOL]             prop = u; [EOL]             if (unwrapped == null) { [EOL]                 unwrapped = new UnwrappedPropertyHandler(); [EOL]             } [EOL]             unwrapped.addProperty(prop); [EOL]             continue; [EOL]         } [EOL]         prop = _resolveInnerClassValuedProperty(ctxt, prop); [EOL]         if (prop != origProp) { [EOL]             _beanProperties.replace(prop); [EOL]         } [EOL]         if (prop.hasValueTypeDeserializer()) { [EOL]             TypeDeserializer typeDeser = prop.getValueTypeDeserializer(); [EOL]             if (typeDeser.getTypeInclusion() == JsonTypeInfo.As.EXTERNAL_PROPERTY) { [EOL]                 if (extTypes == null) { [EOL]                     extTypes = new ExternalTypeHandler.Builder(); [EOL]                 } [EOL]                 extTypes.addExternal(prop, typeDeser); [EOL]                 _beanProperties.remove(prop); [EOL]                 continue; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (_anySetter != null && !_anySetter.hasValueDeserializer()) { [EOL]         _anySetter = _anySetter.withValueDeserializer(findDeserializer(ctxt, _anySetter.getType(), _anySetter.getProperty())); [EOL]     } [EOL]     if (_valueInstantiator.canCreateUsingDelegate()) { [EOL]         JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig()); [EOL]         if (delegateType == null) { [EOL]             throw new IllegalArgumentException("Invalid delegate-creator definition for " + _beanType + ": value instantiator (" + _valueInstantiator.getClass().getName() + ") returned true for 'canCreateUsingDelegate()', but null for 'getDelegateType()'"); [EOL]         } [EOL]         AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator(); [EOL]         BeanProperty.Std property = new BeanProperty.Std(null, delegateType, null, _classAnnotations, delegateCreator, false); [EOL]         _delegateDeserializer = findDeserializer(ctxt, delegateType, property); [EOL]     } [EOL]     if (extTypes != null) { [EOL]         _externalTypeIdHandler = extTypes.build(); [EOL]         _nonStandardCreation = true; [EOL]     } [EOL]     _unwrappedPropertyHandler = unwrapped; [EOL]     if (unwrapped != null) { [EOL]         _nonStandardCreation = true; [EOL]     } [EOL]     _vanillaProcessing = _vanillaProcessing && !_nonStandardCreation; [EOL] }
@Override [EOL] public void resolve(DeserializationContext ctxt) throws JsonMappingException { [EOL]     ExternalTypeHandler.Builder extTypes = null; [EOL]     if (_valueInstantiator.canCreateFromObjectWith()) { [EOL]         SettableBeanProperty[] creatorProps = _valueInstantiator.getFromObjectArguments(ctxt.getConfig()); [EOL]         _propertyBasedCreator = PropertyBasedCreator.construct(ctxt, _valueInstantiator, creatorProps); [EOL]         for (SettableBeanProperty prop : _propertyBasedCreator.properties()) { [EOL]             if (prop.hasValueTypeDeserializer()) { [EOL]                 TypeDeserializer typeDeser = prop.getValueTypeDeserializer(); [EOL]                 if (typeDeser.getTypeInclusion() == JsonTypeInfo.As.EXTERNAL_PROPERTY) { [EOL]                     if (extTypes == null) { [EOL]                         extTypes = new ExternalTypeHandler.Builder(); [EOL]                     } [EOL]                     extTypes.addExternal(prop, typeDeser); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     UnwrappedPropertyHandler unwrapped = null; [EOL]     for (SettableBeanProperty origProp : _beanProperties) { [EOL]         SettableBeanProperty prop = origProp; [EOL]         if (!prop.hasValueDeserializer()) { [EOL]             JsonDeserializer<?> deser = findConvertingDeserializer(ctxt, prop); [EOL]             if (deser == null) { [EOL]                 deser = findDeserializer(ctxt, prop.getType(), prop); [EOL]             } [EOL]             prop = prop.withValueDeserializer(deser); [EOL]         } else { [EOL]             JsonDeserializer<Object> deser = prop.getValueDeserializer(); [EOL]             if (deser instanceof ContextualDeserializer) { [EOL]                 JsonDeserializer<?> cd = ((ContextualDeserializer) deser).createContextual(ctxt, prop); [EOL]                 if (cd != deser) { [EOL]                     prop = prop.withValueDeserializer(cd); [EOL]                 } [EOL]             } [EOL]         } [EOL]         prop = _resolveManagedReferenceProperty(ctxt, prop); [EOL]         SettableBeanProperty u = _resolveUnwrappedProperty(ctxt, prop); [EOL]         if (u != null) { [EOL]             prop = u; [EOL]             if (unwrapped == null) { [EOL]                 unwrapped = new UnwrappedPropertyHandler(); [EOL]             } [EOL]             unwrapped.addProperty(prop); [EOL]             continue; [EOL]         } [EOL]         prop = _resolveInnerClassValuedProperty(ctxt, prop); [EOL]         if (prop != origProp) { [EOL]             _beanProperties.replace(prop); [EOL]         } [EOL]         if (prop.hasValueTypeDeserializer()) { [EOL]             TypeDeserializer typeDeser = prop.getValueTypeDeserializer(); [EOL]             if (typeDeser.getTypeInclusion() == JsonTypeInfo.As.EXTERNAL_PROPERTY) { [EOL]                 if (extTypes == null) { [EOL]                     extTypes = new ExternalTypeHandler.Builder(); [EOL]                 } [EOL]                 extTypes.addExternal(prop, typeDeser); [EOL]                 _beanProperties.remove(prop); [EOL]                 continue; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (_anySetter != null && !_anySetter.hasValueDeserializer()) { [EOL]         _anySetter = _anySetter.withValueDeserializer(findDeserializer(ctxt, _anySetter.getType(), _anySetter.getProperty())); [EOL]     } [EOL]     if (_valueInstantiator.canCreateUsingDelegate()) { [EOL]         JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig()); [EOL]         if (delegateType == null) { [EOL]             throw new IllegalArgumentException("Invalid delegate-creator definition for " + _beanType + ": value instantiator (" + _valueInstantiator.getClass().getName() + ") returned true for 'canCreateUsingDelegate()', but null for 'getDelegateType()'"); [EOL]         } [EOL]         AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator(); [EOL]         BeanProperty.Std property = new BeanProperty.Std(null, delegateType, null, _classAnnotations, delegateCreator, false); [EOL]         _delegateDeserializer = findDeserializer(ctxt, delegateType, property); [EOL]     } [EOL]     if (extTypes != null) { [EOL]         _externalTypeIdHandler = extTypes.build(); [EOL]         _nonStandardCreation = true; [EOL]     } [EOL]     _unwrappedPropertyHandler = unwrapped; [EOL]     if (unwrapped != null) { [EOL]         _nonStandardCreation = true; [EOL]     } [EOL]     _vanillaProcessing = _vanillaProcessing && !_nonStandardCreation; [EOL] }
@Override [EOL] public void resolve(DeserializationContext ctxt) throws JsonMappingException { [EOL]     ExternalTypeHandler.Builder extTypes = null; [EOL]     if (_valueInstantiator.canCreateFromObjectWith()) { [EOL]         SettableBeanProperty[] creatorProps = _valueInstantiator.getFromObjectArguments(ctxt.getConfig()); [EOL]         _propertyBasedCreator = PropertyBasedCreator.construct(ctxt, _valueInstantiator, creatorProps); [EOL]         for (SettableBeanProperty prop : _propertyBasedCreator.properties()) { [EOL]             if (prop.hasValueTypeDeserializer()) { [EOL]                 TypeDeserializer typeDeser = prop.getValueTypeDeserializer(); [EOL]                 if (typeDeser.getTypeInclusion() == JsonTypeInfo.As.EXTERNAL_PROPERTY) { [EOL]                     if (extTypes == null) { [EOL]                         extTypes = new ExternalTypeHandler.Builder(); [EOL]                     } [EOL]                     extTypes.addExternal(prop, typeDeser); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     UnwrappedPropertyHandler unwrapped = null; [EOL]     for (SettableBeanProperty origProp : _beanProperties) { [EOL]         SettableBeanProperty prop = origProp; [EOL]         if (!prop.hasValueDeserializer()) { [EOL]             JsonDeserializer<?> deser = findConvertingDeserializer(ctxt, prop); [EOL]             if (deser == null) { [EOL]                 deser = findDeserializer(ctxt, prop.getType(), prop); [EOL]             } [EOL]             prop = prop.withValueDeserializer(deser); [EOL]         } else { [EOL]             JsonDeserializer<Object> deser = prop.getValueDeserializer(); [EOL]             if (deser instanceof ContextualDeserializer) { [EOL]                 JsonDeserializer<?> cd = ((ContextualDeserializer) deser).createContextual(ctxt, prop); [EOL]                 if (cd != deser) { [EOL]                     prop = prop.withValueDeserializer(cd); [EOL]                 } [EOL]             } [EOL]         } [EOL]         prop = _resolveManagedReferenceProperty(ctxt, prop); [EOL]         SettableBeanProperty u = _resolveUnwrappedProperty(ctxt, prop); [EOL]         if (u != null) { [EOL]             prop = u; [EOL]             if (unwrapped == null) { [EOL]                 unwrapped = new UnwrappedPropertyHandler(); [EOL]             } [EOL]             unwrapped.addProperty(prop); [EOL]             continue; [EOL]         } [EOL]         prop = _resolveInnerClassValuedProperty(ctxt, prop); [EOL]         if (prop != origProp) { [EOL]             _beanProperties.replace(prop); [EOL]         } [EOL]         if (prop.hasValueTypeDeserializer()) { [EOL]             TypeDeserializer typeDeser = prop.getValueTypeDeserializer(); [EOL]             if (typeDeser.getTypeInclusion() == JsonTypeInfo.As.EXTERNAL_PROPERTY) { [EOL]                 if (extTypes == null) { [EOL]                     extTypes = new ExternalTypeHandler.Builder(); [EOL]                 } [EOL]                 extTypes.addExternal(prop, typeDeser); [EOL]                 _beanProperties.remove(prop); [EOL]                 continue; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (_anySetter != null && !_anySetter.hasValueDeserializer()) { [EOL]         _anySetter = _anySetter.withValueDeserializer(findDeserializer(ctxt, _anySetter.getType(), _anySetter.getProperty())); [EOL]     } [EOL]     if (_valueInstantiator.canCreateUsingDelegate()) { [EOL]         JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig()); [EOL]         if (delegateType == null) { [EOL]             throw new IllegalArgumentException("Invalid delegate-creator definition for " + _beanType + ": value instantiator (" + _valueInstantiator.getClass().getName() + ") returned true for 'canCreateUsingDelegate()', but null for 'getDelegateType()'"); [EOL]         } [EOL]         AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator(); [EOL]         BeanProperty.Std property = new BeanProperty.Std(null, delegateType, null, _classAnnotations, delegateCreator, false); [EOL]         _delegateDeserializer = findDeserializer(ctxt, delegateType, property); [EOL]     } [EOL]     if (extTypes != null) { [EOL]         _externalTypeIdHandler = extTypes.build(); [EOL]         _nonStandardCreation = true; [EOL]     } [EOL]     _unwrappedPropertyHandler = unwrapped; [EOL]     if (unwrapped != null) { [EOL]         _nonStandardCreation = true; [EOL]     } [EOL]     _vanillaProcessing = _vanillaProcessing && !_nonStandardCreation; [EOL] }
@Override [EOL] public void resolve(DeserializationContext ctxt) throws JsonMappingException { [EOL]     ExternalTypeHandler.Builder extTypes = null; [EOL]     if (_valueInstantiator.canCreateFromObjectWith()) { [EOL]         SettableBeanProperty[] creatorProps = _valueInstantiator.getFromObjectArguments(ctxt.getConfig()); [EOL]         _propertyBasedCreator = PropertyBasedCreator.construct(ctxt, _valueInstantiator, creatorProps); [EOL]         for (SettableBeanProperty prop : _propertyBasedCreator.properties()) { [EOL]             if (prop.hasValueTypeDeserializer()) { [EOL]                 TypeDeserializer typeDeser = prop.getValueTypeDeserializer(); [EOL]                 if (typeDeser.getTypeInclusion() == JsonTypeInfo.As.EXTERNAL_PROPERTY) { [EOL]                     if (extTypes == null) { [EOL]                         extTypes = new ExternalTypeHandler.Builder(); [EOL]                     } [EOL]                     extTypes.addExternal(prop, typeDeser); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     UnwrappedPropertyHandler unwrapped = null; [EOL]     for (SettableBeanProperty origProp : _beanProperties) { [EOL]         SettableBeanProperty prop = origProp; [EOL]         if (!prop.hasValueDeserializer()) { [EOL]             JsonDeserializer<?> deser = findConvertingDeserializer(ctxt, prop); [EOL]             if (deser == null) { [EOL]                 deser = findDeserializer(ctxt, prop.getType(), prop); [EOL]             } [EOL]             prop = prop.withValueDeserializer(deser); [EOL]         } else { [EOL]             JsonDeserializer<Object> deser = prop.getValueDeserializer(); [EOL]             if (deser instanceof ContextualDeserializer) { [EOL]                 JsonDeserializer<?> cd = ((ContextualDeserializer) deser).createContextual(ctxt, prop); [EOL]                 if (cd != deser) { [EOL]                     prop = prop.withValueDeserializer(cd); [EOL]                 } [EOL]             } [EOL]         } [EOL]         prop = _resolveManagedReferenceProperty(ctxt, prop); [EOL]         SettableBeanProperty u = _resolveUnwrappedProperty(ctxt, prop); [EOL]         if (u != null) { [EOL]             prop = u; [EOL]             if (unwrapped == null) { [EOL]                 unwrapped = new UnwrappedPropertyHandler(); [EOL]             } [EOL]             unwrapped.addProperty(prop); [EOL]             continue; [EOL]         } [EOL]         prop = _resolveInnerClassValuedProperty(ctxt, prop); [EOL]         if (prop != origProp) { [EOL]             _beanProperties.replace(prop); [EOL]         } [EOL]         if (prop.hasValueTypeDeserializer()) { [EOL]             TypeDeserializer typeDeser = prop.getValueTypeDeserializer(); [EOL]             if (typeDeser.getTypeInclusion() == JsonTypeInfo.As.EXTERNAL_PROPERTY) { [EOL]                 if (extTypes == null) { [EOL]                     extTypes = new ExternalTypeHandler.Builder(); [EOL]                 } [EOL]                 extTypes.addExternal(prop, typeDeser); [EOL]                 _beanProperties.remove(prop); [EOL]                 continue; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (_anySetter != null && !_anySetter.hasValueDeserializer()) { [EOL]         _anySetter = _anySetter.withValueDeserializer(findDeserializer(ctxt, _anySetter.getType(), _anySetter.getProperty())); [EOL]     } [EOL]     if (_valueInstantiator.canCreateUsingDelegate()) { [EOL]         JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig()); [EOL]         if (delegateType == null) { [EOL]             throw new IllegalArgumentException("Invalid delegate-creator definition for " + _beanType + ": value instantiator (" + _valueInstantiator.getClass().getName() + ") returned true for 'canCreateUsingDelegate()', but null for 'getDelegateType()'"); [EOL]         } [EOL]         AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator(); [EOL]         BeanProperty.Std property = new BeanProperty.Std(null, delegateType, null, _classAnnotations, delegateCreator, false); [EOL]         _delegateDeserializer = findDeserializer(ctxt, delegateType, property); [EOL]     } [EOL]     if (extTypes != null) { [EOL]         _externalTypeIdHandler = extTypes.build(); [EOL]         _nonStandardCreation = true; [EOL]     } [EOL]     _unwrappedPropertyHandler = unwrapped; [EOL]     if (unwrapped != null) { [EOL]         _nonStandardCreation = true; [EOL]     } [EOL]     _vanillaProcessing = _vanillaProcessing && !_nonStandardCreation; [EOL] }
@Override [EOL] public void resolve(DeserializationContext ctxt) throws JsonMappingException { [EOL]     ExternalTypeHandler.Builder extTypes = null; [EOL]     if (_valueInstantiator.canCreateFromObjectWith()) { [EOL]         SettableBeanProperty[] creatorProps = _valueInstantiator.getFromObjectArguments(ctxt.getConfig()); [EOL]         _propertyBasedCreator = PropertyBasedCreator.construct(ctxt, _valueInstantiator, creatorProps); [EOL]         for (SettableBeanProperty prop : _propertyBasedCreator.properties()) { [EOL]             if (prop.hasValueTypeDeserializer()) { [EOL]                 TypeDeserializer typeDeser = prop.getValueTypeDeserializer(); [EOL]                 if (typeDeser.getTypeInclusion() == JsonTypeInfo.As.EXTERNAL_PROPERTY) { [EOL]                     if (extTypes == null) { [EOL]                         extTypes = new ExternalTypeHandler.Builder(); [EOL]                     } [EOL]                     extTypes.addExternal(prop, typeDeser); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     UnwrappedPropertyHandler unwrapped = null; [EOL]     for (SettableBeanProperty origProp : _beanProperties) { [EOL]         SettableBeanProperty prop = origProp; [EOL]         if (!prop.hasValueDeserializer()) { [EOL]             JsonDeserializer<?> deser = findConvertingDeserializer(ctxt, prop); [EOL]             if (deser == null) { [EOL]                 deser = findDeserializer(ctxt, prop.getType(), prop); [EOL]             } [EOL]             prop = prop.withValueDeserializer(deser); [EOL]         } else { [EOL]             JsonDeserializer<Object> deser = prop.getValueDeserializer(); [EOL]             if (deser instanceof ContextualDeserializer) { [EOL]                 JsonDeserializer<?> cd = ((ContextualDeserializer) deser).createContextual(ctxt, prop); [EOL]                 if (cd != deser) { [EOL]                     prop = prop.withValueDeserializer(cd); [EOL]                 } [EOL]             } [EOL]         } [EOL]         prop = _resolveManagedReferenceProperty(ctxt, prop); [EOL]         SettableBeanProperty u = _resolveUnwrappedProperty(ctxt, prop); [EOL]         if (u != null) { [EOL]             prop = u; [EOL]             if (unwrapped == null) { [EOL]                 unwrapped = new UnwrappedPropertyHandler(); [EOL]             } [EOL]             unwrapped.addProperty(prop); [EOL]             continue; [EOL]         } [EOL]         prop = _resolveInnerClassValuedProperty(ctxt, prop); [EOL]         if (prop != origProp) { [EOL]             _beanProperties.replace(prop); [EOL]         } [EOL]         if (prop.hasValueTypeDeserializer()) { [EOL]             TypeDeserializer typeDeser = prop.getValueTypeDeserializer(); [EOL]             if (typeDeser.getTypeInclusion() == JsonTypeInfo.As.EXTERNAL_PROPERTY) { [EOL]                 if (extTypes == null) { [EOL]                     extTypes = new ExternalTypeHandler.Builder(); [EOL]                 } [EOL]                 extTypes.addExternal(prop, typeDeser); [EOL]                 _beanProperties.remove(prop); [EOL]                 continue; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (_anySetter != null && !_anySetter.hasValueDeserializer()) { [EOL]         _anySetter = _anySetter.withValueDeserializer(findDeserializer(ctxt, _anySetter.getType(), _anySetter.getProperty())); [EOL]     } [EOL]     if (_valueInstantiator.canCreateUsingDelegate()) { [EOL]         JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig()); [EOL]         if (delegateType == null) { [EOL]             throw new IllegalArgumentException("Invalid delegate-creator definition for " + _beanType + ": value instantiator (" + _valueInstantiator.getClass().getName() + ") returned true for 'canCreateUsingDelegate()', but null for 'getDelegateType()'"); [EOL]         } [EOL]         AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator(); [EOL]         BeanProperty.Std property = new BeanProperty.Std(null, delegateType, null, _classAnnotations, delegateCreator, false); [EOL]         _delegateDeserializer = findDeserializer(ctxt, delegateType, property); [EOL]     } [EOL]     if (extTypes != null) { [EOL]         _externalTypeIdHandler = extTypes.build(); [EOL]         _nonStandardCreation = true; [EOL]     } [EOL]     _unwrappedPropertyHandler = unwrapped; [EOL]     if (unwrapped != null) { [EOL]         _nonStandardCreation = true; [EOL]     } [EOL]     _vanillaProcessing = _vanillaProcessing && !_nonStandardCreation; [EOL] }
@Override [EOL] public void resolve(DeserializationContext ctxt) throws JsonMappingException { [EOL]     ExternalTypeHandler.Builder extTypes = null; [EOL]     if (_valueInstantiator.canCreateFromObjectWith()) { [EOL]         SettableBeanProperty[] creatorProps = _valueInstantiator.getFromObjectArguments(ctxt.getConfig()); [EOL]         _propertyBasedCreator = PropertyBasedCreator.construct(ctxt, _valueInstantiator, creatorProps); [EOL]         for (SettableBeanProperty prop : _propertyBasedCreator.properties()) { [EOL]             if (prop.hasValueTypeDeserializer()) { [EOL]                 TypeDeserializer typeDeser = prop.getValueTypeDeserializer(); [EOL]                 if (typeDeser.getTypeInclusion() == JsonTypeInfo.As.EXTERNAL_PROPERTY) { [EOL]                     if (extTypes == null) { [EOL]                         extTypes = new ExternalTypeHandler.Builder(); [EOL]                     } [EOL]                     extTypes.addExternal(prop, typeDeser); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     UnwrappedPropertyHandler unwrapped = null; [EOL]     for (SettableBeanProperty origProp : _beanProperties) { [EOL]         SettableBeanProperty prop = origProp; [EOL]         if (!prop.hasValueDeserializer()) { [EOL]             JsonDeserializer<?> deser = findConvertingDeserializer(ctxt, prop); [EOL]             if (deser == null) { [EOL]                 deser = findDeserializer(ctxt, prop.getType(), prop); [EOL]             } [EOL]             prop = prop.withValueDeserializer(deser); [EOL]         } else { [EOL]             JsonDeserializer<Object> deser = prop.getValueDeserializer(); [EOL]             if (deser instanceof ContextualDeserializer) { [EOL]                 JsonDeserializer<?> cd = ((ContextualDeserializer) deser).createContextual(ctxt, prop); [EOL]                 if (cd != deser) { [EOL]                     prop = prop.withValueDeserializer(cd); [EOL]                 } [EOL]             } [EOL]         } [EOL]         prop = _resolveManagedReferenceProperty(ctxt, prop); [EOL]         SettableBeanProperty u = _resolveUnwrappedProperty(ctxt, prop); [EOL]         if (u != null) { [EOL]             prop = u; [EOL]             if (unwrapped == null) { [EOL]                 unwrapped = new UnwrappedPropertyHandler(); [EOL]             } [EOL]             unwrapped.addProperty(prop); [EOL]             continue; [EOL]         } [EOL]         prop = _resolveInnerClassValuedProperty(ctxt, prop); [EOL]         if (prop != origProp) { [EOL]             _beanProperties.replace(prop); [EOL]         } [EOL]         if (prop.hasValueTypeDeserializer()) { [EOL]             TypeDeserializer typeDeser = prop.getValueTypeDeserializer(); [EOL]             if (typeDeser.getTypeInclusion() == JsonTypeInfo.As.EXTERNAL_PROPERTY) { [EOL]                 if (extTypes == null) { [EOL]                     extTypes = new ExternalTypeHandler.Builder(); [EOL]                 } [EOL]                 extTypes.addExternal(prop, typeDeser); [EOL]                 _beanProperties.remove(prop); [EOL]                 continue; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (_anySetter != null && !_anySetter.hasValueDeserializer()) { [EOL]         _anySetter = _anySetter.withValueDeserializer(findDeserializer(ctxt, _anySetter.getType(), _anySetter.getProperty())); [EOL]     } [EOL]     if (_valueInstantiator.canCreateUsingDelegate()) { [EOL]         JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig()); [EOL]         if (delegateType == null) { [EOL]             throw new IllegalArgumentException("Invalid delegate-creator definition for " + _beanType + ": value instantiator (" + _valueInstantiator.getClass().getName() + ") returned true for 'canCreateUsingDelegate()', but null for 'getDelegateType()'"); [EOL]         } [EOL]         AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator(); [EOL]         BeanProperty.Std property = new BeanProperty.Std(null, delegateType, null, _classAnnotations, delegateCreator, false); [EOL]         _delegateDeserializer = findDeserializer(ctxt, delegateType, property); [EOL]     } [EOL]     if (extTypes != null) { [EOL]         _externalTypeIdHandler = extTypes.build(); [EOL]         _nonStandardCreation = true; [EOL]     } [EOL]     _unwrappedPropertyHandler = unwrapped; [EOL]     if (unwrapped != null) { [EOL]         _nonStandardCreation = true; [EOL]     } [EOL]     _vanillaProcessing = _vanillaProcessing && !_nonStandardCreation; [EOL] }
@Override [EOL] public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException { [EOL]     ObjectIdReader oir = _objectIdReader; [EOL]     String[] ignorals = null; [EOL]     final AnnotationIntrospector intr = ctxt.getAnnotationIntrospector(); [EOL]     final AnnotatedMember accessor = (property == null || intr == null) ? null : property.getMember(); [EOL]     if (property != null && intr != null) { [EOL]         ignorals = intr.findPropertiesToIgnore(accessor); [EOL]         ObjectIdInfo objectIdInfo = intr.findObjectIdInfo(accessor); [EOL]         if (objectIdInfo != null) { [EOL]             objectIdInfo = intr.findObjectReferenceInfo(accessor, objectIdInfo); [EOL]             Class<?> implClass = objectIdInfo.getGeneratorType(); [EOL]             JavaType idType; [EOL]             SettableBeanProperty idProp; [EOL]             ObjectIdGenerator<?> idGen; [EOL]             if (implClass == ObjectIdGenerators.PropertyGenerator.class) { [EOL]                 String propName = objectIdInfo.getPropertyName(); [EOL]                 idProp = findProperty(propName); [EOL]                 if (idProp == null) { [EOL]                     throw new IllegalArgumentException("Invalid Object Id definition for " + getBeanClass().getName() + ": can not find property with name '" + propName + "'"); [EOL]                 } [EOL]                 idType = idProp.getType(); [EOL]                 idGen = new PropertyBasedObjectIdGenerator(objectIdInfo.getScope()); [EOL]             } else { [EOL]                 JavaType type = ctxt.constructType(implClass); [EOL]                 idType = ctxt.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0]; [EOL]                 idProp = null; [EOL]                 idGen = ctxt.objectIdGeneratorInstance(accessor, objectIdInfo); [EOL]             } [EOL]             JsonDeserializer<?> deser = ctxt.findRootValueDeserializer(idType); [EOL]             oir = ObjectIdReader.construct(idType, objectIdInfo.getPropertyName(), idGen, deser, idProp); [EOL]         } [EOL]     } [EOL]     BeanDeserializerBase contextual = this; [EOL]     if (oir != null && oir != _objectIdReader) { [EOL]         contextual = contextual.withObjectIdReader(oir); [EOL]     } [EOL]     if (ignorals != null && ignorals.length != 0) { [EOL]         HashSet<String> newIgnored = ArrayBuilders.setAndArray(contextual._ignorableProps, ignorals); [EOL]         contextual = contextual.withIgnorableProperties(newIgnored); [EOL]     } [EOL]     JsonFormat.Shape shape = null; [EOL]     if (accessor != null) { [EOL]         JsonFormat.Value format = intr.findFormat((Annotated) accessor); [EOL]         if (format != null) { [EOL]             shape = format.getShape(); [EOL]         } [EOL]     } [EOL]     if (shape == null) { [EOL]         shape = _serializationShape; [EOL]     } [EOL]     if (shape == JsonFormat.Shape.ARRAY) { [EOL]         contextual = contextual.asArrayDeserializer(); [EOL]     } [EOL]     return contextual; [EOL] }
@Override [EOL] public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException { [EOL]     ObjectIdReader oir = _objectIdReader; [EOL]     String[] ignorals = null; [EOL]     final AnnotationIntrospector intr = ctxt.getAnnotationIntrospector(); [EOL]     final AnnotatedMember accessor = (property == null || intr == null) ? null : property.getMember(); [EOL]     if (property != null && intr != null) { [EOL]         ignorals = intr.findPropertiesToIgnore(accessor); [EOL]         ObjectIdInfo objectIdInfo = intr.findObjectIdInfo(accessor); [EOL]         if (objectIdInfo != null) { [EOL]             objectIdInfo = intr.findObjectReferenceInfo(accessor, objectIdInfo); [EOL]             Class<?> implClass = objectIdInfo.getGeneratorType(); [EOL]             JavaType idType; [EOL]             SettableBeanProperty idProp; [EOL]             ObjectIdGenerator<?> idGen; [EOL]             if (implClass == ObjectIdGenerators.PropertyGenerator.class) { [EOL]                 String propName = objectIdInfo.getPropertyName(); [EOL]                 idProp = findProperty(propName); [EOL]                 if (idProp == null) { [EOL]                     throw new IllegalArgumentException("Invalid Object Id definition for " + getBeanClass().getName() + ": can not find property with name '" + propName + "'"); [EOL]                 } [EOL]                 idType = idProp.getType(); [EOL]                 idGen = new PropertyBasedObjectIdGenerator(objectIdInfo.getScope()); [EOL]             } else { [EOL]                 JavaType type = ctxt.constructType(implClass); [EOL]                 idType = ctxt.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0]; [EOL]                 idProp = null; [EOL]                 idGen = ctxt.objectIdGeneratorInstance(accessor, objectIdInfo); [EOL]             } [EOL]             JsonDeserializer<?> deser = ctxt.findRootValueDeserializer(idType); [EOL]             oir = ObjectIdReader.construct(idType, objectIdInfo.getPropertyName(), idGen, deser, idProp); [EOL]         } [EOL]     } [EOL]     BeanDeserializerBase contextual = this; [EOL]     if (oir != null && oir != _objectIdReader) { [EOL]         contextual = contextual.withObjectIdReader(oir); [EOL]     } [EOL]     if (ignorals != null && ignorals.length != 0) { [EOL]         HashSet<String> newIgnored = ArrayBuilders.setAndArray(contextual._ignorableProps, ignorals); [EOL]         contextual = contextual.withIgnorableProperties(newIgnored); [EOL]     } [EOL]     JsonFormat.Shape shape = null; [EOL]     if (accessor != null) { [EOL]         JsonFormat.Value format = intr.findFormat((Annotated) accessor); [EOL]         if (format != null) { [EOL]             shape = format.getShape(); [EOL]         } [EOL]     } [EOL]     if (shape == null) { [EOL]         shape = _serializationShape; [EOL]     } [EOL]     if (shape == JsonFormat.Shape.ARRAY) { [EOL]         contextual = contextual.asArrayDeserializer(); [EOL]     } [EOL]     return contextual; [EOL] }
protected SettableBeanProperty _resolveManagedReferenceProperty(DeserializationContext ctxt, SettableBeanProperty prop) { [EOL]     String refName = prop.getManagedReferenceName(); [EOL]     if (refName == null) { [EOL]         return prop; [EOL]     } [EOL]     JsonDeserializer<?> valueDeser = prop.getValueDeserializer(); [EOL]     SettableBeanProperty backProp = null; [EOL]     boolean isContainer = false; [EOL]     if (valueDeser instanceof BeanDeserializerBase) { [EOL]         backProp = ((BeanDeserializerBase) valueDeser).findBackReference(refName); [EOL]     } else if (valueDeser instanceof ContainerDeserializerBase<?>) { [EOL]         JsonDeserializer<?> contentDeser = ((ContainerDeserializerBase<?>) valueDeser).getContentDeserializer(); [EOL]         if (!(contentDeser instanceof BeanDeserializerBase)) { [EOL]             String deserName = (contentDeser == null) ? "NULL" : contentDeser.getClass().getName(); [EOL]             throw new IllegalArgumentException("Can not handle managed/back reference '" + refName + "': value deserializer is of type ContainerDeserializerBase, but content type is not handled by a BeanDeserializer " + " (instead it's of type " + deserName + ")"); [EOL]         } [EOL]         backProp = ((BeanDeserializerBase) contentDeser).findBackReference(refName); [EOL]         isContainer = true; [EOL]     } else if (valueDeser instanceof AbstractDeserializer) { [EOL]         backProp = ((AbstractDeserializer) valueDeser).findBackReference(refName); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Can not handle managed/back reference '" + refName + "': type for value deserializer is not BeanDeserializer or ContainerDeserializerBase, but " + valueDeser.getClass().getName()); [EOL]     } [EOL]     if (backProp == null) { [EOL]         throw new IllegalArgumentException("Can not handle managed/back reference '" + refName + "': no back reference property found from type " + prop.getType()); [EOL]     } [EOL]     JavaType referredType = _beanType; [EOL]     JavaType backRefType = backProp.getType(); [EOL]     if (!backRefType.getRawClass().isAssignableFrom(referredType.getRawClass())) { [EOL]         throw new IllegalArgumentException("Can not handle managed/back reference '" + refName + "': back reference type (" + backRefType.getRawClass().getName() + ") not compatible with managed type (" + referredType.getRawClass().getName() + ")"); [EOL]     } [EOL]     return new ManagedReferenceProperty(prop, refName, backProp, _classAnnotations, isContainer); [EOL] }
protected SettableBeanProperty _resolveUnwrappedProperty(DeserializationContext ctxt, SettableBeanProperty prop) { [EOL]     AnnotatedMember am = prop.getMember(); [EOL]     if (am != null) { [EOL]         NameTransformer unwrapper = ctxt.getAnnotationIntrospector().findUnwrappingNameTransformer(am); [EOL]         if (unwrapper != null) { [EOL]             JsonDeserializer<Object> orig = prop.getValueDeserializer(); [EOL]             JsonDeserializer<Object> unwrapping = orig.unwrappingDeserializer(unwrapper); [EOL]             if (unwrapping != orig && unwrapping != null) { [EOL]                 return prop.withValueDeserializer(unwrapping); [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
protected SettableBeanProperty _resolveUnwrappedProperty(DeserializationContext ctxt, SettableBeanProperty prop) { [EOL]     AnnotatedMember am = prop.getMember(); [EOL]     if (am != null) { [EOL]         NameTransformer unwrapper = ctxt.getAnnotationIntrospector().findUnwrappingNameTransformer(am); [EOL]         if (unwrapper != null) { [EOL]             JsonDeserializer<Object> orig = prop.getValueDeserializer(); [EOL]             JsonDeserializer<Object> unwrapping = orig.unwrappingDeserializer(unwrapper); [EOL]             if (unwrapping != orig && unwrapping != null) { [EOL]                 return prop.withValueDeserializer(unwrapping); [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
protected SettableBeanProperty _resolveUnwrappedProperty(DeserializationContext ctxt, SettableBeanProperty prop) { [EOL]     AnnotatedMember am = prop.getMember(); [EOL]     if (am != null) { [EOL]         NameTransformer unwrapper = ctxt.getAnnotationIntrospector().findUnwrappingNameTransformer(am); [EOL]         if (unwrapper != null) { [EOL]             JsonDeserializer<Object> orig = prop.getValueDeserializer(); [EOL]             JsonDeserializer<Object> unwrapping = orig.unwrappingDeserializer(unwrapper); [EOL]             if (unwrapping != orig && unwrapping != null) { [EOL]                 return prop.withValueDeserializer(unwrapping); [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
protected SettableBeanProperty _resolveUnwrappedProperty(DeserializationContext ctxt, SettableBeanProperty prop) { [EOL]     AnnotatedMember am = prop.getMember(); [EOL]     if (am != null) { [EOL]         NameTransformer unwrapper = ctxt.getAnnotationIntrospector().findUnwrappingNameTransformer(am); [EOL]         if (unwrapper != null) { [EOL]             JsonDeserializer<Object> orig = prop.getValueDeserializer(); [EOL]             JsonDeserializer<Object> unwrapping = orig.unwrappingDeserializer(unwrapper); [EOL]             if (unwrapping != orig && unwrapping != null) { [EOL]                 return prop.withValueDeserializer(unwrapping); [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public final Object deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException, JsonProcessingException { [EOL]     if (_objectIdReader != null) { [EOL]         JsonToken t = jp.getCurrentToken(); [EOL]         if (t != null && t.isScalarValue()) { [EOL]             return deserializeFromObjectId(jp, ctxt); [EOL]         } [EOL]     } [EOL]     return typeDeserializer.deserializeTypedFromObject(jp, ctxt); [EOL] }
@Override [EOL] public final Object deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException, JsonProcessingException { [EOL]     if (_objectIdReader != null) { [EOL]         JsonToken t = jp.getCurrentToken(); [EOL]         if (t != null && t.isScalarValue()) { [EOL]             return deserializeFromObjectId(jp, ctxt); [EOL]         } [EOL]     } [EOL]     return typeDeserializer.deserializeTypedFromObject(jp, ctxt); [EOL] }
@Override [EOL] public final Object deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException, JsonProcessingException { [EOL]     if (_objectIdReader != null) { [EOL]         JsonToken t = jp.getCurrentToken(); [EOL]         if (t != null && t.isScalarValue()) { [EOL]             return deserializeFromObjectId(jp, ctxt); [EOL]         } [EOL]     } [EOL]     return typeDeserializer.deserializeTypedFromObject(jp, ctxt); [EOL] }
@SuppressWarnings("resource") [EOL] protected Object deserializeWithObjectId(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     final String idPropName = _objectIdReader.propertyName; [EOL]     if (idPropName.equals(jp.getCurrentName())) { [EOL]         return deserializeFromObject(jp, ctxt); [EOL]     } [EOL]     TokenBuffer tmpBuffer = new TokenBuffer(jp.getCodec()); [EOL]     TokenBuffer mergedBuffer = null; [EOL]     for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         if (mergedBuffer == null) { [EOL]             if (idPropName.equals(propName)) { [EOL]                 mergedBuffer = new TokenBuffer(jp.getCodec()); [EOL]                 mergedBuffer.writeFieldName(propName); [EOL]                 jp.nextToken(); [EOL]                 mergedBuffer.copyCurrentStructure(jp); [EOL]                 mergedBuffer.append(tmpBuffer); [EOL]                 tmpBuffer = null; [EOL]             } else { [EOL]                 tmpBuffer.writeFieldName(propName); [EOL]                 jp.nextToken(); [EOL]                 tmpBuffer.copyCurrentStructure(jp); [EOL]             } [EOL]         } else { [EOL]             mergedBuffer.writeFieldName(propName); [EOL]             jp.nextToken(); [EOL]             mergedBuffer.copyCurrentStructure(jp); [EOL]         } [EOL]     } [EOL]     TokenBuffer buffer = (mergedBuffer == null) ? tmpBuffer : mergedBuffer; [EOL]     buffer.writeEndObject(); [EOL]     JsonParser mergedParser = buffer.asParser(); [EOL]     mergedParser.nextToken(); [EOL]     return deserializeFromObject(mergedParser, ctxt); [EOL] }
@SuppressWarnings("resource") [EOL] protected Object deserializeWithObjectId(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     final String idPropName = _objectIdReader.propertyName; [EOL]     if (idPropName.equals(jp.getCurrentName())) { [EOL]         return deserializeFromObject(jp, ctxt); [EOL]     } [EOL]     TokenBuffer tmpBuffer = new TokenBuffer(jp.getCodec()); [EOL]     TokenBuffer mergedBuffer = null; [EOL]     for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         if (mergedBuffer == null) { [EOL]             if (idPropName.equals(propName)) { [EOL]                 mergedBuffer = new TokenBuffer(jp.getCodec()); [EOL]                 mergedBuffer.writeFieldName(propName); [EOL]                 jp.nextToken(); [EOL]                 mergedBuffer.copyCurrentStructure(jp); [EOL]                 mergedBuffer.append(tmpBuffer); [EOL]                 tmpBuffer = null; [EOL]             } else { [EOL]                 tmpBuffer.writeFieldName(propName); [EOL]                 jp.nextToken(); [EOL]                 tmpBuffer.copyCurrentStructure(jp); [EOL]             } [EOL]         } else { [EOL]             mergedBuffer.writeFieldName(propName); [EOL]             jp.nextToken(); [EOL]             mergedBuffer.copyCurrentStructure(jp); [EOL]         } [EOL]     } [EOL]     TokenBuffer buffer = (mergedBuffer == null) ? tmpBuffer : mergedBuffer; [EOL]     buffer.writeEndObject(); [EOL]     JsonParser mergedParser = buffer.asParser(); [EOL]     mergedParser.nextToken(); [EOL]     return deserializeFromObject(mergedParser, ctxt); [EOL] }
@SuppressWarnings("resource") [EOL] protected Object deserializeWithObjectId(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     final String idPropName = _objectIdReader.propertyName; [EOL]     if (idPropName.equals(jp.getCurrentName())) { [EOL]         return deserializeFromObject(jp, ctxt); [EOL]     } [EOL]     TokenBuffer tmpBuffer = new TokenBuffer(jp.getCodec()); [EOL]     TokenBuffer mergedBuffer = null; [EOL]     for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         if (mergedBuffer == null) { [EOL]             if (idPropName.equals(propName)) { [EOL]                 mergedBuffer = new TokenBuffer(jp.getCodec()); [EOL]                 mergedBuffer.writeFieldName(propName); [EOL]                 jp.nextToken(); [EOL]                 mergedBuffer.copyCurrentStructure(jp); [EOL]                 mergedBuffer.append(tmpBuffer); [EOL]                 tmpBuffer = null; [EOL]             } else { [EOL]                 tmpBuffer.writeFieldName(propName); [EOL]                 jp.nextToken(); [EOL]                 tmpBuffer.copyCurrentStructure(jp); [EOL]             } [EOL]         } else { [EOL]             mergedBuffer.writeFieldName(propName); [EOL]             jp.nextToken(); [EOL]             mergedBuffer.copyCurrentStructure(jp); [EOL]         } [EOL]     } [EOL]     TokenBuffer buffer = (mergedBuffer == null) ? tmpBuffer : mergedBuffer; [EOL]     buffer.writeEndObject(); [EOL]     JsonParser mergedParser = buffer.asParser(); [EOL]     mergedParser.nextToken(); [EOL]     return deserializeFromObject(mergedParser, ctxt); [EOL] }
protected Object handlePolymorphic(JsonParser jp, DeserializationContext ctxt, Object bean, TokenBuffer unknownTokens) throws IOException, JsonProcessingException { [EOL]     JsonDeserializer<Object> subDeser = _findSubclassDeserializer(ctxt, bean, unknownTokens); [EOL]     if (subDeser != null) { [EOL]         if (unknownTokens != null) { [EOL]             unknownTokens.writeEndObject(); [EOL]             JsonParser p2 = unknownTokens.asParser(); [EOL]             p2.nextToken(); [EOL]             bean = subDeser.deserialize(p2, ctxt, bean); [EOL]         } [EOL]         if (jp != null) { [EOL]             bean = subDeser.deserialize(jp, ctxt, bean); [EOL]         } [EOL]         return bean; [EOL]     } [EOL]     if (unknownTokens != null) { [EOL]         bean = handleUnknownProperties(ctxt, bean, unknownTokens); [EOL]     } [EOL]     if (jp != null) { [EOL]         bean = deserialize(jp, ctxt, bean); [EOL]     } [EOL]     return bean; [EOL] }
protected Object handlePolymorphic(JsonParser jp, DeserializationContext ctxt, Object bean, TokenBuffer unknownTokens) throws IOException, JsonProcessingException { [EOL]     JsonDeserializer<Object> subDeser = _findSubclassDeserializer(ctxt, bean, unknownTokens); [EOL]     if (subDeser != null) { [EOL]         if (unknownTokens != null) { [EOL]             unknownTokens.writeEndObject(); [EOL]             JsonParser p2 = unknownTokens.asParser(); [EOL]             p2.nextToken(); [EOL]             bean = subDeser.deserialize(p2, ctxt, bean); [EOL]         } [EOL]         if (jp != null) { [EOL]             bean = subDeser.deserialize(jp, ctxt, bean); [EOL]         } [EOL]         return bean; [EOL]     } [EOL]     if (unknownTokens != null) { [EOL]         bean = handleUnknownProperties(ctxt, bean, unknownTokens); [EOL]     } [EOL]     if (jp != null) { [EOL]         bean = deserialize(jp, ctxt, bean); [EOL]     } [EOL]     return bean; [EOL] }
protected Object handlePolymorphic(JsonParser jp, DeserializationContext ctxt, Object bean, TokenBuffer unknownTokens) throws IOException, JsonProcessingException { [EOL]     JsonDeserializer<Object> subDeser = _findSubclassDeserializer(ctxt, bean, unknownTokens); [EOL]     if (subDeser != null) { [EOL]         if (unknownTokens != null) { [EOL]             unknownTokens.writeEndObject(); [EOL]             JsonParser p2 = unknownTokens.asParser(); [EOL]             p2.nextToken(); [EOL]             bean = subDeser.deserialize(p2, ctxt, bean); [EOL]         } [EOL]         if (jp != null) { [EOL]             bean = subDeser.deserialize(jp, ctxt, bean); [EOL]         } [EOL]         return bean; [EOL]     } [EOL]     if (unknownTokens != null) { [EOL]         bean = handleUnknownProperties(ctxt, bean, unknownTokens); [EOL]     } [EOL]     if (jp != null) { [EOL]         bean = deserialize(jp, ctxt, bean); [EOL]     } [EOL]     return bean; [EOL] }
protected Object handlePolymorphic(JsonParser jp, DeserializationContext ctxt, Object bean, TokenBuffer unknownTokens) throws IOException, JsonProcessingException { [EOL]     JsonDeserializer<Object> subDeser = _findSubclassDeserializer(ctxt, bean, unknownTokens); [EOL]     if (subDeser != null) { [EOL]         if (unknownTokens != null) { [EOL]             unknownTokens.writeEndObject(); [EOL]             JsonParser p2 = unknownTokens.asParser(); [EOL]             p2.nextToken(); [EOL]             bean = subDeser.deserialize(p2, ctxt, bean); [EOL]         } [EOL]         if (jp != null) { [EOL]             bean = subDeser.deserialize(jp, ctxt, bean); [EOL]         } [EOL]         return bean; [EOL]     } [EOL]     if (unknownTokens != null) { [EOL]         bean = handleUnknownProperties(ctxt, bean, unknownTokens); [EOL]     } [EOL]     if (jp != null) { [EOL]         bean = deserialize(jp, ctxt, bean); [EOL]     } [EOL]     return bean; [EOL] }
protected JsonDeserializer<Object> _findSubclassDeserializer(DeserializationContext ctxt, Object bean, TokenBuffer unknownTokens) throws IOException, JsonProcessingException { [EOL]     JsonDeserializer<Object> subDeser; [EOL]     synchronized (this) { [EOL]         subDeser = (_subDeserializers == null) ? null : _subDeserializers.get(new ClassKey(bean.getClass())); [EOL]     } [EOL]     if (subDeser != null) { [EOL]         return subDeser; [EOL]     } [EOL]     JavaType type = ctxt.constructType(bean.getClass()); [EOL]     subDeser = ctxt.findRootValueDeserializer(type); [EOL]     if (subDeser != null) { [EOL]         synchronized (this) { [EOL]             if (_subDeserializers == null) { [EOL]                 _subDeserializers = new HashMap<ClassKey, JsonDeserializer<Object>>(); [EOL]                 ; [EOL]             } [EOL]             _subDeserializers.put(new ClassKey(bean.getClass()), subDeser); [EOL]         } [EOL]     } [EOL]     return subDeser; [EOL] }
protected final ArrayNode deserializeArray(JsonParser jp, DeserializationContext ctxt, final JsonNodeFactory nodeFactory) throws IOException, JsonProcessingException { [EOL]     ArrayNode node = nodeFactory.arrayNode(); [EOL]     while (true) { [EOL]         JsonToken t = jp.nextToken(); [EOL]         if (t == null) { [EOL]             throw ctxt.mappingException("Unexpected end-of-input when binding data into ArrayNode"); [EOL]         } [EOL]         switch(t) { [EOL]             case START_OBJECT: [EOL]                 node.add(deserializeObject(jp, ctxt, nodeFactory)); [EOL]                 break; [EOL]             case START_ARRAY: [EOL]                 node.add(deserializeArray(jp, ctxt, nodeFactory)); [EOL]                 break; [EOL]             case END_ARRAY: [EOL]                 return node; [EOL]             case VALUE_STRING: [EOL]                 node.add(nodeFactory.textNode(jp.getText())); [EOL]                 break; [EOL]             default: [EOL]                 node.add(deserializeAny(jp, ctxt, nodeFactory)); [EOL]                 break; [EOL]         } [EOL]     } [EOL] }
protected final JsonNode deserializeAny(JsonParser jp, DeserializationContext ctxt, final JsonNodeFactory nodeFactory) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return deserializeObject(jp, ctxt, nodeFactory); [EOL]         case START_ARRAY: [EOL]             return deserializeArray(jp, ctxt, nodeFactory); [EOL]         case FIELD_NAME: [EOL]             return deserializeObject(jp, ctxt, nodeFactory); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             { [EOL]                 Object ob = jp.getEmbeddedObject(); [EOL]                 if (ob == null) { [EOL]                     return nodeFactory.nullNode(); [EOL]                 } [EOL]                 Class<?> type = ob.getClass(); [EOL]                 if (type == byte[].class) { [EOL]                     return nodeFactory.binaryNode((byte[]) ob); [EOL]                 } [EOL]                 return nodeFactory.POJONode(ob); [EOL]             } [EOL]         case VALUE_STRING: [EOL]             return nodeFactory.textNode(jp.getText()); [EOL]         case VALUE_NUMBER_INT: [EOL]             { [EOL]                 JsonParser.NumberType nt = jp.getNumberType(); [EOL]                 if (nt == JsonParser.NumberType.BIG_INTEGER || ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                     return nodeFactory.numberNode(jp.getBigIntegerValue()); [EOL]                 } [EOL]                 if (nt == JsonParser.NumberType.INT) { [EOL]                     return nodeFactory.numberNode(jp.getIntValue()); [EOL]                 } [EOL]                 return nodeFactory.numberNode(jp.getLongValue()); [EOL]             } [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             { [EOL]                 JsonParser.NumberType nt = jp.getNumberType(); [EOL]                 if (nt == JsonParser.NumberType.BIG_DECIMAL || ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                     return nodeFactory.numberNode(jp.getDecimalValue()); [EOL]                 } [EOL]                 return nodeFactory.numberNode(jp.getDoubleValue()); [EOL]             } [EOL]         case VALUE_TRUE: [EOL]             return nodeFactory.booleanNode(true); [EOL]         case VALUE_FALSE: [EOL]             return nodeFactory.booleanNode(false); [EOL]         case VALUE_NULL: [EOL]             return nodeFactory.nullNode(); [EOL]         default: [EOL]             throw ctxt.mappingException(getValueClass()); [EOL]     } [EOL] }
protected final JsonNode deserializeAny(JsonParser jp, DeserializationContext ctxt, final JsonNodeFactory nodeFactory) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return deserializeObject(jp, ctxt, nodeFactory); [EOL]         case START_ARRAY: [EOL]             return deserializeArray(jp, ctxt, nodeFactory); [EOL]         case FIELD_NAME: [EOL]             return deserializeObject(jp, ctxt, nodeFactory); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             { [EOL]                 Object ob = jp.getEmbeddedObject(); [EOL]                 if (ob == null) { [EOL]                     return nodeFactory.nullNode(); [EOL]                 } [EOL]                 Class<?> type = ob.getClass(); [EOL]                 if (type == byte[].class) { [EOL]                     return nodeFactory.binaryNode((byte[]) ob); [EOL]                 } [EOL]                 return nodeFactory.POJONode(ob); [EOL]             } [EOL]         case VALUE_STRING: [EOL]             return nodeFactory.textNode(jp.getText()); [EOL]         case VALUE_NUMBER_INT: [EOL]             { [EOL]                 JsonParser.NumberType nt = jp.getNumberType(); [EOL]                 if (nt == JsonParser.NumberType.BIG_INTEGER || ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                     return nodeFactory.numberNode(jp.getBigIntegerValue()); [EOL]                 } [EOL]                 if (nt == JsonParser.NumberType.INT) { [EOL]                     return nodeFactory.numberNode(jp.getIntValue()); [EOL]                 } [EOL]                 return nodeFactory.numberNode(jp.getLongValue()); [EOL]             } [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             { [EOL]                 JsonParser.NumberType nt = jp.getNumberType(); [EOL]                 if (nt == JsonParser.NumberType.BIG_DECIMAL || ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                     return nodeFactory.numberNode(jp.getDecimalValue()); [EOL]                 } [EOL]                 return nodeFactory.numberNode(jp.getDoubleValue()); [EOL]             } [EOL]         case VALUE_TRUE: [EOL]             return nodeFactory.booleanNode(true); [EOL]         case VALUE_FALSE: [EOL]             return nodeFactory.booleanNode(false); [EOL]         case VALUE_NULL: [EOL]             return nodeFactory.nullNode(); [EOL]         default: [EOL]             throw ctxt.mappingException(getValueClass()); [EOL]     } [EOL] }
protected final JsonNode deserializeAny(JsonParser jp, DeserializationContext ctxt, final JsonNodeFactory nodeFactory) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return deserializeObject(jp, ctxt, nodeFactory); [EOL]         case START_ARRAY: [EOL]             return deserializeArray(jp, ctxt, nodeFactory); [EOL]         case FIELD_NAME: [EOL]             return deserializeObject(jp, ctxt, nodeFactory); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             { [EOL]                 Object ob = jp.getEmbeddedObject(); [EOL]                 if (ob == null) { [EOL]                     return nodeFactory.nullNode(); [EOL]                 } [EOL]                 Class<?> type = ob.getClass(); [EOL]                 if (type == byte[].class) { [EOL]                     return nodeFactory.binaryNode((byte[]) ob); [EOL]                 } [EOL]                 return nodeFactory.POJONode(ob); [EOL]             } [EOL]         case VALUE_STRING: [EOL]             return nodeFactory.textNode(jp.getText()); [EOL]         case VALUE_NUMBER_INT: [EOL]             { [EOL]                 JsonParser.NumberType nt = jp.getNumberType(); [EOL]                 if (nt == JsonParser.NumberType.BIG_INTEGER || ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                     return nodeFactory.numberNode(jp.getBigIntegerValue()); [EOL]                 } [EOL]                 if (nt == JsonParser.NumberType.INT) { [EOL]                     return nodeFactory.numberNode(jp.getIntValue()); [EOL]                 } [EOL]                 return nodeFactory.numberNode(jp.getLongValue()); [EOL]             } [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             { [EOL]                 JsonParser.NumberType nt = jp.getNumberType(); [EOL]                 if (nt == JsonParser.NumberType.BIG_DECIMAL || ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                     return nodeFactory.numberNode(jp.getDecimalValue()); [EOL]                 } [EOL]                 return nodeFactory.numberNode(jp.getDoubleValue()); [EOL]             } [EOL]         case VALUE_TRUE: [EOL]             return nodeFactory.booleanNode(true); [EOL]         case VALUE_FALSE: [EOL]             return nodeFactory.booleanNode(false); [EOL]         case VALUE_NULL: [EOL]             return nodeFactory.nullNode(); [EOL]         default: [EOL]             throw ctxt.mappingException(getValueClass()); [EOL]     } [EOL] }
protected final JsonNode deserializeAny(JsonParser jp, DeserializationContext ctxt, final JsonNodeFactory nodeFactory) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return deserializeObject(jp, ctxt, nodeFactory); [EOL]         case START_ARRAY: [EOL]             return deserializeArray(jp, ctxt, nodeFactory); [EOL]         case FIELD_NAME: [EOL]             return deserializeObject(jp, ctxt, nodeFactory); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             { [EOL]                 Object ob = jp.getEmbeddedObject(); [EOL]                 if (ob == null) { [EOL]                     return nodeFactory.nullNode(); [EOL]                 } [EOL]                 Class<?> type = ob.getClass(); [EOL]                 if (type == byte[].class) { [EOL]                     return nodeFactory.binaryNode((byte[]) ob); [EOL]                 } [EOL]                 return nodeFactory.POJONode(ob); [EOL]             } [EOL]         case VALUE_STRING: [EOL]             return nodeFactory.textNode(jp.getText()); [EOL]         case VALUE_NUMBER_INT: [EOL]             { [EOL]                 JsonParser.NumberType nt = jp.getNumberType(); [EOL]                 if (nt == JsonParser.NumberType.BIG_INTEGER || ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                     return nodeFactory.numberNode(jp.getBigIntegerValue()); [EOL]                 } [EOL]                 if (nt == JsonParser.NumberType.INT) { [EOL]                     return nodeFactory.numberNode(jp.getIntValue()); [EOL]                 } [EOL]                 return nodeFactory.numberNode(jp.getLongValue()); [EOL]             } [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             { [EOL]                 JsonParser.NumberType nt = jp.getNumberType(); [EOL]                 if (nt == JsonParser.NumberType.BIG_DECIMAL || ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                     return nodeFactory.numberNode(jp.getDecimalValue()); [EOL]                 } [EOL]                 return nodeFactory.numberNode(jp.getDoubleValue()); [EOL]             } [EOL]         case VALUE_TRUE: [EOL]             return nodeFactory.booleanNode(true); [EOL]         case VALUE_FALSE: [EOL]             return nodeFactory.booleanNode(false); [EOL]         case VALUE_NULL: [EOL]             return nodeFactory.nullNode(); [EOL]         default: [EOL]             throw ctxt.mappingException(getValueClass()); [EOL]     } [EOL] }
protected final JsonNode deserializeAny(JsonParser jp, DeserializationContext ctxt, final JsonNodeFactory nodeFactory) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return deserializeObject(jp, ctxt, nodeFactory); [EOL]         case START_ARRAY: [EOL]             return deserializeArray(jp, ctxt, nodeFactory); [EOL]         case FIELD_NAME: [EOL]             return deserializeObject(jp, ctxt, nodeFactory); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             { [EOL]                 Object ob = jp.getEmbeddedObject(); [EOL]                 if (ob == null) { [EOL]                     return nodeFactory.nullNode(); [EOL]                 } [EOL]                 Class<?> type = ob.getClass(); [EOL]                 if (type == byte[].class) { [EOL]                     return nodeFactory.binaryNode((byte[]) ob); [EOL]                 } [EOL]                 return nodeFactory.POJONode(ob); [EOL]             } [EOL]         case VALUE_STRING: [EOL]             return nodeFactory.textNode(jp.getText()); [EOL]         case VALUE_NUMBER_INT: [EOL]             { [EOL]                 JsonParser.NumberType nt = jp.getNumberType(); [EOL]                 if (nt == JsonParser.NumberType.BIG_INTEGER || ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                     return nodeFactory.numberNode(jp.getBigIntegerValue()); [EOL]                 } [EOL]                 if (nt == JsonParser.NumberType.INT) { [EOL]                     return nodeFactory.numberNode(jp.getIntValue()); [EOL]                 } [EOL]                 return nodeFactory.numberNode(jp.getLongValue()); [EOL]             } [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             { [EOL]                 JsonParser.NumberType nt = jp.getNumberType(); [EOL]                 if (nt == JsonParser.NumberType.BIG_DECIMAL || ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                     return nodeFactory.numberNode(jp.getDecimalValue()); [EOL]                 } [EOL]                 return nodeFactory.numberNode(jp.getDoubleValue()); [EOL]             } [EOL]         case VALUE_TRUE: [EOL]             return nodeFactory.booleanNode(true); [EOL]         case VALUE_FALSE: [EOL]             return nodeFactory.booleanNode(false); [EOL]         case VALUE_NULL: [EOL]             return nodeFactory.nullNode(); [EOL]         default: [EOL]             throw ctxt.mappingException(getValueClass()); [EOL]     } [EOL] }
protected final JsonNode deserializeAny(JsonParser jp, DeserializationContext ctxt, final JsonNodeFactory nodeFactory) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return deserializeObject(jp, ctxt, nodeFactory); [EOL]         case START_ARRAY: [EOL]             return deserializeArray(jp, ctxt, nodeFactory); [EOL]         case FIELD_NAME: [EOL]             return deserializeObject(jp, ctxt, nodeFactory); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             { [EOL]                 Object ob = jp.getEmbeddedObject(); [EOL]                 if (ob == null) { [EOL]                     return nodeFactory.nullNode(); [EOL]                 } [EOL]                 Class<?> type = ob.getClass(); [EOL]                 if (type == byte[].class) { [EOL]                     return nodeFactory.binaryNode((byte[]) ob); [EOL]                 } [EOL]                 return nodeFactory.POJONode(ob); [EOL]             } [EOL]         case VALUE_STRING: [EOL]             return nodeFactory.textNode(jp.getText()); [EOL]         case VALUE_NUMBER_INT: [EOL]             { [EOL]                 JsonParser.NumberType nt = jp.getNumberType(); [EOL]                 if (nt == JsonParser.NumberType.BIG_INTEGER || ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                     return nodeFactory.numberNode(jp.getBigIntegerValue()); [EOL]                 } [EOL]                 if (nt == JsonParser.NumberType.INT) { [EOL]                     return nodeFactory.numberNode(jp.getIntValue()); [EOL]                 } [EOL]                 return nodeFactory.numberNode(jp.getLongValue()); [EOL]             } [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             { [EOL]                 JsonParser.NumberType nt = jp.getNumberType(); [EOL]                 if (nt == JsonParser.NumberType.BIG_DECIMAL || ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                     return nodeFactory.numberNode(jp.getDecimalValue()); [EOL]                 } [EOL]                 return nodeFactory.numberNode(jp.getDoubleValue()); [EOL]             } [EOL]         case VALUE_TRUE: [EOL]             return nodeFactory.booleanNode(true); [EOL]         case VALUE_FALSE: [EOL]             return nodeFactory.booleanNode(false); [EOL]         case VALUE_NULL: [EOL]             return nodeFactory.nullNode(); [EOL]         default: [EOL]             throw ctxt.mappingException(getValueClass()); [EOL]     } [EOL] }
protected final JsonNode deserializeAny(JsonParser jp, DeserializationContext ctxt, final JsonNodeFactory nodeFactory) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return deserializeObject(jp, ctxt, nodeFactory); [EOL]         case START_ARRAY: [EOL]             return deserializeArray(jp, ctxt, nodeFactory); [EOL]         case FIELD_NAME: [EOL]             return deserializeObject(jp, ctxt, nodeFactory); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             { [EOL]                 Object ob = jp.getEmbeddedObject(); [EOL]                 if (ob == null) { [EOL]                     return nodeFactory.nullNode(); [EOL]                 } [EOL]                 Class<?> type = ob.getClass(); [EOL]                 if (type == byte[].class) { [EOL]                     return nodeFactory.binaryNode((byte[]) ob); [EOL]                 } [EOL]                 return nodeFactory.POJONode(ob); [EOL]             } [EOL]         case VALUE_STRING: [EOL]             return nodeFactory.textNode(jp.getText()); [EOL]         case VALUE_NUMBER_INT: [EOL]             { [EOL]                 JsonParser.NumberType nt = jp.getNumberType(); [EOL]                 if (nt == JsonParser.NumberType.BIG_INTEGER || ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                     return nodeFactory.numberNode(jp.getBigIntegerValue()); [EOL]                 } [EOL]                 if (nt == JsonParser.NumberType.INT) { [EOL]                     return nodeFactory.numberNode(jp.getIntValue()); [EOL]                 } [EOL]                 return nodeFactory.numberNode(jp.getLongValue()); [EOL]             } [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             { [EOL]                 JsonParser.NumberType nt = jp.getNumberType(); [EOL]                 if (nt == JsonParser.NumberType.BIG_DECIMAL || ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                     return nodeFactory.numberNode(jp.getDecimalValue()); [EOL]                 } [EOL]                 return nodeFactory.numberNode(jp.getDoubleValue()); [EOL]             } [EOL]         case VALUE_TRUE: [EOL]             return nodeFactory.booleanNode(true); [EOL]         case VALUE_FALSE: [EOL]             return nodeFactory.booleanNode(false); [EOL]         case VALUE_NULL: [EOL]             return nodeFactory.nullNode(); [EOL]         default: [EOL]             throw ctxt.mappingException(getValueClass()); [EOL]     } [EOL] }
protected final JsonNode deserializeAny(JsonParser jp, DeserializationContext ctxt, final JsonNodeFactory nodeFactory) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return deserializeObject(jp, ctxt, nodeFactory); [EOL]         case START_ARRAY: [EOL]             return deserializeArray(jp, ctxt, nodeFactory); [EOL]         case FIELD_NAME: [EOL]             return deserializeObject(jp, ctxt, nodeFactory); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             { [EOL]                 Object ob = jp.getEmbeddedObject(); [EOL]                 if (ob == null) { [EOL]                     return nodeFactory.nullNode(); [EOL]                 } [EOL]                 Class<?> type = ob.getClass(); [EOL]                 if (type == byte[].class) { [EOL]                     return nodeFactory.binaryNode((byte[]) ob); [EOL]                 } [EOL]                 return nodeFactory.POJONode(ob); [EOL]             } [EOL]         case VALUE_STRING: [EOL]             return nodeFactory.textNode(jp.getText()); [EOL]         case VALUE_NUMBER_INT: [EOL]             { [EOL]                 JsonParser.NumberType nt = jp.getNumberType(); [EOL]                 if (nt == JsonParser.NumberType.BIG_INTEGER || ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                     return nodeFactory.numberNode(jp.getBigIntegerValue()); [EOL]                 } [EOL]                 if (nt == JsonParser.NumberType.INT) { [EOL]                     return nodeFactory.numberNode(jp.getIntValue()); [EOL]                 } [EOL]                 return nodeFactory.numberNode(jp.getLongValue()); [EOL]             } [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             { [EOL]                 JsonParser.NumberType nt = jp.getNumberType(); [EOL]                 if (nt == JsonParser.NumberType.BIG_DECIMAL || ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                     return nodeFactory.numberNode(jp.getDecimalValue()); [EOL]                 } [EOL]                 return nodeFactory.numberNode(jp.getDoubleValue()); [EOL]             } [EOL]         case VALUE_TRUE: [EOL]             return nodeFactory.booleanNode(true); [EOL]         case VALUE_FALSE: [EOL]             return nodeFactory.booleanNode(false); [EOL]         case VALUE_NULL: [EOL]             return nodeFactory.nullNode(); [EOL]         default: [EOL]             throw ctxt.mappingException(getValueClass()); [EOL]     } [EOL] }
protected final JsonNode deserializeAny(JsonParser jp, DeserializationContext ctxt, final JsonNodeFactory nodeFactory) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return deserializeObject(jp, ctxt, nodeFactory); [EOL]         case START_ARRAY: [EOL]             return deserializeArray(jp, ctxt, nodeFactory); [EOL]         case FIELD_NAME: [EOL]             return deserializeObject(jp, ctxt, nodeFactory); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             { [EOL]                 Object ob = jp.getEmbeddedObject(); [EOL]                 if (ob == null) { [EOL]                     return nodeFactory.nullNode(); [EOL]                 } [EOL]                 Class<?> type = ob.getClass(); [EOL]                 if (type == byte[].class) { [EOL]                     return nodeFactory.binaryNode((byte[]) ob); [EOL]                 } [EOL]                 return nodeFactory.POJONode(ob); [EOL]             } [EOL]         case VALUE_STRING: [EOL]             return nodeFactory.textNode(jp.getText()); [EOL]         case VALUE_NUMBER_INT: [EOL]             { [EOL]                 JsonParser.NumberType nt = jp.getNumberType(); [EOL]                 if (nt == JsonParser.NumberType.BIG_INTEGER || ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                     return nodeFactory.numberNode(jp.getBigIntegerValue()); [EOL]                 } [EOL]                 if (nt == JsonParser.NumberType.INT) { [EOL]                     return nodeFactory.numberNode(jp.getIntValue()); [EOL]                 } [EOL]                 return nodeFactory.numberNode(jp.getLongValue()); [EOL]             } [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             { [EOL]                 JsonParser.NumberType nt = jp.getNumberType(); [EOL]                 if (nt == JsonParser.NumberType.BIG_DECIMAL || ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                     return nodeFactory.numberNode(jp.getDecimalValue()); [EOL]                 } [EOL]                 return nodeFactory.numberNode(jp.getDoubleValue()); [EOL]             } [EOL]         case VALUE_TRUE: [EOL]             return nodeFactory.booleanNode(true); [EOL]         case VALUE_FALSE: [EOL]             return nodeFactory.booleanNode(false); [EOL]         case VALUE_NULL: [EOL]             return nodeFactory.nullNode(); [EOL]         default: [EOL]             throw ctxt.mappingException(getValueClass()); [EOL]     } [EOL] }
protected final JsonNode deserializeAny(JsonParser jp, DeserializationContext ctxt, final JsonNodeFactory nodeFactory) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return deserializeObject(jp, ctxt, nodeFactory); [EOL]         case START_ARRAY: [EOL]             return deserializeArray(jp, ctxt, nodeFactory); [EOL]         case FIELD_NAME: [EOL]             return deserializeObject(jp, ctxt, nodeFactory); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             { [EOL]                 Object ob = jp.getEmbeddedObject(); [EOL]                 if (ob == null) { [EOL]                     return nodeFactory.nullNode(); [EOL]                 } [EOL]                 Class<?> type = ob.getClass(); [EOL]                 if (type == byte[].class) { [EOL]                     return nodeFactory.binaryNode((byte[]) ob); [EOL]                 } [EOL]                 return nodeFactory.POJONode(ob); [EOL]             } [EOL]         case VALUE_STRING: [EOL]             return nodeFactory.textNode(jp.getText()); [EOL]         case VALUE_NUMBER_INT: [EOL]             { [EOL]                 JsonParser.NumberType nt = jp.getNumberType(); [EOL]                 if (nt == JsonParser.NumberType.BIG_INTEGER || ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                     return nodeFactory.numberNode(jp.getBigIntegerValue()); [EOL]                 } [EOL]                 if (nt == JsonParser.NumberType.INT) { [EOL]                     return nodeFactory.numberNode(jp.getIntValue()); [EOL]                 } [EOL]                 return nodeFactory.numberNode(jp.getLongValue()); [EOL]             } [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             { [EOL]                 JsonParser.NumberType nt = jp.getNumberType(); [EOL]                 if (nt == JsonParser.NumberType.BIG_DECIMAL || ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                     return nodeFactory.numberNode(jp.getDecimalValue()); [EOL]                 } [EOL]                 return nodeFactory.numberNode(jp.getDoubleValue()); [EOL]             } [EOL]         case VALUE_TRUE: [EOL]             return nodeFactory.booleanNode(true); [EOL]         case VALUE_FALSE: [EOL]             return nodeFactory.booleanNode(false); [EOL]         case VALUE_NULL: [EOL]             return nodeFactory.nullNode(); [EOL]         default: [EOL]             throw ctxt.mappingException(getValueClass()); [EOL]     } [EOL] }
protected final JsonNode deserializeAny(JsonParser jp, DeserializationContext ctxt, final JsonNodeFactory nodeFactory) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return deserializeObject(jp, ctxt, nodeFactory); [EOL]         case START_ARRAY: [EOL]             return deserializeArray(jp, ctxt, nodeFactory); [EOL]         case FIELD_NAME: [EOL]             return deserializeObject(jp, ctxt, nodeFactory); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             { [EOL]                 Object ob = jp.getEmbeddedObject(); [EOL]                 if (ob == null) { [EOL]                     return nodeFactory.nullNode(); [EOL]                 } [EOL]                 Class<?> type = ob.getClass(); [EOL]                 if (type == byte[].class) { [EOL]                     return nodeFactory.binaryNode((byte[]) ob); [EOL]                 } [EOL]                 return nodeFactory.POJONode(ob); [EOL]             } [EOL]         case VALUE_STRING: [EOL]             return nodeFactory.textNode(jp.getText()); [EOL]         case VALUE_NUMBER_INT: [EOL]             { [EOL]                 JsonParser.NumberType nt = jp.getNumberType(); [EOL]                 if (nt == JsonParser.NumberType.BIG_INTEGER || ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                     return nodeFactory.numberNode(jp.getBigIntegerValue()); [EOL]                 } [EOL]                 if (nt == JsonParser.NumberType.INT) { [EOL]                     return nodeFactory.numberNode(jp.getIntValue()); [EOL]                 } [EOL]                 return nodeFactory.numberNode(jp.getLongValue()); [EOL]             } [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             { [EOL]                 JsonParser.NumberType nt = jp.getNumberType(); [EOL]                 if (nt == JsonParser.NumberType.BIG_DECIMAL || ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                     return nodeFactory.numberNode(jp.getDecimalValue()); [EOL]                 } [EOL]                 return nodeFactory.numberNode(jp.getDoubleValue()); [EOL]             } [EOL]         case VALUE_TRUE: [EOL]             return nodeFactory.booleanNode(true); [EOL]         case VALUE_FALSE: [EOL]             return nodeFactory.booleanNode(false); [EOL]         case VALUE_NULL: [EOL]             return nodeFactory.nullNode(); [EOL]         default: [EOL]             throw ctxt.mappingException(getValueClass()); [EOL]     } [EOL] }
protected final JsonNode deserializeAny(JsonParser jp, DeserializationContext ctxt, final JsonNodeFactory nodeFactory) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return deserializeObject(jp, ctxt, nodeFactory); [EOL]         case START_ARRAY: [EOL]             return deserializeArray(jp, ctxt, nodeFactory); [EOL]         case FIELD_NAME: [EOL]             return deserializeObject(jp, ctxt, nodeFactory); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             { [EOL]                 Object ob = jp.getEmbeddedObject(); [EOL]                 if (ob == null) { [EOL]                     return nodeFactory.nullNode(); [EOL]                 } [EOL]                 Class<?> type = ob.getClass(); [EOL]                 if (type == byte[].class) { [EOL]                     return nodeFactory.binaryNode((byte[]) ob); [EOL]                 } [EOL]                 return nodeFactory.POJONode(ob); [EOL]             } [EOL]         case VALUE_STRING: [EOL]             return nodeFactory.textNode(jp.getText()); [EOL]         case VALUE_NUMBER_INT: [EOL]             { [EOL]                 JsonParser.NumberType nt = jp.getNumberType(); [EOL]                 if (nt == JsonParser.NumberType.BIG_INTEGER || ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                     return nodeFactory.numberNode(jp.getBigIntegerValue()); [EOL]                 } [EOL]                 if (nt == JsonParser.NumberType.INT) { [EOL]                     return nodeFactory.numberNode(jp.getIntValue()); [EOL]                 } [EOL]                 return nodeFactory.numberNode(jp.getLongValue()); [EOL]             } [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             { [EOL]                 JsonParser.NumberType nt = jp.getNumberType(); [EOL]                 if (nt == JsonParser.NumberType.BIG_DECIMAL || ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                     return nodeFactory.numberNode(jp.getDecimalValue()); [EOL]                 } [EOL]                 return nodeFactory.numberNode(jp.getDoubleValue()); [EOL]             } [EOL]         case VALUE_TRUE: [EOL]             return nodeFactory.booleanNode(true); [EOL]         case VALUE_FALSE: [EOL]             return nodeFactory.booleanNode(false); [EOL]         case VALUE_NULL: [EOL]             return nodeFactory.nullNode(); [EOL]         default: [EOL]             throw ctxt.mappingException(getValueClass()); [EOL]     } [EOL] }
protected final JsonNode deserializeAny(JsonParser jp, DeserializationContext ctxt, final JsonNodeFactory nodeFactory) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return deserializeObject(jp, ctxt, nodeFactory); [EOL]         case START_ARRAY: [EOL]             return deserializeArray(jp, ctxt, nodeFactory); [EOL]         case FIELD_NAME: [EOL]             return deserializeObject(jp, ctxt, nodeFactory); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             { [EOL]                 Object ob = jp.getEmbeddedObject(); [EOL]                 if (ob == null) { [EOL]                     return nodeFactory.nullNode(); [EOL]                 } [EOL]                 Class<?> type = ob.getClass(); [EOL]                 if (type == byte[].class) { [EOL]                     return nodeFactory.binaryNode((byte[]) ob); [EOL]                 } [EOL]                 return nodeFactory.POJONode(ob); [EOL]             } [EOL]         case VALUE_STRING: [EOL]             return nodeFactory.textNode(jp.getText()); [EOL]         case VALUE_NUMBER_INT: [EOL]             { [EOL]                 JsonParser.NumberType nt = jp.getNumberType(); [EOL]                 if (nt == JsonParser.NumberType.BIG_INTEGER || ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                     return nodeFactory.numberNode(jp.getBigIntegerValue()); [EOL]                 } [EOL]                 if (nt == JsonParser.NumberType.INT) { [EOL]                     return nodeFactory.numberNode(jp.getIntValue()); [EOL]                 } [EOL]                 return nodeFactory.numberNode(jp.getLongValue()); [EOL]             } [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             { [EOL]                 JsonParser.NumberType nt = jp.getNumberType(); [EOL]                 if (nt == JsonParser.NumberType.BIG_DECIMAL || ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                     return nodeFactory.numberNode(jp.getDecimalValue()); [EOL]                 } [EOL]                 return nodeFactory.numberNode(jp.getDoubleValue()); [EOL]             } [EOL]         case VALUE_TRUE: [EOL]             return nodeFactory.booleanNode(true); [EOL]         case VALUE_FALSE: [EOL]             return nodeFactory.booleanNode(false); [EOL]         case VALUE_NULL: [EOL]             return nodeFactory.nullNode(); [EOL]         default: [EOL]             throw ctxt.mappingException(getValueClass()); [EOL]     } [EOL] }
protected final JsonNode deserializeAny(JsonParser jp, DeserializationContext ctxt, final JsonNodeFactory nodeFactory) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return deserializeObject(jp, ctxt, nodeFactory); [EOL]         case START_ARRAY: [EOL]             return deserializeArray(jp, ctxt, nodeFactory); [EOL]         case FIELD_NAME: [EOL]             return deserializeObject(jp, ctxt, nodeFactory); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             { [EOL]                 Object ob = jp.getEmbeddedObject(); [EOL]                 if (ob == null) { [EOL]                     return nodeFactory.nullNode(); [EOL]                 } [EOL]                 Class<?> type = ob.getClass(); [EOL]                 if (type == byte[].class) { [EOL]                     return nodeFactory.binaryNode((byte[]) ob); [EOL]                 } [EOL]                 return nodeFactory.POJONode(ob); [EOL]             } [EOL]         case VALUE_STRING: [EOL]             return nodeFactory.textNode(jp.getText()); [EOL]         case VALUE_NUMBER_INT: [EOL]             { [EOL]                 JsonParser.NumberType nt = jp.getNumberType(); [EOL]                 if (nt == JsonParser.NumberType.BIG_INTEGER || ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                     return nodeFactory.numberNode(jp.getBigIntegerValue()); [EOL]                 } [EOL]                 if (nt == JsonParser.NumberType.INT) { [EOL]                     return nodeFactory.numberNode(jp.getIntValue()); [EOL]                 } [EOL]                 return nodeFactory.numberNode(jp.getLongValue()); [EOL]             } [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             { [EOL]                 JsonParser.NumberType nt = jp.getNumberType(); [EOL]                 if (nt == JsonParser.NumberType.BIG_DECIMAL || ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                     return nodeFactory.numberNode(jp.getDecimalValue()); [EOL]                 } [EOL]                 return nodeFactory.numberNode(jp.getDoubleValue()); [EOL]             } [EOL]         case VALUE_TRUE: [EOL]             return nodeFactory.booleanNode(true); [EOL]         case VALUE_FALSE: [EOL]             return nodeFactory.booleanNode(false); [EOL]         case VALUE_NULL: [EOL]             return nodeFactory.nullNode(); [EOL]         default: [EOL]             throw ctxt.mappingException(getValueClass()); [EOL]     } [EOL] }
protected final JsonNode deserializeAny(JsonParser jp, DeserializationContext ctxt, final JsonNodeFactory nodeFactory) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return deserializeObject(jp, ctxt, nodeFactory); [EOL]         case START_ARRAY: [EOL]             return deserializeArray(jp, ctxt, nodeFactory); [EOL]         case FIELD_NAME: [EOL]             return deserializeObject(jp, ctxt, nodeFactory); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             { [EOL]                 Object ob = jp.getEmbeddedObject(); [EOL]                 if (ob == null) { [EOL]                     return nodeFactory.nullNode(); [EOL]                 } [EOL]                 Class<?> type = ob.getClass(); [EOL]                 if (type == byte[].class) { [EOL]                     return nodeFactory.binaryNode((byte[]) ob); [EOL]                 } [EOL]                 return nodeFactory.POJONode(ob); [EOL]             } [EOL]         case VALUE_STRING: [EOL]             return nodeFactory.textNode(jp.getText()); [EOL]         case VALUE_NUMBER_INT: [EOL]             { [EOL]                 JsonParser.NumberType nt = jp.getNumberType(); [EOL]                 if (nt == JsonParser.NumberType.BIG_INTEGER || ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                     return nodeFactory.numberNode(jp.getBigIntegerValue()); [EOL]                 } [EOL]                 if (nt == JsonParser.NumberType.INT) { [EOL]                     return nodeFactory.numberNode(jp.getIntValue()); [EOL]                 } [EOL]                 return nodeFactory.numberNode(jp.getLongValue()); [EOL]             } [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             { [EOL]                 JsonParser.NumberType nt = jp.getNumberType(); [EOL]                 if (nt == JsonParser.NumberType.BIG_DECIMAL || ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                     return nodeFactory.numberNode(jp.getDecimalValue()); [EOL]                 } [EOL]                 return nodeFactory.numberNode(jp.getDoubleValue()); [EOL]             } [EOL]         case VALUE_TRUE: [EOL]             return nodeFactory.booleanNode(true); [EOL]         case VALUE_FALSE: [EOL]             return nodeFactory.booleanNode(false); [EOL]         case VALUE_NULL: [EOL]             return nodeFactory.nullNode(); [EOL]         default: [EOL]             throw ctxt.mappingException(getValueClass()); [EOL]     } [EOL] }
protected final JsonNode deserializeAny(JsonParser jp, DeserializationContext ctxt, final JsonNodeFactory nodeFactory) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return deserializeObject(jp, ctxt, nodeFactory); [EOL]         case START_ARRAY: [EOL]             return deserializeArray(jp, ctxt, nodeFactory); [EOL]         case FIELD_NAME: [EOL]             return deserializeObject(jp, ctxt, nodeFactory); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             { [EOL]                 Object ob = jp.getEmbeddedObject(); [EOL]                 if (ob == null) { [EOL]                     return nodeFactory.nullNode(); [EOL]                 } [EOL]                 Class<?> type = ob.getClass(); [EOL]                 if (type == byte[].class) { [EOL]                     return nodeFactory.binaryNode((byte[]) ob); [EOL]                 } [EOL]                 return nodeFactory.POJONode(ob); [EOL]             } [EOL]         case VALUE_STRING: [EOL]             return nodeFactory.textNode(jp.getText()); [EOL]         case VALUE_NUMBER_INT: [EOL]             { [EOL]                 JsonParser.NumberType nt = jp.getNumberType(); [EOL]                 if (nt == JsonParser.NumberType.BIG_INTEGER || ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                     return nodeFactory.numberNode(jp.getBigIntegerValue()); [EOL]                 } [EOL]                 if (nt == JsonParser.NumberType.INT) { [EOL]                     return nodeFactory.numberNode(jp.getIntValue()); [EOL]                 } [EOL]                 return nodeFactory.numberNode(jp.getLongValue()); [EOL]             } [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             { [EOL]                 JsonParser.NumberType nt = jp.getNumberType(); [EOL]                 if (nt == JsonParser.NumberType.BIG_DECIMAL || ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                     return nodeFactory.numberNode(jp.getDecimalValue()); [EOL]                 } [EOL]                 return nodeFactory.numberNode(jp.getDoubleValue()); [EOL]             } [EOL]         case VALUE_TRUE: [EOL]             return nodeFactory.booleanNode(true); [EOL]         case VALUE_FALSE: [EOL]             return nodeFactory.booleanNode(false); [EOL]         case VALUE_NULL: [EOL]             return nodeFactory.nullNode(); [EOL]         default: [EOL]             throw ctxt.mappingException(getValueClass()); [EOL]     } [EOL] }
@Override [EOL] public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     JsonDeserializer<Object> custom = _findCustomBeanDeserializer(type, config, beanDesc); [EOL]     if (custom != null) { [EOL]         return custom; [EOL]     } [EOL]     if (type.isThrowable()) { [EOL]         return buildThrowableDeserializer(ctxt, type, beanDesc); [EOL]     } [EOL]     if (type.isAbstract()) { [EOL]         JavaType concreteType = materializeAbstractType(ctxt, type, beanDesc); [EOL]         if (concreteType != null) { [EOL]             beanDesc = config.introspect(concreteType); [EOL]             return buildBeanDeserializer(ctxt, concreteType, beanDesc); [EOL]         } [EOL]     } [EOL]     @SuppressWarnings("unchecked") [EOL]     JsonDeserializer<Object> deser = (JsonDeserializer<Object>) findStdDeserializer(ctxt, type, beanDesc); [EOL]     if (deser != null) { [EOL]         return deser; [EOL]     } [EOL]     if (!isPotentialBeanType(type.getRawClass())) { [EOL]         return null; [EOL]     } [EOL]     return buildBeanDeserializer(ctxt, type, beanDesc); [EOL] } public BeanDeserializerFactory(DeserializerFactoryConfig config); public DeserializerFactory withConfig(DeserializerFactoryConfig config); protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription beanDesc, Class<?> builderClass) throws JsonMappingException; protected JsonDeserializer<?> findStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> findOptionalStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JavaType materializeAbstractType(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException; protected void addObjectIdReader(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; public JsonDeserializer<Object> buildThrowableDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected BeanDeserializerBuilder constructBeanDeserializerBuilder(DeserializationContext ctxt, BeanDescription beanDesc); protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected List<BeanPropertyDefinition> filterBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder, List<BeanPropertyDefinition> propDefsIn, Set<String> ignored) throws JsonMappingException; protected void addReferenceProperties(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected void addInjectables(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected SettableAnyProperty constructAnySetter(DeserializationContext ctxt, BeanDescription beanDesc, AnnotatedMethod setter) throws JsonMappingException; protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef, Type jdkType) throws JsonMappingException; protected SettableBeanProperty constructSetterlessProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef) throws JsonMappingException; protected boolean isPotentialBeanType(Class<?> type); protected boolean isIgnorableType(DeserializationConfig config, BeanDescription beanDesc, Class<?> type, Map<Class<?>, Boolean> ignoredTypes); long serialVersionUID=Optional[1]; Class<?>[] INIT_CAUSE_PARAMS=Optional[new Class<?>[] { Throwable.class }
protected JsonDeserializer<?> findStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     JsonDeserializer<?> deser = findDefaultDeserializer(ctxt, type, beanDesc); [EOL]     if (deser != null) { [EOL]         return deser; [EOL]     } [EOL]     Class<?> cls = type.getRawClass(); [EOL]     if (AtomicReference.class.isAssignableFrom(cls)) { [EOL]         TypeFactory tf = ctxt.getTypeFactory(); [EOL]         JavaType[] params = tf.findTypeParameters(type, AtomicReference.class); [EOL]         JavaType referencedType; [EOL]         if (params == null || params.length < 1) { [EOL]             referencedType = TypeFactory.unknownType(); [EOL]         } else { [EOL]             referencedType = params[0]; [EOL]         } [EOL]         return new JdkDeserializers.AtomicReferenceDeserializer(referencedType); [EOL]     } [EOL]     return findOptionalStdDeserializer(ctxt, type, beanDesc); [EOL] } public BeanDeserializerFactory(DeserializerFactoryConfig config); public DeserializerFactory withConfig(DeserializerFactoryConfig config); protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription beanDesc, Class<?> builderClass) throws JsonMappingException; protected JsonDeserializer<?> findStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> findOptionalStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JavaType materializeAbstractType(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException; protected void addObjectIdReader(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; public JsonDeserializer<Object> buildThrowableDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected BeanDeserializerBuilder constructBeanDeserializerBuilder(DeserializationContext ctxt, BeanDescription beanDesc); protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected List<BeanPropertyDefinition> filterBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder, List<BeanPropertyDefinition> propDefsIn, Set<String> ignored) throws JsonMappingException; protected void addReferenceProperties(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected void addInjectables(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected SettableAnyProperty constructAnySetter(DeserializationContext ctxt, BeanDescription beanDesc, AnnotatedMethod setter) throws JsonMappingException; protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef, Type jdkType) throws JsonMappingException; protected SettableBeanProperty constructSetterlessProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef) throws JsonMappingException; protected boolean isPotentialBeanType(Class<?> type); protected boolean isIgnorableType(DeserializationConfig config, BeanDescription beanDesc, Class<?> type, Map<Class<?>, Boolean> ignoredTypes); long serialVersionUID=Optional[1]; Class<?>[] INIT_CAUSE_PARAMS=Optional[new Class<?>[] { Throwable.class }
protected JavaType materializeAbstractType(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     final JavaType abstractType = beanDesc.getType(); [EOL]     for (AbstractTypeResolver r : _factoryConfig.abstractTypeResolvers()) { [EOL]         JavaType concrete = r.resolveAbstractType(ctxt.getConfig(), abstractType); [EOL]         if (concrete != null) { [EOL]             return concrete; [EOL]         } [EOL]     } [EOL]     return null; [EOL] } public BeanDeserializerFactory(DeserializerFactoryConfig config); public DeserializerFactory withConfig(DeserializerFactoryConfig config); protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription beanDesc, Class<?> builderClass) throws JsonMappingException; protected JsonDeserializer<?> findStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> findOptionalStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JavaType materializeAbstractType(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException; protected void addObjectIdReader(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; public JsonDeserializer<Object> buildThrowableDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected BeanDeserializerBuilder constructBeanDeserializerBuilder(DeserializationContext ctxt, BeanDescription beanDesc); protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected List<BeanPropertyDefinition> filterBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder, List<BeanPropertyDefinition> propDefsIn, Set<String> ignored) throws JsonMappingException; protected void addReferenceProperties(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected void addInjectables(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected SettableAnyProperty constructAnySetter(DeserializationContext ctxt, BeanDescription beanDesc, AnnotatedMethod setter) throws JsonMappingException; protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef, Type jdkType) throws JsonMappingException; protected SettableBeanProperty constructSetterlessProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef) throws JsonMappingException; protected boolean isPotentialBeanType(Class<?> type); protected boolean isIgnorableType(DeserializationConfig config, BeanDescription beanDesc, Class<?> type, Map<Class<?>, Boolean> ignoredTypes); long serialVersionUID=Optional[1]; Class<?>[] INIT_CAUSE_PARAMS=Optional[new Class<?>[] { Throwable.class }
protected void addObjectIdReader(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException { [EOL]     ObjectIdInfo objectIdInfo = beanDesc.getObjectIdInfo(); [EOL]     if (objectIdInfo == null) { [EOL]         return; [EOL]     } [EOL]     Class<?> implClass = objectIdInfo.getGeneratorType(); [EOL]     JavaType idType; [EOL]     SettableBeanProperty idProp; [EOL]     ObjectIdGenerator<?> gen; [EOL]     if (implClass == ObjectIdGenerators.PropertyGenerator.class) { [EOL]         String propName = objectIdInfo.getPropertyName(); [EOL]         idProp = builder.findProperty(propName); [EOL]         if (idProp == null) { [EOL]             throw new IllegalArgumentException("Invalid Object Id definition for " + beanDesc.getBeanClass().getName() + ": can not find property with name '" + propName + "'"); [EOL]         } [EOL]         idType = idProp.getType(); [EOL]         gen = new PropertyBasedObjectIdGenerator(objectIdInfo.getScope()); [EOL]     } else { [EOL]         JavaType type = ctxt.constructType(implClass); [EOL]         idType = ctxt.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0]; [EOL]         idProp = null; [EOL]         gen = ctxt.objectIdGeneratorInstance(beanDesc.getClassInfo(), objectIdInfo); [EOL]     } [EOL]     JsonDeserializer<?> deser = ctxt.findRootValueDeserializer(idType); [EOL]     builder.setObjectIdReader(ObjectIdReader.construct(idType, objectIdInfo.getPropertyName(), gen, deser, idProp)); [EOL] } public BeanDeserializerFactory(DeserializerFactoryConfig config); public DeserializerFactory withConfig(DeserializerFactoryConfig config); protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription beanDesc, Class<?> builderClass) throws JsonMappingException; protected JsonDeserializer<?> findStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> findOptionalStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JavaType materializeAbstractType(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException; protected void addObjectIdReader(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; public JsonDeserializer<Object> buildThrowableDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected BeanDeserializerBuilder constructBeanDeserializerBuilder(DeserializationContext ctxt, BeanDescription beanDesc); protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected List<BeanPropertyDefinition> filterBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder, List<BeanPropertyDefinition> propDefsIn, Set<String> ignored) throws JsonMappingException; protected void addReferenceProperties(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected void addInjectables(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected SettableAnyProperty constructAnySetter(DeserializationContext ctxt, BeanDescription beanDesc, AnnotatedMethod setter) throws JsonMappingException; protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef, Type jdkType) throws JsonMappingException; protected SettableBeanProperty constructSetterlessProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef) throws JsonMappingException; protected boolean isPotentialBeanType(Class<?> type); protected boolean isIgnorableType(DeserializationConfig config, BeanDescription beanDesc, Class<?> type, Map<Class<?>, Boolean> ignoredTypes); long serialVersionUID=Optional[1]; Class<?>[] INIT_CAUSE_PARAMS=Optional[new Class<?>[] { Throwable.class }
protected void addObjectIdReader(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException { [EOL]     ObjectIdInfo objectIdInfo = beanDesc.getObjectIdInfo(); [EOL]     if (objectIdInfo == null) { [EOL]         return; [EOL]     } [EOL]     Class<?> implClass = objectIdInfo.getGeneratorType(); [EOL]     JavaType idType; [EOL]     SettableBeanProperty idProp; [EOL]     ObjectIdGenerator<?> gen; [EOL]     if (implClass == ObjectIdGenerators.PropertyGenerator.class) { [EOL]         String propName = objectIdInfo.getPropertyName(); [EOL]         idProp = builder.findProperty(propName); [EOL]         if (idProp == null) { [EOL]             throw new IllegalArgumentException("Invalid Object Id definition for " + beanDesc.getBeanClass().getName() + ": can not find property with name '" + propName + "'"); [EOL]         } [EOL]         idType = idProp.getType(); [EOL]         gen = new PropertyBasedObjectIdGenerator(objectIdInfo.getScope()); [EOL]     } else { [EOL]         JavaType type = ctxt.constructType(implClass); [EOL]         idType = ctxt.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0]; [EOL]         idProp = null; [EOL]         gen = ctxt.objectIdGeneratorInstance(beanDesc.getClassInfo(), objectIdInfo); [EOL]     } [EOL]     JsonDeserializer<?> deser = ctxt.findRootValueDeserializer(idType); [EOL]     builder.setObjectIdReader(ObjectIdReader.construct(idType, objectIdInfo.getPropertyName(), gen, deser, idProp)); [EOL] } public BeanDeserializerFactory(DeserializerFactoryConfig config); public DeserializerFactory withConfig(DeserializerFactoryConfig config); protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription beanDesc, Class<?> builderClass) throws JsonMappingException; protected JsonDeserializer<?> findStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> findOptionalStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JavaType materializeAbstractType(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException; protected void addObjectIdReader(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; public JsonDeserializer<Object> buildThrowableDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected BeanDeserializerBuilder constructBeanDeserializerBuilder(DeserializationContext ctxt, BeanDescription beanDesc); protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected List<BeanPropertyDefinition> filterBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder, List<BeanPropertyDefinition> propDefsIn, Set<String> ignored) throws JsonMappingException; protected void addReferenceProperties(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected void addInjectables(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected SettableAnyProperty constructAnySetter(DeserializationContext ctxt, BeanDescription beanDesc, AnnotatedMethod setter) throws JsonMappingException; protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef, Type jdkType) throws JsonMappingException; protected SettableBeanProperty constructSetterlessProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef) throws JsonMappingException; protected boolean isPotentialBeanType(Class<?> type); protected boolean isIgnorableType(DeserializationConfig config, BeanDescription beanDesc, Class<?> type, Map<Class<?>, Boolean> ignoredTypes); long serialVersionUID=Optional[1]; Class<?>[] INIT_CAUSE_PARAMS=Optional[new Class<?>[] { Throwable.class }
protected void addObjectIdReader(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException { [EOL]     ObjectIdInfo objectIdInfo = beanDesc.getObjectIdInfo(); [EOL]     if (objectIdInfo == null) { [EOL]         return; [EOL]     } [EOL]     Class<?> implClass = objectIdInfo.getGeneratorType(); [EOL]     JavaType idType; [EOL]     SettableBeanProperty idProp; [EOL]     ObjectIdGenerator<?> gen; [EOL]     if (implClass == ObjectIdGenerators.PropertyGenerator.class) { [EOL]         String propName = objectIdInfo.getPropertyName(); [EOL]         idProp = builder.findProperty(propName); [EOL]         if (idProp == null) { [EOL]             throw new IllegalArgumentException("Invalid Object Id definition for " + beanDesc.getBeanClass().getName() + ": can not find property with name '" + propName + "'"); [EOL]         } [EOL]         idType = idProp.getType(); [EOL]         gen = new PropertyBasedObjectIdGenerator(objectIdInfo.getScope()); [EOL]     } else { [EOL]         JavaType type = ctxt.constructType(implClass); [EOL]         idType = ctxt.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0]; [EOL]         idProp = null; [EOL]         gen = ctxt.objectIdGeneratorInstance(beanDesc.getClassInfo(), objectIdInfo); [EOL]     } [EOL]     JsonDeserializer<?> deser = ctxt.findRootValueDeserializer(idType); [EOL]     builder.setObjectIdReader(ObjectIdReader.construct(idType, objectIdInfo.getPropertyName(), gen, deser, idProp)); [EOL] } public BeanDeserializerFactory(DeserializerFactoryConfig config); public DeserializerFactory withConfig(DeserializerFactoryConfig config); protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription beanDesc, Class<?> builderClass) throws JsonMappingException; protected JsonDeserializer<?> findStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> findOptionalStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JavaType materializeAbstractType(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException; protected void addObjectIdReader(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; public JsonDeserializer<Object> buildThrowableDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected BeanDeserializerBuilder constructBeanDeserializerBuilder(DeserializationContext ctxt, BeanDescription beanDesc); protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected List<BeanPropertyDefinition> filterBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder, List<BeanPropertyDefinition> propDefsIn, Set<String> ignored) throws JsonMappingException; protected void addReferenceProperties(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected void addInjectables(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected SettableAnyProperty constructAnySetter(DeserializationContext ctxt, BeanDescription beanDesc, AnnotatedMethod setter) throws JsonMappingException; protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef, Type jdkType) throws JsonMappingException; protected SettableBeanProperty constructSetterlessProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef) throws JsonMappingException; protected boolean isPotentialBeanType(Class<?> type); protected boolean isIgnorableType(DeserializationConfig config, BeanDescription beanDesc, Class<?> type, Map<Class<?>, Boolean> ignoredTypes); long serialVersionUID=Optional[1]; Class<?>[] INIT_CAUSE_PARAMS=Optional[new Class<?>[] { Throwable.class }
protected void addObjectIdReader(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException { [EOL]     ObjectIdInfo objectIdInfo = beanDesc.getObjectIdInfo(); [EOL]     if (objectIdInfo == null) { [EOL]         return; [EOL]     } [EOL]     Class<?> implClass = objectIdInfo.getGeneratorType(); [EOL]     JavaType idType; [EOL]     SettableBeanProperty idProp; [EOL]     ObjectIdGenerator<?> gen; [EOL]     if (implClass == ObjectIdGenerators.PropertyGenerator.class) { [EOL]         String propName = objectIdInfo.getPropertyName(); [EOL]         idProp = builder.findProperty(propName); [EOL]         if (idProp == null) { [EOL]             throw new IllegalArgumentException("Invalid Object Id definition for " + beanDesc.getBeanClass().getName() + ": can not find property with name '" + propName + "'"); [EOL]         } [EOL]         idType = idProp.getType(); [EOL]         gen = new PropertyBasedObjectIdGenerator(objectIdInfo.getScope()); [EOL]     } else { [EOL]         JavaType type = ctxt.constructType(implClass); [EOL]         idType = ctxt.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0]; [EOL]         idProp = null; [EOL]         gen = ctxt.objectIdGeneratorInstance(beanDesc.getClassInfo(), objectIdInfo); [EOL]     } [EOL]     JsonDeserializer<?> deser = ctxt.findRootValueDeserializer(idType); [EOL]     builder.setObjectIdReader(ObjectIdReader.construct(idType, objectIdInfo.getPropertyName(), gen, deser, idProp)); [EOL] } public BeanDeserializerFactory(DeserializerFactoryConfig config); public DeserializerFactory withConfig(DeserializerFactoryConfig config); protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription beanDesc, Class<?> builderClass) throws JsonMappingException; protected JsonDeserializer<?> findStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> findOptionalStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JavaType materializeAbstractType(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException; protected void addObjectIdReader(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; public JsonDeserializer<Object> buildThrowableDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected BeanDeserializerBuilder constructBeanDeserializerBuilder(DeserializationContext ctxt, BeanDescription beanDesc); protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected List<BeanPropertyDefinition> filterBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder, List<BeanPropertyDefinition> propDefsIn, Set<String> ignored) throws JsonMappingException; protected void addReferenceProperties(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected void addInjectables(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected SettableAnyProperty constructAnySetter(DeserializationContext ctxt, BeanDescription beanDesc, AnnotatedMethod setter) throws JsonMappingException; protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef, Type jdkType) throws JsonMappingException; protected SettableBeanProperty constructSetterlessProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef) throws JsonMappingException; protected boolean isPotentialBeanType(Class<?> type); protected boolean isIgnorableType(DeserializationConfig config, BeanDescription beanDesc, Class<?> type, Map<Class<?>, Boolean> ignoredTypes); long serialVersionUID=Optional[1]; Class<?>[] INIT_CAUSE_PARAMS=Optional[new Class<?>[] { Throwable.class }
protected void addReferenceProperties(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException { [EOL]     Map<String, AnnotatedMember> refs = beanDesc.findBackReferenceProperties(); [EOL]     if (refs != null) { [EOL]         for (Map.Entry<String, AnnotatedMember> en : refs.entrySet()) { [EOL]             String name = en.getKey(); [EOL]             AnnotatedMember m = en.getValue(); [EOL]             Type genericType; [EOL]             if (m instanceof AnnotatedMethod) { [EOL]                 genericType = ((AnnotatedMethod) m).getGenericParameterType(0); [EOL]             } else { [EOL]                 genericType = m.getRawType(); [EOL]             } [EOL]             SimpleBeanPropertyDefinition propDef = SimpleBeanPropertyDefinition.construct(ctxt.getConfig(), m); [EOL]             builder.addBackReferenceProperty(name, constructSettableProperty(ctxt, beanDesc, propDef, genericType)); [EOL]         } [EOL]     } [EOL] } public BeanDeserializerFactory(DeserializerFactoryConfig config); public DeserializerFactory withConfig(DeserializerFactoryConfig config); protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription beanDesc, Class<?> builderClass) throws JsonMappingException; protected JsonDeserializer<?> findStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> findOptionalStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JavaType materializeAbstractType(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException; protected void addObjectIdReader(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; public JsonDeserializer<Object> buildThrowableDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected BeanDeserializerBuilder constructBeanDeserializerBuilder(DeserializationContext ctxt, BeanDescription beanDesc); protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected List<BeanPropertyDefinition> filterBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder, List<BeanPropertyDefinition> propDefsIn, Set<String> ignored) throws JsonMappingException; protected void addReferenceProperties(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected void addInjectables(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected SettableAnyProperty constructAnySetter(DeserializationContext ctxt, BeanDescription beanDesc, AnnotatedMethod setter) throws JsonMappingException; protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef, Type jdkType) throws JsonMappingException; protected SettableBeanProperty constructSetterlessProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef) throws JsonMappingException; protected boolean isPotentialBeanType(Class<?> type); protected boolean isIgnorableType(DeserializationConfig config, BeanDescription beanDesc, Class<?> type, Map<Class<?>, Boolean> ignoredTypes); long serialVersionUID=Optional[1]; Class<?>[] INIT_CAUSE_PARAMS=Optional[new Class<?>[] { Throwable.class }
public SimpleFilterProvider setDefaultFilter(BeanPropertyFilter f) { [EOL]     _defaultFilter = f; [EOL]     return this; [EOL] }
public SimpleFilterProvider setDefaultFilter(BeanPropertyFilter f) { [EOL]     _defaultFilter = f; [EOL]     return this; [EOL] }
@Override [EOL] public BeanPropertyFilter findFilter(Object filterId) { [EOL]     BeanPropertyFilter f = _filtersById.get(filterId); [EOL]     if (f == null) { [EOL]         f = _defaultFilter; [EOL]         if (f == null && _cfgFailOnUnknownId) { [EOL]             throw new IllegalArgumentException("No filter configured with id '" + filterId + "' (type " + filterId.getClass().getName() + ")"); [EOL]         } [EOL]     } [EOL]     return f; [EOL] }
@Override [EOL] public BeanPropertyFilter findFilter(Object filterId) { [EOL]     BeanPropertyFilter f = _filtersById.get(filterId); [EOL]     if (f == null) { [EOL]         f = _defaultFilter; [EOL]         if (f == null && _cfgFailOnUnknownId) { [EOL]             throw new IllegalArgumentException("No filter configured with id '" + filterId + "' (type " + filterId.getClass().getName() + ")"); [EOL]         } [EOL]     } [EOL]     return f; [EOL] }
@Override [EOL] public BeanPropertyFilter findFilter(Object filterId) { [EOL]     BeanPropertyFilter f = _filtersById.get(filterId); [EOL]     if (f == null) { [EOL]         f = _defaultFilter; [EOL]         if (f == null && _cfgFailOnUnknownId) { [EOL]             throw new IllegalArgumentException("No filter configured with id '" + filterId + "' (type " + filterId.getClass().getName() + ")"); [EOL]         } [EOL]     } [EOL]     return f; [EOL] }
@Override [EOL] public final SerializerFactory withAdditionalKeySerializers(Serializers additional) { [EOL]     return withConfig(_factoryConfig.withAdditionalKeySerializers(additional)); [EOL] }
@Override [EOL] public final SerializerFactory withAdditionalKeySerializers(Serializers additional) { [EOL]     return withConfig(_factoryConfig.withAdditionalKeySerializers(additional)); [EOL] }
@Override [EOL] @SuppressWarnings("unchecked") [EOL] public JsonSerializer<Object> createKeySerializer(SerializationConfig config, JavaType keyType, JsonSerializer<Object> defaultImpl) { [EOL]     BeanDescription beanDesc = config.introspectClassAnnotations(keyType.getRawClass()); [EOL]     JsonSerializer<?> ser = null; [EOL]     if (_factoryConfig.hasKeySerializers()) { [EOL]         for (Serializers serializers : _factoryConfig.keySerializers()) { [EOL]             ser = serializers.findSerializer(config, keyType, beanDesc); [EOL]             if (ser != null) { [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         ser = defaultImpl; [EOL]         if (ser == null) { [EOL]             ser = StdKeySerializers.getStdKeySerializer(keyType); [EOL]         } [EOL]     } [EOL]     if (_factoryConfig.hasSerializerModifiers()) { [EOL]         for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]             ser = mod.modifyKeySerializer(config, keyType, beanDesc, ser); [EOL]         } [EOL]     } [EOL]     return (JsonSerializer<Object>) ser; [EOL] }
@Override [EOL] @SuppressWarnings("unchecked") [EOL] public JsonSerializer<Object> createKeySerializer(SerializationConfig config, JavaType keyType, JsonSerializer<Object> defaultImpl) { [EOL]     BeanDescription beanDesc = config.introspectClassAnnotations(keyType.getRawClass()); [EOL]     JsonSerializer<?> ser = null; [EOL]     if (_factoryConfig.hasKeySerializers()) { [EOL]         for (Serializers serializers : _factoryConfig.keySerializers()) { [EOL]             ser = serializers.findSerializer(config, keyType, beanDesc); [EOL]             if (ser != null) { [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         ser = defaultImpl; [EOL]         if (ser == null) { [EOL]             ser = StdKeySerializers.getStdKeySerializer(keyType); [EOL]         } [EOL]     } [EOL]     if (_factoryConfig.hasSerializerModifiers()) { [EOL]         for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]             ser = mod.modifyKeySerializer(config, keyType, beanDesc, ser); [EOL]         } [EOL]     } [EOL]     return (JsonSerializer<Object>) ser; [EOL] }
@Override [EOL] @SuppressWarnings("unchecked") [EOL] public JsonSerializer<Object> createKeySerializer(SerializationConfig config, JavaType keyType, JsonSerializer<Object> defaultImpl) { [EOL]     BeanDescription beanDesc = config.introspectClassAnnotations(keyType.getRawClass()); [EOL]     JsonSerializer<?> ser = null; [EOL]     if (_factoryConfig.hasKeySerializers()) { [EOL]         for (Serializers serializers : _factoryConfig.keySerializers()) { [EOL]             ser = serializers.findSerializer(config, keyType, beanDesc); [EOL]             if (ser != null) { [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         ser = defaultImpl; [EOL]         if (ser == null) { [EOL]             ser = StdKeySerializers.getStdKeySerializer(keyType); [EOL]         } [EOL]     } [EOL]     if (_factoryConfig.hasSerializerModifiers()) { [EOL]         for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]             ser = mod.modifyKeySerializer(config, keyType, beanDesc, ser); [EOL]         } [EOL]     } [EOL]     return (JsonSerializer<Object>) ser; [EOL] }
@Override [EOL] @SuppressWarnings("unchecked") [EOL] public JsonSerializer<Object> createKeySerializer(SerializationConfig config, JavaType keyType, JsonSerializer<Object> defaultImpl) { [EOL]     BeanDescription beanDesc = config.introspectClassAnnotations(keyType.getRawClass()); [EOL]     JsonSerializer<?> ser = null; [EOL]     if (_factoryConfig.hasKeySerializers()) { [EOL]         for (Serializers serializers : _factoryConfig.keySerializers()) { [EOL]             ser = serializers.findSerializer(config, keyType, beanDesc); [EOL]             if (ser != null) { [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         ser = defaultImpl; [EOL]         if (ser == null) { [EOL]             ser = StdKeySerializers.getStdKeySerializer(keyType); [EOL]         } [EOL]     } [EOL]     if (_factoryConfig.hasSerializerModifiers()) { [EOL]         for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]             ser = mod.modifyKeySerializer(config, keyType, beanDesc, ser); [EOL]         } [EOL]     } [EOL]     return (JsonSerializer<Object>) ser; [EOL] }
@Override [EOL] public TypeSerializer createTypeSerializer(SerializationConfig config, JavaType baseType) { [EOL]     BeanDescription bean = config.introspectClassAnnotations(baseType.getRawClass()); [EOL]     AnnotatedClass ac = bean.getClassInfo(); [EOL]     AnnotationIntrospector ai = config.getAnnotationIntrospector(); [EOL]     TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType); [EOL]     Collection<NamedType> subtypes = null; [EOL]     if (b == null) { [EOL]         b = config.getDefaultTyper(baseType); [EOL]     } else { [EOL]         subtypes = config.getSubtypeResolver().collectAndResolveSubtypes(ac, config, ai); [EOL]     } [EOL]     if (b == null) { [EOL]         return null; [EOL]     } [EOL]     return b.buildTypeSerializer(config, baseType, subtypes); [EOL] }
@Override [EOL] public TypeSerializer createTypeSerializer(SerializationConfig config, JavaType baseType) { [EOL]     BeanDescription bean = config.introspectClassAnnotations(baseType.getRawClass()); [EOL]     AnnotatedClass ac = bean.getClassInfo(); [EOL]     AnnotationIntrospector ai = config.getAnnotationIntrospector(); [EOL]     TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType); [EOL]     Collection<NamedType> subtypes = null; [EOL]     if (b == null) { [EOL]         b = config.getDefaultTyper(baseType); [EOL]     } else { [EOL]         subtypes = config.getSubtypeResolver().collectAndResolveSubtypes(ac, config, ai); [EOL]     } [EOL]     if (b == null) { [EOL]         return null; [EOL]     } [EOL]     return b.buildTypeSerializer(config, baseType, subtypes); [EOL] }
@Override [EOL] public TypeSerializer createTypeSerializer(SerializationConfig config, JavaType baseType) { [EOL]     BeanDescription bean = config.introspectClassAnnotations(baseType.getRawClass()); [EOL]     AnnotatedClass ac = bean.getClassInfo(); [EOL]     AnnotationIntrospector ai = config.getAnnotationIntrospector(); [EOL]     TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType); [EOL]     Collection<NamedType> subtypes = null; [EOL]     if (b == null) { [EOL]         b = config.getDefaultTyper(baseType); [EOL]     } else { [EOL]         subtypes = config.getSubtypeResolver().collectAndResolveSubtypes(ac, config, ai); [EOL]     } [EOL]     if (b == null) { [EOL]         return null; [EOL]     } [EOL]     return b.buildTypeSerializer(config, baseType, subtypes); [EOL] }
protected final JsonSerializer<?> findSerializerByPrimaryType(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     if (InetAddress.class.isAssignableFrom(raw)) { [EOL]         return InetAddressSerializer.instance; [EOL]     } [EOL]     if (TimeZone.class.isAssignableFrom(raw)) { [EOL]         return TimeZoneSerializer.instance; [EOL]     } [EOL]     if (java.nio.charset.Charset.class.isAssignableFrom(raw)) { [EOL]         return ToStringSerializer.instance; [EOL]     } [EOL]     JsonSerializer<?> ser = findOptionalStdSerializer(prov, type, beanDesc, staticTyping); [EOL]     if (ser != null) { [EOL]         return ser; [EOL]     } [EOL]     if (Number.class.isAssignableFrom(raw)) { [EOL]         return NumberSerializers.NumberSerializer.instance; [EOL]     } [EOL]     if (Enum.class.isAssignableFrom(raw)) { [EOL]         return buildEnumSerializer(prov.getConfig(), type, beanDesc); [EOL]     } [EOL]     if (Calendar.class.isAssignableFrom(raw)) { [EOL]         return CalendarSerializer.instance; [EOL]     } [EOL]     if (java.util.Date.class.isAssignableFrom(raw)) { [EOL]         return DateSerializer.instance; [EOL]     } [EOL]     return null; [EOL] }
protected final JsonSerializer<?> findSerializerByPrimaryType(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     if (InetAddress.class.isAssignableFrom(raw)) { [EOL]         return InetAddressSerializer.instance; [EOL]     } [EOL]     if (TimeZone.class.isAssignableFrom(raw)) { [EOL]         return TimeZoneSerializer.instance; [EOL]     } [EOL]     if (java.nio.charset.Charset.class.isAssignableFrom(raw)) { [EOL]         return ToStringSerializer.instance; [EOL]     } [EOL]     JsonSerializer<?> ser = findOptionalStdSerializer(prov, type, beanDesc, staticTyping); [EOL]     if (ser != null) { [EOL]         return ser; [EOL]     } [EOL]     if (Number.class.isAssignableFrom(raw)) { [EOL]         return NumberSerializers.NumberSerializer.instance; [EOL]     } [EOL]     if (Enum.class.isAssignableFrom(raw)) { [EOL]         return buildEnumSerializer(prov.getConfig(), type, beanDesc); [EOL]     } [EOL]     if (Calendar.class.isAssignableFrom(raw)) { [EOL]         return CalendarSerializer.instance; [EOL]     } [EOL]     if (java.util.Date.class.isAssignableFrom(raw)) { [EOL]         return DateSerializer.instance; [EOL]     } [EOL]     return null; [EOL] }
protected final JsonSerializer<?> findSerializerByPrimaryType(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     if (InetAddress.class.isAssignableFrom(raw)) { [EOL]         return InetAddressSerializer.instance; [EOL]     } [EOL]     if (TimeZone.class.isAssignableFrom(raw)) { [EOL]         return TimeZoneSerializer.instance; [EOL]     } [EOL]     if (java.nio.charset.Charset.class.isAssignableFrom(raw)) { [EOL]         return ToStringSerializer.instance; [EOL]     } [EOL]     JsonSerializer<?> ser = findOptionalStdSerializer(prov, type, beanDesc, staticTyping); [EOL]     if (ser != null) { [EOL]         return ser; [EOL]     } [EOL]     if (Number.class.isAssignableFrom(raw)) { [EOL]         return NumberSerializers.NumberSerializer.instance; [EOL]     } [EOL]     if (Enum.class.isAssignableFrom(raw)) { [EOL]         return buildEnumSerializer(prov.getConfig(), type, beanDesc); [EOL]     } [EOL]     if (Calendar.class.isAssignableFrom(raw)) { [EOL]         return CalendarSerializer.instance; [EOL]     } [EOL]     if (java.util.Date.class.isAssignableFrom(raw)) { [EOL]         return DateSerializer.instance; [EOL]     } [EOL]     return null; [EOL] }
protected final JsonSerializer<?> findSerializerByPrimaryType(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     if (InetAddress.class.isAssignableFrom(raw)) { [EOL]         return InetAddressSerializer.instance; [EOL]     } [EOL]     if (TimeZone.class.isAssignableFrom(raw)) { [EOL]         return TimeZoneSerializer.instance; [EOL]     } [EOL]     if (java.nio.charset.Charset.class.isAssignableFrom(raw)) { [EOL]         return ToStringSerializer.instance; [EOL]     } [EOL]     JsonSerializer<?> ser = findOptionalStdSerializer(prov, type, beanDesc, staticTyping); [EOL]     if (ser != null) { [EOL]         return ser; [EOL]     } [EOL]     if (Number.class.isAssignableFrom(raw)) { [EOL]         return NumberSerializers.NumberSerializer.instance; [EOL]     } [EOL]     if (Enum.class.isAssignableFrom(raw)) { [EOL]         return buildEnumSerializer(prov.getConfig(), type, beanDesc); [EOL]     } [EOL]     if (Calendar.class.isAssignableFrom(raw)) { [EOL]         return CalendarSerializer.instance; [EOL]     } [EOL]     if (java.util.Date.class.isAssignableFrom(raw)) { [EOL]         return DateSerializer.instance; [EOL]     } [EOL]     return null; [EOL] }
protected final JsonSerializer<?> findSerializerByPrimaryType(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     if (InetAddress.class.isAssignableFrom(raw)) { [EOL]         return InetAddressSerializer.instance; [EOL]     } [EOL]     if (TimeZone.class.isAssignableFrom(raw)) { [EOL]         return TimeZoneSerializer.instance; [EOL]     } [EOL]     if (java.nio.charset.Charset.class.isAssignableFrom(raw)) { [EOL]         return ToStringSerializer.instance; [EOL]     } [EOL]     JsonSerializer<?> ser = findOptionalStdSerializer(prov, type, beanDesc, staticTyping); [EOL]     if (ser != null) { [EOL]         return ser; [EOL]     } [EOL]     if (Number.class.isAssignableFrom(raw)) { [EOL]         return NumberSerializers.NumberSerializer.instance; [EOL]     } [EOL]     if (Enum.class.isAssignableFrom(raw)) { [EOL]         return buildEnumSerializer(prov.getConfig(), type, beanDesc); [EOL]     } [EOL]     if (Calendar.class.isAssignableFrom(raw)) { [EOL]         return CalendarSerializer.instance; [EOL]     } [EOL]     if (java.util.Date.class.isAssignableFrom(raw)) { [EOL]         return DateSerializer.instance; [EOL]     } [EOL]     return null; [EOL] }
protected final JsonSerializer<?> findSerializerByPrimaryType(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     if (InetAddress.class.isAssignableFrom(raw)) { [EOL]         return InetAddressSerializer.instance; [EOL]     } [EOL]     if (TimeZone.class.isAssignableFrom(raw)) { [EOL]         return TimeZoneSerializer.instance; [EOL]     } [EOL]     if (java.nio.charset.Charset.class.isAssignableFrom(raw)) { [EOL]         return ToStringSerializer.instance; [EOL]     } [EOL]     JsonSerializer<?> ser = findOptionalStdSerializer(prov, type, beanDesc, staticTyping); [EOL]     if (ser != null) { [EOL]         return ser; [EOL]     } [EOL]     if (Number.class.isAssignableFrom(raw)) { [EOL]         return NumberSerializers.NumberSerializer.instance; [EOL]     } [EOL]     if (Enum.class.isAssignableFrom(raw)) { [EOL]         return buildEnumSerializer(prov.getConfig(), type, beanDesc); [EOL]     } [EOL]     if (Calendar.class.isAssignableFrom(raw)) { [EOL]         return CalendarSerializer.instance; [EOL]     } [EOL]     if (java.util.Date.class.isAssignableFrom(raw)) { [EOL]         return DateSerializer.instance; [EOL]     } [EOL]     return null; [EOL] }
protected final JsonSerializer<?> findSerializerByPrimaryType(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     if (InetAddress.class.isAssignableFrom(raw)) { [EOL]         return InetAddressSerializer.instance; [EOL]     } [EOL]     if (TimeZone.class.isAssignableFrom(raw)) { [EOL]         return TimeZoneSerializer.instance; [EOL]     } [EOL]     if (java.nio.charset.Charset.class.isAssignableFrom(raw)) { [EOL]         return ToStringSerializer.instance; [EOL]     } [EOL]     JsonSerializer<?> ser = findOptionalStdSerializer(prov, type, beanDesc, staticTyping); [EOL]     if (ser != null) { [EOL]         return ser; [EOL]     } [EOL]     if (Number.class.isAssignableFrom(raw)) { [EOL]         return NumberSerializers.NumberSerializer.instance; [EOL]     } [EOL]     if (Enum.class.isAssignableFrom(raw)) { [EOL]         return buildEnumSerializer(prov.getConfig(), type, beanDesc); [EOL]     } [EOL]     if (Calendar.class.isAssignableFrom(raw)) { [EOL]         return CalendarSerializer.instance; [EOL]     } [EOL]     if (java.util.Date.class.isAssignableFrom(raw)) { [EOL]         return DateSerializer.instance; [EOL]     } [EOL]     return null; [EOL] }
protected final JsonSerializer<?> findSerializerByPrimaryType(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     if (InetAddress.class.isAssignableFrom(raw)) { [EOL]         return InetAddressSerializer.instance; [EOL]     } [EOL]     if (TimeZone.class.isAssignableFrom(raw)) { [EOL]         return TimeZoneSerializer.instance; [EOL]     } [EOL]     if (java.nio.charset.Charset.class.isAssignableFrom(raw)) { [EOL]         return ToStringSerializer.instance; [EOL]     } [EOL]     JsonSerializer<?> ser = findOptionalStdSerializer(prov, type, beanDesc, staticTyping); [EOL]     if (ser != null) { [EOL]         return ser; [EOL]     } [EOL]     if (Number.class.isAssignableFrom(raw)) { [EOL]         return NumberSerializers.NumberSerializer.instance; [EOL]     } [EOL]     if (Enum.class.isAssignableFrom(raw)) { [EOL]         return buildEnumSerializer(prov.getConfig(), type, beanDesc); [EOL]     } [EOL]     if (Calendar.class.isAssignableFrom(raw)) { [EOL]         return CalendarSerializer.instance; [EOL]     } [EOL]     if (java.util.Date.class.isAssignableFrom(raw)) { [EOL]         return DateSerializer.instance; [EOL]     } [EOL]     return null; [EOL] }
protected final JsonSerializer<?> findSerializerByPrimaryType(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     if (InetAddress.class.isAssignableFrom(raw)) { [EOL]         return InetAddressSerializer.instance; [EOL]     } [EOL]     if (TimeZone.class.isAssignableFrom(raw)) { [EOL]         return TimeZoneSerializer.instance; [EOL]     } [EOL]     if (java.nio.charset.Charset.class.isAssignableFrom(raw)) { [EOL]         return ToStringSerializer.instance; [EOL]     } [EOL]     JsonSerializer<?> ser = findOptionalStdSerializer(prov, type, beanDesc, staticTyping); [EOL]     if (ser != null) { [EOL]         return ser; [EOL]     } [EOL]     if (Number.class.isAssignableFrom(raw)) { [EOL]         return NumberSerializers.NumberSerializer.instance; [EOL]     } [EOL]     if (Enum.class.isAssignableFrom(raw)) { [EOL]         return buildEnumSerializer(prov.getConfig(), type, beanDesc); [EOL]     } [EOL]     if (Calendar.class.isAssignableFrom(raw)) { [EOL]         return CalendarSerializer.instance; [EOL]     } [EOL]     if (java.util.Date.class.isAssignableFrom(raw)) { [EOL]         return DateSerializer.instance; [EOL]     } [EOL]     return null; [EOL] }
protected JsonSerializer<?> buildContainerSerializer(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { [EOL]     final SerializationConfig config = prov.getConfig(); [EOL]     if (!staticTyping && type.useStaticType()) { [EOL]         if (!type.isContainerType() || type.getContentType().getRawClass() != Object.class) { [EOL]             staticTyping = true; [EOL]         } [EOL]     } [EOL]     JavaType elementType = type.getContentType(); [EOL]     TypeSerializer elementTypeSerializer = createTypeSerializer(config, elementType); [EOL]     if (elementTypeSerializer != null) { [EOL]         staticTyping = false; [EOL]     } [EOL]     JsonSerializer<Object> elementValueSerializer = _findContentSerializer(prov, beanDesc.getClassInfo()); [EOL]     if (type.isMapLikeType()) { [EOL]         MapLikeType mlt = (MapLikeType) type; [EOL]         JsonSerializer<Object> keySerializer = _findKeySerializer(prov, beanDesc.getClassInfo()); [EOL]         if (mlt.isTrueMapType()) { [EOL]             return buildMapSerializer(config, (MapType) mlt, beanDesc, staticTyping, keySerializer, elementTypeSerializer, elementValueSerializer); [EOL]         } [EOL]         for (Serializers serializers : customSerializers()) { [EOL]             MapLikeType mlType = (MapLikeType) type; [EOL]             JsonSerializer<?> ser = serializers.findMapLikeSerializer(config, mlType, beanDesc, keySerializer, elementTypeSerializer, elementValueSerializer); [EOL]             if (ser != null) { [EOL]                 if (_factoryConfig.hasSerializerModifiers()) { [EOL]                     for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]                         ser = mod.modifyMapLikeSerializer(config, mlType, beanDesc, ser); [EOL]                     } [EOL]                 } [EOL]                 return ser; [EOL]             } [EOL]         } [EOL]         return null; [EOL]     } [EOL]     if (type.isCollectionLikeType()) { [EOL]         CollectionLikeType clt = (CollectionLikeType) type; [EOL]         if (clt.isTrueCollectionType()) { [EOL]             return buildCollectionSerializer(config, (CollectionType) clt, beanDesc, staticTyping, elementTypeSerializer, elementValueSerializer); [EOL]         } [EOL]         CollectionLikeType clType = (CollectionLikeType) type; [EOL]         for (Serializers serializers : customSerializers()) { [EOL]             JsonSerializer<?> ser = serializers.findCollectionLikeSerializer(config, clType, beanDesc, elementTypeSerializer, elementValueSerializer); [EOL]             if (ser != null) { [EOL]                 if (_factoryConfig.hasSerializerModifiers()) { [EOL]                     for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]                         ser = mod.modifyCollectionLikeSerializer(config, clType, beanDesc, ser); [EOL]                     } [EOL]                 } [EOL]                 return ser; [EOL]             } [EOL]         } [EOL]         return null; [EOL]     } [EOL]     if (type.isArrayType()) { [EOL]         return buildArraySerializer(config, (ArrayType) type, beanDesc, staticTyping, elementTypeSerializer, elementValueSerializer); [EOL]     } [EOL]     return null; [EOL] }
protected JsonSerializer<?> buildContainerSerializer(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { [EOL]     final SerializationConfig config = prov.getConfig(); [EOL]     if (!staticTyping && type.useStaticType()) { [EOL]         if (!type.isContainerType() || type.getContentType().getRawClass() != Object.class) { [EOL]             staticTyping = true; [EOL]         } [EOL]     } [EOL]     JavaType elementType = type.getContentType(); [EOL]     TypeSerializer elementTypeSerializer = createTypeSerializer(config, elementType); [EOL]     if (elementTypeSerializer != null) { [EOL]         staticTyping = false; [EOL]     } [EOL]     JsonSerializer<Object> elementValueSerializer = _findContentSerializer(prov, beanDesc.getClassInfo()); [EOL]     if (type.isMapLikeType()) { [EOL]         MapLikeType mlt = (MapLikeType) type; [EOL]         JsonSerializer<Object> keySerializer = _findKeySerializer(prov, beanDesc.getClassInfo()); [EOL]         if (mlt.isTrueMapType()) { [EOL]             return buildMapSerializer(config, (MapType) mlt, beanDesc, staticTyping, keySerializer, elementTypeSerializer, elementValueSerializer); [EOL]         } [EOL]         for (Serializers serializers : customSerializers()) { [EOL]             MapLikeType mlType = (MapLikeType) type; [EOL]             JsonSerializer<?> ser = serializers.findMapLikeSerializer(config, mlType, beanDesc, keySerializer, elementTypeSerializer, elementValueSerializer); [EOL]             if (ser != null) { [EOL]                 if (_factoryConfig.hasSerializerModifiers()) { [EOL]                     for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]                         ser = mod.modifyMapLikeSerializer(config, mlType, beanDesc, ser); [EOL]                     } [EOL]                 } [EOL]                 return ser; [EOL]             } [EOL]         } [EOL]         return null; [EOL]     } [EOL]     if (type.isCollectionLikeType()) { [EOL]         CollectionLikeType clt = (CollectionLikeType) type; [EOL]         if (clt.isTrueCollectionType()) { [EOL]             return buildCollectionSerializer(config, (CollectionType) clt, beanDesc, staticTyping, elementTypeSerializer, elementValueSerializer); [EOL]         } [EOL]         CollectionLikeType clType = (CollectionLikeType) type; [EOL]         for (Serializers serializers : customSerializers()) { [EOL]             JsonSerializer<?> ser = serializers.findCollectionLikeSerializer(config, clType, beanDesc, elementTypeSerializer, elementValueSerializer); [EOL]             if (ser != null) { [EOL]                 if (_factoryConfig.hasSerializerModifiers()) { [EOL]                     for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]                         ser = mod.modifyCollectionLikeSerializer(config, clType, beanDesc, ser); [EOL]                     } [EOL]                 } [EOL]                 return ser; [EOL]             } [EOL]         } [EOL]         return null; [EOL]     } [EOL]     if (type.isArrayType()) { [EOL]         return buildArraySerializer(config, (ArrayType) type, beanDesc, staticTyping, elementTypeSerializer, elementValueSerializer); [EOL]     } [EOL]     return null; [EOL] }
protected JsonSerializer<?> buildEnumSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     JsonFormat.Value format = beanDesc.findExpectedFormat(null); [EOL]     if (format != null && format.getShape() == JsonFormat.Shape.OBJECT) { [EOL]         ((BasicBeanDescription) beanDesc).removeProperty("declaringClass"); [EOL]         return null; [EOL]     } [EOL]     @SuppressWarnings("unchecked") [EOL]     Class<Enum<?>> enumClass = (Class<Enum<?>>) type.getRawClass(); [EOL]     JsonSerializer<?> ser = EnumSerializer.construct(enumClass, config, beanDesc, format); [EOL]     if (_factoryConfig.hasSerializerModifiers()) { [EOL]         for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]             ser = mod.modifyEnumSerializer(config, type, beanDesc, ser); [EOL]         } [EOL]     } [EOL]     return ser; [EOL] }
protected JsonSerializer<?> buildEnumSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     JsonFormat.Value format = beanDesc.findExpectedFormat(null); [EOL]     if (format != null && format.getShape() == JsonFormat.Shape.OBJECT) { [EOL]         ((BasicBeanDescription) beanDesc).removeProperty("declaringClass"); [EOL]         return null; [EOL]     } [EOL]     @SuppressWarnings("unchecked") [EOL]     Class<Enum<?>> enumClass = (Class<Enum<?>>) type.getRawClass(); [EOL]     JsonSerializer<?> ser = EnumSerializer.construct(enumClass, config, beanDesc, format); [EOL]     if (_factoryConfig.hasSerializerModifiers()) { [EOL]         for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]             ser = mod.modifyEnumSerializer(config, type, beanDesc, ser); [EOL]         } [EOL]     } [EOL]     return ser; [EOL] }
protected JsonSerializer<?> buildEnumSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     JsonFormat.Value format = beanDesc.findExpectedFormat(null); [EOL]     if (format != null && format.getShape() == JsonFormat.Shape.OBJECT) { [EOL]         ((BasicBeanDescription) beanDesc).removeProperty("declaringClass"); [EOL]         return null; [EOL]     } [EOL]     @SuppressWarnings("unchecked") [EOL]     Class<Enum<?>> enumClass = (Class<Enum<?>>) type.getRawClass(); [EOL]     JsonSerializer<?> ser = EnumSerializer.construct(enumClass, config, beanDesc, format); [EOL]     if (_factoryConfig.hasSerializerModifiers()) { [EOL]         for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]             ser = mod.modifyEnumSerializer(config, type, beanDesc, ser); [EOL]         } [EOL]     } [EOL]     return ser; [EOL] }
@Override [EOL] public void serialize(Object value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonMappingException { [EOL]     if (provider.isEnabled(SerializationFeature.FAIL_ON_EMPTY_BEANS)) { [EOL]         failForEmpty(value); [EOL]     } [EOL]     jgen.writeStartObject(); [EOL]     jgen.writeEndObject(); [EOL] }
@Override [EOL] public void serialize(Object value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonMappingException { [EOL]     if (provider.isEnabled(SerializationFeature.FAIL_ON_EMPTY_BEANS)) { [EOL]         failForEmpty(value); [EOL]     } [EOL]     jgen.writeStartObject(); [EOL]     jgen.writeEndObject(); [EOL] }
protected void failForEmpty(Object value) throws JsonMappingException { [EOL]     throw new JsonMappingException("No serializer found for class " + value.getClass().getName() + " and no properties discovered to create BeanSerializer (to avoid exception, disable SerializationFeature.FAIL_ON_EMPTY_BEANS) )"); [EOL] }
protected void failForEmpty(Object value) throws JsonMappingException { [EOL]     throw new JsonMappingException("No serializer found for class " + value.getClass().getName() + " and no properties discovered to create BeanSerializer (to avoid exception, disable SerializationFeature.FAIL_ON_EMPTY_BEANS) )"); [EOL] }
public List<AnnotatedMethod> getStaticMethods() { [EOL]     if (!_creatorsResolved) { [EOL]         resolveCreators(); [EOL]     } [EOL]     return _creatorMethods; [EOL] }
public List<AnnotatedMethod> getStaticMethods() { [EOL]     if (!_creatorsResolved) { [EOL]         resolveCreators(); [EOL]     } [EOL]     return _creatorMethods; [EOL] }
private void resolveClassAnnotations() { [EOL]     _classAnnotations = new AnnotationMap(); [EOL]     if (_annotationIntrospector != null) { [EOL]         if (_primaryMixIn != null) { [EOL]             _addClassMixIns(_classAnnotations, _class, _primaryMixIn); [EOL]         } [EOL]         _addAnnotationsIfNotPresent(_classAnnotations, _class.getDeclaredAnnotations()); [EOL]         for (Class<?> cls : _superTypes) { [EOL]             _addClassMixIns(_classAnnotations, cls); [EOL]             _addAnnotationsIfNotPresent(_classAnnotations, cls.getDeclaredAnnotations()); [EOL]         } [EOL]         _addClassMixIns(_classAnnotations, Object.class); [EOL]     } [EOL] }
private void resolveClassAnnotations() { [EOL]     _classAnnotations = new AnnotationMap(); [EOL]     if (_annotationIntrospector != null) { [EOL]         if (_primaryMixIn != null) { [EOL]             _addClassMixIns(_classAnnotations, _class, _primaryMixIn); [EOL]         } [EOL]         _addAnnotationsIfNotPresent(_classAnnotations, _class.getDeclaredAnnotations()); [EOL]         for (Class<?> cls : _superTypes) { [EOL]             _addClassMixIns(_classAnnotations, cls); [EOL]             _addAnnotationsIfNotPresent(_classAnnotations, cls.getDeclaredAnnotations()); [EOL]         } [EOL]         _addClassMixIns(_classAnnotations, Object.class); [EOL]     } [EOL] }
private void resolveClassAnnotations() { [EOL]     _classAnnotations = new AnnotationMap(); [EOL]     if (_annotationIntrospector != null) { [EOL]         if (_primaryMixIn != null) { [EOL]             _addClassMixIns(_classAnnotations, _class, _primaryMixIn); [EOL]         } [EOL]         _addAnnotationsIfNotPresent(_classAnnotations, _class.getDeclaredAnnotations()); [EOL]         for (Class<?> cls : _superTypes) { [EOL]             _addClassMixIns(_classAnnotations, cls); [EOL]             _addAnnotationsIfNotPresent(_classAnnotations, cls.getDeclaredAnnotations()); [EOL]         } [EOL]         _addClassMixIns(_classAnnotations, Object.class); [EOL]     } [EOL] }
private void resolveCreators() { [EOL]     List<AnnotatedConstructor> constructors = null; [EOL]     Constructor<?>[] declaredCtors = _class.getDeclaredConstructors(); [EOL]     for (Constructor<?> ctor : declaredCtors) { [EOL]         if (ctor.getParameterTypes().length == 0) { [EOL]             _defaultConstructor = _constructConstructor(ctor, true); [EOL]         } else { [EOL]             if (constructors == null) { [EOL]                 constructors = new ArrayList<AnnotatedConstructor>(Math.max(10, declaredCtors.length)); [EOL]             } [EOL]             constructors.add(_constructConstructor(ctor, false)); [EOL]         } [EOL]     } [EOL]     if (constructors == null) { [EOL]         _constructors = Collections.emptyList(); [EOL]     } else { [EOL]         _constructors = constructors; [EOL]     } [EOL]     if (_primaryMixIn != null) { [EOL]         if (_defaultConstructor != null || !_constructors.isEmpty()) { [EOL]             _addConstructorMixIns(_primaryMixIn); [EOL]         } [EOL]     } [EOL]     if (_annotationIntrospector != null) { [EOL]         if (_defaultConstructor != null) { [EOL]             if (_annotationIntrospector.hasIgnoreMarker(_defaultConstructor)) { [EOL]                 _defaultConstructor = null; [EOL]             } [EOL]         } [EOL]         if (_constructors != null) { [EOL]             for (int i = _constructors.size(); --i >= 0; ) { [EOL]                 if (_annotationIntrospector.hasIgnoreMarker(_constructors.get(i))) { [EOL]                     _constructors.remove(i); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     List<AnnotatedMethod> creatorMethods = null; [EOL]     for (Method m : _class.getDeclaredMethods()) { [EOL]         if (!Modifier.isStatic(m.getModifiers())) { [EOL]             continue; [EOL]         } [EOL]         if (creatorMethods == null) { [EOL]             creatorMethods = new ArrayList<AnnotatedMethod>(8); [EOL]         } [EOL]         creatorMethods.add(_constructCreatorMethod(m)); [EOL]     } [EOL]     if (creatorMethods == null) { [EOL]         _creatorMethods = Collections.emptyList(); [EOL]     } else { [EOL]         _creatorMethods = creatorMethods; [EOL]         if (_primaryMixIn != null) { [EOL]             _addFactoryMixIns(_primaryMixIn); [EOL]         } [EOL]         if (_annotationIntrospector != null) { [EOL]             for (int i = _creatorMethods.size(); --i >= 0; ) { [EOL]                 if (_annotationIntrospector.hasIgnoreMarker(_creatorMethods.get(i))) { [EOL]                     _creatorMethods.remove(i); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     _creatorsResolved = true; [EOL] }
private void resolveCreators() { [EOL]     List<AnnotatedConstructor> constructors = null; [EOL]     Constructor<?>[] declaredCtors = _class.getDeclaredConstructors(); [EOL]     for (Constructor<?> ctor : declaredCtors) { [EOL]         if (ctor.getParameterTypes().length == 0) { [EOL]             _defaultConstructor = _constructConstructor(ctor, true); [EOL]         } else { [EOL]             if (constructors == null) { [EOL]                 constructors = new ArrayList<AnnotatedConstructor>(Math.max(10, declaredCtors.length)); [EOL]             } [EOL]             constructors.add(_constructConstructor(ctor, false)); [EOL]         } [EOL]     } [EOL]     if (constructors == null) { [EOL]         _constructors = Collections.emptyList(); [EOL]     } else { [EOL]         _constructors = constructors; [EOL]     } [EOL]     if (_primaryMixIn != null) { [EOL]         if (_defaultConstructor != null || !_constructors.isEmpty()) { [EOL]             _addConstructorMixIns(_primaryMixIn); [EOL]         } [EOL]     } [EOL]     if (_annotationIntrospector != null) { [EOL]         if (_defaultConstructor != null) { [EOL]             if (_annotationIntrospector.hasIgnoreMarker(_defaultConstructor)) { [EOL]                 _defaultConstructor = null; [EOL]             } [EOL]         } [EOL]         if (_constructors != null) { [EOL]             for (int i = _constructors.size(); --i >= 0; ) { [EOL]                 if (_annotationIntrospector.hasIgnoreMarker(_constructors.get(i))) { [EOL]                     _constructors.remove(i); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     List<AnnotatedMethod> creatorMethods = null; [EOL]     for (Method m : _class.getDeclaredMethods()) { [EOL]         if (!Modifier.isStatic(m.getModifiers())) { [EOL]             continue; [EOL]         } [EOL]         if (creatorMethods == null) { [EOL]             creatorMethods = new ArrayList<AnnotatedMethod>(8); [EOL]         } [EOL]         creatorMethods.add(_constructCreatorMethod(m)); [EOL]     } [EOL]     if (creatorMethods == null) { [EOL]         _creatorMethods = Collections.emptyList(); [EOL]     } else { [EOL]         _creatorMethods = creatorMethods; [EOL]         if (_primaryMixIn != null) { [EOL]             _addFactoryMixIns(_primaryMixIn); [EOL]         } [EOL]         if (_annotationIntrospector != null) { [EOL]             for (int i = _creatorMethods.size(); --i >= 0; ) { [EOL]                 if (_annotationIntrospector.hasIgnoreMarker(_creatorMethods.get(i))) { [EOL]                     _creatorMethods.remove(i); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     _creatorsResolved = true; [EOL] }
private void resolveCreators() { [EOL]     List<AnnotatedConstructor> constructors = null; [EOL]     Constructor<?>[] declaredCtors = _class.getDeclaredConstructors(); [EOL]     for (Constructor<?> ctor : declaredCtors) { [EOL]         if (ctor.getParameterTypes().length == 0) { [EOL]             _defaultConstructor = _constructConstructor(ctor, true); [EOL]         } else { [EOL]             if (constructors == null) { [EOL]                 constructors = new ArrayList<AnnotatedConstructor>(Math.max(10, declaredCtors.length)); [EOL]             } [EOL]             constructors.add(_constructConstructor(ctor, false)); [EOL]         } [EOL]     } [EOL]     if (constructors == null) { [EOL]         _constructors = Collections.emptyList(); [EOL]     } else { [EOL]         _constructors = constructors; [EOL]     } [EOL]     if (_primaryMixIn != null) { [EOL]         if (_defaultConstructor != null || !_constructors.isEmpty()) { [EOL]             _addConstructorMixIns(_primaryMixIn); [EOL]         } [EOL]     } [EOL]     if (_annotationIntrospector != null) { [EOL]         if (_defaultConstructor != null) { [EOL]             if (_annotationIntrospector.hasIgnoreMarker(_defaultConstructor)) { [EOL]                 _defaultConstructor = null; [EOL]             } [EOL]         } [EOL]         if (_constructors != null) { [EOL]             for (int i = _constructors.size(); --i >= 0; ) { [EOL]                 if (_annotationIntrospector.hasIgnoreMarker(_constructors.get(i))) { [EOL]                     _constructors.remove(i); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     List<AnnotatedMethod> creatorMethods = null; [EOL]     for (Method m : _class.getDeclaredMethods()) { [EOL]         if (!Modifier.isStatic(m.getModifiers())) { [EOL]             continue; [EOL]         } [EOL]         if (creatorMethods == null) { [EOL]             creatorMethods = new ArrayList<AnnotatedMethod>(8); [EOL]         } [EOL]         creatorMethods.add(_constructCreatorMethod(m)); [EOL]     } [EOL]     if (creatorMethods == null) { [EOL]         _creatorMethods = Collections.emptyList(); [EOL]     } else { [EOL]         _creatorMethods = creatorMethods; [EOL]         if (_primaryMixIn != null) { [EOL]             _addFactoryMixIns(_primaryMixIn); [EOL]         } [EOL]         if (_annotationIntrospector != null) { [EOL]             for (int i = _creatorMethods.size(); --i >= 0; ) { [EOL]                 if (_annotationIntrospector.hasIgnoreMarker(_creatorMethods.get(i))) { [EOL]                     _creatorMethods.remove(i); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     _creatorsResolved = true; [EOL] }
private void resolveCreators() { [EOL]     List<AnnotatedConstructor> constructors = null; [EOL]     Constructor<?>[] declaredCtors = _class.getDeclaredConstructors(); [EOL]     for (Constructor<?> ctor : declaredCtors) { [EOL]         if (ctor.getParameterTypes().length == 0) { [EOL]             _defaultConstructor = _constructConstructor(ctor, true); [EOL]         } else { [EOL]             if (constructors == null) { [EOL]                 constructors = new ArrayList<AnnotatedConstructor>(Math.max(10, declaredCtors.length)); [EOL]             } [EOL]             constructors.add(_constructConstructor(ctor, false)); [EOL]         } [EOL]     } [EOL]     if (constructors == null) { [EOL]         _constructors = Collections.emptyList(); [EOL]     } else { [EOL]         _constructors = constructors; [EOL]     } [EOL]     if (_primaryMixIn != null) { [EOL]         if (_defaultConstructor != null || !_constructors.isEmpty()) { [EOL]             _addConstructorMixIns(_primaryMixIn); [EOL]         } [EOL]     } [EOL]     if (_annotationIntrospector != null) { [EOL]         if (_defaultConstructor != null) { [EOL]             if (_annotationIntrospector.hasIgnoreMarker(_defaultConstructor)) { [EOL]                 _defaultConstructor = null; [EOL]             } [EOL]         } [EOL]         if (_constructors != null) { [EOL]             for (int i = _constructors.size(); --i >= 0; ) { [EOL]                 if (_annotationIntrospector.hasIgnoreMarker(_constructors.get(i))) { [EOL]                     _constructors.remove(i); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     List<AnnotatedMethod> creatorMethods = null; [EOL]     for (Method m : _class.getDeclaredMethods()) { [EOL]         if (!Modifier.isStatic(m.getModifiers())) { [EOL]             continue; [EOL]         } [EOL]         if (creatorMethods == null) { [EOL]             creatorMethods = new ArrayList<AnnotatedMethod>(8); [EOL]         } [EOL]         creatorMethods.add(_constructCreatorMethod(m)); [EOL]     } [EOL]     if (creatorMethods == null) { [EOL]         _creatorMethods = Collections.emptyList(); [EOL]     } else { [EOL]         _creatorMethods = creatorMethods; [EOL]         if (_primaryMixIn != null) { [EOL]             _addFactoryMixIns(_primaryMixIn); [EOL]         } [EOL]         if (_annotationIntrospector != null) { [EOL]             for (int i = _creatorMethods.size(); --i >= 0; ) { [EOL]                 if (_annotationIntrospector.hasIgnoreMarker(_creatorMethods.get(i))) { [EOL]                     _creatorMethods.remove(i); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     _creatorsResolved = true; [EOL] }
private void resolveMemberMethods() { [EOL]     _memberMethods = new AnnotatedMethodMap(); [EOL]     AnnotatedMethodMap mixins = new AnnotatedMethodMap(); [EOL]     _addMemberMethods(_class, _memberMethods, _primaryMixIn, mixins); [EOL]     for (Class<?> cls : _superTypes) { [EOL]         Class<?> mixin = (_mixInResolver == null) ? null : _mixInResolver.findMixInClassFor(cls); [EOL]         _addMemberMethods(cls, _memberMethods, mixin, mixins); [EOL]     } [EOL]     if (_mixInResolver != null) { [EOL]         Class<?> mixin = _mixInResolver.findMixInClassFor(Object.class); [EOL]         if (mixin != null) { [EOL]             _addMethodMixIns(_class, _memberMethods, mixin, mixins); [EOL]         } [EOL]     } [EOL]     if (_annotationIntrospector != null) { [EOL]         if (!mixins.isEmpty()) { [EOL]             Iterator<AnnotatedMethod> it = mixins.iterator(); [EOL]             while (it.hasNext()) { [EOL]                 AnnotatedMethod mixIn = it.next(); [EOL]                 try { [EOL]                     Method m = Object.class.getDeclaredMethod(mixIn.getName(), mixIn.getRawParameterTypes()); [EOL]                     if (m != null) { [EOL]                         AnnotatedMethod am = _constructMethod(m); [EOL]                         _addMixOvers(mixIn.getAnnotated(), am, false); [EOL]                         _memberMethods.add(am); [EOL]                     } [EOL]                 } catch (Exception e) { [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
private void resolveMemberMethods() { [EOL]     _memberMethods = new AnnotatedMethodMap(); [EOL]     AnnotatedMethodMap mixins = new AnnotatedMethodMap(); [EOL]     _addMemberMethods(_class, _memberMethods, _primaryMixIn, mixins); [EOL]     for (Class<?> cls : _superTypes) { [EOL]         Class<?> mixin = (_mixInResolver == null) ? null : _mixInResolver.findMixInClassFor(cls); [EOL]         _addMemberMethods(cls, _memberMethods, mixin, mixins); [EOL]     } [EOL]     if (_mixInResolver != null) { [EOL]         Class<?> mixin = _mixInResolver.findMixInClassFor(Object.class); [EOL]         if (mixin != null) { [EOL]             _addMethodMixIns(_class, _memberMethods, mixin, mixins); [EOL]         } [EOL]     } [EOL]     if (_annotationIntrospector != null) { [EOL]         if (!mixins.isEmpty()) { [EOL]             Iterator<AnnotatedMethod> it = mixins.iterator(); [EOL]             while (it.hasNext()) { [EOL]                 AnnotatedMethod mixIn = it.next(); [EOL]                 try { [EOL]                     Method m = Object.class.getDeclaredMethod(mixIn.getName(), mixIn.getRawParameterTypes()); [EOL]                     if (m != null) { [EOL]                         AnnotatedMethod am = _constructMethod(m); [EOL]                         _addMixOvers(mixIn.getAnnotated(), am, false); [EOL]                         _memberMethods.add(am); [EOL]                     } [EOL]                 } catch (Exception e) { [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
private void resolveMemberMethods() { [EOL]     _memberMethods = new AnnotatedMethodMap(); [EOL]     AnnotatedMethodMap mixins = new AnnotatedMethodMap(); [EOL]     _addMemberMethods(_class, _memberMethods, _primaryMixIn, mixins); [EOL]     for (Class<?> cls : _superTypes) { [EOL]         Class<?> mixin = (_mixInResolver == null) ? null : _mixInResolver.findMixInClassFor(cls); [EOL]         _addMemberMethods(cls, _memberMethods, mixin, mixins); [EOL]     } [EOL]     if (_mixInResolver != null) { [EOL]         Class<?> mixin = _mixInResolver.findMixInClassFor(Object.class); [EOL]         if (mixin != null) { [EOL]             _addMethodMixIns(_class, _memberMethods, mixin, mixins); [EOL]         } [EOL]     } [EOL]     if (_annotationIntrospector != null) { [EOL]         if (!mixins.isEmpty()) { [EOL]             Iterator<AnnotatedMethod> it = mixins.iterator(); [EOL]             while (it.hasNext()) { [EOL]                 AnnotatedMethod mixIn = it.next(); [EOL]                 try { [EOL]                     Method m = Object.class.getDeclaredMethod(mixIn.getName(), mixIn.getRawParameterTypes()); [EOL]                     if (m != null) { [EOL]                         AnnotatedMethod am = _constructMethod(m); [EOL]                         _addMixOvers(mixIn.getAnnotated(), am, false); [EOL]                         _memberMethods.add(am); [EOL]                     } [EOL]                 } catch (Exception e) { [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
private void resolveMemberMethods() { [EOL]     _memberMethods = new AnnotatedMethodMap(); [EOL]     AnnotatedMethodMap mixins = new AnnotatedMethodMap(); [EOL]     _addMemberMethods(_class, _memberMethods, _primaryMixIn, mixins); [EOL]     for (Class<?> cls : _superTypes) { [EOL]         Class<?> mixin = (_mixInResolver == null) ? null : _mixInResolver.findMixInClassFor(cls); [EOL]         _addMemberMethods(cls, _memberMethods, mixin, mixins); [EOL]     } [EOL]     if (_mixInResolver != null) { [EOL]         Class<?> mixin = _mixInResolver.findMixInClassFor(Object.class); [EOL]         if (mixin != null) { [EOL]             _addMethodMixIns(_class, _memberMethods, mixin, mixins); [EOL]         } [EOL]     } [EOL]     if (_annotationIntrospector != null) { [EOL]         if (!mixins.isEmpty()) { [EOL]             Iterator<AnnotatedMethod> it = mixins.iterator(); [EOL]             while (it.hasNext()) { [EOL]                 AnnotatedMethod mixIn = it.next(); [EOL]                 try { [EOL]                     Method m = Object.class.getDeclaredMethod(mixIn.getName(), mixIn.getRawParameterTypes()); [EOL]                     if (m != null) { [EOL]                         AnnotatedMethod am = _constructMethod(m); [EOL]                         _addMixOvers(mixIn.getAnnotated(), am, false); [EOL]                         _memberMethods.add(am); [EOL]                     } [EOL]                 } catch (Exception e) { [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
private void resolveFields() { [EOL]     Map<String, AnnotatedField> foundFields = _findFields(_class, null); [EOL]     if (foundFields == null || foundFields.size() == 0) { [EOL]         _fields = Collections.emptyList(); [EOL]     } else { [EOL]         _fields = new ArrayList<AnnotatedField>(foundFields.size()); [EOL]         _fields.addAll(foundFields.values()); [EOL]     } [EOL] }
private void resolveFields() { [EOL]     Map<String, AnnotatedField> foundFields = _findFields(_class, null); [EOL]     if (foundFields == null || foundFields.size() == 0) { [EOL]         _fields = Collections.emptyList(); [EOL]     } else { [EOL]         _fields = new ArrayList<AnnotatedField>(foundFields.size()); [EOL]         _fields.addAll(foundFields.values()); [EOL]     } [EOL] }
private void resolveFields() { [EOL]     Map<String, AnnotatedField> foundFields = _findFields(_class, null); [EOL]     if (foundFields == null || foundFields.size() == 0) { [EOL]         _fields = Collections.emptyList(); [EOL]     } else { [EOL]         _fields = new ArrayList<AnnotatedField>(foundFields.size()); [EOL]         _fields.addAll(foundFields.values()); [EOL]     } [EOL] }
protected void _addClassMixIns(AnnotationMap annotations, Class<?> toMask, Class<?> mixin) { [EOL]     if (mixin == null) { [EOL]         return; [EOL]     } [EOL]     _addAnnotationsIfNotPresent(annotations, mixin.getDeclaredAnnotations()); [EOL]     for (Class<?> parent : ClassUtil.findSuperTypes(mixin, toMask)) { [EOL]         _addAnnotationsIfNotPresent(annotations, parent.getDeclaredAnnotations()); [EOL]     } [EOL] }
protected void _addClassMixIns(AnnotationMap annotations, Class<?> toMask, Class<?> mixin) { [EOL]     if (mixin == null) { [EOL]         return; [EOL]     } [EOL]     _addAnnotationsIfNotPresent(annotations, mixin.getDeclaredAnnotations()); [EOL]     for (Class<?> parent : ClassUtil.findSuperTypes(mixin, toMask)) { [EOL]         _addAnnotationsIfNotPresent(annotations, parent.getDeclaredAnnotations()); [EOL]     } [EOL] }
protected void _addClassMixIns(AnnotationMap annotations, Class<?> toMask, Class<?> mixin) { [EOL]     if (mixin == null) { [EOL]         return; [EOL]     } [EOL]     _addAnnotationsIfNotPresent(annotations, mixin.getDeclaredAnnotations()); [EOL]     for (Class<?> parent : ClassUtil.findSuperTypes(mixin, toMask)) { [EOL]         _addAnnotationsIfNotPresent(annotations, parent.getDeclaredAnnotations()); [EOL]     } [EOL] }
protected void _addConstructorMixIns(Class<?> mixin) { [EOL]     MemberKey[] ctorKeys = null; [EOL]     int ctorCount = (_constructors == null) ? 0 : _constructors.size(); [EOL]     for (Constructor<?> ctor : mixin.getDeclaredConstructors()) { [EOL]         if (ctor.getParameterTypes().length == 0) { [EOL]             if (_defaultConstructor != null) { [EOL]                 _addMixOvers(ctor, _defaultConstructor, false); [EOL]             } [EOL]         } else { [EOL]             if (ctorKeys == null) { [EOL]                 ctorKeys = new MemberKey[ctorCount]; [EOL]                 for (int i = 0; i < ctorCount; ++i) { [EOL]                     ctorKeys[i] = new MemberKey(_constructors.get(i).getAnnotated()); [EOL]                 } [EOL]             } [EOL]             MemberKey key = new MemberKey(ctor); [EOL]             for (int i = 0; i < ctorCount; ++i) { [EOL]                 if (!key.equals(ctorKeys[i])) { [EOL]                     continue; [EOL]                 } [EOL]                 _addMixOvers(ctor, _constructors.get(i), true); [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected void _addMemberMethods(Class<?> cls, AnnotatedMethodMap methods, Class<?> mixInCls, AnnotatedMethodMap mixIns) { [EOL]     if (mixInCls != null) { [EOL]         _addMethodMixIns(cls, methods, mixInCls, mixIns); [EOL]     } [EOL]     if (cls == null) { [EOL]         return; [EOL]     } [EOL]     for (Method m : cls.getDeclaredMethods()) { [EOL]         if (!_isIncludableMemberMethod(m)) { [EOL]             continue; [EOL]         } [EOL]         AnnotatedMethod old = methods.find(m); [EOL]         if (old == null) { [EOL]             AnnotatedMethod newM = _constructMethod(m); [EOL]             methods.add(newM); [EOL]             old = mixIns.remove(m); [EOL]             if (old != null) { [EOL]                 _addMixOvers(old.getAnnotated(), newM, false); [EOL]             } [EOL]         } else { [EOL]             _addMixUnders(m, old); [EOL]             if (old.getDeclaringClass().isInterface() && !m.getDeclaringClass().isInterface()) { [EOL]                 methods.add(old.withMethod(m)); [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected void _addMethodMixIns(Class<?> targetClass, AnnotatedMethodMap methods, Class<?> mixInCls, AnnotatedMethodMap mixIns) { [EOL]     List<Class<?>> parents = new ArrayList<Class<?>>(); [EOL]     parents.add(mixInCls); [EOL]     ClassUtil.findSuperTypes(mixInCls, targetClass, parents); [EOL]     for (Class<?> mixin : parents) { [EOL]         for (Method m : mixin.getDeclaredMethods()) { [EOL]             if (!_isIncludableMemberMethod(m)) { [EOL]                 continue; [EOL]             } [EOL]             AnnotatedMethod am = methods.find(m); [EOL]             if (am != null) { [EOL]                 _addMixUnders(m, am); [EOL]             } else { [EOL]                 mixIns.add(_constructMethod(m)); [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected void _addMethodMixIns(Class<?> targetClass, AnnotatedMethodMap methods, Class<?> mixInCls, AnnotatedMethodMap mixIns) { [EOL]     List<Class<?>> parents = new ArrayList<Class<?>>(); [EOL]     parents.add(mixInCls); [EOL]     ClassUtil.findSuperTypes(mixInCls, targetClass, parents); [EOL]     for (Class<?> mixin : parents) { [EOL]         for (Method m : mixin.getDeclaredMethods()) { [EOL]             if (!_isIncludableMemberMethod(m)) { [EOL]                 continue; [EOL]             } [EOL]             AnnotatedMethod am = methods.find(m); [EOL]             if (am != null) { [EOL]                 _addMixUnders(m, am); [EOL]             } else { [EOL]                 mixIns.add(_constructMethod(m)); [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected void _addMethodMixIns(Class<?> targetClass, AnnotatedMethodMap methods, Class<?> mixInCls, AnnotatedMethodMap mixIns) { [EOL]     List<Class<?>> parents = new ArrayList<Class<?>>(); [EOL]     parents.add(mixInCls); [EOL]     ClassUtil.findSuperTypes(mixInCls, targetClass, parents); [EOL]     for (Class<?> mixin : parents) { [EOL]         for (Method m : mixin.getDeclaredMethods()) { [EOL]             if (!_isIncludableMemberMethod(m)) { [EOL]                 continue; [EOL]             } [EOL]             AnnotatedMethod am = methods.find(m); [EOL]             if (am != null) { [EOL]                 _addMixUnders(m, am); [EOL]             } else { [EOL]                 mixIns.add(_constructMethod(m)); [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected Map<String, AnnotatedField> _findFields(Class<?> c, Map<String, AnnotatedField> fields) { [EOL]     Class<?> parent = c.getSuperclass(); [EOL]     if (parent != null) { [EOL]         fields = _findFields(parent, fields); [EOL]         for (Field f : c.getDeclaredFields()) { [EOL]             if (!_isIncludableField(f)) { [EOL]                 continue; [EOL]             } [EOL]             if (fields == null) { [EOL]                 fields = new LinkedHashMap<String, AnnotatedField>(); [EOL]             } [EOL]             fields.put(f.getName(), _constructField(f)); [EOL]         } [EOL]         if (_mixInResolver != null) { [EOL]             Class<?> mixin = _mixInResolver.findMixInClassFor(c); [EOL]             if (mixin != null) { [EOL]                 _addFieldMixIns(parent, mixin, fields); [EOL]             } [EOL]         } [EOL]     } [EOL]     return fields; [EOL] }
protected Map<String, AnnotatedField> _findFields(Class<?> c, Map<String, AnnotatedField> fields) { [EOL]     Class<?> parent = c.getSuperclass(); [EOL]     if (parent != null) { [EOL]         fields = _findFields(parent, fields); [EOL]         for (Field f : c.getDeclaredFields()) { [EOL]             if (!_isIncludableField(f)) { [EOL]                 continue; [EOL]             } [EOL]             if (fields == null) { [EOL]                 fields = new LinkedHashMap<String, AnnotatedField>(); [EOL]             } [EOL]             fields.put(f.getName(), _constructField(f)); [EOL]         } [EOL]         if (_mixInResolver != null) { [EOL]             Class<?> mixin = _mixInResolver.findMixInClassFor(c); [EOL]             if (mixin != null) { [EOL]                 _addFieldMixIns(parent, mixin, fields); [EOL]             } [EOL]         } [EOL]     } [EOL]     return fields; [EOL] }
protected void _addFieldMixIns(Class<?> targetClass, Class<?> mixInCls, Map<String, AnnotatedField> fields) { [EOL]     List<Class<?>> parents = new ArrayList<Class<?>>(); [EOL]     parents.add(mixInCls); [EOL]     ClassUtil.findSuperTypes(mixInCls, targetClass, parents); [EOL]     for (Class<?> mixin : parents) { [EOL]         for (Field mixinField : mixin.getDeclaredFields()) { [EOL]             if (!_isIncludableField(mixinField)) { [EOL]                 continue; [EOL]             } [EOL]             String name = mixinField.getName(); [EOL]             AnnotatedField maskedField = fields.get(name); [EOL]             if (maskedField != null) { [EOL]                 _addOrOverrideAnnotations(maskedField, mixinField.getDeclaredAnnotations()); [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected void _addFieldMixIns(Class<?> targetClass, Class<?> mixInCls, Map<String, AnnotatedField> fields) { [EOL]     List<Class<?>> parents = new ArrayList<Class<?>>(); [EOL]     parents.add(mixInCls); [EOL]     ClassUtil.findSuperTypes(mixInCls, targetClass, parents); [EOL]     for (Class<?> mixin : parents) { [EOL]         for (Field mixinField : mixin.getDeclaredFields()) { [EOL]             if (!_isIncludableField(mixinField)) { [EOL]                 continue; [EOL]             } [EOL]             String name = mixinField.getName(); [EOL]             AnnotatedField maskedField = fields.get(name); [EOL]             if (maskedField != null) { [EOL]                 _addOrOverrideAnnotations(maskedField, mixinField.getDeclaredAnnotations()); [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected void _addFieldMixIns(Class<?> targetClass, Class<?> mixInCls, Map<String, AnnotatedField> fields) { [EOL]     List<Class<?>> parents = new ArrayList<Class<?>>(); [EOL]     parents.add(mixInCls); [EOL]     ClassUtil.findSuperTypes(mixInCls, targetClass, parents); [EOL]     for (Class<?> mixin : parents) { [EOL]         for (Field mixinField : mixin.getDeclaredFields()) { [EOL]             if (!_isIncludableField(mixinField)) { [EOL]                 continue; [EOL]             } [EOL]             String name = mixinField.getName(); [EOL]             AnnotatedField maskedField = fields.get(name); [EOL]             if (maskedField != null) { [EOL]                 _addOrOverrideAnnotations(maskedField, mixinField.getDeclaredAnnotations()); [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected void _addFieldMixIns(Class<?> targetClass, Class<?> mixInCls, Map<String, AnnotatedField> fields) { [EOL]     List<Class<?>> parents = new ArrayList<Class<?>>(); [EOL]     parents.add(mixInCls); [EOL]     ClassUtil.findSuperTypes(mixInCls, targetClass, parents); [EOL]     for (Class<?> mixin : parents) { [EOL]         for (Field mixinField : mixin.getDeclaredFields()) { [EOL]             if (!_isIncludableField(mixinField)) { [EOL]                 continue; [EOL]             } [EOL]             String name = mixinField.getName(); [EOL]             AnnotatedField maskedField = fields.get(name); [EOL]             if (maskedField != null) { [EOL]                 _addOrOverrideAnnotations(maskedField, mixinField.getDeclaredAnnotations()); [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected void _addFieldMixIns(Class<?> targetClass, Class<?> mixInCls, Map<String, AnnotatedField> fields) { [EOL]     List<Class<?>> parents = new ArrayList<Class<?>>(); [EOL]     parents.add(mixInCls); [EOL]     ClassUtil.findSuperTypes(mixInCls, targetClass, parents); [EOL]     for (Class<?> mixin : parents) { [EOL]         for (Field mixinField : mixin.getDeclaredFields()) { [EOL]             if (!_isIncludableField(mixinField)) { [EOL]                 continue; [EOL]             } [EOL]             String name = mixinField.getName(); [EOL]             AnnotatedField maskedField = fields.get(name); [EOL]             if (maskedField != null) { [EOL]                 _addOrOverrideAnnotations(maskedField, mixinField.getDeclaredAnnotations()); [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected AnnotatedMethod _constructMethod(Method m) { [EOL]     if (_annotationIntrospector == null) { [EOL]         return new AnnotatedMethod(m, _emptyAnnotationMap(), null); [EOL]     } [EOL]     return new AnnotatedMethod(m, _collectRelevantAnnotations(m.getDeclaredAnnotations()), null); [EOL] }
protected AnnotatedMethod _constructMethod(Method m) { [EOL]     if (_annotationIntrospector == null) { [EOL]         return new AnnotatedMethod(m, _emptyAnnotationMap(), null); [EOL]     } [EOL]     return new AnnotatedMethod(m, _collectRelevantAnnotations(m.getDeclaredAnnotations()), null); [EOL] }
protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor) { [EOL]     if (_annotationIntrospector == null) { [EOL]         return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length)); [EOL]     } [EOL]     if (defaultCtor) { [EOL]         return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null); [EOL]     } [EOL]     Annotation[][] paramAnns = ctor.getParameterAnnotations(); [EOL]     int paramCount = ctor.getParameterTypes().length; [EOL]     AnnotationMap[] resolvedAnnotations = null; [EOL]     if (paramCount != paramAnns.length) { [EOL]         Class<?> dc = ctor.getDeclaringClass(); [EOL]         if (dc.isEnum() && (paramCount == paramAnns.length + 2)) { [EOL]             Annotation[][] old = paramAnns; [EOL]             paramAnns = new Annotation[old.length + 2][]; [EOL]             System.arraycopy(old, 0, paramAnns, 2, old.length); [EOL]             resolvedAnnotations = _collectRelevantAnnotations(paramAnns); [EOL]         } else if (dc.isMemberClass()) { [EOL]             if (paramCount == (paramAnns.length + 1)) { [EOL]                 Annotation[][] old = paramAnns; [EOL]                 paramAnns = new Annotation[old.length + 1][]; [EOL]                 System.arraycopy(old, 0, paramAnns, 1, old.length); [EOL]                 resolvedAnnotations = _collectRelevantAnnotations(paramAnns); [EOL]             } [EOL]         } [EOL]         if (resolvedAnnotations == null) { [EOL]             throw new IllegalStateException("Internal error: constructor for " + ctor.getDeclaringClass().getName() + " has mismatch: " + paramCount + " parameters; " + paramAnns.length + " sets of annotations"); [EOL]         } [EOL]     } else { [EOL]         resolvedAnnotations = _collectRelevantAnnotations(paramAnns); [EOL]     } [EOL]     return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), resolvedAnnotations); [EOL] }
protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor) { [EOL]     if (_annotationIntrospector == null) { [EOL]         return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length)); [EOL]     } [EOL]     if (defaultCtor) { [EOL]         return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null); [EOL]     } [EOL]     Annotation[][] paramAnns = ctor.getParameterAnnotations(); [EOL]     int paramCount = ctor.getParameterTypes().length; [EOL]     AnnotationMap[] resolvedAnnotations = null; [EOL]     if (paramCount != paramAnns.length) { [EOL]         Class<?> dc = ctor.getDeclaringClass(); [EOL]         if (dc.isEnum() && (paramCount == paramAnns.length + 2)) { [EOL]             Annotation[][] old = paramAnns; [EOL]             paramAnns = new Annotation[old.length + 2][]; [EOL]             System.arraycopy(old, 0, paramAnns, 2, old.length); [EOL]             resolvedAnnotations = _collectRelevantAnnotations(paramAnns); [EOL]         } else if (dc.isMemberClass()) { [EOL]             if (paramCount == (paramAnns.length + 1)) { [EOL]                 Annotation[][] old = paramAnns; [EOL]                 paramAnns = new Annotation[old.length + 1][]; [EOL]                 System.arraycopy(old, 0, paramAnns, 1, old.length); [EOL]                 resolvedAnnotations = _collectRelevantAnnotations(paramAnns); [EOL]             } [EOL]         } [EOL]         if (resolvedAnnotations == null) { [EOL]             throw new IllegalStateException("Internal error: constructor for " + ctor.getDeclaringClass().getName() + " has mismatch: " + paramCount + " parameters; " + paramAnns.length + " sets of annotations"); [EOL]         } [EOL]     } else { [EOL]         resolvedAnnotations = _collectRelevantAnnotations(paramAnns); [EOL]     } [EOL]     return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), resolvedAnnotations); [EOL] }
protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor) { [EOL]     if (_annotationIntrospector == null) { [EOL]         return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length)); [EOL]     } [EOL]     if (defaultCtor) { [EOL]         return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null); [EOL]     } [EOL]     Annotation[][] paramAnns = ctor.getParameterAnnotations(); [EOL]     int paramCount = ctor.getParameterTypes().length; [EOL]     AnnotationMap[] resolvedAnnotations = null; [EOL]     if (paramCount != paramAnns.length) { [EOL]         Class<?> dc = ctor.getDeclaringClass(); [EOL]         if (dc.isEnum() && (paramCount == paramAnns.length + 2)) { [EOL]             Annotation[][] old = paramAnns; [EOL]             paramAnns = new Annotation[old.length + 2][]; [EOL]             System.arraycopy(old, 0, paramAnns, 2, old.length); [EOL]             resolvedAnnotations = _collectRelevantAnnotations(paramAnns); [EOL]         } else if (dc.isMemberClass()) { [EOL]             if (paramCount == (paramAnns.length + 1)) { [EOL]                 Annotation[][] old = paramAnns; [EOL]                 paramAnns = new Annotation[old.length + 1][]; [EOL]                 System.arraycopy(old, 0, paramAnns, 1, old.length); [EOL]                 resolvedAnnotations = _collectRelevantAnnotations(paramAnns); [EOL]             } [EOL]         } [EOL]         if (resolvedAnnotations == null) { [EOL]             throw new IllegalStateException("Internal error: constructor for " + ctor.getDeclaringClass().getName() + " has mismatch: " + paramCount + " parameters; " + paramAnns.length + " sets of annotations"); [EOL]         } [EOL]     } else { [EOL]         resolvedAnnotations = _collectRelevantAnnotations(paramAnns); [EOL]     } [EOL]     return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), resolvedAnnotations); [EOL] }
protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor) { [EOL]     if (_annotationIntrospector == null) { [EOL]         return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length)); [EOL]     } [EOL]     if (defaultCtor) { [EOL]         return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null); [EOL]     } [EOL]     Annotation[][] paramAnns = ctor.getParameterAnnotations(); [EOL]     int paramCount = ctor.getParameterTypes().length; [EOL]     AnnotationMap[] resolvedAnnotations = null; [EOL]     if (paramCount != paramAnns.length) { [EOL]         Class<?> dc = ctor.getDeclaringClass(); [EOL]         if (dc.isEnum() && (paramCount == paramAnns.length + 2)) { [EOL]             Annotation[][] old = paramAnns; [EOL]             paramAnns = new Annotation[old.length + 2][]; [EOL]             System.arraycopy(old, 0, paramAnns, 2, old.length); [EOL]             resolvedAnnotations = _collectRelevantAnnotations(paramAnns); [EOL]         } else if (dc.isMemberClass()) { [EOL]             if (paramCount == (paramAnns.length + 1)) { [EOL]                 Annotation[][] old = paramAnns; [EOL]                 paramAnns = new Annotation[old.length + 1][]; [EOL]                 System.arraycopy(old, 0, paramAnns, 1, old.length); [EOL]                 resolvedAnnotations = _collectRelevantAnnotations(paramAnns); [EOL]             } [EOL]         } [EOL]         if (resolvedAnnotations == null) { [EOL]             throw new IllegalStateException("Internal error: constructor for " + ctor.getDeclaringClass().getName() + " has mismatch: " + paramCount + " parameters; " + paramAnns.length + " sets of annotations"); [EOL]         } [EOL]     } else { [EOL]         resolvedAnnotations = _collectRelevantAnnotations(paramAnns); [EOL]     } [EOL]     return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), resolvedAnnotations); [EOL] }
protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor) { [EOL]     if (_annotationIntrospector == null) { [EOL]         return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length)); [EOL]     } [EOL]     if (defaultCtor) { [EOL]         return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null); [EOL]     } [EOL]     Annotation[][] paramAnns = ctor.getParameterAnnotations(); [EOL]     int paramCount = ctor.getParameterTypes().length; [EOL]     AnnotationMap[] resolvedAnnotations = null; [EOL]     if (paramCount != paramAnns.length) { [EOL]         Class<?> dc = ctor.getDeclaringClass(); [EOL]         if (dc.isEnum() && (paramCount == paramAnns.length + 2)) { [EOL]             Annotation[][] old = paramAnns; [EOL]             paramAnns = new Annotation[old.length + 2][]; [EOL]             System.arraycopy(old, 0, paramAnns, 2, old.length); [EOL]             resolvedAnnotations = _collectRelevantAnnotations(paramAnns); [EOL]         } else if (dc.isMemberClass()) { [EOL]             if (paramCount == (paramAnns.length + 1)) { [EOL]                 Annotation[][] old = paramAnns; [EOL]                 paramAnns = new Annotation[old.length + 1][]; [EOL]                 System.arraycopy(old, 0, paramAnns, 1, old.length); [EOL]                 resolvedAnnotations = _collectRelevantAnnotations(paramAnns); [EOL]             } [EOL]         } [EOL]         if (resolvedAnnotations == null) { [EOL]             throw new IllegalStateException("Internal error: constructor for " + ctor.getDeclaringClass().getName() + " has mismatch: " + paramCount + " parameters; " + paramAnns.length + " sets of annotations"); [EOL]         } [EOL]     } else { [EOL]         resolvedAnnotations = _collectRelevantAnnotations(paramAnns); [EOL]     } [EOL]     return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), resolvedAnnotations); [EOL] }
protected AnnotatedMethod _constructCreatorMethod(Method m) { [EOL]     if (_annotationIntrospector == null) { [EOL]         return new AnnotatedMethod(m, _emptyAnnotationMap(), _emptyAnnotationMaps(m.getParameterTypes().length)); [EOL]     } [EOL]     return new AnnotatedMethod(m, _collectRelevantAnnotations(m.getDeclaredAnnotations()), _collectRelevantAnnotations(m.getParameterAnnotations())); [EOL] }
protected AnnotatedMethod _constructCreatorMethod(Method m) { [EOL]     if (_annotationIntrospector == null) { [EOL]         return new AnnotatedMethod(m, _emptyAnnotationMap(), _emptyAnnotationMaps(m.getParameterTypes().length)); [EOL]     } [EOL]     return new AnnotatedMethod(m, _collectRelevantAnnotations(m.getDeclaredAnnotations()), _collectRelevantAnnotations(m.getParameterAnnotations())); [EOL] }
protected AnnotatedField _constructField(Field f) { [EOL]     if (_annotationIntrospector == null) { [EOL]         return new AnnotatedField(f, _emptyAnnotationMap()); [EOL]     } [EOL]     return new AnnotatedField(f, _collectRelevantAnnotations(f.getDeclaredAnnotations())); [EOL] }
protected AnnotatedField _constructField(Field f) { [EOL]     if (_annotationIntrospector == null) { [EOL]         return new AnnotatedField(f, _emptyAnnotationMap()); [EOL]     } [EOL]     return new AnnotatedField(f, _collectRelevantAnnotations(f.getDeclaredAnnotations())); [EOL] }
private AnnotationMap _emptyAnnotationMap() { [EOL]     return new AnnotationMap(); [EOL] }
private AnnotationMap[] _emptyAnnotationMaps(int count) { [EOL]     if (count == 0) { [EOL]         return NO_ANNOTATION_MAPS; [EOL]     } [EOL]     AnnotationMap[] maps = new AnnotationMap[count]; [EOL]     for (int i = 0; i < count; ++i) { [EOL]         maps[i] = _emptyAnnotationMap(); [EOL]     } [EOL]     return maps; [EOL] }
private AnnotationMap[] _emptyAnnotationMaps(int count) { [EOL]     if (count == 0) { [EOL]         return NO_ANNOTATION_MAPS; [EOL]     } [EOL]     AnnotationMap[] maps = new AnnotationMap[count]; [EOL]     for (int i = 0; i < count; ++i) { [EOL]         maps[i] = _emptyAnnotationMap(); [EOL]     } [EOL]     return maps; [EOL] }
protected final JsonDeserializer<Object> _findDefaultImplDeserializer(DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_defaultImpl == null) { [EOL]         if (!ctxt.isEnabled(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE)) { [EOL]             return NullifyingDeserializer.instance; [EOL]         } [EOL]         return null; [EOL]     } [EOL]     if (_defaultImpl.getRawClass() == NoClass.class) { [EOL]         return NullifyingDeserializer.instance; [EOL]     } [EOL]     synchronized (_defaultImpl) { [EOL]         if (_defaultImplDeserializer == null) { [EOL]             _defaultImplDeserializer = ctxt.findContextualValueDeserializer(_defaultImpl, _property); [EOL]         } [EOL]         return _defaultImplDeserializer; [EOL]     } [EOL] }
protected final JsonDeserializer<Object> _findDefaultImplDeserializer(DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_defaultImpl == null) { [EOL]         if (!ctxt.isEnabled(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE)) { [EOL]             return NullifyingDeserializer.instance; [EOL]         } [EOL]         return null; [EOL]     } [EOL]     if (_defaultImpl.getRawClass() == NoClass.class) { [EOL]         return NullifyingDeserializer.instance; [EOL]     } [EOL]     synchronized (_defaultImpl) { [EOL]         if (_defaultImplDeserializer == null) { [EOL]             _defaultImplDeserializer = ctxt.findContextualValueDeserializer(_defaultImpl, _property); [EOL]         } [EOL]         return _defaultImplDeserializer; [EOL]     } [EOL] }
protected final JsonDeserializer<Object> _findDefaultImplDeserializer(DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_defaultImpl == null) { [EOL]         if (!ctxt.isEnabled(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE)) { [EOL]             return NullifyingDeserializer.instance; [EOL]         } [EOL]         return null; [EOL]     } [EOL]     if (_defaultImpl.getRawClass() == NoClass.class) { [EOL]         return NullifyingDeserializer.instance; [EOL]     } [EOL]     synchronized (_defaultImpl) { [EOL]         if (_defaultImplDeserializer == null) { [EOL]             _defaultImplDeserializer = ctxt.findContextualValueDeserializer(_defaultImpl, _property); [EOL]         } [EOL]         return _defaultImplDeserializer; [EOL]     } [EOL] }
protected final JsonDeserializer<Object> _findDefaultImplDeserializer(DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_defaultImpl == null) { [EOL]         if (!ctxt.isEnabled(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE)) { [EOL]             return NullifyingDeserializer.instance; [EOL]         } [EOL]         return null; [EOL]     } [EOL]     if (_defaultImpl.getRawClass() == NoClass.class) { [EOL]         return NullifyingDeserializer.instance; [EOL]     } [EOL]     synchronized (_defaultImpl) { [EOL]         if (_defaultImplDeserializer == null) { [EOL]             _defaultImplDeserializer = ctxt.findContextualValueDeserializer(_defaultImpl, _property); [EOL]         } [EOL]         return _defaultImplDeserializer; [EOL]     } [EOL] }
public <T> SimpleAbstractTypeResolver addMapping(Class<T> superType, Class<? extends T> subType) { [EOL]     if (superType == subType) { [EOL]         throw new IllegalArgumentException("Can not add mapping from class to itself"); [EOL]     } [EOL]     if (!superType.isAssignableFrom(subType)) { [EOL]         throw new IllegalArgumentException("Can not add mapping from class " + superType.getName() + " to " + subType.getName() + ", as latter is not a subtype of former"); [EOL]     } [EOL]     if (!Modifier.isAbstract(superType.getModifiers())) { [EOL]         throw new IllegalArgumentException("Can not add mapping from class " + superType.getName() + " since it is not abstract"); [EOL]     } [EOL]     _mappings.put(new ClassKey(superType), subType); [EOL]     return this; [EOL] }
public <T> SimpleAbstractTypeResolver addMapping(Class<T> superType, Class<? extends T> subType) { [EOL]     if (superType == subType) { [EOL]         throw new IllegalArgumentException("Can not add mapping from class to itself"); [EOL]     } [EOL]     if (!superType.isAssignableFrom(subType)) { [EOL]         throw new IllegalArgumentException("Can not add mapping from class " + superType.getName() + " to " + subType.getName() + ", as latter is not a subtype of former"); [EOL]     } [EOL]     if (!Modifier.isAbstract(superType.getModifiers())) { [EOL]         throw new IllegalArgumentException("Can not add mapping from class " + superType.getName() + " since it is not abstract"); [EOL]     } [EOL]     _mappings.put(new ClassKey(superType), subType); [EOL]     return this; [EOL] }
public <T> SimpleAbstractTypeResolver addMapping(Class<T> superType, Class<? extends T> subType) { [EOL]     if (superType == subType) { [EOL]         throw new IllegalArgumentException("Can not add mapping from class to itself"); [EOL]     } [EOL]     if (!superType.isAssignableFrom(subType)) { [EOL]         throw new IllegalArgumentException("Can not add mapping from class " + superType.getName() + " to " + subType.getName() + ", as latter is not a subtype of former"); [EOL]     } [EOL]     if (!Modifier.isAbstract(superType.getModifiers())) { [EOL]         throw new IllegalArgumentException("Can not add mapping from class " + superType.getName() + " since it is not abstract"); [EOL]     } [EOL]     _mappings.put(new ClassKey(superType), subType); [EOL]     return this; [EOL] }
public <T> SimpleAbstractTypeResolver addMapping(Class<T> superType, Class<? extends T> subType) { [EOL]     if (superType == subType) { [EOL]         throw new IllegalArgumentException("Can not add mapping from class to itself"); [EOL]     } [EOL]     if (!superType.isAssignableFrom(subType)) { [EOL]         throw new IllegalArgumentException("Can not add mapping from class " + superType.getName() + " to " + subType.getName() + ", as latter is not a subtype of former"); [EOL]     } [EOL]     if (!Modifier.isAbstract(superType.getModifiers())) { [EOL]         throw new IllegalArgumentException("Can not add mapping from class " + superType.getName() + " since it is not abstract"); [EOL]     } [EOL]     _mappings.put(new ClassKey(superType), subType); [EOL]     return this; [EOL] }
@Override [EOL] public JavaType findTypeMapping(DeserializationConfig config, JavaType type) { [EOL]     Class<?> src = type.getRawClass(); [EOL]     Class<?> dst = _mappings.get(new ClassKey(src)); [EOL]     if (dst == null) { [EOL]         return null; [EOL]     } [EOL]     return type.narrowBy(dst); [EOL] }
@Override [EOL] public JavaType findTypeMapping(DeserializationConfig config, JavaType type) { [EOL]     Class<?> src = type.getRawClass(); [EOL]     Class<?> dst = _mappings.get(new ClassKey(src)); [EOL]     if (dst == null) { [EOL]         return null; [EOL]     } [EOL]     return type.narrowBy(dst); [EOL] }
@Override [EOL] public BasicBeanDescription forDeserialization(DeserializationConfig cfg, JavaType type, MixInResolver r) { [EOL]     BasicBeanDescription desc = _findCachedDesc(type); [EOL]     if (desc == null) { [EOL]         desc = BasicBeanDescription.forDeserialization(collectProperties(cfg, type, r, false, "set")); [EOL]     } [EOL]     return desc; [EOL] }
@Override [EOL] public BasicBeanDescription forDeserialization(DeserializationConfig cfg, JavaType type, MixInResolver r) { [EOL]     BasicBeanDescription desc = _findCachedDesc(type); [EOL]     if (desc == null) { [EOL]         desc = BasicBeanDescription.forDeserialization(collectProperties(cfg, type, r, false, "set")); [EOL]     } [EOL]     return desc; [EOL] }
protected BasicBeanDescription _findCachedDesc(JavaType type) { [EOL]     Class<?> cls = type.getRawClass(); [EOL]     if (cls == String.class) { [EOL]         return STRING_DESC; [EOL]     } [EOL]     if (cls == Boolean.TYPE) { [EOL]         return BOOLEAN_DESC; [EOL]     } [EOL]     if (cls == Integer.TYPE) { [EOL]         return INT_DESC; [EOL]     } [EOL]     if (cls == Long.TYPE) { [EOL]         return LONG_DESC; [EOL]     } [EOL]     return null; [EOL] }
protected BasicBeanDescription _findCachedDesc(JavaType type) { [EOL]     Class<?> cls = type.getRawClass(); [EOL]     if (cls == String.class) { [EOL]         return STRING_DESC; [EOL]     } [EOL]     if (cls == Boolean.TYPE) { [EOL]         return BOOLEAN_DESC; [EOL]     } [EOL]     if (cls == Integer.TYPE) { [EOL]         return INT_DESC; [EOL]     } [EOL]     if (cls == Long.TYPE) { [EOL]         return LONG_DESC; [EOL]     } [EOL]     return null; [EOL] }
protected BasicBeanDescription _findCachedDesc(JavaType type) { [EOL]     Class<?> cls = type.getRawClass(); [EOL]     if (cls == String.class) { [EOL]         return STRING_DESC; [EOL]     } [EOL]     if (cls == Boolean.TYPE) { [EOL]         return BOOLEAN_DESC; [EOL]     } [EOL]     if (cls == Integer.TYPE) { [EOL]         return INT_DESC; [EOL]     } [EOL]     if (cls == Long.TYPE) { [EOL]         return LONG_DESC; [EOL]     } [EOL]     return null; [EOL] }
protected BasicBeanDescription _findCachedDesc(JavaType type) { [EOL]     Class<?> cls = type.getRawClass(); [EOL]     if (cls == String.class) { [EOL]         return STRING_DESC; [EOL]     } [EOL]     if (cls == Boolean.TYPE) { [EOL]         return BOOLEAN_DESC; [EOL]     } [EOL]     if (cls == Integer.TYPE) { [EOL]         return INT_DESC; [EOL]     } [EOL]     if (cls == Long.TYPE) { [EOL]         return LONG_DESC; [EOL]     } [EOL]     return null; [EOL] }
protected BasicBeanDescription _findCachedDesc(JavaType type) { [EOL]     Class<?> cls = type.getRawClass(); [EOL]     if (cls == String.class) { [EOL]         return STRING_DESC; [EOL]     } [EOL]     if (cls == Boolean.TYPE) { [EOL]         return BOOLEAN_DESC; [EOL]     } [EOL]     if (cls == Integer.TYPE) { [EOL]         return INT_DESC; [EOL]     } [EOL]     if (cls == Long.TYPE) { [EOL]         return LONG_DESC; [EOL]     } [EOL]     return null; [EOL] }
public ArrayBlockingQueueDeserializer(JavaType collectionType, JsonDeserializer<Object> valueDeser, TypeDeserializer valueTypeDeser, ValueInstantiator valueInstantiator, JsonDeserializer<Object> delegateDeser) { [EOL]     super(collectionType, valueDeser, valueTypeDeser, valueInstantiator, delegateDeser); [EOL] }
@Override [EOL] @SuppressWarnings("unchecked") [EOL] protected ArrayBlockingQueueDeserializer withResolved(JsonDeserializer<?> dd, JsonDeserializer<?> vd, TypeDeserializer vtd) { [EOL]     if ((dd == _delegateDeserializer) && (vd == _valueDeserializer) && (vtd == _valueTypeDeserializer)) { [EOL]         return this; [EOL]     } [EOL]     return new ArrayBlockingQueueDeserializer(_collectionType, (JsonDeserializer<Object>) vd, vtd, _valueInstantiator, (JsonDeserializer<Object>) dd); [EOL] }
@Override [EOL] @SuppressWarnings("unchecked") [EOL] protected ArrayBlockingQueueDeserializer withResolved(JsonDeserializer<?> dd, JsonDeserializer<?> vd, TypeDeserializer vtd) { [EOL]     if ((dd == _delegateDeserializer) && (vd == _valueDeserializer) && (vtd == _valueTypeDeserializer)) { [EOL]         return this; [EOL]     } [EOL]     return new ArrayBlockingQueueDeserializer(_collectionType, (JsonDeserializer<Object>) vd, vtd, _valueInstantiator, (JsonDeserializer<Object>) dd); [EOL] }
@Override [EOL] @SuppressWarnings("unchecked") [EOL] protected ArrayBlockingQueueDeserializer withResolved(JsonDeserializer<?> dd, JsonDeserializer<?> vd, TypeDeserializer vtd) { [EOL]     if ((dd == _delegateDeserializer) && (vd == _valueDeserializer) && (vtd == _valueTypeDeserializer)) { [EOL]         return this; [EOL]     } [EOL]     return new ArrayBlockingQueueDeserializer(_collectionType, (JsonDeserializer<Object>) vd, vtd, _valueInstantiator, (JsonDeserializer<Object>) dd); [EOL] }
@Override [EOL] @SuppressWarnings("unchecked") [EOL] protected ArrayBlockingQueueDeserializer withResolved(JsonDeserializer<?> dd, JsonDeserializer<?> vd, TypeDeserializer vtd) { [EOL]     if ((dd == _delegateDeserializer) && (vd == _valueDeserializer) && (vtd == _valueTypeDeserializer)) { [EOL]         return this; [EOL]     } [EOL]     return new ArrayBlockingQueueDeserializer(_collectionType, (JsonDeserializer<Object>) vd, vtd, _valueInstantiator, (JsonDeserializer<Object>) dd); [EOL] }
@SuppressWarnings("unchecked") [EOL] @Override [EOL] public Collection<Object> deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_delegateDeserializer != null) { [EOL]         return (Collection<Object>) _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]     } [EOL]     if (jp.getCurrentToken() == JsonToken.VALUE_STRING) { [EOL]         String str = jp.getText(); [EOL]         if (str.length() == 0) { [EOL]             return (Collection<Object>) _valueInstantiator.createFromString(ctxt, str); [EOL]         } [EOL]     } [EOL]     return deserialize(jp, ctxt, null); [EOL] }
@SuppressWarnings("unchecked") [EOL] @Override [EOL] public Collection<Object> deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_delegateDeserializer != null) { [EOL]         return (Collection<Object>) _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]     } [EOL]     if (jp.getCurrentToken() == JsonToken.VALUE_STRING) { [EOL]         String str = jp.getText(); [EOL]         if (str.length() == 0) { [EOL]             return (Collection<Object>) _valueInstantiator.createFromString(ctxt, str); [EOL]         } [EOL]     } [EOL]     return deserialize(jp, ctxt, null); [EOL] }
@SuppressWarnings("unchecked") [EOL] @Override [EOL] public Collection<Object> deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_delegateDeserializer != null) { [EOL]         return (Collection<Object>) _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]     } [EOL]     if (jp.getCurrentToken() == JsonToken.VALUE_STRING) { [EOL]         String str = jp.getText(); [EOL]         if (str.length() == 0) { [EOL]             return (Collection<Object>) _valueInstantiator.createFromString(ctxt, str); [EOL]         } [EOL]     } [EOL]     return deserialize(jp, ctxt, null); [EOL] }
@SuppressWarnings("unchecked") [EOL] @Override [EOL] public Collection<Object> deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_delegateDeserializer != null) { [EOL]         return (Collection<Object>) _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]     } [EOL]     if (jp.getCurrentToken() == JsonToken.VALUE_STRING) { [EOL]         String str = jp.getText(); [EOL]         if (str.length() == 0) { [EOL]             return (Collection<Object>) _valueInstantiator.createFromString(ctxt, str); [EOL]         } [EOL]     } [EOL]     return deserialize(jp, ctxt, null); [EOL] }
@Override [EOL] public Collection<Object> deserialize(JsonParser jp, DeserializationContext ctxt, Collection<Object> result0) throws IOException, JsonProcessingException { [EOL]     if (!jp.isExpectedStartArrayToken()) { [EOL]         return handleNonArray(jp, ctxt, new ArrayBlockingQueue<Object>(1)); [EOL]     } [EOL]     ArrayList<Object> tmp = new ArrayList<Object>(); [EOL]     JsonDeserializer<Object> valueDes = _valueDeserializer; [EOL]     JsonToken t; [EOL]     final TypeDeserializer typeDeser = _valueTypeDeserializer; [EOL]     while ((t = jp.nextToken()) != JsonToken.END_ARRAY) { [EOL]         Object value; [EOL]         if (t == JsonToken.VALUE_NULL) { [EOL]             value = null; [EOL]         } else if (typeDeser == null) { [EOL]             value = valueDes.deserialize(jp, ctxt); [EOL]         } else { [EOL]             value = valueDes.deserializeWithType(jp, ctxt, typeDeser); [EOL]         } [EOL]         tmp.add(value); [EOL]     } [EOL]     if (result0 != null) { [EOL]         result0.addAll(tmp); [EOL]         return result0; [EOL]     } [EOL]     return new ArrayBlockingQueue<Object>(tmp.size(), false, tmp); [EOL] }
@Override [EOL] public Collection<Object> deserialize(JsonParser jp, DeserializationContext ctxt, Collection<Object> result0) throws IOException, JsonProcessingException { [EOL]     if (!jp.isExpectedStartArrayToken()) { [EOL]         return handleNonArray(jp, ctxt, new ArrayBlockingQueue<Object>(1)); [EOL]     } [EOL]     ArrayList<Object> tmp = new ArrayList<Object>(); [EOL]     JsonDeserializer<Object> valueDes = _valueDeserializer; [EOL]     JsonToken t; [EOL]     final TypeDeserializer typeDeser = _valueTypeDeserializer; [EOL]     while ((t = jp.nextToken()) != JsonToken.END_ARRAY) { [EOL]         Object value; [EOL]         if (t == JsonToken.VALUE_NULL) { [EOL]             value = null; [EOL]         } else if (typeDeser == null) { [EOL]             value = valueDes.deserialize(jp, ctxt); [EOL]         } else { [EOL]             value = valueDes.deserializeWithType(jp, ctxt, typeDeser); [EOL]         } [EOL]         tmp.add(value); [EOL]     } [EOL]     if (result0 != null) { [EOL]         result0.addAll(tmp); [EOL]         return result0; [EOL]     } [EOL]     return new ArrayBlockingQueue<Object>(tmp.size(), false, tmp); [EOL] }
@Override [EOL] public Collection<Object> deserialize(JsonParser jp, DeserializationContext ctxt, Collection<Object> result0) throws IOException, JsonProcessingException { [EOL]     if (!jp.isExpectedStartArrayToken()) { [EOL]         return handleNonArray(jp, ctxt, new ArrayBlockingQueue<Object>(1)); [EOL]     } [EOL]     ArrayList<Object> tmp = new ArrayList<Object>(); [EOL]     JsonDeserializer<Object> valueDes = _valueDeserializer; [EOL]     JsonToken t; [EOL]     final TypeDeserializer typeDeser = _valueTypeDeserializer; [EOL]     while ((t = jp.nextToken()) != JsonToken.END_ARRAY) { [EOL]         Object value; [EOL]         if (t == JsonToken.VALUE_NULL) { [EOL]             value = null; [EOL]         } else if (typeDeser == null) { [EOL]             value = valueDes.deserialize(jp, ctxt); [EOL]         } else { [EOL]             value = valueDes.deserializeWithType(jp, ctxt, typeDeser); [EOL]         } [EOL]         tmp.add(value); [EOL]     } [EOL]     if (result0 != null) { [EOL]         result0.addAll(tmp); [EOL]         return result0; [EOL]     } [EOL]     return new ArrayBlockingQueue<Object>(tmp.size(), false, tmp); [EOL] }
@Override [EOL] public Collection<Object> deserialize(JsonParser jp, DeserializationContext ctxt, Collection<Object> result0) throws IOException, JsonProcessingException { [EOL]     if (!jp.isExpectedStartArrayToken()) { [EOL]         return handleNonArray(jp, ctxt, new ArrayBlockingQueue<Object>(1)); [EOL]     } [EOL]     ArrayList<Object> tmp = new ArrayList<Object>(); [EOL]     JsonDeserializer<Object> valueDes = _valueDeserializer; [EOL]     JsonToken t; [EOL]     final TypeDeserializer typeDeser = _valueTypeDeserializer; [EOL]     while ((t = jp.nextToken()) != JsonToken.END_ARRAY) { [EOL]         Object value; [EOL]         if (t == JsonToken.VALUE_NULL) { [EOL]             value = null; [EOL]         } else if (typeDeser == null) { [EOL]             value = valueDes.deserialize(jp, ctxt); [EOL]         } else { [EOL]             value = valueDes.deserializeWithType(jp, ctxt, typeDeser); [EOL]         } [EOL]         tmp.add(value); [EOL]     } [EOL]     if (result0 != null) { [EOL]         result0.addAll(tmp); [EOL]         return result0; [EOL]     } [EOL]     return new ArrayBlockingQueue<Object>(tmp.size(), false, tmp); [EOL] }
protected final String _idFrom(Object value, Class<?> cls) { [EOL]     if (Enum.class.isAssignableFrom(cls)) { [EOL]         if (!cls.isEnum()) { [EOL]             cls = cls.getSuperclass(); [EOL]         } [EOL]     } [EOL]     String str = cls.getName(); [EOL]     if (str.startsWith("java.util")) { [EOL]         if (value instanceof EnumSet<?>) { [EOL]             Class<?> enumClass = ClassUtil.findEnumType((EnumSet<?>) value); [EOL]             str = TypeFactory.defaultInstance().constructCollectionType(EnumSet.class, enumClass).toCanonical(); [EOL]         } else if (value instanceof EnumMap<?, ?>) { [EOL]             Class<?> enumClass = ClassUtil.findEnumType((EnumMap<?, ?>) value); [EOL]             Class<?> valueClass = Object.class; [EOL]             str = TypeFactory.defaultInstance().constructMapType(EnumMap.class, enumClass, valueClass).toCanonical(); [EOL]         } else { [EOL]             String end = str.substring(9); [EOL]             if ((end.startsWith(".Arrays$") || end.startsWith(".Collections$")) && str.indexOf("List") >= 0) { [EOL]                 str = "java.util.ArrayList"; [EOL]             } [EOL]         } [EOL]     } else if (str.indexOf('$') >= 0) { [EOL]         Class<?> outer = ClassUtil.getOuterClass(cls); [EOL]         if (outer != null) { [EOL]             Class<?> staticType = _baseType.getRawClass(); [EOL]             if (ClassUtil.getOuterClass(staticType) == null) { [EOL]                 cls = _baseType.getRawClass(); [EOL]                 str = cls.getName(); [EOL]             } [EOL]         } [EOL]     } [EOL]     return str; [EOL] }
protected final String _idFrom(Object value, Class<?> cls) { [EOL]     if (Enum.class.isAssignableFrom(cls)) { [EOL]         if (!cls.isEnum()) { [EOL]             cls = cls.getSuperclass(); [EOL]         } [EOL]     } [EOL]     String str = cls.getName(); [EOL]     if (str.startsWith("java.util")) { [EOL]         if (value instanceof EnumSet<?>) { [EOL]             Class<?> enumClass = ClassUtil.findEnumType((EnumSet<?>) value); [EOL]             str = TypeFactory.defaultInstance().constructCollectionType(EnumSet.class, enumClass).toCanonical(); [EOL]         } else if (value instanceof EnumMap<?, ?>) { [EOL]             Class<?> enumClass = ClassUtil.findEnumType((EnumMap<?, ?>) value); [EOL]             Class<?> valueClass = Object.class; [EOL]             str = TypeFactory.defaultInstance().constructMapType(EnumMap.class, enumClass, valueClass).toCanonical(); [EOL]         } else { [EOL]             String end = str.substring(9); [EOL]             if ((end.startsWith(".Arrays$") || end.startsWith(".Collections$")) && str.indexOf("List") >= 0) { [EOL]                 str = "java.util.ArrayList"; [EOL]             } [EOL]         } [EOL]     } else if (str.indexOf('$') >= 0) { [EOL]         Class<?> outer = ClassUtil.getOuterClass(cls); [EOL]         if (outer != null) { [EOL]             Class<?> staticType = _baseType.getRawClass(); [EOL]             if (ClassUtil.getOuterClass(staticType) == null) { [EOL]                 cls = _baseType.getRawClass(); [EOL]                 str = cls.getName(); [EOL]             } [EOL]         } [EOL]     } [EOL]     return str; [EOL] }
protected final String _idFrom(Object value, Class<?> cls) { [EOL]     if (Enum.class.isAssignableFrom(cls)) { [EOL]         if (!cls.isEnum()) { [EOL]             cls = cls.getSuperclass(); [EOL]         } [EOL]     } [EOL]     String str = cls.getName(); [EOL]     if (str.startsWith("java.util")) { [EOL]         if (value instanceof EnumSet<?>) { [EOL]             Class<?> enumClass = ClassUtil.findEnumType((EnumSet<?>) value); [EOL]             str = TypeFactory.defaultInstance().constructCollectionType(EnumSet.class, enumClass).toCanonical(); [EOL]         } else if (value instanceof EnumMap<?, ?>) { [EOL]             Class<?> enumClass = ClassUtil.findEnumType((EnumMap<?, ?>) value); [EOL]             Class<?> valueClass = Object.class; [EOL]             str = TypeFactory.defaultInstance().constructMapType(EnumMap.class, enumClass, valueClass).toCanonical(); [EOL]         } else { [EOL]             String end = str.substring(9); [EOL]             if ((end.startsWith(".Arrays$") || end.startsWith(".Collections$")) && str.indexOf("List") >= 0) { [EOL]                 str = "java.util.ArrayList"; [EOL]             } [EOL]         } [EOL]     } else if (str.indexOf('$') >= 0) { [EOL]         Class<?> outer = ClassUtil.getOuterClass(cls); [EOL]         if (outer != null) { [EOL]             Class<?> staticType = _baseType.getRawClass(); [EOL]             if (ClassUtil.getOuterClass(staticType) == null) { [EOL]                 cls = _baseType.getRawClass(); [EOL]                 str = cls.getName(); [EOL]             } [EOL]         } [EOL]     } [EOL]     return str; [EOL] }
protected final String _idFrom(Object value, Class<?> cls) { [EOL]     if (Enum.class.isAssignableFrom(cls)) { [EOL]         if (!cls.isEnum()) { [EOL]             cls = cls.getSuperclass(); [EOL]         } [EOL]     } [EOL]     String str = cls.getName(); [EOL]     if (str.startsWith("java.util")) { [EOL]         if (value instanceof EnumSet<?>) { [EOL]             Class<?> enumClass = ClassUtil.findEnumType((EnumSet<?>) value); [EOL]             str = TypeFactory.defaultInstance().constructCollectionType(EnumSet.class, enumClass).toCanonical(); [EOL]         } else if (value instanceof EnumMap<?, ?>) { [EOL]             Class<?> enumClass = ClassUtil.findEnumType((EnumMap<?, ?>) value); [EOL]             Class<?> valueClass = Object.class; [EOL]             str = TypeFactory.defaultInstance().constructMapType(EnumMap.class, enumClass, valueClass).toCanonical(); [EOL]         } else { [EOL]             String end = str.substring(9); [EOL]             if ((end.startsWith(".Arrays$") || end.startsWith(".Collections$")) && str.indexOf("List") >= 0) { [EOL]                 str = "java.util.ArrayList"; [EOL]             } [EOL]         } [EOL]     } else if (str.indexOf('$') >= 0) { [EOL]         Class<?> outer = ClassUtil.getOuterClass(cls); [EOL]         if (outer != null) { [EOL]             Class<?> staticType = _baseType.getRawClass(); [EOL]             if (ClassUtil.getOuterClass(staticType) == null) { [EOL]                 cls = _baseType.getRawClass(); [EOL]                 str = cls.getName(); [EOL]             } [EOL]         } [EOL]     } [EOL]     return str; [EOL] }
protected final String _idFrom(Object value, Class<?> cls) { [EOL]     if (Enum.class.isAssignableFrom(cls)) { [EOL]         if (!cls.isEnum()) { [EOL]             cls = cls.getSuperclass(); [EOL]         } [EOL]     } [EOL]     String str = cls.getName(); [EOL]     if (str.startsWith("java.util")) { [EOL]         if (value instanceof EnumSet<?>) { [EOL]             Class<?> enumClass = ClassUtil.findEnumType((EnumSet<?>) value); [EOL]             str = TypeFactory.defaultInstance().constructCollectionType(EnumSet.class, enumClass).toCanonical(); [EOL]         } else if (value instanceof EnumMap<?, ?>) { [EOL]             Class<?> enumClass = ClassUtil.findEnumType((EnumMap<?, ?>) value); [EOL]             Class<?> valueClass = Object.class; [EOL]             str = TypeFactory.defaultInstance().constructMapType(EnumMap.class, enumClass, valueClass).toCanonical(); [EOL]         } else { [EOL]             String end = str.substring(9); [EOL]             if ((end.startsWith(".Arrays$") || end.startsWith(".Collections$")) && str.indexOf("List") >= 0) { [EOL]                 str = "java.util.ArrayList"; [EOL]             } [EOL]         } [EOL]     } else if (str.indexOf('$') >= 0) { [EOL]         Class<?> outer = ClassUtil.getOuterClass(cls); [EOL]         if (outer != null) { [EOL]             Class<?> staticType = _baseType.getRawClass(); [EOL]             if (ClassUtil.getOuterClass(staticType) == null) { [EOL]                 cls = _baseType.getRawClass(); [EOL]                 str = cls.getName(); [EOL]             } [EOL]         } [EOL]     } [EOL]     return str; [EOL] }
protected final String _idFrom(Object value, Class<?> cls) { [EOL]     if (Enum.class.isAssignableFrom(cls)) { [EOL]         if (!cls.isEnum()) { [EOL]             cls = cls.getSuperclass(); [EOL]         } [EOL]     } [EOL]     String str = cls.getName(); [EOL]     if (str.startsWith("java.util")) { [EOL]         if (value instanceof EnumSet<?>) { [EOL]             Class<?> enumClass = ClassUtil.findEnumType((EnumSet<?>) value); [EOL]             str = TypeFactory.defaultInstance().constructCollectionType(EnumSet.class, enumClass).toCanonical(); [EOL]         } else if (value instanceof EnumMap<?, ?>) { [EOL]             Class<?> enumClass = ClassUtil.findEnumType((EnumMap<?, ?>) value); [EOL]             Class<?> valueClass = Object.class; [EOL]             str = TypeFactory.defaultInstance().constructMapType(EnumMap.class, enumClass, valueClass).toCanonical(); [EOL]         } else { [EOL]             String end = str.substring(9); [EOL]             if ((end.startsWith(".Arrays$") || end.startsWith(".Collections$")) && str.indexOf("List") >= 0) { [EOL]                 str = "java.util.ArrayList"; [EOL]             } [EOL]         } [EOL]     } else if (str.indexOf('$') >= 0) { [EOL]         Class<?> outer = ClassUtil.getOuterClass(cls); [EOL]         if (outer != null) { [EOL]             Class<?> staticType = _baseType.getRawClass(); [EOL]             if (ClassUtil.getOuterClass(staticType) == null) { [EOL]                 cls = _baseType.getRawClass(); [EOL]                 str = cls.getName(); [EOL]             } [EOL]         } [EOL]     } [EOL]     return str; [EOL] }
protected final String _idFrom(Object value, Class<?> cls) { [EOL]     if (Enum.class.isAssignableFrom(cls)) { [EOL]         if (!cls.isEnum()) { [EOL]             cls = cls.getSuperclass(); [EOL]         } [EOL]     } [EOL]     String str = cls.getName(); [EOL]     if (str.startsWith("java.util")) { [EOL]         if (value instanceof EnumSet<?>) { [EOL]             Class<?> enumClass = ClassUtil.findEnumType((EnumSet<?>) value); [EOL]             str = TypeFactory.defaultInstance().constructCollectionType(EnumSet.class, enumClass).toCanonical(); [EOL]         } else if (value instanceof EnumMap<?, ?>) { [EOL]             Class<?> enumClass = ClassUtil.findEnumType((EnumMap<?, ?>) value); [EOL]             Class<?> valueClass = Object.class; [EOL]             str = TypeFactory.defaultInstance().constructMapType(EnumMap.class, enumClass, valueClass).toCanonical(); [EOL]         } else { [EOL]             String end = str.substring(9); [EOL]             if ((end.startsWith(".Arrays$") || end.startsWith(".Collections$")) && str.indexOf("List") >= 0) { [EOL]                 str = "java.util.ArrayList"; [EOL]             } [EOL]         } [EOL]     } else if (str.indexOf('$') >= 0) { [EOL]         Class<?> outer = ClassUtil.getOuterClass(cls); [EOL]         if (outer != null) { [EOL]             Class<?> staticType = _baseType.getRawClass(); [EOL]             if (ClassUtil.getOuterClass(staticType) == null) { [EOL]                 cls = _baseType.getRawClass(); [EOL]                 str = cls.getName(); [EOL]             } [EOL]         } [EOL]     } [EOL]     return str; [EOL] }
protected BeanPropertyWriter buildWriter(BeanPropertyDefinition propDef, JavaType declaredType, JsonSerializer<?> ser, TypeSerializer typeSer, TypeSerializer contentTypeSer, AnnotatedMember am, boolean defaultUseStaticTyping) { [EOL]     JavaType serializationType = findSerializationType(am, defaultUseStaticTyping, declaredType); [EOL]     if (contentTypeSer != null) { [EOL]         if (serializationType == null) { [EOL]             serializationType = declaredType; [EOL]         } [EOL]         JavaType ct = serializationType.getContentType(); [EOL]         if (ct == null) { [EOL]             throw new IllegalStateException("Problem trying to create BeanPropertyWriter for property '" + propDef.getName() + "' (of type " + _beanDesc.getType() + "); serialization type " + serializationType + " has no content"); [EOL]         } [EOL]         serializationType = serializationType.withContentTypeHandler(contentTypeSer); [EOL]         ct = serializationType.getContentType(); [EOL]     } [EOL]     Object valueToSuppress = null; [EOL]     boolean suppressNulls = false; [EOL]     JsonInclude.Include methodProps = _annotationIntrospector.findSerializationInclusion(am, _outputProps); [EOL]     if (methodProps != null) { [EOL]         switch(methodProps) { [EOL]             case NON_DEFAULT: [EOL]                 valueToSuppress = getDefaultValue(propDef.getName(), am); [EOL]                 if (valueToSuppress == null) { [EOL]                     suppressNulls = true; [EOL]                 } else { [EOL]                     if (valueToSuppress.getClass().isArray()) { [EOL]                         valueToSuppress = ArrayBuilders.getArrayComparator(valueToSuppress); [EOL]                     } [EOL]                 } [EOL]                 break; [EOL]             case NON_EMPTY: [EOL]                 suppressNulls = true; [EOL]                 valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY; [EOL]                 break; [EOL]             case NON_NULL: [EOL]                 suppressNulls = true; [EOL]             case ALWAYS: [EOL]                 if (declaredType.isContainerType() && !_config.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS)) { [EOL]                     valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]     } [EOL]     BeanPropertyWriter bpw = new BeanPropertyWriter(propDef, am, _beanDesc.getClassAnnotations(), declaredType, ser, typeSer, serializationType, suppressNulls, valueToSuppress); [EOL]     NameTransformer unwrapper = _annotationIntrospector.findUnwrappingNameTransformer(am); [EOL]     if (unwrapper != null) { [EOL]         bpw = bpw.unwrappingWriter(unwrapper); [EOL]     } [EOL]     return bpw; [EOL] }
protected BeanPropertyWriter buildWriter(BeanPropertyDefinition propDef, JavaType declaredType, JsonSerializer<?> ser, TypeSerializer typeSer, TypeSerializer contentTypeSer, AnnotatedMember am, boolean defaultUseStaticTyping) { [EOL]     JavaType serializationType = findSerializationType(am, defaultUseStaticTyping, declaredType); [EOL]     if (contentTypeSer != null) { [EOL]         if (serializationType == null) { [EOL]             serializationType = declaredType; [EOL]         } [EOL]         JavaType ct = serializationType.getContentType(); [EOL]         if (ct == null) { [EOL]             throw new IllegalStateException("Problem trying to create BeanPropertyWriter for property '" + propDef.getName() + "' (of type " + _beanDesc.getType() + "); serialization type " + serializationType + " has no content"); [EOL]         } [EOL]         serializationType = serializationType.withContentTypeHandler(contentTypeSer); [EOL]         ct = serializationType.getContentType(); [EOL]     } [EOL]     Object valueToSuppress = null; [EOL]     boolean suppressNulls = false; [EOL]     JsonInclude.Include methodProps = _annotationIntrospector.findSerializationInclusion(am, _outputProps); [EOL]     if (methodProps != null) { [EOL]         switch(methodProps) { [EOL]             case NON_DEFAULT: [EOL]                 valueToSuppress = getDefaultValue(propDef.getName(), am); [EOL]                 if (valueToSuppress == null) { [EOL]                     suppressNulls = true; [EOL]                 } else { [EOL]                     if (valueToSuppress.getClass().isArray()) { [EOL]                         valueToSuppress = ArrayBuilders.getArrayComparator(valueToSuppress); [EOL]                     } [EOL]                 } [EOL]                 break; [EOL]             case NON_EMPTY: [EOL]                 suppressNulls = true; [EOL]                 valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY; [EOL]                 break; [EOL]             case NON_NULL: [EOL]                 suppressNulls = true; [EOL]             case ALWAYS: [EOL]                 if (declaredType.isContainerType() && !_config.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS)) { [EOL]                     valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]     } [EOL]     BeanPropertyWriter bpw = new BeanPropertyWriter(propDef, am, _beanDesc.getClassAnnotations(), declaredType, ser, typeSer, serializationType, suppressNulls, valueToSuppress); [EOL]     NameTransformer unwrapper = _annotationIntrospector.findUnwrappingNameTransformer(am); [EOL]     if (unwrapper != null) { [EOL]         bpw = bpw.unwrappingWriter(unwrapper); [EOL]     } [EOL]     return bpw; [EOL] }
protected BeanPropertyWriter buildWriter(BeanPropertyDefinition propDef, JavaType declaredType, JsonSerializer<?> ser, TypeSerializer typeSer, TypeSerializer contentTypeSer, AnnotatedMember am, boolean defaultUseStaticTyping) { [EOL]     JavaType serializationType = findSerializationType(am, defaultUseStaticTyping, declaredType); [EOL]     if (contentTypeSer != null) { [EOL]         if (serializationType == null) { [EOL]             serializationType = declaredType; [EOL]         } [EOL]         JavaType ct = serializationType.getContentType(); [EOL]         if (ct == null) { [EOL]             throw new IllegalStateException("Problem trying to create BeanPropertyWriter for property '" + propDef.getName() + "' (of type " + _beanDesc.getType() + "); serialization type " + serializationType + " has no content"); [EOL]         } [EOL]         serializationType = serializationType.withContentTypeHandler(contentTypeSer); [EOL]         ct = serializationType.getContentType(); [EOL]     } [EOL]     Object valueToSuppress = null; [EOL]     boolean suppressNulls = false; [EOL]     JsonInclude.Include methodProps = _annotationIntrospector.findSerializationInclusion(am, _outputProps); [EOL]     if (methodProps != null) { [EOL]         switch(methodProps) { [EOL]             case NON_DEFAULT: [EOL]                 valueToSuppress = getDefaultValue(propDef.getName(), am); [EOL]                 if (valueToSuppress == null) { [EOL]                     suppressNulls = true; [EOL]                 } else { [EOL]                     if (valueToSuppress.getClass().isArray()) { [EOL]                         valueToSuppress = ArrayBuilders.getArrayComparator(valueToSuppress); [EOL]                     } [EOL]                 } [EOL]                 break; [EOL]             case NON_EMPTY: [EOL]                 suppressNulls = true; [EOL]                 valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY; [EOL]                 break; [EOL]             case NON_NULL: [EOL]                 suppressNulls = true; [EOL]             case ALWAYS: [EOL]                 if (declaredType.isContainerType() && !_config.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS)) { [EOL]                     valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]     } [EOL]     BeanPropertyWriter bpw = new BeanPropertyWriter(propDef, am, _beanDesc.getClassAnnotations(), declaredType, ser, typeSer, serializationType, suppressNulls, valueToSuppress); [EOL]     NameTransformer unwrapper = _annotationIntrospector.findUnwrappingNameTransformer(am); [EOL]     if (unwrapper != null) { [EOL]         bpw = bpw.unwrappingWriter(unwrapper); [EOL]     } [EOL]     return bpw; [EOL] }
protected BeanPropertyWriter buildWriter(BeanPropertyDefinition propDef, JavaType declaredType, JsonSerializer<?> ser, TypeSerializer typeSer, TypeSerializer contentTypeSer, AnnotatedMember am, boolean defaultUseStaticTyping) { [EOL]     JavaType serializationType = findSerializationType(am, defaultUseStaticTyping, declaredType); [EOL]     if (contentTypeSer != null) { [EOL]         if (serializationType == null) { [EOL]             serializationType = declaredType; [EOL]         } [EOL]         JavaType ct = serializationType.getContentType(); [EOL]         if (ct == null) { [EOL]             throw new IllegalStateException("Problem trying to create BeanPropertyWriter for property '" + propDef.getName() + "' (of type " + _beanDesc.getType() + "); serialization type " + serializationType + " has no content"); [EOL]         } [EOL]         serializationType = serializationType.withContentTypeHandler(contentTypeSer); [EOL]         ct = serializationType.getContentType(); [EOL]     } [EOL]     Object valueToSuppress = null; [EOL]     boolean suppressNulls = false; [EOL]     JsonInclude.Include methodProps = _annotationIntrospector.findSerializationInclusion(am, _outputProps); [EOL]     if (methodProps != null) { [EOL]         switch(methodProps) { [EOL]             case NON_DEFAULT: [EOL]                 valueToSuppress = getDefaultValue(propDef.getName(), am); [EOL]                 if (valueToSuppress == null) { [EOL]                     suppressNulls = true; [EOL]                 } else { [EOL]                     if (valueToSuppress.getClass().isArray()) { [EOL]                         valueToSuppress = ArrayBuilders.getArrayComparator(valueToSuppress); [EOL]                     } [EOL]                 } [EOL]                 break; [EOL]             case NON_EMPTY: [EOL]                 suppressNulls = true; [EOL]                 valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY; [EOL]                 break; [EOL]             case NON_NULL: [EOL]                 suppressNulls = true; [EOL]             case ALWAYS: [EOL]                 if (declaredType.isContainerType() && !_config.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS)) { [EOL]                     valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]     } [EOL]     BeanPropertyWriter bpw = new BeanPropertyWriter(propDef, am, _beanDesc.getClassAnnotations(), declaredType, ser, typeSer, serializationType, suppressNulls, valueToSuppress); [EOL]     NameTransformer unwrapper = _annotationIntrospector.findUnwrappingNameTransformer(am); [EOL]     if (unwrapper != null) { [EOL]         bpw = bpw.unwrappingWriter(unwrapper); [EOL]     } [EOL]     return bpw; [EOL] }
protected BeanPropertyWriter buildWriter(BeanPropertyDefinition propDef, JavaType declaredType, JsonSerializer<?> ser, TypeSerializer typeSer, TypeSerializer contentTypeSer, AnnotatedMember am, boolean defaultUseStaticTyping) { [EOL]     JavaType serializationType = findSerializationType(am, defaultUseStaticTyping, declaredType); [EOL]     if (contentTypeSer != null) { [EOL]         if (serializationType == null) { [EOL]             serializationType = declaredType; [EOL]         } [EOL]         JavaType ct = serializationType.getContentType(); [EOL]         if (ct == null) { [EOL]             throw new IllegalStateException("Problem trying to create BeanPropertyWriter for property '" + propDef.getName() + "' (of type " + _beanDesc.getType() + "); serialization type " + serializationType + " has no content"); [EOL]         } [EOL]         serializationType = serializationType.withContentTypeHandler(contentTypeSer); [EOL]         ct = serializationType.getContentType(); [EOL]     } [EOL]     Object valueToSuppress = null; [EOL]     boolean suppressNulls = false; [EOL]     JsonInclude.Include methodProps = _annotationIntrospector.findSerializationInclusion(am, _outputProps); [EOL]     if (methodProps != null) { [EOL]         switch(methodProps) { [EOL]             case NON_DEFAULT: [EOL]                 valueToSuppress = getDefaultValue(propDef.getName(), am); [EOL]                 if (valueToSuppress == null) { [EOL]                     suppressNulls = true; [EOL]                 } else { [EOL]                     if (valueToSuppress.getClass().isArray()) { [EOL]                         valueToSuppress = ArrayBuilders.getArrayComparator(valueToSuppress); [EOL]                     } [EOL]                 } [EOL]                 break; [EOL]             case NON_EMPTY: [EOL]                 suppressNulls = true; [EOL]                 valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY; [EOL]                 break; [EOL]             case NON_NULL: [EOL]                 suppressNulls = true; [EOL]             case ALWAYS: [EOL]                 if (declaredType.isContainerType() && !_config.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS)) { [EOL]                     valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]     } [EOL]     BeanPropertyWriter bpw = new BeanPropertyWriter(propDef, am, _beanDesc.getClassAnnotations(), declaredType, ser, typeSer, serializationType, suppressNulls, valueToSuppress); [EOL]     NameTransformer unwrapper = _annotationIntrospector.findUnwrappingNameTransformer(am); [EOL]     if (unwrapper != null) { [EOL]         bpw = bpw.unwrappingWriter(unwrapper); [EOL]     } [EOL]     return bpw; [EOL] }
protected BeanPropertyWriter buildWriter(BeanPropertyDefinition propDef, JavaType declaredType, JsonSerializer<?> ser, TypeSerializer typeSer, TypeSerializer contentTypeSer, AnnotatedMember am, boolean defaultUseStaticTyping) { [EOL]     JavaType serializationType = findSerializationType(am, defaultUseStaticTyping, declaredType); [EOL]     if (contentTypeSer != null) { [EOL]         if (serializationType == null) { [EOL]             serializationType = declaredType; [EOL]         } [EOL]         JavaType ct = serializationType.getContentType(); [EOL]         if (ct == null) { [EOL]             throw new IllegalStateException("Problem trying to create BeanPropertyWriter for property '" + propDef.getName() + "' (of type " + _beanDesc.getType() + "); serialization type " + serializationType + " has no content"); [EOL]         } [EOL]         serializationType = serializationType.withContentTypeHandler(contentTypeSer); [EOL]         ct = serializationType.getContentType(); [EOL]     } [EOL]     Object valueToSuppress = null; [EOL]     boolean suppressNulls = false; [EOL]     JsonInclude.Include methodProps = _annotationIntrospector.findSerializationInclusion(am, _outputProps); [EOL]     if (methodProps != null) { [EOL]         switch(methodProps) { [EOL]             case NON_DEFAULT: [EOL]                 valueToSuppress = getDefaultValue(propDef.getName(), am); [EOL]                 if (valueToSuppress == null) { [EOL]                     suppressNulls = true; [EOL]                 } else { [EOL]                     if (valueToSuppress.getClass().isArray()) { [EOL]                         valueToSuppress = ArrayBuilders.getArrayComparator(valueToSuppress); [EOL]                     } [EOL]                 } [EOL]                 break; [EOL]             case NON_EMPTY: [EOL]                 suppressNulls = true; [EOL]                 valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY; [EOL]                 break; [EOL]             case NON_NULL: [EOL]                 suppressNulls = true; [EOL]             case ALWAYS: [EOL]                 if (declaredType.isContainerType() && !_config.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS)) { [EOL]                     valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]     } [EOL]     BeanPropertyWriter bpw = new BeanPropertyWriter(propDef, am, _beanDesc.getClassAnnotations(), declaredType, ser, typeSer, serializationType, suppressNulls, valueToSuppress); [EOL]     NameTransformer unwrapper = _annotationIntrospector.findUnwrappingNameTransformer(am); [EOL]     if (unwrapper != null) { [EOL]         bpw = bpw.unwrappingWriter(unwrapper); [EOL]     } [EOL]     return bpw; [EOL] }
protected BeanPropertyWriter buildWriter(BeanPropertyDefinition propDef, JavaType declaredType, JsonSerializer<?> ser, TypeSerializer typeSer, TypeSerializer contentTypeSer, AnnotatedMember am, boolean defaultUseStaticTyping) { [EOL]     JavaType serializationType = findSerializationType(am, defaultUseStaticTyping, declaredType); [EOL]     if (contentTypeSer != null) { [EOL]         if (serializationType == null) { [EOL]             serializationType = declaredType; [EOL]         } [EOL]         JavaType ct = serializationType.getContentType(); [EOL]         if (ct == null) { [EOL]             throw new IllegalStateException("Problem trying to create BeanPropertyWriter for property '" + propDef.getName() + "' (of type " + _beanDesc.getType() + "); serialization type " + serializationType + " has no content"); [EOL]         } [EOL]         serializationType = serializationType.withContentTypeHandler(contentTypeSer); [EOL]         ct = serializationType.getContentType(); [EOL]     } [EOL]     Object valueToSuppress = null; [EOL]     boolean suppressNulls = false; [EOL]     JsonInclude.Include methodProps = _annotationIntrospector.findSerializationInclusion(am, _outputProps); [EOL]     if (methodProps != null) { [EOL]         switch(methodProps) { [EOL]             case NON_DEFAULT: [EOL]                 valueToSuppress = getDefaultValue(propDef.getName(), am); [EOL]                 if (valueToSuppress == null) { [EOL]                     suppressNulls = true; [EOL]                 } else { [EOL]                     if (valueToSuppress.getClass().isArray()) { [EOL]                         valueToSuppress = ArrayBuilders.getArrayComparator(valueToSuppress); [EOL]                     } [EOL]                 } [EOL]                 break; [EOL]             case NON_EMPTY: [EOL]                 suppressNulls = true; [EOL]                 valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY; [EOL]                 break; [EOL]             case NON_NULL: [EOL]                 suppressNulls = true; [EOL]             case ALWAYS: [EOL]                 if (declaredType.isContainerType() && !_config.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS)) { [EOL]                     valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]     } [EOL]     BeanPropertyWriter bpw = new BeanPropertyWriter(propDef, am, _beanDesc.getClassAnnotations(), declaredType, ser, typeSer, serializationType, suppressNulls, valueToSuppress); [EOL]     NameTransformer unwrapper = _annotationIntrospector.findUnwrappingNameTransformer(am); [EOL]     if (unwrapper != null) { [EOL]         bpw = bpw.unwrappingWriter(unwrapper); [EOL]     } [EOL]     return bpw; [EOL] }
protected JavaType findSerializationType(Annotated a, boolean useStaticTyping, JavaType declaredType) { [EOL]     Class<?> serClass = _annotationIntrospector.findSerializationType(a); [EOL]     if (serClass != null) { [EOL]         Class<?> rawDeclared = declaredType.getRawClass(); [EOL]         if (serClass.isAssignableFrom(rawDeclared)) { [EOL]             declaredType = declaredType.widenBy(serClass); [EOL]         } else { [EOL]             if (!rawDeclared.isAssignableFrom(serClass)) { [EOL]                 throw new IllegalArgumentException("Illegal concrete-type annotation for method '" + a.getName() + "': class " + serClass.getName() + " not a super-type of (declared) class " + rawDeclared.getName()); [EOL]             } [EOL]             declaredType = _config.constructSpecializedType(declaredType, serClass); [EOL]         } [EOL]         useStaticTyping = true; [EOL]     } [EOL]     JavaType secondary = BeanSerializerFactory.modifySecondaryTypesByAnnotation(_config, a, declaredType); [EOL]     if (secondary != declaredType) { [EOL]         useStaticTyping = true; [EOL]         declaredType = secondary; [EOL]     } [EOL]     if (!useStaticTyping) { [EOL]         JsonSerialize.Typing typing = _annotationIntrospector.findSerializationTyping(a); [EOL]         if (typing != null) { [EOL]             useStaticTyping = (typing == JsonSerialize.Typing.STATIC); [EOL]         } [EOL]     } [EOL]     return useStaticTyping ? declaredType : null; [EOL] }
@Override [EOL] public String toString() { [EOL]     return this.schema.toString(); [EOL] }
@Override [EOL] public void serialize(Collection<String> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if ((value.size() == 1) && provider.isEnabled(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED)) { [EOL]         _serializeUnwrapped(value, jgen, provider); [EOL]         return; [EOL]     } [EOL]     jgen.writeStartArray(); [EOL]     if (_serializer == null) { [EOL]         serializeContents(value, jgen, provider); [EOL]     } else { [EOL]         serializeUsingCustom(value, jgen, provider); [EOL]     } [EOL]     jgen.writeEndArray(); [EOL] }
@Override [EOL] public void serialize(Collection<String> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if ((value.size() == 1) && provider.isEnabled(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED)) { [EOL]         _serializeUnwrapped(value, jgen, provider); [EOL]         return; [EOL]     } [EOL]     jgen.writeStartArray(); [EOL]     if (_serializer == null) { [EOL]         serializeContents(value, jgen, provider); [EOL]     } else { [EOL]         serializeUsingCustom(value, jgen, provider); [EOL]     } [EOL]     jgen.writeEndArray(); [EOL] }
@Override [EOL] public void serialize(Collection<String> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if ((value.size() == 1) && provider.isEnabled(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED)) { [EOL]         _serializeUnwrapped(value, jgen, provider); [EOL]         return; [EOL]     } [EOL]     jgen.writeStartArray(); [EOL]     if (_serializer == null) { [EOL]         serializeContents(value, jgen, provider); [EOL]     } else { [EOL]         serializeUsingCustom(value, jgen, provider); [EOL]     } [EOL]     jgen.writeEndArray(); [EOL] }
private final void _serializeUnwrapped(Collection<String> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (_serializer == null) { [EOL]         serializeContents(value, jgen, provider); [EOL]     } else { [EOL]         serializeUsingCustom(value, jgen, provider); [EOL]     } [EOL] }
private final void _serializeUnwrapped(Collection<String> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (_serializer == null) { [EOL]         serializeContents(value, jgen, provider); [EOL]     } else { [EOL]         serializeUsingCustom(value, jgen, provider); [EOL]     } [EOL] }
public BaseSettings with(Base64Variant base64) { [EOL]     if (base64 == _defaultBase64) { [EOL]         return this; [EOL]     } [EOL]     return new BaseSettings(_classIntrospector, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory, _typeResolverBuilder, _dateFormat, _handlerInstantiator, _locale, _timeZone, base64); [EOL] }
public BaseSettings with(Base64Variant base64) { [EOL]     if (base64 == _defaultBase64) { [EOL]         return this; [EOL]     } [EOL]     return new BaseSettings(_classIntrospector, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory, _typeResolverBuilder, _dateFormat, _handlerInstantiator, _locale, _timeZone, base64); [EOL] }
public Base64Variant getBase64Variant() { [EOL]     return _defaultBase64; [EOL] }
public ByteBuilder getByteBuilder() { [EOL]     if (_byteBuilder == null) { [EOL]         _byteBuilder = new ByteBuilder(); [EOL]     } [EOL]     return _byteBuilder; [EOL] }
public ByteBuilder getByteBuilder() { [EOL]     if (_byteBuilder == null) { [EOL]         _byteBuilder = new ByteBuilder(); [EOL]     } [EOL]     return _byteBuilder; [EOL] }
public ByteBuilder() { [EOL] }
@Override [EOL] public final byte[] _constructArray(int len) { [EOL]     return new byte[len]; [EOL] }
@Override [EOL] public final byte[] _constructArray(int len) { [EOL]     return new byte[len]; [EOL] }
public static <T> HashSet<T> arrayToSet(T[] elements) { [EOL]     HashSet<T> result = new HashSet<T>(); [EOL]     if (elements != null) { [EOL]         for (T elem : elements) { [EOL]             result.add(elem); [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
public static <T> HashSet<T> arrayToSet(T[] elements) { [EOL]     HashSet<T> result = new HashSet<T>(); [EOL]     if (elements != null) { [EOL]         for (T elem : elements) { [EOL]             result.add(elem); [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
public static <T> HashSet<T> arrayToSet(T[] elements) { [EOL]     HashSet<T> result = new HashSet<T>(); [EOL]     if (elements != null) { [EOL]         for (T elem : elements) { [EOL]             result.add(elem); [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
public static <T> HashSet<T> arrayToSet(T[] elements) { [EOL]     HashSet<T> result = new HashSet<T>(); [EOL]     if (elements != null) { [EOL]         for (T elem : elements) { [EOL]             result.add(elem); [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
@SuppressWarnings("unchecked") [EOL] public static <T> T[] insertInListNoDup(T[] array, T element) { [EOL]     final int len = array.length; [EOL]     for (int ix = 0; ix < len; ++ix) { [EOL]         if (array[ix] == element) { [EOL]             if (ix == 0) { [EOL]                 return array; [EOL]             } [EOL]             T[] result = (T[]) Array.newInstance(array.getClass().getComponentType(), len); [EOL]             System.arraycopy(array, 0, result, 1, ix); [EOL]             result[0] = element; [EOL]             ++ix; [EOL]             int left = len - ix; [EOL]             if (left > 0) { [EOL]                 System.arraycopy(array, ix, result, ix, left); [EOL]             } [EOL]             return result; [EOL]         } [EOL]     } [EOL]     T[] result = (T[]) Array.newInstance(array.getClass().getComponentType(), len + 1); [EOL]     if (len > 0) { [EOL]         System.arraycopy(array, 0, result, 1, len); [EOL]     } [EOL]     result[0] = element; [EOL]     return result; [EOL] }
@SuppressWarnings("unchecked") [EOL] public static <T> T[] insertInListNoDup(T[] array, T element) { [EOL]     final int len = array.length; [EOL]     for (int ix = 0; ix < len; ++ix) { [EOL]         if (array[ix] == element) { [EOL]             if (ix == 0) { [EOL]                 return array; [EOL]             } [EOL]             T[] result = (T[]) Array.newInstance(array.getClass().getComponentType(), len); [EOL]             System.arraycopy(array, 0, result, 1, ix); [EOL]             result[0] = element; [EOL]             ++ix; [EOL]             int left = len - ix; [EOL]             if (left > 0) { [EOL]                 System.arraycopy(array, ix, result, ix, left); [EOL]             } [EOL]             return result; [EOL]         } [EOL]     } [EOL]     T[] result = (T[]) Array.newInstance(array.getClass().getComponentType(), len + 1); [EOL]     if (len > 0) { [EOL]         System.arraycopy(array, 0, result, 1, len); [EOL]     } [EOL]     result[0] = element; [EOL]     return result; [EOL] }
@SuppressWarnings("unchecked") [EOL] public static <T> T[] insertInListNoDup(T[] array, T element) { [EOL]     final int len = array.length; [EOL]     for (int ix = 0; ix < len; ++ix) { [EOL]         if (array[ix] == element) { [EOL]             if (ix == 0) { [EOL]                 return array; [EOL]             } [EOL]             T[] result = (T[]) Array.newInstance(array.getClass().getComponentType(), len); [EOL]             System.arraycopy(array, 0, result, 1, ix); [EOL]             result[0] = element; [EOL]             ++ix; [EOL]             int left = len - ix; [EOL]             if (left > 0) { [EOL]                 System.arraycopy(array, ix, result, ix, left); [EOL]             } [EOL]             return result; [EOL]         } [EOL]     } [EOL]     T[] result = (T[]) Array.newInstance(array.getClass().getComponentType(), len + 1); [EOL]     if (len > 0) { [EOL]         System.arraycopy(array, 0, result, 1, len); [EOL]     } [EOL]     result[0] = element; [EOL]     return result; [EOL] }
@SuppressWarnings("unchecked") [EOL] public static <T> T[] insertInListNoDup(T[] array, T element) { [EOL]     final int len = array.length; [EOL]     for (int ix = 0; ix < len; ++ix) { [EOL]         if (array[ix] == element) { [EOL]             if (ix == 0) { [EOL]                 return array; [EOL]             } [EOL]             T[] result = (T[]) Array.newInstance(array.getClass().getComponentType(), len); [EOL]             System.arraycopy(array, 0, result, 1, ix); [EOL]             result[0] = element; [EOL]             ++ix; [EOL]             int left = len - ix; [EOL]             if (left > 0) { [EOL]                 System.arraycopy(array, ix, result, ix, left); [EOL]             } [EOL]             return result; [EOL]         } [EOL]     } [EOL]     T[] result = (T[]) Array.newInstance(array.getClass().getComponentType(), len + 1); [EOL]     if (len > 0) { [EOL]         System.arraycopy(array, 0, result, 1, len); [EOL]     } [EOL]     result[0] = element; [EOL]     return result; [EOL] }
public boolean hasAbstractTypeResolvers() { [EOL]     return _abstractTypeResolvers.length > 0; [EOL] } public DeserializerFactoryConfig(); protected DeserializerFactoryConfig(Deserializers[] allAdditionalDeserializers, KeyDeserializers[] allAdditionalKeyDeserializers, BeanDeserializerModifier[] modifiers, AbstractTypeResolver[] atr, ValueInstantiators[] vi); public DeserializerFactoryConfig withAdditionalDeserializers(Deserializers additional); public DeserializerFactoryConfig withAdditionalKeyDeserializers(KeyDeserializers additional); public DeserializerFactoryConfig withDeserializerModifier(BeanDeserializerModifier modifier); public DeserializerFactoryConfig withAbstractTypeResolver(AbstractTypeResolver resolver); public DeserializerFactoryConfig withValueInstantiators(ValueInstantiators instantiators); public boolean hasDeserializers(); public boolean hasKeyDeserializers(); public boolean hasDeserializerModifiers(); public boolean hasAbstractTypeResolvers(); public boolean hasValueInstantiators(); public Iterable<Deserializers> deserializers(); public Iterable<KeyDeserializers> keyDeserializers(); public Iterable<BeanDeserializerModifier> deserializerModifiers(); public Iterable<AbstractTypeResolver> abstractTypeResolvers(); public Iterable<ValueInstantiators> valueInstantiators(); long serialVersionUID=Optional[3683541151102256824L]; Deserializers[] NO_DESERIALIZERS=Optional[new Deserializers[0]]; BeanDeserializerModifier[] NO_MODIFIERS=Optional[new BeanDeserializerModifier[0]]; AbstractTypeResolver[] NO_ABSTRACT_TYPE_RESOLVERS=Optional[new AbstractTypeResolver[0]]; ValueInstantiators[] NO_VALUE_INSTANTIATORS=Optional[new ValueInstantiators[0]]; KeyDeserializers[] DEFAULT_KEY_DESERIALIZERS=Optional[new KeyDeserializers[] { new StdKeyDeserializers() }
public boolean hasAbstractTypeResolvers() { [EOL]     return _abstractTypeResolvers.length > 0; [EOL] } public DeserializerFactoryConfig(); protected DeserializerFactoryConfig(Deserializers[] allAdditionalDeserializers, KeyDeserializers[] allAdditionalKeyDeserializers, BeanDeserializerModifier[] modifiers, AbstractTypeResolver[] atr, ValueInstantiators[] vi); public DeserializerFactoryConfig withAdditionalDeserializers(Deserializers additional); public DeserializerFactoryConfig withAdditionalKeyDeserializers(KeyDeserializers additional); public DeserializerFactoryConfig withDeserializerModifier(BeanDeserializerModifier modifier); public DeserializerFactoryConfig withAbstractTypeResolver(AbstractTypeResolver resolver); public DeserializerFactoryConfig withValueInstantiators(ValueInstantiators instantiators); public boolean hasDeserializers(); public boolean hasKeyDeserializers(); public boolean hasDeserializerModifiers(); public boolean hasAbstractTypeResolvers(); public boolean hasValueInstantiators(); public Iterable<Deserializers> deserializers(); public Iterable<KeyDeserializers> keyDeserializers(); public Iterable<BeanDeserializerModifier> deserializerModifiers(); public Iterable<AbstractTypeResolver> abstractTypeResolvers(); public Iterable<ValueInstantiators> valueInstantiators(); long serialVersionUID=Optional[3683541151102256824L]; Deserializers[] NO_DESERIALIZERS=Optional[new Deserializers[0]]; BeanDeserializerModifier[] NO_MODIFIERS=Optional[new BeanDeserializerModifier[0]]; AbstractTypeResolver[] NO_ABSTRACT_TYPE_RESOLVERS=Optional[new AbstractTypeResolver[0]]; ValueInstantiators[] NO_VALUE_INSTANTIATORS=Optional[new ValueInstantiators[0]]; KeyDeserializers[] DEFAULT_KEY_DESERIALIZERS=Optional[new KeyDeserializers[] { new StdKeyDeserializers() }
public boolean hasAbstractTypeResolvers() { [EOL]     return _abstractTypeResolvers.length > 0; [EOL] } public DeserializerFactoryConfig(); protected DeserializerFactoryConfig(Deserializers[] allAdditionalDeserializers, KeyDeserializers[] allAdditionalKeyDeserializers, BeanDeserializerModifier[] modifiers, AbstractTypeResolver[] atr, ValueInstantiators[] vi); public DeserializerFactoryConfig withAdditionalDeserializers(Deserializers additional); public DeserializerFactoryConfig withAdditionalKeyDeserializers(KeyDeserializers additional); public DeserializerFactoryConfig withDeserializerModifier(BeanDeserializerModifier modifier); public DeserializerFactoryConfig withAbstractTypeResolver(AbstractTypeResolver resolver); public DeserializerFactoryConfig withValueInstantiators(ValueInstantiators instantiators); public boolean hasDeserializers(); public boolean hasKeyDeserializers(); public boolean hasDeserializerModifiers(); public boolean hasAbstractTypeResolvers(); public boolean hasValueInstantiators(); public Iterable<Deserializers> deserializers(); public Iterable<KeyDeserializers> keyDeserializers(); public Iterable<BeanDeserializerModifier> deserializerModifiers(); public Iterable<AbstractTypeResolver> abstractTypeResolvers(); public Iterable<ValueInstantiators> valueInstantiators(); long serialVersionUID=Optional[3683541151102256824L]; Deserializers[] NO_DESERIALIZERS=Optional[new Deserializers[0]]; BeanDeserializerModifier[] NO_MODIFIERS=Optional[new BeanDeserializerModifier[0]]; AbstractTypeResolver[] NO_ABSTRACT_TYPE_RESOLVERS=Optional[new AbstractTypeResolver[0]]; ValueInstantiators[] NO_VALUE_INSTANTIATORS=Optional[new ValueInstantiators[0]]; KeyDeserializers[] DEFAULT_KEY_DESERIALIZERS=Optional[new KeyDeserializers[] { new StdKeyDeserializers() }
public boolean hasAbstractTypeResolvers() { [EOL]     return _abstractTypeResolvers.length > 0; [EOL] } public DeserializerFactoryConfig(); protected DeserializerFactoryConfig(Deserializers[] allAdditionalDeserializers, KeyDeserializers[] allAdditionalKeyDeserializers, BeanDeserializerModifier[] modifiers, AbstractTypeResolver[] atr, ValueInstantiators[] vi); public DeserializerFactoryConfig withAdditionalDeserializers(Deserializers additional); public DeserializerFactoryConfig withAdditionalKeyDeserializers(KeyDeserializers additional); public DeserializerFactoryConfig withDeserializerModifier(BeanDeserializerModifier modifier); public DeserializerFactoryConfig withAbstractTypeResolver(AbstractTypeResolver resolver); public DeserializerFactoryConfig withValueInstantiators(ValueInstantiators instantiators); public boolean hasDeserializers(); public boolean hasKeyDeserializers(); public boolean hasDeserializerModifiers(); public boolean hasAbstractTypeResolvers(); public boolean hasValueInstantiators(); public Iterable<Deserializers> deserializers(); public Iterable<KeyDeserializers> keyDeserializers(); public Iterable<BeanDeserializerModifier> deserializerModifiers(); public Iterable<AbstractTypeResolver> abstractTypeResolvers(); public Iterable<ValueInstantiators> valueInstantiators(); long serialVersionUID=Optional[3683541151102256824L]; Deserializers[] NO_DESERIALIZERS=Optional[new Deserializers[0]]; BeanDeserializerModifier[] NO_MODIFIERS=Optional[new BeanDeserializerModifier[0]]; AbstractTypeResolver[] NO_ABSTRACT_TYPE_RESOLVERS=Optional[new AbstractTypeResolver[0]]; ValueInstantiators[] NO_VALUE_INSTANTIATORS=Optional[new ValueInstantiators[0]]; KeyDeserializers[] DEFAULT_KEY_DESERIALIZERS=Optional[new KeyDeserializers[] { new StdKeyDeserializers() }
public boolean hasAbstractTypeResolvers() { [EOL]     return _abstractTypeResolvers.length > 0; [EOL] } public DeserializerFactoryConfig(); protected DeserializerFactoryConfig(Deserializers[] allAdditionalDeserializers, KeyDeserializers[] allAdditionalKeyDeserializers, BeanDeserializerModifier[] modifiers, AbstractTypeResolver[] atr, ValueInstantiators[] vi); public DeserializerFactoryConfig withAdditionalDeserializers(Deserializers additional); public DeserializerFactoryConfig withAdditionalKeyDeserializers(KeyDeserializers additional); public DeserializerFactoryConfig withDeserializerModifier(BeanDeserializerModifier modifier); public DeserializerFactoryConfig withAbstractTypeResolver(AbstractTypeResolver resolver); public DeserializerFactoryConfig withValueInstantiators(ValueInstantiators instantiators); public boolean hasDeserializers(); public boolean hasKeyDeserializers(); public boolean hasDeserializerModifiers(); public boolean hasAbstractTypeResolvers(); public boolean hasValueInstantiators(); public Iterable<Deserializers> deserializers(); public Iterable<KeyDeserializers> keyDeserializers(); public Iterable<BeanDeserializerModifier> deserializerModifiers(); public Iterable<AbstractTypeResolver> abstractTypeResolvers(); public Iterable<ValueInstantiators> valueInstantiators(); long serialVersionUID=Optional[3683541151102256824L]; Deserializers[] NO_DESERIALIZERS=Optional[new Deserializers[0]]; BeanDeserializerModifier[] NO_MODIFIERS=Optional[new BeanDeserializerModifier[0]]; AbstractTypeResolver[] NO_ABSTRACT_TYPE_RESOLVERS=Optional[new AbstractTypeResolver[0]]; ValueInstantiators[] NO_VALUE_INSTANTIATORS=Optional[new ValueInstantiators[0]]; KeyDeserializers[] DEFAULT_KEY_DESERIALIZERS=Optional[new KeyDeserializers[] { new StdKeyDeserializers() }
public Iterable<AbstractTypeResolver> abstractTypeResolvers() { [EOL]     return ArrayBuilders.arrayAsIterable(_abstractTypeResolvers); [EOL] } public DeserializerFactoryConfig(); protected DeserializerFactoryConfig(Deserializers[] allAdditionalDeserializers, KeyDeserializers[] allAdditionalKeyDeserializers, BeanDeserializerModifier[] modifiers, AbstractTypeResolver[] atr, ValueInstantiators[] vi); public DeserializerFactoryConfig withAdditionalDeserializers(Deserializers additional); public DeserializerFactoryConfig withAdditionalKeyDeserializers(KeyDeserializers additional); public DeserializerFactoryConfig withDeserializerModifier(BeanDeserializerModifier modifier); public DeserializerFactoryConfig withAbstractTypeResolver(AbstractTypeResolver resolver); public DeserializerFactoryConfig withValueInstantiators(ValueInstantiators instantiators); public boolean hasDeserializers(); public boolean hasKeyDeserializers(); public boolean hasDeserializerModifiers(); public boolean hasAbstractTypeResolvers(); public boolean hasValueInstantiators(); public Iterable<Deserializers> deserializers(); public Iterable<KeyDeserializers> keyDeserializers(); public Iterable<BeanDeserializerModifier> deserializerModifiers(); public Iterable<AbstractTypeResolver> abstractTypeResolvers(); public Iterable<ValueInstantiators> valueInstantiators(); long serialVersionUID=Optional[3683541151102256824L]; Deserializers[] NO_DESERIALIZERS=Optional[new Deserializers[0]]; BeanDeserializerModifier[] NO_MODIFIERS=Optional[new BeanDeserializerModifier[0]]; AbstractTypeResolver[] NO_ABSTRACT_TYPE_RESOLVERS=Optional[new AbstractTypeResolver[0]]; ValueInstantiators[] NO_VALUE_INSTANTIATORS=Optional[new ValueInstantiators[0]]; KeyDeserializers[] DEFAULT_KEY_DESERIALIZERS=Optional[new KeyDeserializers[] { new StdKeyDeserializers() }
public Iterable<AbstractTypeResolver> abstractTypeResolvers() { [EOL]     return ArrayBuilders.arrayAsIterable(_abstractTypeResolvers); [EOL] } public DeserializerFactoryConfig(); protected DeserializerFactoryConfig(Deserializers[] allAdditionalDeserializers, KeyDeserializers[] allAdditionalKeyDeserializers, BeanDeserializerModifier[] modifiers, AbstractTypeResolver[] atr, ValueInstantiators[] vi); public DeserializerFactoryConfig withAdditionalDeserializers(Deserializers additional); public DeserializerFactoryConfig withAdditionalKeyDeserializers(KeyDeserializers additional); public DeserializerFactoryConfig withDeserializerModifier(BeanDeserializerModifier modifier); public DeserializerFactoryConfig withAbstractTypeResolver(AbstractTypeResolver resolver); public DeserializerFactoryConfig withValueInstantiators(ValueInstantiators instantiators); public boolean hasDeserializers(); public boolean hasKeyDeserializers(); public boolean hasDeserializerModifiers(); public boolean hasAbstractTypeResolvers(); public boolean hasValueInstantiators(); public Iterable<Deserializers> deserializers(); public Iterable<KeyDeserializers> keyDeserializers(); public Iterable<BeanDeserializerModifier> deserializerModifiers(); public Iterable<AbstractTypeResolver> abstractTypeResolvers(); public Iterable<ValueInstantiators> valueInstantiators(); long serialVersionUID=Optional[3683541151102256824L]; Deserializers[] NO_DESERIALIZERS=Optional[new Deserializers[0]]; BeanDeserializerModifier[] NO_MODIFIERS=Optional[new BeanDeserializerModifier[0]]; AbstractTypeResolver[] NO_ABSTRACT_TYPE_RESOLVERS=Optional[new AbstractTypeResolver[0]]; ValueInstantiators[] NO_VALUE_INSTANTIATORS=Optional[new ValueInstantiators[0]]; KeyDeserializers[] DEFAULT_KEY_DESERIALIZERS=Optional[new KeyDeserializers[] { new StdKeyDeserializers() }
@Override [EOL] public void serializeAsField(Object bean, JsonGenerator jgen, SerializerProvider prov) throws Exception { [EOL]     Object value = get(bean); [EOL]     if (value == null) { [EOL]         return; [EOL]     } [EOL]     JsonSerializer<Object> ser = _serializer; [EOL]     if (ser == null) { [EOL]         Class<?> cls = value.getClass(); [EOL]         PropertySerializerMap map = _dynamicSerializers; [EOL]         ser = map.serializerFor(cls); [EOL]         if (ser == null) { [EOL]             ser = _findAndAddDynamic(map, cls, prov); [EOL]         } [EOL]     } [EOL]     if (_suppressableValue != null) { [EOL]         if (MARKER_FOR_EMPTY == _suppressableValue) { [EOL]             if (ser.isEmpty(value)) { [EOL]                 return; [EOL]             } [EOL]         } else if (_suppressableValue.equals(value)) { [EOL]             return; [EOL]         } [EOL]     } [EOL]     if (value == bean) { [EOL]         _handleSelfReference(bean, ser); [EOL]     } [EOL]     if (!ser.isUnwrappingSerializer()) { [EOL]         jgen.writeFieldName(_name); [EOL]     } [EOL]     if (_typeSerializer == null) { [EOL]         ser.serialize(value, jgen, prov); [EOL]     } else { [EOL]         ser.serializeWithType(value, jgen, prov, _typeSerializer); [EOL]     } [EOL] }
@Override [EOL] public void serializeAsField(Object bean, JsonGenerator jgen, SerializerProvider prov) throws Exception { [EOL]     Object value = get(bean); [EOL]     if (value == null) { [EOL]         return; [EOL]     } [EOL]     JsonSerializer<Object> ser = _serializer; [EOL]     if (ser == null) { [EOL]         Class<?> cls = value.getClass(); [EOL]         PropertySerializerMap map = _dynamicSerializers; [EOL]         ser = map.serializerFor(cls); [EOL]         if (ser == null) { [EOL]             ser = _findAndAddDynamic(map, cls, prov); [EOL]         } [EOL]     } [EOL]     if (_suppressableValue != null) { [EOL]         if (MARKER_FOR_EMPTY == _suppressableValue) { [EOL]             if (ser.isEmpty(value)) { [EOL]                 return; [EOL]             } [EOL]         } else if (_suppressableValue.equals(value)) { [EOL]             return; [EOL]         } [EOL]     } [EOL]     if (value == bean) { [EOL]         _handleSelfReference(bean, ser); [EOL]     } [EOL]     if (!ser.isUnwrappingSerializer()) { [EOL]         jgen.writeFieldName(_name); [EOL]     } [EOL]     if (_typeSerializer == null) { [EOL]         ser.serialize(value, jgen, prov); [EOL]     } else { [EOL]         ser.serializeWithType(value, jgen, prov, _typeSerializer); [EOL]     } [EOL] }
@Override [EOL] public void serializeAsField(Object bean, JsonGenerator jgen, SerializerProvider prov) throws Exception { [EOL]     Object value = get(bean); [EOL]     if (value == null) { [EOL]         return; [EOL]     } [EOL]     JsonSerializer<Object> ser = _serializer; [EOL]     if (ser == null) { [EOL]         Class<?> cls = value.getClass(); [EOL]         PropertySerializerMap map = _dynamicSerializers; [EOL]         ser = map.serializerFor(cls); [EOL]         if (ser == null) { [EOL]             ser = _findAndAddDynamic(map, cls, prov); [EOL]         } [EOL]     } [EOL]     if (_suppressableValue != null) { [EOL]         if (MARKER_FOR_EMPTY == _suppressableValue) { [EOL]             if (ser.isEmpty(value)) { [EOL]                 return; [EOL]             } [EOL]         } else if (_suppressableValue.equals(value)) { [EOL]             return; [EOL]         } [EOL]     } [EOL]     if (value == bean) { [EOL]         _handleSelfReference(bean, ser); [EOL]     } [EOL]     if (!ser.isUnwrappingSerializer()) { [EOL]         jgen.writeFieldName(_name); [EOL]     } [EOL]     if (_typeSerializer == null) { [EOL]         ser.serialize(value, jgen, prov); [EOL]     } else { [EOL]         ser.serializeWithType(value, jgen, prov, _typeSerializer); [EOL]     } [EOL] }
@Override [EOL] public void serializeAsField(Object bean, JsonGenerator jgen, SerializerProvider prov) throws Exception { [EOL]     Object value = get(bean); [EOL]     if (value == null) { [EOL]         return; [EOL]     } [EOL]     JsonSerializer<Object> ser = _serializer; [EOL]     if (ser == null) { [EOL]         Class<?> cls = value.getClass(); [EOL]         PropertySerializerMap map = _dynamicSerializers; [EOL]         ser = map.serializerFor(cls); [EOL]         if (ser == null) { [EOL]             ser = _findAndAddDynamic(map, cls, prov); [EOL]         } [EOL]     } [EOL]     if (_suppressableValue != null) { [EOL]         if (MARKER_FOR_EMPTY == _suppressableValue) { [EOL]             if (ser.isEmpty(value)) { [EOL]                 return; [EOL]             } [EOL]         } else if (_suppressableValue.equals(value)) { [EOL]             return; [EOL]         } [EOL]     } [EOL]     if (value == bean) { [EOL]         _handleSelfReference(bean, ser); [EOL]     } [EOL]     if (!ser.isUnwrappingSerializer()) { [EOL]         jgen.writeFieldName(_name); [EOL]     } [EOL]     if (_typeSerializer == null) { [EOL]         ser.serialize(value, jgen, prov); [EOL]     } else { [EOL]         ser.serializeWithType(value, jgen, prov, _typeSerializer); [EOL]     } [EOL] }
@Override [EOL] public void serializeAsField(Object bean, JsonGenerator jgen, SerializerProvider prov) throws Exception { [EOL]     Object value = get(bean); [EOL]     if (value == null) { [EOL]         return; [EOL]     } [EOL]     JsonSerializer<Object> ser = _serializer; [EOL]     if (ser == null) { [EOL]         Class<?> cls = value.getClass(); [EOL]         PropertySerializerMap map = _dynamicSerializers; [EOL]         ser = map.serializerFor(cls); [EOL]         if (ser == null) { [EOL]             ser = _findAndAddDynamic(map, cls, prov); [EOL]         } [EOL]     } [EOL]     if (_suppressableValue != null) { [EOL]         if (MARKER_FOR_EMPTY == _suppressableValue) { [EOL]             if (ser.isEmpty(value)) { [EOL]                 return; [EOL]             } [EOL]         } else if (_suppressableValue.equals(value)) { [EOL]             return; [EOL]         } [EOL]     } [EOL]     if (value == bean) { [EOL]         _handleSelfReference(bean, ser); [EOL]     } [EOL]     if (!ser.isUnwrappingSerializer()) { [EOL]         jgen.writeFieldName(_name); [EOL]     } [EOL]     if (_typeSerializer == null) { [EOL]         ser.serialize(value, jgen, prov); [EOL]     } else { [EOL]         ser.serializeWithType(value, jgen, prov, _typeSerializer); [EOL]     } [EOL] }
@Override [EOL] protected JsonSerializer<Object> _findAndAddDynamic(PropertySerializerMap map, Class<?> type, SerializerProvider provider) throws JsonMappingException { [EOL]     JsonSerializer<Object> serializer; [EOL]     if (_nonTrivialBaseType != null) { [EOL]         JavaType subtype = provider.constructSpecializedType(_nonTrivialBaseType, type); [EOL]         serializer = provider.findValueSerializer(subtype, this); [EOL]     } else { [EOL]         serializer = provider.findValueSerializer(type, this); [EOL]     } [EOL]     NameTransformer t = _nameTransformer; [EOL]     if (serializer.isUnwrappingSerializer()) { [EOL]         t = NameTransformer.chainedTransformer(t, ((UnwrappingBeanSerializer) serializer)._nameTransformer); [EOL]     } [EOL]     serializer = serializer.unwrappingSerializer(t); [EOL]     _dynamicSerializers = _dynamicSerializers.newWith(type, serializer); [EOL]     return serializer; [EOL] }
protected BeanSerializerBase(JavaType type, BeanSerializerBuilder builder, BeanPropertyWriter[] properties, BeanPropertyWriter[] filteredProperties) { [EOL]     super(type); [EOL]     _props = properties; [EOL]     _filteredProps = filteredProperties; [EOL]     if (builder == null) { [EOL]         _typeId = null; [EOL]         _anyGetterWriter = null; [EOL]         _propertyFilterId = null; [EOL]         _objectIdWriter = null; [EOL]         _serializationShape = null; [EOL]     } else { [EOL]         _typeId = builder.getTypeId(); [EOL]         _anyGetterWriter = builder.getAnyGetter(); [EOL]         _propertyFilterId = builder.getFilterId(); [EOL]         _objectIdWriter = builder.getObjectIdWriter(); [EOL]         JsonFormat.Value format = builder.getBeanDescription().findExpectedFormat(null); [EOL]         _serializationShape = (format == null) ? null : format.getShape(); [EOL]     } [EOL] }
protected BeanSerializerBase(JavaType type, BeanSerializerBuilder builder, BeanPropertyWriter[] properties, BeanPropertyWriter[] filteredProperties) { [EOL]     super(type); [EOL]     _props = properties; [EOL]     _filteredProps = filteredProperties; [EOL]     if (builder == null) { [EOL]         _typeId = null; [EOL]         _anyGetterWriter = null; [EOL]         _propertyFilterId = null; [EOL]         _objectIdWriter = null; [EOL]         _serializationShape = null; [EOL]     } else { [EOL]         _typeId = builder.getTypeId(); [EOL]         _anyGetterWriter = builder.getAnyGetter(); [EOL]         _propertyFilterId = builder.getFilterId(); [EOL]         _objectIdWriter = builder.getObjectIdWriter(); [EOL]         JsonFormat.Value format = builder.getBeanDescription().findExpectedFormat(null); [EOL]         _serializationShape = (format == null) ? null : format.getShape(); [EOL]     } [EOL] }
public BeanSerializerBase(BeanSerializerBase src, BeanPropertyWriter[] properties, BeanPropertyWriter[] filteredProperties) { [EOL]     super(src._handledType); [EOL]     _props = properties; [EOL]     _filteredProps = filteredProperties; [EOL]     _typeId = src._typeId; [EOL]     _anyGetterWriter = src._anyGetterWriter; [EOL]     _objectIdWriter = src._objectIdWriter; [EOL]     _propertyFilterId = src._propertyFilterId; [EOL]     _serializationShape = src._serializationShape; [EOL] }
protected BeanSerializerBase(BeanSerializerBase src, NameTransformer unwrapper) { [EOL]     this(src, rename(src._props, unwrapper), rename(src._filteredProps, unwrapper)); [EOL] }
private final static BeanPropertyWriter[] rename(BeanPropertyWriter[] props, NameTransformer transformer) { [EOL]     if (props == null || props.length == 0 || transformer == null || transformer == NameTransformer.NOP) { [EOL]         return props; [EOL]     } [EOL]     final int len = props.length; [EOL]     BeanPropertyWriter[] result = new BeanPropertyWriter[len]; [EOL]     for (int i = 0; i < len; ++i) { [EOL]         BeanPropertyWriter bpw = props[i]; [EOL]         if (bpw != null) { [EOL]             result[i] = bpw.rename(transformer); [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
private final static BeanPropertyWriter[] rename(BeanPropertyWriter[] props, NameTransformer transformer) { [EOL]     if (props == null || props.length == 0 || transformer == null || transformer == NameTransformer.NOP) { [EOL]         return props; [EOL]     } [EOL]     final int len = props.length; [EOL]     BeanPropertyWriter[] result = new BeanPropertyWriter[len]; [EOL]     for (int i = 0; i < len; ++i) { [EOL]         BeanPropertyWriter bpw = props[i]; [EOL]         if (bpw != null) { [EOL]             result[i] = bpw.rename(transformer); [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
private final static BeanPropertyWriter[] rename(BeanPropertyWriter[] props, NameTransformer transformer) { [EOL]     if (props == null || props.length == 0 || transformer == null || transformer == NameTransformer.NOP) { [EOL]         return props; [EOL]     } [EOL]     final int len = props.length; [EOL]     BeanPropertyWriter[] result = new BeanPropertyWriter[len]; [EOL]     for (int i = 0; i < len; ++i) { [EOL]         BeanPropertyWriter bpw = props[i]; [EOL]         if (bpw != null) { [EOL]             result[i] = bpw.rename(transformer); [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
private final static BeanPropertyWriter[] rename(BeanPropertyWriter[] props, NameTransformer transformer) { [EOL]     if (props == null || props.length == 0 || transformer == null || transformer == NameTransformer.NOP) { [EOL]         return props; [EOL]     } [EOL]     final int len = props.length; [EOL]     BeanPropertyWriter[] result = new BeanPropertyWriter[len]; [EOL]     for (int i = 0; i < len; ++i) { [EOL]         BeanPropertyWriter bpw = props[i]; [EOL]         if (bpw != null) { [EOL]             result[i] = bpw.rename(transformer); [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
private final static BeanPropertyWriter[] rename(BeanPropertyWriter[] props, NameTransformer transformer) { [EOL]     if (props == null || props.length == 0 || transformer == null || transformer == NameTransformer.NOP) { [EOL]         return props; [EOL]     } [EOL]     final int len = props.length; [EOL]     BeanPropertyWriter[] result = new BeanPropertyWriter[len]; [EOL]     for (int i = 0; i < len; ++i) { [EOL]         BeanPropertyWriter bpw = props[i]; [EOL]         if (bpw != null) { [EOL]             result[i] = bpw.rename(transformer); [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
@Override [EOL] public void serializeWithType(Object bean, JsonGenerator jgen, SerializerProvider provider, TypeSerializer typeSer) throws IOException, JsonGenerationException { [EOL]     if (_objectIdWriter != null) { [EOL]         _serializeWithObjectId(bean, jgen, provider, typeSer); [EOL]         return; [EOL]     } [EOL]     String typeStr = (_typeId == null) ? null : _customTypeId(bean); [EOL]     if (typeStr == null) { [EOL]         typeSer.writeTypePrefixForObject(bean, jgen); [EOL]     } else { [EOL]         typeSer.writeCustomTypePrefixForObject(bean, jgen, typeStr); [EOL]     } [EOL]     if (_propertyFilterId != null) { [EOL]         serializeFieldsFiltered(bean, jgen, provider); [EOL]     } else { [EOL]         serializeFields(bean, jgen, provider); [EOL]     } [EOL]     if (typeStr == null) { [EOL]         typeSer.writeTypeSuffixForObject(bean, jgen); [EOL]     } else { [EOL]         typeSer.writeCustomTypeSuffixForObject(bean, jgen, typeStr); [EOL]     } [EOL] }
@Override [EOL] public void serializeWithType(Object bean, JsonGenerator jgen, SerializerProvider provider, TypeSerializer typeSer) throws IOException, JsonGenerationException { [EOL]     if (_objectIdWriter != null) { [EOL]         _serializeWithObjectId(bean, jgen, provider, typeSer); [EOL]         return; [EOL]     } [EOL]     String typeStr = (_typeId == null) ? null : _customTypeId(bean); [EOL]     if (typeStr == null) { [EOL]         typeSer.writeTypePrefixForObject(bean, jgen); [EOL]     } else { [EOL]         typeSer.writeCustomTypePrefixForObject(bean, jgen, typeStr); [EOL]     } [EOL]     if (_propertyFilterId != null) { [EOL]         serializeFieldsFiltered(bean, jgen, provider); [EOL]     } else { [EOL]         serializeFields(bean, jgen, provider); [EOL]     } [EOL]     if (typeStr == null) { [EOL]         typeSer.writeTypeSuffixForObject(bean, jgen); [EOL]     } else { [EOL]         typeSer.writeCustomTypeSuffixForObject(bean, jgen, typeStr); [EOL]     } [EOL] }
@Override [EOL] public void serializeWithType(Object bean, JsonGenerator jgen, SerializerProvider provider, TypeSerializer typeSer) throws IOException, JsonGenerationException { [EOL]     if (_objectIdWriter != null) { [EOL]         _serializeWithObjectId(bean, jgen, provider, typeSer); [EOL]         return; [EOL]     } [EOL]     String typeStr = (_typeId == null) ? null : _customTypeId(bean); [EOL]     if (typeStr == null) { [EOL]         typeSer.writeTypePrefixForObject(bean, jgen); [EOL]     } else { [EOL]         typeSer.writeCustomTypePrefixForObject(bean, jgen, typeStr); [EOL]     } [EOL]     if (_propertyFilterId != null) { [EOL]         serializeFieldsFiltered(bean, jgen, provider); [EOL]     } else { [EOL]         serializeFields(bean, jgen, provider); [EOL]     } [EOL]     if (typeStr == null) { [EOL]         typeSer.writeTypeSuffixForObject(bean, jgen); [EOL]     } else { [EOL]         typeSer.writeCustomTypeSuffixForObject(bean, jgen, typeStr); [EOL]     } [EOL] }
@Override [EOL] public void serializeWithType(Object bean, JsonGenerator jgen, SerializerProvider provider, TypeSerializer typeSer) throws IOException, JsonGenerationException { [EOL]     if (_objectIdWriter != null) { [EOL]         _serializeWithObjectId(bean, jgen, provider, typeSer); [EOL]         return; [EOL]     } [EOL]     String typeStr = (_typeId == null) ? null : _customTypeId(bean); [EOL]     if (typeStr == null) { [EOL]         typeSer.writeTypePrefixForObject(bean, jgen); [EOL]     } else { [EOL]         typeSer.writeCustomTypePrefixForObject(bean, jgen, typeStr); [EOL]     } [EOL]     if (_propertyFilterId != null) { [EOL]         serializeFieldsFiltered(bean, jgen, provider); [EOL]     } else { [EOL]         serializeFields(bean, jgen, provider); [EOL]     } [EOL]     if (typeStr == null) { [EOL]         typeSer.writeTypeSuffixForObject(bean, jgen); [EOL]     } else { [EOL]         typeSer.writeCustomTypeSuffixForObject(bean, jgen, typeStr); [EOL]     } [EOL] }
private final String _customTypeId(Object bean) { [EOL]     final Object typeId = _typeId.getValue(bean); [EOL]     if (typeId == null) { [EOL]         return ""; [EOL]     } [EOL]     return (typeId instanceof String) ? (String) typeId : typeId.toString(); [EOL] }
private final String _customTypeId(Object bean) { [EOL]     final Object typeId = _typeId.getValue(bean); [EOL]     if (typeId == null) { [EOL]         return ""; [EOL]     } [EOL]     return (typeId instanceof String) ? (String) typeId : typeId.toString(); [EOL] }
private final String _customTypeId(Object bean) { [EOL]     final Object typeId = _typeId.getValue(bean); [EOL]     if (typeId == null) { [EOL]         return ""; [EOL]     } [EOL]     return (typeId instanceof String) ? (String) typeId : typeId.toString(); [EOL] }
@Override [EOL] public JsonNode getSchema(SerializerProvider provider, Type typeHint) throws JsonMappingException { [EOL]     ObjectNode o = createSchemaNode("object", true); [EOL]     JsonSerializableSchema ann = _handledType.getAnnotation(JsonSerializableSchema.class); [EOL]     if (ann != null) { [EOL]         String id = ann.id(); [EOL]         if (id != null && id.length() > 0) { [EOL]             o.put("id", id); [EOL]         } [EOL]     } [EOL]     ObjectNode propertiesNode = o.objectNode(); [EOL]     final BeanPropertyFilter filter; [EOL]     if (_propertyFilterId != null) { [EOL]         filter = findFilter(provider); [EOL]     } else { [EOL]         filter = null; [EOL]     } [EOL]     for (int i = 0; i < _props.length; i++) { [EOL]         BeanPropertyWriter prop = _props[i]; [EOL]         if (filter == null) { [EOL]             prop.depositSchemaProperty(propertiesNode, provider); [EOL]         } else { [EOL]             filter.depositSchemaProperty(prop, propertiesNode, provider); [EOL]         } [EOL]     } [EOL]     o.put("properties", propertiesNode); [EOL]     return o; [EOL] }
@Override [EOL] public JsonNode getSchema(SerializerProvider provider, Type typeHint) throws JsonMappingException { [EOL]     ObjectNode o = createSchemaNode("object", true); [EOL]     JsonSerializableSchema ann = _handledType.getAnnotation(JsonSerializableSchema.class); [EOL]     if (ann != null) { [EOL]         String id = ann.id(); [EOL]         if (id != null && id.length() > 0) { [EOL]             o.put("id", id); [EOL]         } [EOL]     } [EOL]     ObjectNode propertiesNode = o.objectNode(); [EOL]     final BeanPropertyFilter filter; [EOL]     if (_propertyFilterId != null) { [EOL]         filter = findFilter(provider); [EOL]     } else { [EOL]         filter = null; [EOL]     } [EOL]     for (int i = 0; i < _props.length; i++) { [EOL]         BeanPropertyWriter prop = _props[i]; [EOL]         if (filter == null) { [EOL]             prop.depositSchemaProperty(propertiesNode, provider); [EOL]         } else { [EOL]             filter.depositSchemaProperty(prop, propertiesNode, provider); [EOL]         } [EOL]     } [EOL]     o.put("properties", propertiesNode); [EOL]     return o; [EOL] }
public BeanSerializerBuilder updateBuilder(SerializationConfig config, BeanDescription beanDesc, BeanSerializerBuilder builder) { [EOL]     return builder; [EOL] }
public JsonSerializer<?> modifySerializer(SerializationConfig config, BeanDescription beanDesc, JsonSerializer<?> serializer) { [EOL]     return serializer; [EOL] }
protected void _sortProperties() { [EOL]     AnnotationIntrospector intr = _annotationIntrospector; [EOL]     boolean sort; [EOL]     Boolean alpha = (intr == null) ? null : intr.findSerializationSortAlphabetically(_classDef); [EOL]     if (alpha == null) { [EOL]         sort = _config.shouldSortPropertiesAlphabetically(); [EOL]     } else { [EOL]         sort = alpha.booleanValue(); [EOL]     } [EOL]     String[] propertyOrder = (intr == null) ? null : intr.findSerializationPropertyOrder(_classDef); [EOL]     if (!sort && (_creatorProperties == null) && (propertyOrder == null)) { [EOL]         return; [EOL]     } [EOL]     int size = _properties.size(); [EOL]     Map<String, POJOPropertyBuilder> all; [EOL]     if (sort) { [EOL]         all = new TreeMap<String, POJOPropertyBuilder>(); [EOL]     } else { [EOL]         all = new LinkedHashMap<String, POJOPropertyBuilder>(size + size); [EOL]     } [EOL]     for (POJOPropertyBuilder prop : _properties.values()) { [EOL]         all.put(prop.getName(), prop); [EOL]     } [EOL]     Map<String, POJOPropertyBuilder> ordered = new LinkedHashMap<String, POJOPropertyBuilder>(size + size); [EOL]     if (propertyOrder != null) { [EOL]         for (String name : propertyOrder) { [EOL]             POJOPropertyBuilder w = all.get(name); [EOL]             if (w == null) { [EOL]                 for (POJOPropertyBuilder prop : _properties.values()) { [EOL]                     if (name.equals(prop.getInternalName())) { [EOL]                         w = prop; [EOL]                         name = prop.getName(); [EOL]                         break; [EOL]                     } [EOL]                 } [EOL]             } [EOL]             if (w != null) { [EOL]                 ordered.put(name, w); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (_creatorProperties != null) { [EOL]         for (POJOPropertyBuilder prop : _creatorProperties) { [EOL]             ordered.put(prop.getName(), prop); [EOL]         } [EOL]     } [EOL]     ordered.putAll(all); [EOL]     _properties.clear(); [EOL]     _properties.putAll(ordered); [EOL] }
protected void _sortProperties() { [EOL]     AnnotationIntrospector intr = _annotationIntrospector; [EOL]     boolean sort; [EOL]     Boolean alpha = (intr == null) ? null : intr.findSerializationSortAlphabetically(_classDef); [EOL]     if (alpha == null) { [EOL]         sort = _config.shouldSortPropertiesAlphabetically(); [EOL]     } else { [EOL]         sort = alpha.booleanValue(); [EOL]     } [EOL]     String[] propertyOrder = (intr == null) ? null : intr.findSerializationPropertyOrder(_classDef); [EOL]     if (!sort && (_creatorProperties == null) && (propertyOrder == null)) { [EOL]         return; [EOL]     } [EOL]     int size = _properties.size(); [EOL]     Map<String, POJOPropertyBuilder> all; [EOL]     if (sort) { [EOL]         all = new TreeMap<String, POJOPropertyBuilder>(); [EOL]     } else { [EOL]         all = new LinkedHashMap<String, POJOPropertyBuilder>(size + size); [EOL]     } [EOL]     for (POJOPropertyBuilder prop : _properties.values()) { [EOL]         all.put(prop.getName(), prop); [EOL]     } [EOL]     Map<String, POJOPropertyBuilder> ordered = new LinkedHashMap<String, POJOPropertyBuilder>(size + size); [EOL]     if (propertyOrder != null) { [EOL]         for (String name : propertyOrder) { [EOL]             POJOPropertyBuilder w = all.get(name); [EOL]             if (w == null) { [EOL]                 for (POJOPropertyBuilder prop : _properties.values()) { [EOL]                     if (name.equals(prop.getInternalName())) { [EOL]                         w = prop; [EOL]                         name = prop.getName(); [EOL]                         break; [EOL]                     } [EOL]                 } [EOL]             } [EOL]             if (w != null) { [EOL]                 ordered.put(name, w); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (_creatorProperties != null) { [EOL]         for (POJOPropertyBuilder prop : _creatorProperties) { [EOL]             ordered.put(prop.getName(), prop); [EOL]         } [EOL]     } [EOL]     ordered.putAll(all); [EOL]     _properties.clear(); [EOL]     _properties.putAll(ordered); [EOL] }
protected void _sortProperties() { [EOL]     AnnotationIntrospector intr = _annotationIntrospector; [EOL]     boolean sort; [EOL]     Boolean alpha = (intr == null) ? null : intr.findSerializationSortAlphabetically(_classDef); [EOL]     if (alpha == null) { [EOL]         sort = _config.shouldSortPropertiesAlphabetically(); [EOL]     } else { [EOL]         sort = alpha.booleanValue(); [EOL]     } [EOL]     String[] propertyOrder = (intr == null) ? null : intr.findSerializationPropertyOrder(_classDef); [EOL]     if (!sort && (_creatorProperties == null) && (propertyOrder == null)) { [EOL]         return; [EOL]     } [EOL]     int size = _properties.size(); [EOL]     Map<String, POJOPropertyBuilder> all; [EOL]     if (sort) { [EOL]         all = new TreeMap<String, POJOPropertyBuilder>(); [EOL]     } else { [EOL]         all = new LinkedHashMap<String, POJOPropertyBuilder>(size + size); [EOL]     } [EOL]     for (POJOPropertyBuilder prop : _properties.values()) { [EOL]         all.put(prop.getName(), prop); [EOL]     } [EOL]     Map<String, POJOPropertyBuilder> ordered = new LinkedHashMap<String, POJOPropertyBuilder>(size + size); [EOL]     if (propertyOrder != null) { [EOL]         for (String name : propertyOrder) { [EOL]             POJOPropertyBuilder w = all.get(name); [EOL]             if (w == null) { [EOL]                 for (POJOPropertyBuilder prop : _properties.values()) { [EOL]                     if (name.equals(prop.getInternalName())) { [EOL]                         w = prop; [EOL]                         name = prop.getName(); [EOL]                         break; [EOL]                     } [EOL]                 } [EOL]             } [EOL]             if (w != null) { [EOL]                 ordered.put(name, w); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (_creatorProperties != null) { [EOL]         for (POJOPropertyBuilder prop : _creatorProperties) { [EOL]             ordered.put(prop.getName(), prop); [EOL]         } [EOL]     } [EOL]     ordered.putAll(all); [EOL]     _properties.clear(); [EOL]     _properties.putAll(ordered); [EOL] }
protected void _sortProperties() { [EOL]     AnnotationIntrospector intr = _annotationIntrospector; [EOL]     boolean sort; [EOL]     Boolean alpha = (intr == null) ? null : intr.findSerializationSortAlphabetically(_classDef); [EOL]     if (alpha == null) { [EOL]         sort = _config.shouldSortPropertiesAlphabetically(); [EOL]     } else { [EOL]         sort = alpha.booleanValue(); [EOL]     } [EOL]     String[] propertyOrder = (intr == null) ? null : intr.findSerializationPropertyOrder(_classDef); [EOL]     if (!sort && (_creatorProperties == null) && (propertyOrder == null)) { [EOL]         return; [EOL]     } [EOL]     int size = _properties.size(); [EOL]     Map<String, POJOPropertyBuilder> all; [EOL]     if (sort) { [EOL]         all = new TreeMap<String, POJOPropertyBuilder>(); [EOL]     } else { [EOL]         all = new LinkedHashMap<String, POJOPropertyBuilder>(size + size); [EOL]     } [EOL]     for (POJOPropertyBuilder prop : _properties.values()) { [EOL]         all.put(prop.getName(), prop); [EOL]     } [EOL]     Map<String, POJOPropertyBuilder> ordered = new LinkedHashMap<String, POJOPropertyBuilder>(size + size); [EOL]     if (propertyOrder != null) { [EOL]         for (String name : propertyOrder) { [EOL]             POJOPropertyBuilder w = all.get(name); [EOL]             if (w == null) { [EOL]                 for (POJOPropertyBuilder prop : _properties.values()) { [EOL]                     if (name.equals(prop.getInternalName())) { [EOL]                         w = prop; [EOL]                         name = prop.getName(); [EOL]                         break; [EOL]                     } [EOL]                 } [EOL]             } [EOL]             if (w != null) { [EOL]                 ordered.put(name, w); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (_creatorProperties != null) { [EOL]         for (POJOPropertyBuilder prop : _creatorProperties) { [EOL]             ordered.put(prop.getName(), prop); [EOL]         } [EOL]     } [EOL]     ordered.putAll(all); [EOL]     _properties.clear(); [EOL]     _properties.putAll(ordered); [EOL] }
protected void _sortProperties() { [EOL]     AnnotationIntrospector intr = _annotationIntrospector; [EOL]     boolean sort; [EOL]     Boolean alpha = (intr == null) ? null : intr.findSerializationSortAlphabetically(_classDef); [EOL]     if (alpha == null) { [EOL]         sort = _config.shouldSortPropertiesAlphabetically(); [EOL]     } else { [EOL]         sort = alpha.booleanValue(); [EOL]     } [EOL]     String[] propertyOrder = (intr == null) ? null : intr.findSerializationPropertyOrder(_classDef); [EOL]     if (!sort && (_creatorProperties == null) && (propertyOrder == null)) { [EOL]         return; [EOL]     } [EOL]     int size = _properties.size(); [EOL]     Map<String, POJOPropertyBuilder> all; [EOL]     if (sort) { [EOL]         all = new TreeMap<String, POJOPropertyBuilder>(); [EOL]     } else { [EOL]         all = new LinkedHashMap<String, POJOPropertyBuilder>(size + size); [EOL]     } [EOL]     for (POJOPropertyBuilder prop : _properties.values()) { [EOL]         all.put(prop.getName(), prop); [EOL]     } [EOL]     Map<String, POJOPropertyBuilder> ordered = new LinkedHashMap<String, POJOPropertyBuilder>(size + size); [EOL]     if (propertyOrder != null) { [EOL]         for (String name : propertyOrder) { [EOL]             POJOPropertyBuilder w = all.get(name); [EOL]             if (w == null) { [EOL]                 for (POJOPropertyBuilder prop : _properties.values()) { [EOL]                     if (name.equals(prop.getInternalName())) { [EOL]                         w = prop; [EOL]                         name = prop.getName(); [EOL]                         break; [EOL]                     } [EOL]                 } [EOL]             } [EOL]             if (w != null) { [EOL]                 ordered.put(name, w); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (_creatorProperties != null) { [EOL]         for (POJOPropertyBuilder prop : _creatorProperties) { [EOL]             ordered.put(prop.getName(), prop); [EOL]         } [EOL]     } [EOL]     ordered.putAll(all); [EOL]     _properties.clear(); [EOL]     _properties.putAll(ordered); [EOL] }
protected void _addFields() { [EOL]     final AnnotationIntrospector ai = _annotationIntrospector; [EOL]     final boolean pruneFinalFields = !_forSerialization && !_config.isEnabled(MapperFeature.ALLOW_FINAL_FIELDS_AS_MUTATORS); [EOL]     for (AnnotatedField f : _classDef.fields()) { [EOL]         String implName = f.getName(); [EOL]         String explName; [EOL]         if (ai == null) { [EOL]             explName = null; [EOL]         } else if (_forSerialization) { [EOL]             PropertyName pn = ai.findNameForSerialization(f); [EOL]             explName = (pn == null) ? null : pn.getSimpleName(); [EOL]         } else { [EOL]             PropertyName pn = ai.findNameForDeserialization(f); [EOL]             explName = (pn == null) ? null : pn.getSimpleName(); [EOL]         } [EOL]         if ("".equals(explName)) { [EOL]             explName = implName; [EOL]         } [EOL]         boolean visible = (explName != null); [EOL]         if (!visible) { [EOL]             visible = _visibilityChecker.isFieldVisible(f); [EOL]         } [EOL]         boolean ignored = (ai != null) && ai.hasIgnoreMarker(f); [EOL]         if (pruneFinalFields && (explName == null) && !ignored && Modifier.isFinal(f.getModifiers())) { [EOL]             continue; [EOL]         } [EOL]         _property(implName).addField(f, explName, visible, ignored); [EOL]     } [EOL] }
protected void _addFields() { [EOL]     final AnnotationIntrospector ai = _annotationIntrospector; [EOL]     final boolean pruneFinalFields = !_forSerialization && !_config.isEnabled(MapperFeature.ALLOW_FINAL_FIELDS_AS_MUTATORS); [EOL]     for (AnnotatedField f : _classDef.fields()) { [EOL]         String implName = f.getName(); [EOL]         String explName; [EOL]         if (ai == null) { [EOL]             explName = null; [EOL]         } else if (_forSerialization) { [EOL]             PropertyName pn = ai.findNameForSerialization(f); [EOL]             explName = (pn == null) ? null : pn.getSimpleName(); [EOL]         } else { [EOL]             PropertyName pn = ai.findNameForDeserialization(f); [EOL]             explName = (pn == null) ? null : pn.getSimpleName(); [EOL]         } [EOL]         if ("".equals(explName)) { [EOL]             explName = implName; [EOL]         } [EOL]         boolean visible = (explName != null); [EOL]         if (!visible) { [EOL]             visible = _visibilityChecker.isFieldVisible(f); [EOL]         } [EOL]         boolean ignored = (ai != null) && ai.hasIgnoreMarker(f); [EOL]         if (pruneFinalFields && (explName == null) && !ignored && Modifier.isFinal(f.getModifiers())) { [EOL]             continue; [EOL]         } [EOL]         _property(implName).addField(f, explName, visible, ignored); [EOL]     } [EOL] }
protected void _addFields() { [EOL]     final AnnotationIntrospector ai = _annotationIntrospector; [EOL]     final boolean pruneFinalFields = !_forSerialization && !_config.isEnabled(MapperFeature.ALLOW_FINAL_FIELDS_AS_MUTATORS); [EOL]     for (AnnotatedField f : _classDef.fields()) { [EOL]         String implName = f.getName(); [EOL]         String explName; [EOL]         if (ai == null) { [EOL]             explName = null; [EOL]         } else if (_forSerialization) { [EOL]             PropertyName pn = ai.findNameForSerialization(f); [EOL]             explName = (pn == null) ? null : pn.getSimpleName(); [EOL]         } else { [EOL]             PropertyName pn = ai.findNameForDeserialization(f); [EOL]             explName = (pn == null) ? null : pn.getSimpleName(); [EOL]         } [EOL]         if ("".equals(explName)) { [EOL]             explName = implName; [EOL]         } [EOL]         boolean visible = (explName != null); [EOL]         if (!visible) { [EOL]             visible = _visibilityChecker.isFieldVisible(f); [EOL]         } [EOL]         boolean ignored = (ai != null) && ai.hasIgnoreMarker(f); [EOL]         if (pruneFinalFields && (explName == null) && !ignored && Modifier.isFinal(f.getModifiers())) { [EOL]             continue; [EOL]         } [EOL]         _property(implName).addField(f, explName, visible, ignored); [EOL]     } [EOL] }
protected void _addFields() { [EOL]     final AnnotationIntrospector ai = _annotationIntrospector; [EOL]     final boolean pruneFinalFields = !_forSerialization && !_config.isEnabled(MapperFeature.ALLOW_FINAL_FIELDS_AS_MUTATORS); [EOL]     for (AnnotatedField f : _classDef.fields()) { [EOL]         String implName = f.getName(); [EOL]         String explName; [EOL]         if (ai == null) { [EOL]             explName = null; [EOL]         } else if (_forSerialization) { [EOL]             PropertyName pn = ai.findNameForSerialization(f); [EOL]             explName = (pn == null) ? null : pn.getSimpleName(); [EOL]         } else { [EOL]             PropertyName pn = ai.findNameForDeserialization(f); [EOL]             explName = (pn == null) ? null : pn.getSimpleName(); [EOL]         } [EOL]         if ("".equals(explName)) { [EOL]             explName = implName; [EOL]         } [EOL]         boolean visible = (explName != null); [EOL]         if (!visible) { [EOL]             visible = _visibilityChecker.isFieldVisible(f); [EOL]         } [EOL]         boolean ignored = (ai != null) && ai.hasIgnoreMarker(f); [EOL]         if (pruneFinalFields && (explName == null) && !ignored && Modifier.isFinal(f.getModifiers())) { [EOL]             continue; [EOL]         } [EOL]         _property(implName).addField(f, explName, visible, ignored); [EOL]     } [EOL] }
protected void _addFields() { [EOL]     final AnnotationIntrospector ai = _annotationIntrospector; [EOL]     final boolean pruneFinalFields = !_forSerialization && !_config.isEnabled(MapperFeature.ALLOW_FINAL_FIELDS_AS_MUTATORS); [EOL]     for (AnnotatedField f : _classDef.fields()) { [EOL]         String implName = f.getName(); [EOL]         String explName; [EOL]         if (ai == null) { [EOL]             explName = null; [EOL]         } else if (_forSerialization) { [EOL]             PropertyName pn = ai.findNameForSerialization(f); [EOL]             explName = (pn == null) ? null : pn.getSimpleName(); [EOL]         } else { [EOL]             PropertyName pn = ai.findNameForDeserialization(f); [EOL]             explName = (pn == null) ? null : pn.getSimpleName(); [EOL]         } [EOL]         if ("".equals(explName)) { [EOL]             explName = implName; [EOL]         } [EOL]         boolean visible = (explName != null); [EOL]         if (!visible) { [EOL]             visible = _visibilityChecker.isFieldVisible(f); [EOL]         } [EOL]         boolean ignored = (ai != null) && ai.hasIgnoreMarker(f); [EOL]         if (pruneFinalFields && (explName == null) && !ignored && Modifier.isFinal(f.getModifiers())) { [EOL]             continue; [EOL]         } [EOL]         _property(implName).addField(f, explName, visible, ignored); [EOL]     } [EOL] }
protected void _addFields() { [EOL]     final AnnotationIntrospector ai = _annotationIntrospector; [EOL]     final boolean pruneFinalFields = !_forSerialization && !_config.isEnabled(MapperFeature.ALLOW_FINAL_FIELDS_AS_MUTATORS); [EOL]     for (AnnotatedField f : _classDef.fields()) { [EOL]         String implName = f.getName(); [EOL]         String explName; [EOL]         if (ai == null) { [EOL]             explName = null; [EOL]         } else if (_forSerialization) { [EOL]             PropertyName pn = ai.findNameForSerialization(f); [EOL]             explName = (pn == null) ? null : pn.getSimpleName(); [EOL]         } else { [EOL]             PropertyName pn = ai.findNameForDeserialization(f); [EOL]             explName = (pn == null) ? null : pn.getSimpleName(); [EOL]         } [EOL]         if ("".equals(explName)) { [EOL]             explName = implName; [EOL]         } [EOL]         boolean visible = (explName != null); [EOL]         if (!visible) { [EOL]             visible = _visibilityChecker.isFieldVisible(f); [EOL]         } [EOL]         boolean ignored = (ai != null) && ai.hasIgnoreMarker(f); [EOL]         if (pruneFinalFields && (explName == null) && !ignored && Modifier.isFinal(f.getModifiers())) { [EOL]             continue; [EOL]         } [EOL]         _property(implName).addField(f, explName, visible, ignored); [EOL]     } [EOL] }
protected void _renameUsing(PropertyNamingStrategy naming) { [EOL]     POJOPropertyBuilder[] props = _properties.values().toArray(new POJOPropertyBuilder[_properties.size()]); [EOL]     _properties.clear(); [EOL]     for (POJOPropertyBuilder prop : props) { [EOL]         String name = prop.getName(); [EOL]         if (_forSerialization) { [EOL]             if (prop.hasGetter()) { [EOL]                 name = naming.nameForGetterMethod(_config, prop.getGetter(), name); [EOL]             } else if (prop.hasField()) { [EOL]                 name = naming.nameForField(_config, prop.getField(), name); [EOL]             } [EOL]         } else { [EOL]             if (prop.hasSetter()) { [EOL]                 name = naming.nameForSetterMethod(_config, prop.getSetter(), name); [EOL]             } else if (prop.hasConstructorParameter()) { [EOL]                 name = naming.nameForConstructorParameter(_config, prop.getConstructorParameter(), name); [EOL]             } else if (prop.hasField()) { [EOL]                 name = naming.nameForField(_config, prop.getField(), name); [EOL]             } else if (prop.hasGetter()) { [EOL]                 name = naming.nameForGetterMethod(_config, prop.getGetter(), name); [EOL]             } [EOL]         } [EOL]         if (!name.equals(prop.getName())) { [EOL]             prop = prop.withName(name); [EOL]         } [EOL]         POJOPropertyBuilder old = _properties.get(name); [EOL]         if (old == null) { [EOL]             _properties.put(name, prop); [EOL]         } else { [EOL]             old.addAll(prop); [EOL]         } [EOL]     } [EOL] }
protected void _renameUsing(PropertyNamingStrategy naming) { [EOL]     POJOPropertyBuilder[] props = _properties.values().toArray(new POJOPropertyBuilder[_properties.size()]); [EOL]     _properties.clear(); [EOL]     for (POJOPropertyBuilder prop : props) { [EOL]         String name = prop.getName(); [EOL]         if (_forSerialization) { [EOL]             if (prop.hasGetter()) { [EOL]                 name = naming.nameForGetterMethod(_config, prop.getGetter(), name); [EOL]             } else if (prop.hasField()) { [EOL]                 name = naming.nameForField(_config, prop.getField(), name); [EOL]             } [EOL]         } else { [EOL]             if (prop.hasSetter()) { [EOL]                 name = naming.nameForSetterMethod(_config, prop.getSetter(), name); [EOL]             } else if (prop.hasConstructorParameter()) { [EOL]                 name = naming.nameForConstructorParameter(_config, prop.getConstructorParameter(), name); [EOL]             } else if (prop.hasField()) { [EOL]                 name = naming.nameForField(_config, prop.getField(), name); [EOL]             } else if (prop.hasGetter()) { [EOL]                 name = naming.nameForGetterMethod(_config, prop.getGetter(), name); [EOL]             } [EOL]         } [EOL]         if (!name.equals(prop.getName())) { [EOL]             prop = prop.withName(name); [EOL]         } [EOL]         POJOPropertyBuilder old = _properties.get(name); [EOL]         if (old == null) { [EOL]             _properties.put(name, prop); [EOL]         } else { [EOL]             old.addAll(prop); [EOL]         } [EOL]     } [EOL] }
protected void _renameUsing(PropertyNamingStrategy naming) { [EOL]     POJOPropertyBuilder[] props = _properties.values().toArray(new POJOPropertyBuilder[_properties.size()]); [EOL]     _properties.clear(); [EOL]     for (POJOPropertyBuilder prop : props) { [EOL]         String name = prop.getName(); [EOL]         if (_forSerialization) { [EOL]             if (prop.hasGetter()) { [EOL]                 name = naming.nameForGetterMethod(_config, prop.getGetter(), name); [EOL]             } else if (prop.hasField()) { [EOL]                 name = naming.nameForField(_config, prop.getField(), name); [EOL]             } [EOL]         } else { [EOL]             if (prop.hasSetter()) { [EOL]                 name = naming.nameForSetterMethod(_config, prop.getSetter(), name); [EOL]             } else if (prop.hasConstructorParameter()) { [EOL]                 name = naming.nameForConstructorParameter(_config, prop.getConstructorParameter(), name); [EOL]             } else if (prop.hasField()) { [EOL]                 name = naming.nameForField(_config, prop.getField(), name); [EOL]             } else if (prop.hasGetter()) { [EOL]                 name = naming.nameForGetterMethod(_config, prop.getGetter(), name); [EOL]             } [EOL]         } [EOL]         if (!name.equals(prop.getName())) { [EOL]             prop = prop.withName(name); [EOL]         } [EOL]         POJOPropertyBuilder old = _properties.get(name); [EOL]         if (old == null) { [EOL]             _properties.put(name, prop); [EOL]         } else { [EOL]             old.addAll(prop); [EOL]         } [EOL]     } [EOL] }
protected void _renameUsing(PropertyNamingStrategy naming) { [EOL]     POJOPropertyBuilder[] props = _properties.values().toArray(new POJOPropertyBuilder[_properties.size()]); [EOL]     _properties.clear(); [EOL]     for (POJOPropertyBuilder prop : props) { [EOL]         String name = prop.getName(); [EOL]         if (_forSerialization) { [EOL]             if (prop.hasGetter()) { [EOL]                 name = naming.nameForGetterMethod(_config, prop.getGetter(), name); [EOL]             } else if (prop.hasField()) { [EOL]                 name = naming.nameForField(_config, prop.getField(), name); [EOL]             } [EOL]         } else { [EOL]             if (prop.hasSetter()) { [EOL]                 name = naming.nameForSetterMethod(_config, prop.getSetter(), name); [EOL]             } else if (prop.hasConstructorParameter()) { [EOL]                 name = naming.nameForConstructorParameter(_config, prop.getConstructorParameter(), name); [EOL]             } else if (prop.hasField()) { [EOL]                 name = naming.nameForField(_config, prop.getField(), name); [EOL]             } else if (prop.hasGetter()) { [EOL]                 name = naming.nameForGetterMethod(_config, prop.getGetter(), name); [EOL]             } [EOL]         } [EOL]         if (!name.equals(prop.getName())) { [EOL]             prop = prop.withName(name); [EOL]         } [EOL]         POJOPropertyBuilder old = _properties.get(name); [EOL]         if (old == null) { [EOL]             _properties.put(name, prop); [EOL]         } else { [EOL]             old.addAll(prop); [EOL]         } [EOL]     } [EOL] }
protected void _renameUsing(PropertyNamingStrategy naming) { [EOL]     POJOPropertyBuilder[] props = _properties.values().toArray(new POJOPropertyBuilder[_properties.size()]); [EOL]     _properties.clear(); [EOL]     for (POJOPropertyBuilder prop : props) { [EOL]         String name = prop.getName(); [EOL]         if (_forSerialization) { [EOL]             if (prop.hasGetter()) { [EOL]                 name = naming.nameForGetterMethod(_config, prop.getGetter(), name); [EOL]             } else if (prop.hasField()) { [EOL]                 name = naming.nameForField(_config, prop.getField(), name); [EOL]             } [EOL]         } else { [EOL]             if (prop.hasSetter()) { [EOL]                 name = naming.nameForSetterMethod(_config, prop.getSetter(), name); [EOL]             } else if (prop.hasConstructorParameter()) { [EOL]                 name = naming.nameForConstructorParameter(_config, prop.getConstructorParameter(), name); [EOL]             } else if (prop.hasField()) { [EOL]                 name = naming.nameForField(_config, prop.getField(), name); [EOL]             } else if (prop.hasGetter()) { [EOL]                 name = naming.nameForGetterMethod(_config, prop.getGetter(), name); [EOL]             } [EOL]         } [EOL]         if (!name.equals(prop.getName())) { [EOL]             prop = prop.withName(name); [EOL]         } [EOL]         POJOPropertyBuilder old = _properties.get(name); [EOL]         if (old == null) { [EOL]             _properties.put(name, prop); [EOL]         } else { [EOL]             old.addAll(prop); [EOL]         } [EOL]     } [EOL] }
protected void _renameUsing(PropertyNamingStrategy naming) { [EOL]     POJOPropertyBuilder[] props = _properties.values().toArray(new POJOPropertyBuilder[_properties.size()]); [EOL]     _properties.clear(); [EOL]     for (POJOPropertyBuilder prop : props) { [EOL]         String name = prop.getName(); [EOL]         if (_forSerialization) { [EOL]             if (prop.hasGetter()) { [EOL]                 name = naming.nameForGetterMethod(_config, prop.getGetter(), name); [EOL]             } else if (prop.hasField()) { [EOL]                 name = naming.nameForField(_config, prop.getField(), name); [EOL]             } [EOL]         } else { [EOL]             if (prop.hasSetter()) { [EOL]                 name = naming.nameForSetterMethod(_config, prop.getSetter(), name); [EOL]             } else if (prop.hasConstructorParameter()) { [EOL]                 name = naming.nameForConstructorParameter(_config, prop.getConstructorParameter(), name); [EOL]             } else if (prop.hasField()) { [EOL]                 name = naming.nameForField(_config, prop.getField(), name); [EOL]             } else if (prop.hasGetter()) { [EOL]                 name = naming.nameForGetterMethod(_config, prop.getGetter(), name); [EOL]             } [EOL]         } [EOL]         if (!name.equals(prop.getName())) { [EOL]             prop = prop.withName(name); [EOL]         } [EOL]         POJOPropertyBuilder old = _properties.get(name); [EOL]         if (old == null) { [EOL]             _properties.put(name, prop); [EOL]         } else { [EOL]             old.addAll(prop); [EOL]         } [EOL]     } [EOL] }
public SettableBeanProperty findBackReference(String logicalName) { [EOL]     return (_backRefProperties == null) ? null : _backRefProperties.get(logicalName); [EOL] }
public SettableBeanProperty findBackReference(String logicalName) { [EOL]     return (_backRefProperties == null) ? null : _backRefProperties.get(logicalName); [EOL] }
public SettableBeanProperty findBackReference(String logicalName) { [EOL]     return (_backRefProperties == null) ? null : _backRefProperties.get(logicalName); [EOL] }
public ObjectReader with(Base64Variant defaultBase64) { [EOL]     return _with(_config.with(defaultBase64)); [EOL] }
public ObjectReader with(Base64Variant defaultBase64) { [EOL]     return _with(_config.with(defaultBase64)); [EOL] }
@SuppressWarnings("unchecked") [EOL] public <T> T readValue(InputStream src) throws IOException, JsonProcessingException { [EOL]     if (_dataFormatReaders != null) { [EOL]         return (T) _detectBindAndClose(_dataFormatReaders.findFormat(src), false); [EOL]     } [EOL]     return (T) _bindAndClose(_jsonFactory.createParser(src), _valueToUpdate); [EOL] }
@SuppressWarnings("unchecked") [EOL] public <T> T readValue(InputStream src) throws IOException, JsonProcessingException { [EOL]     if (_dataFormatReaders != null) { [EOL]         return (T) _detectBindAndClose(_dataFormatReaders.findFormat(src), false); [EOL]     } [EOL]     return (T) _bindAndClose(_jsonFactory.createParser(src), _valueToUpdate); [EOL] }
public JsonNode readTree(String json) throws IOException, JsonProcessingException { [EOL]     if (_dataFormatReaders != null) { [EOL]         _reportUndetectableSource(json); [EOL]     } [EOL]     return _bindAndCloseAsTree(_jsonFactory.createParser(json)); [EOL] }
public JsonNode readTree(String json) throws IOException, JsonProcessingException { [EOL]     if (_dataFormatReaders != null) { [EOL]         _reportUndetectableSource(json); [EOL]     } [EOL]     return _bindAndCloseAsTree(_jsonFactory.createParser(json)); [EOL] }
public <T> MappingIterator<T> readValues(JsonParser jp) throws IOException, JsonProcessingException { [EOL]     DeserializationContext ctxt = createDeserializationContext(jp, _config); [EOL]     return new MappingIterator<T>(_valueType, jp, ctxt, _findRootDeserializer(ctxt, _valueType), false, _valueToUpdate); [EOL] }
public <T> MappingIterator<T> readValues(JsonParser jp) throws IOException, JsonProcessingException { [EOL]     DeserializationContext ctxt = createDeserializationContext(jp, _config); [EOL]     return new MappingIterator<T>(_valueType, jp, ctxt, _findRootDeserializer(ctxt, _valueType), false, _valueToUpdate); [EOL] }
public <T> MappingIterator<T> readValues(JsonParser jp) throws IOException, JsonProcessingException { [EOL]     DeserializationContext ctxt = createDeserializationContext(jp, _config); [EOL]     return new MappingIterator<T>(_valueType, jp, ctxt, _findRootDeserializer(ctxt, _valueType), false, _valueToUpdate); [EOL] }
protected JsonNode _bindAsTree(JsonParser jp) throws IOException, JsonParseException, JsonMappingException { [EOL]     JsonNode result; [EOL]     JsonToken t = _initForReading(jp); [EOL]     if (t == JsonToken.VALUE_NULL || t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) { [EOL]         result = NullNode.instance; [EOL]     } else { [EOL]         DeserializationContext ctxt = createDeserializationContext(jp, _config); [EOL]         JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, JSON_NODE_TYPE); [EOL]         if (_unwrapRoot) { [EOL]             result = (JsonNode) _unwrapAndDeserialize(jp, ctxt, JSON_NODE_TYPE, deser); [EOL]         } else { [EOL]             result = (JsonNode) deser.deserialize(jp, ctxt); [EOL]         } [EOL]     } [EOL]     jp.clearCurrentToken(); [EOL]     return result; [EOL] }
protected JsonNode _bindAsTree(JsonParser jp) throws IOException, JsonParseException, JsonMappingException { [EOL]     JsonNode result; [EOL]     JsonToken t = _initForReading(jp); [EOL]     if (t == JsonToken.VALUE_NULL || t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) { [EOL]         result = NullNode.instance; [EOL]     } else { [EOL]         DeserializationContext ctxt = createDeserializationContext(jp, _config); [EOL]         JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, JSON_NODE_TYPE); [EOL]         if (_unwrapRoot) { [EOL]             result = (JsonNode) _unwrapAndDeserialize(jp, ctxt, JSON_NODE_TYPE, deser); [EOL]         } else { [EOL]             result = (JsonNode) deser.deserialize(jp, ctxt); [EOL]         } [EOL]     } [EOL]     jp.clearCurrentToken(); [EOL]     return result; [EOL] }
protected JsonNode _bindAsTree(JsonParser jp) throws IOException, JsonParseException, JsonMappingException { [EOL]     JsonNode result; [EOL]     JsonToken t = _initForReading(jp); [EOL]     if (t == JsonToken.VALUE_NULL || t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) { [EOL]         result = NullNode.instance; [EOL]     } else { [EOL]         DeserializationContext ctxt = createDeserializationContext(jp, _config); [EOL]         JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, JSON_NODE_TYPE); [EOL]         if (_unwrapRoot) { [EOL]             result = (JsonNode) _unwrapAndDeserialize(jp, ctxt, JSON_NODE_TYPE, deser); [EOL]         } else { [EOL]             result = (JsonNode) deser.deserialize(jp, ctxt); [EOL]         } [EOL]     } [EOL]     jp.clearCurrentToken(); [EOL]     return result; [EOL] }
protected JsonNode _bindAsTree(JsonParser jp) throws IOException, JsonParseException, JsonMappingException { [EOL]     JsonNode result; [EOL]     JsonToken t = _initForReading(jp); [EOL]     if (t == JsonToken.VALUE_NULL || t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) { [EOL]         result = NullNode.instance; [EOL]     } else { [EOL]         DeserializationContext ctxt = createDeserializationContext(jp, _config); [EOL]         JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, JSON_NODE_TYPE); [EOL]         if (_unwrapRoot) { [EOL]             result = (JsonNode) _unwrapAndDeserialize(jp, ctxt, JSON_NODE_TYPE, deser); [EOL]         } else { [EOL]             result = (JsonNode) deser.deserialize(jp, ctxt); [EOL]         } [EOL]     } [EOL]     jp.clearCurrentToken(); [EOL]     return result; [EOL] }
protected JsonNode _bindAsTree(JsonParser jp) throws IOException, JsonParseException, JsonMappingException { [EOL]     JsonNode result; [EOL]     JsonToken t = _initForReading(jp); [EOL]     if (t == JsonToken.VALUE_NULL || t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) { [EOL]         result = NullNode.instance; [EOL]     } else { [EOL]         DeserializationContext ctxt = createDeserializationContext(jp, _config); [EOL]         JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, JSON_NODE_TYPE); [EOL]         if (_unwrapRoot) { [EOL]             result = (JsonNode) _unwrapAndDeserialize(jp, ctxt, JSON_NODE_TYPE, deser); [EOL]         } else { [EOL]             result = (JsonNode) deser.deserialize(jp, ctxt); [EOL]         } [EOL]     } [EOL]     jp.clearCurrentToken(); [EOL]     return result; [EOL] }
protected JsonNode _bindAsTree(JsonParser jp) throws IOException, JsonParseException, JsonMappingException { [EOL]     JsonNode result; [EOL]     JsonToken t = _initForReading(jp); [EOL]     if (t == JsonToken.VALUE_NULL || t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) { [EOL]         result = NullNode.instance; [EOL]     } else { [EOL]         DeserializationContext ctxt = createDeserializationContext(jp, _config); [EOL]         JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, JSON_NODE_TYPE); [EOL]         if (_unwrapRoot) { [EOL]             result = (JsonNode) _unwrapAndDeserialize(jp, ctxt, JSON_NODE_TYPE, deser); [EOL]         } else { [EOL]             result = (JsonNode) deser.deserialize(jp, ctxt); [EOL]         } [EOL]     } [EOL]     jp.clearCurrentToken(); [EOL]     return result; [EOL] }
protected JsonNode _bindAndCloseAsTree(JsonParser jp) throws IOException, JsonParseException, JsonMappingException { [EOL]     if (_schema != null) { [EOL]         jp.setSchema(_schema); [EOL]     } [EOL]     try { [EOL]         return _bindAsTree(jp); [EOL]     } finally { [EOL]         try { [EOL]             jp.close(); [EOL]         } catch (IOException ioe) { [EOL]         } [EOL]     } [EOL] }
protected JsonNode _bindAndCloseAsTree(JsonParser jp) throws IOException, JsonParseException, JsonMappingException { [EOL]     if (_schema != null) { [EOL]         jp.setSchema(_schema); [EOL]     } [EOL]     try { [EOL]         return _bindAsTree(jp); [EOL]     } finally { [EOL]         try { [EOL]             jp.close(); [EOL]         } catch (IOException ioe) { [EOL]         } [EOL]     } [EOL] }
protected JsonNode _bindAndCloseAsTree(JsonParser jp) throws IOException, JsonParseException, JsonMappingException { [EOL]     if (_schema != null) { [EOL]         jp.setSchema(_schema); [EOL]     } [EOL]     try { [EOL]         return _bindAsTree(jp); [EOL]     } finally { [EOL]         try { [EOL]             jp.close(); [EOL]         } catch (IOException ioe) { [EOL]         } [EOL]     } [EOL] }
protected JsonDeserializer<Object> _findRootDeserializer(DeserializationContext ctxt, JavaType valueType) throws JsonMappingException { [EOL]     if (_rootDeserializer != null) { [EOL]         return _rootDeserializer; [EOL]     } [EOL]     if (valueType == null) { [EOL]         throw new JsonMappingException("No value type configured for ObjectReader"); [EOL]     } [EOL]     JsonDeserializer<Object> deser = _rootDeserializers.get(valueType); [EOL]     if (deser != null) { [EOL]         return deser; [EOL]     } [EOL]     deser = ctxt.findRootValueDeserializer(valueType); [EOL]     if (deser == null) { [EOL]         throw new JsonMappingException("Can not find a deserializer for type " + valueType); [EOL]     } [EOL]     _rootDeserializers.put(valueType, deser); [EOL]     return deser; [EOL] }
protected ObjectReader _with(DeserializationConfig newConfig) { [EOL]     if (newConfig == _config) { [EOL]         return this; [EOL]     } [EOL]     if (_dataFormatReaders != null) { [EOL]         return new ObjectReader(this, newConfig).withFormatDetection(_dataFormatReaders.with(newConfig)); [EOL]     } [EOL]     return new ObjectReader(this, newConfig); [EOL] }
protected ObjectReader _with(DeserializationConfig newConfig) { [EOL]     if (newConfig == _config) { [EOL]         return this; [EOL]     } [EOL]     if (_dataFormatReaders != null) { [EOL]         return new ObjectReader(this, newConfig).withFormatDetection(_dataFormatReaders.with(newConfig)); [EOL]     } [EOL]     return new ObjectReader(this, newConfig); [EOL] }
protected ObjectReader _with(DeserializationConfig newConfig) { [EOL]     if (newConfig == _config) { [EOL]         return this; [EOL]     } [EOL]     if (_dataFormatReaders != null) { [EOL]         return new ObjectReader(this, newConfig).withFormatDetection(_dataFormatReaders.with(newConfig)); [EOL]     } [EOL]     return new ObjectReader(this, newConfig); [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) [EOL]         return false; [EOL]     CollectionLikeType other = (CollectionLikeType) o; [EOL]     return (_class == other._class) && _elementType.equals(other._elementType); [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) [EOL]         return false; [EOL]     CollectionLikeType other = (CollectionLikeType) o; [EOL]     return (_class == other._class) && _elementType.equals(other._elementType); [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) [EOL]         return false; [EOL]     CollectionLikeType other = (CollectionLikeType) o; [EOL]     return (_class == other._class) && _elementType.equals(other._elementType); [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) [EOL]         return false; [EOL]     CollectionLikeType other = (CollectionLikeType) o; [EOL]     return (_class == other._class) && _elementType.equals(other._elementType); [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) [EOL]         return false; [EOL]     CollectionLikeType other = (CollectionLikeType) o; [EOL]     return (_class == other._class) && _elementType.equals(other._elementType); [EOL] }
@Override [EOL] public String toCanonical() { [EOL]     String str = _canonicalName; [EOL]     if (str == null) { [EOL]         str = buildCanonicalName(); [EOL]     } [EOL]     return str; [EOL] }
@Override [EOL] public String toCanonical() { [EOL]     String str = _canonicalName; [EOL]     if (str == null) { [EOL]         str = buildCanonicalName(); [EOL]     } [EOL]     return str; [EOL] }
@Override [EOL] @SuppressWarnings("unchecked") [EOL] public <T> T getValueHandler() { [EOL]     return (T) _valueHandler; [EOL] }
@Override [EOL] @SuppressWarnings("unchecked") [EOL] public <T> T getValueHandler() { [EOL]     return (T) _valueHandler; [EOL] }
@Override [EOL] @SuppressWarnings("unchecked") [EOL] public <T> T getTypeHandler() { [EOL]     return (T) _typeHandler; [EOL] }
@Override [EOL] @SuppressWarnings("unchecked") [EOL] public <T> T getTypeHandler() { [EOL]     return (T) _typeHandler; [EOL] }
protected ObjectWriter(ObjectMapper mapper, SerializationConfig config) { [EOL]     _config = config; [EOL]     _serializerProvider = mapper._serializerProvider; [EOL]     _serializerFactory = mapper._serializerFactory; [EOL]     _jsonFactory = mapper._jsonFactory; [EOL]     _rootType = null; [EOL]     _rootSerializer = null; [EOL]     _prettyPrinter = null; [EOL]     _schema = null; [EOL] }
protected ObjectWriter(ObjectWriter base, SerializationConfig config, JavaType rootType, JsonSerializer<Object> rootSer, PrettyPrinter pp, FormatSchema s) { [EOL]     _config = config; [EOL]     _serializerProvider = base._serializerProvider; [EOL]     _serializerFactory = base._serializerFactory; [EOL]     _jsonFactory = base._jsonFactory; [EOL]     _rootType = rootType; [EOL]     _rootSerializer = rootSer; [EOL]     _prettyPrinter = pp; [EOL]     _schema = s; [EOL] }
protected ObjectWriter(ObjectWriter base, SerializationConfig config) { [EOL]     _config = config; [EOL]     _serializerProvider = base._serializerProvider; [EOL]     _serializerFactory = base._serializerFactory; [EOL]     _jsonFactory = base._jsonFactory; [EOL]     _schema = base._schema; [EOL]     _rootType = base._rootType; [EOL]     _rootSerializer = base._rootSerializer; [EOL]     _prettyPrinter = base._prettyPrinter; [EOL] }
public ObjectWriter with(DateFormat df) { [EOL]     SerializationConfig newConfig = _config.with(df); [EOL]     return (newConfig == _config) ? this : new ObjectWriter(this, newConfig); [EOL] }
public ObjectWriter with(DateFormat df) { [EOL]     SerializationConfig newConfig = _config.with(df); [EOL]     return (newConfig == _config) ? this : new ObjectWriter(this, newConfig); [EOL] }
public ObjectWriter withDefaultPrettyPrinter() { [EOL]     return with(new DefaultPrettyPrinter()); [EOL] }
public ObjectWriter with(PrettyPrinter pp) { [EOL]     if (pp == _prettyPrinter) { [EOL]         return this; [EOL]     } [EOL]     if (pp == null) { [EOL]         pp = NULL_PRETTY_PRINTER; [EOL]     } [EOL]     return new ObjectWriter(this, _config, _rootType, _rootSerializer, pp, _schema); [EOL] }
public ObjectWriter with(PrettyPrinter pp) { [EOL]     if (pp == _prettyPrinter) { [EOL]         return this; [EOL]     } [EOL]     if (pp == null) { [EOL]         pp = NULL_PRETTY_PRINTER; [EOL]     } [EOL]     return new ObjectWriter(this, _config, _rootType, _rootSerializer, pp, _schema); [EOL] }
public ObjectWriter with(PrettyPrinter pp) { [EOL]     if (pp == _prettyPrinter) { [EOL]         return this; [EOL]     } [EOL]     if (pp == null) { [EOL]         pp = NULL_PRETTY_PRINTER; [EOL]     } [EOL]     return new ObjectWriter(this, _config, _rootType, _rootSerializer, pp, _schema); [EOL] }
public ObjectWriter withType(JavaType rootType) { [EOL]     rootType = rootType.withStaticTyping(); [EOL]     JsonSerializer<Object> rootSer = _prefetchRootSerializer(_config, rootType); [EOL]     return new ObjectWriter(this, _config, rootType, rootSer, _prettyPrinter, _schema); [EOL] }
public ObjectWriter withType(JavaType rootType) { [EOL]     rootType = rootType.withStaticTyping(); [EOL]     JsonSerializer<Object> rootSer = _prefetchRootSerializer(_config, rootType); [EOL]     return new ObjectWriter(this, _config, rootType, rootSer, _prettyPrinter, _schema); [EOL] }
public ObjectWriter withType(Class<?> rootType) { [EOL]     return withType(_config.constructType(rootType)); [EOL] }
public ObjectWriter withType(Class<?> rootType) { [EOL]     return withType(_config.constructType(rootType)); [EOL] }
public boolean hasPrefetchedSerializer() { [EOL]     return _rootSerializer != null; [EOL] }
public boolean hasPrefetchedSerializer() { [EOL]     return _rootSerializer != null; [EOL] }
public String writeValueAsString(Object value) throws JsonProcessingException { [EOL]     SegmentedStringWriter sw = new SegmentedStringWriter(_jsonFactory._getBufferRecycler()); [EOL]     try { [EOL]         _configAndWriteValue(_jsonFactory.createGenerator(sw), value); [EOL]     } catch (JsonProcessingException e) { [EOL]         throw e; [EOL]     } catch (IOException e) { [EOL]         throw JsonMappingException.fromUnexpectedIOE(e); [EOL]     } [EOL]     return sw.getAndClear(); [EOL] }
protected DefaultSerializerProvider _serializerProvider(SerializationConfig config) { [EOL]     return _serializerProvider.createInstance(config, _serializerFactory); [EOL] }
protected DefaultSerializerProvider _serializerProvider(SerializationConfig config) { [EOL]     return _serializerProvider.createInstance(config, _serializerFactory); [EOL] }
protected final void _configAndWriteValue(JsonGenerator jgen, Object value) throws IOException, JsonGenerationException, JsonMappingException { [EOL]     _configureJsonGenerator(jgen); [EOL]     if (_config.isEnabled(SerializationFeature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) { [EOL]         _writeCloseable(jgen, value, _config); [EOL]         return; [EOL]     } [EOL]     boolean closed = false; [EOL]     try { [EOL]         if (_rootType == null) { [EOL]             _serializerProvider(_config).serializeValue(jgen, value); [EOL]         } else { [EOL]             _serializerProvider(_config).serializeValue(jgen, value, _rootType, _rootSerializer); [EOL]         } [EOL]         closed = true; [EOL]         jgen.close(); [EOL]     } finally { [EOL]         if (!closed) { [EOL]             try { [EOL]                 jgen.close(); [EOL]             } catch (IOException ioe) { [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected final void _configAndWriteValue(JsonGenerator jgen, Object value) throws IOException, JsonGenerationException, JsonMappingException { [EOL]     _configureJsonGenerator(jgen); [EOL]     if (_config.isEnabled(SerializationFeature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) { [EOL]         _writeCloseable(jgen, value, _config); [EOL]         return; [EOL]     } [EOL]     boolean closed = false; [EOL]     try { [EOL]         if (_rootType == null) { [EOL]             _serializerProvider(_config).serializeValue(jgen, value); [EOL]         } else { [EOL]             _serializerProvider(_config).serializeValue(jgen, value, _rootType, _rootSerializer); [EOL]         } [EOL]         closed = true; [EOL]         jgen.close(); [EOL]     } finally { [EOL]         if (!closed) { [EOL]             try { [EOL]                 jgen.close(); [EOL]             } catch (IOException ioe) { [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected final void _configAndWriteValue(JsonGenerator jgen, Object value) throws IOException, JsonGenerationException, JsonMappingException { [EOL]     _configureJsonGenerator(jgen); [EOL]     if (_config.isEnabled(SerializationFeature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) { [EOL]         _writeCloseable(jgen, value, _config); [EOL]         return; [EOL]     } [EOL]     boolean closed = false; [EOL]     try { [EOL]         if (_rootType == null) { [EOL]             _serializerProvider(_config).serializeValue(jgen, value); [EOL]         } else { [EOL]             _serializerProvider(_config).serializeValue(jgen, value, _rootType, _rootSerializer); [EOL]         } [EOL]         closed = true; [EOL]         jgen.close(); [EOL]     } finally { [EOL]         if (!closed) { [EOL]             try { [EOL]                 jgen.close(); [EOL]             } catch (IOException ioe) { [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected final void _configAndWriteValue(JsonGenerator jgen, Object value) throws IOException, JsonGenerationException, JsonMappingException { [EOL]     _configureJsonGenerator(jgen); [EOL]     if (_config.isEnabled(SerializationFeature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) { [EOL]         _writeCloseable(jgen, value, _config); [EOL]         return; [EOL]     } [EOL]     boolean closed = false; [EOL]     try { [EOL]         if (_rootType == null) { [EOL]             _serializerProvider(_config).serializeValue(jgen, value); [EOL]         } else { [EOL]             _serializerProvider(_config).serializeValue(jgen, value, _rootType, _rootSerializer); [EOL]         } [EOL]         closed = true; [EOL]         jgen.close(); [EOL]     } finally { [EOL]         if (!closed) { [EOL]             try { [EOL]                 jgen.close(); [EOL]             } catch (IOException ioe) { [EOL]             } [EOL]         } [EOL]     } [EOL] }
private final void _writeCloseable(JsonGenerator jgen, Object value, SerializationConfig cfg) throws IOException, JsonGenerationException, JsonMappingException { [EOL]     Closeable toClose = (Closeable) value; [EOL]     try { [EOL]         if (_rootType == null) { [EOL]             _serializerProvider(cfg).serializeValue(jgen, value); [EOL]         } else { [EOL]             _serializerProvider(cfg).serializeValue(jgen, value, _rootType, _rootSerializer); [EOL]         } [EOL]         JsonGenerator tmpJgen = jgen; [EOL]         jgen = null; [EOL]         tmpJgen.close(); [EOL]         Closeable tmpToClose = toClose; [EOL]         toClose = null; [EOL]         tmpToClose.close(); [EOL]     } finally { [EOL]         if (jgen != null) { [EOL]             try { [EOL]                 jgen.close(); [EOL]             } catch (IOException ioe) { [EOL]             } [EOL]         } [EOL]         if (toClose != null) { [EOL]             try { [EOL]                 toClose.close(); [EOL]             } catch (IOException ioe) { [EOL]             } [EOL]         } [EOL]     } [EOL] }
private final void _writeCloseable(JsonGenerator jgen, Object value, SerializationConfig cfg) throws IOException, JsonGenerationException, JsonMappingException { [EOL]     Closeable toClose = (Closeable) value; [EOL]     try { [EOL]         if (_rootType == null) { [EOL]             _serializerProvider(cfg).serializeValue(jgen, value); [EOL]         } else { [EOL]             _serializerProvider(cfg).serializeValue(jgen, value, _rootType, _rootSerializer); [EOL]         } [EOL]         JsonGenerator tmpJgen = jgen; [EOL]         jgen = null; [EOL]         tmpJgen.close(); [EOL]         Closeable tmpToClose = toClose; [EOL]         toClose = null; [EOL]         tmpToClose.close(); [EOL]     } finally { [EOL]         if (jgen != null) { [EOL]             try { [EOL]                 jgen.close(); [EOL]             } catch (IOException ioe) { [EOL]             } [EOL]         } [EOL]         if (toClose != null) { [EOL]             try { [EOL]                 toClose.close(); [EOL]             } catch (IOException ioe) { [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected JsonSerializer<Object> _prefetchRootSerializer(SerializationConfig config, JavaType valueType) { [EOL]     if (valueType == null || !_config.isEnabled(SerializationFeature.EAGER_SERIALIZER_FETCH)) { [EOL]         return null; [EOL]     } [EOL]     try { [EOL]         return _serializerProvider(config).findTypedValueSerializer(valueType, true, null); [EOL]     } catch (JsonProcessingException e) { [EOL]         return null; [EOL]     } [EOL] }
protected JsonSerializer<Object> _prefetchRootSerializer(SerializationConfig config, JavaType valueType) { [EOL]     if (valueType == null || !_config.isEnabled(SerializationFeature.EAGER_SERIALIZER_FETCH)) { [EOL]         return null; [EOL]     } [EOL]     try { [EOL]         return _serializerProvider(config).findTypedValueSerializer(valueType, true, null); [EOL]     } catch (JsonProcessingException e) { [EOL]         return null; [EOL]     } [EOL] }
protected JsonSerializer<Object> _prefetchRootSerializer(SerializationConfig config, JavaType valueType) { [EOL]     if (valueType == null || !_config.isEnabled(SerializationFeature.EAGER_SERIALIZER_FETCH)) { [EOL]         return null; [EOL]     } [EOL]     try { [EOL]         return _serializerProvider(config).findTypedValueSerializer(valueType, true, null); [EOL]     } catch (JsonProcessingException e) { [EOL]         return null; [EOL]     } [EOL] }
protected JsonSerializer<Object> _prefetchRootSerializer(SerializationConfig config, JavaType valueType) { [EOL]     if (valueType == null || !_config.isEnabled(SerializationFeature.EAGER_SERIALIZER_FETCH)) { [EOL]         return null; [EOL]     } [EOL]     try { [EOL]         return _serializerProvider(config).findTypedValueSerializer(valueType, true, null); [EOL]     } catch (JsonProcessingException e) { [EOL]         return null; [EOL]     } [EOL] }
private void _configureJsonGenerator(JsonGenerator jgen) { [EOL]     if (_prettyPrinter != null) { [EOL]         PrettyPrinter pp = _prettyPrinter; [EOL]         if (pp == NULL_PRETTY_PRINTER) { [EOL]             jgen.setPrettyPrinter(null); [EOL]         } else { [EOL]             if (pp instanceof Instantiatable<?>) { [EOL]                 pp = (PrettyPrinter) ((Instantiatable<?>) pp).createInstance(); [EOL]             } [EOL]             jgen.setPrettyPrinter(pp); [EOL]         } [EOL]     } else if (_config.isEnabled(SerializationFeature.INDENT_OUTPUT)) { [EOL]         jgen.useDefaultPrettyPrinter(); [EOL]     } [EOL]     if (_schema != null) { [EOL]         jgen.setSchema(_schema); [EOL]     } [EOL] }
private void _configureJsonGenerator(JsonGenerator jgen) { [EOL]     if (_prettyPrinter != null) { [EOL]         PrettyPrinter pp = _prettyPrinter; [EOL]         if (pp == NULL_PRETTY_PRINTER) { [EOL]             jgen.setPrettyPrinter(null); [EOL]         } else { [EOL]             if (pp instanceof Instantiatable<?>) { [EOL]                 pp = (PrettyPrinter) ((Instantiatable<?>) pp).createInstance(); [EOL]             } [EOL]             jgen.setPrettyPrinter(pp); [EOL]         } [EOL]     } else if (_config.isEnabled(SerializationFeature.INDENT_OUTPUT)) { [EOL]         jgen.useDefaultPrettyPrinter(); [EOL]     } [EOL]     if (_schema != null) { [EOL]         jgen.setSchema(_schema); [EOL]     } [EOL] }
private void _configureJsonGenerator(JsonGenerator jgen) { [EOL]     if (_prettyPrinter != null) { [EOL]         PrettyPrinter pp = _prettyPrinter; [EOL]         if (pp == NULL_PRETTY_PRINTER) { [EOL]             jgen.setPrettyPrinter(null); [EOL]         } else { [EOL]             if (pp instanceof Instantiatable<?>) { [EOL]                 pp = (PrettyPrinter) ((Instantiatable<?>) pp).createInstance(); [EOL]             } [EOL]             jgen.setPrettyPrinter(pp); [EOL]         } [EOL]     } else if (_config.isEnabled(SerializationFeature.INDENT_OUTPUT)) { [EOL]         jgen.useDefaultPrettyPrinter(); [EOL]     } [EOL]     if (_schema != null) { [EOL]         jgen.setSchema(_schema); [EOL]     } [EOL] }
private void _configureJsonGenerator(JsonGenerator jgen) { [EOL]     if (_prettyPrinter != null) { [EOL]         PrettyPrinter pp = _prettyPrinter; [EOL]         if (pp == NULL_PRETTY_PRINTER) { [EOL]             jgen.setPrettyPrinter(null); [EOL]         } else { [EOL]             if (pp instanceof Instantiatable<?>) { [EOL]                 pp = (PrettyPrinter) ((Instantiatable<?>) pp).createInstance(); [EOL]             } [EOL]             jgen.setPrettyPrinter(pp); [EOL]         } [EOL]     } else if (_config.isEnabled(SerializationFeature.INDENT_OUTPUT)) { [EOL]         jgen.useDefaultPrettyPrinter(); [EOL]     } [EOL]     if (_schema != null) { [EOL]         jgen.setSchema(_schema); [EOL]     } [EOL] }
private void _configureJsonGenerator(JsonGenerator jgen) { [EOL]     if (_prettyPrinter != null) { [EOL]         PrettyPrinter pp = _prettyPrinter; [EOL]         if (pp == NULL_PRETTY_PRINTER) { [EOL]             jgen.setPrettyPrinter(null); [EOL]         } else { [EOL]             if (pp instanceof Instantiatable<?>) { [EOL]                 pp = (PrettyPrinter) ((Instantiatable<?>) pp).createInstance(); [EOL]             } [EOL]             jgen.setPrettyPrinter(pp); [EOL]         } [EOL]     } else if (_config.isEnabled(SerializationFeature.INDENT_OUTPUT)) { [EOL]         jgen.useDefaultPrettyPrinter(); [EOL]     } [EOL]     if (_schema != null) { [EOL]         jgen.setSchema(_schema); [EOL]     } [EOL] }
@Override [EOL] public JsonToken asToken() { [EOL]     return JsonToken.START_ARRAY; [EOL] }
@Override [EOL] public JsonNode findValue(String fieldName) { [EOL]     for (JsonNode node : _children) { [EOL]         JsonNode value = node.findValue(fieldName); [EOL]         if (value != null) { [EOL]             return value; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public JsonNode findValue(String fieldName) { [EOL]     for (JsonNode node : _children) { [EOL]         JsonNode value = node.findValue(fieldName); [EOL]         if (value != null) { [EOL]             return value; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public JsonNode findValue(String fieldName) { [EOL]     for (JsonNode node : _children) { [EOL]         JsonNode value = node.findValue(fieldName); [EOL]         if (value != null) { [EOL]             return value; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public ObjectNode findParent(String fieldName) { [EOL]     for (JsonNode node : _children) { [EOL]         JsonNode parent = node.findParent(fieldName); [EOL]         if (parent != null) { [EOL]             return (ObjectNode) parent; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public ObjectNode findParent(String fieldName) { [EOL]     for (JsonNode node : _children) { [EOL]         JsonNode parent = node.findParent(fieldName); [EOL]         if (parent != null) { [EOL]             return (ObjectNode) parent; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public ArrayNode addArray() { [EOL]     ArrayNode n = arrayNode(); [EOL]     _add(n); [EOL]     return n; [EOL] }
public ObjectNode addObject() { [EOL]     ObjectNode n = objectNode(); [EOL]     _add(n); [EOL]     return n; [EOL] }
public ObjectNode addObject() { [EOL]     ObjectNode n = objectNode(); [EOL]     _add(n); [EOL]     return n; [EOL] }
public ArrayNode addPOJO(Object value) { [EOL]     if (value == null) { [EOL]         addNull(); [EOL]     } else { [EOL]         _add(POJONode(value)); [EOL]     } [EOL]     return this; [EOL] }
public ArrayNode addPOJO(Object value) { [EOL]     if (value == null) { [EOL]         addNull(); [EOL]     } else { [EOL]         _add(POJONode(value)); [EOL]     } [EOL]     return this; [EOL] }
public ArrayNode add(long v) { [EOL]     return _add(numberNode(v)); [EOL] }
public ArrayNode add(float v) { [EOL]     return _add(numberNode(v)); [EOL] }
public ArrayNode add(double v) { [EOL]     return _add(numberNode(v)); [EOL] }
public ArrayNode add(boolean v) { [EOL]     return _add(booleanNode(v)); [EOL] }
public ArrayNode add(boolean v) { [EOL]     return _add(booleanNode(v)); [EOL] }
public ArrayNode insertArray(int index) { [EOL]     ArrayNode n = arrayNode(); [EOL]     _insert(index, n); [EOL]     return n; [EOL] }
public ArrayNode insertArray(int index) { [EOL]     ArrayNode n = arrayNode(); [EOL]     _insert(index, n); [EOL]     return n; [EOL] }
public ArrayNode insertArray(int index) { [EOL]     ArrayNode n = arrayNode(); [EOL]     _insert(index, n); [EOL]     return n; [EOL] }
public ObjectNode insertObject(int index) { [EOL]     ObjectNode n = objectNode(); [EOL]     _insert(index, n); [EOL]     return n; [EOL] }
public ObjectNode insertObject(int index) { [EOL]     ObjectNode n = objectNode(); [EOL]     _insert(index, n); [EOL]     return n; [EOL] }
public ObjectNode insertObject(int index) { [EOL]     ObjectNode n = objectNode(); [EOL]     _insert(index, n); [EOL]     return n; [EOL] }
public ArrayNode insertPOJO(int index, Object value) { [EOL]     if (value == null) { [EOL]         return insertNull(index); [EOL]     } [EOL]     return _insert(index, POJONode(value)); [EOL] }
public ArrayNode insertPOJO(int index, Object value) { [EOL]     if (value == null) { [EOL]         return insertNull(index); [EOL]     } [EOL]     return _insert(index, POJONode(value)); [EOL] }
@Override [EOL] public String toString() { [EOL]     StringBuilder sb = new StringBuilder(16 + (size() << 4)); [EOL]     sb.append('['); [EOL]     for (int i = 0, len = _children.size(); i < len; ++i) { [EOL]         if (i > 0) { [EOL]             sb.append(','); [EOL]         } [EOL]         sb.append(_children.get(i).toString()); [EOL]     } [EOL]     sb.append(']'); [EOL]     return sb.toString(); [EOL] }
@Override [EOL] public String toString() { [EOL]     StringBuilder sb = new StringBuilder(16 + (size() << 4)); [EOL]     sb.append('['); [EOL]     for (int i = 0, len = _children.size(); i < len; ++i) { [EOL]         if (i > 0) { [EOL]             sb.append(','); [EOL]         } [EOL]         sb.append(_children.get(i).toString()); [EOL]     } [EOL]     sb.append(']'); [EOL]     return sb.toString(); [EOL] }
@Override [EOL] public String toString() { [EOL]     StringBuilder sb = new StringBuilder(16 + (size() << 4)); [EOL]     sb.append('['); [EOL]     for (int i = 0, len = _children.size(); i < len; ++i) { [EOL]         if (i > 0) { [EOL]             sb.append(','); [EOL]         } [EOL]         sb.append(_children.get(i).toString()); [EOL]     } [EOL]     sb.append(']'); [EOL]     return sb.toString(); [EOL] }
private ArrayNode _insert(int index, JsonNode node) { [EOL]     if (index < 0) { [EOL]         _children.add(0, node); [EOL]     } else if (index >= _children.size()) { [EOL]         _children.add(node); [EOL]     } else { [EOL]         _children.add(index, node); [EOL]     } [EOL]     return this; [EOL] }
private ArrayNode _insert(int index, JsonNode node) { [EOL]     if (index < 0) { [EOL]         _children.add(0, node); [EOL]     } else if (index >= _children.size()) { [EOL]         _children.add(node); [EOL]     } else { [EOL]         _children.add(index, node); [EOL]     } [EOL]     return this; [EOL] }
private ArrayNode _insert(int index, JsonNode node) { [EOL]     if (index < 0) { [EOL]         _children.add(0, node); [EOL]     } else if (index >= _children.size()) { [EOL]         _children.add(node); [EOL]     } else { [EOL]         _children.add(index, node); [EOL]     } [EOL]     return this; [EOL] }
public int cachedDeserializersCount() { [EOL]     return _cachedDeserializers.size(); [EOL] }
public int cachedDeserializersCount() { [EOL]     return _cachedDeserializers.size(); [EOL] }
public void flushCachedDeserializers() { [EOL]     _cachedDeserializers.clear(); [EOL] }
public JsonDeserializer<Object> findValueDeserializer(DeserializationContext ctxt, DeserializerFactory factory, JavaType propertyType) throws JsonMappingException { [EOL]     JsonDeserializer<Object> deser = _findCachedDeserializer(propertyType); [EOL]     if (deser != null) { [EOL]         return deser; [EOL]     } [EOL]     deser = _createAndCacheValueDeserializer(ctxt, factory, propertyType); [EOL]     if (deser == null) { [EOL]         deser = _handleUnknownValueDeserializer(propertyType); [EOL]     } [EOL]     return deser; [EOL] }
public JsonDeserializer<Object> findValueDeserializer(DeserializationContext ctxt, DeserializerFactory factory, JavaType propertyType) throws JsonMappingException { [EOL]     JsonDeserializer<Object> deser = _findCachedDeserializer(propertyType); [EOL]     if (deser != null) { [EOL]         return deser; [EOL]     } [EOL]     deser = _createAndCacheValueDeserializer(ctxt, factory, propertyType); [EOL]     if (deser == null) { [EOL]         deser = _handleUnknownValueDeserializer(propertyType); [EOL]     } [EOL]     return deser; [EOL] }
public JsonDeserializer<Object> findValueDeserializer(DeserializationContext ctxt, DeserializerFactory factory, JavaType propertyType) throws JsonMappingException { [EOL]     JsonDeserializer<Object> deser = _findCachedDeserializer(propertyType); [EOL]     if (deser != null) { [EOL]         return deser; [EOL]     } [EOL]     deser = _createAndCacheValueDeserializer(ctxt, factory, propertyType); [EOL]     if (deser == null) { [EOL]         deser = _handleUnknownValueDeserializer(propertyType); [EOL]     } [EOL]     return deser; [EOL] }
protected JsonDeserializer<Object> _findCachedDeserializer(JavaType type) { [EOL]     if (type == null) { [EOL]         throw new IllegalArgumentException("Null JavaType passed"); [EOL]     } [EOL]     return _cachedDeserializers.get(type); [EOL] }
protected JsonDeserializer<Object> _createAndCacheValueDeserializer(DeserializationContext ctxt, DeserializerFactory factory, JavaType type) throws JsonMappingException { [EOL]     synchronized (_incompleteDeserializers) { [EOL]         JsonDeserializer<Object> deser = _findCachedDeserializer(type); [EOL]         if (deser != null) { [EOL]             return deser; [EOL]         } [EOL]         int count = _incompleteDeserializers.size(); [EOL]         if (count > 0) { [EOL]             deser = _incompleteDeserializers.get(type); [EOL]             if (deser != null) { [EOL]                 return deser; [EOL]             } [EOL]         } [EOL]         try { [EOL]             return _createAndCache2(ctxt, factory, type); [EOL]         } finally { [EOL]             if (count == 0 && _incompleteDeserializers.size() > 0) { [EOL]                 _incompleteDeserializers.clear(); [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected JsonDeserializer<Object> _createAndCacheValueDeserializer(DeserializationContext ctxt, DeserializerFactory factory, JavaType type) throws JsonMappingException { [EOL]     synchronized (_incompleteDeserializers) { [EOL]         JsonDeserializer<Object> deser = _findCachedDeserializer(type); [EOL]         if (deser != null) { [EOL]             return deser; [EOL]         } [EOL]         int count = _incompleteDeserializers.size(); [EOL]         if (count > 0) { [EOL]             deser = _incompleteDeserializers.get(type); [EOL]             if (deser != null) { [EOL]                 return deser; [EOL]             } [EOL]         } [EOL]         try { [EOL]             return _createAndCache2(ctxt, factory, type); [EOL]         } finally { [EOL]             if (count == 0 && _incompleteDeserializers.size() > 0) { [EOL]                 _incompleteDeserializers.clear(); [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected JsonDeserializer<Object> _createAndCacheValueDeserializer(DeserializationContext ctxt, DeserializerFactory factory, JavaType type) throws JsonMappingException { [EOL]     synchronized (_incompleteDeserializers) { [EOL]         JsonDeserializer<Object> deser = _findCachedDeserializer(type); [EOL]         if (deser != null) { [EOL]             return deser; [EOL]         } [EOL]         int count = _incompleteDeserializers.size(); [EOL]         if (count > 0) { [EOL]             deser = _incompleteDeserializers.get(type); [EOL]             if (deser != null) { [EOL]                 return deser; [EOL]             } [EOL]         } [EOL]         try { [EOL]             return _createAndCache2(ctxt, factory, type); [EOL]         } finally { [EOL]             if (count == 0 && _incompleteDeserializers.size() > 0) { [EOL]                 _incompleteDeserializers.clear(); [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected JsonDeserializer<Object> _createAndCache2(DeserializationContext ctxt, DeserializerFactory factory, JavaType type) throws JsonMappingException { [EOL]     JsonDeserializer<Object> deser; [EOL]     try { [EOL]         deser = _createDeserializer(ctxt, factory, type); [EOL]     } catch (IllegalArgumentException iae) { [EOL]         throw new JsonMappingException(iae.getMessage(), null, iae); [EOL]     } [EOL]     if (deser == null) { [EOL]         return null; [EOL]     } [EOL]     boolean isResolvable = (deser instanceof ResolvableDeserializer); [EOL]     boolean addToCache = deser.isCachable(); [EOL]     if (isResolvable) { [EOL]         _incompleteDeserializers.put(type, deser); [EOL]         ((ResolvableDeserializer) deser).resolve(ctxt); [EOL]         _incompleteDeserializers.remove(type); [EOL]     } [EOL]     if (addToCache) { [EOL]         _cachedDeserializers.put(type, deser); [EOL]     } [EOL]     return deser; [EOL] }
protected JsonDeserializer<Object> _createAndCache2(DeserializationContext ctxt, DeserializerFactory factory, JavaType type) throws JsonMappingException { [EOL]     JsonDeserializer<Object> deser; [EOL]     try { [EOL]         deser = _createDeserializer(ctxt, factory, type); [EOL]     } catch (IllegalArgumentException iae) { [EOL]         throw new JsonMappingException(iae.getMessage(), null, iae); [EOL]     } [EOL]     if (deser == null) { [EOL]         return null; [EOL]     } [EOL]     boolean isResolvable = (deser instanceof ResolvableDeserializer); [EOL]     boolean addToCache = deser.isCachable(); [EOL]     if (isResolvable) { [EOL]         _incompleteDeserializers.put(type, deser); [EOL]         ((ResolvableDeserializer) deser).resolve(ctxt); [EOL]         _incompleteDeserializers.remove(type); [EOL]     } [EOL]     if (addToCache) { [EOL]         _cachedDeserializers.put(type, deser); [EOL]     } [EOL]     return deser; [EOL] }
protected JsonDeserializer<Object> _createAndCache2(DeserializationContext ctxt, DeserializerFactory factory, JavaType type) throws JsonMappingException { [EOL]     JsonDeserializer<Object> deser; [EOL]     try { [EOL]         deser = _createDeserializer(ctxt, factory, type); [EOL]     } catch (IllegalArgumentException iae) { [EOL]         throw new JsonMappingException(iae.getMessage(), null, iae); [EOL]     } [EOL]     if (deser == null) { [EOL]         return null; [EOL]     } [EOL]     boolean isResolvable = (deser instanceof ResolvableDeserializer); [EOL]     boolean addToCache = deser.isCachable(); [EOL]     if (isResolvable) { [EOL]         _incompleteDeserializers.put(type, deser); [EOL]         ((ResolvableDeserializer) deser).resolve(ctxt); [EOL]         _incompleteDeserializers.remove(type); [EOL]     } [EOL]     if (addToCache) { [EOL]         _cachedDeserializers.put(type, deser); [EOL]     } [EOL]     return deser; [EOL] }
protected JsonDeserializer<Object> _createAndCache2(DeserializationContext ctxt, DeserializerFactory factory, JavaType type) throws JsonMappingException { [EOL]     JsonDeserializer<Object> deser; [EOL]     try { [EOL]         deser = _createDeserializer(ctxt, factory, type); [EOL]     } catch (IllegalArgumentException iae) { [EOL]         throw new JsonMappingException(iae.getMessage(), null, iae); [EOL]     } [EOL]     if (deser == null) { [EOL]         return null; [EOL]     } [EOL]     boolean isResolvable = (deser instanceof ResolvableDeserializer); [EOL]     boolean addToCache = deser.isCachable(); [EOL]     if (isResolvable) { [EOL]         _incompleteDeserializers.put(type, deser); [EOL]         ((ResolvableDeserializer) deser).resolve(ctxt); [EOL]         _incompleteDeserializers.remove(type); [EOL]     } [EOL]     if (addToCache) { [EOL]         _cachedDeserializers.put(type, deser); [EOL]     } [EOL]     return deser; [EOL] }
@SuppressWarnings("unchecked") [EOL] protected JsonDeserializer<Object> _createDeserializer(DeserializationContext ctxt, DeserializerFactory factory, JavaType type) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     if (type.isAbstract() || type.isMapLikeType() || type.isCollectionLikeType()) { [EOL]         type = factory.mapAbstractType(config, type); [EOL]     } [EOL]     BeanDescription beanDesc = config.introspect(type); [EOL]     JsonDeserializer<Object> deser = findDeserializerFromAnnotation(ctxt, beanDesc.getClassInfo()); [EOL]     if (deser != null) { [EOL]         return deser; [EOL]     } [EOL]     JavaType newType = modifyTypeByAnnotation(ctxt, beanDesc.getClassInfo(), type); [EOL]     if (newType != type) { [EOL]         type = newType; [EOL]         beanDesc = config.introspect(newType); [EOL]     } [EOL]     Class<?> builder = beanDesc.findPOJOBuilder(); [EOL]     if (builder != null) { [EOL]         return (JsonDeserializer<Object>) factory.createBuilderBasedDeserializer(ctxt, type, beanDesc, builder); [EOL]     } [EOL]     Converter<Object, Object> conv = beanDesc.findDeserializationConverter(); [EOL]     if (conv == null) { [EOL]         return (JsonDeserializer<Object>) _createDeserializer2(ctxt, factory, type, beanDesc); [EOL]     } [EOL]     JavaType delegateType = conv.getInputType(ctxt.getTypeFactory()); [EOL]     return new StdDelegatingDeserializer<Object>(conv, delegateType, _createDeserializer2(ctxt, factory, delegateType, beanDesc)); [EOL] }
@SuppressWarnings("unchecked") [EOL] protected JsonDeserializer<Object> _createDeserializer(DeserializationContext ctxt, DeserializerFactory factory, JavaType type) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     if (type.isAbstract() || type.isMapLikeType() || type.isCollectionLikeType()) { [EOL]         type = factory.mapAbstractType(config, type); [EOL]     } [EOL]     BeanDescription beanDesc = config.introspect(type); [EOL]     JsonDeserializer<Object> deser = findDeserializerFromAnnotation(ctxt, beanDesc.getClassInfo()); [EOL]     if (deser != null) { [EOL]         return deser; [EOL]     } [EOL]     JavaType newType = modifyTypeByAnnotation(ctxt, beanDesc.getClassInfo(), type); [EOL]     if (newType != type) { [EOL]         type = newType; [EOL]         beanDesc = config.introspect(newType); [EOL]     } [EOL]     Class<?> builder = beanDesc.findPOJOBuilder(); [EOL]     if (builder != null) { [EOL]         return (JsonDeserializer<Object>) factory.createBuilderBasedDeserializer(ctxt, type, beanDesc, builder); [EOL]     } [EOL]     Converter<Object, Object> conv = beanDesc.findDeserializationConverter(); [EOL]     if (conv == null) { [EOL]         return (JsonDeserializer<Object>) _createDeserializer2(ctxt, factory, type, beanDesc); [EOL]     } [EOL]     JavaType delegateType = conv.getInputType(ctxt.getTypeFactory()); [EOL]     return new StdDelegatingDeserializer<Object>(conv, delegateType, _createDeserializer2(ctxt, factory, delegateType, beanDesc)); [EOL] }
@SuppressWarnings("unchecked") [EOL] protected JsonDeserializer<Object> _createDeserializer(DeserializationContext ctxt, DeserializerFactory factory, JavaType type) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     if (type.isAbstract() || type.isMapLikeType() || type.isCollectionLikeType()) { [EOL]         type = factory.mapAbstractType(config, type); [EOL]     } [EOL]     BeanDescription beanDesc = config.introspect(type); [EOL]     JsonDeserializer<Object> deser = findDeserializerFromAnnotation(ctxt, beanDesc.getClassInfo()); [EOL]     if (deser != null) { [EOL]         return deser; [EOL]     } [EOL]     JavaType newType = modifyTypeByAnnotation(ctxt, beanDesc.getClassInfo(), type); [EOL]     if (newType != type) { [EOL]         type = newType; [EOL]         beanDesc = config.introspect(newType); [EOL]     } [EOL]     Class<?> builder = beanDesc.findPOJOBuilder(); [EOL]     if (builder != null) { [EOL]         return (JsonDeserializer<Object>) factory.createBuilderBasedDeserializer(ctxt, type, beanDesc, builder); [EOL]     } [EOL]     Converter<Object, Object> conv = beanDesc.findDeserializationConverter(); [EOL]     if (conv == null) { [EOL]         return (JsonDeserializer<Object>) _createDeserializer2(ctxt, factory, type, beanDesc); [EOL]     } [EOL]     JavaType delegateType = conv.getInputType(ctxt.getTypeFactory()); [EOL]     return new StdDelegatingDeserializer<Object>(conv, delegateType, _createDeserializer2(ctxt, factory, delegateType, beanDesc)); [EOL] }
@SuppressWarnings("unchecked") [EOL] protected JsonDeserializer<Object> _createDeserializer(DeserializationContext ctxt, DeserializerFactory factory, JavaType type) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     if (type.isAbstract() || type.isMapLikeType() || type.isCollectionLikeType()) { [EOL]         type = factory.mapAbstractType(config, type); [EOL]     } [EOL]     BeanDescription beanDesc = config.introspect(type); [EOL]     JsonDeserializer<Object> deser = findDeserializerFromAnnotation(ctxt, beanDesc.getClassInfo()); [EOL]     if (deser != null) { [EOL]         return deser; [EOL]     } [EOL]     JavaType newType = modifyTypeByAnnotation(ctxt, beanDesc.getClassInfo(), type); [EOL]     if (newType != type) { [EOL]         type = newType; [EOL]         beanDesc = config.introspect(newType); [EOL]     } [EOL]     Class<?> builder = beanDesc.findPOJOBuilder(); [EOL]     if (builder != null) { [EOL]         return (JsonDeserializer<Object>) factory.createBuilderBasedDeserializer(ctxt, type, beanDesc, builder); [EOL]     } [EOL]     Converter<Object, Object> conv = beanDesc.findDeserializationConverter(); [EOL]     if (conv == null) { [EOL]         return (JsonDeserializer<Object>) _createDeserializer2(ctxt, factory, type, beanDesc); [EOL]     } [EOL]     JavaType delegateType = conv.getInputType(ctxt.getTypeFactory()); [EOL]     return new StdDelegatingDeserializer<Object>(conv, delegateType, _createDeserializer2(ctxt, factory, delegateType, beanDesc)); [EOL] }
@SuppressWarnings("unchecked") [EOL] protected JsonDeserializer<Object> _createDeserializer(DeserializationContext ctxt, DeserializerFactory factory, JavaType type) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     if (type.isAbstract() || type.isMapLikeType() || type.isCollectionLikeType()) { [EOL]         type = factory.mapAbstractType(config, type); [EOL]     } [EOL]     BeanDescription beanDesc = config.introspect(type); [EOL]     JsonDeserializer<Object> deser = findDeserializerFromAnnotation(ctxt, beanDesc.getClassInfo()); [EOL]     if (deser != null) { [EOL]         return deser; [EOL]     } [EOL]     JavaType newType = modifyTypeByAnnotation(ctxt, beanDesc.getClassInfo(), type); [EOL]     if (newType != type) { [EOL]         type = newType; [EOL]         beanDesc = config.introspect(newType); [EOL]     } [EOL]     Class<?> builder = beanDesc.findPOJOBuilder(); [EOL]     if (builder != null) { [EOL]         return (JsonDeserializer<Object>) factory.createBuilderBasedDeserializer(ctxt, type, beanDesc, builder); [EOL]     } [EOL]     Converter<Object, Object> conv = beanDesc.findDeserializationConverter(); [EOL]     if (conv == null) { [EOL]         return (JsonDeserializer<Object>) _createDeserializer2(ctxt, factory, type, beanDesc); [EOL]     } [EOL]     JavaType delegateType = conv.getInputType(ctxt.getTypeFactory()); [EOL]     return new StdDelegatingDeserializer<Object>(conv, delegateType, _createDeserializer2(ctxt, factory, delegateType, beanDesc)); [EOL] }
protected JsonDeserializer<?> _createDeserializer2(DeserializationContext ctxt, DeserializerFactory factory, JavaType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     if (type.isEnumType()) { [EOL]         return factory.createEnumDeserializer(ctxt, type, beanDesc); [EOL]     } [EOL]     if (type.isContainerType()) { [EOL]         if (type.isArrayType()) { [EOL]             return factory.createArrayDeserializer(ctxt, (ArrayType) type, beanDesc); [EOL]         } [EOL]         if (type.isMapLikeType()) { [EOL]             MapLikeType mlt = (MapLikeType) type; [EOL]             if (mlt.isTrueMapType()) { [EOL]                 return factory.createMapDeserializer(ctxt, (MapType) mlt, beanDesc); [EOL]             } [EOL]             return factory.createMapLikeDeserializer(ctxt, mlt, beanDesc); [EOL]         } [EOL]         if (type.isCollectionLikeType()) { [EOL]             JsonFormat.Value format = beanDesc.findExpectedFormat(null); [EOL]             if (format == null || format.getShape() != JsonFormat.Shape.OBJECT) { [EOL]                 CollectionLikeType clt = (CollectionLikeType) type; [EOL]                 if (clt.isTrueCollectionType()) { [EOL]                     return factory.createCollectionDeserializer(ctxt, (CollectionType) clt, beanDesc); [EOL]                 } [EOL]                 return factory.createCollectionLikeDeserializer(ctxt, clt, beanDesc); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (JsonNode.class.isAssignableFrom(type.getRawClass())) { [EOL]         return factory.createTreeDeserializer(config, type, beanDesc); [EOL]     } [EOL]     return factory.createBeanDeserializer(ctxt, type, beanDesc); [EOL] }
protected JsonDeserializer<?> _createDeserializer2(DeserializationContext ctxt, DeserializerFactory factory, JavaType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     if (type.isEnumType()) { [EOL]         return factory.createEnumDeserializer(ctxt, type, beanDesc); [EOL]     } [EOL]     if (type.isContainerType()) { [EOL]         if (type.isArrayType()) { [EOL]             return factory.createArrayDeserializer(ctxt, (ArrayType) type, beanDesc); [EOL]         } [EOL]         if (type.isMapLikeType()) { [EOL]             MapLikeType mlt = (MapLikeType) type; [EOL]             if (mlt.isTrueMapType()) { [EOL]                 return factory.createMapDeserializer(ctxt, (MapType) mlt, beanDesc); [EOL]             } [EOL]             return factory.createMapLikeDeserializer(ctxt, mlt, beanDesc); [EOL]         } [EOL]         if (type.isCollectionLikeType()) { [EOL]             JsonFormat.Value format = beanDesc.findExpectedFormat(null); [EOL]             if (format == null || format.getShape() != JsonFormat.Shape.OBJECT) { [EOL]                 CollectionLikeType clt = (CollectionLikeType) type; [EOL]                 if (clt.isTrueCollectionType()) { [EOL]                     return factory.createCollectionDeserializer(ctxt, (CollectionType) clt, beanDesc); [EOL]                 } [EOL]                 return factory.createCollectionLikeDeserializer(ctxt, clt, beanDesc); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (JsonNode.class.isAssignableFrom(type.getRawClass())) { [EOL]         return factory.createTreeDeserializer(config, type, beanDesc); [EOL]     } [EOL]     return factory.createBeanDeserializer(ctxt, type, beanDesc); [EOL] }
protected JsonDeserializer<?> _createDeserializer2(DeserializationContext ctxt, DeserializerFactory factory, JavaType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     if (type.isEnumType()) { [EOL]         return factory.createEnumDeserializer(ctxt, type, beanDesc); [EOL]     } [EOL]     if (type.isContainerType()) { [EOL]         if (type.isArrayType()) { [EOL]             return factory.createArrayDeserializer(ctxt, (ArrayType) type, beanDesc); [EOL]         } [EOL]         if (type.isMapLikeType()) { [EOL]             MapLikeType mlt = (MapLikeType) type; [EOL]             if (mlt.isTrueMapType()) { [EOL]                 return factory.createMapDeserializer(ctxt, (MapType) mlt, beanDesc); [EOL]             } [EOL]             return factory.createMapLikeDeserializer(ctxt, mlt, beanDesc); [EOL]         } [EOL]         if (type.isCollectionLikeType()) { [EOL]             JsonFormat.Value format = beanDesc.findExpectedFormat(null); [EOL]             if (format == null || format.getShape() != JsonFormat.Shape.OBJECT) { [EOL]                 CollectionLikeType clt = (CollectionLikeType) type; [EOL]                 if (clt.isTrueCollectionType()) { [EOL]                     return factory.createCollectionDeserializer(ctxt, (CollectionType) clt, beanDesc); [EOL]                 } [EOL]                 return factory.createCollectionLikeDeserializer(ctxt, clt, beanDesc); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (JsonNode.class.isAssignableFrom(type.getRawClass())) { [EOL]         return factory.createTreeDeserializer(config, type, beanDesc); [EOL]     } [EOL]     return factory.createBeanDeserializer(ctxt, type, beanDesc); [EOL] }
protected JsonDeserializer<?> _createDeserializer2(DeserializationContext ctxt, DeserializerFactory factory, JavaType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     if (type.isEnumType()) { [EOL]         return factory.createEnumDeserializer(ctxt, type, beanDesc); [EOL]     } [EOL]     if (type.isContainerType()) { [EOL]         if (type.isArrayType()) { [EOL]             return factory.createArrayDeserializer(ctxt, (ArrayType) type, beanDesc); [EOL]         } [EOL]         if (type.isMapLikeType()) { [EOL]             MapLikeType mlt = (MapLikeType) type; [EOL]             if (mlt.isTrueMapType()) { [EOL]                 return factory.createMapDeserializer(ctxt, (MapType) mlt, beanDesc); [EOL]             } [EOL]             return factory.createMapLikeDeserializer(ctxt, mlt, beanDesc); [EOL]         } [EOL]         if (type.isCollectionLikeType()) { [EOL]             JsonFormat.Value format = beanDesc.findExpectedFormat(null); [EOL]             if (format == null || format.getShape() != JsonFormat.Shape.OBJECT) { [EOL]                 CollectionLikeType clt = (CollectionLikeType) type; [EOL]                 if (clt.isTrueCollectionType()) { [EOL]                     return factory.createCollectionDeserializer(ctxt, (CollectionType) clt, beanDesc); [EOL]                 } [EOL]                 return factory.createCollectionLikeDeserializer(ctxt, clt, beanDesc); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (JsonNode.class.isAssignableFrom(type.getRawClass())) { [EOL]         return factory.createTreeDeserializer(config, type, beanDesc); [EOL]     } [EOL]     return factory.createBeanDeserializer(ctxt, type, beanDesc); [EOL] }
protected JsonDeserializer<?> _createDeserializer2(DeserializationContext ctxt, DeserializerFactory factory, JavaType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     if (type.isEnumType()) { [EOL]         return factory.createEnumDeserializer(ctxt, type, beanDesc); [EOL]     } [EOL]     if (type.isContainerType()) { [EOL]         if (type.isArrayType()) { [EOL]             return factory.createArrayDeserializer(ctxt, (ArrayType) type, beanDesc); [EOL]         } [EOL]         if (type.isMapLikeType()) { [EOL]             MapLikeType mlt = (MapLikeType) type; [EOL]             if (mlt.isTrueMapType()) { [EOL]                 return factory.createMapDeserializer(ctxt, (MapType) mlt, beanDesc); [EOL]             } [EOL]             return factory.createMapLikeDeserializer(ctxt, mlt, beanDesc); [EOL]         } [EOL]         if (type.isCollectionLikeType()) { [EOL]             JsonFormat.Value format = beanDesc.findExpectedFormat(null); [EOL]             if (format == null || format.getShape() != JsonFormat.Shape.OBJECT) { [EOL]                 CollectionLikeType clt = (CollectionLikeType) type; [EOL]                 if (clt.isTrueCollectionType()) { [EOL]                     return factory.createCollectionDeserializer(ctxt, (CollectionType) clt, beanDesc); [EOL]                 } [EOL]                 return factory.createCollectionLikeDeserializer(ctxt, clt, beanDesc); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (JsonNode.class.isAssignableFrom(type.getRawClass())) { [EOL]         return factory.createTreeDeserializer(config, type, beanDesc); [EOL]     } [EOL]     return factory.createBeanDeserializer(ctxt, type, beanDesc); [EOL] }
protected JsonDeserializer<?> _createDeserializer2(DeserializationContext ctxt, DeserializerFactory factory, JavaType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     if (type.isEnumType()) { [EOL]         return factory.createEnumDeserializer(ctxt, type, beanDesc); [EOL]     } [EOL]     if (type.isContainerType()) { [EOL]         if (type.isArrayType()) { [EOL]             return factory.createArrayDeserializer(ctxt, (ArrayType) type, beanDesc); [EOL]         } [EOL]         if (type.isMapLikeType()) { [EOL]             MapLikeType mlt = (MapLikeType) type; [EOL]             if (mlt.isTrueMapType()) { [EOL]                 return factory.createMapDeserializer(ctxt, (MapType) mlt, beanDesc); [EOL]             } [EOL]             return factory.createMapLikeDeserializer(ctxt, mlt, beanDesc); [EOL]         } [EOL]         if (type.isCollectionLikeType()) { [EOL]             JsonFormat.Value format = beanDesc.findExpectedFormat(null); [EOL]             if (format == null || format.getShape() != JsonFormat.Shape.OBJECT) { [EOL]                 CollectionLikeType clt = (CollectionLikeType) type; [EOL]                 if (clt.isTrueCollectionType()) { [EOL]                     return factory.createCollectionDeserializer(ctxt, (CollectionType) clt, beanDesc); [EOL]                 } [EOL]                 return factory.createCollectionLikeDeserializer(ctxt, clt, beanDesc); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (JsonNode.class.isAssignableFrom(type.getRawClass())) { [EOL]         return factory.createTreeDeserializer(config, type, beanDesc); [EOL]     } [EOL]     return factory.createBeanDeserializer(ctxt, type, beanDesc); [EOL] }
protected JsonDeserializer<?> _createDeserializer2(DeserializationContext ctxt, DeserializerFactory factory, JavaType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     if (type.isEnumType()) { [EOL]         return factory.createEnumDeserializer(ctxt, type, beanDesc); [EOL]     } [EOL]     if (type.isContainerType()) { [EOL]         if (type.isArrayType()) { [EOL]             return factory.createArrayDeserializer(ctxt, (ArrayType) type, beanDesc); [EOL]         } [EOL]         if (type.isMapLikeType()) { [EOL]             MapLikeType mlt = (MapLikeType) type; [EOL]             if (mlt.isTrueMapType()) { [EOL]                 return factory.createMapDeserializer(ctxt, (MapType) mlt, beanDesc); [EOL]             } [EOL]             return factory.createMapLikeDeserializer(ctxt, mlt, beanDesc); [EOL]         } [EOL]         if (type.isCollectionLikeType()) { [EOL]             JsonFormat.Value format = beanDesc.findExpectedFormat(null); [EOL]             if (format == null || format.getShape() != JsonFormat.Shape.OBJECT) { [EOL]                 CollectionLikeType clt = (CollectionLikeType) type; [EOL]                 if (clt.isTrueCollectionType()) { [EOL]                     return factory.createCollectionDeserializer(ctxt, (CollectionType) clt, beanDesc); [EOL]                 } [EOL]                 return factory.createCollectionLikeDeserializer(ctxt, clt, beanDesc); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (JsonNode.class.isAssignableFrom(type.getRawClass())) { [EOL]         return factory.createTreeDeserializer(config, type, beanDesc); [EOL]     } [EOL]     return factory.createBeanDeserializer(ctxt, type, beanDesc); [EOL] }
protected JsonDeserializer<?> _createDeserializer2(DeserializationContext ctxt, DeserializerFactory factory, JavaType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     if (type.isEnumType()) { [EOL]         return factory.createEnumDeserializer(ctxt, type, beanDesc); [EOL]     } [EOL]     if (type.isContainerType()) { [EOL]         if (type.isArrayType()) { [EOL]             return factory.createArrayDeserializer(ctxt, (ArrayType) type, beanDesc); [EOL]         } [EOL]         if (type.isMapLikeType()) { [EOL]             MapLikeType mlt = (MapLikeType) type; [EOL]             if (mlt.isTrueMapType()) { [EOL]                 return factory.createMapDeserializer(ctxt, (MapType) mlt, beanDesc); [EOL]             } [EOL]             return factory.createMapLikeDeserializer(ctxt, mlt, beanDesc); [EOL]         } [EOL]         if (type.isCollectionLikeType()) { [EOL]             JsonFormat.Value format = beanDesc.findExpectedFormat(null); [EOL]             if (format == null || format.getShape() != JsonFormat.Shape.OBJECT) { [EOL]                 CollectionLikeType clt = (CollectionLikeType) type; [EOL]                 if (clt.isTrueCollectionType()) { [EOL]                     return factory.createCollectionDeserializer(ctxt, (CollectionType) clt, beanDesc); [EOL]                 } [EOL]                 return factory.createCollectionLikeDeserializer(ctxt, clt, beanDesc); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (JsonNode.class.isAssignableFrom(type.getRawClass())) { [EOL]         return factory.createTreeDeserializer(config, type, beanDesc); [EOL]     } [EOL]     return factory.createBeanDeserializer(ctxt, type, beanDesc); [EOL] }
protected JsonDeserializer<Object> findDeserializerFromAnnotation(DeserializationContext ctxt, Annotated ann) throws JsonMappingException { [EOL]     Object deserDef = ctxt.getAnnotationIntrospector().findDeserializer(ann); [EOL]     if (deserDef == null) { [EOL]         return null; [EOL]     } [EOL]     JsonDeserializer<Object> deser = ctxt.deserializerInstance(ann, deserDef); [EOL]     return findConvertingDeserializer(ctxt, ann, deser); [EOL] }
protected JsonDeserializer<Object> findDeserializerFromAnnotation(DeserializationContext ctxt, Annotated ann) throws JsonMappingException { [EOL]     Object deserDef = ctxt.getAnnotationIntrospector().findDeserializer(ann); [EOL]     if (deserDef == null) { [EOL]         return null; [EOL]     } [EOL]     JsonDeserializer<Object> deser = ctxt.deserializerInstance(ann, deserDef); [EOL]     return findConvertingDeserializer(ctxt, ann, deser); [EOL] }
private JavaType modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, JavaType type) throws JsonMappingException { [EOL]     AnnotationIntrospector intr = ctxt.getAnnotationIntrospector(); [EOL]     Class<?> subclass = intr.findDeserializationType(a, type); [EOL]     if (subclass != null) { [EOL]         try { [EOL]             type = type.narrowBy(subclass); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw new JsonMappingException("Failed to narrow type " + type + " with concrete-type annotation (value " + subclass.getName() + "), method '" + a.getName() + "': " + iae.getMessage(), null, iae); [EOL]         } [EOL]     } [EOL]     if (type.isContainerType()) { [EOL]         Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType()); [EOL]         if (keyClass != null) { [EOL]             if (!(type instanceof MapLikeType)) { [EOL]                 throw new JsonMappingException("Illegal key-type annotation: type " + type + " is not a Map(-like) type"); [EOL]             } [EOL]             try { [EOL]                 type = ((MapLikeType) type).narrowKey(keyClass); [EOL]             } catch (IllegalArgumentException iae) { [EOL]                 throw new JsonMappingException("Failed to narrow key type " + type + " with key-type annotation (" + keyClass.getName() + "): " + iae.getMessage(), null, iae); [EOL]             } [EOL]         } [EOL]         JavaType keyType = type.getKeyType(); [EOL]         if (keyType != null && keyType.getValueHandler() == null) { [EOL]             Object kdDef = intr.findKeyDeserializer(a); [EOL]             if (kdDef != null) { [EOL]                 KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef); [EOL]                 if (kd != null) { [EOL]                     type = ((MapLikeType) type).withKeyValueHandler(kd); [EOL]                     keyType = type.getKeyType(); [EOL]                 } [EOL]             } [EOL]         } [EOL]         Class<?> cc = intr.findDeserializationContentType(a, type.getContentType()); [EOL]         if (cc != null) { [EOL]             try { [EOL]                 type = type.narrowContentsBy(cc); [EOL]             } catch (IllegalArgumentException iae) { [EOL]                 throw new JsonMappingException("Failed to narrow content type " + type + " with content-type annotation (" + cc.getName() + "): " + iae.getMessage(), null, iae); [EOL]             } [EOL]         } [EOL]         JavaType contentType = type.getContentType(); [EOL]         if (contentType.getValueHandler() == null) { [EOL]             Object cdDef = intr.findContentDeserializer(a); [EOL]             if (cdDef != null) { [EOL]                 JsonDeserializer<?> cd = null; [EOL]                 if (cdDef instanceof JsonDeserializer<?>) { [EOL]                     cdDef = (JsonDeserializer<?>) cdDef; [EOL]                 } else { [EOL]                     Class<?> cdClass = _verifyAsClass(cdDef, "findContentDeserializer", JsonDeserializer.None.class); [EOL]                     if (cdClass != null) { [EOL]                         cd = ctxt.deserializerInstance(a, cdClass); [EOL]                     } [EOL]                 } [EOL]                 if (cd != null) { [EOL]                     type = type.withContentValueHandler(cd); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return type; [EOL] }
private JavaType modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, JavaType type) throws JsonMappingException { [EOL]     AnnotationIntrospector intr = ctxt.getAnnotationIntrospector(); [EOL]     Class<?> subclass = intr.findDeserializationType(a, type); [EOL]     if (subclass != null) { [EOL]         try { [EOL]             type = type.narrowBy(subclass); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw new JsonMappingException("Failed to narrow type " + type + " with concrete-type annotation (value " + subclass.getName() + "), method '" + a.getName() + "': " + iae.getMessage(), null, iae); [EOL]         } [EOL]     } [EOL]     if (type.isContainerType()) { [EOL]         Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType()); [EOL]         if (keyClass != null) { [EOL]             if (!(type instanceof MapLikeType)) { [EOL]                 throw new JsonMappingException("Illegal key-type annotation: type " + type + " is not a Map(-like) type"); [EOL]             } [EOL]             try { [EOL]                 type = ((MapLikeType) type).narrowKey(keyClass); [EOL]             } catch (IllegalArgumentException iae) { [EOL]                 throw new JsonMappingException("Failed to narrow key type " + type + " with key-type annotation (" + keyClass.getName() + "): " + iae.getMessage(), null, iae); [EOL]             } [EOL]         } [EOL]         JavaType keyType = type.getKeyType(); [EOL]         if (keyType != null && keyType.getValueHandler() == null) { [EOL]             Object kdDef = intr.findKeyDeserializer(a); [EOL]             if (kdDef != null) { [EOL]                 KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef); [EOL]                 if (kd != null) { [EOL]                     type = ((MapLikeType) type).withKeyValueHandler(kd); [EOL]                     keyType = type.getKeyType(); [EOL]                 } [EOL]             } [EOL]         } [EOL]         Class<?> cc = intr.findDeserializationContentType(a, type.getContentType()); [EOL]         if (cc != null) { [EOL]             try { [EOL]                 type = type.narrowContentsBy(cc); [EOL]             } catch (IllegalArgumentException iae) { [EOL]                 throw new JsonMappingException("Failed to narrow content type " + type + " with content-type annotation (" + cc.getName() + "): " + iae.getMessage(), null, iae); [EOL]             } [EOL]         } [EOL]         JavaType contentType = type.getContentType(); [EOL]         if (contentType.getValueHandler() == null) { [EOL]             Object cdDef = intr.findContentDeserializer(a); [EOL]             if (cdDef != null) { [EOL]                 JsonDeserializer<?> cd = null; [EOL]                 if (cdDef instanceof JsonDeserializer<?>) { [EOL]                     cdDef = (JsonDeserializer<?>) cdDef; [EOL]                 } else { [EOL]                     Class<?> cdClass = _verifyAsClass(cdDef, "findContentDeserializer", JsonDeserializer.None.class); [EOL]                     if (cdClass != null) { [EOL]                         cd = ctxt.deserializerInstance(a, cdClass); [EOL]                     } [EOL]                 } [EOL]                 if (cd != null) { [EOL]                     type = type.withContentValueHandler(cd); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return type; [EOL] }
private JavaType modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, JavaType type) throws JsonMappingException { [EOL]     AnnotationIntrospector intr = ctxt.getAnnotationIntrospector(); [EOL]     Class<?> subclass = intr.findDeserializationType(a, type); [EOL]     if (subclass != null) { [EOL]         try { [EOL]             type = type.narrowBy(subclass); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw new JsonMappingException("Failed to narrow type " + type + " with concrete-type annotation (value " + subclass.getName() + "), method '" + a.getName() + "': " + iae.getMessage(), null, iae); [EOL]         } [EOL]     } [EOL]     if (type.isContainerType()) { [EOL]         Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType()); [EOL]         if (keyClass != null) { [EOL]             if (!(type instanceof MapLikeType)) { [EOL]                 throw new JsonMappingException("Illegal key-type annotation: type " + type + " is not a Map(-like) type"); [EOL]             } [EOL]             try { [EOL]                 type = ((MapLikeType) type).narrowKey(keyClass); [EOL]             } catch (IllegalArgumentException iae) { [EOL]                 throw new JsonMappingException("Failed to narrow key type " + type + " with key-type annotation (" + keyClass.getName() + "): " + iae.getMessage(), null, iae); [EOL]             } [EOL]         } [EOL]         JavaType keyType = type.getKeyType(); [EOL]         if (keyType != null && keyType.getValueHandler() == null) { [EOL]             Object kdDef = intr.findKeyDeserializer(a); [EOL]             if (kdDef != null) { [EOL]                 KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef); [EOL]                 if (kd != null) { [EOL]                     type = ((MapLikeType) type).withKeyValueHandler(kd); [EOL]                     keyType = type.getKeyType(); [EOL]                 } [EOL]             } [EOL]         } [EOL]         Class<?> cc = intr.findDeserializationContentType(a, type.getContentType()); [EOL]         if (cc != null) { [EOL]             try { [EOL]                 type = type.narrowContentsBy(cc); [EOL]             } catch (IllegalArgumentException iae) { [EOL]                 throw new JsonMappingException("Failed to narrow content type " + type + " with content-type annotation (" + cc.getName() + "): " + iae.getMessage(), null, iae); [EOL]             } [EOL]         } [EOL]         JavaType contentType = type.getContentType(); [EOL]         if (contentType.getValueHandler() == null) { [EOL]             Object cdDef = intr.findContentDeserializer(a); [EOL]             if (cdDef != null) { [EOL]                 JsonDeserializer<?> cd = null; [EOL]                 if (cdDef instanceof JsonDeserializer<?>) { [EOL]                     cdDef = (JsonDeserializer<?>) cdDef; [EOL]                 } else { [EOL]                     Class<?> cdClass = _verifyAsClass(cdDef, "findContentDeserializer", JsonDeserializer.None.class); [EOL]                     if (cdClass != null) { [EOL]                         cd = ctxt.deserializerInstance(a, cdClass); [EOL]                     } [EOL]                 } [EOL]                 if (cd != null) { [EOL]                     type = type.withContentValueHandler(cd); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return type; [EOL] }
private JavaType modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, JavaType type) throws JsonMappingException { [EOL]     AnnotationIntrospector intr = ctxt.getAnnotationIntrospector(); [EOL]     Class<?> subclass = intr.findDeserializationType(a, type); [EOL]     if (subclass != null) { [EOL]         try { [EOL]             type = type.narrowBy(subclass); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw new JsonMappingException("Failed to narrow type " + type + " with concrete-type annotation (value " + subclass.getName() + "), method '" + a.getName() + "': " + iae.getMessage(), null, iae); [EOL]         } [EOL]     } [EOL]     if (type.isContainerType()) { [EOL]         Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType()); [EOL]         if (keyClass != null) { [EOL]             if (!(type instanceof MapLikeType)) { [EOL]                 throw new JsonMappingException("Illegal key-type annotation: type " + type + " is not a Map(-like) type"); [EOL]             } [EOL]             try { [EOL]                 type = ((MapLikeType) type).narrowKey(keyClass); [EOL]             } catch (IllegalArgumentException iae) { [EOL]                 throw new JsonMappingException("Failed to narrow key type " + type + " with key-type annotation (" + keyClass.getName() + "): " + iae.getMessage(), null, iae); [EOL]             } [EOL]         } [EOL]         JavaType keyType = type.getKeyType(); [EOL]         if (keyType != null && keyType.getValueHandler() == null) { [EOL]             Object kdDef = intr.findKeyDeserializer(a); [EOL]             if (kdDef != null) { [EOL]                 KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef); [EOL]                 if (kd != null) { [EOL]                     type = ((MapLikeType) type).withKeyValueHandler(kd); [EOL]                     keyType = type.getKeyType(); [EOL]                 } [EOL]             } [EOL]         } [EOL]         Class<?> cc = intr.findDeserializationContentType(a, type.getContentType()); [EOL]         if (cc != null) { [EOL]             try { [EOL]                 type = type.narrowContentsBy(cc); [EOL]             } catch (IllegalArgumentException iae) { [EOL]                 throw new JsonMappingException("Failed to narrow content type " + type + " with content-type annotation (" + cc.getName() + "): " + iae.getMessage(), null, iae); [EOL]             } [EOL]         } [EOL]         JavaType contentType = type.getContentType(); [EOL]         if (contentType.getValueHandler() == null) { [EOL]             Object cdDef = intr.findContentDeserializer(a); [EOL]             if (cdDef != null) { [EOL]                 JsonDeserializer<?> cd = null; [EOL]                 if (cdDef instanceof JsonDeserializer<?>) { [EOL]                     cdDef = (JsonDeserializer<?>) cdDef; [EOL]                 } else { [EOL]                     Class<?> cdClass = _verifyAsClass(cdDef, "findContentDeserializer", JsonDeserializer.None.class); [EOL]                     if (cdClass != null) { [EOL]                         cd = ctxt.deserializerInstance(a, cdClass); [EOL]                     } [EOL]                 } [EOL]                 if (cd != null) { [EOL]                     type = type.withContentValueHandler(cd); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return type; [EOL] }
private JavaType modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, JavaType type) throws JsonMappingException { [EOL]     AnnotationIntrospector intr = ctxt.getAnnotationIntrospector(); [EOL]     Class<?> subclass = intr.findDeserializationType(a, type); [EOL]     if (subclass != null) { [EOL]         try { [EOL]             type = type.narrowBy(subclass); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw new JsonMappingException("Failed to narrow type " + type + " with concrete-type annotation (value " + subclass.getName() + "), method '" + a.getName() + "': " + iae.getMessage(), null, iae); [EOL]         } [EOL]     } [EOL]     if (type.isContainerType()) { [EOL]         Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType()); [EOL]         if (keyClass != null) { [EOL]             if (!(type instanceof MapLikeType)) { [EOL]                 throw new JsonMappingException("Illegal key-type annotation: type " + type + " is not a Map(-like) type"); [EOL]             } [EOL]             try { [EOL]                 type = ((MapLikeType) type).narrowKey(keyClass); [EOL]             } catch (IllegalArgumentException iae) { [EOL]                 throw new JsonMappingException("Failed to narrow key type " + type + " with key-type annotation (" + keyClass.getName() + "): " + iae.getMessage(), null, iae); [EOL]             } [EOL]         } [EOL]         JavaType keyType = type.getKeyType(); [EOL]         if (keyType != null && keyType.getValueHandler() == null) { [EOL]             Object kdDef = intr.findKeyDeserializer(a); [EOL]             if (kdDef != null) { [EOL]                 KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef); [EOL]                 if (kd != null) { [EOL]                     type = ((MapLikeType) type).withKeyValueHandler(kd); [EOL]                     keyType = type.getKeyType(); [EOL]                 } [EOL]             } [EOL]         } [EOL]         Class<?> cc = intr.findDeserializationContentType(a, type.getContentType()); [EOL]         if (cc != null) { [EOL]             try { [EOL]                 type = type.narrowContentsBy(cc); [EOL]             } catch (IllegalArgumentException iae) { [EOL]                 throw new JsonMappingException("Failed to narrow content type " + type + " with content-type annotation (" + cc.getName() + "): " + iae.getMessage(), null, iae); [EOL]             } [EOL]         } [EOL]         JavaType contentType = type.getContentType(); [EOL]         if (contentType.getValueHandler() == null) { [EOL]             Object cdDef = intr.findContentDeserializer(a); [EOL]             if (cdDef != null) { [EOL]                 JsonDeserializer<?> cd = null; [EOL]                 if (cdDef instanceof JsonDeserializer<?>) { [EOL]                     cdDef = (JsonDeserializer<?>) cdDef; [EOL]                 } else { [EOL]                     Class<?> cdClass = _verifyAsClass(cdDef, "findContentDeserializer", JsonDeserializer.None.class); [EOL]                     if (cdClass != null) { [EOL]                         cd = ctxt.deserializerInstance(a, cdClass); [EOL]                     } [EOL]                 } [EOL]                 if (cd != null) { [EOL]                     type = type.withContentValueHandler(cd); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return type; [EOL] }
private JavaType modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, JavaType type) throws JsonMappingException { [EOL]     AnnotationIntrospector intr = ctxt.getAnnotationIntrospector(); [EOL]     Class<?> subclass = intr.findDeserializationType(a, type); [EOL]     if (subclass != null) { [EOL]         try { [EOL]             type = type.narrowBy(subclass); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw new JsonMappingException("Failed to narrow type " + type + " with concrete-type annotation (value " + subclass.getName() + "), method '" + a.getName() + "': " + iae.getMessage(), null, iae); [EOL]         } [EOL]     } [EOL]     if (type.isContainerType()) { [EOL]         Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType()); [EOL]         if (keyClass != null) { [EOL]             if (!(type instanceof MapLikeType)) { [EOL]                 throw new JsonMappingException("Illegal key-type annotation: type " + type + " is not a Map(-like) type"); [EOL]             } [EOL]             try { [EOL]                 type = ((MapLikeType) type).narrowKey(keyClass); [EOL]             } catch (IllegalArgumentException iae) { [EOL]                 throw new JsonMappingException("Failed to narrow key type " + type + " with key-type annotation (" + keyClass.getName() + "): " + iae.getMessage(), null, iae); [EOL]             } [EOL]         } [EOL]         JavaType keyType = type.getKeyType(); [EOL]         if (keyType != null && keyType.getValueHandler() == null) { [EOL]             Object kdDef = intr.findKeyDeserializer(a); [EOL]             if (kdDef != null) { [EOL]                 KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef); [EOL]                 if (kd != null) { [EOL]                     type = ((MapLikeType) type).withKeyValueHandler(kd); [EOL]                     keyType = type.getKeyType(); [EOL]                 } [EOL]             } [EOL]         } [EOL]         Class<?> cc = intr.findDeserializationContentType(a, type.getContentType()); [EOL]         if (cc != null) { [EOL]             try { [EOL]                 type = type.narrowContentsBy(cc); [EOL]             } catch (IllegalArgumentException iae) { [EOL]                 throw new JsonMappingException("Failed to narrow content type " + type + " with content-type annotation (" + cc.getName() + "): " + iae.getMessage(), null, iae); [EOL]             } [EOL]         } [EOL]         JavaType contentType = type.getContentType(); [EOL]         if (contentType.getValueHandler() == null) { [EOL]             Object cdDef = intr.findContentDeserializer(a); [EOL]             if (cdDef != null) { [EOL]                 JsonDeserializer<?> cd = null; [EOL]                 if (cdDef instanceof JsonDeserializer<?>) { [EOL]                     cdDef = (JsonDeserializer<?>) cdDef; [EOL]                 } else { [EOL]                     Class<?> cdClass = _verifyAsClass(cdDef, "findContentDeserializer", JsonDeserializer.None.class); [EOL]                     if (cdClass != null) { [EOL]                         cd = ctxt.deserializerInstance(a, cdClass); [EOL]                     } [EOL]                 } [EOL]                 if (cd != null) { [EOL]                     type = type.withContentValueHandler(cd); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return type; [EOL] }
private JavaType modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, JavaType type) throws JsonMappingException { [EOL]     AnnotationIntrospector intr = ctxt.getAnnotationIntrospector(); [EOL]     Class<?> subclass = intr.findDeserializationType(a, type); [EOL]     if (subclass != null) { [EOL]         try { [EOL]             type = type.narrowBy(subclass); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw new JsonMappingException("Failed to narrow type " + type + " with concrete-type annotation (value " + subclass.getName() + "), method '" + a.getName() + "': " + iae.getMessage(), null, iae); [EOL]         } [EOL]     } [EOL]     if (type.isContainerType()) { [EOL]         Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType()); [EOL]         if (keyClass != null) { [EOL]             if (!(type instanceof MapLikeType)) { [EOL]                 throw new JsonMappingException("Illegal key-type annotation: type " + type + " is not a Map(-like) type"); [EOL]             } [EOL]             try { [EOL]                 type = ((MapLikeType) type).narrowKey(keyClass); [EOL]             } catch (IllegalArgumentException iae) { [EOL]                 throw new JsonMappingException("Failed to narrow key type " + type + " with key-type annotation (" + keyClass.getName() + "): " + iae.getMessage(), null, iae); [EOL]             } [EOL]         } [EOL]         JavaType keyType = type.getKeyType(); [EOL]         if (keyType != null && keyType.getValueHandler() == null) { [EOL]             Object kdDef = intr.findKeyDeserializer(a); [EOL]             if (kdDef != null) { [EOL]                 KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef); [EOL]                 if (kd != null) { [EOL]                     type = ((MapLikeType) type).withKeyValueHandler(kd); [EOL]                     keyType = type.getKeyType(); [EOL]                 } [EOL]             } [EOL]         } [EOL]         Class<?> cc = intr.findDeserializationContentType(a, type.getContentType()); [EOL]         if (cc != null) { [EOL]             try { [EOL]                 type = type.narrowContentsBy(cc); [EOL]             } catch (IllegalArgumentException iae) { [EOL]                 throw new JsonMappingException("Failed to narrow content type " + type + " with content-type annotation (" + cc.getName() + "): " + iae.getMessage(), null, iae); [EOL]             } [EOL]         } [EOL]         JavaType contentType = type.getContentType(); [EOL]         if (contentType.getValueHandler() == null) { [EOL]             Object cdDef = intr.findContentDeserializer(a); [EOL]             if (cdDef != null) { [EOL]                 JsonDeserializer<?> cd = null; [EOL]                 if (cdDef instanceof JsonDeserializer<?>) { [EOL]                     cdDef = (JsonDeserializer<?>) cdDef; [EOL]                 } else { [EOL]                     Class<?> cdClass = _verifyAsClass(cdDef, "findContentDeserializer", JsonDeserializer.None.class); [EOL]                     if (cdClass != null) { [EOL]                         cd = ctxt.deserializerInstance(a, cdClass); [EOL]                     } [EOL]                 } [EOL]                 if (cd != null) { [EOL]                     type = type.withContentValueHandler(cd); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return type; [EOL] }
@SuppressWarnings("unchecked") [EOL] protected MappingIterator(JavaType type, JsonParser jp, DeserializationContext ctxt, JsonDeserializer<?> deser, boolean managedParser, Object valueToUpdate) { [EOL]     _type = type; [EOL]     _parser = jp; [EOL]     _context = ctxt; [EOL]     _deserializer = (JsonDeserializer<T>) deser; [EOL]     _closeParser = managedParser; [EOL]     if (valueToUpdate == null) { [EOL]         _updatedValue = null; [EOL]     } else { [EOL]         _updatedValue = (T) valueToUpdate; [EOL]     } [EOL]     if (managedParser && jp != null && jp.getCurrentToken() == JsonToken.START_ARRAY) { [EOL]         jp.clearCurrentToken(); [EOL]     } [EOL] }
@SuppressWarnings("unchecked") [EOL] protected MappingIterator(JavaType type, JsonParser jp, DeserializationContext ctxt, JsonDeserializer<?> deser, boolean managedParser, Object valueToUpdate) { [EOL]     _type = type; [EOL]     _parser = jp; [EOL]     _context = ctxt; [EOL]     _deserializer = (JsonDeserializer<T>) deser; [EOL]     _closeParser = managedParser; [EOL]     if (valueToUpdate == null) { [EOL]         _updatedValue = null; [EOL]     } else { [EOL]         _updatedValue = (T) valueToUpdate; [EOL]     } [EOL]     if (managedParser && jp != null && jp.getCurrentToken() == JsonToken.START_ARRAY) { [EOL]         jp.clearCurrentToken(); [EOL]     } [EOL] }
@SuppressWarnings("unchecked") [EOL] protected MappingIterator(JavaType type, JsonParser jp, DeserializationContext ctxt, JsonDeserializer<?> deser, boolean managedParser, Object valueToUpdate) { [EOL]     _type = type; [EOL]     _parser = jp; [EOL]     _context = ctxt; [EOL]     _deserializer = (JsonDeserializer<T>) deser; [EOL]     _closeParser = managedParser; [EOL]     if (valueToUpdate == null) { [EOL]         _updatedValue = null; [EOL]     } else { [EOL]         _updatedValue = (T) valueToUpdate; [EOL]     } [EOL]     if (managedParser && jp != null && jp.getCurrentToken() == JsonToken.START_ARRAY) { [EOL]         jp.clearCurrentToken(); [EOL]     } [EOL] }
@SuppressWarnings("unchecked") [EOL] protected MappingIterator(JavaType type, JsonParser jp, DeserializationContext ctxt, JsonDeserializer<?> deser, boolean managedParser, Object valueToUpdate) { [EOL]     _type = type; [EOL]     _parser = jp; [EOL]     _context = ctxt; [EOL]     _deserializer = (JsonDeserializer<T>) deser; [EOL]     _closeParser = managedParser; [EOL]     if (valueToUpdate == null) { [EOL]         _updatedValue = null; [EOL]     } else { [EOL]         _updatedValue = (T) valueToUpdate; [EOL]     } [EOL]     if (managedParser && jp != null && jp.getCurrentToken() == JsonToken.START_ARRAY) { [EOL]         jp.clearCurrentToken(); [EOL]     } [EOL] }
public boolean hasNextValue() throws IOException { [EOL]     if (_parser == null) { [EOL]         return false; [EOL]     } [EOL]     if (!_hasNextChecked) { [EOL]         JsonToken t = _parser.getCurrentToken(); [EOL]         _hasNextChecked = true; [EOL]         if (t == null) { [EOL]             t = _parser.nextToken(); [EOL]             if (t == null || t == JsonToken.END_ARRAY) { [EOL]                 JsonParser jp = _parser; [EOL]                 _parser = null; [EOL]                 if (_closeParser) { [EOL]                     jp.close(); [EOL]                 } [EOL]                 return false; [EOL]             } [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public boolean hasNextValue() throws IOException { [EOL]     if (_parser == null) { [EOL]         return false; [EOL]     } [EOL]     if (!_hasNextChecked) { [EOL]         JsonToken t = _parser.getCurrentToken(); [EOL]         _hasNextChecked = true; [EOL]         if (t == null) { [EOL]             t = _parser.nextToken(); [EOL]             if (t == null || t == JsonToken.END_ARRAY) { [EOL]                 JsonParser jp = _parser; [EOL]                 _parser = null; [EOL]                 if (_closeParser) { [EOL]                     jp.close(); [EOL]                 } [EOL]                 return false; [EOL]             } [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public boolean hasNextValue() throws IOException { [EOL]     if (_parser == null) { [EOL]         return false; [EOL]     } [EOL]     if (!_hasNextChecked) { [EOL]         JsonToken t = _parser.getCurrentToken(); [EOL]         _hasNextChecked = true; [EOL]         if (t == null) { [EOL]             t = _parser.nextToken(); [EOL]             if (t == null || t == JsonToken.END_ARRAY) { [EOL]                 JsonParser jp = _parser; [EOL]                 _parser = null; [EOL]                 if (_closeParser) { [EOL]                     jp.close(); [EOL]                 } [EOL]                 return false; [EOL]             } [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public boolean hasNextValue() throws IOException { [EOL]     if (_parser == null) { [EOL]         return false; [EOL]     } [EOL]     if (!_hasNextChecked) { [EOL]         JsonToken t = _parser.getCurrentToken(); [EOL]         _hasNextChecked = true; [EOL]         if (t == null) { [EOL]             t = _parser.nextToken(); [EOL]             if (t == null || t == JsonToken.END_ARRAY) { [EOL]                 JsonParser jp = _parser; [EOL]                 _parser = null; [EOL]                 if (_closeParser) { [EOL]                     jp.close(); [EOL]                 } [EOL]                 return false; [EOL]             } [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public boolean hasNextValue() throws IOException { [EOL]     if (_parser == null) { [EOL]         return false; [EOL]     } [EOL]     if (!_hasNextChecked) { [EOL]         JsonToken t = _parser.getCurrentToken(); [EOL]         _hasNextChecked = true; [EOL]         if (t == null) { [EOL]             t = _parser.nextToken(); [EOL]             if (t == null || t == JsonToken.END_ARRAY) { [EOL]                 JsonParser jp = _parser; [EOL]                 _parser = null; [EOL]                 if (_closeParser) { [EOL]                     jp.close(); [EOL]                 } [EOL]                 return false; [EOL]             } [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public T nextValue() throws IOException { [EOL]     if (!_hasNextChecked) { [EOL]         if (!hasNextValue()) { [EOL]             throw new NoSuchElementException(); [EOL]         } [EOL]     } [EOL]     if (_parser == null) { [EOL]         throw new NoSuchElementException(); [EOL]     } [EOL]     _hasNextChecked = false; [EOL]     T result; [EOL]     if (_updatedValue == null) { [EOL]         result = _deserializer.deserialize(_parser, _context); [EOL]     } else { [EOL]         _deserializer.deserialize(_parser, _context, _updatedValue); [EOL]         result = _updatedValue; [EOL]     } [EOL]     _parser.clearCurrentToken(); [EOL]     return result; [EOL] }
public T nextValue() throws IOException { [EOL]     if (!_hasNextChecked) { [EOL]         if (!hasNextValue()) { [EOL]             throw new NoSuchElementException(); [EOL]         } [EOL]     } [EOL]     if (_parser == null) { [EOL]         throw new NoSuchElementException(); [EOL]     } [EOL]     _hasNextChecked = false; [EOL]     T result; [EOL]     if (_updatedValue == null) { [EOL]         result = _deserializer.deserialize(_parser, _context); [EOL]     } else { [EOL]         _deserializer.deserialize(_parser, _context, _updatedValue); [EOL]         result = _updatedValue; [EOL]     } [EOL]     _parser.clearCurrentToken(); [EOL]     return result; [EOL] }
public T nextValue() throws IOException { [EOL]     if (!_hasNextChecked) { [EOL]         if (!hasNextValue()) { [EOL]             throw new NoSuchElementException(); [EOL]         } [EOL]     } [EOL]     if (_parser == null) { [EOL]         throw new NoSuchElementException(); [EOL]     } [EOL]     _hasNextChecked = false; [EOL]     T result; [EOL]     if (_updatedValue == null) { [EOL]         result = _deserializer.deserialize(_parser, _context); [EOL]     } else { [EOL]         _deserializer.deserialize(_parser, _context, _updatedValue); [EOL]         result = _updatedValue; [EOL]     } [EOL]     _parser.clearCurrentToken(); [EOL]     return result; [EOL] }
public T nextValue() throws IOException { [EOL]     if (!_hasNextChecked) { [EOL]         if (!hasNextValue()) { [EOL]             throw new NoSuchElementException(); [EOL]         } [EOL]     } [EOL]     if (_parser == null) { [EOL]         throw new NoSuchElementException(); [EOL]     } [EOL]     _hasNextChecked = false; [EOL]     T result; [EOL]     if (_updatedValue == null) { [EOL]         result = _deserializer.deserialize(_parser, _context); [EOL]     } else { [EOL]         _deserializer.deserialize(_parser, _context, _updatedValue); [EOL]         result = _updatedValue; [EOL]     } [EOL]     _parser.clearCurrentToken(); [EOL]     return result; [EOL] }
public BinaryNode(byte[] data) { [EOL]     _data = data; [EOL] }
public BinaryNode(byte[] data) { [EOL]     _data = data; [EOL] }
public static BinaryNode valueOf(byte[] data) { [EOL]     if (data == null) { [EOL]         return null; [EOL]     } [EOL]     if (data.length == 0) { [EOL]         return EMPTY_BINARY_NODE; [EOL]     } [EOL]     return new BinaryNode(data); [EOL] }
public static BinaryNode valueOf(byte[] data) { [EOL]     if (data == null) { [EOL]         return null; [EOL]     } [EOL]     if (data.length == 0) { [EOL]         return EMPTY_BINARY_NODE; [EOL]     } [EOL]     return new BinaryNode(data); [EOL] }
public static BinaryNode valueOf(byte[] data) { [EOL]     if (data == null) { [EOL]         return null; [EOL]     } [EOL]     if (data.length == 0) { [EOL]         return EMPTY_BINARY_NODE; [EOL]     } [EOL]     return new BinaryNode(data); [EOL] }
@Override [EOL] public JsonNodeType getNodeType() { [EOL]     return JsonNodeType.BINARY; [EOL] }
@Override [EOL] public JsonToken asToken() { [EOL]     return JsonToken.VALUE_EMBEDDED_OBJECT; [EOL] }
@Override [EOL] public byte[] binaryValue() { [EOL]     return _data; [EOL] }
@Override [EOL] public String asText() { [EOL]     return Base64Variants.getDefaultVariant().encode(_data, false); [EOL] }
@Override [EOL] public String asText() { [EOL]     return Base64Variants.getDefaultVariant().encode(_data, false); [EOL] }
public Object[] completeAndClearBuffer(Object[] lastChunk, int lastChunkEntries) { [EOL]     int totalSize = lastChunkEntries + _bufferedEntryCount; [EOL]     Object[] result = new Object[totalSize]; [EOL]     _copyTo(result, totalSize, lastChunk, lastChunkEntries); [EOL]     return result; [EOL] }
public Object[] completeAndClearBuffer(Object[] lastChunk, int lastChunkEntries) { [EOL]     int totalSize = lastChunkEntries + _bufferedEntryCount; [EOL]     Object[] result = new Object[totalSize]; [EOL]     _copyTo(result, totalSize, lastChunk, lastChunkEntries); [EOL]     return result; [EOL] }
@Override [EOL] public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return mapObject(jp, ctxt); [EOL]         case START_ARRAY: [EOL]             return mapArray(jp, ctxt); [EOL]         case FIELD_NAME: [EOL]             return mapObject(jp, ctxt); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_STRING: [EOL]             return jp.getText(); [EOL]         case VALUE_NUMBER_INT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return jp.getBigIntegerValue(); [EOL]             } [EOL]             return jp.getNumberValue(); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                 return jp.getDecimalValue(); [EOL]             } [EOL]             return Double.valueOf(jp.getDoubleValue()); [EOL]         case VALUE_TRUE: [EOL]             return Boolean.TRUE; [EOL]         case VALUE_FALSE: [EOL]             return Boolean.FALSE; [EOL]         case VALUE_NULL: [EOL]             return null; [EOL]         case END_ARRAY: [EOL]         case END_OBJECT: [EOL]         default: [EOL]             throw ctxt.mappingException(Object.class); [EOL]     } [EOL] }
@Override [EOL] public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return mapObject(jp, ctxt); [EOL]         case START_ARRAY: [EOL]             return mapArray(jp, ctxt); [EOL]         case FIELD_NAME: [EOL]             return mapObject(jp, ctxt); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_STRING: [EOL]             return jp.getText(); [EOL]         case VALUE_NUMBER_INT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return jp.getBigIntegerValue(); [EOL]             } [EOL]             return jp.getNumberValue(); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                 return jp.getDecimalValue(); [EOL]             } [EOL]             return Double.valueOf(jp.getDoubleValue()); [EOL]         case VALUE_TRUE: [EOL]             return Boolean.TRUE; [EOL]         case VALUE_FALSE: [EOL]             return Boolean.FALSE; [EOL]         case VALUE_NULL: [EOL]             return null; [EOL]         case END_ARRAY: [EOL]         case END_OBJECT: [EOL]         default: [EOL]             throw ctxt.mappingException(Object.class); [EOL]     } [EOL] }
@Override [EOL] public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return mapObject(jp, ctxt); [EOL]         case START_ARRAY: [EOL]             return mapArray(jp, ctxt); [EOL]         case FIELD_NAME: [EOL]             return mapObject(jp, ctxt); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_STRING: [EOL]             return jp.getText(); [EOL]         case VALUE_NUMBER_INT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return jp.getBigIntegerValue(); [EOL]             } [EOL]             return jp.getNumberValue(); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                 return jp.getDecimalValue(); [EOL]             } [EOL]             return Double.valueOf(jp.getDoubleValue()); [EOL]         case VALUE_TRUE: [EOL]             return Boolean.TRUE; [EOL]         case VALUE_FALSE: [EOL]             return Boolean.FALSE; [EOL]         case VALUE_NULL: [EOL]             return null; [EOL]         case END_ARRAY: [EOL]         case END_OBJECT: [EOL]         default: [EOL]             throw ctxt.mappingException(Object.class); [EOL]     } [EOL] }
@Override [EOL] public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return mapObject(jp, ctxt); [EOL]         case START_ARRAY: [EOL]             return mapArray(jp, ctxt); [EOL]         case FIELD_NAME: [EOL]             return mapObject(jp, ctxt); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_STRING: [EOL]             return jp.getText(); [EOL]         case VALUE_NUMBER_INT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return jp.getBigIntegerValue(); [EOL]             } [EOL]             return jp.getNumberValue(); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                 return jp.getDecimalValue(); [EOL]             } [EOL]             return Double.valueOf(jp.getDoubleValue()); [EOL]         case VALUE_TRUE: [EOL]             return Boolean.TRUE; [EOL]         case VALUE_FALSE: [EOL]             return Boolean.FALSE; [EOL]         case VALUE_NULL: [EOL]             return null; [EOL]         case END_ARRAY: [EOL]         case END_OBJECT: [EOL]         default: [EOL]             throw ctxt.mappingException(Object.class); [EOL]     } [EOL] }
@Override [EOL] public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return mapObject(jp, ctxt); [EOL]         case START_ARRAY: [EOL]             return mapArray(jp, ctxt); [EOL]         case FIELD_NAME: [EOL]             return mapObject(jp, ctxt); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_STRING: [EOL]             return jp.getText(); [EOL]         case VALUE_NUMBER_INT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return jp.getBigIntegerValue(); [EOL]             } [EOL]             return jp.getNumberValue(); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                 return jp.getDecimalValue(); [EOL]             } [EOL]             return Double.valueOf(jp.getDoubleValue()); [EOL]         case VALUE_TRUE: [EOL]             return Boolean.TRUE; [EOL]         case VALUE_FALSE: [EOL]             return Boolean.FALSE; [EOL]         case VALUE_NULL: [EOL]             return null; [EOL]         case END_ARRAY: [EOL]         case END_OBJECT: [EOL]         default: [EOL]             throw ctxt.mappingException(Object.class); [EOL]     } [EOL] }
@Override [EOL] public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return mapObject(jp, ctxt); [EOL]         case START_ARRAY: [EOL]             return mapArray(jp, ctxt); [EOL]         case FIELD_NAME: [EOL]             return mapObject(jp, ctxt); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_STRING: [EOL]             return jp.getText(); [EOL]         case VALUE_NUMBER_INT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return jp.getBigIntegerValue(); [EOL]             } [EOL]             return jp.getNumberValue(); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                 return jp.getDecimalValue(); [EOL]             } [EOL]             return Double.valueOf(jp.getDoubleValue()); [EOL]         case VALUE_TRUE: [EOL]             return Boolean.TRUE; [EOL]         case VALUE_FALSE: [EOL]             return Boolean.FALSE; [EOL]         case VALUE_NULL: [EOL]             return null; [EOL]         case END_ARRAY: [EOL]         case END_OBJECT: [EOL]         default: [EOL]             throw ctxt.mappingException(Object.class); [EOL]     } [EOL] }
@Override [EOL] public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return mapObject(jp, ctxt); [EOL]         case START_ARRAY: [EOL]             return mapArray(jp, ctxt); [EOL]         case FIELD_NAME: [EOL]             return mapObject(jp, ctxt); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_STRING: [EOL]             return jp.getText(); [EOL]         case VALUE_NUMBER_INT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return jp.getBigIntegerValue(); [EOL]             } [EOL]             return jp.getNumberValue(); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                 return jp.getDecimalValue(); [EOL]             } [EOL]             return Double.valueOf(jp.getDoubleValue()); [EOL]         case VALUE_TRUE: [EOL]             return Boolean.TRUE; [EOL]         case VALUE_FALSE: [EOL]             return Boolean.FALSE; [EOL]         case VALUE_NULL: [EOL]             return null; [EOL]         case END_ARRAY: [EOL]         case END_OBJECT: [EOL]         default: [EOL]             throw ctxt.mappingException(Object.class); [EOL]     } [EOL] }
@Override [EOL] public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return mapObject(jp, ctxt); [EOL]         case START_ARRAY: [EOL]             return mapArray(jp, ctxt); [EOL]         case FIELD_NAME: [EOL]             return mapObject(jp, ctxt); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_STRING: [EOL]             return jp.getText(); [EOL]         case VALUE_NUMBER_INT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return jp.getBigIntegerValue(); [EOL]             } [EOL]             return jp.getNumberValue(); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                 return jp.getDecimalValue(); [EOL]             } [EOL]             return Double.valueOf(jp.getDoubleValue()); [EOL]         case VALUE_TRUE: [EOL]             return Boolean.TRUE; [EOL]         case VALUE_FALSE: [EOL]             return Boolean.FALSE; [EOL]         case VALUE_NULL: [EOL]             return null; [EOL]         case END_ARRAY: [EOL]         case END_OBJECT: [EOL]         default: [EOL]             throw ctxt.mappingException(Object.class); [EOL]     } [EOL] }
@Override [EOL] public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return mapObject(jp, ctxt); [EOL]         case START_ARRAY: [EOL]             return mapArray(jp, ctxt); [EOL]         case FIELD_NAME: [EOL]             return mapObject(jp, ctxt); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_STRING: [EOL]             return jp.getText(); [EOL]         case VALUE_NUMBER_INT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return jp.getBigIntegerValue(); [EOL]             } [EOL]             return jp.getNumberValue(); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                 return jp.getDecimalValue(); [EOL]             } [EOL]             return Double.valueOf(jp.getDoubleValue()); [EOL]         case VALUE_TRUE: [EOL]             return Boolean.TRUE; [EOL]         case VALUE_FALSE: [EOL]             return Boolean.FALSE; [EOL]         case VALUE_NULL: [EOL]             return null; [EOL]         case END_ARRAY: [EOL]         case END_OBJECT: [EOL]         default: [EOL]             throw ctxt.mappingException(Object.class); [EOL]     } [EOL] }
@Override [EOL] public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return mapObject(jp, ctxt); [EOL]         case START_ARRAY: [EOL]             return mapArray(jp, ctxt); [EOL]         case FIELD_NAME: [EOL]             return mapObject(jp, ctxt); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_STRING: [EOL]             return jp.getText(); [EOL]         case VALUE_NUMBER_INT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return jp.getBigIntegerValue(); [EOL]             } [EOL]             return jp.getNumberValue(); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                 return jp.getDecimalValue(); [EOL]             } [EOL]             return Double.valueOf(jp.getDoubleValue()); [EOL]         case VALUE_TRUE: [EOL]             return Boolean.TRUE; [EOL]         case VALUE_FALSE: [EOL]             return Boolean.FALSE; [EOL]         case VALUE_NULL: [EOL]             return null; [EOL]         case END_ARRAY: [EOL]         case END_OBJECT: [EOL]         default: [EOL]             throw ctxt.mappingException(Object.class); [EOL]     } [EOL] }
@Override [EOL] public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return mapObject(jp, ctxt); [EOL]         case START_ARRAY: [EOL]             return mapArray(jp, ctxt); [EOL]         case FIELD_NAME: [EOL]             return mapObject(jp, ctxt); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_STRING: [EOL]             return jp.getText(); [EOL]         case VALUE_NUMBER_INT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return jp.getBigIntegerValue(); [EOL]             } [EOL]             return jp.getNumberValue(); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                 return jp.getDecimalValue(); [EOL]             } [EOL]             return Double.valueOf(jp.getDoubleValue()); [EOL]         case VALUE_TRUE: [EOL]             return Boolean.TRUE; [EOL]         case VALUE_FALSE: [EOL]             return Boolean.FALSE; [EOL]         case VALUE_NULL: [EOL]             return null; [EOL]         case END_ARRAY: [EOL]         case END_OBJECT: [EOL]         default: [EOL]             throw ctxt.mappingException(Object.class); [EOL]     } [EOL] }
@Override [EOL] public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return mapObject(jp, ctxt); [EOL]         case START_ARRAY: [EOL]             return mapArray(jp, ctxt); [EOL]         case FIELD_NAME: [EOL]             return mapObject(jp, ctxt); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_STRING: [EOL]             return jp.getText(); [EOL]         case VALUE_NUMBER_INT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return jp.getBigIntegerValue(); [EOL]             } [EOL]             return jp.getNumberValue(); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                 return jp.getDecimalValue(); [EOL]             } [EOL]             return Double.valueOf(jp.getDoubleValue()); [EOL]         case VALUE_TRUE: [EOL]             return Boolean.TRUE; [EOL]         case VALUE_FALSE: [EOL]             return Boolean.FALSE; [EOL]         case VALUE_NULL: [EOL]             return null; [EOL]         case END_ARRAY: [EOL]         case END_OBJECT: [EOL]         default: [EOL]             throw ctxt.mappingException(Object.class); [EOL]     } [EOL] }
@Override [EOL] public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return mapObject(jp, ctxt); [EOL]         case START_ARRAY: [EOL]             return mapArray(jp, ctxt); [EOL]         case FIELD_NAME: [EOL]             return mapObject(jp, ctxt); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_STRING: [EOL]             return jp.getText(); [EOL]         case VALUE_NUMBER_INT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return jp.getBigIntegerValue(); [EOL]             } [EOL]             return jp.getNumberValue(); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                 return jp.getDecimalValue(); [EOL]             } [EOL]             return Double.valueOf(jp.getDoubleValue()); [EOL]         case VALUE_TRUE: [EOL]             return Boolean.TRUE; [EOL]         case VALUE_FALSE: [EOL]             return Boolean.FALSE; [EOL]         case VALUE_NULL: [EOL]             return null; [EOL]         case END_ARRAY: [EOL]         case END_OBJECT: [EOL]         default: [EOL]             throw ctxt.mappingException(Object.class); [EOL]     } [EOL] }
@Override [EOL] public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return mapObject(jp, ctxt); [EOL]         case START_ARRAY: [EOL]             return mapArray(jp, ctxt); [EOL]         case FIELD_NAME: [EOL]             return mapObject(jp, ctxt); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_STRING: [EOL]             return jp.getText(); [EOL]         case VALUE_NUMBER_INT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return jp.getBigIntegerValue(); [EOL]             } [EOL]             return jp.getNumberValue(); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                 return jp.getDecimalValue(); [EOL]             } [EOL]             return Double.valueOf(jp.getDoubleValue()); [EOL]         case VALUE_TRUE: [EOL]             return Boolean.TRUE; [EOL]         case VALUE_FALSE: [EOL]             return Boolean.FALSE; [EOL]         case VALUE_NULL: [EOL]             return null; [EOL]         case END_ARRAY: [EOL]         case END_OBJECT: [EOL]         default: [EOL]             throw ctxt.mappingException(Object.class); [EOL]     } [EOL] }
@Override [EOL] public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return mapObject(jp, ctxt); [EOL]         case START_ARRAY: [EOL]             return mapArray(jp, ctxt); [EOL]         case FIELD_NAME: [EOL]             return mapObject(jp, ctxt); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_STRING: [EOL]             return jp.getText(); [EOL]         case VALUE_NUMBER_INT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return jp.getBigIntegerValue(); [EOL]             } [EOL]             return jp.getNumberValue(); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                 return jp.getDecimalValue(); [EOL]             } [EOL]             return Double.valueOf(jp.getDoubleValue()); [EOL]         case VALUE_TRUE: [EOL]             return Boolean.TRUE; [EOL]         case VALUE_FALSE: [EOL]             return Boolean.FALSE; [EOL]         case VALUE_NULL: [EOL]             return null; [EOL]         case END_ARRAY: [EOL]         case END_OBJECT: [EOL]         default: [EOL]             throw ctxt.mappingException(Object.class); [EOL]     } [EOL] }
@Override [EOL] public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     switch(t) { [EOL]         case START_ARRAY: [EOL]         case START_OBJECT: [EOL]         case FIELD_NAME: [EOL]             return typeDeserializer.deserializeTypedFromAny(jp, ctxt); [EOL]         case VALUE_STRING: [EOL]             return jp.getText(); [EOL]         case VALUE_NUMBER_INT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return jp.getBigIntegerValue(); [EOL]             } [EOL]             return jp.getNumberValue(); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                 return jp.getDecimalValue(); [EOL]             } [EOL]             return Double.valueOf(jp.getDoubleValue()); [EOL]         case VALUE_TRUE: [EOL]             return Boolean.TRUE; [EOL]         case VALUE_FALSE: [EOL]             return Boolean.FALSE; [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_NULL: [EOL]             return null; [EOL]         default: [EOL]             throw ctxt.mappingException(Object.class); [EOL]     } [EOL] }
@Override [EOL] public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     switch(t) { [EOL]         case START_ARRAY: [EOL]         case START_OBJECT: [EOL]         case FIELD_NAME: [EOL]             return typeDeserializer.deserializeTypedFromAny(jp, ctxt); [EOL]         case VALUE_STRING: [EOL]             return jp.getText(); [EOL]         case VALUE_NUMBER_INT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return jp.getBigIntegerValue(); [EOL]             } [EOL]             return jp.getNumberValue(); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                 return jp.getDecimalValue(); [EOL]             } [EOL]             return Double.valueOf(jp.getDoubleValue()); [EOL]         case VALUE_TRUE: [EOL]             return Boolean.TRUE; [EOL]         case VALUE_FALSE: [EOL]             return Boolean.FALSE; [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_NULL: [EOL]             return null; [EOL]         default: [EOL]             throw ctxt.mappingException(Object.class); [EOL]     } [EOL] }
@Override [EOL] public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     switch(t) { [EOL]         case START_ARRAY: [EOL]         case START_OBJECT: [EOL]         case FIELD_NAME: [EOL]             return typeDeserializer.deserializeTypedFromAny(jp, ctxt); [EOL]         case VALUE_STRING: [EOL]             return jp.getText(); [EOL]         case VALUE_NUMBER_INT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return jp.getBigIntegerValue(); [EOL]             } [EOL]             return jp.getNumberValue(); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                 return jp.getDecimalValue(); [EOL]             } [EOL]             return Double.valueOf(jp.getDoubleValue()); [EOL]         case VALUE_TRUE: [EOL]             return Boolean.TRUE; [EOL]         case VALUE_FALSE: [EOL]             return Boolean.FALSE; [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_NULL: [EOL]             return null; [EOL]         default: [EOL]             throw ctxt.mappingException(Object.class); [EOL]     } [EOL] }
@Override [EOL] public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     switch(t) { [EOL]         case START_ARRAY: [EOL]         case START_OBJECT: [EOL]         case FIELD_NAME: [EOL]             return typeDeserializer.deserializeTypedFromAny(jp, ctxt); [EOL]         case VALUE_STRING: [EOL]             return jp.getText(); [EOL]         case VALUE_NUMBER_INT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return jp.getBigIntegerValue(); [EOL]             } [EOL]             return jp.getNumberValue(); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                 return jp.getDecimalValue(); [EOL]             } [EOL]             return Double.valueOf(jp.getDoubleValue()); [EOL]         case VALUE_TRUE: [EOL]             return Boolean.TRUE; [EOL]         case VALUE_FALSE: [EOL]             return Boolean.FALSE; [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_NULL: [EOL]             return null; [EOL]         default: [EOL]             throw ctxt.mappingException(Object.class); [EOL]     } [EOL] }
@Override [EOL] public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     switch(t) { [EOL]         case START_ARRAY: [EOL]         case START_OBJECT: [EOL]         case FIELD_NAME: [EOL]             return typeDeserializer.deserializeTypedFromAny(jp, ctxt); [EOL]         case VALUE_STRING: [EOL]             return jp.getText(); [EOL]         case VALUE_NUMBER_INT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return jp.getBigIntegerValue(); [EOL]             } [EOL]             return jp.getNumberValue(); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                 return jp.getDecimalValue(); [EOL]             } [EOL]             return Double.valueOf(jp.getDoubleValue()); [EOL]         case VALUE_TRUE: [EOL]             return Boolean.TRUE; [EOL]         case VALUE_FALSE: [EOL]             return Boolean.FALSE; [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_NULL: [EOL]             return null; [EOL]         default: [EOL]             throw ctxt.mappingException(Object.class); [EOL]     } [EOL] }
@Override [EOL] public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     switch(t) { [EOL]         case START_ARRAY: [EOL]         case START_OBJECT: [EOL]         case FIELD_NAME: [EOL]             return typeDeserializer.deserializeTypedFromAny(jp, ctxt); [EOL]         case VALUE_STRING: [EOL]             return jp.getText(); [EOL]         case VALUE_NUMBER_INT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return jp.getBigIntegerValue(); [EOL]             } [EOL]             return jp.getNumberValue(); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                 return jp.getDecimalValue(); [EOL]             } [EOL]             return Double.valueOf(jp.getDoubleValue()); [EOL]         case VALUE_TRUE: [EOL]             return Boolean.TRUE; [EOL]         case VALUE_FALSE: [EOL]             return Boolean.FALSE; [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_NULL: [EOL]             return null; [EOL]         default: [EOL]             throw ctxt.mappingException(Object.class); [EOL]     } [EOL] }
@Override [EOL] public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     switch(t) { [EOL]         case START_ARRAY: [EOL]         case START_OBJECT: [EOL]         case FIELD_NAME: [EOL]             return typeDeserializer.deserializeTypedFromAny(jp, ctxt); [EOL]         case VALUE_STRING: [EOL]             return jp.getText(); [EOL]         case VALUE_NUMBER_INT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return jp.getBigIntegerValue(); [EOL]             } [EOL]             return jp.getNumberValue(); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                 return jp.getDecimalValue(); [EOL]             } [EOL]             return Double.valueOf(jp.getDoubleValue()); [EOL]         case VALUE_TRUE: [EOL]             return Boolean.TRUE; [EOL]         case VALUE_FALSE: [EOL]             return Boolean.FALSE; [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_NULL: [EOL]             return null; [EOL]         default: [EOL]             throw ctxt.mappingException(Object.class); [EOL]     } [EOL] }
@Override [EOL] public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     switch(t) { [EOL]         case START_ARRAY: [EOL]         case START_OBJECT: [EOL]         case FIELD_NAME: [EOL]             return typeDeserializer.deserializeTypedFromAny(jp, ctxt); [EOL]         case VALUE_STRING: [EOL]             return jp.getText(); [EOL]         case VALUE_NUMBER_INT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return jp.getBigIntegerValue(); [EOL]             } [EOL]             return jp.getNumberValue(); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                 return jp.getDecimalValue(); [EOL]             } [EOL]             return Double.valueOf(jp.getDoubleValue()); [EOL]         case VALUE_TRUE: [EOL]             return Boolean.TRUE; [EOL]         case VALUE_FALSE: [EOL]             return Boolean.FALSE; [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_NULL: [EOL]             return null; [EOL]         default: [EOL]             throw ctxt.mappingException(Object.class); [EOL]     } [EOL] }
@Override [EOL] public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     switch(t) { [EOL]         case START_ARRAY: [EOL]         case START_OBJECT: [EOL]         case FIELD_NAME: [EOL]             return typeDeserializer.deserializeTypedFromAny(jp, ctxt); [EOL]         case VALUE_STRING: [EOL]             return jp.getText(); [EOL]         case VALUE_NUMBER_INT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return jp.getBigIntegerValue(); [EOL]             } [EOL]             return jp.getNumberValue(); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                 return jp.getDecimalValue(); [EOL]             } [EOL]             return Double.valueOf(jp.getDoubleValue()); [EOL]         case VALUE_TRUE: [EOL]             return Boolean.TRUE; [EOL]         case VALUE_FALSE: [EOL]             return Boolean.FALSE; [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_NULL: [EOL]             return null; [EOL]         default: [EOL]             throw ctxt.mappingException(Object.class); [EOL]     } [EOL] }
@Override [EOL] public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     switch(t) { [EOL]         case START_ARRAY: [EOL]         case START_OBJECT: [EOL]         case FIELD_NAME: [EOL]             return typeDeserializer.deserializeTypedFromAny(jp, ctxt); [EOL]         case VALUE_STRING: [EOL]             return jp.getText(); [EOL]         case VALUE_NUMBER_INT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return jp.getBigIntegerValue(); [EOL]             } [EOL]             return jp.getNumberValue(); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                 return jp.getDecimalValue(); [EOL]             } [EOL]             return Double.valueOf(jp.getDoubleValue()); [EOL]         case VALUE_TRUE: [EOL]             return Boolean.TRUE; [EOL]         case VALUE_FALSE: [EOL]             return Boolean.FALSE; [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_NULL: [EOL]             return null; [EOL]         default: [EOL]             throw ctxt.mappingException(Object.class); [EOL]     } [EOL] }
@Override [EOL] public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     switch(t) { [EOL]         case START_ARRAY: [EOL]         case START_OBJECT: [EOL]         case FIELD_NAME: [EOL]             return typeDeserializer.deserializeTypedFromAny(jp, ctxt); [EOL]         case VALUE_STRING: [EOL]             return jp.getText(); [EOL]         case VALUE_NUMBER_INT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return jp.getBigIntegerValue(); [EOL]             } [EOL]             return jp.getNumberValue(); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                 return jp.getDecimalValue(); [EOL]             } [EOL]             return Double.valueOf(jp.getDoubleValue()); [EOL]         case VALUE_TRUE: [EOL]             return Boolean.TRUE; [EOL]         case VALUE_FALSE: [EOL]             return Boolean.FALSE; [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_NULL: [EOL]             return null; [EOL]         default: [EOL]             throw ctxt.mappingException(Object.class); [EOL]     } [EOL] }
@Override [EOL] public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     switch(t) { [EOL]         case START_ARRAY: [EOL]         case START_OBJECT: [EOL]         case FIELD_NAME: [EOL]             return typeDeserializer.deserializeTypedFromAny(jp, ctxt); [EOL]         case VALUE_STRING: [EOL]             return jp.getText(); [EOL]         case VALUE_NUMBER_INT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return jp.getBigIntegerValue(); [EOL]             } [EOL]             return jp.getNumberValue(); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                 return jp.getDecimalValue(); [EOL]             } [EOL]             return Double.valueOf(jp.getDoubleValue()); [EOL]         case VALUE_TRUE: [EOL]             return Boolean.TRUE; [EOL]         case VALUE_FALSE: [EOL]             return Boolean.FALSE; [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_NULL: [EOL]             return null; [EOL]         default: [EOL]             throw ctxt.mappingException(Object.class); [EOL]     } [EOL] }
@Override [EOL] public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     switch(t) { [EOL]         case START_ARRAY: [EOL]         case START_OBJECT: [EOL]         case FIELD_NAME: [EOL]             return typeDeserializer.deserializeTypedFromAny(jp, ctxt); [EOL]         case VALUE_STRING: [EOL]             return jp.getText(); [EOL]         case VALUE_NUMBER_INT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return jp.getBigIntegerValue(); [EOL]             } [EOL]             return jp.getNumberValue(); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                 return jp.getDecimalValue(); [EOL]             } [EOL]             return Double.valueOf(jp.getDoubleValue()); [EOL]         case VALUE_TRUE: [EOL]             return Boolean.TRUE; [EOL]         case VALUE_FALSE: [EOL]             return Boolean.FALSE; [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_NULL: [EOL]             return null; [EOL]         default: [EOL]             throw ctxt.mappingException(Object.class); [EOL]     } [EOL] }
protected Object mapArray(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) { [EOL]         return mapArrayToArray(jp, ctxt); [EOL]     } [EOL]     if (jp.nextToken() == JsonToken.END_ARRAY) { [EOL]         return new ArrayList<Object>(4); [EOL]     } [EOL]     ObjectBuffer buffer = ctxt.leaseObjectBuffer(); [EOL]     Object[] values = buffer.resetAndStart(); [EOL]     int ptr = 0; [EOL]     int totalSize = 0; [EOL]     do { [EOL]         Object value = deserialize(jp, ctxt); [EOL]         ++totalSize; [EOL]         if (ptr >= values.length) { [EOL]             values = buffer.appendCompletedChunk(values); [EOL]             ptr = 0; [EOL]         } [EOL]         values[ptr++] = value; [EOL]     } while (jp.nextToken() != JsonToken.END_ARRAY); [EOL]     ArrayList<Object> result = new ArrayList<Object>(totalSize + (totalSize >> 3) + 1); [EOL]     buffer.completeAndClearBuffer(values, ptr, result); [EOL]     return result; [EOL] }
protected Object mapArray(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) { [EOL]         return mapArrayToArray(jp, ctxt); [EOL]     } [EOL]     if (jp.nextToken() == JsonToken.END_ARRAY) { [EOL]         return new ArrayList<Object>(4); [EOL]     } [EOL]     ObjectBuffer buffer = ctxt.leaseObjectBuffer(); [EOL]     Object[] values = buffer.resetAndStart(); [EOL]     int ptr = 0; [EOL]     int totalSize = 0; [EOL]     do { [EOL]         Object value = deserialize(jp, ctxt); [EOL]         ++totalSize; [EOL]         if (ptr >= values.length) { [EOL]             values = buffer.appendCompletedChunk(values); [EOL]             ptr = 0; [EOL]         } [EOL]         values[ptr++] = value; [EOL]     } while (jp.nextToken() != JsonToken.END_ARRAY); [EOL]     ArrayList<Object> result = new ArrayList<Object>(totalSize + (totalSize >> 3) + 1); [EOL]     buffer.completeAndClearBuffer(values, ptr, result); [EOL]     return result; [EOL] }
protected Object mapArray(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) { [EOL]         return mapArrayToArray(jp, ctxt); [EOL]     } [EOL]     if (jp.nextToken() == JsonToken.END_ARRAY) { [EOL]         return new ArrayList<Object>(4); [EOL]     } [EOL]     ObjectBuffer buffer = ctxt.leaseObjectBuffer(); [EOL]     Object[] values = buffer.resetAndStart(); [EOL]     int ptr = 0; [EOL]     int totalSize = 0; [EOL]     do { [EOL]         Object value = deserialize(jp, ctxt); [EOL]         ++totalSize; [EOL]         if (ptr >= values.length) { [EOL]             values = buffer.appendCompletedChunk(values); [EOL]             ptr = 0; [EOL]         } [EOL]         values[ptr++] = value; [EOL]     } while (jp.nextToken() != JsonToken.END_ARRAY); [EOL]     ArrayList<Object> result = new ArrayList<Object>(totalSize + (totalSize >> 3) + 1); [EOL]     buffer.completeAndClearBuffer(values, ptr, result); [EOL]     return result; [EOL] }
protected Object mapObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.START_OBJECT) { [EOL]         t = jp.nextToken(); [EOL]     } [EOL]     if (t != JsonToken.FIELD_NAME) { [EOL]         return new LinkedHashMap<String, Object>(4); [EOL]     } [EOL]     String field1 = jp.getText(); [EOL]     jp.nextToken(); [EOL]     Object value1 = deserialize(jp, ctxt); [EOL]     if (jp.nextToken() != JsonToken.FIELD_NAME) { [EOL]         LinkedHashMap<String, Object> result = new LinkedHashMap<String, Object>(4); [EOL]         result.put(field1, value1); [EOL]         return result; [EOL]     } [EOL]     String field2 = jp.getText(); [EOL]     jp.nextToken(); [EOL]     Object value2 = deserialize(jp, ctxt); [EOL]     if (jp.nextToken() != JsonToken.FIELD_NAME) { [EOL]         LinkedHashMap<String, Object> result = new LinkedHashMap<String, Object>(4); [EOL]         result.put(field1, value1); [EOL]         result.put(field2, value2); [EOL]         return result; [EOL]     } [EOL]     LinkedHashMap<String, Object> result = new LinkedHashMap<String, Object>(); [EOL]     result.put(field1, value1); [EOL]     result.put(field2, value2); [EOL]     do { [EOL]         String fieldName = jp.getText(); [EOL]         jp.nextToken(); [EOL]         result.put(fieldName, deserialize(jp, ctxt)); [EOL]     } while (jp.nextToken() != JsonToken.END_OBJECT); [EOL]     return result; [EOL] }
protected Object mapObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.START_OBJECT) { [EOL]         t = jp.nextToken(); [EOL]     } [EOL]     if (t != JsonToken.FIELD_NAME) { [EOL]         return new LinkedHashMap<String, Object>(4); [EOL]     } [EOL]     String field1 = jp.getText(); [EOL]     jp.nextToken(); [EOL]     Object value1 = deserialize(jp, ctxt); [EOL]     if (jp.nextToken() != JsonToken.FIELD_NAME) { [EOL]         LinkedHashMap<String, Object> result = new LinkedHashMap<String, Object>(4); [EOL]         result.put(field1, value1); [EOL]         return result; [EOL]     } [EOL]     String field2 = jp.getText(); [EOL]     jp.nextToken(); [EOL]     Object value2 = deserialize(jp, ctxt); [EOL]     if (jp.nextToken() != JsonToken.FIELD_NAME) { [EOL]         LinkedHashMap<String, Object> result = new LinkedHashMap<String, Object>(4); [EOL]         result.put(field1, value1); [EOL]         result.put(field2, value2); [EOL]         return result; [EOL]     } [EOL]     LinkedHashMap<String, Object> result = new LinkedHashMap<String, Object>(); [EOL]     result.put(field1, value1); [EOL]     result.put(field2, value2); [EOL]     do { [EOL]         String fieldName = jp.getText(); [EOL]         jp.nextToken(); [EOL]         result.put(fieldName, deserialize(jp, ctxt)); [EOL]     } while (jp.nextToken() != JsonToken.END_OBJECT); [EOL]     return result; [EOL] }
protected Object mapObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.START_OBJECT) { [EOL]         t = jp.nextToken(); [EOL]     } [EOL]     if (t != JsonToken.FIELD_NAME) { [EOL]         return new LinkedHashMap<String, Object>(4); [EOL]     } [EOL]     String field1 = jp.getText(); [EOL]     jp.nextToken(); [EOL]     Object value1 = deserialize(jp, ctxt); [EOL]     if (jp.nextToken() != JsonToken.FIELD_NAME) { [EOL]         LinkedHashMap<String, Object> result = new LinkedHashMap<String, Object>(4); [EOL]         result.put(field1, value1); [EOL]         return result; [EOL]     } [EOL]     String field2 = jp.getText(); [EOL]     jp.nextToken(); [EOL]     Object value2 = deserialize(jp, ctxt); [EOL]     if (jp.nextToken() != JsonToken.FIELD_NAME) { [EOL]         LinkedHashMap<String, Object> result = new LinkedHashMap<String, Object>(4); [EOL]         result.put(field1, value1); [EOL]         result.put(field2, value2); [EOL]         return result; [EOL]     } [EOL]     LinkedHashMap<String, Object> result = new LinkedHashMap<String, Object>(); [EOL]     result.put(field1, value1); [EOL]     result.put(field2, value2); [EOL]     do { [EOL]         String fieldName = jp.getText(); [EOL]         jp.nextToken(); [EOL]         result.put(fieldName, deserialize(jp, ctxt)); [EOL]     } while (jp.nextToken() != JsonToken.END_OBJECT); [EOL]     return result; [EOL] }
protected Object mapObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.START_OBJECT) { [EOL]         t = jp.nextToken(); [EOL]     } [EOL]     if (t != JsonToken.FIELD_NAME) { [EOL]         return new LinkedHashMap<String, Object>(4); [EOL]     } [EOL]     String field1 = jp.getText(); [EOL]     jp.nextToken(); [EOL]     Object value1 = deserialize(jp, ctxt); [EOL]     if (jp.nextToken() != JsonToken.FIELD_NAME) { [EOL]         LinkedHashMap<String, Object> result = new LinkedHashMap<String, Object>(4); [EOL]         result.put(field1, value1); [EOL]         return result; [EOL]     } [EOL]     String field2 = jp.getText(); [EOL]     jp.nextToken(); [EOL]     Object value2 = deserialize(jp, ctxt); [EOL]     if (jp.nextToken() != JsonToken.FIELD_NAME) { [EOL]         LinkedHashMap<String, Object> result = new LinkedHashMap<String, Object>(4); [EOL]         result.put(field1, value1); [EOL]         result.put(field2, value2); [EOL]         return result; [EOL]     } [EOL]     LinkedHashMap<String, Object> result = new LinkedHashMap<String, Object>(); [EOL]     result.put(field1, value1); [EOL]     result.put(field2, value2); [EOL]     do { [EOL]         String fieldName = jp.getText(); [EOL]         jp.nextToken(); [EOL]         result.put(fieldName, deserialize(jp, ctxt)); [EOL]     } while (jp.nextToken() != JsonToken.END_OBJECT); [EOL]     return result; [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (!_classNames.contains(clsName)) { [EOL]         return null; [EOL]     } [EOL]     if (rawType == Calendar.class) { [EOL]         return CalendarDeserializer.instance; [EOL]     } [EOL]     if (rawType == java.util.Date.class) { [EOL]         return DateDeserializer.instance; [EOL]     } [EOL]     if (rawType == java.sql.Date.class) { [EOL]         return SqlDateDeserializer.instance; [EOL]     } [EOL]     if (rawType == Timestamp.class) { [EOL]         return TimestampDeserializer.instance; [EOL]     } [EOL]     if (rawType == TimeZone.class) { [EOL]         return TimeZoneDeserializer.instance; [EOL]     } [EOL]     if (rawType == GregorianCalendar.class) { [EOL]         return CalendarDeserializer.gregorianInstance; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + clsName); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (!_classNames.contains(clsName)) { [EOL]         return null; [EOL]     } [EOL]     if (rawType == Calendar.class) { [EOL]         return CalendarDeserializer.instance; [EOL]     } [EOL]     if (rawType == java.util.Date.class) { [EOL]         return DateDeserializer.instance; [EOL]     } [EOL]     if (rawType == java.sql.Date.class) { [EOL]         return SqlDateDeserializer.instance; [EOL]     } [EOL]     if (rawType == Timestamp.class) { [EOL]         return TimestampDeserializer.instance; [EOL]     } [EOL]     if (rawType == TimeZone.class) { [EOL]         return TimeZoneDeserializer.instance; [EOL]     } [EOL]     if (rawType == GregorianCalendar.class) { [EOL]         return CalendarDeserializer.gregorianInstance; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + clsName); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (!_classNames.contains(clsName)) { [EOL]         return null; [EOL]     } [EOL]     if (rawType == Calendar.class) { [EOL]         return CalendarDeserializer.instance; [EOL]     } [EOL]     if (rawType == java.util.Date.class) { [EOL]         return DateDeserializer.instance; [EOL]     } [EOL]     if (rawType == java.sql.Date.class) { [EOL]         return SqlDateDeserializer.instance; [EOL]     } [EOL]     if (rawType == Timestamp.class) { [EOL]         return TimestampDeserializer.instance; [EOL]     } [EOL]     if (rawType == TimeZone.class) { [EOL]         return TimeZoneDeserializer.instance; [EOL]     } [EOL]     if (rawType == GregorianCalendar.class) { [EOL]         return CalendarDeserializer.gregorianInstance; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + clsName); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (!_classNames.contains(clsName)) { [EOL]         return null; [EOL]     } [EOL]     if (rawType == Calendar.class) { [EOL]         return CalendarDeserializer.instance; [EOL]     } [EOL]     if (rawType == java.util.Date.class) { [EOL]         return DateDeserializer.instance; [EOL]     } [EOL]     if (rawType == java.sql.Date.class) { [EOL]         return SqlDateDeserializer.instance; [EOL]     } [EOL]     if (rawType == Timestamp.class) { [EOL]         return TimestampDeserializer.instance; [EOL]     } [EOL]     if (rawType == TimeZone.class) { [EOL]         return TimeZoneDeserializer.instance; [EOL]     } [EOL]     if (rawType == GregorianCalendar.class) { [EOL]         return CalendarDeserializer.gregorianInstance; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + clsName); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (!_classNames.contains(clsName)) { [EOL]         return null; [EOL]     } [EOL]     if (rawType == Calendar.class) { [EOL]         return CalendarDeserializer.instance; [EOL]     } [EOL]     if (rawType == java.util.Date.class) { [EOL]         return DateDeserializer.instance; [EOL]     } [EOL]     if (rawType == java.sql.Date.class) { [EOL]         return SqlDateDeserializer.instance; [EOL]     } [EOL]     if (rawType == Timestamp.class) { [EOL]         return TimestampDeserializer.instance; [EOL]     } [EOL]     if (rawType == TimeZone.class) { [EOL]         return TimeZoneDeserializer.instance; [EOL]     } [EOL]     if (rawType == GregorianCalendar.class) { [EOL]         return CalendarDeserializer.gregorianInstance; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + clsName); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (!_classNames.contains(clsName)) { [EOL]         return null; [EOL]     } [EOL]     if (rawType == Calendar.class) { [EOL]         return CalendarDeserializer.instance; [EOL]     } [EOL]     if (rawType == java.util.Date.class) { [EOL]         return DateDeserializer.instance; [EOL]     } [EOL]     if (rawType == java.sql.Date.class) { [EOL]         return SqlDateDeserializer.instance; [EOL]     } [EOL]     if (rawType == Timestamp.class) { [EOL]         return TimestampDeserializer.instance; [EOL]     } [EOL]     if (rawType == TimeZone.class) { [EOL]         return TimeZoneDeserializer.instance; [EOL]     } [EOL]     if (rawType == GregorianCalendar.class) { [EOL]         return CalendarDeserializer.gregorianInstance; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + clsName); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (!_classNames.contains(clsName)) { [EOL]         return null; [EOL]     } [EOL]     if (rawType == Calendar.class) { [EOL]         return CalendarDeserializer.instance; [EOL]     } [EOL]     if (rawType == java.util.Date.class) { [EOL]         return DateDeserializer.instance; [EOL]     } [EOL]     if (rawType == java.sql.Date.class) { [EOL]         return SqlDateDeserializer.instance; [EOL]     } [EOL]     if (rawType == Timestamp.class) { [EOL]         return TimestampDeserializer.instance; [EOL]     } [EOL]     if (rawType == TimeZone.class) { [EOL]         return TimeZoneDeserializer.instance; [EOL]     } [EOL]     if (rawType == GregorianCalendar.class) { [EOL]         return CalendarDeserializer.gregorianInstance; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + clsName); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (!_classNames.contains(clsName)) { [EOL]         return null; [EOL]     } [EOL]     if (rawType == Calendar.class) { [EOL]         return CalendarDeserializer.instance; [EOL]     } [EOL]     if (rawType == java.util.Date.class) { [EOL]         return DateDeserializer.instance; [EOL]     } [EOL]     if (rawType == java.sql.Date.class) { [EOL]         return SqlDateDeserializer.instance; [EOL]     } [EOL]     if (rawType == Timestamp.class) { [EOL]         return TimestampDeserializer.instance; [EOL]     } [EOL]     if (rawType == TimeZone.class) { [EOL]         return TimeZoneDeserializer.instance; [EOL]     } [EOL]     if (rawType == GregorianCalendar.class) { [EOL]         return CalendarDeserializer.gregorianInstance; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + clsName); [EOL] }
protected DateBasedDeserializer(Class<?> clz) { [EOL]     super(clz); [EOL]     _customFormat = null; [EOL]     _formatString = null; [EOL] }
@Override [EOL] public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException { [EOL]     if (property != null) { [EOL]         JsonFormat.Value format = ctxt.getAnnotationIntrospector().findFormat((Annotated) property.getMember()); [EOL]         if (format != null) { [EOL]             TimeZone tz = format.getTimeZone(); [EOL]             String pattern = format.getPattern(); [EOL]             if (pattern.length() > 0) { [EOL]                 Locale loc = format.getLocale(); [EOL]                 if (loc == null) { [EOL]                     loc = ctxt.getLocale(); [EOL]                 } [EOL]                 SimpleDateFormat df = new SimpleDateFormat(pattern, loc); [EOL]                 if (tz == null) { [EOL]                     tz = ctxt.getTimeZone(); [EOL]                 } [EOL]                 df.setTimeZone(tz); [EOL]                 return withDateFormat(df, pattern); [EOL]             } [EOL]             if (tz != null) { [EOL]                 DateFormat df = ctxt.getConfig().getDateFormat(); [EOL]                 if (df.getClass() == StdDateFormat.class) { [EOL]                     df = ((StdDateFormat) df).withTimeZone(tz); [EOL]                 } else { [EOL]                     df = (DateFormat) df.clone(); [EOL]                     df.setTimeZone(tz); [EOL]                 } [EOL]                 return withDateFormat(df, pattern); [EOL]             } [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException { [EOL]     if (property != null) { [EOL]         JsonFormat.Value format = ctxt.getAnnotationIntrospector().findFormat((Annotated) property.getMember()); [EOL]         if (format != null) { [EOL]             TimeZone tz = format.getTimeZone(); [EOL]             String pattern = format.getPattern(); [EOL]             if (pattern.length() > 0) { [EOL]                 Locale loc = format.getLocale(); [EOL]                 if (loc == null) { [EOL]                     loc = ctxt.getLocale(); [EOL]                 } [EOL]                 SimpleDateFormat df = new SimpleDateFormat(pattern, loc); [EOL]                 if (tz == null) { [EOL]                     tz = ctxt.getTimeZone(); [EOL]                 } [EOL]                 df.setTimeZone(tz); [EOL]                 return withDateFormat(df, pattern); [EOL]             } [EOL]             if (tz != null) { [EOL]                 DateFormat df = ctxt.getConfig().getDateFormat(); [EOL]                 if (df.getClass() == StdDateFormat.class) { [EOL]                     df = ((StdDateFormat) df).withTimeZone(tz); [EOL]                 } else { [EOL]                     df = (DateFormat) df.clone(); [EOL]                     df.setTimeZone(tz); [EOL]                 } [EOL]                 return withDateFormat(df, pattern); [EOL]             } [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException { [EOL]     if (property != null) { [EOL]         JsonFormat.Value format = ctxt.getAnnotationIntrospector().findFormat((Annotated) property.getMember()); [EOL]         if (format != null) { [EOL]             TimeZone tz = format.getTimeZone(); [EOL]             String pattern = format.getPattern(); [EOL]             if (pattern.length() > 0) { [EOL]                 Locale loc = format.getLocale(); [EOL]                 if (loc == null) { [EOL]                     loc = ctxt.getLocale(); [EOL]                 } [EOL]                 SimpleDateFormat df = new SimpleDateFormat(pattern, loc); [EOL]                 if (tz == null) { [EOL]                     tz = ctxt.getTimeZone(); [EOL]                 } [EOL]                 df.setTimeZone(tz); [EOL]                 return withDateFormat(df, pattern); [EOL]             } [EOL]             if (tz != null) { [EOL]                 DateFormat df = ctxt.getConfig().getDateFormat(); [EOL]                 if (df.getClass() == StdDateFormat.class) { [EOL]                     df = ((StdDateFormat) df).withTimeZone(tz); [EOL]                 } else { [EOL]                     df = (DateFormat) df.clone(); [EOL]                     df.setTimeZone(tz); [EOL]                 } [EOL]                 return withDateFormat(df, pattern); [EOL]             } [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException { [EOL]     if (property != null) { [EOL]         JsonFormat.Value format = ctxt.getAnnotationIntrospector().findFormat((Annotated) property.getMember()); [EOL]         if (format != null) { [EOL]             TimeZone tz = format.getTimeZone(); [EOL]             String pattern = format.getPattern(); [EOL]             if (pattern.length() > 0) { [EOL]                 Locale loc = format.getLocale(); [EOL]                 if (loc == null) { [EOL]                     loc = ctxt.getLocale(); [EOL]                 } [EOL]                 SimpleDateFormat df = new SimpleDateFormat(pattern, loc); [EOL]                 if (tz == null) { [EOL]                     tz = ctxt.getTimeZone(); [EOL]                 } [EOL]                 df.setTimeZone(tz); [EOL]                 return withDateFormat(df, pattern); [EOL]             } [EOL]             if (tz != null) { [EOL]                 DateFormat df = ctxt.getConfig().getDateFormat(); [EOL]                 if (df.getClass() == StdDateFormat.class) { [EOL]                     df = ((StdDateFormat) df).withTimeZone(tz); [EOL]                 } else { [EOL]                     df = (DateFormat) df.clone(); [EOL]                     df.setTimeZone(tz); [EOL]                 } [EOL]                 return withDateFormat(df, pattern); [EOL]             } [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException { [EOL]     if (property != null) { [EOL]         JsonFormat.Value format = ctxt.getAnnotationIntrospector().findFormat((Annotated) property.getMember()); [EOL]         if (format != null) { [EOL]             TimeZone tz = format.getTimeZone(); [EOL]             String pattern = format.getPattern(); [EOL]             if (pattern.length() > 0) { [EOL]                 Locale loc = format.getLocale(); [EOL]                 if (loc == null) { [EOL]                     loc = ctxt.getLocale(); [EOL]                 } [EOL]                 SimpleDateFormat df = new SimpleDateFormat(pattern, loc); [EOL]                 if (tz == null) { [EOL]                     tz = ctxt.getTimeZone(); [EOL]                 } [EOL]                 df.setTimeZone(tz); [EOL]                 return withDateFormat(df, pattern); [EOL]             } [EOL]             if (tz != null) { [EOL]                 DateFormat df = ctxt.getConfig().getDateFormat(); [EOL]                 if (df.getClass() == StdDateFormat.class) { [EOL]                     df = ((StdDateFormat) df).withTimeZone(tz); [EOL]                 } else { [EOL]                     df = (DateFormat) df.clone(); [EOL]                     df.setTimeZone(tz); [EOL]                 } [EOL]                 return withDateFormat(df, pattern); [EOL]             } [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] protected java.util.Date _parseDate(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_customFormat != null && jp.getCurrentToken() == JsonToken.VALUE_STRING) { [EOL]         String str = jp.getText().trim(); [EOL]         if (str.length() == 0) { [EOL]             return (Date) getEmptyValue(); [EOL]         } [EOL]         synchronized (_customFormat) { [EOL]             try { [EOL]                 return _customFormat.parse(str); [EOL]             } catch (ParseException e) { [EOL]                 throw new IllegalArgumentException("Failed to parse Date value '" + str + "' (format: \"" + _formatString + "\"): " + e.getMessage()); [EOL]             } [EOL]         } [EOL]     } [EOL]     return super._parseDate(jp, ctxt); [EOL] }
@Override [EOL] protected java.util.Date _parseDate(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_customFormat != null && jp.getCurrentToken() == JsonToken.VALUE_STRING) { [EOL]         String str = jp.getText().trim(); [EOL]         if (str.length() == 0) { [EOL]             return (Date) getEmptyValue(); [EOL]         } [EOL]         synchronized (_customFormat) { [EOL]             try { [EOL]                 return _customFormat.parse(str); [EOL]             } catch (ParseException e) { [EOL]                 throw new IllegalArgumentException("Failed to parse Date value '" + str + "' (format: \"" + _formatString + "\"): " + e.getMessage()); [EOL]             } [EOL]         } [EOL]     } [EOL]     return super._parseDate(jp, ctxt); [EOL] }
@Override [EOL] protected java.util.Date _parseDate(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_customFormat != null && jp.getCurrentToken() == JsonToken.VALUE_STRING) { [EOL]         String str = jp.getText().trim(); [EOL]         if (str.length() == 0) { [EOL]             return (Date) getEmptyValue(); [EOL]         } [EOL]         synchronized (_customFormat) { [EOL]             try { [EOL]                 return _customFormat.parse(str); [EOL]             } catch (ParseException e) { [EOL]                 throw new IllegalArgumentException("Failed to parse Date value '" + str + "' (format: \"" + _formatString + "\"): " + e.getMessage()); [EOL]             } [EOL]         } [EOL]     } [EOL]     return super._parseDate(jp, ctxt); [EOL] }
@Override [EOL] protected java.util.Date _parseDate(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_customFormat != null && jp.getCurrentToken() == JsonToken.VALUE_STRING) { [EOL]         String str = jp.getText().trim(); [EOL]         if (str.length() == 0) { [EOL]             return (Date) getEmptyValue(); [EOL]         } [EOL]         synchronized (_customFormat) { [EOL]             try { [EOL]                 return _customFormat.parse(str); [EOL]             } catch (ParseException e) { [EOL]                 throw new IllegalArgumentException("Failed to parse Date value '" + str + "' (format: \"" + _formatString + "\"): " + e.getMessage()); [EOL]             } [EOL]         } [EOL]     } [EOL]     return super._parseDate(jp, ctxt); [EOL] }
public CalendarDeserializer() { [EOL]     super(Calendar.class); [EOL]     _calendarClass = null; [EOL] }
public CalendarDeserializer(Class<? extends Calendar> cc) { [EOL]     super(cc); [EOL]     _calendarClass = cc; [EOL] }
public CalendarDeserializer(Class<? extends Calendar> cc) { [EOL]     super(cc); [EOL]     _calendarClass = cc; [EOL] }
@Override [EOL] public Calendar deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     Date d = _parseDate(jp, ctxt); [EOL]     if (d == null) { [EOL]         return null; [EOL]     } [EOL]     if (_calendarClass == null) { [EOL]         return ctxt.constructCalendar(d); [EOL]     } [EOL]     try { [EOL]         Calendar c = _calendarClass.newInstance(); [EOL]         c.setTimeInMillis(d.getTime()); [EOL]         TimeZone tz = ctxt.getTimeZone(); [EOL]         if (tz != null) { [EOL]             c.setTimeZone(tz); [EOL]         } [EOL]         return c; [EOL]     } catch (Exception e) { [EOL]         throw ctxt.instantiationException(_calendarClass, e); [EOL]     } [EOL] }
@Override [EOL] public Calendar deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     Date d = _parseDate(jp, ctxt); [EOL]     if (d == null) { [EOL]         return null; [EOL]     } [EOL]     if (_calendarClass == null) { [EOL]         return ctxt.constructCalendar(d); [EOL]     } [EOL]     try { [EOL]         Calendar c = _calendarClass.newInstance(); [EOL]         c.setTimeInMillis(d.getTime()); [EOL]         TimeZone tz = ctxt.getTimeZone(); [EOL]         if (tz != null) { [EOL]             c.setTimeZone(tz); [EOL]         } [EOL]         return c; [EOL]     } catch (Exception e) { [EOL]         throw ctxt.instantiationException(_calendarClass, e); [EOL]     } [EOL] }
@Override [EOL] public Calendar deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     Date d = _parseDate(jp, ctxt); [EOL]     if (d == null) { [EOL]         return null; [EOL]     } [EOL]     if (_calendarClass == null) { [EOL]         return ctxt.constructCalendar(d); [EOL]     } [EOL]     try { [EOL]         Calendar c = _calendarClass.newInstance(); [EOL]         c.setTimeInMillis(d.getTime()); [EOL]         TimeZone tz = ctxt.getTimeZone(); [EOL]         if (tz != null) { [EOL]             c.setTimeZone(tz); [EOL]         } [EOL]         return c; [EOL]     } catch (Exception e) { [EOL]         throw ctxt.instantiationException(_calendarClass, e); [EOL]     } [EOL] }
@Override [EOL] public Calendar deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     Date d = _parseDate(jp, ctxt); [EOL]     if (d == null) { [EOL]         return null; [EOL]     } [EOL]     if (_calendarClass == null) { [EOL]         return ctxt.constructCalendar(d); [EOL]     } [EOL]     try { [EOL]         Calendar c = _calendarClass.newInstance(); [EOL]         c.setTimeInMillis(d.getTime()); [EOL]         TimeZone tz = ctxt.getTimeZone(); [EOL]         if (tz != null) { [EOL]             c.setTimeZone(tz); [EOL]         } [EOL]         return c; [EOL]     } catch (Exception e) { [EOL]         throw ctxt.instantiationException(_calendarClass, e); [EOL]     } [EOL] }
public SqlDateDeserializer() { [EOL]     super(java.sql.Date.class); [EOL] }
@Override [EOL] public java.sql.Date deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     Date d = _parseDate(jp, ctxt); [EOL]     return (d == null) ? null : new java.sql.Date(d.getTime()); [EOL] }
@Override [EOL] public java.sql.Date deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     Date d = _parseDate(jp, ctxt); [EOL]     return (d == null) ? null : new java.sql.Date(d.getTime()); [EOL] }
@Override [EOL] public Class<?> getRawType() { [EOL]     return _method.getReturnType(); [EOL] }
@Override [EOL] public final Object call(Object[] args) throws Exception { [EOL]     return _method.invoke(null, args); [EOL] }
@Override [EOL] public final Object call(Object[] args) throws Exception { [EOL]     return _method.invoke(null, args); [EOL] }
@Override [EOL] public final Object call(Object[] args) throws Exception { [EOL]     return _method.invoke(null, args); [EOL] }
@Override [EOL] public JsonParser skipChildren() throws IOException, JsonParseException { [EOL]     if (_currToken == JsonToken.START_OBJECT) { [EOL]         _startContainer = false; [EOL]         _currToken = JsonToken.END_OBJECT; [EOL]     } else if (_currToken == JsonToken.START_ARRAY) { [EOL]         _startContainer = false; [EOL]         _currToken = JsonToken.END_ARRAY; [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public JsonParser skipChildren() throws IOException, JsonParseException { [EOL]     if (_currToken == JsonToken.START_OBJECT) { [EOL]         _startContainer = false; [EOL]         _currToken = JsonToken.END_OBJECT; [EOL]     } else if (_currToken == JsonToken.START_ARRAY) { [EOL]         _startContainer = false; [EOL]         _currToken = JsonToken.END_ARRAY; [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public JsonParser skipChildren() throws IOException, JsonParseException { [EOL]     if (_currToken == JsonToken.START_OBJECT) { [EOL]         _startContainer = false; [EOL]         _currToken = JsonToken.END_OBJECT; [EOL]     } else if (_currToken == JsonToken.START_ARRAY) { [EOL]         _startContainer = false; [EOL]         _currToken = JsonToken.END_ARRAY; [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public String getCurrentName() { [EOL]     return (_nodeCursor == null) ? null : _nodeCursor.getCurrentName(); [EOL] }
@Override [EOL] public String getCurrentName() { [EOL]     return (_nodeCursor == null) ? null : _nodeCursor.getCurrentName(); [EOL] }
@Override [EOL] public String getText() { [EOL]     if (_closed) { [EOL]         return null; [EOL]     } [EOL]     switch(_currToken) { [EOL]         case FIELD_NAME: [EOL]             return _nodeCursor.getCurrentName(); [EOL]         case VALUE_STRING: [EOL]             return currentNode().textValue(); [EOL]         case VALUE_NUMBER_INT: [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             return String.valueOf(currentNode().numberValue()); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             JsonNode n = currentNode(); [EOL]             if (n != null && n.isBinary()) { [EOL]                 return n.asText(); [EOL]             } [EOL]         default: [EOL]             return (_currToken == null) ? null : _currToken.asString(); [EOL]     } [EOL] }
@Override [EOL] public String getText() { [EOL]     if (_closed) { [EOL]         return null; [EOL]     } [EOL]     switch(_currToken) { [EOL]         case FIELD_NAME: [EOL]             return _nodeCursor.getCurrentName(); [EOL]         case VALUE_STRING: [EOL]             return currentNode().textValue(); [EOL]         case VALUE_NUMBER_INT: [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             return String.valueOf(currentNode().numberValue()); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             JsonNode n = currentNode(); [EOL]             if (n != null && n.isBinary()) { [EOL]                 return n.asText(); [EOL]             } [EOL]         default: [EOL]             return (_currToken == null) ? null : _currToken.asString(); [EOL]     } [EOL] }
@Override [EOL] public String getText() { [EOL]     if (_closed) { [EOL]         return null; [EOL]     } [EOL]     switch(_currToken) { [EOL]         case FIELD_NAME: [EOL]             return _nodeCursor.getCurrentName(); [EOL]         case VALUE_STRING: [EOL]             return currentNode().textValue(); [EOL]         case VALUE_NUMBER_INT: [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             return String.valueOf(currentNode().numberValue()); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             JsonNode n = currentNode(); [EOL]             if (n != null && n.isBinary()) { [EOL]                 return n.asText(); [EOL]             } [EOL]         default: [EOL]             return (_currToken == null) ? null : _currToken.asString(); [EOL]     } [EOL] }
@Override [EOL] public String getText() { [EOL]     if (_closed) { [EOL]         return null; [EOL]     } [EOL]     switch(_currToken) { [EOL]         case FIELD_NAME: [EOL]             return _nodeCursor.getCurrentName(); [EOL]         case VALUE_STRING: [EOL]             return currentNode().textValue(); [EOL]         case VALUE_NUMBER_INT: [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             return String.valueOf(currentNode().numberValue()); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             JsonNode n = currentNode(); [EOL]             if (n != null && n.isBinary()) { [EOL]                 return n.asText(); [EOL]             } [EOL]         default: [EOL]             return (_currToken == null) ? null : _currToken.asString(); [EOL]     } [EOL] }
@Override [EOL] public String getText() { [EOL]     if (_closed) { [EOL]         return null; [EOL]     } [EOL]     switch(_currToken) { [EOL]         case FIELD_NAME: [EOL]             return _nodeCursor.getCurrentName(); [EOL]         case VALUE_STRING: [EOL]             return currentNode().textValue(); [EOL]         case VALUE_NUMBER_INT: [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             return String.valueOf(currentNode().numberValue()); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             JsonNode n = currentNode(); [EOL]             if (n != null && n.isBinary()) { [EOL]                 return n.asText(); [EOL]             } [EOL]         default: [EOL]             return (_currToken == null) ? null : _currToken.asString(); [EOL]     } [EOL] }
@Override [EOL] public String getText() { [EOL]     if (_closed) { [EOL]         return null; [EOL]     } [EOL]     switch(_currToken) { [EOL]         case FIELD_NAME: [EOL]             return _nodeCursor.getCurrentName(); [EOL]         case VALUE_STRING: [EOL]             return currentNode().textValue(); [EOL]         case VALUE_NUMBER_INT: [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             return String.valueOf(currentNode().numberValue()); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             JsonNode n = currentNode(); [EOL]             if (n != null && n.isBinary()) { [EOL]                 return n.asText(); [EOL]             } [EOL]         default: [EOL]             return (_currToken == null) ? null : _currToken.asString(); [EOL]     } [EOL] }
@Override [EOL] public String getText() { [EOL]     if (_closed) { [EOL]         return null; [EOL]     } [EOL]     switch(_currToken) { [EOL]         case FIELD_NAME: [EOL]             return _nodeCursor.getCurrentName(); [EOL]         case VALUE_STRING: [EOL]             return currentNode().textValue(); [EOL]         case VALUE_NUMBER_INT: [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             return String.valueOf(currentNode().numberValue()); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             JsonNode n = currentNode(); [EOL]             if (n != null && n.isBinary()) { [EOL]                 return n.asText(); [EOL]             } [EOL]         default: [EOL]             return (_currToken == null) ? null : _currToken.asString(); [EOL]     } [EOL] }
@Override [EOL] public String getText() { [EOL]     if (_closed) { [EOL]         return null; [EOL]     } [EOL]     switch(_currToken) { [EOL]         case FIELD_NAME: [EOL]             return _nodeCursor.getCurrentName(); [EOL]         case VALUE_STRING: [EOL]             return currentNode().textValue(); [EOL]         case VALUE_NUMBER_INT: [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             return String.valueOf(currentNode().numberValue()); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             JsonNode n = currentNode(); [EOL]             if (n != null && n.isBinary()) { [EOL]                 return n.asText(); [EOL]             } [EOL]         default: [EOL]             return (_currToken == null) ? null : _currToken.asString(); [EOL]     } [EOL] }
@Override [EOL] public String getText() { [EOL]     if (_closed) { [EOL]         return null; [EOL]     } [EOL]     switch(_currToken) { [EOL]         case FIELD_NAME: [EOL]             return _nodeCursor.getCurrentName(); [EOL]         case VALUE_STRING: [EOL]             return currentNode().textValue(); [EOL]         case VALUE_NUMBER_INT: [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             return String.valueOf(currentNode().numberValue()); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             JsonNode n = currentNode(); [EOL]             if (n != null && n.isBinary()) { [EOL]                 return n.asText(); [EOL]             } [EOL]         default: [EOL]             return (_currToken == null) ? null : _currToken.asString(); [EOL]     } [EOL] }
@Override [EOL] public int getIntValue() throws IOException, JsonParseException { [EOL]     return currentNumericNode().intValue(); [EOL] }
@Override [EOL] public int getIntValue() throws IOException, JsonParseException { [EOL]     return currentNumericNode().intValue(); [EOL] }
protected JsonNode currentNumericNode() throws JsonParseException { [EOL]     JsonNode n = currentNode(); [EOL]     if (n == null || !n.isNumber()) { [EOL]         JsonToken t = (n == null) ? null : n.asToken(); [EOL]         throw _constructError("Current token (" + t + ") not numeric, can not use numeric value accessors"); [EOL]     } [EOL]     return n; [EOL] }
protected JsonNode currentNumericNode() throws JsonParseException { [EOL]     JsonNode n = currentNode(); [EOL]     if (n == null || !n.isNumber()) { [EOL]         JsonToken t = (n == null) ? null : n.asToken(); [EOL]         throw _constructError("Current token (" + t + ") not numeric, can not use numeric value accessors"); [EOL]     } [EOL]     return n; [EOL] }
protected JsonNode currentNumericNode() throws JsonParseException { [EOL]     JsonNode n = currentNode(); [EOL]     if (n == null || !n.isNumber()) { [EOL]         JsonToken t = (n == null) ? null : n.asToken(); [EOL]         throw _constructError("Current token (" + t + ") not numeric, can not use numeric value accessors"); [EOL]     } [EOL]     return n; [EOL] }
@Override [EOL] public final void serializeWithType(T value, JsonGenerator jgen, SerializerProvider provider, TypeSerializer typeSer) throws IOException, JsonGenerationException { [EOL]     typeSer.writeTypePrefixForArray(value, jgen); [EOL]     serializeContents(value, jgen, provider); [EOL]     typeSer.writeTypeSuffixForArray(value, jgen); [EOL] }
@Override [EOL] public final void serializeWithType(T value, JsonGenerator jgen, SerializerProvider provider, TypeSerializer typeSer) throws IOException, JsonGenerationException { [EOL]     typeSer.writeTypePrefixForArray(value, jgen); [EOL]     serializeContents(value, jgen, provider); [EOL]     typeSer.writeTypeSuffixForArray(value, jgen); [EOL] }
@Override [EOL] public void serialize(TimeZone value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     jgen.writeString(value.getID()); [EOL] }
public JsonSerializer<?> build() { [EOL]     BeanPropertyWriter[] properties; [EOL]     if (_properties == null || _properties.isEmpty()) { [EOL]         if (_anyGetter == null) { [EOL]             return null; [EOL]         } [EOL]         properties = NO_PROPERTIES; [EOL]     } else { [EOL]         properties = _properties.toArray(new BeanPropertyWriter[_properties.size()]); [EOL]     } [EOL]     return new BeanSerializer(_beanDesc.getType(), this, properties, _filteredProperties); [EOL] }
public JsonSerializer<?> build() { [EOL]     BeanPropertyWriter[] properties; [EOL]     if (_properties == null || _properties.isEmpty()) { [EOL]         if (_anyGetter == null) { [EOL]             return null; [EOL]         } [EOL]         properties = NO_PROPERTIES; [EOL]     } else { [EOL]         properties = _properties.toArray(new BeanPropertyWriter[_properties.size()]); [EOL]     } [EOL]     return new BeanSerializer(_beanDesc.getType(), this, properties, _filteredProperties); [EOL] }
public JsonSerializer<?> build() { [EOL]     BeanPropertyWriter[] properties; [EOL]     if (_properties == null || _properties.isEmpty()) { [EOL]         if (_anyGetter == null) { [EOL]             return null; [EOL]         } [EOL]         properties = NO_PROPERTIES; [EOL]     } else { [EOL]         properties = _properties.toArray(new BeanPropertyWriter[_properties.size()]); [EOL]     } [EOL]     return new BeanSerializer(_beanDesc.getType(), this, properties, _filteredProperties); [EOL] }
public BeanSerializer createDummy() { [EOL]     return BeanSerializer.createDummy(_beanDesc.getType()); [EOL] }
public BeanSerializer createDummy() { [EOL]     return BeanSerializer.createDummy(_beanDesc.getType()); [EOL] }
protected ClassIntrospector() { [EOL] }
@Override [EOL] public Object deserializeTypedFromArray(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     return _deserialize(jp, ctxt); [EOL] }
@Override [EOL] public Object deserializeTypedFromArray(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     return _deserialize(jp, ctxt); [EOL] }
@Override [EOL] public Object deserializeTypedFromArray(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     return _deserialize(jp, ctxt); [EOL] }
public NullNode nullNode() { [EOL]     return NullNode.getInstance(); [EOL] }
public NumericNode numberNode(float v) { [EOL]     return FloatNode.valueOf((float) v); [EOL] }
public NumericNode numberNode(float v) { [EOL]     return FloatNode.valueOf((float) v); [EOL] }
public NumericNode numberNode(float v) { [EOL]     return FloatNode.valueOf((float) v); [EOL] }
private SimpleBeanPropertyDefinition(AnnotatedMember member, String name, AnnotationIntrospector intr) { [EOL]     _introspector = intr; [EOL]     _member = member; [EOL]     _name = name; [EOL] }
private SimpleBeanPropertyDefinition(AnnotatedMember member, String name, AnnotationIntrospector intr) { [EOL]     _introspector = intr; [EOL]     _member = member; [EOL]     _name = name; [EOL] }
public static SimpleBeanPropertyDefinition construct(MapperConfig<?> config, AnnotatedMember member) { [EOL]     return new SimpleBeanPropertyDefinition(member, member.getName(), (config == null) ? null : config.getAnnotationIntrospector()); [EOL] }
public static SimpleBeanPropertyDefinition construct(MapperConfig<?> config, AnnotatedMember member) { [EOL]     return new SimpleBeanPropertyDefinition(member, member.getName(), (config == null) ? null : config.getAnnotationIntrospector()); [EOL] }
public static SimpleBeanPropertyDefinition construct(MapperConfig<?> config, AnnotatedMember member, String name) { [EOL]     return new SimpleBeanPropertyDefinition(member, name, (config == null) ? null : config.getAnnotationIntrospector()); [EOL] }
public static SimpleBeanPropertyDefinition construct(MapperConfig<?> config, AnnotatedMember member, String name) { [EOL]     return new SimpleBeanPropertyDefinition(member, name, (config == null) ? null : config.getAnnotationIntrospector()); [EOL] }
@Override [EOL] public String getName() { [EOL]     return _name; [EOL] }
@Override [EOL] public PropertyName getWrapperName() { [EOL]     return (_introspector == null) ? null : _introspector.findWrapperName(_member); [EOL] }
@Override [EOL] public PropertyName getWrapperName() { [EOL]     return (_introspector == null) ? null : _introspector.findWrapperName(_member); [EOL] }
@Override [EOL] public AnnotatedMethod getSetter() { [EOL]     if ((_member instanceof AnnotatedMethod) && ((AnnotatedMethod) _member).getParameterCount() == 1) { [EOL]         return (AnnotatedMethod) _member; [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public AnnotatedMethod getSetter() { [EOL]     if ((_member instanceof AnnotatedMethod) && ((AnnotatedMethod) _member).getParameterCount() == 1) { [EOL]         return (AnnotatedMethod) _member; [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public AnnotatedMethod getSetter() { [EOL]     if ((_member instanceof AnnotatedMethod) && ((AnnotatedMethod) _member).getParameterCount() == 1) { [EOL]         return (AnnotatedMethod) _member; [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public AnnotatedField getField() { [EOL]     return (_member instanceof AnnotatedField) ? (AnnotatedField) _member : null; [EOL] }
@Override [EOL] public AnnotatedField getField() { [EOL]     return (_member instanceof AnnotatedField) ? (AnnotatedField) _member : null; [EOL] }
@Override [EOL] public AnnotatedParameter getConstructorParameter() { [EOL]     return (_member instanceof AnnotatedParameter) ? (AnnotatedParameter) _member : null; [EOL] }
@Override [EOL] public AnnotatedParameter getConstructorParameter() { [EOL]     return (_member instanceof AnnotatedParameter) ? (AnnotatedParameter) _member : null; [EOL] }
@Override [EOL] public AnnotatedMember getMutator() { [EOL]     AnnotatedMember acc = getConstructorParameter(); [EOL]     if (acc == null) { [EOL]         acc = getSetter(); [EOL]         if (acc == null) { [EOL]             acc = getField(); [EOL]         } [EOL]     } [EOL]     return acc; [EOL] }
@Override [EOL] public AnnotatedMember getMutator() { [EOL]     AnnotatedMember acc = getConstructorParameter(); [EOL]     if (acc == null) { [EOL]         acc = getSetter(); [EOL]         if (acc == null) { [EOL]             acc = getField(); [EOL]         } [EOL]     } [EOL]     return acc; [EOL] }
@Override [EOL] public AnnotatedMember getMutator() { [EOL]     AnnotatedMember acc = getConstructorParameter(); [EOL]     if (acc == null) { [EOL]         acc = getSetter(); [EOL]         if (acc == null) { [EOL]             acc = getField(); [EOL]         } [EOL]     } [EOL]     return acc; [EOL] }
@Override [EOL] public AnnotatedMember getMutator() { [EOL]     AnnotatedMember acc = getConstructorParameter(); [EOL]     if (acc == null) { [EOL]         acc = getSetter(); [EOL]         if (acc == null) { [EOL]             acc = getField(); [EOL]         } [EOL]     } [EOL]     return acc; [EOL] }
@Override [EOL] public JsonNode getSchema(SerializerProvider provider, Type typeHint, boolean isOptional) throws JsonMappingException { [EOL]     ObjectNode schema = (ObjectNode) getSchema(provider, typeHint); [EOL]     if (!isOptional) { [EOL]         schema.put("required", !isOptional); [EOL]     } [EOL]     return schema; [EOL] }
@Override [EOL] public JsonNode getSchema(SerializerProvider provider, Type typeHint, boolean isOptional) throws JsonMappingException { [EOL]     ObjectNode schema = (ObjectNode) getSchema(provider, typeHint); [EOL]     if (!isOptional) { [EOL]         schema.put("required", !isOptional); [EOL]     } [EOL]     return schema; [EOL] }
protected ObjectNode createObjectNode() { [EOL]     return JsonNodeFactory.instance.objectNode(); [EOL] }
protected ObjectNode createSchemaNode(String type) { [EOL]     ObjectNode schema = createObjectNode(); [EOL]     schema.put("type", type); [EOL]     return schema; [EOL] }
protected ObjectNode createSchemaNode(String type) { [EOL]     ObjectNode schema = createObjectNode(); [EOL]     schema.put("type", type); [EOL]     return schema; [EOL] }
protected ObjectNode createSchemaNode(String type, boolean isOptional) { [EOL]     ObjectNode schema = createSchemaNode(type); [EOL]     if (!isOptional) { [EOL]         schema.put("required", !isOptional); [EOL]     } [EOL]     return schema; [EOL] }
protected ObjectNode createSchemaNode(String type, boolean isOptional) { [EOL]     ObjectNode schema = createSchemaNode(type); [EOL]     if (!isOptional) { [EOL]         schema.put("required", !isOptional); [EOL]     } [EOL]     return schema; [EOL] }
public void wrapAndThrow(SerializerProvider provider, Throwable t, Object bean, int index) throws IOException { [EOL]     while (t instanceof InvocationTargetException && t.getCause() != null) { [EOL]         t = t.getCause(); [EOL]     } [EOL]     if (t instanceof Error) { [EOL]         throw (Error) t; [EOL]     } [EOL]     boolean wrap = (provider == null) || provider.isEnabled(SerializationFeature.WRAP_EXCEPTIONS); [EOL]     if (t instanceof IOException) { [EOL]         if (!wrap || !(t instanceof JsonMappingException)) { [EOL]             throw (IOException) t; [EOL]         } [EOL]     } else if (!wrap) { [EOL]         if (t instanceof RuntimeException) { [EOL]             throw (RuntimeException) t; [EOL]         } [EOL]     } [EOL]     throw JsonMappingException.wrapWithPath(t, bean, index); [EOL] }
public void wrapAndThrow(SerializerProvider provider, Throwable t, Object bean, int index) throws IOException { [EOL]     while (t instanceof InvocationTargetException && t.getCause() != null) { [EOL]         t = t.getCause(); [EOL]     } [EOL]     if (t instanceof Error) { [EOL]         throw (Error) t; [EOL]     } [EOL]     boolean wrap = (provider == null) || provider.isEnabled(SerializationFeature.WRAP_EXCEPTIONS); [EOL]     if (t instanceof IOException) { [EOL]         if (!wrap || !(t instanceof JsonMappingException)) { [EOL]             throw (IOException) t; [EOL]         } [EOL]     } else if (!wrap) { [EOL]         if (t instanceof RuntimeException) { [EOL]             throw (RuntimeException) t; [EOL]         } [EOL]     } [EOL]     throw JsonMappingException.wrapWithPath(t, bean, index); [EOL] }
public void wrapAndThrow(SerializerProvider provider, Throwable t, Object bean, int index) throws IOException { [EOL]     while (t instanceof InvocationTargetException && t.getCause() != null) { [EOL]         t = t.getCause(); [EOL]     } [EOL]     if (t instanceof Error) { [EOL]         throw (Error) t; [EOL]     } [EOL]     boolean wrap = (provider == null) || provider.isEnabled(SerializationFeature.WRAP_EXCEPTIONS); [EOL]     if (t instanceof IOException) { [EOL]         if (!wrap || !(t instanceof JsonMappingException)) { [EOL]             throw (IOException) t; [EOL]         } [EOL]     } else if (!wrap) { [EOL]         if (t instanceof RuntimeException) { [EOL]             throw (RuntimeException) t; [EOL]         } [EOL]     } [EOL]     throw JsonMappingException.wrapWithPath(t, bean, index); [EOL] }
public void wrapAndThrow(SerializerProvider provider, Throwable t, Object bean, int index) throws IOException { [EOL]     while (t instanceof InvocationTargetException && t.getCause() != null) { [EOL]         t = t.getCause(); [EOL]     } [EOL]     if (t instanceof Error) { [EOL]         throw (Error) t; [EOL]     } [EOL]     boolean wrap = (provider == null) || provider.isEnabled(SerializationFeature.WRAP_EXCEPTIONS); [EOL]     if (t instanceof IOException) { [EOL]         if (!wrap || !(t instanceof JsonMappingException)) { [EOL]             throw (IOException) t; [EOL]         } [EOL]     } else if (!wrap) { [EOL]         if (t instanceof RuntimeException) { [EOL]             throw (RuntimeException) t; [EOL]         } [EOL]     } [EOL]     throw JsonMappingException.wrapWithPath(t, bean, index); [EOL] }
public void wrapAndThrow(SerializerProvider provider, Throwable t, Object bean, int index) throws IOException { [EOL]     while (t instanceof InvocationTargetException && t.getCause() != null) { [EOL]         t = t.getCause(); [EOL]     } [EOL]     if (t instanceof Error) { [EOL]         throw (Error) t; [EOL]     } [EOL]     boolean wrap = (provider == null) || provider.isEnabled(SerializationFeature.WRAP_EXCEPTIONS); [EOL]     if (t instanceof IOException) { [EOL]         if (!wrap || !(t instanceof JsonMappingException)) { [EOL]             throw (IOException) t; [EOL]         } [EOL]     } else if (!wrap) { [EOL]         if (t instanceof RuntimeException) { [EOL]             throw (RuntimeException) t; [EOL]         } [EOL]     } [EOL]     throw JsonMappingException.wrapWithPath(t, bean, index); [EOL] }
@Override [EOL] public JavaType mapAbstractType(DeserializationConfig config, JavaType type) throws JsonMappingException { [EOL]     while (true) { [EOL]         JavaType next = _mapAbstractType2(config, type); [EOL]         if (next == null) { [EOL]             return type; [EOL]         } [EOL]         Class<?> prevCls = type.getRawClass(); [EOL]         Class<?> nextCls = next.getRawClass(); [EOL]         if ((prevCls == nextCls) || !prevCls.isAssignableFrom(nextCls)) { [EOL]             throw new IllegalArgumentException("Invalid abstract type resolution from " + type + " to " + next + ": latter is not a subtype of former"); [EOL]         } [EOL]         type = next; [EOL]     } [EOL] }
@Override [EOL] public JavaType mapAbstractType(DeserializationConfig config, JavaType type) throws JsonMappingException { [EOL]     while (true) { [EOL]         JavaType next = _mapAbstractType2(config, type); [EOL]         if (next == null) { [EOL]             return type; [EOL]         } [EOL]         Class<?> prevCls = type.getRawClass(); [EOL]         Class<?> nextCls = next.getRawClass(); [EOL]         if ((prevCls == nextCls) || !prevCls.isAssignableFrom(nextCls)) { [EOL]             throw new IllegalArgumentException("Invalid abstract type resolution from " + type + " to " + next + ": latter is not a subtype of former"); [EOL]         } [EOL]         type = next; [EOL]     } [EOL] }
@Override [EOL] public JavaType mapAbstractType(DeserializationConfig config, JavaType type) throws JsonMappingException { [EOL]     while (true) { [EOL]         JavaType next = _mapAbstractType2(config, type); [EOL]         if (next == null) { [EOL]             return type; [EOL]         } [EOL]         Class<?> prevCls = type.getRawClass(); [EOL]         Class<?> nextCls = next.getRawClass(); [EOL]         if ((prevCls == nextCls) || !prevCls.isAssignableFrom(nextCls)) { [EOL]             throw new IllegalArgumentException("Invalid abstract type resolution from " + type + " to " + next + ": latter is not a subtype of former"); [EOL]         } [EOL]         type = next; [EOL]     } [EOL] }
private JavaType _mapAbstractType2(DeserializationConfig config, JavaType type) throws JsonMappingException { [EOL]     Class<?> currClass = type.getRawClass(); [EOL]     if (_factoryConfig.hasAbstractTypeResolvers()) { [EOL]         for (AbstractTypeResolver resolver : _factoryConfig.abstractTypeResolvers()) { [EOL]             JavaType concrete = resolver.findTypeMapping(config, type); [EOL]             if (concrete != null && concrete.getRawClass() != currClass) { [EOL]                 return concrete; [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
private JavaType _mapAbstractType2(DeserializationConfig config, JavaType type) throws JsonMappingException { [EOL]     Class<?> currClass = type.getRawClass(); [EOL]     if (_factoryConfig.hasAbstractTypeResolvers()) { [EOL]         for (AbstractTypeResolver resolver : _factoryConfig.abstractTypeResolvers()) { [EOL]             JavaType concrete = resolver.findTypeMapping(config, type); [EOL]             if (concrete != null && concrete.getRawClass() != currClass) { [EOL]                 return concrete; [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
private JavaType _mapAbstractType2(DeserializationConfig config, JavaType type) throws JsonMappingException { [EOL]     Class<?> currClass = type.getRawClass(); [EOL]     if (_factoryConfig.hasAbstractTypeResolvers()) { [EOL]         for (AbstractTypeResolver resolver : _factoryConfig.abstractTypeResolvers()) { [EOL]             JavaType concrete = resolver.findTypeMapping(config, type); [EOL]             if (concrete != null && concrete.getRawClass() != currClass) { [EOL]                 return concrete; [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
protected void _addDeserializerConstructors(DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators) throws JsonMappingException { [EOL]     AnnotatedConstructor defaultCtor = beanDesc.findDefaultConstructor(); [EOL]     if (defaultCtor != null) { [EOL]         if (!creators.hasDefaultCreator() || intr.hasCreatorAnnotation(defaultCtor)) { [EOL]             creators.setDefaultCreator(defaultCtor); [EOL]         } [EOL]     } [EOL]     String[] ctorPropNames = null; [EOL]     AnnotatedConstructor propertyCtor = null; [EOL]     for (BeanPropertyDefinition propDef : beanDesc.findProperties()) { [EOL]         if (propDef.getConstructorParameter() != null) { [EOL]             AnnotatedParameter param = propDef.getConstructorParameter(); [EOL]             AnnotatedWithParams owner = param.getOwner(); [EOL]             if (owner instanceof AnnotatedConstructor) { [EOL]                 if (propertyCtor == null) { [EOL]                     propertyCtor = (AnnotatedConstructor) owner; [EOL]                     ctorPropNames = new String[propertyCtor.getParameterCount()]; [EOL]                 } [EOL]                 ctorPropNames[param.getIndex()] = propDef.getName(); [EOL]             } [EOL]         } [EOL]     } [EOL]     for (AnnotatedConstructor ctor : beanDesc.getConstructors()) { [EOL]         int argCount = ctor.getParameterCount(); [EOL]         boolean isCreator = intr.hasCreatorAnnotation(ctor) || ctor == propertyCtor; [EOL]         boolean isVisible = vchecker.isCreatorVisible(ctor); [EOL]         if (argCount == 1) { [EOL]             String name = ctor == propertyCtor ? ctorPropNames[0] : null; [EOL]             _handleSingleArgumentConstructor(ctxt, beanDesc, vchecker, intr, creators, ctor, isCreator, isVisible, name); [EOL]             continue; [EOL]         } [EOL]         if (!isCreator && !isVisible) { [EOL]             continue; [EOL]         } [EOL]         AnnotatedParameter nonAnnotatedParam = null; [EOL]         int namedCount = 0; [EOL]         int injectCount = 0; [EOL]         CreatorProperty[] properties = new CreatorProperty[argCount]; [EOL]         for (int i = 0; i < argCount; ++i) { [EOL]             AnnotatedParameter param = ctor.getParameter(i); [EOL]             String name = null; [EOL]             if (ctor == propertyCtor) { [EOL]                 name = ctorPropNames[i]; [EOL]             } [EOL]             if (name == null) { [EOL]                 PropertyName pn = (param == null) ? null : intr.findNameForDeserialization(param); [EOL]                 name = (pn == null) ? null : pn.getSimpleName(); [EOL]             } [EOL]             Object injectId = intr.findInjectableValueId(param); [EOL]             if (name != null && name.length() > 0) { [EOL]                 ++namedCount; [EOL]                 properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId); [EOL]             } else if (injectId != null) { [EOL]                 ++injectCount; [EOL]                 properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId); [EOL]             } else if (nonAnnotatedParam == null) { [EOL]                 nonAnnotatedParam = param; [EOL]             } [EOL]         } [EOL]         if (isCreator || namedCount > 0 || injectCount > 0) { [EOL]             if ((namedCount + injectCount) == argCount) { [EOL]                 creators.addPropertyCreator(ctor, properties); [EOL]             } else if ((namedCount == 0) && ((injectCount + 1) == argCount)) { [EOL]                 creators.addDelegatingCreator(ctor, properties); [EOL]             } else { [EOL]                 creators.addIncompeteParameter(nonAnnotatedParam); [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected void _addDeserializerConstructors(DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators) throws JsonMappingException { [EOL]     AnnotatedConstructor defaultCtor = beanDesc.findDefaultConstructor(); [EOL]     if (defaultCtor != null) { [EOL]         if (!creators.hasDefaultCreator() || intr.hasCreatorAnnotation(defaultCtor)) { [EOL]             creators.setDefaultCreator(defaultCtor); [EOL]         } [EOL]     } [EOL]     String[] ctorPropNames = null; [EOL]     AnnotatedConstructor propertyCtor = null; [EOL]     for (BeanPropertyDefinition propDef : beanDesc.findProperties()) { [EOL]         if (propDef.getConstructorParameter() != null) { [EOL]             AnnotatedParameter param = propDef.getConstructorParameter(); [EOL]             AnnotatedWithParams owner = param.getOwner(); [EOL]             if (owner instanceof AnnotatedConstructor) { [EOL]                 if (propertyCtor == null) { [EOL]                     propertyCtor = (AnnotatedConstructor) owner; [EOL]                     ctorPropNames = new String[propertyCtor.getParameterCount()]; [EOL]                 } [EOL]                 ctorPropNames[param.getIndex()] = propDef.getName(); [EOL]             } [EOL]         } [EOL]     } [EOL]     for (AnnotatedConstructor ctor : beanDesc.getConstructors()) { [EOL]         int argCount = ctor.getParameterCount(); [EOL]         boolean isCreator = intr.hasCreatorAnnotation(ctor) || ctor == propertyCtor; [EOL]         boolean isVisible = vchecker.isCreatorVisible(ctor); [EOL]         if (argCount == 1) { [EOL]             String name = ctor == propertyCtor ? ctorPropNames[0] : null; [EOL]             _handleSingleArgumentConstructor(ctxt, beanDesc, vchecker, intr, creators, ctor, isCreator, isVisible, name); [EOL]             continue; [EOL]         } [EOL]         if (!isCreator && !isVisible) { [EOL]             continue; [EOL]         } [EOL]         AnnotatedParameter nonAnnotatedParam = null; [EOL]         int namedCount = 0; [EOL]         int injectCount = 0; [EOL]         CreatorProperty[] properties = new CreatorProperty[argCount]; [EOL]         for (int i = 0; i < argCount; ++i) { [EOL]             AnnotatedParameter param = ctor.getParameter(i); [EOL]             String name = null; [EOL]             if (ctor == propertyCtor) { [EOL]                 name = ctorPropNames[i]; [EOL]             } [EOL]             if (name == null) { [EOL]                 PropertyName pn = (param == null) ? null : intr.findNameForDeserialization(param); [EOL]                 name = (pn == null) ? null : pn.getSimpleName(); [EOL]             } [EOL]             Object injectId = intr.findInjectableValueId(param); [EOL]             if (name != null && name.length() > 0) { [EOL]                 ++namedCount; [EOL]                 properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId); [EOL]             } else if (injectId != null) { [EOL]                 ++injectCount; [EOL]                 properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId); [EOL]             } else if (nonAnnotatedParam == null) { [EOL]                 nonAnnotatedParam = param; [EOL]             } [EOL]         } [EOL]         if (isCreator || namedCount > 0 || injectCount > 0) { [EOL]             if ((namedCount + injectCount) == argCount) { [EOL]                 creators.addPropertyCreator(ctor, properties); [EOL]             } else if ((namedCount == 0) && ((injectCount + 1) == argCount)) { [EOL]                 creators.addDelegatingCreator(ctor, properties); [EOL]             } else { [EOL]                 creators.addIncompeteParameter(nonAnnotatedParam); [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected void _addDeserializerConstructors(DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators) throws JsonMappingException { [EOL]     AnnotatedConstructor defaultCtor = beanDesc.findDefaultConstructor(); [EOL]     if (defaultCtor != null) { [EOL]         if (!creators.hasDefaultCreator() || intr.hasCreatorAnnotation(defaultCtor)) { [EOL]             creators.setDefaultCreator(defaultCtor); [EOL]         } [EOL]     } [EOL]     String[] ctorPropNames = null; [EOL]     AnnotatedConstructor propertyCtor = null; [EOL]     for (BeanPropertyDefinition propDef : beanDesc.findProperties()) { [EOL]         if (propDef.getConstructorParameter() != null) { [EOL]             AnnotatedParameter param = propDef.getConstructorParameter(); [EOL]             AnnotatedWithParams owner = param.getOwner(); [EOL]             if (owner instanceof AnnotatedConstructor) { [EOL]                 if (propertyCtor == null) { [EOL]                     propertyCtor = (AnnotatedConstructor) owner; [EOL]                     ctorPropNames = new String[propertyCtor.getParameterCount()]; [EOL]                 } [EOL]                 ctorPropNames[param.getIndex()] = propDef.getName(); [EOL]             } [EOL]         } [EOL]     } [EOL]     for (AnnotatedConstructor ctor : beanDesc.getConstructors()) { [EOL]         int argCount = ctor.getParameterCount(); [EOL]         boolean isCreator = intr.hasCreatorAnnotation(ctor) || ctor == propertyCtor; [EOL]         boolean isVisible = vchecker.isCreatorVisible(ctor); [EOL]         if (argCount == 1) { [EOL]             String name = ctor == propertyCtor ? ctorPropNames[0] : null; [EOL]             _handleSingleArgumentConstructor(ctxt, beanDesc, vchecker, intr, creators, ctor, isCreator, isVisible, name); [EOL]             continue; [EOL]         } [EOL]         if (!isCreator && !isVisible) { [EOL]             continue; [EOL]         } [EOL]         AnnotatedParameter nonAnnotatedParam = null; [EOL]         int namedCount = 0; [EOL]         int injectCount = 0; [EOL]         CreatorProperty[] properties = new CreatorProperty[argCount]; [EOL]         for (int i = 0; i < argCount; ++i) { [EOL]             AnnotatedParameter param = ctor.getParameter(i); [EOL]             String name = null; [EOL]             if (ctor == propertyCtor) { [EOL]                 name = ctorPropNames[i]; [EOL]             } [EOL]             if (name == null) { [EOL]                 PropertyName pn = (param == null) ? null : intr.findNameForDeserialization(param); [EOL]                 name = (pn == null) ? null : pn.getSimpleName(); [EOL]             } [EOL]             Object injectId = intr.findInjectableValueId(param); [EOL]             if (name != null && name.length() > 0) { [EOL]                 ++namedCount; [EOL]                 properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId); [EOL]             } else if (injectId != null) { [EOL]                 ++injectCount; [EOL]                 properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId); [EOL]             } else if (nonAnnotatedParam == null) { [EOL]                 nonAnnotatedParam = param; [EOL]             } [EOL]         } [EOL]         if (isCreator || namedCount > 0 || injectCount > 0) { [EOL]             if ((namedCount + injectCount) == argCount) { [EOL]                 creators.addPropertyCreator(ctor, properties); [EOL]             } else if ((namedCount == 0) && ((injectCount + 1) == argCount)) { [EOL]                 creators.addDelegatingCreator(ctor, properties); [EOL]             } else { [EOL]                 creators.addIncompeteParameter(nonAnnotatedParam); [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected void _addDeserializerConstructors(DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators) throws JsonMappingException { [EOL]     AnnotatedConstructor defaultCtor = beanDesc.findDefaultConstructor(); [EOL]     if (defaultCtor != null) { [EOL]         if (!creators.hasDefaultCreator() || intr.hasCreatorAnnotation(defaultCtor)) { [EOL]             creators.setDefaultCreator(defaultCtor); [EOL]         } [EOL]     } [EOL]     String[] ctorPropNames = null; [EOL]     AnnotatedConstructor propertyCtor = null; [EOL]     for (BeanPropertyDefinition propDef : beanDesc.findProperties()) { [EOL]         if (propDef.getConstructorParameter() != null) { [EOL]             AnnotatedParameter param = propDef.getConstructorParameter(); [EOL]             AnnotatedWithParams owner = param.getOwner(); [EOL]             if (owner instanceof AnnotatedConstructor) { [EOL]                 if (propertyCtor == null) { [EOL]                     propertyCtor = (AnnotatedConstructor) owner; [EOL]                     ctorPropNames = new String[propertyCtor.getParameterCount()]; [EOL]                 } [EOL]                 ctorPropNames[param.getIndex()] = propDef.getName(); [EOL]             } [EOL]         } [EOL]     } [EOL]     for (AnnotatedConstructor ctor : beanDesc.getConstructors()) { [EOL]         int argCount = ctor.getParameterCount(); [EOL]         boolean isCreator = intr.hasCreatorAnnotation(ctor) || ctor == propertyCtor; [EOL]         boolean isVisible = vchecker.isCreatorVisible(ctor); [EOL]         if (argCount == 1) { [EOL]             String name = ctor == propertyCtor ? ctorPropNames[0] : null; [EOL]             _handleSingleArgumentConstructor(ctxt, beanDesc, vchecker, intr, creators, ctor, isCreator, isVisible, name); [EOL]             continue; [EOL]         } [EOL]         if (!isCreator && !isVisible) { [EOL]             continue; [EOL]         } [EOL]         AnnotatedParameter nonAnnotatedParam = null; [EOL]         int namedCount = 0; [EOL]         int injectCount = 0; [EOL]         CreatorProperty[] properties = new CreatorProperty[argCount]; [EOL]         for (int i = 0; i < argCount; ++i) { [EOL]             AnnotatedParameter param = ctor.getParameter(i); [EOL]             String name = null; [EOL]             if (ctor == propertyCtor) { [EOL]                 name = ctorPropNames[i]; [EOL]             } [EOL]             if (name == null) { [EOL]                 PropertyName pn = (param == null) ? null : intr.findNameForDeserialization(param); [EOL]                 name = (pn == null) ? null : pn.getSimpleName(); [EOL]             } [EOL]             Object injectId = intr.findInjectableValueId(param); [EOL]             if (name != null && name.length() > 0) { [EOL]                 ++namedCount; [EOL]                 properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId); [EOL]             } else if (injectId != null) { [EOL]                 ++injectCount; [EOL]                 properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId); [EOL]             } else if (nonAnnotatedParam == null) { [EOL]                 nonAnnotatedParam = param; [EOL]             } [EOL]         } [EOL]         if (isCreator || namedCount > 0 || injectCount > 0) { [EOL]             if ((namedCount + injectCount) == argCount) { [EOL]                 creators.addPropertyCreator(ctor, properties); [EOL]             } else if ((namedCount == 0) && ((injectCount + 1) == argCount)) { [EOL]                 creators.addDelegatingCreator(ctor, properties); [EOL]             } else { [EOL]                 creators.addIncompeteParameter(nonAnnotatedParam); [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected void _addDeserializerFactoryMethods(DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     for (AnnotatedMethod factory : beanDesc.getFactoryMethods()) { [EOL]         boolean isCreator = intr.hasCreatorAnnotation(factory); [EOL]         int argCount = factory.getParameterCount(); [EOL]         if (argCount == 0) { [EOL]             if (isCreator) { [EOL]                 creators.setDefaultCreator(factory); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (argCount == 1) { [EOL]             AnnotatedParameter param = factory.getParameter(0); [EOL]             PropertyName pn = (param == null) ? null : intr.findNameForDeserialization(param); [EOL]             String name = (pn == null) ? null : pn.getSimpleName(); [EOL]             Object injectId = intr.findInjectableValueId(param); [EOL]             if ((injectId == null) && (name == null || name.length() == 0)) { [EOL]                 _handleSingleArgumentFactory(config, beanDesc, vchecker, intr, creators, factory, isCreator); [EOL]                 continue; [EOL]             } [EOL]         } else { [EOL]             if (!intr.hasCreatorAnnotation(factory)) { [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         AnnotatedParameter nonAnnotatedParam = null; [EOL]         CreatorProperty[] properties = new CreatorProperty[argCount]; [EOL]         int namedCount = 0; [EOL]         int injectCount = 0; [EOL]         for (int i = 0; i < argCount; ++i) { [EOL]             AnnotatedParameter param = factory.getParameter(i); [EOL]             PropertyName pn = (param == null) ? null : intr.findNameForDeserialization(param); [EOL]             String name = (pn == null) ? null : pn.getSimpleName(); [EOL]             Object injectId = intr.findInjectableValueId(param); [EOL]             if (name != null && name.length() > 0) { [EOL]                 ++namedCount; [EOL]                 properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId); [EOL]             } else if (injectId != null) { [EOL]                 ++injectCount; [EOL]                 properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId); [EOL]             } else if (nonAnnotatedParam == null) { [EOL]                 nonAnnotatedParam = param; [EOL]             } [EOL]         } [EOL]         if (isCreator || namedCount > 0 || injectCount > 0) { [EOL]             if ((namedCount + injectCount) == argCount) { [EOL]                 creators.addPropertyCreator(factory, properties); [EOL]             } else if ((namedCount == 0) && ((injectCount + 1) == argCount)) { [EOL]                 creators.addDelegatingCreator(factory, properties); [EOL]             } else { [EOL]                 throw new IllegalArgumentException("Argument #" + nonAnnotatedParam.getIndex() + " of factory method " + factory + " has no property name annotation; must have name when multiple-paramater constructor annotated as Creator"); [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected void _addDeserializerFactoryMethods(DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     for (AnnotatedMethod factory : beanDesc.getFactoryMethods()) { [EOL]         boolean isCreator = intr.hasCreatorAnnotation(factory); [EOL]         int argCount = factory.getParameterCount(); [EOL]         if (argCount == 0) { [EOL]             if (isCreator) { [EOL]                 creators.setDefaultCreator(factory); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (argCount == 1) { [EOL]             AnnotatedParameter param = factory.getParameter(0); [EOL]             PropertyName pn = (param == null) ? null : intr.findNameForDeserialization(param); [EOL]             String name = (pn == null) ? null : pn.getSimpleName(); [EOL]             Object injectId = intr.findInjectableValueId(param); [EOL]             if ((injectId == null) && (name == null || name.length() == 0)) { [EOL]                 _handleSingleArgumentFactory(config, beanDesc, vchecker, intr, creators, factory, isCreator); [EOL]                 continue; [EOL]             } [EOL]         } else { [EOL]             if (!intr.hasCreatorAnnotation(factory)) { [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         AnnotatedParameter nonAnnotatedParam = null; [EOL]         CreatorProperty[] properties = new CreatorProperty[argCount]; [EOL]         int namedCount = 0; [EOL]         int injectCount = 0; [EOL]         for (int i = 0; i < argCount; ++i) { [EOL]             AnnotatedParameter param = factory.getParameter(i); [EOL]             PropertyName pn = (param == null) ? null : intr.findNameForDeserialization(param); [EOL]             String name = (pn == null) ? null : pn.getSimpleName(); [EOL]             Object injectId = intr.findInjectableValueId(param); [EOL]             if (name != null && name.length() > 0) { [EOL]                 ++namedCount; [EOL]                 properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId); [EOL]             } else if (injectId != null) { [EOL]                 ++injectCount; [EOL]                 properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId); [EOL]             } else if (nonAnnotatedParam == null) { [EOL]                 nonAnnotatedParam = param; [EOL]             } [EOL]         } [EOL]         if (isCreator || namedCount > 0 || injectCount > 0) { [EOL]             if ((namedCount + injectCount) == argCount) { [EOL]                 creators.addPropertyCreator(factory, properties); [EOL]             } else if ((namedCount == 0) && ((injectCount + 1) == argCount)) { [EOL]                 creators.addDelegatingCreator(factory, properties); [EOL]             } else { [EOL]                 throw new IllegalArgumentException("Argument #" + nonAnnotatedParam.getIndex() + " of factory method " + factory + " has no property name annotation; must have name when multiple-paramater constructor annotated as Creator"); [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected void _addDeserializerFactoryMethods(DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     for (AnnotatedMethod factory : beanDesc.getFactoryMethods()) { [EOL]         boolean isCreator = intr.hasCreatorAnnotation(factory); [EOL]         int argCount = factory.getParameterCount(); [EOL]         if (argCount == 0) { [EOL]             if (isCreator) { [EOL]                 creators.setDefaultCreator(factory); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (argCount == 1) { [EOL]             AnnotatedParameter param = factory.getParameter(0); [EOL]             PropertyName pn = (param == null) ? null : intr.findNameForDeserialization(param); [EOL]             String name = (pn == null) ? null : pn.getSimpleName(); [EOL]             Object injectId = intr.findInjectableValueId(param); [EOL]             if ((injectId == null) && (name == null || name.length() == 0)) { [EOL]                 _handleSingleArgumentFactory(config, beanDesc, vchecker, intr, creators, factory, isCreator); [EOL]                 continue; [EOL]             } [EOL]         } else { [EOL]             if (!intr.hasCreatorAnnotation(factory)) { [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         AnnotatedParameter nonAnnotatedParam = null; [EOL]         CreatorProperty[] properties = new CreatorProperty[argCount]; [EOL]         int namedCount = 0; [EOL]         int injectCount = 0; [EOL]         for (int i = 0; i < argCount; ++i) { [EOL]             AnnotatedParameter param = factory.getParameter(i); [EOL]             PropertyName pn = (param == null) ? null : intr.findNameForDeserialization(param); [EOL]             String name = (pn == null) ? null : pn.getSimpleName(); [EOL]             Object injectId = intr.findInjectableValueId(param); [EOL]             if (name != null && name.length() > 0) { [EOL]                 ++namedCount; [EOL]                 properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId); [EOL]             } else if (injectId != null) { [EOL]                 ++injectCount; [EOL]                 properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId); [EOL]             } else if (nonAnnotatedParam == null) { [EOL]                 nonAnnotatedParam = param; [EOL]             } [EOL]         } [EOL]         if (isCreator || namedCount > 0 || injectCount > 0) { [EOL]             if ((namedCount + injectCount) == argCount) { [EOL]                 creators.addPropertyCreator(factory, properties); [EOL]             } else if ((namedCount == 0) && ((injectCount + 1) == argCount)) { [EOL]                 creators.addDelegatingCreator(factory, properties); [EOL]             } else { [EOL]                 throw new IllegalArgumentException("Argument #" + nonAnnotatedParam.getIndex() + " of factory method " + factory + " has no property name annotation; must have name when multiple-paramater constructor annotated as Creator"); [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected void _addDeserializerFactoryMethods(DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     for (AnnotatedMethod factory : beanDesc.getFactoryMethods()) { [EOL]         boolean isCreator = intr.hasCreatorAnnotation(factory); [EOL]         int argCount = factory.getParameterCount(); [EOL]         if (argCount == 0) { [EOL]             if (isCreator) { [EOL]                 creators.setDefaultCreator(factory); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (argCount == 1) { [EOL]             AnnotatedParameter param = factory.getParameter(0); [EOL]             PropertyName pn = (param == null) ? null : intr.findNameForDeserialization(param); [EOL]             String name = (pn == null) ? null : pn.getSimpleName(); [EOL]             Object injectId = intr.findInjectableValueId(param); [EOL]             if ((injectId == null) && (name == null || name.length() == 0)) { [EOL]                 _handleSingleArgumentFactory(config, beanDesc, vchecker, intr, creators, factory, isCreator); [EOL]                 continue; [EOL]             } [EOL]         } else { [EOL]             if (!intr.hasCreatorAnnotation(factory)) { [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         AnnotatedParameter nonAnnotatedParam = null; [EOL]         CreatorProperty[] properties = new CreatorProperty[argCount]; [EOL]         int namedCount = 0; [EOL]         int injectCount = 0; [EOL]         for (int i = 0; i < argCount; ++i) { [EOL]             AnnotatedParameter param = factory.getParameter(i); [EOL]             PropertyName pn = (param == null) ? null : intr.findNameForDeserialization(param); [EOL]             String name = (pn == null) ? null : pn.getSimpleName(); [EOL]             Object injectId = intr.findInjectableValueId(param); [EOL]             if (name != null && name.length() > 0) { [EOL]                 ++namedCount; [EOL]                 properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId); [EOL]             } else if (injectId != null) { [EOL]                 ++injectCount; [EOL]                 properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId); [EOL]             } else if (nonAnnotatedParam == null) { [EOL]                 nonAnnotatedParam = param; [EOL]             } [EOL]         } [EOL]         if (isCreator || namedCount > 0 || injectCount > 0) { [EOL]             if ((namedCount + injectCount) == argCount) { [EOL]                 creators.addPropertyCreator(factory, properties); [EOL]             } else if ((namedCount == 0) && ((injectCount + 1) == argCount)) { [EOL]                 creators.addDelegatingCreator(factory, properties); [EOL]             } else { [EOL]                 throw new IllegalArgumentException("Argument #" + nonAnnotatedParam.getIndex() + " of factory method " + factory + " has no property name annotation; must have name when multiple-paramater constructor annotated as Creator"); [EOL]             } [EOL]         } [EOL]     } [EOL] }
@Override [EOL] public JsonDeserializer<?> createArrayDeserializer(DeserializationContext ctxt, ArrayType type, final BeanDescription beanDesc) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     JavaType elemType = type.getContentType(); [EOL]     JsonDeserializer<Object> contentDeser = elemType.getValueHandler(); [EOL]     TypeDeserializer elemTypeDeser = elemType.getTypeHandler(); [EOL]     if (elemTypeDeser == null) { [EOL]         elemTypeDeser = findTypeDeserializer(config, elemType); [EOL]     } [EOL]     JsonDeserializer<?> deser = _findCustomArrayDeserializer(type, config, beanDesc, elemTypeDeser, contentDeser); [EOL]     if (deser == null) { [EOL]         if (contentDeser == null) { [EOL]             Class<?> raw = elemType.getRawClass(); [EOL]             if (elemType.isPrimitive()) { [EOL]                 return PrimitiveArrayDeserializers.forType(raw); [EOL]             } else if (raw == String.class) { [EOL]                 return StringArrayDeserializer.instance; [EOL]             } [EOL]         } [EOL]         if (deser == null) { [EOL]             deser = new ObjectArrayDeserializer(type, contentDeser, elemTypeDeser); [EOL]         } [EOL]     } [EOL]     if (_factoryConfig.hasDeserializerModifiers()) { [EOL]         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) { [EOL]             deser = mod.modifyArrayDeserializer(config, type, beanDesc, deser); [EOL]         } [EOL]     } [EOL]     return deser; [EOL] }
@Override [EOL] public JsonDeserializer<?> createArrayDeserializer(DeserializationContext ctxt, ArrayType type, final BeanDescription beanDesc) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     JavaType elemType = type.getContentType(); [EOL]     JsonDeserializer<Object> contentDeser = elemType.getValueHandler(); [EOL]     TypeDeserializer elemTypeDeser = elemType.getTypeHandler(); [EOL]     if (elemTypeDeser == null) { [EOL]         elemTypeDeser = findTypeDeserializer(config, elemType); [EOL]     } [EOL]     JsonDeserializer<?> deser = _findCustomArrayDeserializer(type, config, beanDesc, elemTypeDeser, contentDeser); [EOL]     if (deser == null) { [EOL]         if (contentDeser == null) { [EOL]             Class<?> raw = elemType.getRawClass(); [EOL]             if (elemType.isPrimitive()) { [EOL]                 return PrimitiveArrayDeserializers.forType(raw); [EOL]             } else if (raw == String.class) { [EOL]                 return StringArrayDeserializer.instance; [EOL]             } [EOL]         } [EOL]         if (deser == null) { [EOL]             deser = new ObjectArrayDeserializer(type, contentDeser, elemTypeDeser); [EOL]         } [EOL]     } [EOL]     if (_factoryConfig.hasDeserializerModifiers()) { [EOL]         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) { [EOL]             deser = mod.modifyArrayDeserializer(config, type, beanDesc, deser); [EOL]         } [EOL]     } [EOL]     return deser; [EOL] }
@Override [EOL] public JsonDeserializer<?> createArrayDeserializer(DeserializationContext ctxt, ArrayType type, final BeanDescription beanDesc) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     JavaType elemType = type.getContentType(); [EOL]     JsonDeserializer<Object> contentDeser = elemType.getValueHandler(); [EOL]     TypeDeserializer elemTypeDeser = elemType.getTypeHandler(); [EOL]     if (elemTypeDeser == null) { [EOL]         elemTypeDeser = findTypeDeserializer(config, elemType); [EOL]     } [EOL]     JsonDeserializer<?> deser = _findCustomArrayDeserializer(type, config, beanDesc, elemTypeDeser, contentDeser); [EOL]     if (deser == null) { [EOL]         if (contentDeser == null) { [EOL]             Class<?> raw = elemType.getRawClass(); [EOL]             if (elemType.isPrimitive()) { [EOL]                 return PrimitiveArrayDeserializers.forType(raw); [EOL]             } else if (raw == String.class) { [EOL]                 return StringArrayDeserializer.instance; [EOL]             } [EOL]         } [EOL]         if (deser == null) { [EOL]             deser = new ObjectArrayDeserializer(type, contentDeser, elemTypeDeser); [EOL]         } [EOL]     } [EOL]     if (_factoryConfig.hasDeserializerModifiers()) { [EOL]         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) { [EOL]             deser = mod.modifyArrayDeserializer(config, type, beanDesc, deser); [EOL]         } [EOL]     } [EOL]     return deser; [EOL] }
@Override [EOL] public JsonDeserializer<?> createArrayDeserializer(DeserializationContext ctxt, ArrayType type, final BeanDescription beanDesc) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     JavaType elemType = type.getContentType(); [EOL]     JsonDeserializer<Object> contentDeser = elemType.getValueHandler(); [EOL]     TypeDeserializer elemTypeDeser = elemType.getTypeHandler(); [EOL]     if (elemTypeDeser == null) { [EOL]         elemTypeDeser = findTypeDeserializer(config, elemType); [EOL]     } [EOL]     JsonDeserializer<?> deser = _findCustomArrayDeserializer(type, config, beanDesc, elemTypeDeser, contentDeser); [EOL]     if (deser == null) { [EOL]         if (contentDeser == null) { [EOL]             Class<?> raw = elemType.getRawClass(); [EOL]             if (elemType.isPrimitive()) { [EOL]                 return PrimitiveArrayDeserializers.forType(raw); [EOL]             } else if (raw == String.class) { [EOL]                 return StringArrayDeserializer.instance; [EOL]             } [EOL]         } [EOL]         if (deser == null) { [EOL]             deser = new ObjectArrayDeserializer(type, contentDeser, elemTypeDeser); [EOL]         } [EOL]     } [EOL]     if (_factoryConfig.hasDeserializerModifiers()) { [EOL]         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) { [EOL]             deser = mod.modifyArrayDeserializer(config, type, beanDesc, deser); [EOL]         } [EOL]     } [EOL]     return deser; [EOL] }
protected JsonDeserializer<?> _findCustomArrayDeserializer(ArrayType type, DeserializationConfig config, BeanDescription beanDesc, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException { [EOL]     for (Deserializers d : _factoryConfig.deserializers()) { [EOL]         JsonDeserializer<?> deser = d.findArrayDeserializer(type, config, beanDesc, elementTypeDeserializer, elementDeserializer); [EOL]         if (deser != null) { [EOL]             return deser; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
protected JsonDeserializer<?> _findCustomArrayDeserializer(ArrayType type, DeserializationConfig config, BeanDescription beanDesc, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException { [EOL]     for (Deserializers d : _factoryConfig.deserializers()) { [EOL]         JsonDeserializer<?> deser = d.findArrayDeserializer(type, config, beanDesc, elementTypeDeserializer, elementDeserializer); [EOL]         if (deser != null) { [EOL]             return deser; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public JsonDeserializer<?> createCollectionDeserializer(DeserializationContext ctxt, CollectionType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     JavaType contentType = type.getContentType(); [EOL]     JsonDeserializer<Object> contentDeser = contentType.getValueHandler(); [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     TypeDeserializer contentTypeDeser = contentType.getTypeHandler(); [EOL]     if (contentTypeDeser == null) { [EOL]         contentTypeDeser = findTypeDeserializer(config, contentType); [EOL]     } [EOL]     JsonDeserializer<?> deser = _findCustomCollectionDeserializer(type, config, beanDesc, contentTypeDeser, contentDeser); [EOL]     if (deser == null) { [EOL]         Class<?> collectionClass = type.getRawClass(); [EOL]         if (contentDeser == null) { [EOL]             if (EnumSet.class.isAssignableFrom(collectionClass)) { [EOL]                 deser = new EnumSetDeserializer(contentType, null); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (deser == null) { [EOL]         if (type.isInterface() || type.isAbstract()) { [EOL]             CollectionType implType = _mapAbstractCollectionType(type, config); [EOL]             if (implType == null) { [EOL]                 throw new IllegalArgumentException("Can not find a deserializer for non-concrete Collection type " + type); [EOL]             } [EOL]             type = implType; [EOL]             beanDesc = config.introspectForCreation(type); [EOL]         } [EOL]         ValueInstantiator inst = findValueInstantiator(ctxt, beanDesc); [EOL]         if (!inst.canCreateUsingDefault()) { [EOL]             if (type.getRawClass() == ArrayBlockingQueue.class) { [EOL]                 return new ArrayBlockingQueueDeserializer(type, contentDeser, contentTypeDeser, inst, null); [EOL]             } [EOL]         } [EOL]         if (contentType.getRawClass() == String.class) { [EOL]             deser = new StringCollectionDeserializer(type, contentDeser, inst); [EOL]         } else { [EOL]             deser = new CollectionDeserializer(type, contentDeser, contentTypeDeser, inst); [EOL]         } [EOL]     } [EOL]     if (_factoryConfig.hasDeserializerModifiers()) { [EOL]         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) { [EOL]             deser = mod.modifyCollectionDeserializer(config, type, beanDesc, deser); [EOL]         } [EOL]     } [EOL]     return deser; [EOL] }
@Override [EOL] public JsonDeserializer<?> createCollectionDeserializer(DeserializationContext ctxt, CollectionType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     JavaType contentType = type.getContentType(); [EOL]     JsonDeserializer<Object> contentDeser = contentType.getValueHandler(); [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     TypeDeserializer contentTypeDeser = contentType.getTypeHandler(); [EOL]     if (contentTypeDeser == null) { [EOL]         contentTypeDeser = findTypeDeserializer(config, contentType); [EOL]     } [EOL]     JsonDeserializer<?> deser = _findCustomCollectionDeserializer(type, config, beanDesc, contentTypeDeser, contentDeser); [EOL]     if (deser == null) { [EOL]         Class<?> collectionClass = type.getRawClass(); [EOL]         if (contentDeser == null) { [EOL]             if (EnumSet.class.isAssignableFrom(collectionClass)) { [EOL]                 deser = new EnumSetDeserializer(contentType, null); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (deser == null) { [EOL]         if (type.isInterface() || type.isAbstract()) { [EOL]             CollectionType implType = _mapAbstractCollectionType(type, config); [EOL]             if (implType == null) { [EOL]                 throw new IllegalArgumentException("Can not find a deserializer for non-concrete Collection type " + type); [EOL]             } [EOL]             type = implType; [EOL]             beanDesc = config.introspectForCreation(type); [EOL]         } [EOL]         ValueInstantiator inst = findValueInstantiator(ctxt, beanDesc); [EOL]         if (!inst.canCreateUsingDefault()) { [EOL]             if (type.getRawClass() == ArrayBlockingQueue.class) { [EOL]                 return new ArrayBlockingQueueDeserializer(type, contentDeser, contentTypeDeser, inst, null); [EOL]             } [EOL]         } [EOL]         if (contentType.getRawClass() == String.class) { [EOL]             deser = new StringCollectionDeserializer(type, contentDeser, inst); [EOL]         } else { [EOL]             deser = new CollectionDeserializer(type, contentDeser, contentTypeDeser, inst); [EOL]         } [EOL]     } [EOL]     if (_factoryConfig.hasDeserializerModifiers()) { [EOL]         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) { [EOL]             deser = mod.modifyCollectionDeserializer(config, type, beanDesc, deser); [EOL]         } [EOL]     } [EOL]     return deser; [EOL] }
@Override [EOL] public JsonDeserializer<?> createCollectionDeserializer(DeserializationContext ctxt, CollectionType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     JavaType contentType = type.getContentType(); [EOL]     JsonDeserializer<Object> contentDeser = contentType.getValueHandler(); [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     TypeDeserializer contentTypeDeser = contentType.getTypeHandler(); [EOL]     if (contentTypeDeser == null) { [EOL]         contentTypeDeser = findTypeDeserializer(config, contentType); [EOL]     } [EOL]     JsonDeserializer<?> deser = _findCustomCollectionDeserializer(type, config, beanDesc, contentTypeDeser, contentDeser); [EOL]     if (deser == null) { [EOL]         Class<?> collectionClass = type.getRawClass(); [EOL]         if (contentDeser == null) { [EOL]             if (EnumSet.class.isAssignableFrom(collectionClass)) { [EOL]                 deser = new EnumSetDeserializer(contentType, null); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (deser == null) { [EOL]         if (type.isInterface() || type.isAbstract()) { [EOL]             CollectionType implType = _mapAbstractCollectionType(type, config); [EOL]             if (implType == null) { [EOL]                 throw new IllegalArgumentException("Can not find a deserializer for non-concrete Collection type " + type); [EOL]             } [EOL]             type = implType; [EOL]             beanDesc = config.introspectForCreation(type); [EOL]         } [EOL]         ValueInstantiator inst = findValueInstantiator(ctxt, beanDesc); [EOL]         if (!inst.canCreateUsingDefault()) { [EOL]             if (type.getRawClass() == ArrayBlockingQueue.class) { [EOL]                 return new ArrayBlockingQueueDeserializer(type, contentDeser, contentTypeDeser, inst, null); [EOL]             } [EOL]         } [EOL]         if (contentType.getRawClass() == String.class) { [EOL]             deser = new StringCollectionDeserializer(type, contentDeser, inst); [EOL]         } else { [EOL]             deser = new CollectionDeserializer(type, contentDeser, contentTypeDeser, inst); [EOL]         } [EOL]     } [EOL]     if (_factoryConfig.hasDeserializerModifiers()) { [EOL]         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) { [EOL]             deser = mod.modifyCollectionDeserializer(config, type, beanDesc, deser); [EOL]         } [EOL]     } [EOL]     return deser; [EOL] }
@Override [EOL] public JsonDeserializer<?> createCollectionDeserializer(DeserializationContext ctxt, CollectionType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     JavaType contentType = type.getContentType(); [EOL]     JsonDeserializer<Object> contentDeser = contentType.getValueHandler(); [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     TypeDeserializer contentTypeDeser = contentType.getTypeHandler(); [EOL]     if (contentTypeDeser == null) { [EOL]         contentTypeDeser = findTypeDeserializer(config, contentType); [EOL]     } [EOL]     JsonDeserializer<?> deser = _findCustomCollectionDeserializer(type, config, beanDesc, contentTypeDeser, contentDeser); [EOL]     if (deser == null) { [EOL]         Class<?> collectionClass = type.getRawClass(); [EOL]         if (contentDeser == null) { [EOL]             if (EnumSet.class.isAssignableFrom(collectionClass)) { [EOL]                 deser = new EnumSetDeserializer(contentType, null); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (deser == null) { [EOL]         if (type.isInterface() || type.isAbstract()) { [EOL]             CollectionType implType = _mapAbstractCollectionType(type, config); [EOL]             if (implType == null) { [EOL]                 throw new IllegalArgumentException("Can not find a deserializer for non-concrete Collection type " + type); [EOL]             } [EOL]             type = implType; [EOL]             beanDesc = config.introspectForCreation(type); [EOL]         } [EOL]         ValueInstantiator inst = findValueInstantiator(ctxt, beanDesc); [EOL]         if (!inst.canCreateUsingDefault()) { [EOL]             if (type.getRawClass() == ArrayBlockingQueue.class) { [EOL]                 return new ArrayBlockingQueueDeserializer(type, contentDeser, contentTypeDeser, inst, null); [EOL]             } [EOL]         } [EOL]         if (contentType.getRawClass() == String.class) { [EOL]             deser = new StringCollectionDeserializer(type, contentDeser, inst); [EOL]         } else { [EOL]             deser = new CollectionDeserializer(type, contentDeser, contentTypeDeser, inst); [EOL]         } [EOL]     } [EOL]     if (_factoryConfig.hasDeserializerModifiers()) { [EOL]         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) { [EOL]             deser = mod.modifyCollectionDeserializer(config, type, beanDesc, deser); [EOL]         } [EOL]     } [EOL]     return deser; [EOL] }
@Override [EOL] public JsonDeserializer<?> createCollectionDeserializer(DeserializationContext ctxt, CollectionType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     JavaType contentType = type.getContentType(); [EOL]     JsonDeserializer<Object> contentDeser = contentType.getValueHandler(); [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     TypeDeserializer contentTypeDeser = contentType.getTypeHandler(); [EOL]     if (contentTypeDeser == null) { [EOL]         contentTypeDeser = findTypeDeserializer(config, contentType); [EOL]     } [EOL]     JsonDeserializer<?> deser = _findCustomCollectionDeserializer(type, config, beanDesc, contentTypeDeser, contentDeser); [EOL]     if (deser == null) { [EOL]         Class<?> collectionClass = type.getRawClass(); [EOL]         if (contentDeser == null) { [EOL]             if (EnumSet.class.isAssignableFrom(collectionClass)) { [EOL]                 deser = new EnumSetDeserializer(contentType, null); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (deser == null) { [EOL]         if (type.isInterface() || type.isAbstract()) { [EOL]             CollectionType implType = _mapAbstractCollectionType(type, config); [EOL]             if (implType == null) { [EOL]                 throw new IllegalArgumentException("Can not find a deserializer for non-concrete Collection type " + type); [EOL]             } [EOL]             type = implType; [EOL]             beanDesc = config.introspectForCreation(type); [EOL]         } [EOL]         ValueInstantiator inst = findValueInstantiator(ctxt, beanDesc); [EOL]         if (!inst.canCreateUsingDefault()) { [EOL]             if (type.getRawClass() == ArrayBlockingQueue.class) { [EOL]                 return new ArrayBlockingQueueDeserializer(type, contentDeser, contentTypeDeser, inst, null); [EOL]             } [EOL]         } [EOL]         if (contentType.getRawClass() == String.class) { [EOL]             deser = new StringCollectionDeserializer(type, contentDeser, inst); [EOL]         } else { [EOL]             deser = new CollectionDeserializer(type, contentDeser, contentTypeDeser, inst); [EOL]         } [EOL]     } [EOL]     if (_factoryConfig.hasDeserializerModifiers()) { [EOL]         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) { [EOL]             deser = mod.modifyCollectionDeserializer(config, type, beanDesc, deser); [EOL]         } [EOL]     } [EOL]     return deser; [EOL] }
@Override [EOL] public JsonDeserializer<?> createCollectionDeserializer(DeserializationContext ctxt, CollectionType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     JavaType contentType = type.getContentType(); [EOL]     JsonDeserializer<Object> contentDeser = contentType.getValueHandler(); [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     TypeDeserializer contentTypeDeser = contentType.getTypeHandler(); [EOL]     if (contentTypeDeser == null) { [EOL]         contentTypeDeser = findTypeDeserializer(config, contentType); [EOL]     } [EOL]     JsonDeserializer<?> deser = _findCustomCollectionDeserializer(type, config, beanDesc, contentTypeDeser, contentDeser); [EOL]     if (deser == null) { [EOL]         Class<?> collectionClass = type.getRawClass(); [EOL]         if (contentDeser == null) { [EOL]             if (EnumSet.class.isAssignableFrom(collectionClass)) { [EOL]                 deser = new EnumSetDeserializer(contentType, null); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (deser == null) { [EOL]         if (type.isInterface() || type.isAbstract()) { [EOL]             CollectionType implType = _mapAbstractCollectionType(type, config); [EOL]             if (implType == null) { [EOL]                 throw new IllegalArgumentException("Can not find a deserializer for non-concrete Collection type " + type); [EOL]             } [EOL]             type = implType; [EOL]             beanDesc = config.introspectForCreation(type); [EOL]         } [EOL]         ValueInstantiator inst = findValueInstantiator(ctxt, beanDesc); [EOL]         if (!inst.canCreateUsingDefault()) { [EOL]             if (type.getRawClass() == ArrayBlockingQueue.class) { [EOL]                 return new ArrayBlockingQueueDeserializer(type, contentDeser, contentTypeDeser, inst, null); [EOL]             } [EOL]         } [EOL]         if (contentType.getRawClass() == String.class) { [EOL]             deser = new StringCollectionDeserializer(type, contentDeser, inst); [EOL]         } else { [EOL]             deser = new CollectionDeserializer(type, contentDeser, contentTypeDeser, inst); [EOL]         } [EOL]     } [EOL]     if (_factoryConfig.hasDeserializerModifiers()) { [EOL]         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) { [EOL]             deser = mod.modifyCollectionDeserializer(config, type, beanDesc, deser); [EOL]         } [EOL]     } [EOL]     return deser; [EOL] }
protected JsonDeserializer<?> _findCustomCollectionDeserializer(CollectionType type, DeserializationConfig config, BeanDescription beanDesc, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException { [EOL]     for (Deserializers d : _factoryConfig.deserializers()) { [EOL]         JsonDeserializer<?> deser = d.findCollectionDeserializer(type, config, beanDesc, elementTypeDeserializer, elementDeserializer); [EOL]         if (deser != null) { [EOL]             return deser; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
protected JsonDeserializer<?> _findCustomCollectionDeserializer(CollectionType type, DeserializationConfig config, BeanDescription beanDesc, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException { [EOL]     for (Deserializers d : _factoryConfig.deserializers()) { [EOL]         JsonDeserializer<?> deser = d.findCollectionDeserializer(type, config, beanDesc, elementTypeDeserializer, elementDeserializer); [EOL]         if (deser != null) { [EOL]             return deser; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     Class<?> rawType = type.getRawClass(); [EOL]     String clsName = rawType.getName(); [EOL]     if (rawType.isPrimitive() || clsName.startsWith("java.")) { [EOL]         if (rawType == CLASS_OBJECT) { [EOL]             return UntypedObjectDeserializer.instance; [EOL]         } [EOL]         if (rawType == CLASS_STRING || rawType == CLASS_CHAR_BUFFER) { [EOL]             return StringDeserializer.instance; [EOL]         } [EOL]         if (rawType == CLASS_ITERABLE) { [EOL]             TypeFactory tf = ctxt.getTypeFactory(); [EOL]             JavaType elemType = (type.containedTypeCount() > 0) ? type.containedType(0) : TypeFactory.unknownType(); [EOL]             CollectionType ct = tf.constructCollectionType(Collection.class, elemType); [EOL]             return createCollectionDeserializer(ctxt, ct, beanDesc); [EOL]         } [EOL]         JsonDeserializer<?> deser = NumberDeserializers.find(rawType, clsName); [EOL]         if (deser == null) { [EOL]             deser = DateDeserializers.find(rawType, clsName); [EOL]             if (deser == null) { [EOL]                 deser = JdkDeserializers.find(rawType, clsName); [EOL]             } [EOL]         } [EOL]         return deser; [EOL]     } [EOL]     if (clsName.startsWith("com.fasterxml.")) { [EOL]         return JacksonDeserializers.find(rawType); [EOL]     } [EOL]     return null; [EOL] }
public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     Class<?> rawType = type.getRawClass(); [EOL]     String clsName = rawType.getName(); [EOL]     if (rawType.isPrimitive() || clsName.startsWith("java.")) { [EOL]         if (rawType == CLASS_OBJECT) { [EOL]             return UntypedObjectDeserializer.instance; [EOL]         } [EOL]         if (rawType == CLASS_STRING || rawType == CLASS_CHAR_BUFFER) { [EOL]             return StringDeserializer.instance; [EOL]         } [EOL]         if (rawType == CLASS_ITERABLE) { [EOL]             TypeFactory tf = ctxt.getTypeFactory(); [EOL]             JavaType elemType = (type.containedTypeCount() > 0) ? type.containedType(0) : TypeFactory.unknownType(); [EOL]             CollectionType ct = tf.constructCollectionType(Collection.class, elemType); [EOL]             return createCollectionDeserializer(ctxt, ct, beanDesc); [EOL]         } [EOL]         JsonDeserializer<?> deser = NumberDeserializers.find(rawType, clsName); [EOL]         if (deser == null) { [EOL]             deser = DateDeserializers.find(rawType, clsName); [EOL]             if (deser == null) { [EOL]                 deser = JdkDeserializers.find(rawType, clsName); [EOL]             } [EOL]         } [EOL]         return deser; [EOL]     } [EOL]     if (clsName.startsWith("com.fasterxml.")) { [EOL]         return JacksonDeserializers.find(rawType); [EOL]     } [EOL]     return null; [EOL] }
public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     Class<?> rawType = type.getRawClass(); [EOL]     String clsName = rawType.getName(); [EOL]     if (rawType.isPrimitive() || clsName.startsWith("java.")) { [EOL]         if (rawType == CLASS_OBJECT) { [EOL]             return UntypedObjectDeserializer.instance; [EOL]         } [EOL]         if (rawType == CLASS_STRING || rawType == CLASS_CHAR_BUFFER) { [EOL]             return StringDeserializer.instance; [EOL]         } [EOL]         if (rawType == CLASS_ITERABLE) { [EOL]             TypeFactory tf = ctxt.getTypeFactory(); [EOL]             JavaType elemType = (type.containedTypeCount() > 0) ? type.containedType(0) : TypeFactory.unknownType(); [EOL]             CollectionType ct = tf.constructCollectionType(Collection.class, elemType); [EOL]             return createCollectionDeserializer(ctxt, ct, beanDesc); [EOL]         } [EOL]         JsonDeserializer<?> deser = NumberDeserializers.find(rawType, clsName); [EOL]         if (deser == null) { [EOL]             deser = DateDeserializers.find(rawType, clsName); [EOL]             if (deser == null) { [EOL]                 deser = JdkDeserializers.find(rawType, clsName); [EOL]             } [EOL]         } [EOL]         return deser; [EOL]     } [EOL]     if (clsName.startsWith("com.fasterxml.")) { [EOL]         return JacksonDeserializers.find(rawType); [EOL]     } [EOL]     return null; [EOL] }
public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     Class<?> rawType = type.getRawClass(); [EOL]     String clsName = rawType.getName(); [EOL]     if (rawType.isPrimitive() || clsName.startsWith("java.")) { [EOL]         if (rawType == CLASS_OBJECT) { [EOL]             return UntypedObjectDeserializer.instance; [EOL]         } [EOL]         if (rawType == CLASS_STRING || rawType == CLASS_CHAR_BUFFER) { [EOL]             return StringDeserializer.instance; [EOL]         } [EOL]         if (rawType == CLASS_ITERABLE) { [EOL]             TypeFactory tf = ctxt.getTypeFactory(); [EOL]             JavaType elemType = (type.containedTypeCount() > 0) ? type.containedType(0) : TypeFactory.unknownType(); [EOL]             CollectionType ct = tf.constructCollectionType(Collection.class, elemType); [EOL]             return createCollectionDeserializer(ctxt, ct, beanDesc); [EOL]         } [EOL]         JsonDeserializer<?> deser = NumberDeserializers.find(rawType, clsName); [EOL]         if (deser == null) { [EOL]             deser = DateDeserializers.find(rawType, clsName); [EOL]             if (deser == null) { [EOL]                 deser = JdkDeserializers.find(rawType, clsName); [EOL]             } [EOL]         } [EOL]         return deser; [EOL]     } [EOL]     if (clsName.startsWith("com.fasterxml.")) { [EOL]         return JacksonDeserializers.find(rawType); [EOL]     } [EOL]     return null; [EOL] }
public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     Class<?> rawType = type.getRawClass(); [EOL]     String clsName = rawType.getName(); [EOL]     if (rawType.isPrimitive() || clsName.startsWith("java.")) { [EOL]         if (rawType == CLASS_OBJECT) { [EOL]             return UntypedObjectDeserializer.instance; [EOL]         } [EOL]         if (rawType == CLASS_STRING || rawType == CLASS_CHAR_BUFFER) { [EOL]             return StringDeserializer.instance; [EOL]         } [EOL]         if (rawType == CLASS_ITERABLE) { [EOL]             TypeFactory tf = ctxt.getTypeFactory(); [EOL]             JavaType elemType = (type.containedTypeCount() > 0) ? type.containedType(0) : TypeFactory.unknownType(); [EOL]             CollectionType ct = tf.constructCollectionType(Collection.class, elemType); [EOL]             return createCollectionDeserializer(ctxt, ct, beanDesc); [EOL]         } [EOL]         JsonDeserializer<?> deser = NumberDeserializers.find(rawType, clsName); [EOL]         if (deser == null) { [EOL]             deser = DateDeserializers.find(rawType, clsName); [EOL]             if (deser == null) { [EOL]                 deser = JdkDeserializers.find(rawType, clsName); [EOL]             } [EOL]         } [EOL]         return deser; [EOL]     } [EOL]     if (clsName.startsWith("com.fasterxml.")) { [EOL]         return JacksonDeserializers.find(rawType); [EOL]     } [EOL]     return null; [EOL] }
@SuppressWarnings({ "unchecked" }) [EOL] protected <T extends JavaType> T modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, T type) throws JsonMappingException { [EOL]     AnnotationIntrospector intr = ctxt.getAnnotationIntrospector(); [EOL]     Class<?> subclass = intr.findDeserializationType(a, type); [EOL]     if (subclass != null) { [EOL]         try { [EOL]             type = (T) type.narrowBy(subclass); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw new JsonMappingException("Failed to narrow type " + type + " with concrete-type annotation (value " + subclass.getName() + "), method '" + a.getName() + "': " + iae.getMessage(), null, iae); [EOL]         } [EOL]     } [EOL]     if (type.isContainerType()) { [EOL]         Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType()); [EOL]         if (keyClass != null) { [EOL]             if (!(type instanceof MapLikeType)) { [EOL]                 throw new JsonMappingException("Illegal key-type annotation: type " + type + " is not a Map(-like) type"); [EOL]             } [EOL]             try { [EOL]                 type = (T) ((MapLikeType) type).narrowKey(keyClass); [EOL]             } catch (IllegalArgumentException iae) { [EOL]                 throw new JsonMappingException("Failed to narrow key type " + type + " with key-type annotation (" + keyClass.getName() + "): " + iae.getMessage(), null, iae); [EOL]             } [EOL]         } [EOL]         JavaType keyType = type.getKeyType(); [EOL]         if (keyType != null && keyType.getValueHandler() == null) { [EOL]             Object kdDef = intr.findKeyDeserializer(a); [EOL]             KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef); [EOL]             if (kd != null) { [EOL]                 type = (T) ((MapLikeType) type).withKeyValueHandler(kd); [EOL]                 keyType = type.getKeyType(); [EOL]             } [EOL]         } [EOL]         Class<?> cc = intr.findDeserializationContentType(a, type.getContentType()); [EOL]         if (cc != null) { [EOL]             try { [EOL]                 type = (T) type.narrowContentsBy(cc); [EOL]             } catch (IllegalArgumentException iae) { [EOL]                 throw new JsonMappingException("Failed to narrow content type " + type + " with content-type annotation (" + cc.getName() + "): " + iae.getMessage(), null, iae); [EOL]             } [EOL]         } [EOL]         JavaType contentType = type.getContentType(); [EOL]         if (contentType.getValueHandler() == null) { [EOL]             Object cdDef = intr.findContentDeserializer(a); [EOL]             JsonDeserializer<?> cd = ctxt.deserializerInstance(a, cdDef); [EOL]             if (cd != null) { [EOL]                 type = (T) type.withContentValueHandler(cd); [EOL]             } [EOL]         } [EOL]     } [EOL]     return type; [EOL] }
@SuppressWarnings({ "unchecked" }) [EOL] protected <T extends JavaType> T modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, T type) throws JsonMappingException { [EOL]     AnnotationIntrospector intr = ctxt.getAnnotationIntrospector(); [EOL]     Class<?> subclass = intr.findDeserializationType(a, type); [EOL]     if (subclass != null) { [EOL]         try { [EOL]             type = (T) type.narrowBy(subclass); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw new JsonMappingException("Failed to narrow type " + type + " with concrete-type annotation (value " + subclass.getName() + "), method '" + a.getName() + "': " + iae.getMessage(), null, iae); [EOL]         } [EOL]     } [EOL]     if (type.isContainerType()) { [EOL]         Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType()); [EOL]         if (keyClass != null) { [EOL]             if (!(type instanceof MapLikeType)) { [EOL]                 throw new JsonMappingException("Illegal key-type annotation: type " + type + " is not a Map(-like) type"); [EOL]             } [EOL]             try { [EOL]                 type = (T) ((MapLikeType) type).narrowKey(keyClass); [EOL]             } catch (IllegalArgumentException iae) { [EOL]                 throw new JsonMappingException("Failed to narrow key type " + type + " with key-type annotation (" + keyClass.getName() + "): " + iae.getMessage(), null, iae); [EOL]             } [EOL]         } [EOL]         JavaType keyType = type.getKeyType(); [EOL]         if (keyType != null && keyType.getValueHandler() == null) { [EOL]             Object kdDef = intr.findKeyDeserializer(a); [EOL]             KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef); [EOL]             if (kd != null) { [EOL]                 type = (T) ((MapLikeType) type).withKeyValueHandler(kd); [EOL]                 keyType = type.getKeyType(); [EOL]             } [EOL]         } [EOL]         Class<?> cc = intr.findDeserializationContentType(a, type.getContentType()); [EOL]         if (cc != null) { [EOL]             try { [EOL]                 type = (T) type.narrowContentsBy(cc); [EOL]             } catch (IllegalArgumentException iae) { [EOL]                 throw new JsonMappingException("Failed to narrow content type " + type + " with content-type annotation (" + cc.getName() + "): " + iae.getMessage(), null, iae); [EOL]             } [EOL]         } [EOL]         JavaType contentType = type.getContentType(); [EOL]         if (contentType.getValueHandler() == null) { [EOL]             Object cdDef = intr.findContentDeserializer(a); [EOL]             JsonDeserializer<?> cd = ctxt.deserializerInstance(a, cdDef); [EOL]             if (cd != null) { [EOL]                 type = (T) type.withContentValueHandler(cd); [EOL]             } [EOL]         } [EOL]     } [EOL]     return type; [EOL] }
@SuppressWarnings({ "unchecked" }) [EOL] protected <T extends JavaType> T modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, T type) throws JsonMappingException { [EOL]     AnnotationIntrospector intr = ctxt.getAnnotationIntrospector(); [EOL]     Class<?> subclass = intr.findDeserializationType(a, type); [EOL]     if (subclass != null) { [EOL]         try { [EOL]             type = (T) type.narrowBy(subclass); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw new JsonMappingException("Failed to narrow type " + type + " with concrete-type annotation (value " + subclass.getName() + "), method '" + a.getName() + "': " + iae.getMessage(), null, iae); [EOL]         } [EOL]     } [EOL]     if (type.isContainerType()) { [EOL]         Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType()); [EOL]         if (keyClass != null) { [EOL]             if (!(type instanceof MapLikeType)) { [EOL]                 throw new JsonMappingException("Illegal key-type annotation: type " + type + " is not a Map(-like) type"); [EOL]             } [EOL]             try { [EOL]                 type = (T) ((MapLikeType) type).narrowKey(keyClass); [EOL]             } catch (IllegalArgumentException iae) { [EOL]                 throw new JsonMappingException("Failed to narrow key type " + type + " with key-type annotation (" + keyClass.getName() + "): " + iae.getMessage(), null, iae); [EOL]             } [EOL]         } [EOL]         JavaType keyType = type.getKeyType(); [EOL]         if (keyType != null && keyType.getValueHandler() == null) { [EOL]             Object kdDef = intr.findKeyDeserializer(a); [EOL]             KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef); [EOL]             if (kd != null) { [EOL]                 type = (T) ((MapLikeType) type).withKeyValueHandler(kd); [EOL]                 keyType = type.getKeyType(); [EOL]             } [EOL]         } [EOL]         Class<?> cc = intr.findDeserializationContentType(a, type.getContentType()); [EOL]         if (cc != null) { [EOL]             try { [EOL]                 type = (T) type.narrowContentsBy(cc); [EOL]             } catch (IllegalArgumentException iae) { [EOL]                 throw new JsonMappingException("Failed to narrow content type " + type + " with content-type annotation (" + cc.getName() + "): " + iae.getMessage(), null, iae); [EOL]             } [EOL]         } [EOL]         JavaType contentType = type.getContentType(); [EOL]         if (contentType.getValueHandler() == null) { [EOL]             Object cdDef = intr.findContentDeserializer(a); [EOL]             JsonDeserializer<?> cd = ctxt.deserializerInstance(a, cdDef); [EOL]             if (cd != null) { [EOL]                 type = (T) type.withContentValueHandler(cd); [EOL]             } [EOL]         } [EOL]     } [EOL]     return type; [EOL] }
@SuppressWarnings({ "unchecked" }) [EOL] protected <T extends JavaType> T modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, T type) throws JsonMappingException { [EOL]     AnnotationIntrospector intr = ctxt.getAnnotationIntrospector(); [EOL]     Class<?> subclass = intr.findDeserializationType(a, type); [EOL]     if (subclass != null) { [EOL]         try { [EOL]             type = (T) type.narrowBy(subclass); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw new JsonMappingException("Failed to narrow type " + type + " with concrete-type annotation (value " + subclass.getName() + "), method '" + a.getName() + "': " + iae.getMessage(), null, iae); [EOL]         } [EOL]     } [EOL]     if (type.isContainerType()) { [EOL]         Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType()); [EOL]         if (keyClass != null) { [EOL]             if (!(type instanceof MapLikeType)) { [EOL]                 throw new JsonMappingException("Illegal key-type annotation: type " + type + " is not a Map(-like) type"); [EOL]             } [EOL]             try { [EOL]                 type = (T) ((MapLikeType) type).narrowKey(keyClass); [EOL]             } catch (IllegalArgumentException iae) { [EOL]                 throw new JsonMappingException("Failed to narrow key type " + type + " with key-type annotation (" + keyClass.getName() + "): " + iae.getMessage(), null, iae); [EOL]             } [EOL]         } [EOL]         JavaType keyType = type.getKeyType(); [EOL]         if (keyType != null && keyType.getValueHandler() == null) { [EOL]             Object kdDef = intr.findKeyDeserializer(a); [EOL]             KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef); [EOL]             if (kd != null) { [EOL]                 type = (T) ((MapLikeType) type).withKeyValueHandler(kd); [EOL]                 keyType = type.getKeyType(); [EOL]             } [EOL]         } [EOL]         Class<?> cc = intr.findDeserializationContentType(a, type.getContentType()); [EOL]         if (cc != null) { [EOL]             try { [EOL]                 type = (T) type.narrowContentsBy(cc); [EOL]             } catch (IllegalArgumentException iae) { [EOL]                 throw new JsonMappingException("Failed to narrow content type " + type + " with content-type annotation (" + cc.getName() + "): " + iae.getMessage(), null, iae); [EOL]             } [EOL]         } [EOL]         JavaType contentType = type.getContentType(); [EOL]         if (contentType.getValueHandler() == null) { [EOL]             Object cdDef = intr.findContentDeserializer(a); [EOL]             JsonDeserializer<?> cd = ctxt.deserializerInstance(a, cdDef); [EOL]             if (cd != null) { [EOL]                 type = (T) type.withContentValueHandler(cd); [EOL]             } [EOL]         } [EOL]     } [EOL]     return type; [EOL] }
@SuppressWarnings({ "unchecked" }) [EOL] protected <T extends JavaType> T modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, T type) throws JsonMappingException { [EOL]     AnnotationIntrospector intr = ctxt.getAnnotationIntrospector(); [EOL]     Class<?> subclass = intr.findDeserializationType(a, type); [EOL]     if (subclass != null) { [EOL]         try { [EOL]             type = (T) type.narrowBy(subclass); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw new JsonMappingException("Failed to narrow type " + type + " with concrete-type annotation (value " + subclass.getName() + "), method '" + a.getName() + "': " + iae.getMessage(), null, iae); [EOL]         } [EOL]     } [EOL]     if (type.isContainerType()) { [EOL]         Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType()); [EOL]         if (keyClass != null) { [EOL]             if (!(type instanceof MapLikeType)) { [EOL]                 throw new JsonMappingException("Illegal key-type annotation: type " + type + " is not a Map(-like) type"); [EOL]             } [EOL]             try { [EOL]                 type = (T) ((MapLikeType) type).narrowKey(keyClass); [EOL]             } catch (IllegalArgumentException iae) { [EOL]                 throw new JsonMappingException("Failed to narrow key type " + type + " with key-type annotation (" + keyClass.getName() + "): " + iae.getMessage(), null, iae); [EOL]             } [EOL]         } [EOL]         JavaType keyType = type.getKeyType(); [EOL]         if (keyType != null && keyType.getValueHandler() == null) { [EOL]             Object kdDef = intr.findKeyDeserializer(a); [EOL]             KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef); [EOL]             if (kd != null) { [EOL]                 type = (T) ((MapLikeType) type).withKeyValueHandler(kd); [EOL]                 keyType = type.getKeyType(); [EOL]             } [EOL]         } [EOL]         Class<?> cc = intr.findDeserializationContentType(a, type.getContentType()); [EOL]         if (cc != null) { [EOL]             try { [EOL]                 type = (T) type.narrowContentsBy(cc); [EOL]             } catch (IllegalArgumentException iae) { [EOL]                 throw new JsonMappingException("Failed to narrow content type " + type + " with content-type annotation (" + cc.getName() + "): " + iae.getMessage(), null, iae); [EOL]             } [EOL]         } [EOL]         JavaType contentType = type.getContentType(); [EOL]         if (contentType.getValueHandler() == null) { [EOL]             Object cdDef = intr.findContentDeserializer(a); [EOL]             JsonDeserializer<?> cd = ctxt.deserializerInstance(a, cdDef); [EOL]             if (cd != null) { [EOL]                 type = (T) type.withContentValueHandler(cd); [EOL]             } [EOL]         } [EOL]     } [EOL]     return type; [EOL] }
@SuppressWarnings({ "unchecked" }) [EOL] protected <T extends JavaType> T modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, T type) throws JsonMappingException { [EOL]     AnnotationIntrospector intr = ctxt.getAnnotationIntrospector(); [EOL]     Class<?> subclass = intr.findDeserializationType(a, type); [EOL]     if (subclass != null) { [EOL]         try { [EOL]             type = (T) type.narrowBy(subclass); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw new JsonMappingException("Failed to narrow type " + type + " with concrete-type annotation (value " + subclass.getName() + "), method '" + a.getName() + "': " + iae.getMessage(), null, iae); [EOL]         } [EOL]     } [EOL]     if (type.isContainerType()) { [EOL]         Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType()); [EOL]         if (keyClass != null) { [EOL]             if (!(type instanceof MapLikeType)) { [EOL]                 throw new JsonMappingException("Illegal key-type annotation: type " + type + " is not a Map(-like) type"); [EOL]             } [EOL]             try { [EOL]                 type = (T) ((MapLikeType) type).narrowKey(keyClass); [EOL]             } catch (IllegalArgumentException iae) { [EOL]                 throw new JsonMappingException("Failed to narrow key type " + type + " with key-type annotation (" + keyClass.getName() + "): " + iae.getMessage(), null, iae); [EOL]             } [EOL]         } [EOL]         JavaType keyType = type.getKeyType(); [EOL]         if (keyType != null && keyType.getValueHandler() == null) { [EOL]             Object kdDef = intr.findKeyDeserializer(a); [EOL]             KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef); [EOL]             if (kd != null) { [EOL]                 type = (T) ((MapLikeType) type).withKeyValueHandler(kd); [EOL]                 keyType = type.getKeyType(); [EOL]             } [EOL]         } [EOL]         Class<?> cc = intr.findDeserializationContentType(a, type.getContentType()); [EOL]         if (cc != null) { [EOL]             try { [EOL]                 type = (T) type.narrowContentsBy(cc); [EOL]             } catch (IllegalArgumentException iae) { [EOL]                 throw new JsonMappingException("Failed to narrow content type " + type + " with content-type annotation (" + cc.getName() + "): " + iae.getMessage(), null, iae); [EOL]             } [EOL]         } [EOL]         JavaType contentType = type.getContentType(); [EOL]         if (contentType.getValueHandler() == null) { [EOL]             Object cdDef = intr.findContentDeserializer(a); [EOL]             JsonDeserializer<?> cd = ctxt.deserializerInstance(a, cdDef); [EOL]             if (cd != null) { [EOL]                 type = (T) type.withContentValueHandler(cd); [EOL]             } [EOL]         } [EOL]     } [EOL]     return type; [EOL] }
protected JavaType resolveType(DeserializationContext ctxt, BeanDescription beanDesc, JavaType type, AnnotatedMember member) throws JsonMappingException { [EOL]     if (type.isContainerType()) { [EOL]         AnnotationIntrospector intr = ctxt.getAnnotationIntrospector(); [EOL]         JavaType keyType = type.getKeyType(); [EOL]         if (keyType != null) { [EOL]             Object kdDef = intr.findKeyDeserializer(member); [EOL]             KeyDeserializer kd = ctxt.keyDeserializerInstance(member, kdDef); [EOL]             if (kd != null) { [EOL]                 type = ((MapLikeType) type).withKeyValueHandler(kd); [EOL]                 keyType = type.getKeyType(); [EOL]             } [EOL]         } [EOL]         Object cdDef = intr.findContentDeserializer(member); [EOL]         JsonDeserializer<?> cd = ctxt.deserializerInstance(member, cdDef); [EOL]         if (cd != null) { [EOL]             type = type.withContentValueHandler(cd); [EOL]         } [EOL]         if (member instanceof AnnotatedMember) { [EOL]             TypeDeserializer contentTypeDeser = findPropertyContentTypeDeserializer(ctxt.getConfig(), type, (AnnotatedMember) member); [EOL]             if (contentTypeDeser != null) { [EOL]                 type = type.withContentTypeHandler(contentTypeDeser); [EOL]             } [EOL]         } [EOL]     } [EOL]     TypeDeserializer valueTypeDeser; [EOL]     if (member instanceof AnnotatedMember) { [EOL]         valueTypeDeser = findPropertyTypeDeserializer(ctxt.getConfig(), type, (AnnotatedMember) member); [EOL]     } else { [EOL]         valueTypeDeser = findTypeDeserializer(ctxt.getConfig(), type); [EOL]     } [EOL]     if (valueTypeDeser != null) { [EOL]         type = type.withTypeHandler(valueTypeDeser); [EOL]     } [EOL]     return type; [EOL] }
@SuppressWarnings("deprecation") [EOL] public com.fasterxml.jackson.databind.jsonschema.JsonSchema generateJsonSchema(Class<?> type) throws JsonMappingException { [EOL]     if (type == null) { [EOL]         throw new IllegalArgumentException("A class must be provided"); [EOL]     } [EOL]     JsonSerializer<Object> ser = findValueSerializer(type, null); [EOL]     JsonNode schemaNode = (ser instanceof SchemaAware) ? ((SchemaAware) ser).getSchema(this, null) : com.fasterxml.jackson.databind.jsonschema.JsonSchema.getDefaultSchemaNode(); [EOL]     if (!(schemaNode instanceof ObjectNode)) { [EOL]         throw new IllegalArgumentException("Class " + type.getName() + " would not be serialized as a JSON object and therefore has no schema"); [EOL]     } [EOL]     return new com.fasterxml.jackson.databind.jsonschema.JsonSchema((ObjectNode) schemaNode); [EOL] }
@SuppressWarnings("deprecation") [EOL] public com.fasterxml.jackson.databind.jsonschema.JsonSchema generateJsonSchema(Class<?> type) throws JsonMappingException { [EOL]     if (type == null) { [EOL]         throw new IllegalArgumentException("A class must be provided"); [EOL]     } [EOL]     JsonSerializer<Object> ser = findValueSerializer(type, null); [EOL]     JsonNode schemaNode = (ser instanceof SchemaAware) ? ((SchemaAware) ser).getSchema(this, null) : com.fasterxml.jackson.databind.jsonschema.JsonSchema.getDefaultSchemaNode(); [EOL]     if (!(schemaNode instanceof ObjectNode)) { [EOL]         throw new IllegalArgumentException("Class " + type.getName() + " would not be serialized as a JSON object and therefore has no schema"); [EOL]     } [EOL]     return new com.fasterxml.jackson.databind.jsonschema.JsonSchema((ObjectNode) schemaNode); [EOL] }
@SuppressWarnings("deprecation") [EOL] public com.fasterxml.jackson.databind.jsonschema.JsonSchema generateJsonSchema(Class<?> type) throws JsonMappingException { [EOL]     if (type == null) { [EOL]         throw new IllegalArgumentException("A class must be provided"); [EOL]     } [EOL]     JsonSerializer<Object> ser = findValueSerializer(type, null); [EOL]     JsonNode schemaNode = (ser instanceof SchemaAware) ? ((SchemaAware) ser).getSchema(this, null) : com.fasterxml.jackson.databind.jsonschema.JsonSchema.getDefaultSchemaNode(); [EOL]     if (!(schemaNode instanceof ObjectNode)) { [EOL]         throw new IllegalArgumentException("Class " + type.getName() + " would not be serialized as a JSON object and therefore has no schema"); [EOL]     } [EOL]     return new com.fasterxml.jackson.databind.jsonschema.JsonSchema((ObjectNode) schemaNode); [EOL] }
public boolean hasSerializerFor(Class<?> cls) { [EOL]     try { [EOL]         return _findExplicitUntypedSerializer(cls) != null; [EOL]     } catch (JsonMappingException e) { [EOL]         return false; [EOL]     } [EOL] }
public boolean hasSerializerFor(Class<?> cls) { [EOL]     try { [EOL]         return _findExplicitUntypedSerializer(cls) != null; [EOL]     } catch (JsonMappingException e) { [EOL]         return false; [EOL]     } [EOL] }
public boolean hasSerializerFor(Class<?> cls) { [EOL]     try { [EOL]         return _findExplicitUntypedSerializer(cls) != null; [EOL]     } catch (JsonMappingException e) { [EOL]         return false; [EOL]     } [EOL] }
public int cachedSerializersCount() { [EOL]     return _serializerCache.size(); [EOL] }
public void flushCachedSerializers() { [EOL]     _serializerCache.flush(); [EOL] }
@Override [EOL] public JsonSerializer<Object> serializerInstance(Annotated annotated, Object serDef) throws JsonMappingException { [EOL]     if (serDef == null) { [EOL]         return null; [EOL]     } [EOL]     JsonSerializer<?> ser; [EOL]     if (serDef instanceof JsonSerializer) { [EOL]         ser = (JsonSerializer<?>) serDef; [EOL]     } else { [EOL]         if (!(serDef instanceof Class)) { [EOL]             throw new IllegalStateException("AnnotationIntrospector returned serializer definition of type " + serDef.getClass().getName() + "; expected type JsonSerializer or Class<JsonSerializer> instead"); [EOL]         } [EOL]         Class<?> serClass = (Class<?>) serDef; [EOL]         if (serClass == JsonSerializer.None.class || serClass == NoClass.class) { [EOL]             return null; [EOL]         } [EOL]         if (!JsonSerializer.class.isAssignableFrom(serClass)) { [EOL]             throw new IllegalStateException("AnnotationIntrospector returned Class " + serClass.getName() + "; expected Class<JsonSerializer>"); [EOL]         } [EOL]         HandlerInstantiator hi = _config.getHandlerInstantiator(); [EOL]         ser = (hi == null) ? null : hi.serializerInstance(_config, annotated, serClass); [EOL]         if (ser == null) { [EOL]             ser = (JsonSerializer<?>) ClassUtil.createInstance(serClass, _config.canOverrideAccessModifiers()); [EOL]         } [EOL]     } [EOL]     return (JsonSerializer<Object>) _handleResolvable(ser); [EOL] }
@Override [EOL] public JsonSerializer<Object> serializerInstance(Annotated annotated, Object serDef) throws JsonMappingException { [EOL]     if (serDef == null) { [EOL]         return null; [EOL]     } [EOL]     JsonSerializer<?> ser; [EOL]     if (serDef instanceof JsonSerializer) { [EOL]         ser = (JsonSerializer<?>) serDef; [EOL]     } else { [EOL]         if (!(serDef instanceof Class)) { [EOL]             throw new IllegalStateException("AnnotationIntrospector returned serializer definition of type " + serDef.getClass().getName() + "; expected type JsonSerializer or Class<JsonSerializer> instead"); [EOL]         } [EOL]         Class<?> serClass = (Class<?>) serDef; [EOL]         if (serClass == JsonSerializer.None.class || serClass == NoClass.class) { [EOL]             return null; [EOL]         } [EOL]         if (!JsonSerializer.class.isAssignableFrom(serClass)) { [EOL]             throw new IllegalStateException("AnnotationIntrospector returned Class " + serClass.getName() + "; expected Class<JsonSerializer>"); [EOL]         } [EOL]         HandlerInstantiator hi = _config.getHandlerInstantiator(); [EOL]         ser = (hi == null) ? null : hi.serializerInstance(_config, annotated, serClass); [EOL]         if (ser == null) { [EOL]             ser = (JsonSerializer<?>) ClassUtil.createInstance(serClass, _config.canOverrideAccessModifiers()); [EOL]         } [EOL]     } [EOL]     return (JsonSerializer<Object>) _handleResolvable(ser); [EOL] }
@Override [EOL] public JsonSerializer<Object> serializerInstance(Annotated annotated, Object serDef) throws JsonMappingException { [EOL]     if (serDef == null) { [EOL]         return null; [EOL]     } [EOL]     JsonSerializer<?> ser; [EOL]     if (serDef instanceof JsonSerializer) { [EOL]         ser = (JsonSerializer<?>) serDef; [EOL]     } else { [EOL]         if (!(serDef instanceof Class)) { [EOL]             throw new IllegalStateException("AnnotationIntrospector returned serializer definition of type " + serDef.getClass().getName() + "; expected type JsonSerializer or Class<JsonSerializer> instead"); [EOL]         } [EOL]         Class<?> serClass = (Class<?>) serDef; [EOL]         if (serClass == JsonSerializer.None.class || serClass == NoClass.class) { [EOL]             return null; [EOL]         } [EOL]         if (!JsonSerializer.class.isAssignableFrom(serClass)) { [EOL]             throw new IllegalStateException("AnnotationIntrospector returned Class " + serClass.getName() + "; expected Class<JsonSerializer>"); [EOL]         } [EOL]         HandlerInstantiator hi = _config.getHandlerInstantiator(); [EOL]         ser = (hi == null) ? null : hi.serializerInstance(_config, annotated, serClass); [EOL]         if (ser == null) { [EOL]             ser = (JsonSerializer<?>) ClassUtil.createInstance(serClass, _config.canOverrideAccessModifiers()); [EOL]         } [EOL]     } [EOL]     return (JsonSerializer<Object>) _handleResolvable(ser); [EOL] }
@Override [EOL] public JsonSerializer<Object> serializerInstance(Annotated annotated, Object serDef) throws JsonMappingException { [EOL]     if (serDef == null) { [EOL]         return null; [EOL]     } [EOL]     JsonSerializer<?> ser; [EOL]     if (serDef instanceof JsonSerializer) { [EOL]         ser = (JsonSerializer<?>) serDef; [EOL]     } else { [EOL]         if (!(serDef instanceof Class)) { [EOL]             throw new IllegalStateException("AnnotationIntrospector returned serializer definition of type " + serDef.getClass().getName() + "; expected type JsonSerializer or Class<JsonSerializer> instead"); [EOL]         } [EOL]         Class<?> serClass = (Class<?>) serDef; [EOL]         if (serClass == JsonSerializer.None.class || serClass == NoClass.class) { [EOL]             return null; [EOL]         } [EOL]         if (!JsonSerializer.class.isAssignableFrom(serClass)) { [EOL]             throw new IllegalStateException("AnnotationIntrospector returned Class " + serClass.getName() + "; expected Class<JsonSerializer>"); [EOL]         } [EOL]         HandlerInstantiator hi = _config.getHandlerInstantiator(); [EOL]         ser = (hi == null) ? null : hi.serializerInstance(_config, annotated, serClass); [EOL]         if (ser == null) { [EOL]             ser = (JsonSerializer<?>) ClassUtil.createInstance(serClass, _config.canOverrideAccessModifiers()); [EOL]         } [EOL]     } [EOL]     return (JsonSerializer<Object>) _handleResolvable(ser); [EOL] }
@Override [EOL] public JsonSerializer<Object> serializerInstance(Annotated annotated, Object serDef) throws JsonMappingException { [EOL]     if (serDef == null) { [EOL]         return null; [EOL]     } [EOL]     JsonSerializer<?> ser; [EOL]     if (serDef instanceof JsonSerializer) { [EOL]         ser = (JsonSerializer<?>) serDef; [EOL]     } else { [EOL]         if (!(serDef instanceof Class)) { [EOL]             throw new IllegalStateException("AnnotationIntrospector returned serializer definition of type " + serDef.getClass().getName() + "; expected type JsonSerializer or Class<JsonSerializer> instead"); [EOL]         } [EOL]         Class<?> serClass = (Class<?>) serDef; [EOL]         if (serClass == JsonSerializer.None.class || serClass == NoClass.class) { [EOL]             return null; [EOL]         } [EOL]         if (!JsonSerializer.class.isAssignableFrom(serClass)) { [EOL]             throw new IllegalStateException("AnnotationIntrospector returned Class " + serClass.getName() + "; expected Class<JsonSerializer>"); [EOL]         } [EOL]         HandlerInstantiator hi = _config.getHandlerInstantiator(); [EOL]         ser = (hi == null) ? null : hi.serializerInstance(_config, annotated, serClass); [EOL]         if (ser == null) { [EOL]             ser = (JsonSerializer<?>) ClassUtil.createInstance(serClass, _config.canOverrideAccessModifiers()); [EOL]         } [EOL]     } [EOL]     return (JsonSerializer<Object>) _handleResolvable(ser); [EOL] }
@Override [EOL] public JsonSerializer<Object> serializerInstance(Annotated annotated, Object serDef) throws JsonMappingException { [EOL]     if (serDef == null) { [EOL]         return null; [EOL]     } [EOL]     JsonSerializer<?> ser; [EOL]     if (serDef instanceof JsonSerializer) { [EOL]         ser = (JsonSerializer<?>) serDef; [EOL]     } else { [EOL]         if (!(serDef instanceof Class)) { [EOL]             throw new IllegalStateException("AnnotationIntrospector returned serializer definition of type " + serDef.getClass().getName() + "; expected type JsonSerializer or Class<JsonSerializer> instead"); [EOL]         } [EOL]         Class<?> serClass = (Class<?>) serDef; [EOL]         if (serClass == JsonSerializer.None.class || serClass == NoClass.class) { [EOL]             return null; [EOL]         } [EOL]         if (!JsonSerializer.class.isAssignableFrom(serClass)) { [EOL]             throw new IllegalStateException("AnnotationIntrospector returned Class " + serClass.getName() + "; expected Class<JsonSerializer>"); [EOL]         } [EOL]         HandlerInstantiator hi = _config.getHandlerInstantiator(); [EOL]         ser = (hi == null) ? null : hi.serializerInstance(_config, annotated, serClass); [EOL]         if (ser == null) { [EOL]             ser = (JsonSerializer<?>) ClassUtil.createInstance(serClass, _config.canOverrideAccessModifiers()); [EOL]         } [EOL]     } [EOL]     return (JsonSerializer<Object>) _handleResolvable(ser); [EOL] }
@Override [EOL] public JsonSerializer<Object> serializerInstance(Annotated annotated, Object serDef) throws JsonMappingException { [EOL]     if (serDef == null) { [EOL]         return null; [EOL]     } [EOL]     JsonSerializer<?> ser; [EOL]     if (serDef instanceof JsonSerializer) { [EOL]         ser = (JsonSerializer<?>) serDef; [EOL]     } else { [EOL]         if (!(serDef instanceof Class)) { [EOL]             throw new IllegalStateException("AnnotationIntrospector returned serializer definition of type " + serDef.getClass().getName() + "; expected type JsonSerializer or Class<JsonSerializer> instead"); [EOL]         } [EOL]         Class<?> serClass = (Class<?>) serDef; [EOL]         if (serClass == JsonSerializer.None.class || serClass == NoClass.class) { [EOL]             return null; [EOL]         } [EOL]         if (!JsonSerializer.class.isAssignableFrom(serClass)) { [EOL]             throw new IllegalStateException("AnnotationIntrospector returned Class " + serClass.getName() + "; expected Class<JsonSerializer>"); [EOL]         } [EOL]         HandlerInstantiator hi = _config.getHandlerInstantiator(); [EOL]         ser = (hi == null) ? null : hi.serializerInstance(_config, annotated, serClass); [EOL]         if (ser == null) { [EOL]             ser = (JsonSerializer<?>) ClassUtil.createInstance(serClass, _config.canOverrideAccessModifiers()); [EOL]         } [EOL]     } [EOL]     return (JsonSerializer<Object>) _handleResolvable(ser); [EOL] }
@Override [EOL] public JsonSerializer<Object> serializerInstance(Annotated annotated, Object serDef) throws JsonMappingException { [EOL]     if (serDef == null) { [EOL]         return null; [EOL]     } [EOL]     JsonSerializer<?> ser; [EOL]     if (serDef instanceof JsonSerializer) { [EOL]         ser = (JsonSerializer<?>) serDef; [EOL]     } else { [EOL]         if (!(serDef instanceof Class)) { [EOL]             throw new IllegalStateException("AnnotationIntrospector returned serializer definition of type " + serDef.getClass().getName() + "; expected type JsonSerializer or Class<JsonSerializer> instead"); [EOL]         } [EOL]         Class<?> serClass = (Class<?>) serDef; [EOL]         if (serClass == JsonSerializer.None.class || serClass == NoClass.class) { [EOL]             return null; [EOL]         } [EOL]         if (!JsonSerializer.class.isAssignableFrom(serClass)) { [EOL]             throw new IllegalStateException("AnnotationIntrospector returned Class " + serClass.getName() + "; expected Class<JsonSerializer>"); [EOL]         } [EOL]         HandlerInstantiator hi = _config.getHandlerInstantiator(); [EOL]         ser = (hi == null) ? null : hi.serializerInstance(_config, annotated, serClass); [EOL]         if (ser == null) { [EOL]             ser = (JsonSerializer<?>) ClassUtil.createInstance(serClass, _config.canOverrideAccessModifiers()); [EOL]         } [EOL]     } [EOL]     return (JsonSerializer<Object>) _handleResolvable(ser); [EOL] }
protected BeanDeserializer(BeanDeserializerBase src, NameTransformer unwrapper) { [EOL]     super(src, unwrapper); [EOL] }
public BeanDeserializer(BeanDeserializerBase src, ObjectIdReader oir) { [EOL]     super(src, oir); [EOL] }
public BeanDeserializer(BeanDeserializerBase src, ObjectIdReader oir) { [EOL]     super(src, oir); [EOL] }
public BeanDeserializer(BeanDeserializerBase src, HashSet<String> ignorableProps) { [EOL]     super(src, ignorableProps); [EOL] }
public BeanDeserializer(BeanDeserializerBase src, HashSet<String> ignorableProps) { [EOL]     super(src, ignorableProps); [EOL] }
public BeanDeserializer(BeanDeserializerBase src, HashSet<String> ignorableProps) { [EOL]     super(src, ignorableProps); [EOL] }
@Override [EOL] public JsonDeserializer<Object> unwrappingDeserializer(NameTransformer unwrapper) { [EOL]     if (getClass() != BeanDeserializer.class) { [EOL]         return this; [EOL]     } [EOL]     return new BeanDeserializer(this, unwrapper); [EOL] }
@Override [EOL] public JsonDeserializer<Object> unwrappingDeserializer(NameTransformer unwrapper) { [EOL]     if (getClass() != BeanDeserializer.class) { [EOL]         return this; [EOL]     } [EOL]     return new BeanDeserializer(this, unwrapper); [EOL] }
@Override [EOL] public BeanDeserializer withObjectIdReader(ObjectIdReader oir) { [EOL]     return new BeanDeserializer(this, oir); [EOL] }
@Override [EOL] public BeanDeserializer withObjectIdReader(ObjectIdReader oir) { [EOL]     return new BeanDeserializer(this, oir); [EOL] }
@Override [EOL] public BeanDeserializer withIgnorableProperties(HashSet<String> ignorableProps) { [EOL]     return new BeanDeserializer(this, ignorableProps); [EOL] }
@Override [EOL] public BeanDeserializer withIgnorableProperties(HashSet<String> ignorableProps) { [EOL]     return new BeanDeserializer(this, ignorableProps); [EOL] }
@Override [EOL] public final Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.START_OBJECT) { [EOL]         if (_vanillaProcessing) { [EOL]             return vanillaDeserialize(jp, ctxt, jp.nextToken()); [EOL]         } [EOL]         jp.nextToken(); [EOL]         if (_objectIdReader != null) { [EOL]             return deserializeWithObjectId(jp, ctxt); [EOL]         } [EOL]         return deserializeFromObject(jp, ctxt); [EOL]     } [EOL]     return _deserializeOther(jp, ctxt, t); [EOL] }
@Override [EOL] public final Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.START_OBJECT) { [EOL]         if (_vanillaProcessing) { [EOL]             return vanillaDeserialize(jp, ctxt, jp.nextToken()); [EOL]         } [EOL]         jp.nextToken(); [EOL]         if (_objectIdReader != null) { [EOL]             return deserializeWithObjectId(jp, ctxt); [EOL]         } [EOL]         return deserializeFromObject(jp, ctxt); [EOL]     } [EOL]     return _deserializeOther(jp, ctxt, t); [EOL] }
@Override [EOL] public final Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.START_OBJECT) { [EOL]         if (_vanillaProcessing) { [EOL]             return vanillaDeserialize(jp, ctxt, jp.nextToken()); [EOL]         } [EOL]         jp.nextToken(); [EOL]         if (_objectIdReader != null) { [EOL]             return deserializeWithObjectId(jp, ctxt); [EOL]         } [EOL]         return deserializeFromObject(jp, ctxt); [EOL]     } [EOL]     return _deserializeOther(jp, ctxt, t); [EOL] }
@Override [EOL] public final Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.START_OBJECT) { [EOL]         if (_vanillaProcessing) { [EOL]             return vanillaDeserialize(jp, ctxt, jp.nextToken()); [EOL]         } [EOL]         jp.nextToken(); [EOL]         if (_objectIdReader != null) { [EOL]             return deserializeWithObjectId(jp, ctxt); [EOL]         } [EOL]         return deserializeFromObject(jp, ctxt); [EOL]     } [EOL]     return _deserializeOther(jp, ctxt, t); [EOL] }
private final Object _deserializeOther(JsonParser jp, DeserializationContext ctxt, JsonToken t) throws IOException, JsonProcessingException { [EOL]     if (t == null) { [EOL]         return _missingToken(jp, ctxt); [EOL]     } [EOL]     switch(t) { [EOL]         case VALUE_STRING: [EOL]             return deserializeFromString(jp, ctxt); [EOL]         case VALUE_NUMBER_INT: [EOL]             return deserializeFromNumber(jp, ctxt); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             return deserializeFromDouble(jp, ctxt); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_TRUE: [EOL]         case VALUE_FALSE: [EOL]             return deserializeFromBoolean(jp, ctxt); [EOL]         case START_ARRAY: [EOL]             return deserializeFromArray(jp, ctxt); [EOL]         case FIELD_NAME: [EOL]         case END_OBJECT: [EOL]             if (_vanillaProcessing) { [EOL]                 return vanillaDeserialize(jp, ctxt, t); [EOL]             } [EOL]             if (_objectIdReader != null) { [EOL]                 return deserializeWithObjectId(jp, ctxt); [EOL]             } [EOL]             return deserializeFromObject(jp, ctxt); [EOL]         default: [EOL]             throw ctxt.mappingException(getBeanClass()); [EOL]     } [EOL] }
private final Object _deserializeOther(JsonParser jp, DeserializationContext ctxt, JsonToken t) throws IOException, JsonProcessingException { [EOL]     if (t == null) { [EOL]         return _missingToken(jp, ctxt); [EOL]     } [EOL]     switch(t) { [EOL]         case VALUE_STRING: [EOL]             return deserializeFromString(jp, ctxt); [EOL]         case VALUE_NUMBER_INT: [EOL]             return deserializeFromNumber(jp, ctxt); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             return deserializeFromDouble(jp, ctxt); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_TRUE: [EOL]         case VALUE_FALSE: [EOL]             return deserializeFromBoolean(jp, ctxt); [EOL]         case START_ARRAY: [EOL]             return deserializeFromArray(jp, ctxt); [EOL]         case FIELD_NAME: [EOL]         case END_OBJECT: [EOL]             if (_vanillaProcessing) { [EOL]                 return vanillaDeserialize(jp, ctxt, t); [EOL]             } [EOL]             if (_objectIdReader != null) { [EOL]                 return deserializeWithObjectId(jp, ctxt); [EOL]             } [EOL]             return deserializeFromObject(jp, ctxt); [EOL]         default: [EOL]             throw ctxt.mappingException(getBeanClass()); [EOL]     } [EOL] }
private final Object _deserializeOther(JsonParser jp, DeserializationContext ctxt, JsonToken t) throws IOException, JsonProcessingException { [EOL]     if (t == null) { [EOL]         return _missingToken(jp, ctxt); [EOL]     } [EOL]     switch(t) { [EOL]         case VALUE_STRING: [EOL]             return deserializeFromString(jp, ctxt); [EOL]         case VALUE_NUMBER_INT: [EOL]             return deserializeFromNumber(jp, ctxt); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             return deserializeFromDouble(jp, ctxt); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_TRUE: [EOL]         case VALUE_FALSE: [EOL]             return deserializeFromBoolean(jp, ctxt); [EOL]         case START_ARRAY: [EOL]             return deserializeFromArray(jp, ctxt); [EOL]         case FIELD_NAME: [EOL]         case END_OBJECT: [EOL]             if (_vanillaProcessing) { [EOL]                 return vanillaDeserialize(jp, ctxt, t); [EOL]             } [EOL]             if (_objectIdReader != null) { [EOL]                 return deserializeWithObjectId(jp, ctxt); [EOL]             } [EOL]             return deserializeFromObject(jp, ctxt); [EOL]         default: [EOL]             throw ctxt.mappingException(getBeanClass()); [EOL]     } [EOL] }
private final Object _deserializeOther(JsonParser jp, DeserializationContext ctxt, JsonToken t) throws IOException, JsonProcessingException { [EOL]     if (t == null) { [EOL]         return _missingToken(jp, ctxt); [EOL]     } [EOL]     switch(t) { [EOL]         case VALUE_STRING: [EOL]             return deserializeFromString(jp, ctxt); [EOL]         case VALUE_NUMBER_INT: [EOL]             return deserializeFromNumber(jp, ctxt); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             return deserializeFromDouble(jp, ctxt); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_TRUE: [EOL]         case VALUE_FALSE: [EOL]             return deserializeFromBoolean(jp, ctxt); [EOL]         case START_ARRAY: [EOL]             return deserializeFromArray(jp, ctxt); [EOL]         case FIELD_NAME: [EOL]         case END_OBJECT: [EOL]             if (_vanillaProcessing) { [EOL]                 return vanillaDeserialize(jp, ctxt, t); [EOL]             } [EOL]             if (_objectIdReader != null) { [EOL]                 return deserializeWithObjectId(jp, ctxt); [EOL]             } [EOL]             return deserializeFromObject(jp, ctxt); [EOL]         default: [EOL]             throw ctxt.mappingException(getBeanClass()); [EOL]     } [EOL] }
private final Object _deserializeOther(JsonParser jp, DeserializationContext ctxt, JsonToken t) throws IOException, JsonProcessingException { [EOL]     if (t == null) { [EOL]         return _missingToken(jp, ctxt); [EOL]     } [EOL]     switch(t) { [EOL]         case VALUE_STRING: [EOL]             return deserializeFromString(jp, ctxt); [EOL]         case VALUE_NUMBER_INT: [EOL]             return deserializeFromNumber(jp, ctxt); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             return deserializeFromDouble(jp, ctxt); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_TRUE: [EOL]         case VALUE_FALSE: [EOL]             return deserializeFromBoolean(jp, ctxt); [EOL]         case START_ARRAY: [EOL]             return deserializeFromArray(jp, ctxt); [EOL]         case FIELD_NAME: [EOL]         case END_OBJECT: [EOL]             if (_vanillaProcessing) { [EOL]                 return vanillaDeserialize(jp, ctxt, t); [EOL]             } [EOL]             if (_objectIdReader != null) { [EOL]                 return deserializeWithObjectId(jp, ctxt); [EOL]             } [EOL]             return deserializeFromObject(jp, ctxt); [EOL]         default: [EOL]             throw ctxt.mappingException(getBeanClass()); [EOL]     } [EOL] }
private final Object _deserializeOther(JsonParser jp, DeserializationContext ctxt, JsonToken t) throws IOException, JsonProcessingException { [EOL]     if (t == null) { [EOL]         return _missingToken(jp, ctxt); [EOL]     } [EOL]     switch(t) { [EOL]         case VALUE_STRING: [EOL]             return deserializeFromString(jp, ctxt); [EOL]         case VALUE_NUMBER_INT: [EOL]             return deserializeFromNumber(jp, ctxt); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             return deserializeFromDouble(jp, ctxt); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_TRUE: [EOL]         case VALUE_FALSE: [EOL]             return deserializeFromBoolean(jp, ctxt); [EOL]         case START_ARRAY: [EOL]             return deserializeFromArray(jp, ctxt); [EOL]         case FIELD_NAME: [EOL]         case END_OBJECT: [EOL]             if (_vanillaProcessing) { [EOL]                 return vanillaDeserialize(jp, ctxt, t); [EOL]             } [EOL]             if (_objectIdReader != null) { [EOL]                 return deserializeWithObjectId(jp, ctxt); [EOL]             } [EOL]             return deserializeFromObject(jp, ctxt); [EOL]         default: [EOL]             throw ctxt.mappingException(getBeanClass()); [EOL]     } [EOL] }
private final Object _deserializeOther(JsonParser jp, DeserializationContext ctxt, JsonToken t) throws IOException, JsonProcessingException { [EOL]     if (t == null) { [EOL]         return _missingToken(jp, ctxt); [EOL]     } [EOL]     switch(t) { [EOL]         case VALUE_STRING: [EOL]             return deserializeFromString(jp, ctxt); [EOL]         case VALUE_NUMBER_INT: [EOL]             return deserializeFromNumber(jp, ctxt); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             return deserializeFromDouble(jp, ctxt); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_TRUE: [EOL]         case VALUE_FALSE: [EOL]             return deserializeFromBoolean(jp, ctxt); [EOL]         case START_ARRAY: [EOL]             return deserializeFromArray(jp, ctxt); [EOL]         case FIELD_NAME: [EOL]         case END_OBJECT: [EOL]             if (_vanillaProcessing) { [EOL]                 return vanillaDeserialize(jp, ctxt, t); [EOL]             } [EOL]             if (_objectIdReader != null) { [EOL]                 return deserializeWithObjectId(jp, ctxt); [EOL]             } [EOL]             return deserializeFromObject(jp, ctxt); [EOL]         default: [EOL]             throw ctxt.mappingException(getBeanClass()); [EOL]     } [EOL] }
private final Object _deserializeOther(JsonParser jp, DeserializationContext ctxt, JsonToken t) throws IOException, JsonProcessingException { [EOL]     if (t == null) { [EOL]         return _missingToken(jp, ctxt); [EOL]     } [EOL]     switch(t) { [EOL]         case VALUE_STRING: [EOL]             return deserializeFromString(jp, ctxt); [EOL]         case VALUE_NUMBER_INT: [EOL]             return deserializeFromNumber(jp, ctxt); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             return deserializeFromDouble(jp, ctxt); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_TRUE: [EOL]         case VALUE_FALSE: [EOL]             return deserializeFromBoolean(jp, ctxt); [EOL]         case START_ARRAY: [EOL]             return deserializeFromArray(jp, ctxt); [EOL]         case FIELD_NAME: [EOL]         case END_OBJECT: [EOL]             if (_vanillaProcessing) { [EOL]                 return vanillaDeserialize(jp, ctxt, t); [EOL]             } [EOL]             if (_objectIdReader != null) { [EOL]                 return deserializeWithObjectId(jp, ctxt); [EOL]             } [EOL]             return deserializeFromObject(jp, ctxt); [EOL]         default: [EOL]             throw ctxt.mappingException(getBeanClass()); [EOL]     } [EOL] }
private final Object _deserializeOther(JsonParser jp, DeserializationContext ctxt, JsonToken t) throws IOException, JsonProcessingException { [EOL]     if (t == null) { [EOL]         return _missingToken(jp, ctxt); [EOL]     } [EOL]     switch(t) { [EOL]         case VALUE_STRING: [EOL]             return deserializeFromString(jp, ctxt); [EOL]         case VALUE_NUMBER_INT: [EOL]             return deserializeFromNumber(jp, ctxt); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             return deserializeFromDouble(jp, ctxt); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_TRUE: [EOL]         case VALUE_FALSE: [EOL]             return deserializeFromBoolean(jp, ctxt); [EOL]         case START_ARRAY: [EOL]             return deserializeFromArray(jp, ctxt); [EOL]         case FIELD_NAME: [EOL]         case END_OBJECT: [EOL]             if (_vanillaProcessing) { [EOL]                 return vanillaDeserialize(jp, ctxt, t); [EOL]             } [EOL]             if (_objectIdReader != null) { [EOL]                 return deserializeWithObjectId(jp, ctxt); [EOL]             } [EOL]             return deserializeFromObject(jp, ctxt); [EOL]         default: [EOL]             throw ctxt.mappingException(getBeanClass()); [EOL]     } [EOL] }
private final Object _deserializeOther(JsonParser jp, DeserializationContext ctxt, JsonToken t) throws IOException, JsonProcessingException { [EOL]     if (t == null) { [EOL]         return _missingToken(jp, ctxt); [EOL]     } [EOL]     switch(t) { [EOL]         case VALUE_STRING: [EOL]             return deserializeFromString(jp, ctxt); [EOL]         case VALUE_NUMBER_INT: [EOL]             return deserializeFromNumber(jp, ctxt); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             return deserializeFromDouble(jp, ctxt); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_TRUE: [EOL]         case VALUE_FALSE: [EOL]             return deserializeFromBoolean(jp, ctxt); [EOL]         case START_ARRAY: [EOL]             return deserializeFromArray(jp, ctxt); [EOL]         case FIELD_NAME: [EOL]         case END_OBJECT: [EOL]             if (_vanillaProcessing) { [EOL]                 return vanillaDeserialize(jp, ctxt, t); [EOL]             } [EOL]             if (_objectIdReader != null) { [EOL]                 return deserializeWithObjectId(jp, ctxt); [EOL]             } [EOL]             return deserializeFromObject(jp, ctxt); [EOL]         default: [EOL]             throw ctxt.mappingException(getBeanClass()); [EOL]     } [EOL] }
@Override [EOL] public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_nonStandardCreation) { [EOL]         if (_unwrappedPropertyHandler != null) { [EOL]             return deserializeWithUnwrapped(jp, ctxt); [EOL]         } [EOL]         if (_externalTypeIdHandler != null) { [EOL]             return deserializeWithExternalTypeId(jp, ctxt); [EOL]         } [EOL]         return deserializeFromObjectUsingNonDefault(jp, ctxt); [EOL]     } [EOL]     final Object bean = _valueInstantiator.createUsingDefault(ctxt); [EOL]     if (_injectables != null) { [EOL]         injectValues(ctxt, bean); [EOL]     } [EOL]     if (_needViewProcesing) { [EOL]         Class<?> view = ctxt.getActiveView(); [EOL]         if (view != null) { [EOL]             return deserializeWithView(jp, ctxt, bean, view); [EOL]         } [EOL]     } [EOL]     for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         if (prop != null) { [EOL]             try { [EOL]                 prop.deserializeAndSet(jp, ctxt, bean); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]         } else if (_anySetter != null) { [EOL]             try { [EOL]                 _anySetter.deserializeAndSet(jp, ctxt, bean, propName); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } else { [EOL]             handleUnknownProperty(jp, ctxt, bean, propName); [EOL]         } [EOL]     } [EOL]     return bean; [EOL] }
@Override [EOL] public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_nonStandardCreation) { [EOL]         if (_unwrappedPropertyHandler != null) { [EOL]             return deserializeWithUnwrapped(jp, ctxt); [EOL]         } [EOL]         if (_externalTypeIdHandler != null) { [EOL]             return deserializeWithExternalTypeId(jp, ctxt); [EOL]         } [EOL]         return deserializeFromObjectUsingNonDefault(jp, ctxt); [EOL]     } [EOL]     final Object bean = _valueInstantiator.createUsingDefault(ctxt); [EOL]     if (_injectables != null) { [EOL]         injectValues(ctxt, bean); [EOL]     } [EOL]     if (_needViewProcesing) { [EOL]         Class<?> view = ctxt.getActiveView(); [EOL]         if (view != null) { [EOL]             return deserializeWithView(jp, ctxt, bean, view); [EOL]         } [EOL]     } [EOL]     for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         if (prop != null) { [EOL]             try { [EOL]                 prop.deserializeAndSet(jp, ctxt, bean); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]         } else if (_anySetter != null) { [EOL]             try { [EOL]                 _anySetter.deserializeAndSet(jp, ctxt, bean, propName); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } else { [EOL]             handleUnknownProperty(jp, ctxt, bean, propName); [EOL]         } [EOL]     } [EOL]     return bean; [EOL] }
@Override [EOL] public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_nonStandardCreation) { [EOL]         if (_unwrappedPropertyHandler != null) { [EOL]             return deserializeWithUnwrapped(jp, ctxt); [EOL]         } [EOL]         if (_externalTypeIdHandler != null) { [EOL]             return deserializeWithExternalTypeId(jp, ctxt); [EOL]         } [EOL]         return deserializeFromObjectUsingNonDefault(jp, ctxt); [EOL]     } [EOL]     final Object bean = _valueInstantiator.createUsingDefault(ctxt); [EOL]     if (_injectables != null) { [EOL]         injectValues(ctxt, bean); [EOL]     } [EOL]     if (_needViewProcesing) { [EOL]         Class<?> view = ctxt.getActiveView(); [EOL]         if (view != null) { [EOL]             return deserializeWithView(jp, ctxt, bean, view); [EOL]         } [EOL]     } [EOL]     for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         if (prop != null) { [EOL]             try { [EOL]                 prop.deserializeAndSet(jp, ctxt, bean); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]         } else if (_anySetter != null) { [EOL]             try { [EOL]                 _anySetter.deserializeAndSet(jp, ctxt, bean, propName); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } else { [EOL]             handleUnknownProperty(jp, ctxt, bean, propName); [EOL]         } [EOL]     } [EOL]     return bean; [EOL] }
@Override [EOL] public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_nonStandardCreation) { [EOL]         if (_unwrappedPropertyHandler != null) { [EOL]             return deserializeWithUnwrapped(jp, ctxt); [EOL]         } [EOL]         if (_externalTypeIdHandler != null) { [EOL]             return deserializeWithExternalTypeId(jp, ctxt); [EOL]         } [EOL]         return deserializeFromObjectUsingNonDefault(jp, ctxt); [EOL]     } [EOL]     final Object bean = _valueInstantiator.createUsingDefault(ctxt); [EOL]     if (_injectables != null) { [EOL]         injectValues(ctxt, bean); [EOL]     } [EOL]     if (_needViewProcesing) { [EOL]         Class<?> view = ctxt.getActiveView(); [EOL]         if (view != null) { [EOL]             return deserializeWithView(jp, ctxt, bean, view); [EOL]         } [EOL]     } [EOL]     for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         if (prop != null) { [EOL]             try { [EOL]                 prop.deserializeAndSet(jp, ctxt, bean); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]         } else if (_anySetter != null) { [EOL]             try { [EOL]                 _anySetter.deserializeAndSet(jp, ctxt, bean, propName); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } else { [EOL]             handleUnknownProperty(jp, ctxt, bean, propName); [EOL]         } [EOL]     } [EOL]     return bean; [EOL] }
@Override [EOL] public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_nonStandardCreation) { [EOL]         if (_unwrappedPropertyHandler != null) { [EOL]             return deserializeWithUnwrapped(jp, ctxt); [EOL]         } [EOL]         if (_externalTypeIdHandler != null) { [EOL]             return deserializeWithExternalTypeId(jp, ctxt); [EOL]         } [EOL]         return deserializeFromObjectUsingNonDefault(jp, ctxt); [EOL]     } [EOL]     final Object bean = _valueInstantiator.createUsingDefault(ctxt); [EOL]     if (_injectables != null) { [EOL]         injectValues(ctxt, bean); [EOL]     } [EOL]     if (_needViewProcesing) { [EOL]         Class<?> view = ctxt.getActiveView(); [EOL]         if (view != null) { [EOL]             return deserializeWithView(jp, ctxt, bean, view); [EOL]         } [EOL]     } [EOL]     for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         if (prop != null) { [EOL]             try { [EOL]                 prop.deserializeAndSet(jp, ctxt, bean); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]         } else if (_anySetter != null) { [EOL]             try { [EOL]                 _anySetter.deserializeAndSet(jp, ctxt, bean, propName); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } else { [EOL]             handleUnknownProperty(jp, ctxt, bean, propName); [EOL]         } [EOL]     } [EOL]     return bean; [EOL] }
@Override [EOL] public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_nonStandardCreation) { [EOL]         if (_unwrappedPropertyHandler != null) { [EOL]             return deserializeWithUnwrapped(jp, ctxt); [EOL]         } [EOL]         if (_externalTypeIdHandler != null) { [EOL]             return deserializeWithExternalTypeId(jp, ctxt); [EOL]         } [EOL]         return deserializeFromObjectUsingNonDefault(jp, ctxt); [EOL]     } [EOL]     final Object bean = _valueInstantiator.createUsingDefault(ctxt); [EOL]     if (_injectables != null) { [EOL]         injectValues(ctxt, bean); [EOL]     } [EOL]     if (_needViewProcesing) { [EOL]         Class<?> view = ctxt.getActiveView(); [EOL]         if (view != null) { [EOL]             return deserializeWithView(jp, ctxt, bean, view); [EOL]         } [EOL]     } [EOL]     for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         if (prop != null) { [EOL]             try { [EOL]                 prop.deserializeAndSet(jp, ctxt, bean); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]         } else if (_anySetter != null) { [EOL]             try { [EOL]                 _anySetter.deserializeAndSet(jp, ctxt, bean, propName); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } else { [EOL]             handleUnknownProperty(jp, ctxt, bean, propName); [EOL]         } [EOL]     } [EOL]     return bean; [EOL] }
@Override [EOL] protected Object _deserializeUsingPropertyBased(final JsonParser jp, final DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     final PropertyBasedCreator creator = _propertyBasedCreator; [EOL]     PropertyValueBuffer buffer = creator.startBuilding(jp, ctxt, _objectIdReader); [EOL]     TokenBuffer unknown = null; [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         SettableBeanProperty creatorProp = creator.findCreatorProperty(propName); [EOL]         if (creatorProp != null) { [EOL]             Object value = creatorProp.deserialize(jp, ctxt); [EOL]             if (buffer.assignParameter(creatorProp.getCreatorIndex(), value)) { [EOL]                 jp.nextToken(); [EOL]                 Object bean; [EOL]                 try { [EOL]                     bean = creator.build(ctxt, buffer); [EOL]                 } catch (Exception e) { [EOL]                     wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt); [EOL]                     bean = null; [EOL]                 } [EOL]                 if (bean.getClass() != _beanType.getRawClass()) { [EOL]                     return handlePolymorphic(jp, ctxt, bean, unknown); [EOL]                 } [EOL]                 if (unknown != null) { [EOL]                     bean = handleUnknownProperties(ctxt, bean, unknown); [EOL]                 } [EOL]                 return deserialize(jp, ctxt, bean); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (buffer.readIdProperty(propName)) { [EOL]             continue; [EOL]         } [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         if (prop != null) { [EOL]             buffer.bufferProperty(prop, prop.deserialize(jp, ctxt)); [EOL]             continue; [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]             continue; [EOL]         } [EOL]         if (_anySetter != null) { [EOL]             buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(jp, ctxt)); [EOL]             continue; [EOL]         } [EOL]         if (unknown == null) { [EOL]             unknown = new TokenBuffer(jp.getCodec()); [EOL]         } [EOL]         unknown.writeFieldName(propName); [EOL]         unknown.copyCurrentStructure(jp); [EOL]     } [EOL]     Object bean; [EOL]     try { [EOL]         bean = creator.build(ctxt, buffer); [EOL]     } catch (Exception e) { [EOL]         wrapInstantiationProblem(e, ctxt); [EOL]         bean = null; [EOL]     } [EOL]     if (unknown != null) { [EOL]         if (bean.getClass() != _beanType.getRawClass()) { [EOL]             return handlePolymorphic(null, ctxt, bean, unknown); [EOL]         } [EOL]         return handleUnknownProperties(ctxt, bean, unknown); [EOL]     } [EOL]     return bean; [EOL] }
protected Object deserializeWithUnwrapped(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_delegateDeserializer != null) { [EOL]         return _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]     } [EOL]     if (_propertyBasedCreator != null) { [EOL]         return deserializeUsingPropertyBasedWithUnwrapped(jp, ctxt); [EOL]     } [EOL]     TokenBuffer tokens = new TokenBuffer(jp.getCodec()); [EOL]     tokens.writeStartObject(); [EOL]     final Object bean = _valueInstantiator.createUsingDefault(ctxt); [EOL]     if (_injectables != null) { [EOL]         injectValues(ctxt, bean); [EOL]     } [EOL]     final Class<?> activeView = _needViewProcesing ? ctxt.getActiveView() : null; [EOL]     for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         if (prop != null) { [EOL]             if (activeView != null && !prop.visibleInView(activeView)) { [EOL]                 jp.skipChildren(); [EOL]                 continue; [EOL]             } [EOL]             try { [EOL]                 prop.deserializeAndSet(jp, ctxt, bean); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]             continue; [EOL]         } [EOL]         tokens.writeFieldName(propName); [EOL]         tokens.copyCurrentStructure(jp); [EOL]         if (_anySetter != null) { [EOL]             try { [EOL]                 _anySetter.deserializeAndSet(jp, ctxt, bean, propName); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } [EOL]     } [EOL]     tokens.writeEndObject(); [EOL]     _unwrappedPropertyHandler.processUnwrapped(jp, ctxt, bean, tokens); [EOL]     return bean; [EOL] }
protected Object deserializeWithUnwrapped(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_delegateDeserializer != null) { [EOL]         return _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]     } [EOL]     if (_propertyBasedCreator != null) { [EOL]         return deserializeUsingPropertyBasedWithUnwrapped(jp, ctxt); [EOL]     } [EOL]     TokenBuffer tokens = new TokenBuffer(jp.getCodec()); [EOL]     tokens.writeStartObject(); [EOL]     final Object bean = _valueInstantiator.createUsingDefault(ctxt); [EOL]     if (_injectables != null) { [EOL]         injectValues(ctxt, bean); [EOL]     } [EOL]     final Class<?> activeView = _needViewProcesing ? ctxt.getActiveView() : null; [EOL]     for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         if (prop != null) { [EOL]             if (activeView != null && !prop.visibleInView(activeView)) { [EOL]                 jp.skipChildren(); [EOL]                 continue; [EOL]             } [EOL]             try { [EOL]                 prop.deserializeAndSet(jp, ctxt, bean); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]             continue; [EOL]         } [EOL]         tokens.writeFieldName(propName); [EOL]         tokens.copyCurrentStructure(jp); [EOL]         if (_anySetter != null) { [EOL]             try { [EOL]                 _anySetter.deserializeAndSet(jp, ctxt, bean, propName); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } [EOL]     } [EOL]     tokens.writeEndObject(); [EOL]     _unwrappedPropertyHandler.processUnwrapped(jp, ctxt, bean, tokens); [EOL]     return bean; [EOL] }
protected Object deserializeWithUnwrapped(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_delegateDeserializer != null) { [EOL]         return _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]     } [EOL]     if (_propertyBasedCreator != null) { [EOL]         return deserializeUsingPropertyBasedWithUnwrapped(jp, ctxt); [EOL]     } [EOL]     TokenBuffer tokens = new TokenBuffer(jp.getCodec()); [EOL]     tokens.writeStartObject(); [EOL]     final Object bean = _valueInstantiator.createUsingDefault(ctxt); [EOL]     if (_injectables != null) { [EOL]         injectValues(ctxt, bean); [EOL]     } [EOL]     final Class<?> activeView = _needViewProcesing ? ctxt.getActiveView() : null; [EOL]     for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         if (prop != null) { [EOL]             if (activeView != null && !prop.visibleInView(activeView)) { [EOL]                 jp.skipChildren(); [EOL]                 continue; [EOL]             } [EOL]             try { [EOL]                 prop.deserializeAndSet(jp, ctxt, bean); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]             continue; [EOL]         } [EOL]         tokens.writeFieldName(propName); [EOL]         tokens.copyCurrentStructure(jp); [EOL]         if (_anySetter != null) { [EOL]             try { [EOL]                 _anySetter.deserializeAndSet(jp, ctxt, bean, propName); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } [EOL]     } [EOL]     tokens.writeEndObject(); [EOL]     _unwrappedPropertyHandler.processUnwrapped(jp, ctxt, bean, tokens); [EOL]     return bean; [EOL] }
protected Object deserializeWithUnwrapped(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_delegateDeserializer != null) { [EOL]         return _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]     } [EOL]     if (_propertyBasedCreator != null) { [EOL]         return deserializeUsingPropertyBasedWithUnwrapped(jp, ctxt); [EOL]     } [EOL]     TokenBuffer tokens = new TokenBuffer(jp.getCodec()); [EOL]     tokens.writeStartObject(); [EOL]     final Object bean = _valueInstantiator.createUsingDefault(ctxt); [EOL]     if (_injectables != null) { [EOL]         injectValues(ctxt, bean); [EOL]     } [EOL]     final Class<?> activeView = _needViewProcesing ? ctxt.getActiveView() : null; [EOL]     for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         if (prop != null) { [EOL]             if (activeView != null && !prop.visibleInView(activeView)) { [EOL]                 jp.skipChildren(); [EOL]                 continue; [EOL]             } [EOL]             try { [EOL]                 prop.deserializeAndSet(jp, ctxt, bean); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]             continue; [EOL]         } [EOL]         tokens.writeFieldName(propName); [EOL]         tokens.copyCurrentStructure(jp); [EOL]         if (_anySetter != null) { [EOL]             try { [EOL]                 _anySetter.deserializeAndSet(jp, ctxt, bean, propName); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } [EOL]     } [EOL]     tokens.writeEndObject(); [EOL]     _unwrappedPropertyHandler.processUnwrapped(jp, ctxt, bean, tokens); [EOL]     return bean; [EOL] }
protected Object deserializeWithUnwrapped(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_delegateDeserializer != null) { [EOL]         return _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]     } [EOL]     if (_propertyBasedCreator != null) { [EOL]         return deserializeUsingPropertyBasedWithUnwrapped(jp, ctxt); [EOL]     } [EOL]     TokenBuffer tokens = new TokenBuffer(jp.getCodec()); [EOL]     tokens.writeStartObject(); [EOL]     final Object bean = _valueInstantiator.createUsingDefault(ctxt); [EOL]     if (_injectables != null) { [EOL]         injectValues(ctxt, bean); [EOL]     } [EOL]     final Class<?> activeView = _needViewProcesing ? ctxt.getActiveView() : null; [EOL]     for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         if (prop != null) { [EOL]             if (activeView != null && !prop.visibleInView(activeView)) { [EOL]                 jp.skipChildren(); [EOL]                 continue; [EOL]             } [EOL]             try { [EOL]                 prop.deserializeAndSet(jp, ctxt, bean); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]             continue; [EOL]         } [EOL]         tokens.writeFieldName(propName); [EOL]         tokens.copyCurrentStructure(jp); [EOL]         if (_anySetter != null) { [EOL]             try { [EOL]                 _anySetter.deserializeAndSet(jp, ctxt, bean, propName); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } [EOL]     } [EOL]     tokens.writeEndObject(); [EOL]     _unwrappedPropertyHandler.processUnwrapped(jp, ctxt, bean, tokens); [EOL]     return bean; [EOL] }
protected Object deserializeWithUnwrapped(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_delegateDeserializer != null) { [EOL]         return _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]     } [EOL]     if (_propertyBasedCreator != null) { [EOL]         return deserializeUsingPropertyBasedWithUnwrapped(jp, ctxt); [EOL]     } [EOL]     TokenBuffer tokens = new TokenBuffer(jp.getCodec()); [EOL]     tokens.writeStartObject(); [EOL]     final Object bean = _valueInstantiator.createUsingDefault(ctxt); [EOL]     if (_injectables != null) { [EOL]         injectValues(ctxt, bean); [EOL]     } [EOL]     final Class<?> activeView = _needViewProcesing ? ctxt.getActiveView() : null; [EOL]     for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         if (prop != null) { [EOL]             if (activeView != null && !prop.visibleInView(activeView)) { [EOL]                 jp.skipChildren(); [EOL]                 continue; [EOL]             } [EOL]             try { [EOL]                 prop.deserializeAndSet(jp, ctxt, bean); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]             continue; [EOL]         } [EOL]         tokens.writeFieldName(propName); [EOL]         tokens.copyCurrentStructure(jp); [EOL]         if (_anySetter != null) { [EOL]             try { [EOL]                 _anySetter.deserializeAndSet(jp, ctxt, bean, propName); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } [EOL]     } [EOL]     tokens.writeEndObject(); [EOL]     _unwrappedPropertyHandler.processUnwrapped(jp, ctxt, bean, tokens); [EOL]     return bean; [EOL] }
protected Object deserializeWithUnwrapped(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_delegateDeserializer != null) { [EOL]         return _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]     } [EOL]     if (_propertyBasedCreator != null) { [EOL]         return deserializeUsingPropertyBasedWithUnwrapped(jp, ctxt); [EOL]     } [EOL]     TokenBuffer tokens = new TokenBuffer(jp.getCodec()); [EOL]     tokens.writeStartObject(); [EOL]     final Object bean = _valueInstantiator.createUsingDefault(ctxt); [EOL]     if (_injectables != null) { [EOL]         injectValues(ctxt, bean); [EOL]     } [EOL]     final Class<?> activeView = _needViewProcesing ? ctxt.getActiveView() : null; [EOL]     for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         if (prop != null) { [EOL]             if (activeView != null && !prop.visibleInView(activeView)) { [EOL]                 jp.skipChildren(); [EOL]                 continue; [EOL]             } [EOL]             try { [EOL]                 prop.deserializeAndSet(jp, ctxt, bean); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]             continue; [EOL]         } [EOL]         tokens.writeFieldName(propName); [EOL]         tokens.copyCurrentStructure(jp); [EOL]         if (_anySetter != null) { [EOL]             try { [EOL]                 _anySetter.deserializeAndSet(jp, ctxt, bean, propName); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } [EOL]     } [EOL]     tokens.writeEndObject(); [EOL]     _unwrappedPropertyHandler.processUnwrapped(jp, ctxt, bean, tokens); [EOL]     return bean; [EOL] }
protected Object deserializeWithUnwrapped(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_delegateDeserializer != null) { [EOL]         return _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]     } [EOL]     if (_propertyBasedCreator != null) { [EOL]         return deserializeUsingPropertyBasedWithUnwrapped(jp, ctxt); [EOL]     } [EOL]     TokenBuffer tokens = new TokenBuffer(jp.getCodec()); [EOL]     tokens.writeStartObject(); [EOL]     final Object bean = _valueInstantiator.createUsingDefault(ctxt); [EOL]     if (_injectables != null) { [EOL]         injectValues(ctxt, bean); [EOL]     } [EOL]     final Class<?> activeView = _needViewProcesing ? ctxt.getActiveView() : null; [EOL]     for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         if (prop != null) { [EOL]             if (activeView != null && !prop.visibleInView(activeView)) { [EOL]                 jp.skipChildren(); [EOL]                 continue; [EOL]             } [EOL]             try { [EOL]                 prop.deserializeAndSet(jp, ctxt, bean); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]             continue; [EOL]         } [EOL]         tokens.writeFieldName(propName); [EOL]         tokens.copyCurrentStructure(jp); [EOL]         if (_anySetter != null) { [EOL]             try { [EOL]                 _anySetter.deserializeAndSet(jp, ctxt, bean, propName); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } [EOL]     } [EOL]     tokens.writeEndObject(); [EOL]     _unwrappedPropertyHandler.processUnwrapped(jp, ctxt, bean, tokens); [EOL]     return bean; [EOL] }
protected Object deserializeWithExternalTypeId(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_propertyBasedCreator != null) { [EOL]         return deserializeUsingPropertyBasedWithExternalTypeId(jp, ctxt); [EOL]     } [EOL]     return deserializeWithExternalTypeId(jp, ctxt, _valueInstantiator.createUsingDefault(ctxt)); [EOL] }
protected Object deserializeWithExternalTypeId(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_propertyBasedCreator != null) { [EOL]         return deserializeUsingPropertyBasedWithExternalTypeId(jp, ctxt); [EOL]     } [EOL]     return deserializeWithExternalTypeId(jp, ctxt, _valueInstantiator.createUsingDefault(ctxt)); [EOL] }
protected Object deserializeWithExternalTypeId(JsonParser jp, DeserializationContext ctxt, Object bean) throws IOException, JsonProcessingException { [EOL]     final Class<?> activeView = _needViewProcesing ? ctxt.getActiveView() : null; [EOL]     final ExternalTypeHandler ext = _externalTypeIdHandler.start(); [EOL]     for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         if (prop != null) { [EOL]             if (jp.getCurrentToken().isScalarValue()) { [EOL]                 ext.handleTypePropertyValue(jp, ctxt, propName, bean); [EOL]             } [EOL]             if (activeView != null && !prop.visibleInView(activeView)) { [EOL]                 jp.skipChildren(); [EOL]                 continue; [EOL]             } [EOL]             try { [EOL]                 prop.deserializeAndSet(jp, ctxt, bean); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]             continue; [EOL]         } [EOL]         if (ext.handlePropertyValue(jp, ctxt, propName, bean)) { [EOL]             continue; [EOL]         } [EOL]         if (_anySetter != null) { [EOL]             try { [EOL]                 _anySetter.deserializeAndSet(jp, ctxt, bean, propName); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         handleUnknownProperty(jp, ctxt, bean, propName); [EOL]     } [EOL]     return ext.complete(jp, ctxt, bean); [EOL] }
public EnumSerializer(EnumValues v, Boolean serializeAsIndex) { [EOL]     super(Enum.class, false); [EOL]     _values = v; [EOL]     _serializeAsIndex = serializeAsIndex; [EOL] }
public EnumSerializer(EnumValues v, Boolean serializeAsIndex) { [EOL]     super(Enum.class, false); [EOL]     _values = v; [EOL]     _serializeAsIndex = serializeAsIndex; [EOL] }
public EnumSerializer(EnumValues v, Boolean serializeAsIndex) { [EOL]     super(Enum.class, false); [EOL]     _values = v; [EOL]     _serializeAsIndex = serializeAsIndex; [EOL] }
public static EnumSerializer construct(Class<Enum<?>> enumClass, SerializationConfig config, BeanDescription beanDesc, JsonFormat.Value format) { [EOL]     AnnotationIntrospector intr = config.getAnnotationIntrospector(); [EOL]     EnumValues v = config.isEnabled(SerializationFeature.WRITE_ENUMS_USING_TO_STRING) ? EnumValues.constructFromToString(enumClass, intr) : EnumValues.constructFromName(enumClass, intr); [EOL]     Boolean serializeAsIndex = _isShapeWrittenUsingIndex(enumClass, format, true); [EOL]     return new EnumSerializer(v, serializeAsIndex); [EOL] }
public static EnumSerializer construct(Class<Enum<?>> enumClass, SerializationConfig config, BeanDescription beanDesc, JsonFormat.Value format) { [EOL]     AnnotationIntrospector intr = config.getAnnotationIntrospector(); [EOL]     EnumValues v = config.isEnabled(SerializationFeature.WRITE_ENUMS_USING_TO_STRING) ? EnumValues.constructFromToString(enumClass, intr) : EnumValues.constructFromName(enumClass, intr); [EOL]     Boolean serializeAsIndex = _isShapeWrittenUsingIndex(enumClass, format, true); [EOL]     return new EnumSerializer(v, serializeAsIndex); [EOL] }
public static EnumSerializer construct(Class<Enum<?>> enumClass, SerializationConfig config, BeanDescription beanDesc, JsonFormat.Value format) { [EOL]     AnnotationIntrospector intr = config.getAnnotationIntrospector(); [EOL]     EnumValues v = config.isEnabled(SerializationFeature.WRITE_ENUMS_USING_TO_STRING) ? EnumValues.constructFromToString(enumClass, intr) : EnumValues.constructFromName(enumClass, intr); [EOL]     Boolean serializeAsIndex = _isShapeWrittenUsingIndex(enumClass, format, true); [EOL]     return new EnumSerializer(v, serializeAsIndex); [EOL] }
public static EnumSerializer construct(Class<Enum<?>> enumClass, SerializationConfig config, BeanDescription beanDesc, JsonFormat.Value format) { [EOL]     AnnotationIntrospector intr = config.getAnnotationIntrospector(); [EOL]     EnumValues v = config.isEnabled(SerializationFeature.WRITE_ENUMS_USING_TO_STRING) ? EnumValues.constructFromToString(enumClass, intr) : EnumValues.constructFromName(enumClass, intr); [EOL]     Boolean serializeAsIndex = _isShapeWrittenUsingIndex(enumClass, format, true); [EOL]     return new EnumSerializer(v, serializeAsIndex); [EOL] }
@Override [EOL] public final void serialize(Enum<?> en, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (_serializeAsIndex(provider)) { [EOL]         jgen.writeNumber(en.ordinal()); [EOL]         return; [EOL]     } [EOL]     jgen.writeString(_values.serializedValueFor(en)); [EOL] }
@Override [EOL] public final void serialize(Enum<?> en, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (_serializeAsIndex(provider)) { [EOL]         jgen.writeNumber(en.ordinal()); [EOL]         return; [EOL]     } [EOL]     jgen.writeString(_values.serializedValueFor(en)); [EOL] }
protected static Boolean _isShapeWrittenUsingIndex(Class<?> enumClass, JsonFormat.Value format, boolean fromClass) { [EOL]     JsonFormat.Shape shape = (format == null) ? null : format.getShape(); [EOL]     if (shape == null) { [EOL]         return null; [EOL]     } [EOL]     if (shape == Shape.ANY || shape == Shape.SCALAR) { [EOL]         return null; [EOL]     } [EOL]     if (shape == Shape.STRING) { [EOL]         return Boolean.FALSE; [EOL]     } [EOL]     if (shape.isNumeric()) { [EOL]         return Boolean.TRUE; [EOL]     } [EOL]     throw new IllegalArgumentException("Unsupported serialization shape (" + shape + ") for Enum " + enumClass.getName() + ", not supported as " + (fromClass ? "class" : "property") + " annotation"); [EOL] }
protected static Boolean _isShapeWrittenUsingIndex(Class<?> enumClass, JsonFormat.Value format, boolean fromClass) { [EOL]     JsonFormat.Shape shape = (format == null) ? null : format.getShape(); [EOL]     if (shape == null) { [EOL]         return null; [EOL]     } [EOL]     if (shape == Shape.ANY || shape == Shape.SCALAR) { [EOL]         return null; [EOL]     } [EOL]     if (shape == Shape.STRING) { [EOL]         return Boolean.FALSE; [EOL]     } [EOL]     if (shape.isNumeric()) { [EOL]         return Boolean.TRUE; [EOL]     } [EOL]     throw new IllegalArgumentException("Unsupported serialization shape (" + shape + ") for Enum " + enumClass.getName() + ", not supported as " + (fromClass ? "class" : "property") + " annotation"); [EOL] }
protected static Boolean _isShapeWrittenUsingIndex(Class<?> enumClass, JsonFormat.Value format, boolean fromClass) { [EOL]     JsonFormat.Shape shape = (format == null) ? null : format.getShape(); [EOL]     if (shape == null) { [EOL]         return null; [EOL]     } [EOL]     if (shape == Shape.ANY || shape == Shape.SCALAR) { [EOL]         return null; [EOL]     } [EOL]     if (shape == Shape.STRING) { [EOL]         return Boolean.FALSE; [EOL]     } [EOL]     if (shape.isNumeric()) { [EOL]         return Boolean.TRUE; [EOL]     } [EOL]     throw new IllegalArgumentException("Unsupported serialization shape (" + shape + ") for Enum " + enumClass.getName() + ", not supported as " + (fromClass ? "class" : "property") + " annotation"); [EOL] }
protected static Boolean _isShapeWrittenUsingIndex(Class<?> enumClass, JsonFormat.Value format, boolean fromClass) { [EOL]     JsonFormat.Shape shape = (format == null) ? null : format.getShape(); [EOL]     if (shape == null) { [EOL]         return null; [EOL]     } [EOL]     if (shape == Shape.ANY || shape == Shape.SCALAR) { [EOL]         return null; [EOL]     } [EOL]     if (shape == Shape.STRING) { [EOL]         return Boolean.FALSE; [EOL]     } [EOL]     if (shape.isNumeric()) { [EOL]         return Boolean.TRUE; [EOL]     } [EOL]     throw new IllegalArgumentException("Unsupported serialization shape (" + shape + ") for Enum " + enumClass.getName() + ", not supported as " + (fromClass ? "class" : "property") + " annotation"); [EOL] }
protected static Boolean _isShapeWrittenUsingIndex(Class<?> enumClass, JsonFormat.Value format, boolean fromClass) { [EOL]     JsonFormat.Shape shape = (format == null) ? null : format.getShape(); [EOL]     if (shape == null) { [EOL]         return null; [EOL]     } [EOL]     if (shape == Shape.ANY || shape == Shape.SCALAR) { [EOL]         return null; [EOL]     } [EOL]     if (shape == Shape.STRING) { [EOL]         return Boolean.FALSE; [EOL]     } [EOL]     if (shape.isNumeric()) { [EOL]         return Boolean.TRUE; [EOL]     } [EOL]     throw new IllegalArgumentException("Unsupported serialization shape (" + shape + ") for Enum " + enumClass.getName() + ", not supported as " + (fromClass ? "class" : "property") + " annotation"); [EOL] }
protected static Boolean _isShapeWrittenUsingIndex(Class<?> enumClass, JsonFormat.Value format, boolean fromClass) { [EOL]     JsonFormat.Shape shape = (format == null) ? null : format.getShape(); [EOL]     if (shape == null) { [EOL]         return null; [EOL]     } [EOL]     if (shape == Shape.ANY || shape == Shape.SCALAR) { [EOL]         return null; [EOL]     } [EOL]     if (shape == Shape.STRING) { [EOL]         return Boolean.FALSE; [EOL]     } [EOL]     if (shape.isNumeric()) { [EOL]         return Boolean.TRUE; [EOL]     } [EOL]     throw new IllegalArgumentException("Unsupported serialization shape (" + shape + ") for Enum " + enumClass.getName() + ", not supported as " + (fromClass ? "class" : "property") + " annotation"); [EOL] }
public synchronized int size() { [EOL]     return _sharedMap.size(); [EOL] }
public synchronized int size() { [EOL]     return _sharedMap.size(); [EOL] }
public synchronized void flush() { [EOL]     _sharedMap.clear(); [EOL] }
public MemberKey(Constructor<?> ctor) { [EOL]     this("", ctor.getParameterTypes()); [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) { [EOL]         return false; [EOL]     } [EOL]     MemberKey other = (MemberKey) o; [EOL]     if (!_name.equals(other._name)) { [EOL]         return false; [EOL]     } [EOL]     Class<?>[] otherArgs = other._argTypes; [EOL]     int len = _argTypes.length; [EOL]     if (otherArgs.length != len) { [EOL]         return false; [EOL]     } [EOL]     for (int i = 0; i < len; ++i) { [EOL]         Class<?> type1 = otherArgs[i]; [EOL]         Class<?> type2 = _argTypes[i]; [EOL]         if (type1 == type2) { [EOL]             continue; [EOL]         } [EOL]         if (type1.isAssignableFrom(type2) || type2.isAssignableFrom(type1)) { [EOL]             continue; [EOL]         } [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) { [EOL]         return false; [EOL]     } [EOL]     MemberKey other = (MemberKey) o; [EOL]     if (!_name.equals(other._name)) { [EOL]         return false; [EOL]     } [EOL]     Class<?>[] otherArgs = other._argTypes; [EOL]     int len = _argTypes.length; [EOL]     if (otherArgs.length != len) { [EOL]         return false; [EOL]     } [EOL]     for (int i = 0; i < len; ++i) { [EOL]         Class<?> type1 = otherArgs[i]; [EOL]         Class<?> type2 = _argTypes[i]; [EOL]         if (type1 == type2) { [EOL]             continue; [EOL]         } [EOL]         if (type1.isAssignableFrom(type2) || type2.isAssignableFrom(type1)) { [EOL]             continue; [EOL]         } [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) { [EOL]         return false; [EOL]     } [EOL]     MemberKey other = (MemberKey) o; [EOL]     if (!_name.equals(other._name)) { [EOL]         return false; [EOL]     } [EOL]     Class<?>[] otherArgs = other._argTypes; [EOL]     int len = _argTypes.length; [EOL]     if (otherArgs.length != len) { [EOL]         return false; [EOL]     } [EOL]     for (int i = 0; i < len; ++i) { [EOL]         Class<?> type1 = otherArgs[i]; [EOL]         Class<?> type2 = _argTypes[i]; [EOL]         if (type1 == type2) { [EOL]             continue; [EOL]         } [EOL]         if (type1.isAssignableFrom(type2) || type2.isAssignableFrom(type1)) { [EOL]             continue; [EOL]         } [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) { [EOL]         return false; [EOL]     } [EOL]     MemberKey other = (MemberKey) o; [EOL]     if (!_name.equals(other._name)) { [EOL]         return false; [EOL]     } [EOL]     Class<?>[] otherArgs = other._argTypes; [EOL]     int len = _argTypes.length; [EOL]     if (otherArgs.length != len) { [EOL]         return false; [EOL]     } [EOL]     for (int i = 0; i < len; ++i) { [EOL]         Class<?> type1 = otherArgs[i]; [EOL]         Class<?> type2 = _argTypes[i]; [EOL]         if (type1 == type2) { [EOL]             continue; [EOL]         } [EOL]         if (type1.isAssignableFrom(type2) || type2.isAssignableFrom(type1)) { [EOL]             continue; [EOL]         } [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) { [EOL]         return false; [EOL]     } [EOL]     MemberKey other = (MemberKey) o; [EOL]     if (!_name.equals(other._name)) { [EOL]         return false; [EOL]     } [EOL]     Class<?>[] otherArgs = other._argTypes; [EOL]     int len = _argTypes.length; [EOL]     if (otherArgs.length != len) { [EOL]         return false; [EOL]     } [EOL]     for (int i = 0; i < len; ++i) { [EOL]         Class<?> type1 = otherArgs[i]; [EOL]         Class<?> type2 = _argTypes[i]; [EOL]         if (type1 == type2) { [EOL]             continue; [EOL]         } [EOL]         if (type1.isAssignableFrom(type2) || type2.isAssignableFrom(type1)) { [EOL]             continue; [EOL]         } [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) { [EOL]         return false; [EOL]     } [EOL]     MemberKey other = (MemberKey) o; [EOL]     if (!_name.equals(other._name)) { [EOL]         return false; [EOL]     } [EOL]     Class<?>[] otherArgs = other._argTypes; [EOL]     int len = _argTypes.length; [EOL]     if (otherArgs.length != len) { [EOL]         return false; [EOL]     } [EOL]     for (int i = 0; i < len; ++i) { [EOL]         Class<?> type1 = otherArgs[i]; [EOL]         Class<?> type2 = _argTypes[i]; [EOL]         if (type1 == type2) { [EOL]             continue; [EOL]         } [EOL]         if (type1.isAssignableFrom(type2) || type2.isAssignableFrom(type1)) { [EOL]             continue; [EOL]         } [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) { [EOL]         return false; [EOL]     } [EOL]     MemberKey other = (MemberKey) o; [EOL]     if (!_name.equals(other._name)) { [EOL]         return false; [EOL]     } [EOL]     Class<?>[] otherArgs = other._argTypes; [EOL]     int len = _argTypes.length; [EOL]     if (otherArgs.length != len) { [EOL]         return false; [EOL]     } [EOL]     for (int i = 0; i < len; ++i) { [EOL]         Class<?> type1 = otherArgs[i]; [EOL]         Class<?> type2 = _argTypes[i]; [EOL]         if (type1 == type2) { [EOL]             continue; [EOL]         } [EOL]         if (type1.isAssignableFrom(type2) || type2.isAssignableFrom(type1)) { [EOL]             continue; [EOL]         } [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) { [EOL]         return false; [EOL]     } [EOL]     MemberKey other = (MemberKey) o; [EOL]     if (!_name.equals(other._name)) { [EOL]         return false; [EOL]     } [EOL]     Class<?>[] otherArgs = other._argTypes; [EOL]     int len = _argTypes.length; [EOL]     if (otherArgs.length != len) { [EOL]         return false; [EOL]     } [EOL]     for (int i = 0; i < len; ++i) { [EOL]         Class<?> type1 = otherArgs[i]; [EOL]         Class<?> type2 = _argTypes[i]; [EOL]         if (type1 == type2) { [EOL]             continue; [EOL]         } [EOL]         if (type1.isAssignableFrom(type2) || type2.isAssignableFrom(type1)) { [EOL]             continue; [EOL]         } [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
public BeanPropertyMap renameAll(NameTransformer transformer) { [EOL]     if (transformer == null || (transformer == NameTransformer.NOP)) { [EOL]         return this; [EOL]     } [EOL]     Iterator<SettableBeanProperty> it = iterator(); [EOL]     ArrayList<SettableBeanProperty> newProps = new ArrayList<SettableBeanProperty>(); [EOL]     while (it.hasNext()) { [EOL]         SettableBeanProperty prop = it.next(); [EOL]         String newName = transformer.transform(prop.getName()); [EOL]         prop = prop.withName(newName); [EOL]         JsonDeserializer<?> deser = prop.getValueDeserializer(); [EOL]         if (deser != null) { [EOL]             @SuppressWarnings("unchecked") [EOL]             JsonDeserializer<Object> newDeser = (JsonDeserializer<Object>) deser.unwrappingDeserializer(transformer); [EOL]             if (newDeser != deser) { [EOL]                 prop = prop.withValueDeserializer(newDeser); [EOL]             } [EOL]         } [EOL]         newProps.add(prop); [EOL]     } [EOL]     return new BeanPropertyMap(newProps); [EOL] }
public BeanPropertyMap renameAll(NameTransformer transformer) { [EOL]     if (transformer == null || (transformer == NameTransformer.NOP)) { [EOL]         return this; [EOL]     } [EOL]     Iterator<SettableBeanProperty> it = iterator(); [EOL]     ArrayList<SettableBeanProperty> newProps = new ArrayList<SettableBeanProperty>(); [EOL]     while (it.hasNext()) { [EOL]         SettableBeanProperty prop = it.next(); [EOL]         String newName = transformer.transform(prop.getName()); [EOL]         prop = prop.withName(newName); [EOL]         JsonDeserializer<?> deser = prop.getValueDeserializer(); [EOL]         if (deser != null) { [EOL]             @SuppressWarnings("unchecked") [EOL]             JsonDeserializer<Object> newDeser = (JsonDeserializer<Object>) deser.unwrappingDeserializer(transformer); [EOL]             if (newDeser != deser) { [EOL]                 prop = prop.withValueDeserializer(newDeser); [EOL]             } [EOL]         } [EOL]         newProps.add(prop); [EOL]     } [EOL]     return new BeanPropertyMap(newProps); [EOL] }
public BeanPropertyMap renameAll(NameTransformer transformer) { [EOL]     if (transformer == null || (transformer == NameTransformer.NOP)) { [EOL]         return this; [EOL]     } [EOL]     Iterator<SettableBeanProperty> it = iterator(); [EOL]     ArrayList<SettableBeanProperty> newProps = new ArrayList<SettableBeanProperty>(); [EOL]     while (it.hasNext()) { [EOL]         SettableBeanProperty prop = it.next(); [EOL]         String newName = transformer.transform(prop.getName()); [EOL]         prop = prop.withName(newName); [EOL]         JsonDeserializer<?> deser = prop.getValueDeserializer(); [EOL]         if (deser != null) { [EOL]             @SuppressWarnings("unchecked") [EOL]             JsonDeserializer<Object> newDeser = (JsonDeserializer<Object>) deser.unwrappingDeserializer(transformer); [EOL]             if (newDeser != deser) { [EOL]                 prop = prop.withValueDeserializer(newDeser); [EOL]             } [EOL]         } [EOL]         newProps.add(prop); [EOL]     } [EOL]     return new BeanPropertyMap(newProps); [EOL] }
private SettableBeanProperty _findWithEquals(String key, int index) { [EOL]     Bucket bucket = _buckets[index]; [EOL]     while (bucket != null) { [EOL]         if (key.equals(bucket.key)) { [EOL]             return bucket.value; [EOL]         } [EOL]         bucket = bucket.next; [EOL]     } [EOL]     return null; [EOL] }
private SettableBeanProperty _findWithEquals(String key, int index) { [EOL]     Bucket bucket = _buckets[index]; [EOL]     while (bucket != null) { [EOL]         if (key.equals(bucket.key)) { [EOL]             return bucket.value; [EOL]         } [EOL]         bucket = bucket.next; [EOL]     } [EOL]     return null; [EOL] }
private SettableBeanProperty _findWithEquals(String key, int index) { [EOL]     Bucket bucket = _buckets[index]; [EOL]     while (bucket != null) { [EOL]         if (key.equals(bucket.key)) { [EOL]             return bucket.value; [EOL]         } [EOL]         bucket = bucket.next; [EOL]     } [EOL]     return null; [EOL] }
public static JsonDeserializer<?> forType(Class<?> rawType) { [EOL]     if (rawType == Integer.TYPE) { [EOL]         return IntDeser.instance; [EOL]     } [EOL]     if (rawType == Long.TYPE) { [EOL]         return LongDeser.instance; [EOL]     } [EOL]     if (rawType == Byte.TYPE) { [EOL]         return new ByteDeser(); [EOL]     } [EOL]     if (rawType == Short.TYPE) { [EOL]         return new ShortDeser(); [EOL]     } [EOL]     if (rawType == Float.TYPE) { [EOL]         return new FloatDeser(); [EOL]     } [EOL]     if (rawType == Double.TYPE) { [EOL]         return new DoubleDeser(); [EOL]     } [EOL]     if (rawType == Boolean.TYPE) { [EOL]         return new BooleanDeser(); [EOL]     } [EOL]     if (rawType == Character.TYPE) { [EOL]         return new CharDeser(); [EOL]     } [EOL]     throw new IllegalStateException(); [EOL] }
public static JsonDeserializer<?> forType(Class<?> rawType) { [EOL]     if (rawType == Integer.TYPE) { [EOL]         return IntDeser.instance; [EOL]     } [EOL]     if (rawType == Long.TYPE) { [EOL]         return LongDeser.instance; [EOL]     } [EOL]     if (rawType == Byte.TYPE) { [EOL]         return new ByteDeser(); [EOL]     } [EOL]     if (rawType == Short.TYPE) { [EOL]         return new ShortDeser(); [EOL]     } [EOL]     if (rawType == Float.TYPE) { [EOL]         return new FloatDeser(); [EOL]     } [EOL]     if (rawType == Double.TYPE) { [EOL]         return new DoubleDeser(); [EOL]     } [EOL]     if (rawType == Boolean.TYPE) { [EOL]         return new BooleanDeser(); [EOL]     } [EOL]     if (rawType == Character.TYPE) { [EOL]         return new CharDeser(); [EOL]     } [EOL]     throw new IllegalStateException(); [EOL] }
public static JsonDeserializer<?> forType(Class<?> rawType) { [EOL]     if (rawType == Integer.TYPE) { [EOL]         return IntDeser.instance; [EOL]     } [EOL]     if (rawType == Long.TYPE) { [EOL]         return LongDeser.instance; [EOL]     } [EOL]     if (rawType == Byte.TYPE) { [EOL]         return new ByteDeser(); [EOL]     } [EOL]     if (rawType == Short.TYPE) { [EOL]         return new ShortDeser(); [EOL]     } [EOL]     if (rawType == Float.TYPE) { [EOL]         return new FloatDeser(); [EOL]     } [EOL]     if (rawType == Double.TYPE) { [EOL]         return new DoubleDeser(); [EOL]     } [EOL]     if (rawType == Boolean.TYPE) { [EOL]         return new BooleanDeser(); [EOL]     } [EOL]     if (rawType == Character.TYPE) { [EOL]         return new CharDeser(); [EOL]     } [EOL]     throw new IllegalStateException(); [EOL] }
public static JsonDeserializer<?> forType(Class<?> rawType) { [EOL]     if (rawType == Integer.TYPE) { [EOL]         return IntDeser.instance; [EOL]     } [EOL]     if (rawType == Long.TYPE) { [EOL]         return LongDeser.instance; [EOL]     } [EOL]     if (rawType == Byte.TYPE) { [EOL]         return new ByteDeser(); [EOL]     } [EOL]     if (rawType == Short.TYPE) { [EOL]         return new ShortDeser(); [EOL]     } [EOL]     if (rawType == Float.TYPE) { [EOL]         return new FloatDeser(); [EOL]     } [EOL]     if (rawType == Double.TYPE) { [EOL]         return new DoubleDeser(); [EOL]     } [EOL]     if (rawType == Boolean.TYPE) { [EOL]         return new BooleanDeser(); [EOL]     } [EOL]     if (rawType == Character.TYPE) { [EOL]         return new CharDeser(); [EOL]     } [EOL]     throw new IllegalStateException(); [EOL] }
public static JsonDeserializer<?> forType(Class<?> rawType) { [EOL]     if (rawType == Integer.TYPE) { [EOL]         return IntDeser.instance; [EOL]     } [EOL]     if (rawType == Long.TYPE) { [EOL]         return LongDeser.instance; [EOL]     } [EOL]     if (rawType == Byte.TYPE) { [EOL]         return new ByteDeser(); [EOL]     } [EOL]     if (rawType == Short.TYPE) { [EOL]         return new ShortDeser(); [EOL]     } [EOL]     if (rawType == Float.TYPE) { [EOL]         return new FloatDeser(); [EOL]     } [EOL]     if (rawType == Double.TYPE) { [EOL]         return new DoubleDeser(); [EOL]     } [EOL]     if (rawType == Boolean.TYPE) { [EOL]         return new BooleanDeser(); [EOL]     } [EOL]     if (rawType == Character.TYPE) { [EOL]         return new CharDeser(); [EOL]     } [EOL]     throw new IllegalStateException(); [EOL] }
public static JsonDeserializer<?> forType(Class<?> rawType) { [EOL]     if (rawType == Integer.TYPE) { [EOL]         return IntDeser.instance; [EOL]     } [EOL]     if (rawType == Long.TYPE) { [EOL]         return LongDeser.instance; [EOL]     } [EOL]     if (rawType == Byte.TYPE) { [EOL]         return new ByteDeser(); [EOL]     } [EOL]     if (rawType == Short.TYPE) { [EOL]         return new ShortDeser(); [EOL]     } [EOL]     if (rawType == Float.TYPE) { [EOL]         return new FloatDeser(); [EOL]     } [EOL]     if (rawType == Double.TYPE) { [EOL]         return new DoubleDeser(); [EOL]     } [EOL]     if (rawType == Boolean.TYPE) { [EOL]         return new BooleanDeser(); [EOL]     } [EOL]     if (rawType == Character.TYPE) { [EOL]         return new CharDeser(); [EOL]     } [EOL]     throw new IllegalStateException(); [EOL] }
public static JsonDeserializer<?> forType(Class<?> rawType) { [EOL]     if (rawType == Integer.TYPE) { [EOL]         return IntDeser.instance; [EOL]     } [EOL]     if (rawType == Long.TYPE) { [EOL]         return LongDeser.instance; [EOL]     } [EOL]     if (rawType == Byte.TYPE) { [EOL]         return new ByteDeser(); [EOL]     } [EOL]     if (rawType == Short.TYPE) { [EOL]         return new ShortDeser(); [EOL]     } [EOL]     if (rawType == Float.TYPE) { [EOL]         return new FloatDeser(); [EOL]     } [EOL]     if (rawType == Double.TYPE) { [EOL]         return new DoubleDeser(); [EOL]     } [EOL]     if (rawType == Boolean.TYPE) { [EOL]         return new BooleanDeser(); [EOL]     } [EOL]     if (rawType == Character.TYPE) { [EOL]         return new CharDeser(); [EOL]     } [EOL]     throw new IllegalStateException(); [EOL] }
public static JsonDeserializer<?> forType(Class<?> rawType) { [EOL]     if (rawType == Integer.TYPE) { [EOL]         return IntDeser.instance; [EOL]     } [EOL]     if (rawType == Long.TYPE) { [EOL]         return LongDeser.instance; [EOL]     } [EOL]     if (rawType == Byte.TYPE) { [EOL]         return new ByteDeser(); [EOL]     } [EOL]     if (rawType == Short.TYPE) { [EOL]         return new ShortDeser(); [EOL]     } [EOL]     if (rawType == Float.TYPE) { [EOL]         return new FloatDeser(); [EOL]     } [EOL]     if (rawType == Double.TYPE) { [EOL]         return new DoubleDeser(); [EOL]     } [EOL]     if (rawType == Boolean.TYPE) { [EOL]         return new BooleanDeser(); [EOL]     } [EOL]     if (rawType == Character.TYPE) { [EOL]         return new CharDeser(); [EOL]     } [EOL]     throw new IllegalStateException(); [EOL] }
public static JsonDeserializer<?> forType(Class<?> rawType) { [EOL]     if (rawType == Integer.TYPE) { [EOL]         return IntDeser.instance; [EOL]     } [EOL]     if (rawType == Long.TYPE) { [EOL]         return LongDeser.instance; [EOL]     } [EOL]     if (rawType == Byte.TYPE) { [EOL]         return new ByteDeser(); [EOL]     } [EOL]     if (rawType == Short.TYPE) { [EOL]         return new ShortDeser(); [EOL]     } [EOL]     if (rawType == Float.TYPE) { [EOL]         return new FloatDeser(); [EOL]     } [EOL]     if (rawType == Double.TYPE) { [EOL]         return new DoubleDeser(); [EOL]     } [EOL]     if (rawType == Boolean.TYPE) { [EOL]         return new BooleanDeser(); [EOL]     } [EOL]     if (rawType == Character.TYPE) { [EOL]         return new CharDeser(); [EOL]     } [EOL]     throw new IllegalStateException(); [EOL] }
public CharDeser() { [EOL]     super(char[].class); [EOL] }
@Override [EOL] public char[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         char[] buffer = jp.getTextCharacters(); [EOL]         int offset = jp.getTextOffset(); [EOL]         int len = jp.getTextLength(); [EOL]         char[] result = new char[len]; [EOL]         System.arraycopy(buffer, offset, result, 0, len); [EOL]         return result; [EOL]     } [EOL]     if (jp.isExpectedStartArrayToken()) { [EOL]         StringBuilder sb = new StringBuilder(64); [EOL]         while ((t = jp.nextToken()) != JsonToken.END_ARRAY) { [EOL]             if (t != JsonToken.VALUE_STRING) { [EOL]                 throw ctxt.mappingException(Character.TYPE); [EOL]             } [EOL]             String str = jp.getText(); [EOL]             if (str.length() != 1) { [EOL]                 throw JsonMappingException.from(jp, "Can not convert a JSON String of length " + str.length() + " into a char element of char array"); [EOL]             } [EOL]             sb.append(str.charAt(0)); [EOL]         } [EOL]         return sb.toString().toCharArray(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_EMBEDDED_OBJECT) { [EOL]         Object ob = jp.getEmbeddedObject(); [EOL]         if (ob == null) [EOL]             return null; [EOL]         if (ob instanceof char[]) { [EOL]             return (char[]) ob; [EOL]         } [EOL]         if (ob instanceof String) { [EOL]             return ((String) ob).toCharArray(); [EOL]         } [EOL]         if (ob instanceof byte[]) { [EOL]             return Base64Variants.getDefaultVariant().encode((byte[]) ob, false).toCharArray(); [EOL]         } [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass); [EOL] }
@Override [EOL] public char[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         char[] buffer = jp.getTextCharacters(); [EOL]         int offset = jp.getTextOffset(); [EOL]         int len = jp.getTextLength(); [EOL]         char[] result = new char[len]; [EOL]         System.arraycopy(buffer, offset, result, 0, len); [EOL]         return result; [EOL]     } [EOL]     if (jp.isExpectedStartArrayToken()) { [EOL]         StringBuilder sb = new StringBuilder(64); [EOL]         while ((t = jp.nextToken()) != JsonToken.END_ARRAY) { [EOL]             if (t != JsonToken.VALUE_STRING) { [EOL]                 throw ctxt.mappingException(Character.TYPE); [EOL]             } [EOL]             String str = jp.getText(); [EOL]             if (str.length() != 1) { [EOL]                 throw JsonMappingException.from(jp, "Can not convert a JSON String of length " + str.length() + " into a char element of char array"); [EOL]             } [EOL]             sb.append(str.charAt(0)); [EOL]         } [EOL]         return sb.toString().toCharArray(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_EMBEDDED_OBJECT) { [EOL]         Object ob = jp.getEmbeddedObject(); [EOL]         if (ob == null) [EOL]             return null; [EOL]         if (ob instanceof char[]) { [EOL]             return (char[]) ob; [EOL]         } [EOL]         if (ob instanceof String) { [EOL]             return ((String) ob).toCharArray(); [EOL]         } [EOL]         if (ob instanceof byte[]) { [EOL]             return Base64Variants.getDefaultVariant().encode((byte[]) ob, false).toCharArray(); [EOL]         } [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass); [EOL] }
@Override [EOL] public char[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         char[] buffer = jp.getTextCharacters(); [EOL]         int offset = jp.getTextOffset(); [EOL]         int len = jp.getTextLength(); [EOL]         char[] result = new char[len]; [EOL]         System.arraycopy(buffer, offset, result, 0, len); [EOL]         return result; [EOL]     } [EOL]     if (jp.isExpectedStartArrayToken()) { [EOL]         StringBuilder sb = new StringBuilder(64); [EOL]         while ((t = jp.nextToken()) != JsonToken.END_ARRAY) { [EOL]             if (t != JsonToken.VALUE_STRING) { [EOL]                 throw ctxt.mappingException(Character.TYPE); [EOL]             } [EOL]             String str = jp.getText(); [EOL]             if (str.length() != 1) { [EOL]                 throw JsonMappingException.from(jp, "Can not convert a JSON String of length " + str.length() + " into a char element of char array"); [EOL]             } [EOL]             sb.append(str.charAt(0)); [EOL]         } [EOL]         return sb.toString().toCharArray(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_EMBEDDED_OBJECT) { [EOL]         Object ob = jp.getEmbeddedObject(); [EOL]         if (ob == null) [EOL]             return null; [EOL]         if (ob instanceof char[]) { [EOL]             return (char[]) ob; [EOL]         } [EOL]         if (ob instanceof String) { [EOL]             return ((String) ob).toCharArray(); [EOL]         } [EOL]         if (ob instanceof byte[]) { [EOL]             return Base64Variants.getDefaultVariant().encode((byte[]) ob, false).toCharArray(); [EOL]         } [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass); [EOL] }
@Override [EOL] public char[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         char[] buffer = jp.getTextCharacters(); [EOL]         int offset = jp.getTextOffset(); [EOL]         int len = jp.getTextLength(); [EOL]         char[] result = new char[len]; [EOL]         System.arraycopy(buffer, offset, result, 0, len); [EOL]         return result; [EOL]     } [EOL]     if (jp.isExpectedStartArrayToken()) { [EOL]         StringBuilder sb = new StringBuilder(64); [EOL]         while ((t = jp.nextToken()) != JsonToken.END_ARRAY) { [EOL]             if (t != JsonToken.VALUE_STRING) { [EOL]                 throw ctxt.mappingException(Character.TYPE); [EOL]             } [EOL]             String str = jp.getText(); [EOL]             if (str.length() != 1) { [EOL]                 throw JsonMappingException.from(jp, "Can not convert a JSON String of length " + str.length() + " into a char element of char array"); [EOL]             } [EOL]             sb.append(str.charAt(0)); [EOL]         } [EOL]         return sb.toString().toCharArray(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_EMBEDDED_OBJECT) { [EOL]         Object ob = jp.getEmbeddedObject(); [EOL]         if (ob == null) [EOL]             return null; [EOL]         if (ob instanceof char[]) { [EOL]             return (char[]) ob; [EOL]         } [EOL]         if (ob instanceof String) { [EOL]             return ((String) ob).toCharArray(); [EOL]         } [EOL]         if (ob instanceof byte[]) { [EOL]             return Base64Variants.getDefaultVariant().encode((byte[]) ob, false).toCharArray(); [EOL]         } [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass); [EOL] }
@Override [EOL] public char[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         char[] buffer = jp.getTextCharacters(); [EOL]         int offset = jp.getTextOffset(); [EOL]         int len = jp.getTextLength(); [EOL]         char[] result = new char[len]; [EOL]         System.arraycopy(buffer, offset, result, 0, len); [EOL]         return result; [EOL]     } [EOL]     if (jp.isExpectedStartArrayToken()) { [EOL]         StringBuilder sb = new StringBuilder(64); [EOL]         while ((t = jp.nextToken()) != JsonToken.END_ARRAY) { [EOL]             if (t != JsonToken.VALUE_STRING) { [EOL]                 throw ctxt.mappingException(Character.TYPE); [EOL]             } [EOL]             String str = jp.getText(); [EOL]             if (str.length() != 1) { [EOL]                 throw JsonMappingException.from(jp, "Can not convert a JSON String of length " + str.length() + " into a char element of char array"); [EOL]             } [EOL]             sb.append(str.charAt(0)); [EOL]         } [EOL]         return sb.toString().toCharArray(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_EMBEDDED_OBJECT) { [EOL]         Object ob = jp.getEmbeddedObject(); [EOL]         if (ob == null) [EOL]             return null; [EOL]         if (ob instanceof char[]) { [EOL]             return (char[]) ob; [EOL]         } [EOL]         if (ob instanceof String) { [EOL]             return ((String) ob).toCharArray(); [EOL]         } [EOL]         if (ob instanceof byte[]) { [EOL]             return Base64Variants.getDefaultVariant().encode((byte[]) ob, false).toCharArray(); [EOL]         } [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass); [EOL] }
@Override [EOL] public char[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         char[] buffer = jp.getTextCharacters(); [EOL]         int offset = jp.getTextOffset(); [EOL]         int len = jp.getTextLength(); [EOL]         char[] result = new char[len]; [EOL]         System.arraycopy(buffer, offset, result, 0, len); [EOL]         return result; [EOL]     } [EOL]     if (jp.isExpectedStartArrayToken()) { [EOL]         StringBuilder sb = new StringBuilder(64); [EOL]         while ((t = jp.nextToken()) != JsonToken.END_ARRAY) { [EOL]             if (t != JsonToken.VALUE_STRING) { [EOL]                 throw ctxt.mappingException(Character.TYPE); [EOL]             } [EOL]             String str = jp.getText(); [EOL]             if (str.length() != 1) { [EOL]                 throw JsonMappingException.from(jp, "Can not convert a JSON String of length " + str.length() + " into a char element of char array"); [EOL]             } [EOL]             sb.append(str.charAt(0)); [EOL]         } [EOL]         return sb.toString().toCharArray(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_EMBEDDED_OBJECT) { [EOL]         Object ob = jp.getEmbeddedObject(); [EOL]         if (ob == null) [EOL]             return null; [EOL]         if (ob instanceof char[]) { [EOL]             return (char[]) ob; [EOL]         } [EOL]         if (ob instanceof String) { [EOL]             return ((String) ob).toCharArray(); [EOL]         } [EOL]         if (ob instanceof byte[]) { [EOL]             return Base64Variants.getDefaultVariant().encode((byte[]) ob, false).toCharArray(); [EOL]         } [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass); [EOL] }
@Override [EOL] public char[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         char[] buffer = jp.getTextCharacters(); [EOL]         int offset = jp.getTextOffset(); [EOL]         int len = jp.getTextLength(); [EOL]         char[] result = new char[len]; [EOL]         System.arraycopy(buffer, offset, result, 0, len); [EOL]         return result; [EOL]     } [EOL]     if (jp.isExpectedStartArrayToken()) { [EOL]         StringBuilder sb = new StringBuilder(64); [EOL]         while ((t = jp.nextToken()) != JsonToken.END_ARRAY) { [EOL]             if (t != JsonToken.VALUE_STRING) { [EOL]                 throw ctxt.mappingException(Character.TYPE); [EOL]             } [EOL]             String str = jp.getText(); [EOL]             if (str.length() != 1) { [EOL]                 throw JsonMappingException.from(jp, "Can not convert a JSON String of length " + str.length() + " into a char element of char array"); [EOL]             } [EOL]             sb.append(str.charAt(0)); [EOL]         } [EOL]         return sb.toString().toCharArray(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_EMBEDDED_OBJECT) { [EOL]         Object ob = jp.getEmbeddedObject(); [EOL]         if (ob == null) [EOL]             return null; [EOL]         if (ob instanceof char[]) { [EOL]             return (char[]) ob; [EOL]         } [EOL]         if (ob instanceof String) { [EOL]             return ((String) ob).toCharArray(); [EOL]         } [EOL]         if (ob instanceof byte[]) { [EOL]             return Base64Variants.getDefaultVariant().encode((byte[]) ob, false).toCharArray(); [EOL]         } [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass); [EOL] }
@Override [EOL] public char[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         char[] buffer = jp.getTextCharacters(); [EOL]         int offset = jp.getTextOffset(); [EOL]         int len = jp.getTextLength(); [EOL]         char[] result = new char[len]; [EOL]         System.arraycopy(buffer, offset, result, 0, len); [EOL]         return result; [EOL]     } [EOL]     if (jp.isExpectedStartArrayToken()) { [EOL]         StringBuilder sb = new StringBuilder(64); [EOL]         while ((t = jp.nextToken()) != JsonToken.END_ARRAY) { [EOL]             if (t != JsonToken.VALUE_STRING) { [EOL]                 throw ctxt.mappingException(Character.TYPE); [EOL]             } [EOL]             String str = jp.getText(); [EOL]             if (str.length() != 1) { [EOL]                 throw JsonMappingException.from(jp, "Can not convert a JSON String of length " + str.length() + " into a char element of char array"); [EOL]             } [EOL]             sb.append(str.charAt(0)); [EOL]         } [EOL]         return sb.toString().toCharArray(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_EMBEDDED_OBJECT) { [EOL]         Object ob = jp.getEmbeddedObject(); [EOL]         if (ob == null) [EOL]             return null; [EOL]         if (ob instanceof char[]) { [EOL]             return (char[]) ob; [EOL]         } [EOL]         if (ob instanceof String) { [EOL]             return ((String) ob).toCharArray(); [EOL]         } [EOL]         if (ob instanceof byte[]) { [EOL]             return Base64Variants.getDefaultVariant().encode((byte[]) ob, false).toCharArray(); [EOL]         } [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass); [EOL] }
@Override [EOL] public char[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         char[] buffer = jp.getTextCharacters(); [EOL]         int offset = jp.getTextOffset(); [EOL]         int len = jp.getTextLength(); [EOL]         char[] result = new char[len]; [EOL]         System.arraycopy(buffer, offset, result, 0, len); [EOL]         return result; [EOL]     } [EOL]     if (jp.isExpectedStartArrayToken()) { [EOL]         StringBuilder sb = new StringBuilder(64); [EOL]         while ((t = jp.nextToken()) != JsonToken.END_ARRAY) { [EOL]             if (t != JsonToken.VALUE_STRING) { [EOL]                 throw ctxt.mappingException(Character.TYPE); [EOL]             } [EOL]             String str = jp.getText(); [EOL]             if (str.length() != 1) { [EOL]                 throw JsonMappingException.from(jp, "Can not convert a JSON String of length " + str.length() + " into a char element of char array"); [EOL]             } [EOL]             sb.append(str.charAt(0)); [EOL]         } [EOL]         return sb.toString().toCharArray(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_EMBEDDED_OBJECT) { [EOL]         Object ob = jp.getEmbeddedObject(); [EOL]         if (ob == null) [EOL]             return null; [EOL]         if (ob instanceof char[]) { [EOL]             return (char[]) ob; [EOL]         } [EOL]         if (ob instanceof String) { [EOL]             return ((String) ob).toCharArray(); [EOL]         } [EOL]         if (ob instanceof byte[]) { [EOL]             return Base64Variants.getDefaultVariant().encode((byte[]) ob, false).toCharArray(); [EOL]         } [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass); [EOL] }
@Override [EOL] public byte[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         return jp.getBinaryValue(ctxt.getBase64Variant()); [EOL]     } [EOL]     if (t == JsonToken.VALUE_EMBEDDED_OBJECT) { [EOL]         Object ob = jp.getEmbeddedObject(); [EOL]         if (ob == null) [EOL]             return null; [EOL]         if (ob instanceof byte[]) { [EOL]             return (byte[]) ob; [EOL]         } [EOL]     } [EOL]     if (!jp.isExpectedStartArrayToken()) { [EOL]         return handleNonArray(jp, ctxt); [EOL]     } [EOL]     ArrayBuilders.ByteBuilder builder = ctxt.getArrayBuilders().getByteBuilder(); [EOL]     byte[] chunk = builder.resetAndStart(); [EOL]     int ix = 0; [EOL]     while ((t = jp.nextToken()) != JsonToken.END_ARRAY) { [EOL]         byte value; [EOL]         if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]             value = jp.getByteValue(); [EOL]         } else { [EOL]             if (t != JsonToken.VALUE_NULL) { [EOL]                 throw ctxt.mappingException(_valueClass.getComponentType()); [EOL]             } [EOL]             value = (byte) 0; [EOL]         } [EOL]         if (ix >= chunk.length) { [EOL]             chunk = builder.appendCompletedChunk(chunk, ix); [EOL]             ix = 0; [EOL]         } [EOL]         chunk[ix++] = value; [EOL]     } [EOL]     return builder.completeAndClearBuffer(chunk, ix); [EOL] }
@Override [EOL] public byte[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         return jp.getBinaryValue(ctxt.getBase64Variant()); [EOL]     } [EOL]     if (t == JsonToken.VALUE_EMBEDDED_OBJECT) { [EOL]         Object ob = jp.getEmbeddedObject(); [EOL]         if (ob == null) [EOL]             return null; [EOL]         if (ob instanceof byte[]) { [EOL]             return (byte[]) ob; [EOL]         } [EOL]     } [EOL]     if (!jp.isExpectedStartArrayToken()) { [EOL]         return handleNonArray(jp, ctxt); [EOL]     } [EOL]     ArrayBuilders.ByteBuilder builder = ctxt.getArrayBuilders().getByteBuilder(); [EOL]     byte[] chunk = builder.resetAndStart(); [EOL]     int ix = 0; [EOL]     while ((t = jp.nextToken()) != JsonToken.END_ARRAY) { [EOL]         byte value; [EOL]         if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]             value = jp.getByteValue(); [EOL]         } else { [EOL]             if (t != JsonToken.VALUE_NULL) { [EOL]                 throw ctxt.mappingException(_valueClass.getComponentType()); [EOL]             } [EOL]             value = (byte) 0; [EOL]         } [EOL]         if (ix >= chunk.length) { [EOL]             chunk = builder.appendCompletedChunk(chunk, ix); [EOL]             ix = 0; [EOL]         } [EOL]         chunk[ix++] = value; [EOL]     } [EOL]     return builder.completeAndClearBuffer(chunk, ix); [EOL] }
@Override [EOL] public byte[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         return jp.getBinaryValue(ctxt.getBase64Variant()); [EOL]     } [EOL]     if (t == JsonToken.VALUE_EMBEDDED_OBJECT) { [EOL]         Object ob = jp.getEmbeddedObject(); [EOL]         if (ob == null) [EOL]             return null; [EOL]         if (ob instanceof byte[]) { [EOL]             return (byte[]) ob; [EOL]         } [EOL]     } [EOL]     if (!jp.isExpectedStartArrayToken()) { [EOL]         return handleNonArray(jp, ctxt); [EOL]     } [EOL]     ArrayBuilders.ByteBuilder builder = ctxt.getArrayBuilders().getByteBuilder(); [EOL]     byte[] chunk = builder.resetAndStart(); [EOL]     int ix = 0; [EOL]     while ((t = jp.nextToken()) != JsonToken.END_ARRAY) { [EOL]         byte value; [EOL]         if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]             value = jp.getByteValue(); [EOL]         } else { [EOL]             if (t != JsonToken.VALUE_NULL) { [EOL]                 throw ctxt.mappingException(_valueClass.getComponentType()); [EOL]             } [EOL]             value = (byte) 0; [EOL]         } [EOL]         if (ix >= chunk.length) { [EOL]             chunk = builder.appendCompletedChunk(chunk, ix); [EOL]             ix = 0; [EOL]         } [EOL]         chunk[ix++] = value; [EOL]     } [EOL]     return builder.completeAndClearBuffer(chunk, ix); [EOL] }
@Override [EOL] public byte[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         return jp.getBinaryValue(ctxt.getBase64Variant()); [EOL]     } [EOL]     if (t == JsonToken.VALUE_EMBEDDED_OBJECT) { [EOL]         Object ob = jp.getEmbeddedObject(); [EOL]         if (ob == null) [EOL]             return null; [EOL]         if (ob instanceof byte[]) { [EOL]             return (byte[]) ob; [EOL]         } [EOL]     } [EOL]     if (!jp.isExpectedStartArrayToken()) { [EOL]         return handleNonArray(jp, ctxt); [EOL]     } [EOL]     ArrayBuilders.ByteBuilder builder = ctxt.getArrayBuilders().getByteBuilder(); [EOL]     byte[] chunk = builder.resetAndStart(); [EOL]     int ix = 0; [EOL]     while ((t = jp.nextToken()) != JsonToken.END_ARRAY) { [EOL]         byte value; [EOL]         if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]             value = jp.getByteValue(); [EOL]         } else { [EOL]             if (t != JsonToken.VALUE_NULL) { [EOL]                 throw ctxt.mappingException(_valueClass.getComponentType()); [EOL]             } [EOL]             value = (byte) 0; [EOL]         } [EOL]         if (ix >= chunk.length) { [EOL]             chunk = builder.appendCompletedChunk(chunk, ix); [EOL]             ix = 0; [EOL]         } [EOL]         chunk[ix++] = value; [EOL]     } [EOL]     return builder.completeAndClearBuffer(chunk, ix); [EOL] }
@Override [EOL] public byte[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         return jp.getBinaryValue(ctxt.getBase64Variant()); [EOL]     } [EOL]     if (t == JsonToken.VALUE_EMBEDDED_OBJECT) { [EOL]         Object ob = jp.getEmbeddedObject(); [EOL]         if (ob == null) [EOL]             return null; [EOL]         if (ob instanceof byte[]) { [EOL]             return (byte[]) ob; [EOL]         } [EOL]     } [EOL]     if (!jp.isExpectedStartArrayToken()) { [EOL]         return handleNonArray(jp, ctxt); [EOL]     } [EOL]     ArrayBuilders.ByteBuilder builder = ctxt.getArrayBuilders().getByteBuilder(); [EOL]     byte[] chunk = builder.resetAndStart(); [EOL]     int ix = 0; [EOL]     while ((t = jp.nextToken()) != JsonToken.END_ARRAY) { [EOL]         byte value; [EOL]         if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]             value = jp.getByteValue(); [EOL]         } else { [EOL]             if (t != JsonToken.VALUE_NULL) { [EOL]                 throw ctxt.mappingException(_valueClass.getComponentType()); [EOL]             } [EOL]             value = (byte) 0; [EOL]         } [EOL]         if (ix >= chunk.length) { [EOL]             chunk = builder.appendCompletedChunk(chunk, ix); [EOL]             ix = 0; [EOL]         } [EOL]         chunk[ix++] = value; [EOL]     } [EOL]     return builder.completeAndClearBuffer(chunk, ix); [EOL] }
@Override [EOL] public byte[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         return jp.getBinaryValue(ctxt.getBase64Variant()); [EOL]     } [EOL]     if (t == JsonToken.VALUE_EMBEDDED_OBJECT) { [EOL]         Object ob = jp.getEmbeddedObject(); [EOL]         if (ob == null) [EOL]             return null; [EOL]         if (ob instanceof byte[]) { [EOL]             return (byte[]) ob; [EOL]         } [EOL]     } [EOL]     if (!jp.isExpectedStartArrayToken()) { [EOL]         return handleNonArray(jp, ctxt); [EOL]     } [EOL]     ArrayBuilders.ByteBuilder builder = ctxt.getArrayBuilders().getByteBuilder(); [EOL]     byte[] chunk = builder.resetAndStart(); [EOL]     int ix = 0; [EOL]     while ((t = jp.nextToken()) != JsonToken.END_ARRAY) { [EOL]         byte value; [EOL]         if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]             value = jp.getByteValue(); [EOL]         } else { [EOL]             if (t != JsonToken.VALUE_NULL) { [EOL]                 throw ctxt.mappingException(_valueClass.getComponentType()); [EOL]             } [EOL]             value = (byte) 0; [EOL]         } [EOL]         if (ix >= chunk.length) { [EOL]             chunk = builder.appendCompletedChunk(chunk, ix); [EOL]             ix = 0; [EOL]         } [EOL]         chunk[ix++] = value; [EOL]     } [EOL]     return builder.completeAndClearBuffer(chunk, ix); [EOL] }
@Override [EOL] public byte[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         return jp.getBinaryValue(ctxt.getBase64Variant()); [EOL]     } [EOL]     if (t == JsonToken.VALUE_EMBEDDED_OBJECT) { [EOL]         Object ob = jp.getEmbeddedObject(); [EOL]         if (ob == null) [EOL]             return null; [EOL]         if (ob instanceof byte[]) { [EOL]             return (byte[]) ob; [EOL]         } [EOL]     } [EOL]     if (!jp.isExpectedStartArrayToken()) { [EOL]         return handleNonArray(jp, ctxt); [EOL]     } [EOL]     ArrayBuilders.ByteBuilder builder = ctxt.getArrayBuilders().getByteBuilder(); [EOL]     byte[] chunk = builder.resetAndStart(); [EOL]     int ix = 0; [EOL]     while ((t = jp.nextToken()) != JsonToken.END_ARRAY) { [EOL]         byte value; [EOL]         if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]             value = jp.getByteValue(); [EOL]         } else { [EOL]             if (t != JsonToken.VALUE_NULL) { [EOL]                 throw ctxt.mappingException(_valueClass.getComponentType()); [EOL]             } [EOL]             value = (byte) 0; [EOL]         } [EOL]         if (ix >= chunk.length) { [EOL]             chunk = builder.appendCompletedChunk(chunk, ix); [EOL]             ix = 0; [EOL]         } [EOL]         chunk[ix++] = value; [EOL]     } [EOL]     return builder.completeAndClearBuffer(chunk, ix); [EOL] }
public ShortDeser() { [EOL]     super(short[].class); [EOL] }
@Override [EOL] public short[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (!jp.isExpectedStartArrayToken()) { [EOL]         return handleNonArray(jp, ctxt); [EOL]     } [EOL]     ArrayBuilders.ShortBuilder builder = ctxt.getArrayBuilders().getShortBuilder(); [EOL]     short[] chunk = builder.resetAndStart(); [EOL]     int ix = 0; [EOL]     while (jp.nextToken() != JsonToken.END_ARRAY) { [EOL]         short value = _parseShortPrimitive(jp, ctxt); [EOL]         if (ix >= chunk.length) { [EOL]             chunk = builder.appendCompletedChunk(chunk, ix); [EOL]             ix = 0; [EOL]         } [EOL]         chunk[ix++] = value; [EOL]     } [EOL]     return builder.completeAndClearBuffer(chunk, ix); [EOL] }
@Override [EOL] public short[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (!jp.isExpectedStartArrayToken()) { [EOL]         return handleNonArray(jp, ctxt); [EOL]     } [EOL]     ArrayBuilders.ShortBuilder builder = ctxt.getArrayBuilders().getShortBuilder(); [EOL]     short[] chunk = builder.resetAndStart(); [EOL]     int ix = 0; [EOL]     while (jp.nextToken() != JsonToken.END_ARRAY) { [EOL]         short value = _parseShortPrimitive(jp, ctxt); [EOL]         if (ix >= chunk.length) { [EOL]             chunk = builder.appendCompletedChunk(chunk, ix); [EOL]             ix = 0; [EOL]         } [EOL]         chunk[ix++] = value; [EOL]     } [EOL]     return builder.completeAndClearBuffer(chunk, ix); [EOL] }
@Override [EOL] public short[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (!jp.isExpectedStartArrayToken()) { [EOL]         return handleNonArray(jp, ctxt); [EOL]     } [EOL]     ArrayBuilders.ShortBuilder builder = ctxt.getArrayBuilders().getShortBuilder(); [EOL]     short[] chunk = builder.resetAndStart(); [EOL]     int ix = 0; [EOL]     while (jp.nextToken() != JsonToken.END_ARRAY) { [EOL]         short value = _parseShortPrimitive(jp, ctxt); [EOL]         if (ix >= chunk.length) { [EOL]             chunk = builder.appendCompletedChunk(chunk, ix); [EOL]             ix = 0; [EOL]         } [EOL]         chunk[ix++] = value; [EOL]     } [EOL]     return builder.completeAndClearBuffer(chunk, ix); [EOL] }
@Override [EOL] public short[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (!jp.isExpectedStartArrayToken()) { [EOL]         return handleNonArray(jp, ctxt); [EOL]     } [EOL]     ArrayBuilders.ShortBuilder builder = ctxt.getArrayBuilders().getShortBuilder(); [EOL]     short[] chunk = builder.resetAndStart(); [EOL]     int ix = 0; [EOL]     while (jp.nextToken() != JsonToken.END_ARRAY) { [EOL]         short value = _parseShortPrimitive(jp, ctxt); [EOL]         if (ix >= chunk.length) { [EOL]             chunk = builder.appendCompletedChunk(chunk, ix); [EOL]             ix = 0; [EOL]         } [EOL]         chunk[ix++] = value; [EOL]     } [EOL]     return builder.completeAndClearBuffer(chunk, ix); [EOL] }
public LongDeser() { [EOL]     super(long[].class); [EOL] }
@Override [EOL] public long[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (!jp.isExpectedStartArrayToken()) { [EOL]         return handleNonArray(jp, ctxt); [EOL]     } [EOL]     ArrayBuilders.LongBuilder builder = ctxt.getArrayBuilders().getLongBuilder(); [EOL]     long[] chunk = builder.resetAndStart(); [EOL]     int ix = 0; [EOL]     while (jp.nextToken() != JsonToken.END_ARRAY) { [EOL]         long value = _parseLongPrimitive(jp, ctxt); [EOL]         if (ix >= chunk.length) { [EOL]             chunk = builder.appendCompletedChunk(chunk, ix); [EOL]             ix = 0; [EOL]         } [EOL]         chunk[ix++] = value; [EOL]     } [EOL]     return builder.completeAndClearBuffer(chunk, ix); [EOL] }
@Override [EOL] public long[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (!jp.isExpectedStartArrayToken()) { [EOL]         return handleNonArray(jp, ctxt); [EOL]     } [EOL]     ArrayBuilders.LongBuilder builder = ctxt.getArrayBuilders().getLongBuilder(); [EOL]     long[] chunk = builder.resetAndStart(); [EOL]     int ix = 0; [EOL]     while (jp.nextToken() != JsonToken.END_ARRAY) { [EOL]         long value = _parseLongPrimitive(jp, ctxt); [EOL]         if (ix >= chunk.length) { [EOL]             chunk = builder.appendCompletedChunk(chunk, ix); [EOL]             ix = 0; [EOL]         } [EOL]         chunk[ix++] = value; [EOL]     } [EOL]     return builder.completeAndClearBuffer(chunk, ix); [EOL] }
@Override [EOL] public long[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (!jp.isExpectedStartArrayToken()) { [EOL]         return handleNonArray(jp, ctxt); [EOL]     } [EOL]     ArrayBuilders.LongBuilder builder = ctxt.getArrayBuilders().getLongBuilder(); [EOL]     long[] chunk = builder.resetAndStart(); [EOL]     int ix = 0; [EOL]     while (jp.nextToken() != JsonToken.END_ARRAY) { [EOL]         long value = _parseLongPrimitive(jp, ctxt); [EOL]         if (ix >= chunk.length) { [EOL]             chunk = builder.appendCompletedChunk(chunk, ix); [EOL]             ix = 0; [EOL]         } [EOL]         chunk[ix++] = value; [EOL]     } [EOL]     return builder.completeAndClearBuffer(chunk, ix); [EOL] }
@Override [EOL] public long[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (!jp.isExpectedStartArrayToken()) { [EOL]         return handleNonArray(jp, ctxt); [EOL]     } [EOL]     ArrayBuilders.LongBuilder builder = ctxt.getArrayBuilders().getLongBuilder(); [EOL]     long[] chunk = builder.resetAndStart(); [EOL]     int ix = 0; [EOL]     while (jp.nextToken() != JsonToken.END_ARRAY) { [EOL]         long value = _parseLongPrimitive(jp, ctxt); [EOL]         if (ix >= chunk.length) { [EOL]             chunk = builder.appendCompletedChunk(chunk, ix); [EOL]             ix = 0; [EOL]         } [EOL]         chunk[ix++] = value; [EOL]     } [EOL]     return builder.completeAndClearBuffer(chunk, ix); [EOL] }
public DoubleDeser() { [EOL]     super(double[].class); [EOL] }
@Override [EOL] public double[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (!jp.isExpectedStartArrayToken()) { [EOL]         return handleNonArray(jp, ctxt); [EOL]     } [EOL]     ArrayBuilders.DoubleBuilder builder = ctxt.getArrayBuilders().getDoubleBuilder(); [EOL]     double[] chunk = builder.resetAndStart(); [EOL]     int ix = 0; [EOL]     while (jp.nextToken() != JsonToken.END_ARRAY) { [EOL]         double value = _parseDoublePrimitive(jp, ctxt); [EOL]         if (ix >= chunk.length) { [EOL]             chunk = builder.appendCompletedChunk(chunk, ix); [EOL]             ix = 0; [EOL]         } [EOL]         chunk[ix++] = value; [EOL]     } [EOL]     return builder.completeAndClearBuffer(chunk, ix); [EOL] }
@Override [EOL] public double[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (!jp.isExpectedStartArrayToken()) { [EOL]         return handleNonArray(jp, ctxt); [EOL]     } [EOL]     ArrayBuilders.DoubleBuilder builder = ctxt.getArrayBuilders().getDoubleBuilder(); [EOL]     double[] chunk = builder.resetAndStart(); [EOL]     int ix = 0; [EOL]     while (jp.nextToken() != JsonToken.END_ARRAY) { [EOL]         double value = _parseDoublePrimitive(jp, ctxt); [EOL]         if (ix >= chunk.length) { [EOL]             chunk = builder.appendCompletedChunk(chunk, ix); [EOL]             ix = 0; [EOL]         } [EOL]         chunk[ix++] = value; [EOL]     } [EOL]     return builder.completeAndClearBuffer(chunk, ix); [EOL] }
@Override [EOL] public double[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (!jp.isExpectedStartArrayToken()) { [EOL]         return handleNonArray(jp, ctxt); [EOL]     } [EOL]     ArrayBuilders.DoubleBuilder builder = ctxt.getArrayBuilders().getDoubleBuilder(); [EOL]     double[] chunk = builder.resetAndStart(); [EOL]     int ix = 0; [EOL]     while (jp.nextToken() != JsonToken.END_ARRAY) { [EOL]         double value = _parseDoublePrimitive(jp, ctxt); [EOL]         if (ix >= chunk.length) { [EOL]             chunk = builder.appendCompletedChunk(chunk, ix); [EOL]             ix = 0; [EOL]         } [EOL]         chunk[ix++] = value; [EOL]     } [EOL]     return builder.completeAndClearBuffer(chunk, ix); [EOL] }
@Override [EOL] public double[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (!jp.isExpectedStartArrayToken()) { [EOL]         return handleNonArray(jp, ctxt); [EOL]     } [EOL]     ArrayBuilders.DoubleBuilder builder = ctxt.getArrayBuilders().getDoubleBuilder(); [EOL]     double[] chunk = builder.resetAndStart(); [EOL]     int ix = 0; [EOL]     while (jp.nextToken() != JsonToken.END_ARRAY) { [EOL]         double value = _parseDoublePrimitive(jp, ctxt); [EOL]         if (ix >= chunk.length) { [EOL]             chunk = builder.appendCompletedChunk(chunk, ix); [EOL]             ix = 0; [EOL]         } [EOL]         chunk[ix++] = value; [EOL]     } [EOL]     return builder.completeAndClearBuffer(chunk, ix); [EOL] }
public void inject(SettableBeanProperty[] injectableProperties) { [EOL]     for (int i = 0, len = injectableProperties.length; i < len; ++i) { [EOL]         SettableBeanProperty prop = injectableProperties[i]; [EOL]         if (prop != null) { [EOL]             _creatorParameters[i] = _context.findInjectableValue(prop.getInjectableValueId(), prop, null); [EOL]         } [EOL]     } [EOL] }
public void inject(SettableBeanProperty[] injectableProperties) { [EOL]     for (int i = 0, len = injectableProperties.length; i < len; ++i) { [EOL]         SettableBeanProperty prop = injectableProperties[i]; [EOL]         if (prop != null) { [EOL]             _creatorParameters[i] = _context.findInjectableValue(prop.getInjectableValueId(), prop, null); [EOL]         } [EOL]     } [EOL] }
public void inject(SettableBeanProperty[] injectableProperties) { [EOL]     for (int i = 0, len = injectableProperties.length; i < len; ++i) { [EOL]         SettableBeanProperty prop = injectableProperties[i]; [EOL]         if (prop != null) { [EOL]             _creatorParameters[i] = _context.findInjectableValue(prop.getInjectableValueId(), prop, null); [EOL]         } [EOL]     } [EOL] }
protected final Object[] getParameters(Object[] defaults) { [EOL]     if (defaults != null) { [EOL]         for (int i = 0, len = _creatorParameters.length; i < len; ++i) { [EOL]             if (_creatorParameters[i] == null) { [EOL]                 Object value = defaults[i]; [EOL]                 if (value != null) { [EOL]                     _creatorParameters[i] = value; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return _creatorParameters; [EOL] }
protected final Object[] getParameters(Object[] defaults) { [EOL]     if (defaults != null) { [EOL]         for (int i = 0, len = _creatorParameters.length; i < len; ++i) { [EOL]             if (_creatorParameters[i] == null) { [EOL]                 Object value = defaults[i]; [EOL]                 if (value != null) { [EOL]                     _creatorParameters[i] = value; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return _creatorParameters; [EOL] }
protected final Object[] getParameters(Object[] defaults) { [EOL]     if (defaults != null) { [EOL]         for (int i = 0, len = _creatorParameters.length; i < len; ++i) { [EOL]             if (_creatorParameters[i] == null) { [EOL]                 Object value = defaults[i]; [EOL]                 if (value != null) { [EOL]                     _creatorParameters[i] = value; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return _creatorParameters; [EOL] }
@Override [EOL] public boolean hasSingleElement(List<?> value) { [EOL]     return (value.size() == 1); [EOL] }
@Override [EOL] public boolean hasSingleElement(List<?> value) { [EOL]     return (value.size() == 1); [EOL] }
@Override [EOL] public boolean hasSingleElement(List<?> value) { [EOL]     return (value.size() == 1); [EOL] }
@Override [EOL] public void serializeContents(List<?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (_elementSerializer != null) { [EOL]         serializeContentsUsing(value, jgen, provider, _elementSerializer); [EOL]         return; [EOL]     } [EOL]     if (_valueTypeSerializer != null) { [EOL]         serializeTypedContents(value, jgen, provider); [EOL]         return; [EOL]     } [EOL]     final int len = value.size(); [EOL]     if (len == 0) { [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     try { [EOL]         PropertySerializerMap serializers = _dynamicSerializers; [EOL]         for (; i < len; ++i) { [EOL]             Object elem = value.get(i); [EOL]             if (elem == null) { [EOL]                 provider.defaultSerializeNull(jgen); [EOL]             } else { [EOL]                 Class<?> cc = elem.getClass(); [EOL]                 JsonSerializer<Object> serializer = serializers.serializerFor(cc); [EOL]                 if (serializer == null) { [EOL]                     if (_elementType.hasGenericTypes()) { [EOL]                         serializer = _findAndAddDynamic(serializers, provider.constructSpecializedType(_elementType, cc), provider); [EOL]                     } else { [EOL]                         serializer = _findAndAddDynamic(serializers, cc, provider); [EOL]                     } [EOL]                     serializers = _dynamicSerializers; [EOL]                 } [EOL]                 serializer.serialize(elem, jgen, provider); [EOL]             } [EOL]         } [EOL]     } catch (Exception e) { [EOL]         wrapAndThrow(provider, e, value, i); [EOL]     } [EOL] }
@Override [EOL] public void serializeContents(List<?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (_elementSerializer != null) { [EOL]         serializeContentsUsing(value, jgen, provider, _elementSerializer); [EOL]         return; [EOL]     } [EOL]     if (_valueTypeSerializer != null) { [EOL]         serializeTypedContents(value, jgen, provider); [EOL]         return; [EOL]     } [EOL]     final int len = value.size(); [EOL]     if (len == 0) { [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     try { [EOL]         PropertySerializerMap serializers = _dynamicSerializers; [EOL]         for (; i < len; ++i) { [EOL]             Object elem = value.get(i); [EOL]             if (elem == null) { [EOL]                 provider.defaultSerializeNull(jgen); [EOL]             } else { [EOL]                 Class<?> cc = elem.getClass(); [EOL]                 JsonSerializer<Object> serializer = serializers.serializerFor(cc); [EOL]                 if (serializer == null) { [EOL]                     if (_elementType.hasGenericTypes()) { [EOL]                         serializer = _findAndAddDynamic(serializers, provider.constructSpecializedType(_elementType, cc), provider); [EOL]                     } else { [EOL]                         serializer = _findAndAddDynamic(serializers, cc, provider); [EOL]                     } [EOL]                     serializers = _dynamicSerializers; [EOL]                 } [EOL]                 serializer.serialize(elem, jgen, provider); [EOL]             } [EOL]         } [EOL]     } catch (Exception e) { [EOL]         wrapAndThrow(provider, e, value, i); [EOL]     } [EOL] }
@Override [EOL] public void serializeContents(List<?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (_elementSerializer != null) { [EOL]         serializeContentsUsing(value, jgen, provider, _elementSerializer); [EOL]         return; [EOL]     } [EOL]     if (_valueTypeSerializer != null) { [EOL]         serializeTypedContents(value, jgen, provider); [EOL]         return; [EOL]     } [EOL]     final int len = value.size(); [EOL]     if (len == 0) { [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     try { [EOL]         PropertySerializerMap serializers = _dynamicSerializers; [EOL]         for (; i < len; ++i) { [EOL]             Object elem = value.get(i); [EOL]             if (elem == null) { [EOL]                 provider.defaultSerializeNull(jgen); [EOL]             } else { [EOL]                 Class<?> cc = elem.getClass(); [EOL]                 JsonSerializer<Object> serializer = serializers.serializerFor(cc); [EOL]                 if (serializer == null) { [EOL]                     if (_elementType.hasGenericTypes()) { [EOL]                         serializer = _findAndAddDynamic(serializers, provider.constructSpecializedType(_elementType, cc), provider); [EOL]                     } else { [EOL]                         serializer = _findAndAddDynamic(serializers, cc, provider); [EOL]                     } [EOL]                     serializers = _dynamicSerializers; [EOL]                 } [EOL]                 serializer.serialize(elem, jgen, provider); [EOL]             } [EOL]         } [EOL]     } catch (Exception e) { [EOL]         wrapAndThrow(provider, e, value, i); [EOL]     } [EOL] }
@Override [EOL] public void serializeContents(List<?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (_elementSerializer != null) { [EOL]         serializeContentsUsing(value, jgen, provider, _elementSerializer); [EOL]         return; [EOL]     } [EOL]     if (_valueTypeSerializer != null) { [EOL]         serializeTypedContents(value, jgen, provider); [EOL]         return; [EOL]     } [EOL]     final int len = value.size(); [EOL]     if (len == 0) { [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     try { [EOL]         PropertySerializerMap serializers = _dynamicSerializers; [EOL]         for (; i < len; ++i) { [EOL]             Object elem = value.get(i); [EOL]             if (elem == null) { [EOL]                 provider.defaultSerializeNull(jgen); [EOL]             } else { [EOL]                 Class<?> cc = elem.getClass(); [EOL]                 JsonSerializer<Object> serializer = serializers.serializerFor(cc); [EOL]                 if (serializer == null) { [EOL]                     if (_elementType.hasGenericTypes()) { [EOL]                         serializer = _findAndAddDynamic(serializers, provider.constructSpecializedType(_elementType, cc), provider); [EOL]                     } else { [EOL]                         serializer = _findAndAddDynamic(serializers, cc, provider); [EOL]                     } [EOL]                     serializers = _dynamicSerializers; [EOL]                 } [EOL]                 serializer.serialize(elem, jgen, provider); [EOL]             } [EOL]         } [EOL]     } catch (Exception e) { [EOL]         wrapAndThrow(provider, e, value, i); [EOL]     } [EOL] }
@Override [EOL] public void serializeContents(List<?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (_elementSerializer != null) { [EOL]         serializeContentsUsing(value, jgen, provider, _elementSerializer); [EOL]         return; [EOL]     } [EOL]     if (_valueTypeSerializer != null) { [EOL]         serializeTypedContents(value, jgen, provider); [EOL]         return; [EOL]     } [EOL]     final int len = value.size(); [EOL]     if (len == 0) { [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     try { [EOL]         PropertySerializerMap serializers = _dynamicSerializers; [EOL]         for (; i < len; ++i) { [EOL]             Object elem = value.get(i); [EOL]             if (elem == null) { [EOL]                 provider.defaultSerializeNull(jgen); [EOL]             } else { [EOL]                 Class<?> cc = elem.getClass(); [EOL]                 JsonSerializer<Object> serializer = serializers.serializerFor(cc); [EOL]                 if (serializer == null) { [EOL]                     if (_elementType.hasGenericTypes()) { [EOL]                         serializer = _findAndAddDynamic(serializers, provider.constructSpecializedType(_elementType, cc), provider); [EOL]                     } else { [EOL]                         serializer = _findAndAddDynamic(serializers, cc, provider); [EOL]                     } [EOL]                     serializers = _dynamicSerializers; [EOL]                 } [EOL]                 serializer.serialize(elem, jgen, provider); [EOL]             } [EOL]         } [EOL]     } catch (Exception e) { [EOL]         wrapAndThrow(provider, e, value, i); [EOL]     } [EOL] }
public void serializeTypedContents(List<?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     final int len = value.size(); [EOL]     if (len == 0) { [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     try { [EOL]         final TypeSerializer typeSer = _valueTypeSerializer; [EOL]         PropertySerializerMap serializers = _dynamicSerializers; [EOL]         for (; i < len; ++i) { [EOL]             Object elem = value.get(i); [EOL]             if (elem == null) { [EOL]                 provider.defaultSerializeNull(jgen); [EOL]             } else { [EOL]                 Class<?> cc = elem.getClass(); [EOL]                 JsonSerializer<Object> serializer = serializers.serializerFor(cc); [EOL]                 if (serializer == null) { [EOL]                     if (_elementType.hasGenericTypes()) { [EOL]                         serializer = _findAndAddDynamic(serializers, provider.constructSpecializedType(_elementType, cc), provider); [EOL]                     } else { [EOL]                         serializer = _findAndAddDynamic(serializers, cc, provider); [EOL]                     } [EOL]                     serializers = _dynamicSerializers; [EOL]                 } [EOL]                 serializer.serializeWithType(elem, jgen, provider, typeSer); [EOL]             } [EOL]         } [EOL]     } catch (Exception e) { [EOL]         wrapAndThrow(provider, e, value, i); [EOL]     } [EOL] }
public void serializeTypedContents(List<?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     final int len = value.size(); [EOL]     if (len == 0) { [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     try { [EOL]         final TypeSerializer typeSer = _valueTypeSerializer; [EOL]         PropertySerializerMap serializers = _dynamicSerializers; [EOL]         for (; i < len; ++i) { [EOL]             Object elem = value.get(i); [EOL]             if (elem == null) { [EOL]                 provider.defaultSerializeNull(jgen); [EOL]             } else { [EOL]                 Class<?> cc = elem.getClass(); [EOL]                 JsonSerializer<Object> serializer = serializers.serializerFor(cc); [EOL]                 if (serializer == null) { [EOL]                     if (_elementType.hasGenericTypes()) { [EOL]                         serializer = _findAndAddDynamic(serializers, provider.constructSpecializedType(_elementType, cc), provider); [EOL]                     } else { [EOL]                         serializer = _findAndAddDynamic(serializers, cc, provider); [EOL]                     } [EOL]                     serializers = _dynamicSerializers; [EOL]                 } [EOL]                 serializer.serializeWithType(elem, jgen, provider, typeSer); [EOL]             } [EOL]         } [EOL]     } catch (Exception e) { [EOL]         wrapAndThrow(provider, e, value, i); [EOL]     } [EOL] }
public void serializeTypedContents(List<?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     final int len = value.size(); [EOL]     if (len == 0) { [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     try { [EOL]         final TypeSerializer typeSer = _valueTypeSerializer; [EOL]         PropertySerializerMap serializers = _dynamicSerializers; [EOL]         for (; i < len; ++i) { [EOL]             Object elem = value.get(i); [EOL]             if (elem == null) { [EOL]                 provider.defaultSerializeNull(jgen); [EOL]             } else { [EOL]                 Class<?> cc = elem.getClass(); [EOL]                 JsonSerializer<Object> serializer = serializers.serializerFor(cc); [EOL]                 if (serializer == null) { [EOL]                     if (_elementType.hasGenericTypes()) { [EOL]                         serializer = _findAndAddDynamic(serializers, provider.constructSpecializedType(_elementType, cc), provider); [EOL]                     } else { [EOL]                         serializer = _findAndAddDynamic(serializers, cc, provider); [EOL]                     } [EOL]                     serializers = _dynamicSerializers; [EOL]                 } [EOL]                 serializer.serializeWithType(elem, jgen, provider, typeSer); [EOL]             } [EOL]         } [EOL]     } catch (Exception e) { [EOL]         wrapAndThrow(provider, e, value, i); [EOL]     } [EOL] }
public void serializeTypedContents(List<?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     final int len = value.size(); [EOL]     if (len == 0) { [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     try { [EOL]         final TypeSerializer typeSer = _valueTypeSerializer; [EOL]         PropertySerializerMap serializers = _dynamicSerializers; [EOL]         for (; i < len; ++i) { [EOL]             Object elem = value.get(i); [EOL]             if (elem == null) { [EOL]                 provider.defaultSerializeNull(jgen); [EOL]             } else { [EOL]                 Class<?> cc = elem.getClass(); [EOL]                 JsonSerializer<Object> serializer = serializers.serializerFor(cc); [EOL]                 if (serializer == null) { [EOL]                     if (_elementType.hasGenericTypes()) { [EOL]                         serializer = _findAndAddDynamic(serializers, provider.constructSpecializedType(_elementType, cc), provider); [EOL]                     } else { [EOL]                         serializer = _findAndAddDynamic(serializers, cc, provider); [EOL]                     } [EOL]                     serializers = _dynamicSerializers; [EOL]                 } [EOL]                 serializer.serializeWithType(elem, jgen, provider, typeSer); [EOL]             } [EOL]         } [EOL]     } catch (Exception e) { [EOL]         wrapAndThrow(provider, e, value, i); [EOL]     } [EOL] }
@Override [EOL] public void writeCustomTypePrefixForObject(Object value, JsonGenerator jgen, String typeId) throws IOException, JsonProcessingException { [EOL]     jgen.writeStartArray(); [EOL]     jgen.writeString(typeId); [EOL]     jgen.writeStartObject(); [EOL] }
@Override [EOL] public void writeCustomTypeSuffixForObject(Object value, JsonGenerator jgen, String typeId) throws IOException, JsonProcessingException { [EOL]     writeTypeSuffixForObject(value, jgen); [EOL] }
public final BooleanNode booleanNode(boolean v) { [EOL]     return _nodeFactory.booleanNode(v); [EOL] }
public final BooleanNode booleanNode(boolean v) { [EOL]     return _nodeFactory.booleanNode(v); [EOL] }
public final NumericNode numberNode(long v) { [EOL]     return _nodeFactory.numberNode(v); [EOL] }
public final NumericNode numberNode(long v) { [EOL]     return _nodeFactory.numberNode(v); [EOL] }
public final NumericNode numberNode(long v) { [EOL]     return _nodeFactory.numberNode(v); [EOL] }
public final NumericNode numberNode(float v) { [EOL]     return _nodeFactory.numberNode(v); [EOL] }
public final NumericNode numberNode(float v) { [EOL]     return _nodeFactory.numberNode(v); [EOL] }
public final NumericNode numberNode(float v) { [EOL]     return _nodeFactory.numberNode(v); [EOL] }
public final POJONode POJONode(Object pojo) { [EOL]     return _nodeFactory.POJONode(pojo); [EOL] }
public final POJONode POJONode(Object pojo) { [EOL]     return _nodeFactory.POJONode(pojo); [EOL] }
@SuppressWarnings("unchecked") [EOL] protected CollectionDeserializer withResolved(JsonDeserializer<?> dd, JsonDeserializer<?> vd, TypeDeserializer vtd) { [EOL]     if ((dd == _delegateDeserializer) && (vd == _valueDeserializer) && (vtd == _valueTypeDeserializer)) { [EOL]         return this; [EOL]     } [EOL]     return new CollectionDeserializer(_collectionType, (JsonDeserializer<Object>) vd, vtd, _valueInstantiator, (JsonDeserializer<Object>) dd); [EOL] }
@SuppressWarnings("unchecked") [EOL] protected CollectionDeserializer withResolved(JsonDeserializer<?> dd, JsonDeserializer<?> vd, TypeDeserializer vtd) { [EOL]     if ((dd == _delegateDeserializer) && (vd == _valueDeserializer) && (vtd == _valueTypeDeserializer)) { [EOL]         return this; [EOL]     } [EOL]     return new CollectionDeserializer(_collectionType, (JsonDeserializer<Object>) vd, vtd, _valueInstantiator, (JsonDeserializer<Object>) dd); [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) [EOL]         return false; [EOL]     return _class == ((NamedType) o)._class; [EOL] }
@Override [EOL] public boolean hasSingleElement(Object[] value) { [EOL]     return (value.length == 1); [EOL] }
@Override [EOL] public boolean hasSingleElement(Object[] value) { [EOL]     return (value.length == 1); [EOL] }
@Override [EOL] public boolean hasSingleElement(Object[] value) { [EOL]     return (value.length == 1); [EOL] }
protected Object _deserializeNonVanilla(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_nonStandardCreation) { [EOL]         return _deserializeWithCreator(jp, ctxt); [EOL]     } [EOL]     final Object bean = _valueInstantiator.createUsingDefault(ctxt); [EOL]     if (_injectables != null) { [EOL]         injectValues(ctxt, bean); [EOL]     } [EOL]     Class<?> activeView = _needViewProcesing ? ctxt.getActiveView() : null; [EOL]     final SettableBeanProperty[] props = _orderedProperties; [EOL]     int i = 0; [EOL]     final int propCount = props.length; [EOL]     while (true) { [EOL]         if (jp.nextToken() == JsonToken.END_ARRAY) { [EOL]             return bean; [EOL]         } [EOL]         if (i == propCount) { [EOL]             break; [EOL]         } [EOL]         SettableBeanProperty prop = props[i]; [EOL]         ++i; [EOL]         if (prop != null) { [EOL]             if (activeView == null || prop.visibleInView(activeView)) { [EOL]                 try { [EOL]                     prop.deserializeAndSet(jp, ctxt, bean); [EOL]                 } catch (Exception e) { [EOL]                     wrapAndThrow(e, bean, prop.getName(), ctxt); [EOL]                 } [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         jp.skipChildren(); [EOL]     } [EOL]     if (!_ignoreAllUnknown) { [EOL]         throw ctxt.mappingException("Unexpected JSON values; expected at most " + propCount + " properties (in JSON Array)"); [EOL]     } [EOL]     while (jp.nextToken() != JsonToken.END_ARRAY) { [EOL]         jp.skipChildren(); [EOL]     } [EOL]     return bean; [EOL] }
protected Object _deserializeWithCreator(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_delegateDeserializer != null) { [EOL]         return _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]     } [EOL]     if (_propertyBasedCreator != null) { [EOL]         return _deserializeUsingPropertyBased(jp, ctxt); [EOL]     } [EOL]     if (_beanType.isAbstract()) { [EOL]         throw JsonMappingException.from(jp, "Can not instantiate abstract type " + _beanType + " (need to add/enable type information?)"); [EOL]     } [EOL]     throw JsonMappingException.from(jp, "No suitable constructor found for type " + _beanType + ": can not instantiate from JSON object (need to add/enable type information?)"); [EOL] }
protected Object _deserializeWithCreator(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_delegateDeserializer != null) { [EOL]         return _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]     } [EOL]     if (_propertyBasedCreator != null) { [EOL]         return _deserializeUsingPropertyBased(jp, ctxt); [EOL]     } [EOL]     if (_beanType.isAbstract()) { [EOL]         throw JsonMappingException.from(jp, "Can not instantiate abstract type " + _beanType + " (need to add/enable type information?)"); [EOL]     } [EOL]     throw JsonMappingException.from(jp, "No suitable constructor found for type " + _beanType + ": can not instantiate from JSON object (need to add/enable type information?)"); [EOL] }
protected Object _deserializeWithCreator(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_delegateDeserializer != null) { [EOL]         return _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]     } [EOL]     if (_propertyBasedCreator != null) { [EOL]         return _deserializeUsingPropertyBased(jp, ctxt); [EOL]     } [EOL]     if (_beanType.isAbstract()) { [EOL]         throw JsonMappingException.from(jp, "Can not instantiate abstract type " + _beanType + " (need to add/enable type information?)"); [EOL]     } [EOL]     throw JsonMappingException.from(jp, "No suitable constructor found for type " + _beanType + ": can not instantiate from JSON object (need to add/enable type information?)"); [EOL] }
protected Object _deserializeWithCreator(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_delegateDeserializer != null) { [EOL]         return _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]     } [EOL]     if (_propertyBasedCreator != null) { [EOL]         return _deserializeUsingPropertyBased(jp, ctxt); [EOL]     } [EOL]     if (_beanType.isAbstract()) { [EOL]         throw JsonMappingException.from(jp, "Can not instantiate abstract type " + _beanType + " (need to add/enable type information?)"); [EOL]     } [EOL]     throw JsonMappingException.from(jp, "No suitable constructor found for type " + _beanType + ": can not instantiate from JSON object (need to add/enable type information?)"); [EOL] }
@Override [EOL] protected final Object _deserializeUsingPropertyBased(final JsonParser jp, final DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     final PropertyBasedCreator creator = _propertyBasedCreator; [EOL]     PropertyValueBuffer buffer = creator.startBuilding(jp, ctxt, _objectIdReader); [EOL]     final SettableBeanProperty[] props = _orderedProperties; [EOL]     final int propCount = props.length; [EOL]     int i = 0; [EOL]     Object bean = null; [EOL]     for (; jp.nextToken() != JsonToken.END_ARRAY; ++i) { [EOL]         SettableBeanProperty prop = (i < propCount) ? props[i] : null; [EOL]         if (prop == null) { [EOL]             jp.skipChildren(); [EOL]             continue; [EOL]         } [EOL]         if (bean != null) { [EOL]             try { [EOL]                 prop.deserializeAndSet(jp, ctxt, bean); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, prop.getName(), ctxt); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         final String propName = prop.getName(); [EOL]         SettableBeanProperty creatorProp = creator.findCreatorProperty(propName); [EOL]         if (creatorProp != null) { [EOL]             Object value = creatorProp.deserialize(jp, ctxt); [EOL]             if (buffer.assignParameter(creatorProp.getCreatorIndex(), value)) { [EOL]                 try { [EOL]                     bean = creator.build(ctxt, buffer); [EOL]                 } catch (Exception e) { [EOL]                     wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt); [EOL]                     continue; [EOL]                 } [EOL]                 if (bean.getClass() != _beanType.getRawClass()) { [EOL]                     throw ctxt.mappingException("Can not support implicit polymorphic deserialization for POJOs-as-Arrays style: " + "nominal type " + _beanType.getRawClass().getName() + ", actual type " + bean.getClass().getName()); [EOL]                 } [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (buffer.readIdProperty(propName)) { [EOL]             continue; [EOL]         } [EOL]         buffer.bufferProperty(prop, prop.deserialize(jp, ctxt)); [EOL]     } [EOL]     if (bean == null) { [EOL]         try { [EOL]             bean = creator.build(ctxt, buffer); [EOL]         } catch (Exception e) { [EOL]             wrapInstantiationProblem(e, ctxt); [EOL]             return null; [EOL]         } [EOL]     } [EOL]     return bean; [EOL] }
@Override [EOL] protected final Object _deserializeUsingPropertyBased(final JsonParser jp, final DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     final PropertyBasedCreator creator = _propertyBasedCreator; [EOL]     PropertyValueBuffer buffer = creator.startBuilding(jp, ctxt, _objectIdReader); [EOL]     final SettableBeanProperty[] props = _orderedProperties; [EOL]     final int propCount = props.length; [EOL]     int i = 0; [EOL]     Object bean = null; [EOL]     for (; jp.nextToken() != JsonToken.END_ARRAY; ++i) { [EOL]         SettableBeanProperty prop = (i < propCount) ? props[i] : null; [EOL]         if (prop == null) { [EOL]             jp.skipChildren(); [EOL]             continue; [EOL]         } [EOL]         if (bean != null) { [EOL]             try { [EOL]                 prop.deserializeAndSet(jp, ctxt, bean); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, prop.getName(), ctxt); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         final String propName = prop.getName(); [EOL]         SettableBeanProperty creatorProp = creator.findCreatorProperty(propName); [EOL]         if (creatorProp != null) { [EOL]             Object value = creatorProp.deserialize(jp, ctxt); [EOL]             if (buffer.assignParameter(creatorProp.getCreatorIndex(), value)) { [EOL]                 try { [EOL]                     bean = creator.build(ctxt, buffer); [EOL]                 } catch (Exception e) { [EOL]                     wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt); [EOL]                     continue; [EOL]                 } [EOL]                 if (bean.getClass() != _beanType.getRawClass()) { [EOL]                     throw ctxt.mappingException("Can not support implicit polymorphic deserialization for POJOs-as-Arrays style: " + "nominal type " + _beanType.getRawClass().getName() + ", actual type " + bean.getClass().getName()); [EOL]                 } [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (buffer.readIdProperty(propName)) { [EOL]             continue; [EOL]         } [EOL]         buffer.bufferProperty(prop, prop.deserialize(jp, ctxt)); [EOL]     } [EOL]     if (bean == null) { [EOL]         try { [EOL]             bean = creator.build(ctxt, buffer); [EOL]         } catch (Exception e) { [EOL]             wrapInstantiationProblem(e, ctxt); [EOL]             return null; [EOL]         } [EOL]     } [EOL]     return bean; [EOL] }
@Override [EOL] protected final Object _deserializeUsingPropertyBased(final JsonParser jp, final DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     final PropertyBasedCreator creator = _propertyBasedCreator; [EOL]     PropertyValueBuffer buffer = creator.startBuilding(jp, ctxt, _objectIdReader); [EOL]     final SettableBeanProperty[] props = _orderedProperties; [EOL]     final int propCount = props.length; [EOL]     int i = 0; [EOL]     Object bean = null; [EOL]     for (; jp.nextToken() != JsonToken.END_ARRAY; ++i) { [EOL]         SettableBeanProperty prop = (i < propCount) ? props[i] : null; [EOL]         if (prop == null) { [EOL]             jp.skipChildren(); [EOL]             continue; [EOL]         } [EOL]         if (bean != null) { [EOL]             try { [EOL]                 prop.deserializeAndSet(jp, ctxt, bean); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, prop.getName(), ctxt); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         final String propName = prop.getName(); [EOL]         SettableBeanProperty creatorProp = creator.findCreatorProperty(propName); [EOL]         if (creatorProp != null) { [EOL]             Object value = creatorProp.deserialize(jp, ctxt); [EOL]             if (buffer.assignParameter(creatorProp.getCreatorIndex(), value)) { [EOL]                 try { [EOL]                     bean = creator.build(ctxt, buffer); [EOL]                 } catch (Exception e) { [EOL]                     wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt); [EOL]                     continue; [EOL]                 } [EOL]                 if (bean.getClass() != _beanType.getRawClass()) { [EOL]                     throw ctxt.mappingException("Can not support implicit polymorphic deserialization for POJOs-as-Arrays style: " + "nominal type " + _beanType.getRawClass().getName() + ", actual type " + bean.getClass().getName()); [EOL]                 } [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (buffer.readIdProperty(propName)) { [EOL]             continue; [EOL]         } [EOL]         buffer.bufferProperty(prop, prop.deserialize(jp, ctxt)); [EOL]     } [EOL]     if (bean == null) { [EOL]         try { [EOL]             bean = creator.build(ctxt, buffer); [EOL]         } catch (Exception e) { [EOL]             wrapInstantiationProblem(e, ctxt); [EOL]             return null; [EOL]         } [EOL]     } [EOL]     return bean; [EOL] }
@Override [EOL] protected final Object _deserializeUsingPropertyBased(final JsonParser jp, final DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     final PropertyBasedCreator creator = _propertyBasedCreator; [EOL]     PropertyValueBuffer buffer = creator.startBuilding(jp, ctxt, _objectIdReader); [EOL]     final SettableBeanProperty[] props = _orderedProperties; [EOL]     final int propCount = props.length; [EOL]     int i = 0; [EOL]     Object bean = null; [EOL]     for (; jp.nextToken() != JsonToken.END_ARRAY; ++i) { [EOL]         SettableBeanProperty prop = (i < propCount) ? props[i] : null; [EOL]         if (prop == null) { [EOL]             jp.skipChildren(); [EOL]             continue; [EOL]         } [EOL]         if (bean != null) { [EOL]             try { [EOL]                 prop.deserializeAndSet(jp, ctxt, bean); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, prop.getName(), ctxt); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         final String propName = prop.getName(); [EOL]         SettableBeanProperty creatorProp = creator.findCreatorProperty(propName); [EOL]         if (creatorProp != null) { [EOL]             Object value = creatorProp.deserialize(jp, ctxt); [EOL]             if (buffer.assignParameter(creatorProp.getCreatorIndex(), value)) { [EOL]                 try { [EOL]                     bean = creator.build(ctxt, buffer); [EOL]                 } catch (Exception e) { [EOL]                     wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt); [EOL]                     continue; [EOL]                 } [EOL]                 if (bean.getClass() != _beanType.getRawClass()) { [EOL]                     throw ctxt.mappingException("Can not support implicit polymorphic deserialization for POJOs-as-Arrays style: " + "nominal type " + _beanType.getRawClass().getName() + ", actual type " + bean.getClass().getName()); [EOL]                 } [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (buffer.readIdProperty(propName)) { [EOL]             continue; [EOL]         } [EOL]         buffer.bufferProperty(prop, prop.deserialize(jp, ctxt)); [EOL]     } [EOL]     if (bean == null) { [EOL]         try { [EOL]             bean = creator.build(ctxt, buffer); [EOL]         } catch (Exception e) { [EOL]             wrapInstantiationProblem(e, ctxt); [EOL]             return null; [EOL]         } [EOL]     } [EOL]     return bean; [EOL] }
public JsonSerializer<Object> untypedValueSerializer(Class<?> cls) { [EOL]     if (_cacheKey == null) { [EOL]         _cacheKey = new TypeKey(cls, false); [EOL]     } else { [EOL]         _cacheKey.resetUntyped(cls); [EOL]     } [EOL]     return _map.find(_cacheKey); [EOL] }
public JsonSerializer<Object> untypedValueSerializer(Class<?> cls) { [EOL]     if (_cacheKey == null) { [EOL]         _cacheKey = new TypeKey(cls, false); [EOL]     } else { [EOL]         _cacheKey.resetUntyped(cls); [EOL]     } [EOL]     return _map.find(_cacheKey); [EOL] }
public JSONPObject(String function, Object value) { [EOL]     this(function, value, (JavaType) null); [EOL] }
public JSONPObject(String function, Object value) { [EOL]     this(function, value, (JavaType) null); [EOL] }
@Override [EOL] public void serialize(JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonProcessingException { [EOL]     jgen.writeRaw(_function); [EOL]     jgen.writeRaw('('); [EOL]     if (_value == null) { [EOL]         provider.defaultSerializeNull(jgen); [EOL]     } else if (_serializationType != null) { [EOL]         provider.findTypedValueSerializer(_serializationType, true, null).serialize(_value, jgen, provider); [EOL]     } else { [EOL]         Class<?> cls = _value.getClass(); [EOL]         provider.findTypedValueSerializer(cls, true, null).serialize(_value, jgen, provider); [EOL]     } [EOL]     jgen.writeRaw(')'); [EOL] }
@Override [EOL] public void serialize(JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonProcessingException { [EOL]     jgen.writeRaw(_function); [EOL]     jgen.writeRaw('('); [EOL]     if (_value == null) { [EOL]         provider.defaultSerializeNull(jgen); [EOL]     } else if (_serializationType != null) { [EOL]         provider.findTypedValueSerializer(_serializationType, true, null).serialize(_value, jgen, provider); [EOL]     } else { [EOL]         Class<?> cls = _value.getClass(); [EOL]         provider.findTypedValueSerializer(cls, true, null).serialize(_value, jgen, provider); [EOL]     } [EOL]     jgen.writeRaw(')'); [EOL] }
@Override [EOL] public void serialize(JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonProcessingException { [EOL]     jgen.writeRaw(_function); [EOL]     jgen.writeRaw('('); [EOL]     if (_value == null) { [EOL]         provider.defaultSerializeNull(jgen); [EOL]     } else if (_serializationType != null) { [EOL]         provider.findTypedValueSerializer(_serializationType, true, null).serialize(_value, jgen, provider); [EOL]     } else { [EOL]         Class<?> cls = _value.getClass(); [EOL]         provider.findTypedValueSerializer(cls, true, null).serialize(_value, jgen, provider); [EOL]     } [EOL]     jgen.writeRaw(')'); [EOL] }
protected List<BeanPropertyWriter> findBeanProperties(SerializerProvider prov, BeanDescription beanDesc, BeanSerializerBuilder builder) throws JsonMappingException { [EOL]     List<BeanPropertyDefinition> properties = beanDesc.findProperties(); [EOL]     final SerializationConfig config = prov.getConfig(); [EOL]     removeIgnorableTypes(config, beanDesc, properties); [EOL]     if (config.isEnabled(MapperFeature.REQUIRE_SETTERS_FOR_GETTERS)) { [EOL]         removeSetterlessGetters(config, beanDesc, properties); [EOL]     } [EOL]     if (properties.isEmpty()) { [EOL]         return null; [EOL]     } [EOL]     boolean staticTyping = usesStaticTyping(config, beanDesc, null); [EOL]     PropertyBuilder pb = constructPropertyBuilder(config, beanDesc); [EOL]     ArrayList<BeanPropertyWriter> result = new ArrayList<BeanPropertyWriter>(properties.size()); [EOL]     TypeBindings typeBind = beanDesc.bindingsForBeanType(); [EOL]     for (BeanPropertyDefinition property : properties) { [EOL]         final AnnotatedMember accessor = property.getAccessor(); [EOL]         if (property.isTypeId()) { [EOL]             if (accessor != null) { [EOL]                 if (config.canOverrideAccessModifiers()) { [EOL]                     accessor.fixAccess(); [EOL]                 } [EOL]                 builder.setTypeId(accessor); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         AnnotationIntrospector.ReferenceProperty refType = property.findReferenceType(); [EOL]         if (refType != null && refType.isBackReference()) { [EOL]             continue; [EOL]         } [EOL]         if (accessor instanceof AnnotatedMethod) { [EOL]             result.add(_constructWriter(prov, property, typeBind, pb, staticTyping, (AnnotatedMethod) accessor)); [EOL]         } else { [EOL]             result.add(_constructWriter(prov, property, typeBind, pb, staticTyping, (AnnotatedField) accessor)); [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
protected List<BeanPropertyWriter> findBeanProperties(SerializerProvider prov, BeanDescription beanDesc, BeanSerializerBuilder builder) throws JsonMappingException { [EOL]     List<BeanPropertyDefinition> properties = beanDesc.findProperties(); [EOL]     final SerializationConfig config = prov.getConfig(); [EOL]     removeIgnorableTypes(config, beanDesc, properties); [EOL]     if (config.isEnabled(MapperFeature.REQUIRE_SETTERS_FOR_GETTERS)) { [EOL]         removeSetterlessGetters(config, beanDesc, properties); [EOL]     } [EOL]     if (properties.isEmpty()) { [EOL]         return null; [EOL]     } [EOL]     boolean staticTyping = usesStaticTyping(config, beanDesc, null); [EOL]     PropertyBuilder pb = constructPropertyBuilder(config, beanDesc); [EOL]     ArrayList<BeanPropertyWriter> result = new ArrayList<BeanPropertyWriter>(properties.size()); [EOL]     TypeBindings typeBind = beanDesc.bindingsForBeanType(); [EOL]     for (BeanPropertyDefinition property : properties) { [EOL]         final AnnotatedMember accessor = property.getAccessor(); [EOL]         if (property.isTypeId()) { [EOL]             if (accessor != null) { [EOL]                 if (config.canOverrideAccessModifiers()) { [EOL]                     accessor.fixAccess(); [EOL]                 } [EOL]                 builder.setTypeId(accessor); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         AnnotationIntrospector.ReferenceProperty refType = property.findReferenceType(); [EOL]         if (refType != null && refType.isBackReference()) { [EOL]             continue; [EOL]         } [EOL]         if (accessor instanceof AnnotatedMethod) { [EOL]             result.add(_constructWriter(prov, property, typeBind, pb, staticTyping, (AnnotatedMethod) accessor)); [EOL]         } else { [EOL]             result.add(_constructWriter(prov, property, typeBind, pb, staticTyping, (AnnotatedField) accessor)); [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
protected List<BeanPropertyWriter> findBeanProperties(SerializerProvider prov, BeanDescription beanDesc, BeanSerializerBuilder builder) throws JsonMappingException { [EOL]     List<BeanPropertyDefinition> properties = beanDesc.findProperties(); [EOL]     final SerializationConfig config = prov.getConfig(); [EOL]     removeIgnorableTypes(config, beanDesc, properties); [EOL]     if (config.isEnabled(MapperFeature.REQUIRE_SETTERS_FOR_GETTERS)) { [EOL]         removeSetterlessGetters(config, beanDesc, properties); [EOL]     } [EOL]     if (properties.isEmpty()) { [EOL]         return null; [EOL]     } [EOL]     boolean staticTyping = usesStaticTyping(config, beanDesc, null); [EOL]     PropertyBuilder pb = constructPropertyBuilder(config, beanDesc); [EOL]     ArrayList<BeanPropertyWriter> result = new ArrayList<BeanPropertyWriter>(properties.size()); [EOL]     TypeBindings typeBind = beanDesc.bindingsForBeanType(); [EOL]     for (BeanPropertyDefinition property : properties) { [EOL]         final AnnotatedMember accessor = property.getAccessor(); [EOL]         if (property.isTypeId()) { [EOL]             if (accessor != null) { [EOL]                 if (config.canOverrideAccessModifiers()) { [EOL]                     accessor.fixAccess(); [EOL]                 } [EOL]                 builder.setTypeId(accessor); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         AnnotationIntrospector.ReferenceProperty refType = property.findReferenceType(); [EOL]         if (refType != null && refType.isBackReference()) { [EOL]             continue; [EOL]         } [EOL]         if (accessor instanceof AnnotatedMethod) { [EOL]             result.add(_constructWriter(prov, property, typeBind, pb, staticTyping, (AnnotatedMethod) accessor)); [EOL]         } else { [EOL]             result.add(_constructWriter(prov, property, typeBind, pb, staticTyping, (AnnotatedField) accessor)); [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
protected List<BeanPropertyWriter> findBeanProperties(SerializerProvider prov, BeanDescription beanDesc, BeanSerializerBuilder builder) throws JsonMappingException { [EOL]     List<BeanPropertyDefinition> properties = beanDesc.findProperties(); [EOL]     final SerializationConfig config = prov.getConfig(); [EOL]     removeIgnorableTypes(config, beanDesc, properties); [EOL]     if (config.isEnabled(MapperFeature.REQUIRE_SETTERS_FOR_GETTERS)) { [EOL]         removeSetterlessGetters(config, beanDesc, properties); [EOL]     } [EOL]     if (properties.isEmpty()) { [EOL]         return null; [EOL]     } [EOL]     boolean staticTyping = usesStaticTyping(config, beanDesc, null); [EOL]     PropertyBuilder pb = constructPropertyBuilder(config, beanDesc); [EOL]     ArrayList<BeanPropertyWriter> result = new ArrayList<BeanPropertyWriter>(properties.size()); [EOL]     TypeBindings typeBind = beanDesc.bindingsForBeanType(); [EOL]     for (BeanPropertyDefinition property : properties) { [EOL]         final AnnotatedMember accessor = property.getAccessor(); [EOL]         if (property.isTypeId()) { [EOL]             if (accessor != null) { [EOL]                 if (config.canOverrideAccessModifiers()) { [EOL]                     accessor.fixAccess(); [EOL]                 } [EOL]                 builder.setTypeId(accessor); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         AnnotationIntrospector.ReferenceProperty refType = property.findReferenceType(); [EOL]         if (refType != null && refType.isBackReference()) { [EOL]             continue; [EOL]         } [EOL]         if (accessor instanceof AnnotatedMethod) { [EOL]             result.add(_constructWriter(prov, property, typeBind, pb, staticTyping, (AnnotatedMethod) accessor)); [EOL]         } else { [EOL]             result.add(_constructWriter(prov, property, typeBind, pb, staticTyping, (AnnotatedField) accessor)); [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
protected List<BeanPropertyWriter> findBeanProperties(SerializerProvider prov, BeanDescription beanDesc, BeanSerializerBuilder builder) throws JsonMappingException { [EOL]     List<BeanPropertyDefinition> properties = beanDesc.findProperties(); [EOL]     final SerializationConfig config = prov.getConfig(); [EOL]     removeIgnorableTypes(config, beanDesc, properties); [EOL]     if (config.isEnabled(MapperFeature.REQUIRE_SETTERS_FOR_GETTERS)) { [EOL]         removeSetterlessGetters(config, beanDesc, properties); [EOL]     } [EOL]     if (properties.isEmpty()) { [EOL]         return null; [EOL]     } [EOL]     boolean staticTyping = usesStaticTyping(config, beanDesc, null); [EOL]     PropertyBuilder pb = constructPropertyBuilder(config, beanDesc); [EOL]     ArrayList<BeanPropertyWriter> result = new ArrayList<BeanPropertyWriter>(properties.size()); [EOL]     TypeBindings typeBind = beanDesc.bindingsForBeanType(); [EOL]     for (BeanPropertyDefinition property : properties) { [EOL]         final AnnotatedMember accessor = property.getAccessor(); [EOL]         if (property.isTypeId()) { [EOL]             if (accessor != null) { [EOL]                 if (config.canOverrideAccessModifiers()) { [EOL]                     accessor.fixAccess(); [EOL]                 } [EOL]                 builder.setTypeId(accessor); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         AnnotationIntrospector.ReferenceProperty refType = property.findReferenceType(); [EOL]         if (refType != null && refType.isBackReference()) { [EOL]             continue; [EOL]         } [EOL]         if (accessor instanceof AnnotatedMethod) { [EOL]             result.add(_constructWriter(prov, property, typeBind, pb, staticTyping, (AnnotatedMethod) accessor)); [EOL]         } else { [EOL]             result.add(_constructWriter(prov, property, typeBind, pb, staticTyping, (AnnotatedField) accessor)); [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
protected List<BeanPropertyWriter> findBeanProperties(SerializerProvider prov, BeanDescription beanDesc, BeanSerializerBuilder builder) throws JsonMappingException { [EOL]     List<BeanPropertyDefinition> properties = beanDesc.findProperties(); [EOL]     final SerializationConfig config = prov.getConfig(); [EOL]     removeIgnorableTypes(config, beanDesc, properties); [EOL]     if (config.isEnabled(MapperFeature.REQUIRE_SETTERS_FOR_GETTERS)) { [EOL]         removeSetterlessGetters(config, beanDesc, properties); [EOL]     } [EOL]     if (properties.isEmpty()) { [EOL]         return null; [EOL]     } [EOL]     boolean staticTyping = usesStaticTyping(config, beanDesc, null); [EOL]     PropertyBuilder pb = constructPropertyBuilder(config, beanDesc); [EOL]     ArrayList<BeanPropertyWriter> result = new ArrayList<BeanPropertyWriter>(properties.size()); [EOL]     TypeBindings typeBind = beanDesc.bindingsForBeanType(); [EOL]     for (BeanPropertyDefinition property : properties) { [EOL]         final AnnotatedMember accessor = property.getAccessor(); [EOL]         if (property.isTypeId()) { [EOL]             if (accessor != null) { [EOL]                 if (config.canOverrideAccessModifiers()) { [EOL]                     accessor.fixAccess(); [EOL]                 } [EOL]                 builder.setTypeId(accessor); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         AnnotationIntrospector.ReferenceProperty refType = property.findReferenceType(); [EOL]         if (refType != null && refType.isBackReference()) { [EOL]             continue; [EOL]         } [EOL]         if (accessor instanceof AnnotatedMethod) { [EOL]             result.add(_constructWriter(prov, property, typeBind, pb, staticTyping, (AnnotatedMethod) accessor)); [EOL]         } else { [EOL]             result.add(_constructWriter(prov, property, typeBind, pb, staticTyping, (AnnotatedField) accessor)); [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (rawType.isPrimitive()) { [EOL]         if (rawType == Integer.TYPE) { [EOL]             return IntegerDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Boolean.TYPE) { [EOL]             return BooleanDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Long.TYPE) { [EOL]             return LongDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Double.TYPE) { [EOL]             return DoubleDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Character.TYPE) { [EOL]             return CharacterDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Byte.TYPE) { [EOL]             return ByteDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Short.TYPE) { [EOL]             return ShortDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Float.TYPE) { [EOL]             return FloatDeserializer.primitiveInstance; [EOL]         } [EOL]     } else if (_classNames.contains(clsName)) { [EOL]         if (rawType == Integer.class) { [EOL]             return IntegerDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Boolean.class) { [EOL]             return BooleanDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Long.class) { [EOL]             return LongDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Double.class) { [EOL]             return DoubleDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Character.class) { [EOL]             return CharacterDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Byte.class) { [EOL]             return ByteDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Short.class) { [EOL]             return ShortDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Float.class) { [EOL]             return FloatDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Number.class) { [EOL]             return NumberDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigDecimal.class) { [EOL]             return BigDecimalDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigInteger.class) { [EOL]             return BigIntegerDeserializer.instance; [EOL]         } [EOL]     } else { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + rawType.getName()); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (rawType.isPrimitive()) { [EOL]         if (rawType == Integer.TYPE) { [EOL]             return IntegerDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Boolean.TYPE) { [EOL]             return BooleanDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Long.TYPE) { [EOL]             return LongDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Double.TYPE) { [EOL]             return DoubleDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Character.TYPE) { [EOL]             return CharacterDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Byte.TYPE) { [EOL]             return ByteDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Short.TYPE) { [EOL]             return ShortDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Float.TYPE) { [EOL]             return FloatDeserializer.primitiveInstance; [EOL]         } [EOL]     } else if (_classNames.contains(clsName)) { [EOL]         if (rawType == Integer.class) { [EOL]             return IntegerDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Boolean.class) { [EOL]             return BooleanDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Long.class) { [EOL]             return LongDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Double.class) { [EOL]             return DoubleDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Character.class) { [EOL]             return CharacterDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Byte.class) { [EOL]             return ByteDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Short.class) { [EOL]             return ShortDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Float.class) { [EOL]             return FloatDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Number.class) { [EOL]             return NumberDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigDecimal.class) { [EOL]             return BigDecimalDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigInteger.class) { [EOL]             return BigIntegerDeserializer.instance; [EOL]         } [EOL]     } else { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + rawType.getName()); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (rawType.isPrimitive()) { [EOL]         if (rawType == Integer.TYPE) { [EOL]             return IntegerDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Boolean.TYPE) { [EOL]             return BooleanDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Long.TYPE) { [EOL]             return LongDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Double.TYPE) { [EOL]             return DoubleDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Character.TYPE) { [EOL]             return CharacterDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Byte.TYPE) { [EOL]             return ByteDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Short.TYPE) { [EOL]             return ShortDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Float.TYPE) { [EOL]             return FloatDeserializer.primitiveInstance; [EOL]         } [EOL]     } else if (_classNames.contains(clsName)) { [EOL]         if (rawType == Integer.class) { [EOL]             return IntegerDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Boolean.class) { [EOL]             return BooleanDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Long.class) { [EOL]             return LongDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Double.class) { [EOL]             return DoubleDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Character.class) { [EOL]             return CharacterDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Byte.class) { [EOL]             return ByteDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Short.class) { [EOL]             return ShortDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Float.class) { [EOL]             return FloatDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Number.class) { [EOL]             return NumberDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigDecimal.class) { [EOL]             return BigDecimalDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigInteger.class) { [EOL]             return BigIntegerDeserializer.instance; [EOL]         } [EOL]     } else { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + rawType.getName()); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (rawType.isPrimitive()) { [EOL]         if (rawType == Integer.TYPE) { [EOL]             return IntegerDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Boolean.TYPE) { [EOL]             return BooleanDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Long.TYPE) { [EOL]             return LongDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Double.TYPE) { [EOL]             return DoubleDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Character.TYPE) { [EOL]             return CharacterDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Byte.TYPE) { [EOL]             return ByteDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Short.TYPE) { [EOL]             return ShortDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Float.TYPE) { [EOL]             return FloatDeserializer.primitiveInstance; [EOL]         } [EOL]     } else if (_classNames.contains(clsName)) { [EOL]         if (rawType == Integer.class) { [EOL]             return IntegerDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Boolean.class) { [EOL]             return BooleanDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Long.class) { [EOL]             return LongDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Double.class) { [EOL]             return DoubleDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Character.class) { [EOL]             return CharacterDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Byte.class) { [EOL]             return ByteDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Short.class) { [EOL]             return ShortDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Float.class) { [EOL]             return FloatDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Number.class) { [EOL]             return NumberDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigDecimal.class) { [EOL]             return BigDecimalDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigInteger.class) { [EOL]             return BigIntegerDeserializer.instance; [EOL]         } [EOL]     } else { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + rawType.getName()); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (rawType.isPrimitive()) { [EOL]         if (rawType == Integer.TYPE) { [EOL]             return IntegerDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Boolean.TYPE) { [EOL]             return BooleanDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Long.TYPE) { [EOL]             return LongDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Double.TYPE) { [EOL]             return DoubleDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Character.TYPE) { [EOL]             return CharacterDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Byte.TYPE) { [EOL]             return ByteDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Short.TYPE) { [EOL]             return ShortDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Float.TYPE) { [EOL]             return FloatDeserializer.primitiveInstance; [EOL]         } [EOL]     } else if (_classNames.contains(clsName)) { [EOL]         if (rawType == Integer.class) { [EOL]             return IntegerDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Boolean.class) { [EOL]             return BooleanDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Long.class) { [EOL]             return LongDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Double.class) { [EOL]             return DoubleDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Character.class) { [EOL]             return CharacterDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Byte.class) { [EOL]             return ByteDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Short.class) { [EOL]             return ShortDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Float.class) { [EOL]             return FloatDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Number.class) { [EOL]             return NumberDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigDecimal.class) { [EOL]             return BigDecimalDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigInteger.class) { [EOL]             return BigIntegerDeserializer.instance; [EOL]         } [EOL]     } else { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + rawType.getName()); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (rawType.isPrimitive()) { [EOL]         if (rawType == Integer.TYPE) { [EOL]             return IntegerDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Boolean.TYPE) { [EOL]             return BooleanDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Long.TYPE) { [EOL]             return LongDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Double.TYPE) { [EOL]             return DoubleDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Character.TYPE) { [EOL]             return CharacterDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Byte.TYPE) { [EOL]             return ByteDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Short.TYPE) { [EOL]             return ShortDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Float.TYPE) { [EOL]             return FloatDeserializer.primitiveInstance; [EOL]         } [EOL]     } else if (_classNames.contains(clsName)) { [EOL]         if (rawType == Integer.class) { [EOL]             return IntegerDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Boolean.class) { [EOL]             return BooleanDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Long.class) { [EOL]             return LongDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Double.class) { [EOL]             return DoubleDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Character.class) { [EOL]             return CharacterDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Byte.class) { [EOL]             return ByteDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Short.class) { [EOL]             return ShortDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Float.class) { [EOL]             return FloatDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Number.class) { [EOL]             return NumberDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigDecimal.class) { [EOL]             return BigDecimalDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigInteger.class) { [EOL]             return BigIntegerDeserializer.instance; [EOL]         } [EOL]     } else { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + rawType.getName()); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (rawType.isPrimitive()) { [EOL]         if (rawType == Integer.TYPE) { [EOL]             return IntegerDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Boolean.TYPE) { [EOL]             return BooleanDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Long.TYPE) { [EOL]             return LongDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Double.TYPE) { [EOL]             return DoubleDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Character.TYPE) { [EOL]             return CharacterDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Byte.TYPE) { [EOL]             return ByteDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Short.TYPE) { [EOL]             return ShortDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Float.TYPE) { [EOL]             return FloatDeserializer.primitiveInstance; [EOL]         } [EOL]     } else if (_classNames.contains(clsName)) { [EOL]         if (rawType == Integer.class) { [EOL]             return IntegerDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Boolean.class) { [EOL]             return BooleanDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Long.class) { [EOL]             return LongDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Double.class) { [EOL]             return DoubleDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Character.class) { [EOL]             return CharacterDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Byte.class) { [EOL]             return ByteDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Short.class) { [EOL]             return ShortDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Float.class) { [EOL]             return FloatDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Number.class) { [EOL]             return NumberDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigDecimal.class) { [EOL]             return BigDecimalDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigInteger.class) { [EOL]             return BigIntegerDeserializer.instance; [EOL]         } [EOL]     } else { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + rawType.getName()); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (rawType.isPrimitive()) { [EOL]         if (rawType == Integer.TYPE) { [EOL]             return IntegerDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Boolean.TYPE) { [EOL]             return BooleanDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Long.TYPE) { [EOL]             return LongDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Double.TYPE) { [EOL]             return DoubleDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Character.TYPE) { [EOL]             return CharacterDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Byte.TYPE) { [EOL]             return ByteDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Short.TYPE) { [EOL]             return ShortDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Float.TYPE) { [EOL]             return FloatDeserializer.primitiveInstance; [EOL]         } [EOL]     } else if (_classNames.contains(clsName)) { [EOL]         if (rawType == Integer.class) { [EOL]             return IntegerDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Boolean.class) { [EOL]             return BooleanDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Long.class) { [EOL]             return LongDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Double.class) { [EOL]             return DoubleDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Character.class) { [EOL]             return CharacterDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Byte.class) { [EOL]             return ByteDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Short.class) { [EOL]             return ShortDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Float.class) { [EOL]             return FloatDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Number.class) { [EOL]             return NumberDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigDecimal.class) { [EOL]             return BigDecimalDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigInteger.class) { [EOL]             return BigIntegerDeserializer.instance; [EOL]         } [EOL]     } else { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + rawType.getName()); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (rawType.isPrimitive()) { [EOL]         if (rawType == Integer.TYPE) { [EOL]             return IntegerDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Boolean.TYPE) { [EOL]             return BooleanDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Long.TYPE) { [EOL]             return LongDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Double.TYPE) { [EOL]             return DoubleDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Character.TYPE) { [EOL]             return CharacterDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Byte.TYPE) { [EOL]             return ByteDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Short.TYPE) { [EOL]             return ShortDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Float.TYPE) { [EOL]             return FloatDeserializer.primitiveInstance; [EOL]         } [EOL]     } else if (_classNames.contains(clsName)) { [EOL]         if (rawType == Integer.class) { [EOL]             return IntegerDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Boolean.class) { [EOL]             return BooleanDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Long.class) { [EOL]             return LongDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Double.class) { [EOL]             return DoubleDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Character.class) { [EOL]             return CharacterDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Byte.class) { [EOL]             return ByteDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Short.class) { [EOL]             return ShortDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Float.class) { [EOL]             return FloatDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Number.class) { [EOL]             return NumberDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigDecimal.class) { [EOL]             return BigDecimalDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigInteger.class) { [EOL]             return BigIntegerDeserializer.instance; [EOL]         } [EOL]     } else { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + rawType.getName()); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (rawType.isPrimitive()) { [EOL]         if (rawType == Integer.TYPE) { [EOL]             return IntegerDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Boolean.TYPE) { [EOL]             return BooleanDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Long.TYPE) { [EOL]             return LongDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Double.TYPE) { [EOL]             return DoubleDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Character.TYPE) { [EOL]             return CharacterDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Byte.TYPE) { [EOL]             return ByteDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Short.TYPE) { [EOL]             return ShortDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Float.TYPE) { [EOL]             return FloatDeserializer.primitiveInstance; [EOL]         } [EOL]     } else if (_classNames.contains(clsName)) { [EOL]         if (rawType == Integer.class) { [EOL]             return IntegerDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Boolean.class) { [EOL]             return BooleanDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Long.class) { [EOL]             return LongDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Double.class) { [EOL]             return DoubleDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Character.class) { [EOL]             return CharacterDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Byte.class) { [EOL]             return ByteDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Short.class) { [EOL]             return ShortDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Float.class) { [EOL]             return FloatDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Number.class) { [EOL]             return NumberDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigDecimal.class) { [EOL]             return BigDecimalDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigInteger.class) { [EOL]             return BigIntegerDeserializer.instance; [EOL]         } [EOL]     } else { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + rawType.getName()); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (rawType.isPrimitive()) { [EOL]         if (rawType == Integer.TYPE) { [EOL]             return IntegerDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Boolean.TYPE) { [EOL]             return BooleanDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Long.TYPE) { [EOL]             return LongDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Double.TYPE) { [EOL]             return DoubleDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Character.TYPE) { [EOL]             return CharacterDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Byte.TYPE) { [EOL]             return ByteDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Short.TYPE) { [EOL]             return ShortDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Float.TYPE) { [EOL]             return FloatDeserializer.primitiveInstance; [EOL]         } [EOL]     } else if (_classNames.contains(clsName)) { [EOL]         if (rawType == Integer.class) { [EOL]             return IntegerDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Boolean.class) { [EOL]             return BooleanDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Long.class) { [EOL]             return LongDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Double.class) { [EOL]             return DoubleDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Character.class) { [EOL]             return CharacterDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Byte.class) { [EOL]             return ByteDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Short.class) { [EOL]             return ShortDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Float.class) { [EOL]             return FloatDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Number.class) { [EOL]             return NumberDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigDecimal.class) { [EOL]             return BigDecimalDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigInteger.class) { [EOL]             return BigIntegerDeserializer.instance; [EOL]         } [EOL]     } else { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + rawType.getName()); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (rawType.isPrimitive()) { [EOL]         if (rawType == Integer.TYPE) { [EOL]             return IntegerDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Boolean.TYPE) { [EOL]             return BooleanDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Long.TYPE) { [EOL]             return LongDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Double.TYPE) { [EOL]             return DoubleDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Character.TYPE) { [EOL]             return CharacterDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Byte.TYPE) { [EOL]             return ByteDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Short.TYPE) { [EOL]             return ShortDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Float.TYPE) { [EOL]             return FloatDeserializer.primitiveInstance; [EOL]         } [EOL]     } else if (_classNames.contains(clsName)) { [EOL]         if (rawType == Integer.class) { [EOL]             return IntegerDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Boolean.class) { [EOL]             return BooleanDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Long.class) { [EOL]             return LongDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Double.class) { [EOL]             return DoubleDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Character.class) { [EOL]             return CharacterDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Byte.class) { [EOL]             return ByteDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Short.class) { [EOL]             return ShortDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Float.class) { [EOL]             return FloatDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Number.class) { [EOL]             return NumberDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigDecimal.class) { [EOL]             return BigDecimalDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigInteger.class) { [EOL]             return BigIntegerDeserializer.instance; [EOL]         } [EOL]     } else { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + rawType.getName()); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (rawType.isPrimitive()) { [EOL]         if (rawType == Integer.TYPE) { [EOL]             return IntegerDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Boolean.TYPE) { [EOL]             return BooleanDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Long.TYPE) { [EOL]             return LongDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Double.TYPE) { [EOL]             return DoubleDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Character.TYPE) { [EOL]             return CharacterDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Byte.TYPE) { [EOL]             return ByteDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Short.TYPE) { [EOL]             return ShortDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Float.TYPE) { [EOL]             return FloatDeserializer.primitiveInstance; [EOL]         } [EOL]     } else if (_classNames.contains(clsName)) { [EOL]         if (rawType == Integer.class) { [EOL]             return IntegerDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Boolean.class) { [EOL]             return BooleanDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Long.class) { [EOL]             return LongDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Double.class) { [EOL]             return DoubleDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Character.class) { [EOL]             return CharacterDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Byte.class) { [EOL]             return ByteDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Short.class) { [EOL]             return ShortDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Float.class) { [EOL]             return FloatDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Number.class) { [EOL]             return NumberDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigDecimal.class) { [EOL]             return BigDecimalDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigInteger.class) { [EOL]             return BigIntegerDeserializer.instance; [EOL]         } [EOL]     } else { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + rawType.getName()); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (rawType.isPrimitive()) { [EOL]         if (rawType == Integer.TYPE) { [EOL]             return IntegerDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Boolean.TYPE) { [EOL]             return BooleanDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Long.TYPE) { [EOL]             return LongDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Double.TYPE) { [EOL]             return DoubleDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Character.TYPE) { [EOL]             return CharacterDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Byte.TYPE) { [EOL]             return ByteDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Short.TYPE) { [EOL]             return ShortDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Float.TYPE) { [EOL]             return FloatDeserializer.primitiveInstance; [EOL]         } [EOL]     } else if (_classNames.contains(clsName)) { [EOL]         if (rawType == Integer.class) { [EOL]             return IntegerDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Boolean.class) { [EOL]             return BooleanDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Long.class) { [EOL]             return LongDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Double.class) { [EOL]             return DoubleDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Character.class) { [EOL]             return CharacterDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Byte.class) { [EOL]             return ByteDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Short.class) { [EOL]             return ShortDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Float.class) { [EOL]             return FloatDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Number.class) { [EOL]             return NumberDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigDecimal.class) { [EOL]             return BigDecimalDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigInteger.class) { [EOL]             return BigIntegerDeserializer.instance; [EOL]         } [EOL]     } else { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + rawType.getName()); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (rawType.isPrimitive()) { [EOL]         if (rawType == Integer.TYPE) { [EOL]             return IntegerDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Boolean.TYPE) { [EOL]             return BooleanDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Long.TYPE) { [EOL]             return LongDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Double.TYPE) { [EOL]             return DoubleDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Character.TYPE) { [EOL]             return CharacterDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Byte.TYPE) { [EOL]             return ByteDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Short.TYPE) { [EOL]             return ShortDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Float.TYPE) { [EOL]             return FloatDeserializer.primitiveInstance; [EOL]         } [EOL]     } else if (_classNames.contains(clsName)) { [EOL]         if (rawType == Integer.class) { [EOL]             return IntegerDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Boolean.class) { [EOL]             return BooleanDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Long.class) { [EOL]             return LongDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Double.class) { [EOL]             return DoubleDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Character.class) { [EOL]             return CharacterDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Byte.class) { [EOL]             return ByteDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Short.class) { [EOL]             return ShortDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Float.class) { [EOL]             return FloatDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Number.class) { [EOL]             return NumberDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigDecimal.class) { [EOL]             return BigDecimalDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigInteger.class) { [EOL]             return BigIntegerDeserializer.instance; [EOL]         } [EOL]     } else { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + rawType.getName()); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (rawType.isPrimitive()) { [EOL]         if (rawType == Integer.TYPE) { [EOL]             return IntegerDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Boolean.TYPE) { [EOL]             return BooleanDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Long.TYPE) { [EOL]             return LongDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Double.TYPE) { [EOL]             return DoubleDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Character.TYPE) { [EOL]             return CharacterDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Byte.TYPE) { [EOL]             return ByteDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Short.TYPE) { [EOL]             return ShortDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Float.TYPE) { [EOL]             return FloatDeserializer.primitiveInstance; [EOL]         } [EOL]     } else if (_classNames.contains(clsName)) { [EOL]         if (rawType == Integer.class) { [EOL]             return IntegerDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Boolean.class) { [EOL]             return BooleanDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Long.class) { [EOL]             return LongDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Double.class) { [EOL]             return DoubleDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Character.class) { [EOL]             return CharacterDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Byte.class) { [EOL]             return ByteDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Short.class) { [EOL]             return ShortDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Float.class) { [EOL]             return FloatDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Number.class) { [EOL]             return NumberDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigDecimal.class) { [EOL]             return BigDecimalDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigInteger.class) { [EOL]             return BigIntegerDeserializer.instance; [EOL]         } [EOL]     } else { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + rawType.getName()); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (rawType.isPrimitive()) { [EOL]         if (rawType == Integer.TYPE) { [EOL]             return IntegerDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Boolean.TYPE) { [EOL]             return BooleanDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Long.TYPE) { [EOL]             return LongDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Double.TYPE) { [EOL]             return DoubleDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Character.TYPE) { [EOL]             return CharacterDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Byte.TYPE) { [EOL]             return ByteDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Short.TYPE) { [EOL]             return ShortDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Float.TYPE) { [EOL]             return FloatDeserializer.primitiveInstance; [EOL]         } [EOL]     } else if (_classNames.contains(clsName)) { [EOL]         if (rawType == Integer.class) { [EOL]             return IntegerDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Boolean.class) { [EOL]             return BooleanDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Long.class) { [EOL]             return LongDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Double.class) { [EOL]             return DoubleDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Character.class) { [EOL]             return CharacterDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Byte.class) { [EOL]             return ByteDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Short.class) { [EOL]             return ShortDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Float.class) { [EOL]             return FloatDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Number.class) { [EOL]             return NumberDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigDecimal.class) { [EOL]             return BigDecimalDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigInteger.class) { [EOL]             return BigIntegerDeserializer.instance; [EOL]         } [EOL]     } else { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + rawType.getName()); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (rawType.isPrimitive()) { [EOL]         if (rawType == Integer.TYPE) { [EOL]             return IntegerDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Boolean.TYPE) { [EOL]             return BooleanDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Long.TYPE) { [EOL]             return LongDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Double.TYPE) { [EOL]             return DoubleDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Character.TYPE) { [EOL]             return CharacterDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Byte.TYPE) { [EOL]             return ByteDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Short.TYPE) { [EOL]             return ShortDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Float.TYPE) { [EOL]             return FloatDeserializer.primitiveInstance; [EOL]         } [EOL]     } else if (_classNames.contains(clsName)) { [EOL]         if (rawType == Integer.class) { [EOL]             return IntegerDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Boolean.class) { [EOL]             return BooleanDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Long.class) { [EOL]             return LongDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Double.class) { [EOL]             return DoubleDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Character.class) { [EOL]             return CharacterDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Byte.class) { [EOL]             return ByteDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Short.class) { [EOL]             return ShortDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Float.class) { [EOL]             return FloatDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Number.class) { [EOL]             return NumberDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigDecimal.class) { [EOL]             return BigDecimalDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigInteger.class) { [EOL]             return BigIntegerDeserializer.instance; [EOL]         } [EOL]     } else { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + rawType.getName()); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (rawType.isPrimitive()) { [EOL]         if (rawType == Integer.TYPE) { [EOL]             return IntegerDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Boolean.TYPE) { [EOL]             return BooleanDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Long.TYPE) { [EOL]             return LongDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Double.TYPE) { [EOL]             return DoubleDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Character.TYPE) { [EOL]             return CharacterDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Byte.TYPE) { [EOL]             return ByteDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Short.TYPE) { [EOL]             return ShortDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Float.TYPE) { [EOL]             return FloatDeserializer.primitiveInstance; [EOL]         } [EOL]     } else if (_classNames.contains(clsName)) { [EOL]         if (rawType == Integer.class) { [EOL]             return IntegerDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Boolean.class) { [EOL]             return BooleanDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Long.class) { [EOL]             return LongDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Double.class) { [EOL]             return DoubleDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Character.class) { [EOL]             return CharacterDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Byte.class) { [EOL]             return ByteDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Short.class) { [EOL]             return ShortDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Float.class) { [EOL]             return FloatDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Number.class) { [EOL]             return NumberDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigDecimal.class) { [EOL]             return BigDecimalDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigInteger.class) { [EOL]             return BigIntegerDeserializer.instance; [EOL]         } [EOL]     } else { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + rawType.getName()); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (rawType.isPrimitive()) { [EOL]         if (rawType == Integer.TYPE) { [EOL]             return IntegerDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Boolean.TYPE) { [EOL]             return BooleanDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Long.TYPE) { [EOL]             return LongDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Double.TYPE) { [EOL]             return DoubleDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Character.TYPE) { [EOL]             return CharacterDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Byte.TYPE) { [EOL]             return ByteDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Short.TYPE) { [EOL]             return ShortDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Float.TYPE) { [EOL]             return FloatDeserializer.primitiveInstance; [EOL]         } [EOL]     } else if (_classNames.contains(clsName)) { [EOL]         if (rawType == Integer.class) { [EOL]             return IntegerDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Boolean.class) { [EOL]             return BooleanDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Long.class) { [EOL]             return LongDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Double.class) { [EOL]             return DoubleDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Character.class) { [EOL]             return CharacterDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Byte.class) { [EOL]             return ByteDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Short.class) { [EOL]             return ShortDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Float.class) { [EOL]             return FloatDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Number.class) { [EOL]             return NumberDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigDecimal.class) { [EOL]             return BigDecimalDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigInteger.class) { [EOL]             return BigIntegerDeserializer.instance; [EOL]         } [EOL]     } else { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + rawType.getName()); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (rawType.isPrimitive()) { [EOL]         if (rawType == Integer.TYPE) { [EOL]             return IntegerDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Boolean.TYPE) { [EOL]             return BooleanDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Long.TYPE) { [EOL]             return LongDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Double.TYPE) { [EOL]             return DoubleDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Character.TYPE) { [EOL]             return CharacterDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Byte.TYPE) { [EOL]             return ByteDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Short.TYPE) { [EOL]             return ShortDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Float.TYPE) { [EOL]             return FloatDeserializer.primitiveInstance; [EOL]         } [EOL]     } else if (_classNames.contains(clsName)) { [EOL]         if (rawType == Integer.class) { [EOL]             return IntegerDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Boolean.class) { [EOL]             return BooleanDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Long.class) { [EOL]             return LongDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Double.class) { [EOL]             return DoubleDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Character.class) { [EOL]             return CharacterDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Byte.class) { [EOL]             return ByteDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Short.class) { [EOL]             return ShortDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Float.class) { [EOL]             return FloatDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Number.class) { [EOL]             return NumberDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigDecimal.class) { [EOL]             return BigDecimalDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigInteger.class) { [EOL]             return BigIntegerDeserializer.instance; [EOL]         } [EOL]     } else { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + rawType.getName()); [EOL] }
@Override [EOL] public Number deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]             return jp.getBigIntegerValue(); [EOL]         } [EOL]         return jp.getNumberValue(); [EOL]     } else if (t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]             return jp.getDecimalValue(); [EOL]         } [EOL]         return Double.valueOf(jp.getDoubleValue()); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         try { [EOL]             if (text.indexOf('.') >= 0) { [EOL]                 if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                     return new BigDecimal(text); [EOL]                 } [EOL]                 return new Double(text); [EOL]             } [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return new BigInteger(text); [EOL]             } [EOL]             long value = Long.parseLong(text); [EOL]             if (value <= Integer.MAX_VALUE && value >= Integer.MIN_VALUE) { [EOL]                 return Integer.valueOf((int) value); [EOL]             } [EOL]             return Long.valueOf(value); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "not a valid number"); [EOL]         } [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
@Override [EOL] public Number deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]             return jp.getBigIntegerValue(); [EOL]         } [EOL]         return jp.getNumberValue(); [EOL]     } else if (t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]             return jp.getDecimalValue(); [EOL]         } [EOL]         return Double.valueOf(jp.getDoubleValue()); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         try { [EOL]             if (text.indexOf('.') >= 0) { [EOL]                 if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                     return new BigDecimal(text); [EOL]                 } [EOL]                 return new Double(text); [EOL]             } [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return new BigInteger(text); [EOL]             } [EOL]             long value = Long.parseLong(text); [EOL]             if (value <= Integer.MAX_VALUE && value >= Integer.MIN_VALUE) { [EOL]                 return Integer.valueOf((int) value); [EOL]             } [EOL]             return Long.valueOf(value); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "not a valid number"); [EOL]         } [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
@Override [EOL] public Number deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]             return jp.getBigIntegerValue(); [EOL]         } [EOL]         return jp.getNumberValue(); [EOL]     } else if (t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]             return jp.getDecimalValue(); [EOL]         } [EOL]         return Double.valueOf(jp.getDoubleValue()); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         try { [EOL]             if (text.indexOf('.') >= 0) { [EOL]                 if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                     return new BigDecimal(text); [EOL]                 } [EOL]                 return new Double(text); [EOL]             } [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return new BigInteger(text); [EOL]             } [EOL]             long value = Long.parseLong(text); [EOL]             if (value <= Integer.MAX_VALUE && value >= Integer.MIN_VALUE) { [EOL]                 return Integer.valueOf((int) value); [EOL]             } [EOL]             return Long.valueOf(value); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "not a valid number"); [EOL]         } [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
@Override [EOL] public Number deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]             return jp.getBigIntegerValue(); [EOL]         } [EOL]         return jp.getNumberValue(); [EOL]     } else if (t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]             return jp.getDecimalValue(); [EOL]         } [EOL]         return Double.valueOf(jp.getDoubleValue()); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         try { [EOL]             if (text.indexOf('.') >= 0) { [EOL]                 if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                     return new BigDecimal(text); [EOL]                 } [EOL]                 return new Double(text); [EOL]             } [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return new BigInteger(text); [EOL]             } [EOL]             long value = Long.parseLong(text); [EOL]             if (value <= Integer.MAX_VALUE && value >= Integer.MIN_VALUE) { [EOL]                 return Integer.valueOf((int) value); [EOL]             } [EOL]             return Long.valueOf(value); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "not a valid number"); [EOL]         } [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
@Override [EOL] public Number deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]             return jp.getBigIntegerValue(); [EOL]         } [EOL]         return jp.getNumberValue(); [EOL]     } else if (t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]             return jp.getDecimalValue(); [EOL]         } [EOL]         return Double.valueOf(jp.getDoubleValue()); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         try { [EOL]             if (text.indexOf('.') >= 0) { [EOL]                 if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                     return new BigDecimal(text); [EOL]                 } [EOL]                 return new Double(text); [EOL]             } [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return new BigInteger(text); [EOL]             } [EOL]             long value = Long.parseLong(text); [EOL]             if (value <= Integer.MAX_VALUE && value >= Integer.MIN_VALUE) { [EOL]                 return Integer.valueOf((int) value); [EOL]             } [EOL]             return Long.valueOf(value); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "not a valid number"); [EOL]         } [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
@Override [EOL] public Number deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]             return jp.getBigIntegerValue(); [EOL]         } [EOL]         return jp.getNumberValue(); [EOL]     } else if (t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]             return jp.getDecimalValue(); [EOL]         } [EOL]         return Double.valueOf(jp.getDoubleValue()); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         try { [EOL]             if (text.indexOf('.') >= 0) { [EOL]                 if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                     return new BigDecimal(text); [EOL]                 } [EOL]                 return new Double(text); [EOL]             } [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return new BigInteger(text); [EOL]             } [EOL]             long value = Long.parseLong(text); [EOL]             if (value <= Integer.MAX_VALUE && value >= Integer.MIN_VALUE) { [EOL]                 return Integer.valueOf((int) value); [EOL]             } [EOL]             return Long.valueOf(value); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "not a valid number"); [EOL]         } [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
@Override [EOL] public Number deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]             return jp.getBigIntegerValue(); [EOL]         } [EOL]         return jp.getNumberValue(); [EOL]     } else if (t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]             return jp.getDecimalValue(); [EOL]         } [EOL]         return Double.valueOf(jp.getDoubleValue()); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         try { [EOL]             if (text.indexOf('.') >= 0) { [EOL]                 if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                     return new BigDecimal(text); [EOL]                 } [EOL]                 return new Double(text); [EOL]             } [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return new BigInteger(text); [EOL]             } [EOL]             long value = Long.parseLong(text); [EOL]             if (value <= Integer.MAX_VALUE && value >= Integer.MIN_VALUE) { [EOL]                 return Integer.valueOf((int) value); [EOL]             } [EOL]             return Long.valueOf(value); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "not a valid number"); [EOL]         } [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
@Override [EOL] public Number deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]             return jp.getBigIntegerValue(); [EOL]         } [EOL]         return jp.getNumberValue(); [EOL]     } else if (t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]             return jp.getDecimalValue(); [EOL]         } [EOL]         return Double.valueOf(jp.getDoubleValue()); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         try { [EOL]             if (text.indexOf('.') >= 0) { [EOL]                 if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                     return new BigDecimal(text); [EOL]                 } [EOL]                 return new Double(text); [EOL]             } [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return new BigInteger(text); [EOL]             } [EOL]             long value = Long.parseLong(text); [EOL]             if (value <= Integer.MAX_VALUE && value >= Integer.MIN_VALUE) { [EOL]                 return Integer.valueOf((int) value); [EOL]             } [EOL]             return Long.valueOf(value); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "not a valid number"); [EOL]         } [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
@Override [EOL] public Number deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]             return jp.getBigIntegerValue(); [EOL]         } [EOL]         return jp.getNumberValue(); [EOL]     } else if (t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]             return jp.getDecimalValue(); [EOL]         } [EOL]         return Double.valueOf(jp.getDoubleValue()); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         try { [EOL]             if (text.indexOf('.') >= 0) { [EOL]                 if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                     return new BigDecimal(text); [EOL]                 } [EOL]                 return new Double(text); [EOL]             } [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return new BigInteger(text); [EOL]             } [EOL]             long value = Long.parseLong(text); [EOL]             if (value <= Integer.MAX_VALUE && value >= Integer.MIN_VALUE) { [EOL]                 return Integer.valueOf((int) value); [EOL]             } [EOL]             return Long.valueOf(value); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "not a valid number"); [EOL]         } [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
@Override [EOL] public Number deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]             return jp.getBigIntegerValue(); [EOL]         } [EOL]         return jp.getNumberValue(); [EOL]     } else if (t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]             return jp.getDecimalValue(); [EOL]         } [EOL]         return Double.valueOf(jp.getDoubleValue()); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         try { [EOL]             if (text.indexOf('.') >= 0) { [EOL]                 if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                     return new BigDecimal(text); [EOL]                 } [EOL]                 return new Double(text); [EOL]             } [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return new BigInteger(text); [EOL]             } [EOL]             long value = Long.parseLong(text); [EOL]             if (value <= Integer.MAX_VALUE && value >= Integer.MIN_VALUE) { [EOL]                 return Integer.valueOf((int) value); [EOL]             } [EOL]             return Long.valueOf(value); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "not a valid number"); [EOL]         } [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
@SuppressWarnings("incomplete-switch") [EOL] @Override [EOL] public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case VALUE_NUMBER_INT: [EOL]         case VALUE_NUMBER_FLOAT: [EOL]         case VALUE_STRING: [EOL]             return deserialize(jp, ctxt); [EOL]     } [EOL]     return typeDeserializer.deserializeTypedFromScalar(jp, ctxt); [EOL] }
@SuppressWarnings("incomplete-switch") [EOL] @Override [EOL] public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case VALUE_NUMBER_INT: [EOL]         case VALUE_NUMBER_FLOAT: [EOL]         case VALUE_STRING: [EOL]             return deserialize(jp, ctxt); [EOL]     } [EOL]     return typeDeserializer.deserializeTypedFromScalar(jp, ctxt); [EOL] }
@SuppressWarnings("incomplete-switch") [EOL] @Override [EOL] public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case VALUE_NUMBER_INT: [EOL]         case VALUE_NUMBER_FLOAT: [EOL]         case VALUE_STRING: [EOL]             return deserialize(jp, ctxt); [EOL]     } [EOL]     return typeDeserializer.deserializeTypedFromScalar(jp, ctxt); [EOL] }
@SuppressWarnings("incomplete-switch") [EOL] @Override [EOL] public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case VALUE_NUMBER_INT: [EOL]         case VALUE_NUMBER_FLOAT: [EOL]         case VALUE_STRING: [EOL]             return deserialize(jp, ctxt); [EOL]     } [EOL]     return typeDeserializer.deserializeTypedFromScalar(jp, ctxt); [EOL] }
public BigIntegerDeserializer() { [EOL]     super(BigInteger.class); [EOL] }
@SuppressWarnings("incomplete-switch") [EOL] @Override [EOL] public BigInteger deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     String text; [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         switch(jp.getNumberType()) { [EOL]             case INT: [EOL]             case LONG: [EOL]                 return BigInteger.valueOf(jp.getLongValue()); [EOL]         } [EOL]     } else if (t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getDecimalValue().toBigInteger(); [EOL]     } else if (t != JsonToken.VALUE_STRING) { [EOL]         throw ctxt.mappingException(_valueClass, t); [EOL]     } [EOL]     text = jp.getText().trim(); [EOL]     if (text.length() == 0) { [EOL]         return null; [EOL]     } [EOL]     try { [EOL]         return new BigInteger(text); [EOL]     } catch (IllegalArgumentException iae) { [EOL]         throw ctxt.weirdStringException(text, _valueClass, "not a valid representation"); [EOL]     } [EOL] }
@SuppressWarnings("incomplete-switch") [EOL] @Override [EOL] public BigInteger deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     String text; [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         switch(jp.getNumberType()) { [EOL]             case INT: [EOL]             case LONG: [EOL]                 return BigInteger.valueOf(jp.getLongValue()); [EOL]         } [EOL]     } else if (t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getDecimalValue().toBigInteger(); [EOL]     } else if (t != JsonToken.VALUE_STRING) { [EOL]         throw ctxt.mappingException(_valueClass, t); [EOL]     } [EOL]     text = jp.getText().trim(); [EOL]     if (text.length() == 0) { [EOL]         return null; [EOL]     } [EOL]     try { [EOL]         return new BigInteger(text); [EOL]     } catch (IllegalArgumentException iae) { [EOL]         throw ctxt.weirdStringException(text, _valueClass, "not a valid representation"); [EOL]     } [EOL] }
@SuppressWarnings("incomplete-switch") [EOL] @Override [EOL] public BigInteger deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     String text; [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         switch(jp.getNumberType()) { [EOL]             case INT: [EOL]             case LONG: [EOL]                 return BigInteger.valueOf(jp.getLongValue()); [EOL]         } [EOL]     } else if (t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getDecimalValue().toBigInteger(); [EOL]     } else if (t != JsonToken.VALUE_STRING) { [EOL]         throw ctxt.mappingException(_valueClass, t); [EOL]     } [EOL]     text = jp.getText().trim(); [EOL]     if (text.length() == 0) { [EOL]         return null; [EOL]     } [EOL]     try { [EOL]         return new BigInteger(text); [EOL]     } catch (IllegalArgumentException iae) { [EOL]         throw ctxt.weirdStringException(text, _valueClass, "not a valid representation"); [EOL]     } [EOL] }
@SuppressWarnings("incomplete-switch") [EOL] @Override [EOL] public BigInteger deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     String text; [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         switch(jp.getNumberType()) { [EOL]             case INT: [EOL]             case LONG: [EOL]                 return BigInteger.valueOf(jp.getLongValue()); [EOL]         } [EOL]     } else if (t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getDecimalValue().toBigInteger(); [EOL]     } else if (t != JsonToken.VALUE_STRING) { [EOL]         throw ctxt.mappingException(_valueClass, t); [EOL]     } [EOL]     text = jp.getText().trim(); [EOL]     if (text.length() == 0) { [EOL]         return null; [EOL]     } [EOL]     try { [EOL]         return new BigInteger(text); [EOL]     } catch (IllegalArgumentException iae) { [EOL]         throw ctxt.weirdStringException(text, _valueClass, "not a valid representation"); [EOL]     } [EOL] }
@SuppressWarnings("incomplete-switch") [EOL] @Override [EOL] public BigInteger deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     String text; [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         switch(jp.getNumberType()) { [EOL]             case INT: [EOL]             case LONG: [EOL]                 return BigInteger.valueOf(jp.getLongValue()); [EOL]         } [EOL]     } else if (t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getDecimalValue().toBigInteger(); [EOL]     } else if (t != JsonToken.VALUE_STRING) { [EOL]         throw ctxt.mappingException(_valueClass, t); [EOL]     } [EOL]     text = jp.getText().trim(); [EOL]     if (text.length() == 0) { [EOL]         return null; [EOL]     } [EOL]     try { [EOL]         return new BigInteger(text); [EOL]     } catch (IllegalArgumentException iae) { [EOL]         throw ctxt.weirdStringException(text, _valueClass, "not a valid representation"); [EOL]     } [EOL] }
@SuppressWarnings("incomplete-switch") [EOL] @Override [EOL] public BigInteger deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     String text; [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         switch(jp.getNumberType()) { [EOL]             case INT: [EOL]             case LONG: [EOL]                 return BigInteger.valueOf(jp.getLongValue()); [EOL]         } [EOL]     } else if (t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getDecimalValue().toBigInteger(); [EOL]     } else if (t != JsonToken.VALUE_STRING) { [EOL]         throw ctxt.mappingException(_valueClass, t); [EOL]     } [EOL]     text = jp.getText().trim(); [EOL]     if (text.length() == 0) { [EOL]         return null; [EOL]     } [EOL]     try { [EOL]         return new BigInteger(text); [EOL]     } catch (IllegalArgumentException iae) { [EOL]         throw ctxt.weirdStringException(text, _valueClass, "not a valid representation"); [EOL]     } [EOL] }
@SuppressWarnings("incomplete-switch") [EOL] @Override [EOL] public BigInteger deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     String text; [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         switch(jp.getNumberType()) { [EOL]             case INT: [EOL]             case LONG: [EOL]                 return BigInteger.valueOf(jp.getLongValue()); [EOL]         } [EOL]     } else if (t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getDecimalValue().toBigInteger(); [EOL]     } else if (t != JsonToken.VALUE_STRING) { [EOL]         throw ctxt.mappingException(_valueClass, t); [EOL]     } [EOL]     text = jp.getText().trim(); [EOL]     if (text.length() == 0) { [EOL]         return null; [EOL]     } [EOL]     try { [EOL]         return new BigInteger(text); [EOL]     } catch (IllegalArgumentException iae) { [EOL]         throw ctxt.weirdStringException(text, _valueClass, "not a valid representation"); [EOL]     } [EOL] }
protected StdKeyDeserializer(Class<?> cls) { [EOL]     _keyClass = cls; [EOL] }
private StringKD(Class<?> nominalType) { [EOL]     super(nominalType); [EOL] }
public static StringKD forType(Class<?> nominalType) { [EOL]     if (nominalType == String.class) { [EOL]         return sString; [EOL]     } [EOL]     if (nominalType == Object.class) { [EOL]         return sObject; [EOL]     } [EOL]     return new StringKD(nominalType); [EOL] }
public static StringKD forType(Class<?> nominalType) { [EOL]     if (nominalType == String.class) { [EOL]         return sString; [EOL]     } [EOL]     if (nominalType == Object.class) { [EOL]         return sObject; [EOL]     } [EOL]     return new StringKD(nominalType); [EOL] }
public static StringKD forType(Class<?> nominalType) { [EOL]     if (nominalType == String.class) { [EOL]         return sString; [EOL]     } [EOL]     if (nominalType == Object.class) { [EOL]         return sObject; [EOL]     } [EOL]     return new StringKD(nominalType); [EOL] }
@Override [EOL] public final String getCurrentName() { [EOL]     return _currentName; [EOL] }
@Override [EOL] public final String getCurrentName() { [EOL]     return _currentName; [EOL] }
@Override [EOL] public KeyDeserializer findKeyDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     if (raw == String.class || raw == Object.class) { [EOL]         return StdKeyDeserializer.StringKD.forType(raw); [EOL]     } [EOL]     if (raw == UUID.class) { [EOL]         return new StdKeyDeserializer.UuidKD(); [EOL]     } [EOL]     if (raw.isPrimitive()) { [EOL]         raw = ClassUtil.wrapperType(raw); [EOL]     } [EOL]     if (raw == Integer.class) { [EOL]         return new StdKeyDeserializer.IntKD(); [EOL]     } [EOL]     if (raw == Long.class) { [EOL]         return new StdKeyDeserializer.LongKD(); [EOL]     } [EOL]     if (raw == Date.class) { [EOL]         return new StdKeyDeserializer.DateKD(); [EOL]     } [EOL]     if (raw == Calendar.class) { [EOL]         return new StdKeyDeserializer.CalendarKD(); [EOL]     } [EOL]     if (raw == Boolean.class) { [EOL]         return new StdKeyDeserializer.BoolKD(); [EOL]     } [EOL]     if (raw == Byte.class) { [EOL]         return new StdKeyDeserializer.ByteKD(); [EOL]     } [EOL]     if (raw == Character.class) { [EOL]         return new StdKeyDeserializer.CharKD(); [EOL]     } [EOL]     if (raw == Short.class) { [EOL]         return new StdKeyDeserializer.ShortKD(); [EOL]     } [EOL]     if (raw == Float.class) { [EOL]         return new StdKeyDeserializer.FloatKD(); [EOL]     } [EOL]     if (raw == Double.class) { [EOL]         return new StdKeyDeserializer.DoubleKD(); [EOL]     } [EOL]     if (raw == Locale.class) { [EOL]         return new StdKeyDeserializer.LocaleKD(); [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public KeyDeserializer findKeyDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     if (raw == String.class || raw == Object.class) { [EOL]         return StdKeyDeserializer.StringKD.forType(raw); [EOL]     } [EOL]     if (raw == UUID.class) { [EOL]         return new StdKeyDeserializer.UuidKD(); [EOL]     } [EOL]     if (raw.isPrimitive()) { [EOL]         raw = ClassUtil.wrapperType(raw); [EOL]     } [EOL]     if (raw == Integer.class) { [EOL]         return new StdKeyDeserializer.IntKD(); [EOL]     } [EOL]     if (raw == Long.class) { [EOL]         return new StdKeyDeserializer.LongKD(); [EOL]     } [EOL]     if (raw == Date.class) { [EOL]         return new StdKeyDeserializer.DateKD(); [EOL]     } [EOL]     if (raw == Calendar.class) { [EOL]         return new StdKeyDeserializer.CalendarKD(); [EOL]     } [EOL]     if (raw == Boolean.class) { [EOL]         return new StdKeyDeserializer.BoolKD(); [EOL]     } [EOL]     if (raw == Byte.class) { [EOL]         return new StdKeyDeserializer.ByteKD(); [EOL]     } [EOL]     if (raw == Character.class) { [EOL]         return new StdKeyDeserializer.CharKD(); [EOL]     } [EOL]     if (raw == Short.class) { [EOL]         return new StdKeyDeserializer.ShortKD(); [EOL]     } [EOL]     if (raw == Float.class) { [EOL]         return new StdKeyDeserializer.FloatKD(); [EOL]     } [EOL]     if (raw == Double.class) { [EOL]         return new StdKeyDeserializer.DoubleKD(); [EOL]     } [EOL]     if (raw == Locale.class) { [EOL]         return new StdKeyDeserializer.LocaleKD(); [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public KeyDeserializer findKeyDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     if (raw == String.class || raw == Object.class) { [EOL]         return StdKeyDeserializer.StringKD.forType(raw); [EOL]     } [EOL]     if (raw == UUID.class) { [EOL]         return new StdKeyDeserializer.UuidKD(); [EOL]     } [EOL]     if (raw.isPrimitive()) { [EOL]         raw = ClassUtil.wrapperType(raw); [EOL]     } [EOL]     if (raw == Integer.class) { [EOL]         return new StdKeyDeserializer.IntKD(); [EOL]     } [EOL]     if (raw == Long.class) { [EOL]         return new StdKeyDeserializer.LongKD(); [EOL]     } [EOL]     if (raw == Date.class) { [EOL]         return new StdKeyDeserializer.DateKD(); [EOL]     } [EOL]     if (raw == Calendar.class) { [EOL]         return new StdKeyDeserializer.CalendarKD(); [EOL]     } [EOL]     if (raw == Boolean.class) { [EOL]         return new StdKeyDeserializer.BoolKD(); [EOL]     } [EOL]     if (raw == Byte.class) { [EOL]         return new StdKeyDeserializer.ByteKD(); [EOL]     } [EOL]     if (raw == Character.class) { [EOL]         return new StdKeyDeserializer.CharKD(); [EOL]     } [EOL]     if (raw == Short.class) { [EOL]         return new StdKeyDeserializer.ShortKD(); [EOL]     } [EOL]     if (raw == Float.class) { [EOL]         return new StdKeyDeserializer.FloatKD(); [EOL]     } [EOL]     if (raw == Double.class) { [EOL]         return new StdKeyDeserializer.DoubleKD(); [EOL]     } [EOL]     if (raw == Locale.class) { [EOL]         return new StdKeyDeserializer.LocaleKD(); [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public KeyDeserializer findKeyDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     if (raw == String.class || raw == Object.class) { [EOL]         return StdKeyDeserializer.StringKD.forType(raw); [EOL]     } [EOL]     if (raw == UUID.class) { [EOL]         return new StdKeyDeserializer.UuidKD(); [EOL]     } [EOL]     if (raw.isPrimitive()) { [EOL]         raw = ClassUtil.wrapperType(raw); [EOL]     } [EOL]     if (raw == Integer.class) { [EOL]         return new StdKeyDeserializer.IntKD(); [EOL]     } [EOL]     if (raw == Long.class) { [EOL]         return new StdKeyDeserializer.LongKD(); [EOL]     } [EOL]     if (raw == Date.class) { [EOL]         return new StdKeyDeserializer.DateKD(); [EOL]     } [EOL]     if (raw == Calendar.class) { [EOL]         return new StdKeyDeserializer.CalendarKD(); [EOL]     } [EOL]     if (raw == Boolean.class) { [EOL]         return new StdKeyDeserializer.BoolKD(); [EOL]     } [EOL]     if (raw == Byte.class) { [EOL]         return new StdKeyDeserializer.ByteKD(); [EOL]     } [EOL]     if (raw == Character.class) { [EOL]         return new StdKeyDeserializer.CharKD(); [EOL]     } [EOL]     if (raw == Short.class) { [EOL]         return new StdKeyDeserializer.ShortKD(); [EOL]     } [EOL]     if (raw == Float.class) { [EOL]         return new StdKeyDeserializer.FloatKD(); [EOL]     } [EOL]     if (raw == Double.class) { [EOL]         return new StdKeyDeserializer.DoubleKD(); [EOL]     } [EOL]     if (raw == Locale.class) { [EOL]         return new StdKeyDeserializer.LocaleKD(); [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public KeyDeserializer findKeyDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     if (raw == String.class || raw == Object.class) { [EOL]         return StdKeyDeserializer.StringKD.forType(raw); [EOL]     } [EOL]     if (raw == UUID.class) { [EOL]         return new StdKeyDeserializer.UuidKD(); [EOL]     } [EOL]     if (raw.isPrimitive()) { [EOL]         raw = ClassUtil.wrapperType(raw); [EOL]     } [EOL]     if (raw == Integer.class) { [EOL]         return new StdKeyDeserializer.IntKD(); [EOL]     } [EOL]     if (raw == Long.class) { [EOL]         return new StdKeyDeserializer.LongKD(); [EOL]     } [EOL]     if (raw == Date.class) { [EOL]         return new StdKeyDeserializer.DateKD(); [EOL]     } [EOL]     if (raw == Calendar.class) { [EOL]         return new StdKeyDeserializer.CalendarKD(); [EOL]     } [EOL]     if (raw == Boolean.class) { [EOL]         return new StdKeyDeserializer.BoolKD(); [EOL]     } [EOL]     if (raw == Byte.class) { [EOL]         return new StdKeyDeserializer.ByteKD(); [EOL]     } [EOL]     if (raw == Character.class) { [EOL]         return new StdKeyDeserializer.CharKD(); [EOL]     } [EOL]     if (raw == Short.class) { [EOL]         return new StdKeyDeserializer.ShortKD(); [EOL]     } [EOL]     if (raw == Float.class) { [EOL]         return new StdKeyDeserializer.FloatKD(); [EOL]     } [EOL]     if (raw == Double.class) { [EOL]         return new StdKeyDeserializer.DoubleKD(); [EOL]     } [EOL]     if (raw == Locale.class) { [EOL]         return new StdKeyDeserializer.LocaleKD(); [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public KeyDeserializer findKeyDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     if (raw == String.class || raw == Object.class) { [EOL]         return StdKeyDeserializer.StringKD.forType(raw); [EOL]     } [EOL]     if (raw == UUID.class) { [EOL]         return new StdKeyDeserializer.UuidKD(); [EOL]     } [EOL]     if (raw.isPrimitive()) { [EOL]         raw = ClassUtil.wrapperType(raw); [EOL]     } [EOL]     if (raw == Integer.class) { [EOL]         return new StdKeyDeserializer.IntKD(); [EOL]     } [EOL]     if (raw == Long.class) { [EOL]         return new StdKeyDeserializer.LongKD(); [EOL]     } [EOL]     if (raw == Date.class) { [EOL]         return new StdKeyDeserializer.DateKD(); [EOL]     } [EOL]     if (raw == Calendar.class) { [EOL]         return new StdKeyDeserializer.CalendarKD(); [EOL]     } [EOL]     if (raw == Boolean.class) { [EOL]         return new StdKeyDeserializer.BoolKD(); [EOL]     } [EOL]     if (raw == Byte.class) { [EOL]         return new StdKeyDeserializer.ByteKD(); [EOL]     } [EOL]     if (raw == Character.class) { [EOL]         return new StdKeyDeserializer.CharKD(); [EOL]     } [EOL]     if (raw == Short.class) { [EOL]         return new StdKeyDeserializer.ShortKD(); [EOL]     } [EOL]     if (raw == Float.class) { [EOL]         return new StdKeyDeserializer.FloatKD(); [EOL]     } [EOL]     if (raw == Double.class) { [EOL]         return new StdKeyDeserializer.DoubleKD(); [EOL]     } [EOL]     if (raw == Locale.class) { [EOL]         return new StdKeyDeserializer.LocaleKD(); [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public KeyDeserializer findKeyDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     if (raw == String.class || raw == Object.class) { [EOL]         return StdKeyDeserializer.StringKD.forType(raw); [EOL]     } [EOL]     if (raw == UUID.class) { [EOL]         return new StdKeyDeserializer.UuidKD(); [EOL]     } [EOL]     if (raw.isPrimitive()) { [EOL]         raw = ClassUtil.wrapperType(raw); [EOL]     } [EOL]     if (raw == Integer.class) { [EOL]         return new StdKeyDeserializer.IntKD(); [EOL]     } [EOL]     if (raw == Long.class) { [EOL]         return new StdKeyDeserializer.LongKD(); [EOL]     } [EOL]     if (raw == Date.class) { [EOL]         return new StdKeyDeserializer.DateKD(); [EOL]     } [EOL]     if (raw == Calendar.class) { [EOL]         return new StdKeyDeserializer.CalendarKD(); [EOL]     } [EOL]     if (raw == Boolean.class) { [EOL]         return new StdKeyDeserializer.BoolKD(); [EOL]     } [EOL]     if (raw == Byte.class) { [EOL]         return new StdKeyDeserializer.ByteKD(); [EOL]     } [EOL]     if (raw == Character.class) { [EOL]         return new StdKeyDeserializer.CharKD(); [EOL]     } [EOL]     if (raw == Short.class) { [EOL]         return new StdKeyDeserializer.ShortKD(); [EOL]     } [EOL]     if (raw == Float.class) { [EOL]         return new StdKeyDeserializer.FloatKD(); [EOL]     } [EOL]     if (raw == Double.class) { [EOL]         return new StdKeyDeserializer.DoubleKD(); [EOL]     } [EOL]     if (raw == Locale.class) { [EOL]         return new StdKeyDeserializer.LocaleKD(); [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public KeyDeserializer findKeyDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     if (raw == String.class || raw == Object.class) { [EOL]         return StdKeyDeserializer.StringKD.forType(raw); [EOL]     } [EOL]     if (raw == UUID.class) { [EOL]         return new StdKeyDeserializer.UuidKD(); [EOL]     } [EOL]     if (raw.isPrimitive()) { [EOL]         raw = ClassUtil.wrapperType(raw); [EOL]     } [EOL]     if (raw == Integer.class) { [EOL]         return new StdKeyDeserializer.IntKD(); [EOL]     } [EOL]     if (raw == Long.class) { [EOL]         return new StdKeyDeserializer.LongKD(); [EOL]     } [EOL]     if (raw == Date.class) { [EOL]         return new StdKeyDeserializer.DateKD(); [EOL]     } [EOL]     if (raw == Calendar.class) { [EOL]         return new StdKeyDeserializer.CalendarKD(); [EOL]     } [EOL]     if (raw == Boolean.class) { [EOL]         return new StdKeyDeserializer.BoolKD(); [EOL]     } [EOL]     if (raw == Byte.class) { [EOL]         return new StdKeyDeserializer.ByteKD(); [EOL]     } [EOL]     if (raw == Character.class) { [EOL]         return new StdKeyDeserializer.CharKD(); [EOL]     } [EOL]     if (raw == Short.class) { [EOL]         return new StdKeyDeserializer.ShortKD(); [EOL]     } [EOL]     if (raw == Float.class) { [EOL]         return new StdKeyDeserializer.FloatKD(); [EOL]     } [EOL]     if (raw == Double.class) { [EOL]         return new StdKeyDeserializer.DoubleKD(); [EOL]     } [EOL]     if (raw == Locale.class) { [EOL]         return new StdKeyDeserializer.LocaleKD(); [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public KeyDeserializer findKeyDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     if (raw == String.class || raw == Object.class) { [EOL]         return StdKeyDeserializer.StringKD.forType(raw); [EOL]     } [EOL]     if (raw == UUID.class) { [EOL]         return new StdKeyDeserializer.UuidKD(); [EOL]     } [EOL]     if (raw.isPrimitive()) { [EOL]         raw = ClassUtil.wrapperType(raw); [EOL]     } [EOL]     if (raw == Integer.class) { [EOL]         return new StdKeyDeserializer.IntKD(); [EOL]     } [EOL]     if (raw == Long.class) { [EOL]         return new StdKeyDeserializer.LongKD(); [EOL]     } [EOL]     if (raw == Date.class) { [EOL]         return new StdKeyDeserializer.DateKD(); [EOL]     } [EOL]     if (raw == Calendar.class) { [EOL]         return new StdKeyDeserializer.CalendarKD(); [EOL]     } [EOL]     if (raw == Boolean.class) { [EOL]         return new StdKeyDeserializer.BoolKD(); [EOL]     } [EOL]     if (raw == Byte.class) { [EOL]         return new StdKeyDeserializer.ByteKD(); [EOL]     } [EOL]     if (raw == Character.class) { [EOL]         return new StdKeyDeserializer.CharKD(); [EOL]     } [EOL]     if (raw == Short.class) { [EOL]         return new StdKeyDeserializer.ShortKD(); [EOL]     } [EOL]     if (raw == Float.class) { [EOL]         return new StdKeyDeserializer.FloatKD(); [EOL]     } [EOL]     if (raw == Double.class) { [EOL]         return new StdKeyDeserializer.DoubleKD(); [EOL]     } [EOL]     if (raw == Locale.class) { [EOL]         return new StdKeyDeserializer.LocaleKD(); [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public KeyDeserializer findKeyDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     if (raw == String.class || raw == Object.class) { [EOL]         return StdKeyDeserializer.StringKD.forType(raw); [EOL]     } [EOL]     if (raw == UUID.class) { [EOL]         return new StdKeyDeserializer.UuidKD(); [EOL]     } [EOL]     if (raw.isPrimitive()) { [EOL]         raw = ClassUtil.wrapperType(raw); [EOL]     } [EOL]     if (raw == Integer.class) { [EOL]         return new StdKeyDeserializer.IntKD(); [EOL]     } [EOL]     if (raw == Long.class) { [EOL]         return new StdKeyDeserializer.LongKD(); [EOL]     } [EOL]     if (raw == Date.class) { [EOL]         return new StdKeyDeserializer.DateKD(); [EOL]     } [EOL]     if (raw == Calendar.class) { [EOL]         return new StdKeyDeserializer.CalendarKD(); [EOL]     } [EOL]     if (raw == Boolean.class) { [EOL]         return new StdKeyDeserializer.BoolKD(); [EOL]     } [EOL]     if (raw == Byte.class) { [EOL]         return new StdKeyDeserializer.ByteKD(); [EOL]     } [EOL]     if (raw == Character.class) { [EOL]         return new StdKeyDeserializer.CharKD(); [EOL]     } [EOL]     if (raw == Short.class) { [EOL]         return new StdKeyDeserializer.ShortKD(); [EOL]     } [EOL]     if (raw == Float.class) { [EOL]         return new StdKeyDeserializer.FloatKD(); [EOL]     } [EOL]     if (raw == Double.class) { [EOL]         return new StdKeyDeserializer.DoubleKD(); [EOL]     } [EOL]     if (raw == Locale.class) { [EOL]         return new StdKeyDeserializer.LocaleKD(); [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public KeyDeserializer findKeyDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     if (raw == String.class || raw == Object.class) { [EOL]         return StdKeyDeserializer.StringKD.forType(raw); [EOL]     } [EOL]     if (raw == UUID.class) { [EOL]         return new StdKeyDeserializer.UuidKD(); [EOL]     } [EOL]     if (raw.isPrimitive()) { [EOL]         raw = ClassUtil.wrapperType(raw); [EOL]     } [EOL]     if (raw == Integer.class) { [EOL]         return new StdKeyDeserializer.IntKD(); [EOL]     } [EOL]     if (raw == Long.class) { [EOL]         return new StdKeyDeserializer.LongKD(); [EOL]     } [EOL]     if (raw == Date.class) { [EOL]         return new StdKeyDeserializer.DateKD(); [EOL]     } [EOL]     if (raw == Calendar.class) { [EOL]         return new StdKeyDeserializer.CalendarKD(); [EOL]     } [EOL]     if (raw == Boolean.class) { [EOL]         return new StdKeyDeserializer.BoolKD(); [EOL]     } [EOL]     if (raw == Byte.class) { [EOL]         return new StdKeyDeserializer.ByteKD(); [EOL]     } [EOL]     if (raw == Character.class) { [EOL]         return new StdKeyDeserializer.CharKD(); [EOL]     } [EOL]     if (raw == Short.class) { [EOL]         return new StdKeyDeserializer.ShortKD(); [EOL]     } [EOL]     if (raw == Float.class) { [EOL]         return new StdKeyDeserializer.FloatKD(); [EOL]     } [EOL]     if (raw == Double.class) { [EOL]         return new StdKeyDeserializer.DoubleKD(); [EOL]     } [EOL]     if (raw == Locale.class) { [EOL]         return new StdKeyDeserializer.LocaleKD(); [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public KeyDeserializer findKeyDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     if (raw == String.class || raw == Object.class) { [EOL]         return StdKeyDeserializer.StringKD.forType(raw); [EOL]     } [EOL]     if (raw == UUID.class) { [EOL]         return new StdKeyDeserializer.UuidKD(); [EOL]     } [EOL]     if (raw.isPrimitive()) { [EOL]         raw = ClassUtil.wrapperType(raw); [EOL]     } [EOL]     if (raw == Integer.class) { [EOL]         return new StdKeyDeserializer.IntKD(); [EOL]     } [EOL]     if (raw == Long.class) { [EOL]         return new StdKeyDeserializer.LongKD(); [EOL]     } [EOL]     if (raw == Date.class) { [EOL]         return new StdKeyDeserializer.DateKD(); [EOL]     } [EOL]     if (raw == Calendar.class) { [EOL]         return new StdKeyDeserializer.CalendarKD(); [EOL]     } [EOL]     if (raw == Boolean.class) { [EOL]         return new StdKeyDeserializer.BoolKD(); [EOL]     } [EOL]     if (raw == Byte.class) { [EOL]         return new StdKeyDeserializer.ByteKD(); [EOL]     } [EOL]     if (raw == Character.class) { [EOL]         return new StdKeyDeserializer.CharKD(); [EOL]     } [EOL]     if (raw == Short.class) { [EOL]         return new StdKeyDeserializer.ShortKD(); [EOL]     } [EOL]     if (raw == Float.class) { [EOL]         return new StdKeyDeserializer.FloatKD(); [EOL]     } [EOL]     if (raw == Double.class) { [EOL]         return new StdKeyDeserializer.DoubleKD(); [EOL]     } [EOL]     if (raw == Locale.class) { [EOL]         return new StdKeyDeserializer.LocaleKD(); [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public KeyDeserializer findKeyDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     if (raw == String.class || raw == Object.class) { [EOL]         return StdKeyDeserializer.StringKD.forType(raw); [EOL]     } [EOL]     if (raw == UUID.class) { [EOL]         return new StdKeyDeserializer.UuidKD(); [EOL]     } [EOL]     if (raw.isPrimitive()) { [EOL]         raw = ClassUtil.wrapperType(raw); [EOL]     } [EOL]     if (raw == Integer.class) { [EOL]         return new StdKeyDeserializer.IntKD(); [EOL]     } [EOL]     if (raw == Long.class) { [EOL]         return new StdKeyDeserializer.LongKD(); [EOL]     } [EOL]     if (raw == Date.class) { [EOL]         return new StdKeyDeserializer.DateKD(); [EOL]     } [EOL]     if (raw == Calendar.class) { [EOL]         return new StdKeyDeserializer.CalendarKD(); [EOL]     } [EOL]     if (raw == Boolean.class) { [EOL]         return new StdKeyDeserializer.BoolKD(); [EOL]     } [EOL]     if (raw == Byte.class) { [EOL]         return new StdKeyDeserializer.ByteKD(); [EOL]     } [EOL]     if (raw == Character.class) { [EOL]         return new StdKeyDeserializer.CharKD(); [EOL]     } [EOL]     if (raw == Short.class) { [EOL]         return new StdKeyDeserializer.ShortKD(); [EOL]     } [EOL]     if (raw == Float.class) { [EOL]         return new StdKeyDeserializer.FloatKD(); [EOL]     } [EOL]     if (raw == Double.class) { [EOL]         return new StdKeyDeserializer.DoubleKD(); [EOL]     } [EOL]     if (raw == Locale.class) { [EOL]         return new StdKeyDeserializer.LocaleKD(); [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public KeyDeserializer findKeyDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     if (raw == String.class || raw == Object.class) { [EOL]         return StdKeyDeserializer.StringKD.forType(raw); [EOL]     } [EOL]     if (raw == UUID.class) { [EOL]         return new StdKeyDeserializer.UuidKD(); [EOL]     } [EOL]     if (raw.isPrimitive()) { [EOL]         raw = ClassUtil.wrapperType(raw); [EOL]     } [EOL]     if (raw == Integer.class) { [EOL]         return new StdKeyDeserializer.IntKD(); [EOL]     } [EOL]     if (raw == Long.class) { [EOL]         return new StdKeyDeserializer.LongKD(); [EOL]     } [EOL]     if (raw == Date.class) { [EOL]         return new StdKeyDeserializer.DateKD(); [EOL]     } [EOL]     if (raw == Calendar.class) { [EOL]         return new StdKeyDeserializer.CalendarKD(); [EOL]     } [EOL]     if (raw == Boolean.class) { [EOL]         return new StdKeyDeserializer.BoolKD(); [EOL]     } [EOL]     if (raw == Byte.class) { [EOL]         return new StdKeyDeserializer.ByteKD(); [EOL]     } [EOL]     if (raw == Character.class) { [EOL]         return new StdKeyDeserializer.CharKD(); [EOL]     } [EOL]     if (raw == Short.class) { [EOL]         return new StdKeyDeserializer.ShortKD(); [EOL]     } [EOL]     if (raw == Float.class) { [EOL]         return new StdKeyDeserializer.FloatKD(); [EOL]     } [EOL]     if (raw == Double.class) { [EOL]         return new StdKeyDeserializer.DoubleKD(); [EOL]     } [EOL]     if (raw == Locale.class) { [EOL]         return new StdKeyDeserializer.LocaleKD(); [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public KeyDeserializer findKeyDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     if (raw == String.class || raw == Object.class) { [EOL]         return StdKeyDeserializer.StringKD.forType(raw); [EOL]     } [EOL]     if (raw == UUID.class) { [EOL]         return new StdKeyDeserializer.UuidKD(); [EOL]     } [EOL]     if (raw.isPrimitive()) { [EOL]         raw = ClassUtil.wrapperType(raw); [EOL]     } [EOL]     if (raw == Integer.class) { [EOL]         return new StdKeyDeserializer.IntKD(); [EOL]     } [EOL]     if (raw == Long.class) { [EOL]         return new StdKeyDeserializer.LongKD(); [EOL]     } [EOL]     if (raw == Date.class) { [EOL]         return new StdKeyDeserializer.DateKD(); [EOL]     } [EOL]     if (raw == Calendar.class) { [EOL]         return new StdKeyDeserializer.CalendarKD(); [EOL]     } [EOL]     if (raw == Boolean.class) { [EOL]         return new StdKeyDeserializer.BoolKD(); [EOL]     } [EOL]     if (raw == Byte.class) { [EOL]         return new StdKeyDeserializer.ByteKD(); [EOL]     } [EOL]     if (raw == Character.class) { [EOL]         return new StdKeyDeserializer.CharKD(); [EOL]     } [EOL]     if (raw == Short.class) { [EOL]         return new StdKeyDeserializer.ShortKD(); [EOL]     } [EOL]     if (raw == Float.class) { [EOL]         return new StdKeyDeserializer.FloatKD(); [EOL]     } [EOL]     if (raw == Double.class) { [EOL]         return new StdKeyDeserializer.DoubleKD(); [EOL]     } [EOL]     if (raw == Locale.class) { [EOL]         return new StdKeyDeserializer.LocaleKD(); [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public KeyDeserializer findKeyDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     if (raw == String.class || raw == Object.class) { [EOL]         return StdKeyDeserializer.StringKD.forType(raw); [EOL]     } [EOL]     if (raw == UUID.class) { [EOL]         return new StdKeyDeserializer.UuidKD(); [EOL]     } [EOL]     if (raw.isPrimitive()) { [EOL]         raw = ClassUtil.wrapperType(raw); [EOL]     } [EOL]     if (raw == Integer.class) { [EOL]         return new StdKeyDeserializer.IntKD(); [EOL]     } [EOL]     if (raw == Long.class) { [EOL]         return new StdKeyDeserializer.LongKD(); [EOL]     } [EOL]     if (raw == Date.class) { [EOL]         return new StdKeyDeserializer.DateKD(); [EOL]     } [EOL]     if (raw == Calendar.class) { [EOL]         return new StdKeyDeserializer.CalendarKD(); [EOL]     } [EOL]     if (raw == Boolean.class) { [EOL]         return new StdKeyDeserializer.BoolKD(); [EOL]     } [EOL]     if (raw == Byte.class) { [EOL]         return new StdKeyDeserializer.ByteKD(); [EOL]     } [EOL]     if (raw == Character.class) { [EOL]         return new StdKeyDeserializer.CharKD(); [EOL]     } [EOL]     if (raw == Short.class) { [EOL]         return new StdKeyDeserializer.ShortKD(); [EOL]     } [EOL]     if (raw == Float.class) { [EOL]         return new StdKeyDeserializer.FloatKD(); [EOL]     } [EOL]     if (raw == Double.class) { [EOL]         return new StdKeyDeserializer.DoubleKD(); [EOL]     } [EOL]     if (raw == Locale.class) { [EOL]         return new StdKeyDeserializer.LocaleKD(); [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public boolean hasSingleElement(Collection<?> value) { [EOL]     Iterator<?> it = value.iterator(); [EOL]     if (!it.hasNext()) { [EOL]         return false; [EOL]     } [EOL]     it.next(); [EOL]     return !it.hasNext(); [EOL] }
@Override [EOL] public boolean hasSingleElement(Collection<?> value) { [EOL]     Iterator<?> it = value.iterator(); [EOL]     if (!it.hasNext()) { [EOL]         return false; [EOL]     } [EOL]     it.next(); [EOL]     return !it.hasNext(); [EOL] }
@Override [EOL] public boolean hasSingleElement(Collection<?> value) { [EOL]     Iterator<?> it = value.iterator(); [EOL]     if (!it.hasNext()) { [EOL]         return false; [EOL]     } [EOL]     it.next(); [EOL]     return !it.hasNext(); [EOL] }
@Override [EOL] public void serializeContents(Collection<?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (_elementSerializer != null) { [EOL]         serializeContentsUsing(value, jgen, provider, _elementSerializer); [EOL]         return; [EOL]     } [EOL]     Iterator<?> it = value.iterator(); [EOL]     if (!it.hasNext()) { [EOL]         return; [EOL]     } [EOL]     PropertySerializerMap serializers = _dynamicSerializers; [EOL]     final TypeSerializer typeSer = _valueTypeSerializer; [EOL]     int i = 0; [EOL]     try { [EOL]         do { [EOL]             Object elem = it.next(); [EOL]             if (elem == null) { [EOL]                 provider.defaultSerializeNull(jgen); [EOL]             } else { [EOL]                 Class<?> cc = elem.getClass(); [EOL]                 JsonSerializer<Object> serializer = serializers.serializerFor(cc); [EOL]                 if (serializer == null) { [EOL]                     if (_elementType.hasGenericTypes()) { [EOL]                         serializer = _findAndAddDynamic(serializers, provider.constructSpecializedType(_elementType, cc), provider); [EOL]                     } else { [EOL]                         serializer = _findAndAddDynamic(serializers, cc, provider); [EOL]                     } [EOL]                     serializers = _dynamicSerializers; [EOL]                 } [EOL]                 if (typeSer == null) { [EOL]                     serializer.serialize(elem, jgen, provider); [EOL]                 } else { [EOL]                     serializer.serializeWithType(elem, jgen, provider, typeSer); [EOL]                 } [EOL]             } [EOL]             ++i; [EOL]         } while (it.hasNext()); [EOL]     } catch (Exception e) { [EOL]         wrapAndThrow(provider, e, value, i); [EOL]     } [EOL] }
@Override [EOL] public void serializeContents(Collection<?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (_elementSerializer != null) { [EOL]         serializeContentsUsing(value, jgen, provider, _elementSerializer); [EOL]         return; [EOL]     } [EOL]     Iterator<?> it = value.iterator(); [EOL]     if (!it.hasNext()) { [EOL]         return; [EOL]     } [EOL]     PropertySerializerMap serializers = _dynamicSerializers; [EOL]     final TypeSerializer typeSer = _valueTypeSerializer; [EOL]     int i = 0; [EOL]     try { [EOL]         do { [EOL]             Object elem = it.next(); [EOL]             if (elem == null) { [EOL]                 provider.defaultSerializeNull(jgen); [EOL]             } else { [EOL]                 Class<?> cc = elem.getClass(); [EOL]                 JsonSerializer<Object> serializer = serializers.serializerFor(cc); [EOL]                 if (serializer == null) { [EOL]                     if (_elementType.hasGenericTypes()) { [EOL]                         serializer = _findAndAddDynamic(serializers, provider.constructSpecializedType(_elementType, cc), provider); [EOL]                     } else { [EOL]                         serializer = _findAndAddDynamic(serializers, cc, provider); [EOL]                     } [EOL]                     serializers = _dynamicSerializers; [EOL]                 } [EOL]                 if (typeSer == null) { [EOL]                     serializer.serialize(elem, jgen, provider); [EOL]                 } else { [EOL]                     serializer.serializeWithType(elem, jgen, provider, typeSer); [EOL]                 } [EOL]             } [EOL]             ++i; [EOL]         } while (it.hasNext()); [EOL]     } catch (Exception e) { [EOL]         wrapAndThrow(provider, e, value, i); [EOL]     } [EOL] }
@Override [EOL] public void serializeContents(Collection<?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (_elementSerializer != null) { [EOL]         serializeContentsUsing(value, jgen, provider, _elementSerializer); [EOL]         return; [EOL]     } [EOL]     Iterator<?> it = value.iterator(); [EOL]     if (!it.hasNext()) { [EOL]         return; [EOL]     } [EOL]     PropertySerializerMap serializers = _dynamicSerializers; [EOL]     final TypeSerializer typeSer = _valueTypeSerializer; [EOL]     int i = 0; [EOL]     try { [EOL]         do { [EOL]             Object elem = it.next(); [EOL]             if (elem == null) { [EOL]                 provider.defaultSerializeNull(jgen); [EOL]             } else { [EOL]                 Class<?> cc = elem.getClass(); [EOL]                 JsonSerializer<Object> serializer = serializers.serializerFor(cc); [EOL]                 if (serializer == null) { [EOL]                     if (_elementType.hasGenericTypes()) { [EOL]                         serializer = _findAndAddDynamic(serializers, provider.constructSpecializedType(_elementType, cc), provider); [EOL]                     } else { [EOL]                         serializer = _findAndAddDynamic(serializers, cc, provider); [EOL]                     } [EOL]                     serializers = _dynamicSerializers; [EOL]                 } [EOL]                 if (typeSer == null) { [EOL]                     serializer.serialize(elem, jgen, provider); [EOL]                 } else { [EOL]                     serializer.serializeWithType(elem, jgen, provider, typeSer); [EOL]                 } [EOL]             } [EOL]             ++i; [EOL]         } while (it.hasNext()); [EOL]     } catch (Exception e) { [EOL]         wrapAndThrow(provider, e, value, i); [EOL]     } [EOL] }
@Override [EOL] public void serializeContents(Collection<?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (_elementSerializer != null) { [EOL]         serializeContentsUsing(value, jgen, provider, _elementSerializer); [EOL]         return; [EOL]     } [EOL]     Iterator<?> it = value.iterator(); [EOL]     if (!it.hasNext()) { [EOL]         return; [EOL]     } [EOL]     PropertySerializerMap serializers = _dynamicSerializers; [EOL]     final TypeSerializer typeSer = _valueTypeSerializer; [EOL]     int i = 0; [EOL]     try { [EOL]         do { [EOL]             Object elem = it.next(); [EOL]             if (elem == null) { [EOL]                 provider.defaultSerializeNull(jgen); [EOL]             } else { [EOL]                 Class<?> cc = elem.getClass(); [EOL]                 JsonSerializer<Object> serializer = serializers.serializerFor(cc); [EOL]                 if (serializer == null) { [EOL]                     if (_elementType.hasGenericTypes()) { [EOL]                         serializer = _findAndAddDynamic(serializers, provider.constructSpecializedType(_elementType, cc), provider); [EOL]                     } else { [EOL]                         serializer = _findAndAddDynamic(serializers, cc, provider); [EOL]                     } [EOL]                     serializers = _dynamicSerializers; [EOL]                 } [EOL]                 if (typeSer == null) { [EOL]                     serializer.serialize(elem, jgen, provider); [EOL]                 } else { [EOL]                     serializer.serializeWithType(elem, jgen, provider, typeSer); [EOL]                 } [EOL]             } [EOL]             ++i; [EOL]         } while (it.hasNext()); [EOL]     } catch (Exception e) { [EOL]         wrapAndThrow(provider, e, value, i); [EOL]     } [EOL] }
@Override [EOL] public void serializeContents(Collection<?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (_elementSerializer != null) { [EOL]         serializeContentsUsing(value, jgen, provider, _elementSerializer); [EOL]         return; [EOL]     } [EOL]     Iterator<?> it = value.iterator(); [EOL]     if (!it.hasNext()) { [EOL]         return; [EOL]     } [EOL]     PropertySerializerMap serializers = _dynamicSerializers; [EOL]     final TypeSerializer typeSer = _valueTypeSerializer; [EOL]     int i = 0; [EOL]     try { [EOL]         do { [EOL]             Object elem = it.next(); [EOL]             if (elem == null) { [EOL]                 provider.defaultSerializeNull(jgen); [EOL]             } else { [EOL]                 Class<?> cc = elem.getClass(); [EOL]                 JsonSerializer<Object> serializer = serializers.serializerFor(cc); [EOL]                 if (serializer == null) { [EOL]                     if (_elementType.hasGenericTypes()) { [EOL]                         serializer = _findAndAddDynamic(serializers, provider.constructSpecializedType(_elementType, cc), provider); [EOL]                     } else { [EOL]                         serializer = _findAndAddDynamic(serializers, cc, provider); [EOL]                     } [EOL]                     serializers = _dynamicSerializers; [EOL]                 } [EOL]                 if (typeSer == null) { [EOL]                     serializer.serialize(elem, jgen, provider); [EOL]                 } else { [EOL]                     serializer.serializeWithType(elem, jgen, provider, typeSer); [EOL]                 } [EOL]             } [EOL]             ++i; [EOL]         } while (it.hasNext()); [EOL]     } catch (Exception e) { [EOL]         wrapAndThrow(provider, e, value, i); [EOL]     } [EOL] }
@Override [EOL] public void serialize(List<String> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     final int len = value.size(); [EOL]     if ((len == 1) && provider.isEnabled(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED)) { [EOL]         _serializeUnwrapped(value, jgen, provider); [EOL]         return; [EOL]     } [EOL]     jgen.writeStartArray(); [EOL]     if (_serializer == null) { [EOL]         serializeContents(value, jgen, provider, len); [EOL]     } else { [EOL]         serializeUsingCustom(value, jgen, provider, len); [EOL]     } [EOL]     jgen.writeEndArray(); [EOL] }
@Override [EOL] public void serialize(List<String> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     final int len = value.size(); [EOL]     if ((len == 1) && provider.isEnabled(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED)) { [EOL]         _serializeUnwrapped(value, jgen, provider); [EOL]         return; [EOL]     } [EOL]     jgen.writeStartArray(); [EOL]     if (_serializer == null) { [EOL]         serializeContents(value, jgen, provider, len); [EOL]     } else { [EOL]         serializeUsingCustom(value, jgen, provider, len); [EOL]     } [EOL]     jgen.writeEndArray(); [EOL] }
@Override [EOL] public void serialize(List<String> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     final int len = value.size(); [EOL]     if ((len == 1) && provider.isEnabled(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED)) { [EOL]         _serializeUnwrapped(value, jgen, provider); [EOL]         return; [EOL]     } [EOL]     jgen.writeStartArray(); [EOL]     if (_serializer == null) { [EOL]         serializeContents(value, jgen, provider, len); [EOL]     } else { [EOL]         serializeUsingCustom(value, jgen, provider, len); [EOL]     } [EOL]     jgen.writeEndArray(); [EOL] }
@Override [EOL] public void serialize(List<String> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     final int len = value.size(); [EOL]     if ((len == 1) && provider.isEnabled(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED)) { [EOL]         _serializeUnwrapped(value, jgen, provider); [EOL]         return; [EOL]     } [EOL]     jgen.writeStartArray(); [EOL]     if (_serializer == null) { [EOL]         serializeContents(value, jgen, provider, len); [EOL]     } else { [EOL]         serializeUsingCustom(value, jgen, provider, len); [EOL]     } [EOL]     jgen.writeEndArray(); [EOL] }
private final void _serializeUnwrapped(List<String> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (_serializer == null) { [EOL]         serializeContents(value, jgen, provider, 1); [EOL]     } else { [EOL]         serializeUsingCustom(value, jgen, provider, 1); [EOL]     } [EOL] }
private final void _serializeUnwrapped(List<String> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (_serializer == null) { [EOL]         serializeContents(value, jgen, provider, 1); [EOL]     } else { [EOL]         serializeUsingCustom(value, jgen, provider, 1); [EOL]     } [EOL] }
public AtomicBooleanSerializer() { [EOL]     super(AtomicBoolean.class, false); [EOL] }
@Override [EOL] public void serialize(AtomicBoolean value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     jgen.writeBoolean(value.get()); [EOL] }
@Override [EOL] public void serialize(AtomicBoolean value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     jgen.writeBoolean(value.get()); [EOL] }
public AtomicIntegerSerializer() { [EOL]     super(AtomicInteger.class, false); [EOL] }
@Override [EOL] public void serialize(AtomicInteger value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     jgen.writeNumber(value.get()); [EOL] }
@Override [EOL] public JsonToken asToken() { [EOL]     return JsonToken.START_OBJECT; [EOL] }
@Override [EOL] public Iterator<JsonNode> elements() { [EOL]     return _children.values().iterator(); [EOL] }
@Override [EOL] public Iterator<JsonNode> elements() { [EOL]     return _children.values().iterator(); [EOL] }
@Override [EOL] public JsonNode get(int index) { [EOL]     return null; [EOL] }
@Override [EOL] public Iterator<String> fieldNames() { [EOL]     return _children.keySet().iterator(); [EOL] }
@Override [EOL] public Iterator<String> fieldNames() { [EOL]     return _children.keySet().iterator(); [EOL] }
@Override [EOL] public JsonNode path(String fieldName) { [EOL]     JsonNode n = _children.get(fieldName); [EOL]     if (n != null) { [EOL]         return n; [EOL]     } [EOL]     return MissingNode.getInstance(); [EOL] }
@Override [EOL] public JsonNode path(String fieldName) { [EOL]     JsonNode n = _children.get(fieldName); [EOL]     if (n != null) { [EOL]         return n; [EOL]     } [EOL]     return MissingNode.getInstance(); [EOL] }
@Override [EOL] public Iterator<Map.Entry<String, JsonNode>> fields() { [EOL]     return _children.entrySet().iterator(); [EOL] }
@Override [EOL] public Iterator<Map.Entry<String, JsonNode>> fields() { [EOL]     return _children.entrySet().iterator(); [EOL] }
@Override [EOL] public ObjectNode with(String propertyName) { [EOL]     JsonNode n = _children.get(propertyName); [EOL]     if (n != null) { [EOL]         if (n instanceof ObjectNode) { [EOL]             return (ObjectNode) n; [EOL]         } [EOL]         throw new UnsupportedOperationException("Property '" + propertyName + "' has value that is not of type ObjectNode (but " + n.getClass().getName() + ")"); [EOL]     } [EOL]     ObjectNode result = objectNode(); [EOL]     _children.put(propertyName, result); [EOL]     return result; [EOL] }
@Override [EOL] public ObjectNode with(String propertyName) { [EOL]     JsonNode n = _children.get(propertyName); [EOL]     if (n != null) { [EOL]         if (n instanceof ObjectNode) { [EOL]             return (ObjectNode) n; [EOL]         } [EOL]         throw new UnsupportedOperationException("Property '" + propertyName + "' has value that is not of type ObjectNode (but " + n.getClass().getName() + ")"); [EOL]     } [EOL]     ObjectNode result = objectNode(); [EOL]     _children.put(propertyName, result); [EOL]     return result; [EOL] }
@Override [EOL] public ObjectNode with(String propertyName) { [EOL]     JsonNode n = _children.get(propertyName); [EOL]     if (n != null) { [EOL]         if (n instanceof ObjectNode) { [EOL]             return (ObjectNode) n; [EOL]         } [EOL]         throw new UnsupportedOperationException("Property '" + propertyName + "' has value that is not of type ObjectNode (but " + n.getClass().getName() + ")"); [EOL]     } [EOL]     ObjectNode result = objectNode(); [EOL]     _children.put(propertyName, result); [EOL]     return result; [EOL] }
@Override [EOL] public ArrayNode withArray(String propertyName) { [EOL]     JsonNode n = _children.get(propertyName); [EOL]     if (n != null) { [EOL]         if (n instanceof ArrayNode) { [EOL]             return (ArrayNode) n; [EOL]         } [EOL]         throw new UnsupportedOperationException("Property '" + propertyName + "' has value that is not of type ArrayNode (but " + n.getClass().getName() + ")"); [EOL]     } [EOL]     ArrayNode result = arrayNode(); [EOL]     _children.put(propertyName, result); [EOL]     return result; [EOL] }
@Override [EOL] public ArrayNode withArray(String propertyName) { [EOL]     JsonNode n = _children.get(propertyName); [EOL]     if (n != null) { [EOL]         if (n instanceof ArrayNode) { [EOL]             return (ArrayNode) n; [EOL]         } [EOL]         throw new UnsupportedOperationException("Property '" + propertyName + "' has value that is not of type ArrayNode (but " + n.getClass().getName() + ")"); [EOL]     } [EOL]     ArrayNode result = arrayNode(); [EOL]     _children.put(propertyName, result); [EOL]     return result; [EOL] }
@Override [EOL] public ArrayNode withArray(String propertyName) { [EOL]     JsonNode n = _children.get(propertyName); [EOL]     if (n != null) { [EOL]         if (n instanceof ArrayNode) { [EOL]             return (ArrayNode) n; [EOL]         } [EOL]         throw new UnsupportedOperationException("Property '" + propertyName + "' has value that is not of type ArrayNode (but " + n.getClass().getName() + ")"); [EOL]     } [EOL]     ArrayNode result = arrayNode(); [EOL]     _children.put(propertyName, result); [EOL]     return result; [EOL] }
@Override [EOL] public JsonNode findValue(String fieldName) { [EOL]     for (Map.Entry<String, JsonNode> entry : _children.entrySet()) { [EOL]         if (fieldName.equals(entry.getKey())) { [EOL]             return entry.getValue(); [EOL]         } [EOL]         JsonNode value = entry.getValue().findValue(fieldName); [EOL]         if (value != null) { [EOL]             return value; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public JsonNode findValue(String fieldName) { [EOL]     for (Map.Entry<String, JsonNode> entry : _children.entrySet()) { [EOL]         if (fieldName.equals(entry.getKey())) { [EOL]             return entry.getValue(); [EOL]         } [EOL]         JsonNode value = entry.getValue().findValue(fieldName); [EOL]         if (value != null) { [EOL]             return value; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public JsonNode findValue(String fieldName) { [EOL]     for (Map.Entry<String, JsonNode> entry : _children.entrySet()) { [EOL]         if (fieldName.equals(entry.getKey())) { [EOL]             return entry.getValue(); [EOL]         } [EOL]         JsonNode value = entry.getValue().findValue(fieldName); [EOL]         if (value != null) { [EOL]             return value; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public ObjectNode findParent(String fieldName) { [EOL]     for (Map.Entry<String, JsonNode> entry : _children.entrySet()) { [EOL]         if (fieldName.equals(entry.getKey())) { [EOL]             return this; [EOL]         } [EOL]         JsonNode value = entry.getValue().findParent(fieldName); [EOL]         if (value != null) { [EOL]             return (ObjectNode) value; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public ObjectNode findParent(String fieldName) { [EOL]     for (Map.Entry<String, JsonNode> entry : _children.entrySet()) { [EOL]         if (fieldName.equals(entry.getKey())) { [EOL]             return this; [EOL]         } [EOL]         JsonNode value = entry.getValue().findParent(fieldName); [EOL]         if (value != null) { [EOL]             return (ObjectNode) value; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public ObjectNode findParent(String fieldName) { [EOL]     for (Map.Entry<String, JsonNode> entry : _children.entrySet()) { [EOL]         if (fieldName.equals(entry.getKey())) { [EOL]             return this; [EOL]         } [EOL]         JsonNode value = entry.getValue().findParent(fieldName); [EOL]         if (value != null) { [EOL]             return (ObjectNode) value; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public ObjectNode without(Collection<String> fieldNames) { [EOL]     _children.keySet().removeAll(fieldNames); [EOL]     return this; [EOL] }
public ObjectNode without(Collection<String> fieldNames) { [EOL]     _children.keySet().removeAll(fieldNames); [EOL]     return this; [EOL] }
public JsonNode remove(String fieldName) { [EOL]     return _children.remove(fieldName); [EOL] }
public JsonNode remove(String fieldName) { [EOL]     return _children.remove(fieldName); [EOL] }
@Override [EOL] public ObjectNode removeAll() { [EOL]     _children.clear(); [EOL]     return this; [EOL] }
@Override [EOL] public ObjectNode removeAll() { [EOL]     _children.clear(); [EOL]     return this; [EOL] }
public ObjectNode put(String fieldName, int v) { [EOL]     _children.put(fieldName, numberNode(v)); [EOL]     return this; [EOL] }
public ObjectNode put(String fieldName, boolean v) { [EOL]     _children.put(fieldName, booleanNode(v)); [EOL]     return this; [EOL] }
public ObjectNode put(String fieldName, boolean v) { [EOL]     _children.put(fieldName, booleanNode(v)); [EOL]     return this; [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (getClass() != o.getClass()) { [EOL]         return false; [EOL]     } [EOL]     return _children.equals(((ObjectNode) o)._children); [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (getClass() != o.getClass()) { [EOL]         return false; [EOL]     } [EOL]     return _children.equals(((ObjectNode) o)._children); [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (getClass() != o.getClass()) { [EOL]         return false; [EOL]     } [EOL]     return _children.equals(((ObjectNode) o)._children); [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (getClass() != o.getClass()) { [EOL]         return false; [EOL]     } [EOL]     return _children.equals(((ObjectNode) o)._children); [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (getClass() != o.getClass()) { [EOL]         return false; [EOL]     } [EOL]     return _children.equals(((ObjectNode) o)._children); [EOL] }
@Override [EOL] public int hashCode() { [EOL]     return _children.hashCode(); [EOL] }
@Override [EOL] public int hashCode() { [EOL]     return _children.hashCode(); [EOL] }
@Override [EOL] public String toString() { [EOL]     StringBuilder sb = new StringBuilder(32 + (size() << 4)); [EOL]     sb.append("{"); [EOL]     int count = 0; [EOL]     for (Map.Entry<String, JsonNode> en : _children.entrySet()) { [EOL]         if (count > 0) { [EOL]             sb.append(","); [EOL]         } [EOL]         ++count; [EOL]         TextNode.appendQuoted(sb, en.getKey()); [EOL]         sb.append(':'); [EOL]         sb.append(en.getValue().toString()); [EOL]     } [EOL]     sb.append("}"); [EOL]     return sb.toString(); [EOL] }
@Override [EOL] public String toString() { [EOL]     StringBuilder sb = new StringBuilder(32 + (size() << 4)); [EOL]     sb.append("{"); [EOL]     int count = 0; [EOL]     for (Map.Entry<String, JsonNode> en : _children.entrySet()) { [EOL]         if (count > 0) { [EOL]             sb.append(","); [EOL]         } [EOL]         ++count; [EOL]         TextNode.appendQuoted(sb, en.getKey()); [EOL]         sb.append(':'); [EOL]         sb.append(en.getValue().toString()); [EOL]     } [EOL]     sb.append("}"); [EOL]     return sb.toString(); [EOL] }
@Override [EOL] public String toString() { [EOL]     StringBuilder sb = new StringBuilder(32 + (size() << 4)); [EOL]     sb.append("{"); [EOL]     int count = 0; [EOL]     for (Map.Entry<String, JsonNode> en : _children.entrySet()) { [EOL]         if (count > 0) { [EOL]             sb.append(","); [EOL]         } [EOL]         ++count; [EOL]         TextNode.appendQuoted(sb, en.getKey()); [EOL]         sb.append(':'); [EOL]         sb.append(en.getValue().toString()); [EOL]     } [EOL]     sb.append("}"); [EOL]     return sb.toString(); [EOL] }
public static String okNameForRegularGetter(AnnotatedMethod am, String name) { [EOL]     if (name.startsWith("get")) { [EOL]         if ("getCallbacks".equals(name)) { [EOL]             if (isCglibGetCallbacks(am)) { [EOL]                 return null; [EOL]             } [EOL]         } else if ("getMetaClass".equals(name)) { [EOL]             if (isGroovyMetaClassGetter(am)) { [EOL]                 return null; [EOL]             } [EOL]         } [EOL]         return manglePropertyName(name.substring(3)); [EOL]     } [EOL]     return null; [EOL] }
public static String okNameForRegularGetter(AnnotatedMethod am, String name) { [EOL]     if (name.startsWith("get")) { [EOL]         if ("getCallbacks".equals(name)) { [EOL]             if (isCglibGetCallbacks(am)) { [EOL]                 return null; [EOL]             } [EOL]         } else if ("getMetaClass".equals(name)) { [EOL]             if (isGroovyMetaClassGetter(am)) { [EOL]                 return null; [EOL]             } [EOL]         } [EOL]         return manglePropertyName(name.substring(3)); [EOL]     } [EOL]     return null; [EOL] }
public static String okNameForIsGetter(AnnotatedMethod am, String name) { [EOL]     if (name.startsWith("is")) { [EOL]         Class<?> rt = am.getRawType(); [EOL]         if (rt != Boolean.class && rt != Boolean.TYPE) { [EOL]             return null; [EOL]         } [EOL]         return manglePropertyName(name.substring(2)); [EOL]     } [EOL]     return null; [EOL] }
public static String okNameForIsGetter(AnnotatedMethod am, String name) { [EOL]     if (name.startsWith("is")) { [EOL]         Class<?> rt = am.getRawType(); [EOL]         if (rt != Boolean.class && rt != Boolean.TYPE) { [EOL]             return null; [EOL]         } [EOL]         return manglePropertyName(name.substring(2)); [EOL]     } [EOL]     return null; [EOL] }
public MappingJsonFactory() { [EOL]     this(null); [EOL] }
public MappingJsonFactory(ObjectMapper mapper) { [EOL]     super(mapper); [EOL]     if (mapper == null) { [EOL]         setCodec(new ObjectMapper(this)); [EOL]     } [EOL] }
public MappingJsonFactory(ObjectMapper mapper) { [EOL]     super(mapper); [EOL]     if (mapper == null) { [EOL]         setCodec(new ObjectMapper(this)); [EOL]     } [EOL] }
@Override [EOL] public final ObjectMapper getCodec() { [EOL]     return (ObjectMapper) _objectCodec; [EOL] }
@Override [EOL] public final ObjectMapper getCodec() { [EOL]     return (ObjectMapper) _objectCodec; [EOL] }
@Override [EOL] public JsonToken asToken() { [EOL]     return JsonToken.VALUE_NUMBER_INT; [EOL] }
@Override [EOL] public String asText() { [EOL]     return NumberOutput.toString(_value); [EOL] }
@Override [EOL] public String asText() { [EOL]     return NumberOutput.toString(_value); [EOL] }
@Override [EOL] public String asText() { [EOL]     return NumberOutput.toString(_value); [EOL] }
@Override [EOL] public final void serialize(JsonGenerator jg, SerializerProvider provider) throws IOException, JsonProcessingException { [EOL]     jg.writeNumber(_value); [EOL] }
public FloatNode(float v) { [EOL]     _value = v; [EOL] }
public static FloatNode valueOf(float v) { [EOL]     return new FloatNode(v); [EOL] }
public static FloatNode valueOf(float v) { [EOL]     return new FloatNode(v); [EOL] }
public static FloatNode valueOf(float v) { [EOL]     return new FloatNode(v); [EOL] }
@Override [EOL] public JsonToken asToken() { [EOL]     return JsonToken.VALUE_NUMBER_FLOAT; [EOL] }
@Override [EOL] public JsonParser.NumberType numberType() { [EOL]     return JsonParser.NumberType.FLOAT; [EOL] }
@Override [EOL] public boolean canConvertToInt() { [EOL]     return (_value >= Integer.MIN_VALUE && _value <= Integer.MAX_VALUE); [EOL] }
@Override [EOL] public boolean canConvertToInt() { [EOL]     return (_value >= Integer.MIN_VALUE && _value <= Integer.MAX_VALUE); [EOL] }
@Override [EOL] public boolean canConvertToInt() { [EOL]     return (_value >= Integer.MIN_VALUE && _value <= Integer.MAX_VALUE); [EOL] }
@Override [EOL] public boolean canConvertToInt() { [EOL]     return (_value >= Integer.MIN_VALUE && _value <= Integer.MAX_VALUE); [EOL] }
@Override [EOL] public boolean canConvertToLong() { [EOL]     return (_value >= Long.MIN_VALUE && _value <= Long.MAX_VALUE); [EOL] }
@Override [EOL] public boolean canConvertToLong() { [EOL]     return (_value >= Long.MIN_VALUE && _value <= Long.MAX_VALUE); [EOL] }
@Override [EOL] public boolean canConvertToLong() { [EOL]     return (_value >= Long.MIN_VALUE && _value <= Long.MAX_VALUE); [EOL] }
@Override [EOL] public boolean canConvertToLong() { [EOL]     return (_value >= Long.MIN_VALUE && _value <= Long.MAX_VALUE); [EOL] }
@Override [EOL] public int intValue() { [EOL]     return (int) _value; [EOL] }
@Override [EOL] public int intValue() { [EOL]     return (int) _value; [EOL] }
@Override [EOL] public int intValue() { [EOL]     return (int) _value; [EOL] }
@Override [EOL] public long longValue() { [EOL]     return (long) _value; [EOL] }
@Override [EOL] public long longValue() { [EOL]     return (long) _value; [EOL] }
@Override [EOL] public long longValue() { [EOL]     return (long) _value; [EOL] }
@Override [EOL] public long longValue() { [EOL]     return (long) _value; [EOL] }
@Override [EOL] public long longValue() { [EOL]     return (long) _value; [EOL] }
@Override [EOL] public float floatValue() { [EOL]     return (float) _value; [EOL] }
@Override [EOL] public float floatValue() { [EOL]     return (float) _value; [EOL] }
@Override [EOL] public float floatValue() { [EOL]     return (float) _value; [EOL] }
@Override [EOL] public float floatValue() { [EOL]     return (float) _value; [EOL] }
@Override [EOL] public float floatValue() { [EOL]     return (float) _value; [EOL] }
@Override [EOL] public double doubleValue() { [EOL]     return _value; [EOL] }
@Override [EOL] public double doubleValue() { [EOL]     return _value; [EOL] }
@Override [EOL] public double doubleValue() { [EOL]     return _value; [EOL] }
@Override [EOL] public BigDecimal decimalValue() { [EOL]     return BigDecimal.valueOf(_value); [EOL] }
@Override [EOL] public BigDecimal decimalValue() { [EOL]     return BigDecimal.valueOf(_value); [EOL] }
@Override [EOL] public BigDecimal decimalValue() { [EOL]     return BigDecimal.valueOf(_value); [EOL] }
@Override [EOL] public BigInteger bigIntegerValue() { [EOL]     return decimalValue().toBigInteger(); [EOL] }
@Override [EOL] public BigInteger bigIntegerValue() { [EOL]     return decimalValue().toBigInteger(); [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) { [EOL]         return false; [EOL]     } [EOL]     final float otherValue = ((FloatNode) o)._value; [EOL]     return Float.compare(_value, otherValue) == 0; [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) { [EOL]         return false; [EOL]     } [EOL]     final float otherValue = ((FloatNode) o)._value; [EOL]     return Float.compare(_value, otherValue) == 0; [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) { [EOL]         return false; [EOL]     } [EOL]     final float otherValue = ((FloatNode) o)._value; [EOL]     return Float.compare(_value, otherValue) == 0; [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) { [EOL]         return false; [EOL]     } [EOL]     final float otherValue = ((FloatNode) o)._value; [EOL]     return Float.compare(_value, otherValue) == 0; [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) { [EOL]         return false; [EOL]     } [EOL]     final float otherValue = ((FloatNode) o)._value; [EOL]     return Float.compare(_value, otherValue) == 0; [EOL] }
@Override [EOL] public int hashCode() { [EOL]     return Float.floatToIntBits(_value); [EOL] }
@Override [EOL] public int hashCode() { [EOL]     return Float.floatToIntBits(_value); [EOL] }
@Override [EOL] public int hashCode() { [EOL]     return Float.floatToIntBits(_value); [EOL] }
@Override [EOL] public int hashCode() { [EOL]     return Float.floatToIntBits(_value); [EOL] }
@Override [EOL] public int hashCode() { [EOL]     return Float.floatToIntBits(_value); [EOL] }
@Override [EOL] public int hashCode() { [EOL]     return Float.floatToIntBits(_value); [EOL] }
public void addPropertyCreator(AnnotatedWithParams creator, CreatorProperty[] properties) { [EOL]     _propertyBasedCreator = verifyNonDup(creator, _propertyBasedCreator, "property-based"); [EOL]     if (properties.length > 1) { [EOL]         HashMap<String, Integer> names = new HashMap<String, Integer>(); [EOL]         for (int i = 0, len = properties.length; i < len; ++i) { [EOL]             String name = properties[i].getName(); [EOL]             if (name.length() == 0 && properties[i].getInjectableValueId() != null) { [EOL]                 continue; [EOL]             } [EOL]             Integer old = names.put(name, Integer.valueOf(i)); [EOL]             if (old != null) { [EOL]                 throw new IllegalArgumentException("Duplicate creator property \"" + name + "\" (index " + old + " vs " + i + ")"); [EOL]             } [EOL]         } [EOL]     } [EOL]     _propertyBasedArgs = properties; [EOL] }
public void addPropertyCreator(AnnotatedWithParams creator, CreatorProperty[] properties) { [EOL]     _propertyBasedCreator = verifyNonDup(creator, _propertyBasedCreator, "property-based"); [EOL]     if (properties.length > 1) { [EOL]         HashMap<String, Integer> names = new HashMap<String, Integer>(); [EOL]         for (int i = 0, len = properties.length; i < len; ++i) { [EOL]             String name = properties[i].getName(); [EOL]             if (name.length() == 0 && properties[i].getInjectableValueId() != null) { [EOL]                 continue; [EOL]             } [EOL]             Integer old = names.put(name, Integer.valueOf(i)); [EOL]             if (old != null) { [EOL]                 throw new IllegalArgumentException("Duplicate creator property \"" + name + "\" (index " + old + " vs " + i + ")"); [EOL]             } [EOL]         } [EOL]     } [EOL]     _propertyBasedArgs = properties; [EOL] }
public void addPropertyCreator(AnnotatedWithParams creator, CreatorProperty[] properties) { [EOL]     _propertyBasedCreator = verifyNonDup(creator, _propertyBasedCreator, "property-based"); [EOL]     if (properties.length > 1) { [EOL]         HashMap<String, Integer> names = new HashMap<String, Integer>(); [EOL]         for (int i = 0, len = properties.length; i < len; ++i) { [EOL]             String name = properties[i].getName(); [EOL]             if (name.length() == 0 && properties[i].getInjectableValueId() != null) { [EOL]                 continue; [EOL]             } [EOL]             Integer old = names.put(name, Integer.valueOf(i)); [EOL]             if (old != null) { [EOL]                 throw new IllegalArgumentException("Duplicate creator property \"" + name + "\" (index " + old + " vs " + i + ")"); [EOL]             } [EOL]         } [EOL]     } [EOL]     _propertyBasedArgs = properties; [EOL] }
public void addPropertyCreator(AnnotatedWithParams creator, CreatorProperty[] properties) { [EOL]     _propertyBasedCreator = verifyNonDup(creator, _propertyBasedCreator, "property-based"); [EOL]     if (properties.length > 1) { [EOL]         HashMap<String, Integer> names = new HashMap<String, Integer>(); [EOL]         for (int i = 0, len = properties.length; i < len; ++i) { [EOL]             String name = properties[i].getName(); [EOL]             if (name.length() == 0 && properties[i].getInjectableValueId() != null) { [EOL]                 continue; [EOL]             } [EOL]             Integer old = names.put(name, Integer.valueOf(i)); [EOL]             if (old != null) { [EOL]                 throw new IllegalArgumentException("Duplicate creator property \"" + name + "\" (index " + old + " vs " + i + ")"); [EOL]             } [EOL]         } [EOL]     } [EOL]     _propertyBasedArgs = properties; [EOL] }
@Override [EOL] public JsonDeserializer<?> findCollectionDeserializer(CollectionType type, DeserializationConfig config, BeanDescription beanDesc, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException { [EOL]     return (_classMappings == null) ? null : _classMappings.get(new ClassKey(type.getRawClass())); [EOL] }
@Override [EOL] public JsonDeserializer<?> findCollectionDeserializer(CollectionType type, DeserializationConfig config, BeanDescription beanDesc, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException { [EOL]     return (_classMappings == null) ? null : _classMappings.get(new ClassKey(type.getRawClass())); [EOL] }
public DecimalNode(BigDecimal v) { [EOL]     _value = v; [EOL] }
public DecimalNode(BigDecimal v) { [EOL]     _value = v; [EOL] }
public DecimalNode(BigDecimal v) { [EOL]     _value = v; [EOL] }
public DecimalNode(BigDecimal v) { [EOL]     _value = v; [EOL] }
public static DecimalNode valueOf(BigDecimal d) { [EOL]     return new DecimalNode(d); [EOL] }
public static DecimalNode valueOf(BigDecimal d) { [EOL]     return new DecimalNode(d); [EOL] }
public static DecimalNode valueOf(BigDecimal d) { [EOL]     return new DecimalNode(d); [EOL] }
public static DecimalNode valueOf(BigDecimal d) { [EOL]     return new DecimalNode(d); [EOL] }
@Override [EOL] public boolean isFloatingPointNumber() { [EOL]     return true; [EOL] }
@Override [EOL] public boolean isBigDecimal() { [EOL]     return true; [EOL] }
@Override [EOL] public Number numberValue() { [EOL]     return _value; [EOL] }
@Override [EOL] public Number numberValue() { [EOL]     return _value; [EOL] }
@Override [EOL] public String asText() { [EOL]     return _value.toString(); [EOL] }
@Override [EOL] public String asText() { [EOL]     return _value.toString(); [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) { [EOL]         return false; [EOL]     } [EOL]     return ((DecimalNode) o)._value.equals(_value); [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) { [EOL]         return false; [EOL]     } [EOL]     return ((DecimalNode) o)._value.equals(_value); [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) { [EOL]         return false; [EOL]     } [EOL]     return ((DecimalNode) o)._value.equals(_value); [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) { [EOL]         return false; [EOL]     } [EOL]     return ((DecimalNode) o)._value.equals(_value); [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) { [EOL]         return false; [EOL]     } [EOL]     return ((DecimalNode) o)._value.equals(_value); [EOL] }
public static BasicBeanDescription forDeserialization(POJOPropertiesCollector coll) { [EOL]     BasicBeanDescription desc = new BasicBeanDescription(coll); [EOL]     desc._anySetterMethod = coll.getAnySetterMethod(); [EOL]     desc._ignoredPropertyNames = coll.getIgnoredPropertyNames(); [EOL]     desc._injectables = coll.getInjectables(); [EOL]     desc._jsonValueMethod = coll.getJsonValueMethod(); [EOL]     return desc; [EOL] }
public static BasicBeanDescription forDeserialization(POJOPropertiesCollector coll) { [EOL]     BasicBeanDescription desc = new BasicBeanDescription(coll); [EOL]     desc._anySetterMethod = coll.getAnySetterMethod(); [EOL]     desc._ignoredPropertyNames = coll.getIgnoredPropertyNames(); [EOL]     desc._injectables = coll.getInjectables(); [EOL]     desc._jsonValueMethod = coll.getJsonValueMethod(); [EOL]     return desc; [EOL] }
@Override [EOL] public Class<?> findPOJOBuilder() { [EOL]     return (_annotationIntrospector == null) ? null : _annotationIntrospector.findPOJOBuilder(_classInfo); [EOL] }
@Override [EOL] public Class<?> findPOJOBuilder() { [EOL]     return (_annotationIntrospector == null) ? null : _annotationIntrospector.findPOJOBuilder(_classInfo); [EOL] }
@Override [EOL] public Converter<Object, Object> findDeserializationConverter() { [EOL]     if (_annotationIntrospector == null) { [EOL]         return null; [EOL]     } [EOL]     return _createConverter(_annotationIntrospector.findDeserializationConverter(_classInfo)); [EOL] }
@Override [EOL] public Converter<Object, Object> findDeserializationConverter() { [EOL]     if (_annotationIntrospector == null) { [EOL]         return null; [EOL]     } [EOL]     return _createConverter(_annotationIntrospector.findDeserializationConverter(_classInfo)); [EOL] }
@Override [EOL] public boolean hasSingleElement(boolean[] value) { [EOL]     return (value.length == 1); [EOL] }
@Override [EOL] public boolean hasSingleElement(boolean[] value) { [EOL]     return (value.length == 1); [EOL] }
@Override [EOL] public boolean hasSingleElement(boolean[] value) { [EOL]     return (value.length == 1); [EOL] }
@Override [EOL] public void serializeContents(boolean[] value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     for (int i = 0, len = value.length; i < len; ++i) { [EOL]         jgen.writeBoolean(value[i]); [EOL]     } [EOL] }
@Override [EOL] public void serializeContents(boolean[] value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     for (int i = 0, len = value.length; i < len; ++i) { [EOL]         jgen.writeBoolean(value[i]); [EOL]     } [EOL] }
@Override [EOL] public void serializeContents(boolean[] value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     for (int i = 0, len = value.length; i < len; ++i) { [EOL]         jgen.writeBoolean(value[i]); [EOL]     } [EOL] }
@SuppressWarnings("cast") [EOL] @Override [EOL] public void serializeContents(short[] value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (_valueTypeSerializer != null) { [EOL]         for (int i = 0, len = value.length; i < len; ++i) { [EOL]             _valueTypeSerializer.writeTypePrefixForScalar(null, jgen, Short.TYPE); [EOL]             jgen.writeNumber(value[i]); [EOL]             _valueTypeSerializer.writeTypeSuffixForScalar(null, jgen); [EOL]         } [EOL]         return; [EOL]     } [EOL]     for (int i = 0, len = value.length; i < len; ++i) { [EOL]         jgen.writeNumber((int) value[i]); [EOL]     } [EOL] }
@SuppressWarnings("cast") [EOL] @Override [EOL] public void serializeContents(short[] value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (_valueTypeSerializer != null) { [EOL]         for (int i = 0, len = value.length; i < len; ++i) { [EOL]             _valueTypeSerializer.writeTypePrefixForScalar(null, jgen, Short.TYPE); [EOL]             jgen.writeNumber(value[i]); [EOL]             _valueTypeSerializer.writeTypeSuffixForScalar(null, jgen); [EOL]         } [EOL]         return; [EOL]     } [EOL]     for (int i = 0, len = value.length; i < len; ++i) { [EOL]         jgen.writeNumber((int) value[i]); [EOL]     } [EOL] }
@Override [EOL] public boolean hasSingleElement(int[] value) { [EOL]     return (value.length == 1); [EOL] }
@Override [EOL] public boolean hasSingleElement(int[] value) { [EOL]     return (value.length == 1); [EOL] }
@Override [EOL] public boolean hasSingleElement(int[] value) { [EOL]     return (value.length == 1); [EOL] }
@Override [EOL] public void serializeContents(int[] value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     for (int i = 0, len = value.length; i < len; ++i) { [EOL]         jgen.writeNumber(value[i]); [EOL]     } [EOL] }
@Override [EOL] public void serializeContents(int[] value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     for (int i = 0, len = value.length; i < len; ++i) { [EOL]         jgen.writeNumber(value[i]); [EOL]     } [EOL] }
private MapType(Class<?> mapType, JavaType keyT, JavaType valueT, Object valueHandler, Object typeHandler, boolean asStatic) { [EOL]     super(mapType, keyT, valueT, valueHandler, typeHandler, asStatic); [EOL] }
private MapType(Class<?> mapType, JavaType keyT, JavaType valueT, Object valueHandler, Object typeHandler, boolean asStatic) { [EOL]     super(mapType, keyT, valueT, valueHandler, typeHandler, asStatic); [EOL] }
public static MapType construct(Class<?> rawType, JavaType keyT, JavaType valueT) { [EOL]     return new MapType(rawType, keyT, valueT, null, null, false); [EOL] }
@Override [EOL] public JavaType narrowContentsBy(Class<?> contentClass) { [EOL]     if (contentClass == _valueType.getRawClass()) { [EOL]         return this; [EOL]     } [EOL]     return new MapType(_class, _keyType, _valueType.narrowBy(contentClass), _valueHandler, _typeHandler, _asStatic); [EOL] }
@Override [EOL] public JavaType narrowContentsBy(Class<?> contentClass) { [EOL]     if (contentClass == _valueType.getRawClass()) { [EOL]         return this; [EOL]     } [EOL]     return new MapType(_class, _keyType, _valueType.narrowBy(contentClass), _valueHandler, _typeHandler, _asStatic); [EOL] }
@Override [EOL] public JavaType widenContentsBy(Class<?> contentClass) { [EOL]     if (contentClass == _valueType.getRawClass()) { [EOL]         return this; [EOL]     } [EOL]     return new MapType(_class, _keyType, _valueType.widenBy(contentClass), _valueHandler, _typeHandler, _asStatic); [EOL] }
@Override [EOL] public JavaType widenContentsBy(Class<?> contentClass) { [EOL]     if (contentClass == _valueType.getRawClass()) { [EOL]         return this; [EOL]     } [EOL]     return new MapType(_class, _keyType, _valueType.widenBy(contentClass), _valueHandler, _typeHandler, _asStatic); [EOL] }
@Override [EOL] public JavaType narrowKey(Class<?> keySubclass) { [EOL]     if (keySubclass == _keyType.getRawClass()) { [EOL]         return this; [EOL]     } [EOL]     return new MapType(_class, _keyType.narrowBy(keySubclass), _valueType, _valueHandler, _typeHandler, _asStatic); [EOL] }
@Override [EOL] public JavaType narrowKey(Class<?> keySubclass) { [EOL]     if (keySubclass == _keyType.getRawClass()) { [EOL]         return this; [EOL]     } [EOL]     return new MapType(_class, _keyType.narrowBy(keySubclass), _valueType, _valueHandler, _typeHandler, _asStatic); [EOL] }
@Override [EOL] public JsonDeserializer<?> findBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     if (raw == QName.class) { [EOL]         return QNameDeserializer.instance; [EOL]     } [EOL]     if (raw == XMLGregorianCalendar.class) { [EOL]         return GregorianCalendarDeserializer.instance; [EOL]     } [EOL]     if (raw == Duration.class) { [EOL]         return DurationDeserializer.instance; [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public JsonDeserializer<?> findBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     if (raw == QName.class) { [EOL]         return QNameDeserializer.instance; [EOL]     } [EOL]     if (raw == XMLGregorianCalendar.class) { [EOL]         return GregorianCalendarDeserializer.instance; [EOL]     } [EOL]     if (raw == Duration.class) { [EOL]         return DurationDeserializer.instance; [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public JsonDeserializer<?> findBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     if (raw == QName.class) { [EOL]         return QNameDeserializer.instance; [EOL]     } [EOL]     if (raw == XMLGregorianCalendar.class) { [EOL]         return GregorianCalendarDeserializer.instance; [EOL]     } [EOL]     if (raw == Duration.class) { [EOL]         return DurationDeserializer.instance; [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public JsonDeserializer<?> findBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     if (raw == QName.class) { [EOL]         return QNameDeserializer.instance; [EOL]     } [EOL]     if (raw == XMLGregorianCalendar.class) { [EOL]         return GregorianCalendarDeserializer.instance; [EOL]     } [EOL]     if (raw == Duration.class) { [EOL]         return DurationDeserializer.instance; [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public XMLGregorianCalendar deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     Date d = _parseDate(jp, ctxt); [EOL]     if (d == null) { [EOL]         return null; [EOL]     } [EOL]     GregorianCalendar calendar = new GregorianCalendar(); [EOL]     calendar.setTime(d); [EOL]     TimeZone tz = ctxt.getTimeZone(); [EOL]     if (tz != null) { [EOL]         calendar.setTimeZone(tz); [EOL]     } [EOL]     return _dataTypeFactory.newXMLGregorianCalendar(calendar); [EOL] }
@Override [EOL] public XMLGregorianCalendar deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     Date d = _parseDate(jp, ctxt); [EOL]     if (d == null) { [EOL]         return null; [EOL]     } [EOL]     GregorianCalendar calendar = new GregorianCalendar(); [EOL]     calendar.setTime(d); [EOL]     TimeZone tz = ctxt.getTimeZone(); [EOL]     if (tz != null) { [EOL]         calendar.setTimeZone(tz); [EOL]     } [EOL]     return _dataTypeFactory.newXMLGregorianCalendar(calendar); [EOL] }
@Override [EOL] public XMLGregorianCalendar deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     Date d = _parseDate(jp, ctxt); [EOL]     if (d == null) { [EOL]         return null; [EOL]     } [EOL]     GregorianCalendar calendar = new GregorianCalendar(); [EOL]     calendar.setTime(d); [EOL]     TimeZone tz = ctxt.getTimeZone(); [EOL]     if (tz != null) { [EOL]         calendar.setTimeZone(tz); [EOL]     } [EOL]     return _dataTypeFactory.newXMLGregorianCalendar(calendar); [EOL] }
public BeanPropertyWriter unwrappingWriter(NameTransformer unwrapper) { [EOL]     return new UnwrappingBeanPropertyWriter(this, unwrapper); [EOL] }
public BeanPropertyWriter unwrappingWriter(NameTransformer unwrapper) { [EOL]     return new UnwrappingBeanPropertyWriter(this, unwrapper); [EOL] }
@Override [EOL] public String getName() { [EOL]     return _name.getValue(); [EOL] }
@Override [EOL] public boolean isRequired() { [EOL]     return _isRequired; [EOL] }
@Override [EOL] public boolean isRequired() { [EOL]     return _isRequired; [EOL] }
public JsonSerializer<Object> getSerializer() { [EOL]     return _serializer; [EOL] }
public Class<?> getRawSerializationType() { [EOL]     return (_cfgSerializationType == null) ? null : _cfgSerializationType.getRawClass(); [EOL] }
public Class<?> getRawSerializationType() { [EOL]     return (_cfgSerializationType == null) ? null : _cfgSerializationType.getRawClass(); [EOL] }
public Class<?> getPropertyType() { [EOL]     if (_accessorMethod != null) { [EOL]         return _accessorMethod.getReturnType(); [EOL]     } [EOL]     return _field.getType(); [EOL] }
public Class<?> getPropertyType() { [EOL]     if (_accessorMethod != null) { [EOL]         return _accessorMethod.getReturnType(); [EOL]     } [EOL]     return _field.getType(); [EOL] }
@SuppressWarnings("deprecation") [EOL] public void depositSchemaProperty(ObjectNode propertiesNode, SerializerProvider provider) throws JsonMappingException { [EOL]     JavaType propType = getSerializationType(); [EOL]     Type hint = (propType == null) ? getGenericPropertyType() : propType.getRawClass(); [EOL]     JsonNode schemaNode; [EOL]     JsonSerializer<Object> ser = getSerializer(); [EOL]     if (ser == null) { [EOL]         Class<?> serType = getRawSerializationType(); [EOL]         if (serType == null) { [EOL]             serType = getPropertyType(); [EOL]         } [EOL]         ser = provider.findValueSerializer(serType, this); [EOL]     } [EOL]     boolean isOptional = !isRequired(); [EOL]     if (ser instanceof SchemaAware) { [EOL]         schemaNode = ((SchemaAware) ser).getSchema(provider, hint, isOptional); [EOL]     } else { [EOL]         schemaNode = com.fasterxml.jackson.databind.jsonschema.JsonSchema.getDefaultSchemaNode(); [EOL]     } [EOL]     propertiesNode.put(getName(), schemaNode); [EOL] }
@SuppressWarnings("deprecation") [EOL] public void depositSchemaProperty(ObjectNode propertiesNode, SerializerProvider provider) throws JsonMappingException { [EOL]     JavaType propType = getSerializationType(); [EOL]     Type hint = (propType == null) ? getGenericPropertyType() : propType.getRawClass(); [EOL]     JsonNode schemaNode; [EOL]     JsonSerializer<Object> ser = getSerializer(); [EOL]     if (ser == null) { [EOL]         Class<?> serType = getRawSerializationType(); [EOL]         if (serType == null) { [EOL]             serType = getPropertyType(); [EOL]         } [EOL]         ser = provider.findValueSerializer(serType, this); [EOL]     } [EOL]     boolean isOptional = !isRequired(); [EOL]     if (ser instanceof SchemaAware) { [EOL]         schemaNode = ((SchemaAware) ser).getSchema(provider, hint, isOptional); [EOL]     } else { [EOL]         schemaNode = com.fasterxml.jackson.databind.jsonschema.JsonSchema.getDefaultSchemaNode(); [EOL]     } [EOL]     propertiesNode.put(getName(), schemaNode); [EOL] }
@SuppressWarnings("deprecation") [EOL] public void depositSchemaProperty(ObjectNode propertiesNode, SerializerProvider provider) throws JsonMappingException { [EOL]     JavaType propType = getSerializationType(); [EOL]     Type hint = (propType == null) ? getGenericPropertyType() : propType.getRawClass(); [EOL]     JsonNode schemaNode; [EOL]     JsonSerializer<Object> ser = getSerializer(); [EOL]     if (ser == null) { [EOL]         Class<?> serType = getRawSerializationType(); [EOL]         if (serType == null) { [EOL]             serType = getPropertyType(); [EOL]         } [EOL]         ser = provider.findValueSerializer(serType, this); [EOL]     } [EOL]     boolean isOptional = !isRequired(); [EOL]     if (ser instanceof SchemaAware) { [EOL]         schemaNode = ((SchemaAware) ser).getSchema(provider, hint, isOptional); [EOL]     } else { [EOL]         schemaNode = com.fasterxml.jackson.databind.jsonschema.JsonSchema.getDefaultSchemaNode(); [EOL]     } [EOL]     propertiesNode.put(getName(), schemaNode); [EOL] }
public void serializeAsColumn(Object bean, JsonGenerator jgen, SerializerProvider prov) throws Exception { [EOL]     Object value = get(bean); [EOL]     if (value == null) { [EOL]         if (_nullSerializer != null) { [EOL]             _nullSerializer.serialize(null, jgen, prov); [EOL]         } else { [EOL]             jgen.writeNull(); [EOL]         } [EOL]         return; [EOL]     } [EOL]     JsonSerializer<Object> ser = _serializer; [EOL]     if (ser == null) { [EOL]         Class<?> cls = value.getClass(); [EOL]         PropertySerializerMap map = _dynamicSerializers; [EOL]         ser = map.serializerFor(cls); [EOL]         if (ser == null) { [EOL]             ser = _findAndAddDynamic(map, cls, prov); [EOL]         } [EOL]     } [EOL]     if (_suppressableValue != null) { [EOL]         if (MARKER_FOR_EMPTY == _suppressableValue) { [EOL]             if (ser.isEmpty(value)) { [EOL]                 serializeAsPlaceholder(bean, jgen, prov); [EOL]                 return; [EOL]             } [EOL]         } else if (_suppressableValue.equals(value)) { [EOL]             serializeAsPlaceholder(bean, jgen, prov); [EOL]             return; [EOL]         } [EOL]     } [EOL]     if (value == bean) { [EOL]         _handleSelfReference(bean, ser); [EOL]     } [EOL]     if (_typeSerializer == null) { [EOL]         ser.serialize(value, jgen, prov); [EOL]     } else { [EOL]         ser.serializeWithType(value, jgen, prov, _typeSerializer); [EOL]     } [EOL] }
public void serializeAsColumn(Object bean, JsonGenerator jgen, SerializerProvider prov) throws Exception { [EOL]     Object value = get(bean); [EOL]     if (value == null) { [EOL]         if (_nullSerializer != null) { [EOL]             _nullSerializer.serialize(null, jgen, prov); [EOL]         } else { [EOL]             jgen.writeNull(); [EOL]         } [EOL]         return; [EOL]     } [EOL]     JsonSerializer<Object> ser = _serializer; [EOL]     if (ser == null) { [EOL]         Class<?> cls = value.getClass(); [EOL]         PropertySerializerMap map = _dynamicSerializers; [EOL]         ser = map.serializerFor(cls); [EOL]         if (ser == null) { [EOL]             ser = _findAndAddDynamic(map, cls, prov); [EOL]         } [EOL]     } [EOL]     if (_suppressableValue != null) { [EOL]         if (MARKER_FOR_EMPTY == _suppressableValue) { [EOL]             if (ser.isEmpty(value)) { [EOL]                 serializeAsPlaceholder(bean, jgen, prov); [EOL]                 return; [EOL]             } [EOL]         } else if (_suppressableValue.equals(value)) { [EOL]             serializeAsPlaceholder(bean, jgen, prov); [EOL]             return; [EOL]         } [EOL]     } [EOL]     if (value == bean) { [EOL]         _handleSelfReference(bean, ser); [EOL]     } [EOL]     if (_typeSerializer == null) { [EOL]         ser.serialize(value, jgen, prov); [EOL]     } else { [EOL]         ser.serializeWithType(value, jgen, prov, _typeSerializer); [EOL]     } [EOL] }
public void serializeAsColumn(Object bean, JsonGenerator jgen, SerializerProvider prov) throws Exception { [EOL]     Object value = get(bean); [EOL]     if (value == null) { [EOL]         if (_nullSerializer != null) { [EOL]             _nullSerializer.serialize(null, jgen, prov); [EOL]         } else { [EOL]             jgen.writeNull(); [EOL]         } [EOL]         return; [EOL]     } [EOL]     JsonSerializer<Object> ser = _serializer; [EOL]     if (ser == null) { [EOL]         Class<?> cls = value.getClass(); [EOL]         PropertySerializerMap map = _dynamicSerializers; [EOL]         ser = map.serializerFor(cls); [EOL]         if (ser == null) { [EOL]             ser = _findAndAddDynamic(map, cls, prov); [EOL]         } [EOL]     } [EOL]     if (_suppressableValue != null) { [EOL]         if (MARKER_FOR_EMPTY == _suppressableValue) { [EOL]             if (ser.isEmpty(value)) { [EOL]                 serializeAsPlaceholder(bean, jgen, prov); [EOL]                 return; [EOL]             } [EOL]         } else if (_suppressableValue.equals(value)) { [EOL]             serializeAsPlaceholder(bean, jgen, prov); [EOL]             return; [EOL]         } [EOL]     } [EOL]     if (value == bean) { [EOL]         _handleSelfReference(bean, ser); [EOL]     } [EOL]     if (_typeSerializer == null) { [EOL]         ser.serialize(value, jgen, prov); [EOL]     } else { [EOL]         ser.serializeWithType(value, jgen, prov, _typeSerializer); [EOL]     } [EOL] }
public void serializeAsColumn(Object bean, JsonGenerator jgen, SerializerProvider prov) throws Exception { [EOL]     Object value = get(bean); [EOL]     if (value == null) { [EOL]         if (_nullSerializer != null) { [EOL]             _nullSerializer.serialize(null, jgen, prov); [EOL]         } else { [EOL]             jgen.writeNull(); [EOL]         } [EOL]         return; [EOL]     } [EOL]     JsonSerializer<Object> ser = _serializer; [EOL]     if (ser == null) { [EOL]         Class<?> cls = value.getClass(); [EOL]         PropertySerializerMap map = _dynamicSerializers; [EOL]         ser = map.serializerFor(cls); [EOL]         if (ser == null) { [EOL]             ser = _findAndAddDynamic(map, cls, prov); [EOL]         } [EOL]     } [EOL]     if (_suppressableValue != null) { [EOL]         if (MARKER_FOR_EMPTY == _suppressableValue) { [EOL]             if (ser.isEmpty(value)) { [EOL]                 serializeAsPlaceholder(bean, jgen, prov); [EOL]                 return; [EOL]             } [EOL]         } else if (_suppressableValue.equals(value)) { [EOL]             serializeAsPlaceholder(bean, jgen, prov); [EOL]             return; [EOL]         } [EOL]     } [EOL]     if (value == bean) { [EOL]         _handleSelfReference(bean, ser); [EOL]     } [EOL]     if (_typeSerializer == null) { [EOL]         ser.serialize(value, jgen, prov); [EOL]     } else { [EOL]         ser.serializeWithType(value, jgen, prov, _typeSerializer); [EOL]     } [EOL] }
public void serializeAsColumn(Object bean, JsonGenerator jgen, SerializerProvider prov) throws Exception { [EOL]     Object value = get(bean); [EOL]     if (value == null) { [EOL]         if (_nullSerializer != null) { [EOL]             _nullSerializer.serialize(null, jgen, prov); [EOL]         } else { [EOL]             jgen.writeNull(); [EOL]         } [EOL]         return; [EOL]     } [EOL]     JsonSerializer<Object> ser = _serializer; [EOL]     if (ser == null) { [EOL]         Class<?> cls = value.getClass(); [EOL]         PropertySerializerMap map = _dynamicSerializers; [EOL]         ser = map.serializerFor(cls); [EOL]         if (ser == null) { [EOL]             ser = _findAndAddDynamic(map, cls, prov); [EOL]         } [EOL]     } [EOL]     if (_suppressableValue != null) { [EOL]         if (MARKER_FOR_EMPTY == _suppressableValue) { [EOL]             if (ser.isEmpty(value)) { [EOL]                 serializeAsPlaceholder(bean, jgen, prov); [EOL]                 return; [EOL]             } [EOL]         } else if (_suppressableValue.equals(value)) { [EOL]             serializeAsPlaceholder(bean, jgen, prov); [EOL]             return; [EOL]         } [EOL]     } [EOL]     if (value == bean) { [EOL]         _handleSelfReference(bean, ser); [EOL]     } [EOL]     if (_typeSerializer == null) { [EOL]         ser.serialize(value, jgen, prov); [EOL]     } else { [EOL]         ser.serializeWithType(value, jgen, prov, _typeSerializer); [EOL]     } [EOL] }
public void serializeAsColumn(Object bean, JsonGenerator jgen, SerializerProvider prov) throws Exception { [EOL]     Object value = get(bean); [EOL]     if (value == null) { [EOL]         if (_nullSerializer != null) { [EOL]             _nullSerializer.serialize(null, jgen, prov); [EOL]         } else { [EOL]             jgen.writeNull(); [EOL]         } [EOL]         return; [EOL]     } [EOL]     JsonSerializer<Object> ser = _serializer; [EOL]     if (ser == null) { [EOL]         Class<?> cls = value.getClass(); [EOL]         PropertySerializerMap map = _dynamicSerializers; [EOL]         ser = map.serializerFor(cls); [EOL]         if (ser == null) { [EOL]             ser = _findAndAddDynamic(map, cls, prov); [EOL]         } [EOL]     } [EOL]     if (_suppressableValue != null) { [EOL]         if (MARKER_FOR_EMPTY == _suppressableValue) { [EOL]             if (ser.isEmpty(value)) { [EOL]                 serializeAsPlaceholder(bean, jgen, prov); [EOL]                 return; [EOL]             } [EOL]         } else if (_suppressableValue.equals(value)) { [EOL]             serializeAsPlaceholder(bean, jgen, prov); [EOL]             return; [EOL]         } [EOL]     } [EOL]     if (value == bean) { [EOL]         _handleSelfReference(bean, ser); [EOL]     } [EOL]     if (_typeSerializer == null) { [EOL]         ser.serialize(value, jgen, prov); [EOL]     } else { [EOL]         ser.serializeWithType(value, jgen, prov, _typeSerializer); [EOL]     } [EOL] }
public ObjectArrayDeserializer(ArrayType arrayType, JsonDeserializer<Object> elemDeser, TypeDeserializer elemTypeDeser) { [EOL]     super(Object[].class); [EOL]     _arrayType = arrayType; [EOL]     _elementClass = arrayType.getContentType().getRawClass(); [EOL]     _untyped = (_elementClass == Object.class); [EOL]     _elementDeserializer = elemDeser; [EOL]     _elementTypeDeserializer = elemTypeDeser; [EOL] }
public ObjectArrayDeserializer(ArrayType arrayType, JsonDeserializer<Object> elemDeser, TypeDeserializer elemTypeDeser) { [EOL]     super(Object[].class); [EOL]     _arrayType = arrayType; [EOL]     _elementClass = arrayType.getContentType().getRawClass(); [EOL]     _untyped = (_elementClass == Object.class); [EOL]     _elementDeserializer = elemDeser; [EOL]     _elementTypeDeserializer = elemTypeDeser; [EOL] }
@SuppressWarnings("unchecked") [EOL] public ObjectArrayDeserializer withDeserializer(TypeDeserializer elemTypeDeser, JsonDeserializer<?> elemDeser) { [EOL]     if ((elemDeser == _elementDeserializer) && (elemTypeDeser == _elementTypeDeserializer)) { [EOL]         return this; [EOL]     } [EOL]     return new ObjectArrayDeserializer(_arrayType, (JsonDeserializer<Object>) elemDeser, elemTypeDeser); [EOL] }
@SuppressWarnings("unchecked") [EOL] public ObjectArrayDeserializer withDeserializer(TypeDeserializer elemTypeDeser, JsonDeserializer<?> elemDeser) { [EOL]     if ((elemDeser == _elementDeserializer) && (elemTypeDeser == _elementTypeDeserializer)) { [EOL]         return this; [EOL]     } [EOL]     return new ObjectArrayDeserializer(_arrayType, (JsonDeserializer<Object>) elemDeser, elemTypeDeser); [EOL] }
@SuppressWarnings("unchecked") [EOL] public ObjectArrayDeserializer withDeserializer(TypeDeserializer elemTypeDeser, JsonDeserializer<?> elemDeser) { [EOL]     if ((elemDeser == _elementDeserializer) && (elemTypeDeser == _elementTypeDeserializer)) { [EOL]         return this; [EOL]     } [EOL]     return new ObjectArrayDeserializer(_arrayType, (JsonDeserializer<Object>) elemDeser, elemTypeDeser); [EOL] }
@Override [EOL] public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException { [EOL]     JsonDeserializer<?> deser = _elementDeserializer; [EOL]     deser = findConvertingContentDeserializer(ctxt, property, deser); [EOL]     if (deser == null) { [EOL]         deser = ctxt.findContextualValueDeserializer(_arrayType.getContentType(), property); [EOL]     } else { [EOL]         if (deser instanceof ContextualDeserializer) { [EOL]             deser = ((ContextualDeserializer) deser).createContextual(ctxt, property); [EOL]         } [EOL]     } [EOL]     TypeDeserializer elemTypeDeser = _elementTypeDeserializer; [EOL]     if (elemTypeDeser != null) { [EOL]         elemTypeDeser = elemTypeDeser.forProperty(property); [EOL]     } [EOL]     return withDeserializer(elemTypeDeser, deser); [EOL] }
@Override [EOL] public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException { [EOL]     JsonDeserializer<?> deser = _elementDeserializer; [EOL]     deser = findConvertingContentDeserializer(ctxt, property, deser); [EOL]     if (deser == null) { [EOL]         deser = ctxt.findContextualValueDeserializer(_arrayType.getContentType(), property); [EOL]     } else { [EOL]         if (deser instanceof ContextualDeserializer) { [EOL]             deser = ((ContextualDeserializer) deser).createContextual(ctxt, property); [EOL]         } [EOL]     } [EOL]     TypeDeserializer elemTypeDeser = _elementTypeDeserializer; [EOL]     if (elemTypeDeser != null) { [EOL]         elemTypeDeser = elemTypeDeser.forProperty(property); [EOL]     } [EOL]     return withDeserializer(elemTypeDeser, deser); [EOL] }
@Override [EOL] public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException { [EOL]     JsonDeserializer<?> deser = _elementDeserializer; [EOL]     deser = findConvertingContentDeserializer(ctxt, property, deser); [EOL]     if (deser == null) { [EOL]         deser = ctxt.findContextualValueDeserializer(_arrayType.getContentType(), property); [EOL]     } else { [EOL]         if (deser instanceof ContextualDeserializer) { [EOL]             deser = ((ContextualDeserializer) deser).createContextual(ctxt, property); [EOL]         } [EOL]     } [EOL]     TypeDeserializer elemTypeDeser = _elementTypeDeserializer; [EOL]     if (elemTypeDeser != null) { [EOL]         elemTypeDeser = elemTypeDeser.forProperty(property); [EOL]     } [EOL]     return withDeserializer(elemTypeDeser, deser); [EOL] }
@Override [EOL] public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException { [EOL]     JsonDeserializer<?> deser = _elementDeserializer; [EOL]     deser = findConvertingContentDeserializer(ctxt, property, deser); [EOL]     if (deser == null) { [EOL]         deser = ctxt.findContextualValueDeserializer(_arrayType.getContentType(), property); [EOL]     } else { [EOL]         if (deser instanceof ContextualDeserializer) { [EOL]             deser = ((ContextualDeserializer) deser).createContextual(ctxt, property); [EOL]         } [EOL]     } [EOL]     TypeDeserializer elemTypeDeser = _elementTypeDeserializer; [EOL]     if (elemTypeDeser != null) { [EOL]         elemTypeDeser = elemTypeDeser.forProperty(property); [EOL]     } [EOL]     return withDeserializer(elemTypeDeser, deser); [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     JsonSerializer<?> ser = null; [EOL]     JsonSerializer<?> keySer = null; [EOL]     if (property != null) { [EOL]         AnnotatedMember m = property.getMember(); [EOL]         if (m != null) { [EOL]             Object serDef; [EOL]             final AnnotationIntrospector intr = provider.getAnnotationIntrospector(); [EOL]             serDef = intr.findKeySerializer(m); [EOL]             if (serDef != null) { [EOL]                 keySer = provider.serializerInstance(m, serDef); [EOL]             } [EOL]             serDef = intr.findContentSerializer(m); [EOL]             if (serDef != null) { [EOL]                 ser = provider.serializerInstance(m, serDef); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         ser = _valueSerializer; [EOL]     } [EOL]     ser = findConvertingContentSerializer(provider, property, ser); [EOL]     if (ser == null) { [EOL]         if (_valueTypeIsStatic || hasContentTypeAnnotation(provider, property)) { [EOL]             ser = provider.findValueSerializer(_valueType, property); [EOL]         } [EOL]     } else if (ser instanceof ContextualSerializer) { [EOL]         ser = ((ContextualSerializer) ser).createContextual(provider, property); [EOL]     } [EOL]     if (keySer == null) { [EOL]         keySer = _keySerializer; [EOL]     } [EOL]     if (keySer == null) { [EOL]         keySer = provider.findKeySerializer(_keyType, property); [EOL]     } else if (keySer instanceof ContextualSerializer) { [EOL]         keySer = ((ContextualSerializer) keySer).createContextual(provider, property); [EOL]     } [EOL]     HashSet<String> ignored = this._ignoredEntries; [EOL]     AnnotationIntrospector intr = provider.getAnnotationIntrospector(); [EOL]     if (intr != null && property != null) { [EOL]         String[] moreToIgnore = intr.findPropertiesToIgnore(property.getMember()); [EOL]         if (moreToIgnore != null) { [EOL]             ignored = (ignored == null) ? new HashSet<String>() : new HashSet<String>(ignored); [EOL]             for (String str : moreToIgnore) { [EOL]                 ignored.add(str); [EOL]             } [EOL]         } [EOL]     } [EOL]     return withResolved(property, keySer, ser, ignored); [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     JsonSerializer<?> ser = null; [EOL]     JsonSerializer<?> keySer = null; [EOL]     if (property != null) { [EOL]         AnnotatedMember m = property.getMember(); [EOL]         if (m != null) { [EOL]             Object serDef; [EOL]             final AnnotationIntrospector intr = provider.getAnnotationIntrospector(); [EOL]             serDef = intr.findKeySerializer(m); [EOL]             if (serDef != null) { [EOL]                 keySer = provider.serializerInstance(m, serDef); [EOL]             } [EOL]             serDef = intr.findContentSerializer(m); [EOL]             if (serDef != null) { [EOL]                 ser = provider.serializerInstance(m, serDef); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         ser = _valueSerializer; [EOL]     } [EOL]     ser = findConvertingContentSerializer(provider, property, ser); [EOL]     if (ser == null) { [EOL]         if (_valueTypeIsStatic || hasContentTypeAnnotation(provider, property)) { [EOL]             ser = provider.findValueSerializer(_valueType, property); [EOL]         } [EOL]     } else if (ser instanceof ContextualSerializer) { [EOL]         ser = ((ContextualSerializer) ser).createContextual(provider, property); [EOL]     } [EOL]     if (keySer == null) { [EOL]         keySer = _keySerializer; [EOL]     } [EOL]     if (keySer == null) { [EOL]         keySer = provider.findKeySerializer(_keyType, property); [EOL]     } else if (keySer instanceof ContextualSerializer) { [EOL]         keySer = ((ContextualSerializer) keySer).createContextual(provider, property); [EOL]     } [EOL]     HashSet<String> ignored = this._ignoredEntries; [EOL]     AnnotationIntrospector intr = provider.getAnnotationIntrospector(); [EOL]     if (intr != null && property != null) { [EOL]         String[] moreToIgnore = intr.findPropertiesToIgnore(property.getMember()); [EOL]         if (moreToIgnore != null) { [EOL]             ignored = (ignored == null) ? new HashSet<String>() : new HashSet<String>(ignored); [EOL]             for (String str : moreToIgnore) { [EOL]                 ignored.add(str); [EOL]             } [EOL]         } [EOL]     } [EOL]     return withResolved(property, keySer, ser, ignored); [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     JsonSerializer<?> ser = null; [EOL]     JsonSerializer<?> keySer = null; [EOL]     if (property != null) { [EOL]         AnnotatedMember m = property.getMember(); [EOL]         if (m != null) { [EOL]             Object serDef; [EOL]             final AnnotationIntrospector intr = provider.getAnnotationIntrospector(); [EOL]             serDef = intr.findKeySerializer(m); [EOL]             if (serDef != null) { [EOL]                 keySer = provider.serializerInstance(m, serDef); [EOL]             } [EOL]             serDef = intr.findContentSerializer(m); [EOL]             if (serDef != null) { [EOL]                 ser = provider.serializerInstance(m, serDef); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         ser = _valueSerializer; [EOL]     } [EOL]     ser = findConvertingContentSerializer(provider, property, ser); [EOL]     if (ser == null) { [EOL]         if (_valueTypeIsStatic || hasContentTypeAnnotation(provider, property)) { [EOL]             ser = provider.findValueSerializer(_valueType, property); [EOL]         } [EOL]     } else if (ser instanceof ContextualSerializer) { [EOL]         ser = ((ContextualSerializer) ser).createContextual(provider, property); [EOL]     } [EOL]     if (keySer == null) { [EOL]         keySer = _keySerializer; [EOL]     } [EOL]     if (keySer == null) { [EOL]         keySer = provider.findKeySerializer(_keyType, property); [EOL]     } else if (keySer instanceof ContextualSerializer) { [EOL]         keySer = ((ContextualSerializer) keySer).createContextual(provider, property); [EOL]     } [EOL]     HashSet<String> ignored = this._ignoredEntries; [EOL]     AnnotationIntrospector intr = provider.getAnnotationIntrospector(); [EOL]     if (intr != null && property != null) { [EOL]         String[] moreToIgnore = intr.findPropertiesToIgnore(property.getMember()); [EOL]         if (moreToIgnore != null) { [EOL]             ignored = (ignored == null) ? new HashSet<String>() : new HashSet<String>(ignored); [EOL]             for (String str : moreToIgnore) { [EOL]                 ignored.add(str); [EOL]             } [EOL]         } [EOL]     } [EOL]     return withResolved(property, keySer, ser, ignored); [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     JsonSerializer<?> ser = null; [EOL]     JsonSerializer<?> keySer = null; [EOL]     if (property != null) { [EOL]         AnnotatedMember m = property.getMember(); [EOL]         if (m != null) { [EOL]             Object serDef; [EOL]             final AnnotationIntrospector intr = provider.getAnnotationIntrospector(); [EOL]             serDef = intr.findKeySerializer(m); [EOL]             if (serDef != null) { [EOL]                 keySer = provider.serializerInstance(m, serDef); [EOL]             } [EOL]             serDef = intr.findContentSerializer(m); [EOL]             if (serDef != null) { [EOL]                 ser = provider.serializerInstance(m, serDef); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         ser = _valueSerializer; [EOL]     } [EOL]     ser = findConvertingContentSerializer(provider, property, ser); [EOL]     if (ser == null) { [EOL]         if (_valueTypeIsStatic || hasContentTypeAnnotation(provider, property)) { [EOL]             ser = provider.findValueSerializer(_valueType, property); [EOL]         } [EOL]     } else if (ser instanceof ContextualSerializer) { [EOL]         ser = ((ContextualSerializer) ser).createContextual(provider, property); [EOL]     } [EOL]     if (keySer == null) { [EOL]         keySer = _keySerializer; [EOL]     } [EOL]     if (keySer == null) { [EOL]         keySer = provider.findKeySerializer(_keyType, property); [EOL]     } else if (keySer instanceof ContextualSerializer) { [EOL]         keySer = ((ContextualSerializer) keySer).createContextual(provider, property); [EOL]     } [EOL]     HashSet<String> ignored = this._ignoredEntries; [EOL]     AnnotationIntrospector intr = provider.getAnnotationIntrospector(); [EOL]     if (intr != null && property != null) { [EOL]         String[] moreToIgnore = intr.findPropertiesToIgnore(property.getMember()); [EOL]         if (moreToIgnore != null) { [EOL]             ignored = (ignored == null) ? new HashSet<String>() : new HashSet<String>(ignored); [EOL]             for (String str : moreToIgnore) { [EOL]                 ignored.add(str); [EOL]             } [EOL]         } [EOL]     } [EOL]     return withResolved(property, keySer, ser, ignored); [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     JsonSerializer<?> ser = null; [EOL]     JsonSerializer<?> keySer = null; [EOL]     if (property != null) { [EOL]         AnnotatedMember m = property.getMember(); [EOL]         if (m != null) { [EOL]             Object serDef; [EOL]             final AnnotationIntrospector intr = provider.getAnnotationIntrospector(); [EOL]             serDef = intr.findKeySerializer(m); [EOL]             if (serDef != null) { [EOL]                 keySer = provider.serializerInstance(m, serDef); [EOL]             } [EOL]             serDef = intr.findContentSerializer(m); [EOL]             if (serDef != null) { [EOL]                 ser = provider.serializerInstance(m, serDef); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         ser = _valueSerializer; [EOL]     } [EOL]     ser = findConvertingContentSerializer(provider, property, ser); [EOL]     if (ser == null) { [EOL]         if (_valueTypeIsStatic || hasContentTypeAnnotation(provider, property)) { [EOL]             ser = provider.findValueSerializer(_valueType, property); [EOL]         } [EOL]     } else if (ser instanceof ContextualSerializer) { [EOL]         ser = ((ContextualSerializer) ser).createContextual(provider, property); [EOL]     } [EOL]     if (keySer == null) { [EOL]         keySer = _keySerializer; [EOL]     } [EOL]     if (keySer == null) { [EOL]         keySer = provider.findKeySerializer(_keyType, property); [EOL]     } else if (keySer instanceof ContextualSerializer) { [EOL]         keySer = ((ContextualSerializer) keySer).createContextual(provider, property); [EOL]     } [EOL]     HashSet<String> ignored = this._ignoredEntries; [EOL]     AnnotationIntrospector intr = provider.getAnnotationIntrospector(); [EOL]     if (intr != null && property != null) { [EOL]         String[] moreToIgnore = intr.findPropertiesToIgnore(property.getMember()); [EOL]         if (moreToIgnore != null) { [EOL]             ignored = (ignored == null) ? new HashSet<String>() : new HashSet<String>(ignored); [EOL]             for (String str : moreToIgnore) { [EOL]                 ignored.add(str); [EOL]             } [EOL]         } [EOL]     } [EOL]     return withResolved(property, keySer, ser, ignored); [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     JsonSerializer<?> ser = null; [EOL]     JsonSerializer<?> keySer = null; [EOL]     if (property != null) { [EOL]         AnnotatedMember m = property.getMember(); [EOL]         if (m != null) { [EOL]             Object serDef; [EOL]             final AnnotationIntrospector intr = provider.getAnnotationIntrospector(); [EOL]             serDef = intr.findKeySerializer(m); [EOL]             if (serDef != null) { [EOL]                 keySer = provider.serializerInstance(m, serDef); [EOL]             } [EOL]             serDef = intr.findContentSerializer(m); [EOL]             if (serDef != null) { [EOL]                 ser = provider.serializerInstance(m, serDef); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         ser = _valueSerializer; [EOL]     } [EOL]     ser = findConvertingContentSerializer(provider, property, ser); [EOL]     if (ser == null) { [EOL]         if (_valueTypeIsStatic || hasContentTypeAnnotation(provider, property)) { [EOL]             ser = provider.findValueSerializer(_valueType, property); [EOL]         } [EOL]     } else if (ser instanceof ContextualSerializer) { [EOL]         ser = ((ContextualSerializer) ser).createContextual(provider, property); [EOL]     } [EOL]     if (keySer == null) { [EOL]         keySer = _keySerializer; [EOL]     } [EOL]     if (keySer == null) { [EOL]         keySer = provider.findKeySerializer(_keyType, property); [EOL]     } else if (keySer instanceof ContextualSerializer) { [EOL]         keySer = ((ContextualSerializer) keySer).createContextual(provider, property); [EOL]     } [EOL]     HashSet<String> ignored = this._ignoredEntries; [EOL]     AnnotationIntrospector intr = provider.getAnnotationIntrospector(); [EOL]     if (intr != null && property != null) { [EOL]         String[] moreToIgnore = intr.findPropertiesToIgnore(property.getMember()); [EOL]         if (moreToIgnore != null) { [EOL]             ignored = (ignored == null) ? new HashSet<String>() : new HashSet<String>(ignored); [EOL]             for (String str : moreToIgnore) { [EOL]                 ignored.add(str); [EOL]             } [EOL]         } [EOL]     } [EOL]     return withResolved(property, keySer, ser, ignored); [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     JsonSerializer<?> ser = null; [EOL]     JsonSerializer<?> keySer = null; [EOL]     if (property != null) { [EOL]         AnnotatedMember m = property.getMember(); [EOL]         if (m != null) { [EOL]             Object serDef; [EOL]             final AnnotationIntrospector intr = provider.getAnnotationIntrospector(); [EOL]             serDef = intr.findKeySerializer(m); [EOL]             if (serDef != null) { [EOL]                 keySer = provider.serializerInstance(m, serDef); [EOL]             } [EOL]             serDef = intr.findContentSerializer(m); [EOL]             if (serDef != null) { [EOL]                 ser = provider.serializerInstance(m, serDef); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         ser = _valueSerializer; [EOL]     } [EOL]     ser = findConvertingContentSerializer(provider, property, ser); [EOL]     if (ser == null) { [EOL]         if (_valueTypeIsStatic || hasContentTypeAnnotation(provider, property)) { [EOL]             ser = provider.findValueSerializer(_valueType, property); [EOL]         } [EOL]     } else if (ser instanceof ContextualSerializer) { [EOL]         ser = ((ContextualSerializer) ser).createContextual(provider, property); [EOL]     } [EOL]     if (keySer == null) { [EOL]         keySer = _keySerializer; [EOL]     } [EOL]     if (keySer == null) { [EOL]         keySer = provider.findKeySerializer(_keyType, property); [EOL]     } else if (keySer instanceof ContextualSerializer) { [EOL]         keySer = ((ContextualSerializer) keySer).createContextual(provider, property); [EOL]     } [EOL]     HashSet<String> ignored = this._ignoredEntries; [EOL]     AnnotationIntrospector intr = provider.getAnnotationIntrospector(); [EOL]     if (intr != null && property != null) { [EOL]         String[] moreToIgnore = intr.findPropertiesToIgnore(property.getMember()); [EOL]         if (moreToIgnore != null) { [EOL]             ignored = (ignored == null) ? new HashSet<String>() : new HashSet<String>(ignored); [EOL]             for (String str : moreToIgnore) { [EOL]                 ignored.add(str); [EOL]             } [EOL]         } [EOL]     } [EOL]     return withResolved(property, keySer, ser, ignored); [EOL] }
@Override [EOL] public void serialize(Map<?, ?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     jgen.writeStartObject(); [EOL]     if (!value.isEmpty()) { [EOL]         if (provider.isEnabled(SerializationFeature.ORDER_MAP_ENTRIES_BY_KEYS)) { [EOL]             value = _orderEntries(value); [EOL]         } [EOL]         if (_valueSerializer != null) { [EOL]             serializeFieldsUsing(value, jgen, provider, _valueSerializer); [EOL]         } else { [EOL]             serializeFields(value, jgen, provider); [EOL]         } [EOL]     } [EOL]     jgen.writeEndObject(); [EOL] }
@Override [EOL] public void serialize(Map<?, ?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     jgen.writeStartObject(); [EOL]     if (!value.isEmpty()) { [EOL]         if (provider.isEnabled(SerializationFeature.ORDER_MAP_ENTRIES_BY_KEYS)) { [EOL]             value = _orderEntries(value); [EOL]         } [EOL]         if (_valueSerializer != null) { [EOL]             serializeFieldsUsing(value, jgen, provider, _valueSerializer); [EOL]         } else { [EOL]             serializeFields(value, jgen, provider); [EOL]         } [EOL]     } [EOL]     jgen.writeEndObject(); [EOL] }
@Override [EOL] public void serialize(Map<?, ?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     jgen.writeStartObject(); [EOL]     if (!value.isEmpty()) { [EOL]         if (provider.isEnabled(SerializationFeature.ORDER_MAP_ENTRIES_BY_KEYS)) { [EOL]             value = _orderEntries(value); [EOL]         } [EOL]         if (_valueSerializer != null) { [EOL]             serializeFieldsUsing(value, jgen, provider, _valueSerializer); [EOL]         } else { [EOL]             serializeFields(value, jgen, provider); [EOL]         } [EOL]     } [EOL]     jgen.writeEndObject(); [EOL] }
@Override [EOL] public void serialize(Map<?, ?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     jgen.writeStartObject(); [EOL]     if (!value.isEmpty()) { [EOL]         if (provider.isEnabled(SerializationFeature.ORDER_MAP_ENTRIES_BY_KEYS)) { [EOL]             value = _orderEntries(value); [EOL]         } [EOL]         if (_valueSerializer != null) { [EOL]             serializeFieldsUsing(value, jgen, provider, _valueSerializer); [EOL]         } else { [EOL]             serializeFields(value, jgen, provider); [EOL]         } [EOL]     } [EOL]     jgen.writeEndObject(); [EOL] }
protected Map<?, ?> _orderEntries(Map<?, ?> input) { [EOL]     if (input instanceof SortedMap<?, ?>) { [EOL]         return input; [EOL]     } [EOL]     return new TreeMap<Object, Object>(input); [EOL] }
protected Map<?, ?> _orderEntries(Map<?, ?> input) { [EOL]     if (input instanceof SortedMap<?, ?>) { [EOL]         return input; [EOL]     } [EOL]     return new TreeMap<Object, Object>(input); [EOL] }
protected MapDeserializer(MapDeserializer src, KeyDeserializer keyDeser, JsonDeserializer<Object> valueDeser, TypeDeserializer valueTypeDeser, HashSet<String> ignorable) { [EOL]     super(src._valueClass); [EOL]     _mapType = src._mapType; [EOL]     _keyDeserializer = keyDeser; [EOL]     _valueDeserializer = valueDeser; [EOL]     _valueTypeDeserializer = valueTypeDeser; [EOL]     _valueInstantiator = src._valueInstantiator; [EOL]     _propertyBasedCreator = src._propertyBasedCreator; [EOL]     _delegateDeserializer = src._delegateDeserializer; [EOL]     _hasDefaultCreator = src._hasDefaultCreator; [EOL]     _ignorableProperties = ignorable; [EOL]     _standardStringKey = _isStdKeyDeser(_mapType, keyDeser); [EOL] }
@SuppressWarnings("unchecked") [EOL] protected MapDeserializer withResolved(KeyDeserializer keyDeser, TypeDeserializer valueTypeDeser, JsonDeserializer<?> valueDeser, HashSet<String> ignorable) { [EOL]     if ((_keyDeserializer == keyDeser) && (_valueDeserializer == valueDeser) && (_valueTypeDeserializer == valueTypeDeser) && (_ignorableProperties == ignorable)) { [EOL]         return this; [EOL]     } [EOL]     return new MapDeserializer(this, keyDeser, (JsonDeserializer<Object>) valueDeser, valueTypeDeser, ignorable); [EOL] }
@SuppressWarnings("unchecked") [EOL] protected MapDeserializer withResolved(KeyDeserializer keyDeser, TypeDeserializer valueTypeDeser, JsonDeserializer<?> valueDeser, HashSet<String> ignorable) { [EOL]     if ((_keyDeserializer == keyDeser) && (_valueDeserializer == valueDeser) && (_valueTypeDeserializer == valueTypeDeser) && (_ignorableProperties == ignorable)) { [EOL]         return this; [EOL]     } [EOL]     return new MapDeserializer(this, keyDeser, (JsonDeserializer<Object>) valueDeser, valueTypeDeser, ignorable); [EOL] }
protected final boolean _isStdKeyDeser(JavaType mapType, KeyDeserializer keyDeser) { [EOL]     if (keyDeser == null) { [EOL]         return true; [EOL]     } [EOL]     JavaType keyType = mapType.getKeyType(); [EOL]     if (keyType == null) { [EOL]         return true; [EOL]     } [EOL]     Class<?> rawKeyType = keyType.getRawClass(); [EOL]     return ((rawKeyType == String.class || rawKeyType == Object.class) && isDefaultKeyDeserializer(keyDeser)); [EOL] }
protected final boolean _isStdKeyDeser(JavaType mapType, KeyDeserializer keyDeser) { [EOL]     if (keyDeser == null) { [EOL]         return true; [EOL]     } [EOL]     JavaType keyType = mapType.getKeyType(); [EOL]     if (keyType == null) { [EOL]         return true; [EOL]     } [EOL]     Class<?> rawKeyType = keyType.getRawClass(); [EOL]     return ((rawKeyType == String.class || rawKeyType == Object.class) && isDefaultKeyDeserializer(keyDeser)); [EOL] }
protected final boolean _isStdKeyDeser(JavaType mapType, KeyDeserializer keyDeser) { [EOL]     if (keyDeser == null) { [EOL]         return true; [EOL]     } [EOL]     JavaType keyType = mapType.getKeyType(); [EOL]     if (keyType == null) { [EOL]         return true; [EOL]     } [EOL]     Class<?> rawKeyType = keyType.getRawClass(); [EOL]     return ((rawKeyType == String.class || rawKeyType == Object.class) && isDefaultKeyDeserializer(keyDeser)); [EOL] }
protected final boolean _isStdKeyDeser(JavaType mapType, KeyDeserializer keyDeser) { [EOL]     if (keyDeser == null) { [EOL]         return true; [EOL]     } [EOL]     JavaType keyType = mapType.getKeyType(); [EOL]     if (keyType == null) { [EOL]         return true; [EOL]     } [EOL]     Class<?> rawKeyType = keyType.getRawClass(); [EOL]     return ((rawKeyType == String.class || rawKeyType == Object.class) && isDefaultKeyDeserializer(keyDeser)); [EOL] }
protected final boolean _isStdKeyDeser(JavaType mapType, KeyDeserializer keyDeser) { [EOL]     if (keyDeser == null) { [EOL]         return true; [EOL]     } [EOL]     JavaType keyType = mapType.getKeyType(); [EOL]     if (keyType == null) { [EOL]         return true; [EOL]     } [EOL]     Class<?> rawKeyType = keyType.getRawClass(); [EOL]     return ((rawKeyType == String.class || rawKeyType == Object.class) && isDefaultKeyDeserializer(keyDeser)); [EOL] }
@Override [EOL] public void resolve(DeserializationContext ctxt) throws JsonMappingException { [EOL]     if (_valueInstantiator.canCreateUsingDelegate()) { [EOL]         JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig()); [EOL]         if (delegateType == null) { [EOL]             throw new IllegalArgumentException("Invalid delegate-creator definition for " + _mapType + ": value instantiator (" + _valueInstantiator.getClass().getName() + ") returned true for 'canCreateUsingDelegate()', but null for 'getDelegateType()'"); [EOL]         } [EOL]         _delegateDeserializer = findDeserializer(ctxt, delegateType, null); [EOL]     } [EOL]     if (_valueInstantiator.canCreateFromObjectWith()) { [EOL]         SettableBeanProperty[] creatorProps = _valueInstantiator.getFromObjectArguments(ctxt.getConfig()); [EOL]         _propertyBasedCreator = PropertyBasedCreator.construct(ctxt, _valueInstantiator, creatorProps); [EOL]     } [EOL]     _standardStringKey = _isStdKeyDeser(_mapType, _keyDeserializer); [EOL] }
@Override [EOL] public void resolve(DeserializationContext ctxt) throws JsonMappingException { [EOL]     if (_valueInstantiator.canCreateUsingDelegate()) { [EOL]         JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig()); [EOL]         if (delegateType == null) { [EOL]             throw new IllegalArgumentException("Invalid delegate-creator definition for " + _mapType + ": value instantiator (" + _valueInstantiator.getClass().getName() + ") returned true for 'canCreateUsingDelegate()', but null for 'getDelegateType()'"); [EOL]         } [EOL]         _delegateDeserializer = findDeserializer(ctxt, delegateType, null); [EOL]     } [EOL]     if (_valueInstantiator.canCreateFromObjectWith()) { [EOL]         SettableBeanProperty[] creatorProps = _valueInstantiator.getFromObjectArguments(ctxt.getConfig()); [EOL]         _propertyBasedCreator = PropertyBasedCreator.construct(ctxt, _valueInstantiator, creatorProps); [EOL]     } [EOL]     _standardStringKey = _isStdKeyDeser(_mapType, _keyDeserializer); [EOL] }
@Override [EOL] public void resolve(DeserializationContext ctxt) throws JsonMappingException { [EOL]     if (_valueInstantiator.canCreateUsingDelegate()) { [EOL]         JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig()); [EOL]         if (delegateType == null) { [EOL]             throw new IllegalArgumentException("Invalid delegate-creator definition for " + _mapType + ": value instantiator (" + _valueInstantiator.getClass().getName() + ") returned true for 'canCreateUsingDelegate()', but null for 'getDelegateType()'"); [EOL]         } [EOL]         _delegateDeserializer = findDeserializer(ctxt, delegateType, null); [EOL]     } [EOL]     if (_valueInstantiator.canCreateFromObjectWith()) { [EOL]         SettableBeanProperty[] creatorProps = _valueInstantiator.getFromObjectArguments(ctxt.getConfig()); [EOL]         _propertyBasedCreator = PropertyBasedCreator.construct(ctxt, _valueInstantiator, creatorProps); [EOL]     } [EOL]     _standardStringKey = _isStdKeyDeser(_mapType, _keyDeserializer); [EOL] }
@Override [EOL] public void resolve(DeserializationContext ctxt) throws JsonMappingException { [EOL]     if (_valueInstantiator.canCreateUsingDelegate()) { [EOL]         JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig()); [EOL]         if (delegateType == null) { [EOL]             throw new IllegalArgumentException("Invalid delegate-creator definition for " + _mapType + ": value instantiator (" + _valueInstantiator.getClass().getName() + ") returned true for 'canCreateUsingDelegate()', but null for 'getDelegateType()'"); [EOL]         } [EOL]         _delegateDeserializer = findDeserializer(ctxt, delegateType, null); [EOL]     } [EOL]     if (_valueInstantiator.canCreateFromObjectWith()) { [EOL]         SettableBeanProperty[] creatorProps = _valueInstantiator.getFromObjectArguments(ctxt.getConfig()); [EOL]         _propertyBasedCreator = PropertyBasedCreator.construct(ctxt, _valueInstantiator, creatorProps); [EOL]     } [EOL]     _standardStringKey = _isStdKeyDeser(_mapType, _keyDeserializer); [EOL] }
@Override [EOL] public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException { [EOL]     KeyDeserializer kd = _keyDeserializer; [EOL]     if (kd == null) { [EOL]         kd = ctxt.findKeyDeserializer(_mapType.getKeyType(), property); [EOL]     } else { [EOL]         if (kd instanceof ContextualKeyDeserializer) { [EOL]             kd = ((ContextualKeyDeserializer) kd).createContextual(ctxt, property); [EOL]         } [EOL]     } [EOL]     JsonDeserializer<?> vd = _valueDeserializer; [EOL]     vd = findConvertingContentDeserializer(ctxt, property, vd); [EOL]     if (vd == null) { [EOL]         vd = ctxt.findContextualValueDeserializer(_mapType.getContentType(), property); [EOL]     } else { [EOL]         if (vd instanceof ContextualDeserializer) { [EOL]             vd = ((ContextualDeserializer) vd).createContextual(ctxt, property); [EOL]         } [EOL]     } [EOL]     TypeDeserializer vtd = _valueTypeDeserializer; [EOL]     if (vtd != null) { [EOL]         vtd = vtd.forProperty(property); [EOL]     } [EOL]     HashSet<String> ignored = _ignorableProperties; [EOL]     AnnotationIntrospector intr = ctxt.getAnnotationIntrospector(); [EOL]     if (intr != null && property != null) { [EOL]         String[] moreToIgnore = intr.findPropertiesToIgnore(property.getMember()); [EOL]         if (moreToIgnore != null) { [EOL]             ignored = (ignored == null) ? new HashSet<String>() : new HashSet<String>(ignored); [EOL]             for (String str : moreToIgnore) { [EOL]                 ignored.add(str); [EOL]             } [EOL]         } [EOL]     } [EOL]     return withResolved(kd, vtd, vd, ignored); [EOL] }
@Override [EOL] public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException { [EOL]     KeyDeserializer kd = _keyDeserializer; [EOL]     if (kd == null) { [EOL]         kd = ctxt.findKeyDeserializer(_mapType.getKeyType(), property); [EOL]     } else { [EOL]         if (kd instanceof ContextualKeyDeserializer) { [EOL]             kd = ((ContextualKeyDeserializer) kd).createContextual(ctxt, property); [EOL]         } [EOL]     } [EOL]     JsonDeserializer<?> vd = _valueDeserializer; [EOL]     vd = findConvertingContentDeserializer(ctxt, property, vd); [EOL]     if (vd == null) { [EOL]         vd = ctxt.findContextualValueDeserializer(_mapType.getContentType(), property); [EOL]     } else { [EOL]         if (vd instanceof ContextualDeserializer) { [EOL]             vd = ((ContextualDeserializer) vd).createContextual(ctxt, property); [EOL]         } [EOL]     } [EOL]     TypeDeserializer vtd = _valueTypeDeserializer; [EOL]     if (vtd != null) { [EOL]         vtd = vtd.forProperty(property); [EOL]     } [EOL]     HashSet<String> ignored = _ignorableProperties; [EOL]     AnnotationIntrospector intr = ctxt.getAnnotationIntrospector(); [EOL]     if (intr != null && property != null) { [EOL]         String[] moreToIgnore = intr.findPropertiesToIgnore(property.getMember()); [EOL]         if (moreToIgnore != null) { [EOL]             ignored = (ignored == null) ? new HashSet<String>() : new HashSet<String>(ignored); [EOL]             for (String str : moreToIgnore) { [EOL]                 ignored.add(str); [EOL]             } [EOL]         } [EOL]     } [EOL]     return withResolved(kd, vtd, vd, ignored); [EOL] }
@Override [EOL] public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException { [EOL]     KeyDeserializer kd = _keyDeserializer; [EOL]     if (kd == null) { [EOL]         kd = ctxt.findKeyDeserializer(_mapType.getKeyType(), property); [EOL]     } else { [EOL]         if (kd instanceof ContextualKeyDeserializer) { [EOL]             kd = ((ContextualKeyDeserializer) kd).createContextual(ctxt, property); [EOL]         } [EOL]     } [EOL]     JsonDeserializer<?> vd = _valueDeserializer; [EOL]     vd = findConvertingContentDeserializer(ctxt, property, vd); [EOL]     if (vd == null) { [EOL]         vd = ctxt.findContextualValueDeserializer(_mapType.getContentType(), property); [EOL]     } else { [EOL]         if (vd instanceof ContextualDeserializer) { [EOL]             vd = ((ContextualDeserializer) vd).createContextual(ctxt, property); [EOL]         } [EOL]     } [EOL]     TypeDeserializer vtd = _valueTypeDeserializer; [EOL]     if (vtd != null) { [EOL]         vtd = vtd.forProperty(property); [EOL]     } [EOL]     HashSet<String> ignored = _ignorableProperties; [EOL]     AnnotationIntrospector intr = ctxt.getAnnotationIntrospector(); [EOL]     if (intr != null && property != null) { [EOL]         String[] moreToIgnore = intr.findPropertiesToIgnore(property.getMember()); [EOL]         if (moreToIgnore != null) { [EOL]             ignored = (ignored == null) ? new HashSet<String>() : new HashSet<String>(ignored); [EOL]             for (String str : moreToIgnore) { [EOL]                 ignored.add(str); [EOL]             } [EOL]         } [EOL]     } [EOL]     return withResolved(kd, vtd, vd, ignored); [EOL] }
@Override [EOL] @SuppressWarnings("unchecked") [EOL] public Map<Object, Object> deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_propertyBasedCreator != null) { [EOL]         return _deserializeUsingCreator(jp, ctxt); [EOL]     } [EOL]     if (_delegateDeserializer != null) { [EOL]         return (Map<Object, Object>) _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]     } [EOL]     if (!_hasDefaultCreator) { [EOL]         throw ctxt.instantiationException(getMapClass(), "No default constructor found"); [EOL]     } [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t != JsonToken.START_OBJECT && t != JsonToken.FIELD_NAME && t != JsonToken.END_OBJECT) { [EOL]         if (t == JsonToken.VALUE_STRING) { [EOL]             return (Map<Object, Object>) _valueInstantiator.createFromString(ctxt, jp.getText()); [EOL]         } [EOL]         throw ctxt.mappingException(getMapClass()); [EOL]     } [EOL]     final Map<Object, Object> result = (Map<Object, Object>) _valueInstantiator.createUsingDefault(ctxt); [EOL]     if (_standardStringKey) { [EOL]         _readAndBindStringMap(jp, ctxt, result); [EOL]         return result; [EOL]     } [EOL]     _readAndBind(jp, ctxt, result); [EOL]     return result; [EOL] }
@Override [EOL] @SuppressWarnings("unchecked") [EOL] public Map<Object, Object> deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_propertyBasedCreator != null) { [EOL]         return _deserializeUsingCreator(jp, ctxt); [EOL]     } [EOL]     if (_delegateDeserializer != null) { [EOL]         return (Map<Object, Object>) _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]     } [EOL]     if (!_hasDefaultCreator) { [EOL]         throw ctxt.instantiationException(getMapClass(), "No default constructor found"); [EOL]     } [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t != JsonToken.START_OBJECT && t != JsonToken.FIELD_NAME && t != JsonToken.END_OBJECT) { [EOL]         if (t == JsonToken.VALUE_STRING) { [EOL]             return (Map<Object, Object>) _valueInstantiator.createFromString(ctxt, jp.getText()); [EOL]         } [EOL]         throw ctxt.mappingException(getMapClass()); [EOL]     } [EOL]     final Map<Object, Object> result = (Map<Object, Object>) _valueInstantiator.createUsingDefault(ctxt); [EOL]     if (_standardStringKey) { [EOL]         _readAndBindStringMap(jp, ctxt, result); [EOL]         return result; [EOL]     } [EOL]     _readAndBind(jp, ctxt, result); [EOL]     return result; [EOL] }
@Override [EOL] @SuppressWarnings("unchecked") [EOL] public Map<Object, Object> deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_propertyBasedCreator != null) { [EOL]         return _deserializeUsingCreator(jp, ctxt); [EOL]     } [EOL]     if (_delegateDeserializer != null) { [EOL]         return (Map<Object, Object>) _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]     } [EOL]     if (!_hasDefaultCreator) { [EOL]         throw ctxt.instantiationException(getMapClass(), "No default constructor found"); [EOL]     } [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t != JsonToken.START_OBJECT && t != JsonToken.FIELD_NAME && t != JsonToken.END_OBJECT) { [EOL]         if (t == JsonToken.VALUE_STRING) { [EOL]             return (Map<Object, Object>) _valueInstantiator.createFromString(ctxt, jp.getText()); [EOL]         } [EOL]         throw ctxt.mappingException(getMapClass()); [EOL]     } [EOL]     final Map<Object, Object> result = (Map<Object, Object>) _valueInstantiator.createUsingDefault(ctxt); [EOL]     if (_standardStringKey) { [EOL]         _readAndBindStringMap(jp, ctxt, result); [EOL]         return result; [EOL]     } [EOL]     _readAndBind(jp, ctxt, result); [EOL]     return result; [EOL] }
@Override [EOL] @SuppressWarnings("unchecked") [EOL] public Map<Object, Object> deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_propertyBasedCreator != null) { [EOL]         return _deserializeUsingCreator(jp, ctxt); [EOL]     } [EOL]     if (_delegateDeserializer != null) { [EOL]         return (Map<Object, Object>) _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]     } [EOL]     if (!_hasDefaultCreator) { [EOL]         throw ctxt.instantiationException(getMapClass(), "No default constructor found"); [EOL]     } [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t != JsonToken.START_OBJECT && t != JsonToken.FIELD_NAME && t != JsonToken.END_OBJECT) { [EOL]         if (t == JsonToken.VALUE_STRING) { [EOL]             return (Map<Object, Object>) _valueInstantiator.createFromString(ctxt, jp.getText()); [EOL]         } [EOL]         throw ctxt.mappingException(getMapClass()); [EOL]     } [EOL]     final Map<Object, Object> result = (Map<Object, Object>) _valueInstantiator.createUsingDefault(ctxt); [EOL]     if (_standardStringKey) { [EOL]         _readAndBindStringMap(jp, ctxt, result); [EOL]         return result; [EOL]     } [EOL]     _readAndBind(jp, ctxt, result); [EOL]     return result; [EOL] }
@Override [EOL] @SuppressWarnings("unchecked") [EOL] public Map<Object, Object> deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_propertyBasedCreator != null) { [EOL]         return _deserializeUsingCreator(jp, ctxt); [EOL]     } [EOL]     if (_delegateDeserializer != null) { [EOL]         return (Map<Object, Object>) _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]     } [EOL]     if (!_hasDefaultCreator) { [EOL]         throw ctxt.instantiationException(getMapClass(), "No default constructor found"); [EOL]     } [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t != JsonToken.START_OBJECT && t != JsonToken.FIELD_NAME && t != JsonToken.END_OBJECT) { [EOL]         if (t == JsonToken.VALUE_STRING) { [EOL]             return (Map<Object, Object>) _valueInstantiator.createFromString(ctxt, jp.getText()); [EOL]         } [EOL]         throw ctxt.mappingException(getMapClass()); [EOL]     } [EOL]     final Map<Object, Object> result = (Map<Object, Object>) _valueInstantiator.createUsingDefault(ctxt); [EOL]     if (_standardStringKey) { [EOL]         _readAndBindStringMap(jp, ctxt, result); [EOL]         return result; [EOL]     } [EOL]     _readAndBind(jp, ctxt, result); [EOL]     return result; [EOL] }
@Override [EOL] @SuppressWarnings("unchecked") [EOL] public Map<Object, Object> deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_propertyBasedCreator != null) { [EOL]         return _deserializeUsingCreator(jp, ctxt); [EOL]     } [EOL]     if (_delegateDeserializer != null) { [EOL]         return (Map<Object, Object>) _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]     } [EOL]     if (!_hasDefaultCreator) { [EOL]         throw ctxt.instantiationException(getMapClass(), "No default constructor found"); [EOL]     } [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t != JsonToken.START_OBJECT && t != JsonToken.FIELD_NAME && t != JsonToken.END_OBJECT) { [EOL]         if (t == JsonToken.VALUE_STRING) { [EOL]             return (Map<Object, Object>) _valueInstantiator.createFromString(ctxt, jp.getText()); [EOL]         } [EOL]         throw ctxt.mappingException(getMapClass()); [EOL]     } [EOL]     final Map<Object, Object> result = (Map<Object, Object>) _valueInstantiator.createUsingDefault(ctxt); [EOL]     if (_standardStringKey) { [EOL]         _readAndBindStringMap(jp, ctxt, result); [EOL]         return result; [EOL]     } [EOL]     _readAndBind(jp, ctxt, result); [EOL]     return result; [EOL] }
@Override [EOL] @SuppressWarnings("unchecked") [EOL] public Map<Object, Object> deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_propertyBasedCreator != null) { [EOL]         return _deserializeUsingCreator(jp, ctxt); [EOL]     } [EOL]     if (_delegateDeserializer != null) { [EOL]         return (Map<Object, Object>) _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]     } [EOL]     if (!_hasDefaultCreator) { [EOL]         throw ctxt.instantiationException(getMapClass(), "No default constructor found"); [EOL]     } [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t != JsonToken.START_OBJECT && t != JsonToken.FIELD_NAME && t != JsonToken.END_OBJECT) { [EOL]         if (t == JsonToken.VALUE_STRING) { [EOL]             return (Map<Object, Object>) _valueInstantiator.createFromString(ctxt, jp.getText()); [EOL]         } [EOL]         throw ctxt.mappingException(getMapClass()); [EOL]     } [EOL]     final Map<Object, Object> result = (Map<Object, Object>) _valueInstantiator.createUsingDefault(ctxt); [EOL]     if (_standardStringKey) { [EOL]         _readAndBindStringMap(jp, ctxt, result); [EOL]         return result; [EOL]     } [EOL]     _readAndBind(jp, ctxt, result); [EOL]     return result; [EOL] }
@Override [EOL] @SuppressWarnings("unchecked") [EOL] public Map<Object, Object> deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_propertyBasedCreator != null) { [EOL]         return _deserializeUsingCreator(jp, ctxt); [EOL]     } [EOL]     if (_delegateDeserializer != null) { [EOL]         return (Map<Object, Object>) _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]     } [EOL]     if (!_hasDefaultCreator) { [EOL]         throw ctxt.instantiationException(getMapClass(), "No default constructor found"); [EOL]     } [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t != JsonToken.START_OBJECT && t != JsonToken.FIELD_NAME && t != JsonToken.END_OBJECT) { [EOL]         if (t == JsonToken.VALUE_STRING) { [EOL]             return (Map<Object, Object>) _valueInstantiator.createFromString(ctxt, jp.getText()); [EOL]         } [EOL]         throw ctxt.mappingException(getMapClass()); [EOL]     } [EOL]     final Map<Object, Object> result = (Map<Object, Object>) _valueInstantiator.createUsingDefault(ctxt); [EOL]     if (_standardStringKey) { [EOL]         _readAndBindStringMap(jp, ctxt, result); [EOL]         return result; [EOL]     } [EOL]     _readAndBind(jp, ctxt, result); [EOL]     return result; [EOL] }
protected final void _readAndBindStringMap(JsonParser jp, DeserializationContext ctxt, Map<Object, Object> result) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.START_OBJECT) { [EOL]         t = jp.nextToken(); [EOL]     } [EOL]     final JsonDeserializer<Object> valueDes = _valueDeserializer; [EOL]     final TypeDeserializer typeDeser = _valueTypeDeserializer; [EOL]     for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) { [EOL]         String fieldName = jp.getCurrentName(); [EOL]         t = jp.nextToken(); [EOL]         if (_ignorableProperties != null && _ignorableProperties.contains(fieldName)) { [EOL]             jp.skipChildren(); [EOL]             continue; [EOL]         } [EOL]         Object value; [EOL]         if (t == JsonToken.VALUE_NULL) { [EOL]             value = null; [EOL]         } else if (typeDeser == null) { [EOL]             value = valueDes.deserialize(jp, ctxt); [EOL]         } else { [EOL]             value = valueDes.deserializeWithType(jp, ctxt, typeDeser); [EOL]         } [EOL]         result.put(fieldName, value); [EOL]     } [EOL] }
protected final void _readAndBindStringMap(JsonParser jp, DeserializationContext ctxt, Map<Object, Object> result) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.START_OBJECT) { [EOL]         t = jp.nextToken(); [EOL]     } [EOL]     final JsonDeserializer<Object> valueDes = _valueDeserializer; [EOL]     final TypeDeserializer typeDeser = _valueTypeDeserializer; [EOL]     for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) { [EOL]         String fieldName = jp.getCurrentName(); [EOL]         t = jp.nextToken(); [EOL]         if (_ignorableProperties != null && _ignorableProperties.contains(fieldName)) { [EOL]             jp.skipChildren(); [EOL]             continue; [EOL]         } [EOL]         Object value; [EOL]         if (t == JsonToken.VALUE_NULL) { [EOL]             value = null; [EOL]         } else if (typeDeser == null) { [EOL]             value = valueDes.deserialize(jp, ctxt); [EOL]         } else { [EOL]             value = valueDes.deserializeWithType(jp, ctxt, typeDeser); [EOL]         } [EOL]         result.put(fieldName, value); [EOL]     } [EOL] }
protected final void _readAndBindStringMap(JsonParser jp, DeserializationContext ctxt, Map<Object, Object> result) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.START_OBJECT) { [EOL]         t = jp.nextToken(); [EOL]     } [EOL]     final JsonDeserializer<Object> valueDes = _valueDeserializer; [EOL]     final TypeDeserializer typeDeser = _valueTypeDeserializer; [EOL]     for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) { [EOL]         String fieldName = jp.getCurrentName(); [EOL]         t = jp.nextToken(); [EOL]         if (_ignorableProperties != null && _ignorableProperties.contains(fieldName)) { [EOL]             jp.skipChildren(); [EOL]             continue; [EOL]         } [EOL]         Object value; [EOL]         if (t == JsonToken.VALUE_NULL) { [EOL]             value = null; [EOL]         } else if (typeDeser == null) { [EOL]             value = valueDes.deserialize(jp, ctxt); [EOL]         } else { [EOL]             value = valueDes.deserializeWithType(jp, ctxt, typeDeser); [EOL]         } [EOL]         result.put(fieldName, value); [EOL]     } [EOL] }
protected final void _readAndBindStringMap(JsonParser jp, DeserializationContext ctxt, Map<Object, Object> result) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.START_OBJECT) { [EOL]         t = jp.nextToken(); [EOL]     } [EOL]     final JsonDeserializer<Object> valueDes = _valueDeserializer; [EOL]     final TypeDeserializer typeDeser = _valueTypeDeserializer; [EOL]     for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) { [EOL]         String fieldName = jp.getCurrentName(); [EOL]         t = jp.nextToken(); [EOL]         if (_ignorableProperties != null && _ignorableProperties.contains(fieldName)) { [EOL]             jp.skipChildren(); [EOL]             continue; [EOL]         } [EOL]         Object value; [EOL]         if (t == JsonToken.VALUE_NULL) { [EOL]             value = null; [EOL]         } else if (typeDeser == null) { [EOL]             value = valueDes.deserialize(jp, ctxt); [EOL]         } else { [EOL]             value = valueDes.deserializeWithType(jp, ctxt, typeDeser); [EOL]         } [EOL]         result.put(fieldName, value); [EOL]     } [EOL] }
public static String format(Date date) { [EOL]     return format(date, false, TIMEZONE_GMT); [EOL] }
public static String format(Date date) { [EOL]     return format(date, false, TIMEZONE_GMT); [EOL] }
public static String format(Date date, boolean millis, TimeZone tz) { [EOL]     Calendar calendar = new GregorianCalendar(tz, Locale.US); [EOL]     calendar.setTime(date); [EOL]     int capacity = "yyyy-MM-ddThh:mm:ss".length(); [EOL]     capacity += millis ? ".sss".length() : 0; [EOL]     capacity += tz.getRawOffset() == 0 ? "Z".length() : "+hh:mm".length(); [EOL]     StringBuilder formatted = new StringBuilder(capacity); [EOL]     padInt(formatted, calendar.get(Calendar.YEAR), "yyyy".length()); [EOL]     formatted.append('-'); [EOL]     padInt(formatted, calendar.get(Calendar.MONTH) + 1, "MM".length()); [EOL]     formatted.append('-'); [EOL]     padInt(formatted, calendar.get(Calendar.DAY_OF_MONTH), "dd".length()); [EOL]     formatted.append('T'); [EOL]     padInt(formatted, calendar.get(Calendar.HOUR_OF_DAY), "hh".length()); [EOL]     formatted.append(':'); [EOL]     padInt(formatted, calendar.get(Calendar.MINUTE), "mm".length()); [EOL]     formatted.append(':'); [EOL]     padInt(formatted, calendar.get(Calendar.SECOND), "ss".length()); [EOL]     if (millis) { [EOL]         formatted.append('.'); [EOL]         padInt(formatted, calendar.get(Calendar.MILLISECOND), "sss".length()); [EOL]     } [EOL]     int offset = tz.getOffset(calendar.getTimeInMillis()); [EOL]     if (offset != 0) { [EOL]         int hours = Math.abs((offset / (60 * 1000)) / 60); [EOL]         int minutes = Math.abs((offset / (60 * 1000)) % 60); [EOL]         formatted.append(offset < 0 ? '-' : '+'); [EOL]         padInt(formatted, hours, "hh".length()); [EOL]         formatted.append(':'); [EOL]         padInt(formatted, minutes, "mm".length()); [EOL]     } else { [EOL]         formatted.append('Z'); [EOL]     } [EOL]     return formatted.toString(); [EOL] }
public static String format(Date date, boolean millis, TimeZone tz) { [EOL]     Calendar calendar = new GregorianCalendar(tz, Locale.US); [EOL]     calendar.setTime(date); [EOL]     int capacity = "yyyy-MM-ddThh:mm:ss".length(); [EOL]     capacity += millis ? ".sss".length() : 0; [EOL]     capacity += tz.getRawOffset() == 0 ? "Z".length() : "+hh:mm".length(); [EOL]     StringBuilder formatted = new StringBuilder(capacity); [EOL]     padInt(formatted, calendar.get(Calendar.YEAR), "yyyy".length()); [EOL]     formatted.append('-'); [EOL]     padInt(formatted, calendar.get(Calendar.MONTH) + 1, "MM".length()); [EOL]     formatted.append('-'); [EOL]     padInt(formatted, calendar.get(Calendar.DAY_OF_MONTH), "dd".length()); [EOL]     formatted.append('T'); [EOL]     padInt(formatted, calendar.get(Calendar.HOUR_OF_DAY), "hh".length()); [EOL]     formatted.append(':'); [EOL]     padInt(formatted, calendar.get(Calendar.MINUTE), "mm".length()); [EOL]     formatted.append(':'); [EOL]     padInt(formatted, calendar.get(Calendar.SECOND), "ss".length()); [EOL]     if (millis) { [EOL]         formatted.append('.'); [EOL]         padInt(formatted, calendar.get(Calendar.MILLISECOND), "sss".length()); [EOL]     } [EOL]     int offset = tz.getOffset(calendar.getTimeInMillis()); [EOL]     if (offset != 0) { [EOL]         int hours = Math.abs((offset / (60 * 1000)) / 60); [EOL]         int minutes = Math.abs((offset / (60 * 1000)) % 60); [EOL]         formatted.append(offset < 0 ? '-' : '+'); [EOL]         padInt(formatted, hours, "hh".length()); [EOL]         formatted.append(':'); [EOL]         padInt(formatted, minutes, "mm".length()); [EOL]     } else { [EOL]         formatted.append('Z'); [EOL]     } [EOL]     return formatted.toString(); [EOL] }
public static String format(Date date, boolean millis, TimeZone tz) { [EOL]     Calendar calendar = new GregorianCalendar(tz, Locale.US); [EOL]     calendar.setTime(date); [EOL]     int capacity = "yyyy-MM-ddThh:mm:ss".length(); [EOL]     capacity += millis ? ".sss".length() : 0; [EOL]     capacity += tz.getRawOffset() == 0 ? "Z".length() : "+hh:mm".length(); [EOL]     StringBuilder formatted = new StringBuilder(capacity); [EOL]     padInt(formatted, calendar.get(Calendar.YEAR), "yyyy".length()); [EOL]     formatted.append('-'); [EOL]     padInt(formatted, calendar.get(Calendar.MONTH) + 1, "MM".length()); [EOL]     formatted.append('-'); [EOL]     padInt(formatted, calendar.get(Calendar.DAY_OF_MONTH), "dd".length()); [EOL]     formatted.append('T'); [EOL]     padInt(formatted, calendar.get(Calendar.HOUR_OF_DAY), "hh".length()); [EOL]     formatted.append(':'); [EOL]     padInt(formatted, calendar.get(Calendar.MINUTE), "mm".length()); [EOL]     formatted.append(':'); [EOL]     padInt(formatted, calendar.get(Calendar.SECOND), "ss".length()); [EOL]     if (millis) { [EOL]         formatted.append('.'); [EOL]         padInt(formatted, calendar.get(Calendar.MILLISECOND), "sss".length()); [EOL]     } [EOL]     int offset = tz.getOffset(calendar.getTimeInMillis()); [EOL]     if (offset != 0) { [EOL]         int hours = Math.abs((offset / (60 * 1000)) / 60); [EOL]         int minutes = Math.abs((offset / (60 * 1000)) % 60); [EOL]         formatted.append(offset < 0 ? '-' : '+'); [EOL]         padInt(formatted, hours, "hh".length()); [EOL]         formatted.append(':'); [EOL]         padInt(formatted, minutes, "mm".length()); [EOL]     } else { [EOL]         formatted.append('Z'); [EOL]     } [EOL]     return formatted.toString(); [EOL] }
public static String format(Date date, boolean millis, TimeZone tz) { [EOL]     Calendar calendar = new GregorianCalendar(tz, Locale.US); [EOL]     calendar.setTime(date); [EOL]     int capacity = "yyyy-MM-ddThh:mm:ss".length(); [EOL]     capacity += millis ? ".sss".length() : 0; [EOL]     capacity += tz.getRawOffset() == 0 ? "Z".length() : "+hh:mm".length(); [EOL]     StringBuilder formatted = new StringBuilder(capacity); [EOL]     padInt(formatted, calendar.get(Calendar.YEAR), "yyyy".length()); [EOL]     formatted.append('-'); [EOL]     padInt(formatted, calendar.get(Calendar.MONTH) + 1, "MM".length()); [EOL]     formatted.append('-'); [EOL]     padInt(formatted, calendar.get(Calendar.DAY_OF_MONTH), "dd".length()); [EOL]     formatted.append('T'); [EOL]     padInt(formatted, calendar.get(Calendar.HOUR_OF_DAY), "hh".length()); [EOL]     formatted.append(':'); [EOL]     padInt(formatted, calendar.get(Calendar.MINUTE), "mm".length()); [EOL]     formatted.append(':'); [EOL]     padInt(formatted, calendar.get(Calendar.SECOND), "ss".length()); [EOL]     if (millis) { [EOL]         formatted.append('.'); [EOL]         padInt(formatted, calendar.get(Calendar.MILLISECOND), "sss".length()); [EOL]     } [EOL]     int offset = tz.getOffset(calendar.getTimeInMillis()); [EOL]     if (offset != 0) { [EOL]         int hours = Math.abs((offset / (60 * 1000)) / 60); [EOL]         int minutes = Math.abs((offset / (60 * 1000)) % 60); [EOL]         formatted.append(offset < 0 ? '-' : '+'); [EOL]         padInt(formatted, hours, "hh".length()); [EOL]         formatted.append(':'); [EOL]         padInt(formatted, minutes, "mm".length()); [EOL]     } else { [EOL]         formatted.append('Z'); [EOL]     } [EOL]     return formatted.toString(); [EOL] }
private static void padInt(StringBuilder buffer, int value, int length) { [EOL]     String strValue = Integer.toString(value); [EOL]     for (int i = length - strValue.length(); i > 0; i--) { [EOL]         buffer.append('0'); [EOL]     } [EOL]     buffer.append(strValue); [EOL] }
private static void padInt(StringBuilder buffer, int value, int length) { [EOL]     String strValue = Integer.toString(value); [EOL]     for (int i = length - strValue.length(); i > 0; i--) { [EOL]         buffer.append('0'); [EOL]     } [EOL]     buffer.append(strValue); [EOL] }
private static void padInt(StringBuilder buffer, int value, int length) { [EOL]     String strValue = Integer.toString(value); [EOL]     for (int i = length - strValue.length(); i > 0; i--) { [EOL]         buffer.append('0'); [EOL]     } [EOL]     buffer.append(strValue); [EOL] }
private static void padInt(StringBuilder buffer, int value, int length) { [EOL]     String strValue = Integer.toString(value); [EOL]     for (int i = length - strValue.length(); i > 0; i--) { [EOL]         buffer.append('0'); [EOL]     } [EOL]     buffer.append(strValue); [EOL] }
public Std(Visibility getter, Visibility isGetter, Visibility setter, Visibility creator, Visibility field) { [EOL]     _getterMinLevel = getter; [EOL]     _isGetterMinLevel = isGetter; [EOL]     _setterMinLevel = setter; [EOL]     _creatorMinLevel = creator; [EOL]     _fieldMinLevel = field; [EOL] }
public Std(Visibility getter, Visibility isGetter, Visibility setter, Visibility creator, Visibility field) { [EOL]     _getterMinLevel = getter; [EOL]     _isGetterMinLevel = isGetter; [EOL]     _setterMinLevel = setter; [EOL]     _creatorMinLevel = creator; [EOL]     _fieldMinLevel = field; [EOL] }
public Std(Visibility getter, Visibility isGetter, Visibility setter, Visibility creator, Visibility field) { [EOL]     _getterMinLevel = getter; [EOL]     _isGetterMinLevel = isGetter; [EOL]     _setterMinLevel = setter; [EOL]     _creatorMinLevel = creator; [EOL]     _fieldMinLevel = field; [EOL] }
@Override [EOL] public Std with(JsonAutoDetect ann) { [EOL]     Std curr = this; [EOL]     if (ann != null) { [EOL]         curr = curr.withGetterVisibility(ann.getterVisibility()); [EOL]         curr = curr.withIsGetterVisibility(ann.isGetterVisibility()); [EOL]         curr = curr.withSetterVisibility(ann.setterVisibility()); [EOL]         curr = curr.withCreatorVisibility(ann.creatorVisibility()); [EOL]         curr = curr.withFieldVisibility(ann.fieldVisibility()); [EOL]     } [EOL]     return curr; [EOL] }
@Override [EOL] public Std with(JsonAutoDetect ann) { [EOL]     Std curr = this; [EOL]     if (ann != null) { [EOL]         curr = curr.withGetterVisibility(ann.getterVisibility()); [EOL]         curr = curr.withIsGetterVisibility(ann.isGetterVisibility()); [EOL]         curr = curr.withSetterVisibility(ann.setterVisibility()); [EOL]         curr = curr.withCreatorVisibility(ann.creatorVisibility()); [EOL]         curr = curr.withFieldVisibility(ann.fieldVisibility()); [EOL]     } [EOL]     return curr; [EOL] }
@Override [EOL] public Std withGetterVisibility(Visibility v) { [EOL]     if (v == Visibility.DEFAULT) [EOL]         v = DEFAULT._getterMinLevel; [EOL]     if (_getterMinLevel == v) [EOL]         return this; [EOL]     return new Std(v, _isGetterMinLevel, _setterMinLevel, _creatorMinLevel, _fieldMinLevel); [EOL] }
@Override [EOL] public Std withGetterVisibility(Visibility v) { [EOL]     if (v == Visibility.DEFAULT) [EOL]         v = DEFAULT._getterMinLevel; [EOL]     if (_getterMinLevel == v) [EOL]         return this; [EOL]     return new Std(v, _isGetterMinLevel, _setterMinLevel, _creatorMinLevel, _fieldMinLevel); [EOL] }
@Override [EOL] public Std withIsGetterVisibility(Visibility v) { [EOL]     if (v == Visibility.DEFAULT) [EOL]         v = DEFAULT._isGetterMinLevel; [EOL]     if (_isGetterMinLevel == v) [EOL]         return this; [EOL]     return new Std(_getterMinLevel, v, _setterMinLevel, _creatorMinLevel, _fieldMinLevel); [EOL] }
@Override [EOL] public Std withIsGetterVisibility(Visibility v) { [EOL]     if (v == Visibility.DEFAULT) [EOL]         v = DEFAULT._isGetterMinLevel; [EOL]     if (_isGetterMinLevel == v) [EOL]         return this; [EOL]     return new Std(_getterMinLevel, v, _setterMinLevel, _creatorMinLevel, _fieldMinLevel); [EOL] }
@Override [EOL] public Std withSetterVisibility(Visibility v) { [EOL]     if (v == Visibility.DEFAULT) [EOL]         v = DEFAULT._setterMinLevel; [EOL]     if (_setterMinLevel == v) [EOL]         return this; [EOL]     return new Std(_getterMinLevel, _isGetterMinLevel, v, _creatorMinLevel, _fieldMinLevel); [EOL] }
@Override [EOL] public Std withSetterVisibility(Visibility v) { [EOL]     if (v == Visibility.DEFAULT) [EOL]         v = DEFAULT._setterMinLevel; [EOL]     if (_setterMinLevel == v) [EOL]         return this; [EOL]     return new Std(_getterMinLevel, _isGetterMinLevel, v, _creatorMinLevel, _fieldMinLevel); [EOL] }
@Override [EOL] public Std withCreatorVisibility(Visibility v) { [EOL]     if (v == Visibility.DEFAULT) [EOL]         v = DEFAULT._creatorMinLevel; [EOL]     if (_creatorMinLevel == v) [EOL]         return this; [EOL]     return new Std(_getterMinLevel, _isGetterMinLevel, _setterMinLevel, v, _fieldMinLevel); [EOL] }
@Override [EOL] public Std withCreatorVisibility(Visibility v) { [EOL]     if (v == Visibility.DEFAULT) [EOL]         v = DEFAULT._creatorMinLevel; [EOL]     if (_creatorMinLevel == v) [EOL]         return this; [EOL]     return new Std(_getterMinLevel, _isGetterMinLevel, _setterMinLevel, v, _fieldMinLevel); [EOL] }
@Override [EOL] public Std withFieldVisibility(Visibility v) { [EOL]     if (v == Visibility.DEFAULT) [EOL]         v = DEFAULT._fieldMinLevel; [EOL]     if (_fieldMinLevel == v) [EOL]         return this; [EOL]     return new Std(_getterMinLevel, _isGetterMinLevel, _setterMinLevel, _creatorMinLevel, v); [EOL] }
@Override [EOL] public Std withFieldVisibility(Visibility v) { [EOL]     if (v == Visibility.DEFAULT) [EOL]         v = DEFAULT._fieldMinLevel; [EOL]     if (_fieldMinLevel == v) [EOL]         return this; [EOL]     return new Std(_getterMinLevel, _isGetterMinLevel, _setterMinLevel, _creatorMinLevel, v); [EOL] }
@Override [EOL] public Std withFieldVisibility(Visibility v) { [EOL]     if (v == Visibility.DEFAULT) [EOL]         v = DEFAULT._fieldMinLevel; [EOL]     if (_fieldMinLevel == v) [EOL]         return this; [EOL]     return new Std(_getterMinLevel, _isGetterMinLevel, _setterMinLevel, _creatorMinLevel, v); [EOL] }
public static JsonMappingException wrapWithPath(Throwable src, Object refFrom, String refFieldName) { [EOL]     return wrapWithPath(src, new Reference(refFrom, refFieldName)); [EOL] }
public static JsonMappingException wrapWithPath(Throwable src, Object refFrom, String refFieldName) { [EOL]     return wrapWithPath(src, new Reference(refFrom, refFieldName)); [EOL] }
public static JsonMappingException wrapWithPath(Throwable src, Object refFrom, String refFieldName) { [EOL]     return wrapWithPath(src, new Reference(refFrom, refFieldName)); [EOL] }
public static JsonMappingException wrapWithPath(Throwable src, Object refFrom, String refFieldName) { [EOL]     return wrapWithPath(src, new Reference(refFrom, refFieldName)); [EOL] }
public static JsonMappingException wrapWithPath(Throwable src, Reference ref) { [EOL]     JsonMappingException jme; [EOL]     if (src instanceof JsonMappingException) { [EOL]         jme = (JsonMappingException) src; [EOL]     } else { [EOL]         String msg = src.getMessage(); [EOL]         if (msg == null || msg.length() == 0) { [EOL]             msg = "(was " + src.getClass().getName() + ")"; [EOL]         } [EOL]         jme = new JsonMappingException(msg, null, src); [EOL]     } [EOL]     jme.prependPath(ref); [EOL]     return jme; [EOL] }
public static JsonMappingException wrapWithPath(Throwable src, Reference ref) { [EOL]     JsonMappingException jme; [EOL]     if (src instanceof JsonMappingException) { [EOL]         jme = (JsonMappingException) src; [EOL]     } else { [EOL]         String msg = src.getMessage(); [EOL]         if (msg == null || msg.length() == 0) { [EOL]             msg = "(was " + src.getClass().getName() + ")"; [EOL]         } [EOL]         jme = new JsonMappingException(msg, null, src); [EOL]     } [EOL]     jme.prependPath(ref); [EOL]     return jme; [EOL] }
public static JsonMappingException wrapWithPath(Throwable src, Reference ref) { [EOL]     JsonMappingException jme; [EOL]     if (src instanceof JsonMappingException) { [EOL]         jme = (JsonMappingException) src; [EOL]     } else { [EOL]         String msg = src.getMessage(); [EOL]         if (msg == null || msg.length() == 0) { [EOL]             msg = "(was " + src.getClass().getName() + ")"; [EOL]         } [EOL]         jme = new JsonMappingException(msg, null, src); [EOL]     } [EOL]     jme.prependPath(ref); [EOL]     return jme; [EOL] }
public static JsonMappingException wrapWithPath(Throwable src, Reference ref) { [EOL]     JsonMappingException jme; [EOL]     if (src instanceof JsonMappingException) { [EOL]         jme = (JsonMappingException) src; [EOL]     } else { [EOL]         String msg = src.getMessage(); [EOL]         if (msg == null || msg.length() == 0) { [EOL]             msg = "(was " + src.getClass().getName() + ")"; [EOL]         } [EOL]         jme = new JsonMappingException(msg, null, src); [EOL]     } [EOL]     jme.prependPath(ref); [EOL]     return jme; [EOL] }
public SerializerProvider() { [EOL]     _config = null; [EOL]     _serializerFactory = null; [EOL]     _serializerCache = new SerializerCache(); [EOL]     _knownSerializers = null; [EOL]     _rootNames = new RootNameLookup(); [EOL]     _serializationView = null; [EOL] }
protected SerializerProvider(SerializerProvider src, SerializationConfig config, SerializerFactory f) { [EOL]     if (config == null) { [EOL]         throw new NullPointerException(); [EOL]     } [EOL]     _serializerFactory = f; [EOL]     _config = config; [EOL]     _serializerCache = src._serializerCache; [EOL]     _unknownTypeSerializer = src._unknownTypeSerializer; [EOL]     _keySerializer = src._keySerializer; [EOL]     _nullValueSerializer = src._nullValueSerializer; [EOL]     _nullKeySerializer = src._nullKeySerializer; [EOL]     _rootNames = src._rootNames; [EOL]     _knownSerializers = _serializerCache.getReadOnlyLookupMap(); [EOL]     _serializationView = config.getActiveView(); [EOL] }
protected SerializerProvider(SerializerProvider src, SerializationConfig config, SerializerFactory f) { [EOL]     if (config == null) { [EOL]         throw new NullPointerException(); [EOL]     } [EOL]     _serializerFactory = f; [EOL]     _config = config; [EOL]     _serializerCache = src._serializerCache; [EOL]     _unknownTypeSerializer = src._unknownTypeSerializer; [EOL]     _keySerializer = src._keySerializer; [EOL]     _nullValueSerializer = src._nullValueSerializer; [EOL]     _nullKeySerializer = src._nullKeySerializer; [EOL]     _rootNames = src._rootNames; [EOL]     _knownSerializers = _serializerCache.getReadOnlyLookupMap(); [EOL]     _serializationView = config.getActiveView(); [EOL] }
@Override [EOL] public final SerializationConfig getConfig() { [EOL]     return _config; [EOL] }
@Override [EOL] public final TypeFactory getTypeFactory() { [EOL]     return _config.getTypeFactory(); [EOL] }
public JsonSerializer<Object> findValueSerializer(JavaType valueType, BeanProperty property) throws JsonMappingException { [EOL]     JsonSerializer<Object> ser = _knownSerializers.untypedValueSerializer(valueType); [EOL]     if (ser == null) { [EOL]         ser = _serializerCache.untypedValueSerializer(valueType); [EOL]         if (ser == null) { [EOL]             ser = _createAndCacheUntypedSerializer(valueType); [EOL]             if (ser == null) { [EOL]                 ser = getUnknownTypeSerializer(valueType.getRawClass()); [EOL]                 if (CACHE_UNKNOWN_MAPPINGS) { [EOL]                     _serializerCache.addAndResolveNonTypedSerializer(valueType, ser, this); [EOL]                 } [EOL]                 return ser; [EOL]             } [EOL]         } [EOL]     } [EOL]     return _handleContextual(ser, property); [EOL] }
public JsonSerializer<Object> findValueSerializer(JavaType valueType, BeanProperty property) throws JsonMappingException { [EOL]     JsonSerializer<Object> ser = _knownSerializers.untypedValueSerializer(valueType); [EOL]     if (ser == null) { [EOL]         ser = _serializerCache.untypedValueSerializer(valueType); [EOL]         if (ser == null) { [EOL]             ser = _createAndCacheUntypedSerializer(valueType); [EOL]             if (ser == null) { [EOL]                 ser = getUnknownTypeSerializer(valueType.getRawClass()); [EOL]                 if (CACHE_UNKNOWN_MAPPINGS) { [EOL]                     _serializerCache.addAndResolveNonTypedSerializer(valueType, ser, this); [EOL]                 } [EOL]                 return ser; [EOL]             } [EOL]         } [EOL]     } [EOL]     return _handleContextual(ser, property); [EOL] }
public JsonSerializer<Object> findValueSerializer(JavaType valueType, BeanProperty property) throws JsonMappingException { [EOL]     JsonSerializer<Object> ser = _knownSerializers.untypedValueSerializer(valueType); [EOL]     if (ser == null) { [EOL]         ser = _serializerCache.untypedValueSerializer(valueType); [EOL]         if (ser == null) { [EOL]             ser = _createAndCacheUntypedSerializer(valueType); [EOL]             if (ser == null) { [EOL]                 ser = getUnknownTypeSerializer(valueType.getRawClass()); [EOL]                 if (CACHE_UNKNOWN_MAPPINGS) { [EOL]                     _serializerCache.addAndResolveNonTypedSerializer(valueType, ser, this); [EOL]                 } [EOL]                 return ser; [EOL]             } [EOL]         } [EOL]     } [EOL]     return _handleContextual(ser, property); [EOL] }
public JsonSerializer<Object> findValueSerializer(JavaType valueType, BeanProperty property) throws JsonMappingException { [EOL]     JsonSerializer<Object> ser = _knownSerializers.untypedValueSerializer(valueType); [EOL]     if (ser == null) { [EOL]         ser = _serializerCache.untypedValueSerializer(valueType); [EOL]         if (ser == null) { [EOL]             ser = _createAndCacheUntypedSerializer(valueType); [EOL]             if (ser == null) { [EOL]                 ser = getUnknownTypeSerializer(valueType.getRawClass()); [EOL]                 if (CACHE_UNKNOWN_MAPPINGS) { [EOL]                     _serializerCache.addAndResolveNonTypedSerializer(valueType, ser, this); [EOL]                 } [EOL]                 return ser; [EOL]             } [EOL]         } [EOL]     } [EOL]     return _handleContextual(ser, property); [EOL] }
public JsonSerializer<Object> findKeySerializer(JavaType keyType, BeanProperty property) throws JsonMappingException { [EOL]     JsonSerializer<Object> ser = _serializerFactory.createKeySerializer(_config, keyType, _keySerializer); [EOL]     return _handleContextualResolvable(ser, property); [EOL] }
public JsonSerializer<Object> findKeySerializer(JavaType keyType, BeanProperty property) throws JsonMappingException { [EOL]     JsonSerializer<Object> ser = _serializerFactory.createKeySerializer(_config, keyType, _keySerializer); [EOL]     return _handleContextualResolvable(ser, property); [EOL] }
public JsonSerializer<Object> getDefaultNullKeySerializer() { [EOL]     return _nullKeySerializer; [EOL] }
public JsonSerializer<Object> getDefaultNullValueSerializer() { [EOL]     return _nullValueSerializer; [EOL] }
public JsonSerializer<Object> findNullValueSerializer(BeanProperty property) throws JsonMappingException { [EOL]     return getDefaultNullValueSerializer(); [EOL] }
public JsonSerializer<Object> findNullValueSerializer(BeanProperty property) throws JsonMappingException { [EOL]     return getDefaultNullValueSerializer(); [EOL] }
public JsonSerializer<Object> getUnknownTypeSerializer(Class<?> unknownType) { [EOL]     return _unknownTypeSerializer; [EOL] }
public JsonSerializer<Object> getUnknownTypeSerializer(Class<?> unknownType) { [EOL]     return _unknownTypeSerializer; [EOL] }
protected JsonSerializer<Object> _findExplicitUntypedSerializer(Class<?> runtimeType) throws JsonMappingException { [EOL]     JsonSerializer<Object> ser = _knownSerializers.untypedValueSerializer(runtimeType); [EOL]     if (ser != null) { [EOL]         return ser; [EOL]     } [EOL]     ser = _serializerCache.untypedValueSerializer(runtimeType); [EOL]     if (ser != null) { [EOL]         return ser; [EOL]     } [EOL]     return _createAndCacheUntypedSerializer(runtimeType); [EOL] }
protected JsonSerializer<Object> _findExplicitUntypedSerializer(Class<?> runtimeType) throws JsonMappingException { [EOL]     JsonSerializer<Object> ser = _knownSerializers.untypedValueSerializer(runtimeType); [EOL]     if (ser != null) { [EOL]         return ser; [EOL]     } [EOL]     ser = _serializerCache.untypedValueSerializer(runtimeType); [EOL]     if (ser != null) { [EOL]         return ser; [EOL]     } [EOL]     return _createAndCacheUntypedSerializer(runtimeType); [EOL] }
protected JsonSerializer<Object> _findExplicitUntypedSerializer(Class<?> runtimeType) throws JsonMappingException { [EOL]     JsonSerializer<Object> ser = _knownSerializers.untypedValueSerializer(runtimeType); [EOL]     if (ser != null) { [EOL]         return ser; [EOL]     } [EOL]     ser = _serializerCache.untypedValueSerializer(runtimeType); [EOL]     if (ser != null) { [EOL]         return ser; [EOL]     } [EOL]     return _createAndCacheUntypedSerializer(runtimeType); [EOL] }
protected JsonSerializer<Object> _createAndCacheUntypedSerializer(Class<?> type) throws JsonMappingException { [EOL]     JsonSerializer<Object> ser; [EOL]     try { [EOL]         ser = _createUntypedSerializer(_config.constructType(type)); [EOL]     } catch (IllegalArgumentException iae) { [EOL]         throw new JsonMappingException(iae.getMessage(), null, iae); [EOL]     } [EOL]     if (ser != null) { [EOL]         _serializerCache.addAndResolveNonTypedSerializer(type, ser, this); [EOL]     } [EOL]     return ser; [EOL] }
protected JsonSerializer<Object> _createAndCacheUntypedSerializer(JavaType type) throws JsonMappingException { [EOL]     JsonSerializer<Object> ser; [EOL]     try { [EOL]         ser = _createUntypedSerializer(type); [EOL]     } catch (IllegalArgumentException iae) { [EOL]         throw new JsonMappingException(iae.getMessage(), null, iae); [EOL]     } [EOL]     if (ser != null) { [EOL]         _serializerCache.addAndResolveNonTypedSerializer(type, ser, this); [EOL]     } [EOL]     return ser; [EOL] }
protected JsonSerializer<Object> _createAndCacheUntypedSerializer(JavaType type) throws JsonMappingException { [EOL]     JsonSerializer<Object> ser; [EOL]     try { [EOL]         ser = _createUntypedSerializer(type); [EOL]     } catch (IllegalArgumentException iae) { [EOL]         throw new JsonMappingException(iae.getMessage(), null, iae); [EOL]     } [EOL]     if (ser != null) { [EOL]         _serializerCache.addAndResolveNonTypedSerializer(type, ser, this); [EOL]     } [EOL]     return ser; [EOL] }
protected JsonSerializer<Object> _createAndCacheUntypedSerializer(JavaType type) throws JsonMappingException { [EOL]     JsonSerializer<Object> ser; [EOL]     try { [EOL]         ser = _createUntypedSerializer(type); [EOL]     } catch (IllegalArgumentException iae) { [EOL]         throw new JsonMappingException(iae.getMessage(), null, iae); [EOL]     } [EOL]     if (ser != null) { [EOL]         _serializerCache.addAndResolveNonTypedSerializer(type, ser, this); [EOL]     } [EOL]     return ser; [EOL] }
protected JsonSerializer<Object> _createUntypedSerializer(JavaType type) throws JsonMappingException { [EOL]     return (JsonSerializer<Object>) _serializerFactory.createSerializer(this, type); [EOL] }
protected JsonSerializer<Object> _handleContextualResolvable(JsonSerializer<?> ser, BeanProperty property) throws JsonMappingException { [EOL]     if (ser instanceof ResolvableSerializer) { [EOL]         ((ResolvableSerializer) ser).resolve(this); [EOL]     } [EOL]     return _handleContextual(ser, property); [EOL] }
protected JsonSerializer<Object> _handleContextualResolvable(JsonSerializer<?> ser, BeanProperty property) throws JsonMappingException { [EOL]     if (ser instanceof ResolvableSerializer) { [EOL]         ((ResolvableSerializer) ser).resolve(this); [EOL]     } [EOL]     return _handleContextual(ser, property); [EOL] }
@SuppressWarnings("unchecked") [EOL] protected JsonSerializer<Object> _handleContextual(JsonSerializer<?> ser, BeanProperty property) throws JsonMappingException { [EOL]     if (ser instanceof ContextualSerializer) { [EOL]         ser = ((ContextualSerializer) ser).createContextual(this, property); [EOL]     } [EOL]     return (JsonSerializer<Object>) ser; [EOL] }
@SuppressWarnings("unchecked") [EOL] protected JsonSerializer<Object> _handleContextual(JsonSerializer<?> ser, BeanProperty property) throws JsonMappingException { [EOL]     if (ser instanceof ContextualSerializer) { [EOL]         ser = ((ContextualSerializer) ser).createContextual(this, property); [EOL]     } [EOL]     return (JsonSerializer<Object>) ser; [EOL] }
