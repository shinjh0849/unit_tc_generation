public void testJacksonAnnotationIntrospectorCreation() { [EOL] JacksonAnnotationIntrospector introspector = new JacksonAnnotationIntrospector(); [EOL] assertNotNull(introspector); [EOL] }
public void testFindRootNameWithNoAnnotation() { [EOL] AnnotatedClass ac = mock(AnnotatedClass.class); [EOL] when(ac.getAnnotation(JsonRootName.class)).thenReturn(null); [EOL] PropertyName result = findRootName(ac); [EOL] assertNull(result); [EOL] }
public void testFindRootNameWithAnnotation() { [EOL] AnnotatedClass ac = mock(AnnotatedClass.class); [EOL] JsonRootName jsonRootName = mock(JsonRootName.class); [EOL] when(ac.getAnnotation(JsonRootName.class)).thenReturn(jsonRootName); [EOL] when(jsonRootName.value()).thenReturn("TestRoot"); [EOL] PropertyName result = findRootName(ac); [EOL] assertNotNull(result); [EOL] assertEquals("TestRoot", result.getSimpleName()); [EOL] }
public void testFindFilterIdWithNonNullAnnotationAndNonEmptyId() { [EOL] AnnotatedClass ac = mock(AnnotatedClass.class); [EOL] JsonFilter jsonFilter = mock(JsonFilter.class); [EOL] when(ac.getAnnotation(JsonFilter.class)).thenReturn(jsonFilter); [EOL] when(jsonFilter.value()).thenReturn("filterId"); [EOL] Object result = findFilterId(ac); [EOL] assertNotNull(result); [EOL] assertEquals("filterId", result); [EOL] }
public void testFindFilterIdWithNonNullAnnotationAndEmptyId() { [EOL] AnnotatedClass ac = mock(AnnotatedClass.class); [EOL] JsonFilter jsonFilter = mock(JsonFilter.class); [EOL] when(ac.getAnnotation(JsonFilter.class)).thenReturn(jsonFilter); [EOL] when(jsonFilter.value()).thenReturn(""); [EOL] Object result = findFilterId(ac); [EOL] assertNull(result); [EOL] }
public void testFindFilterIdWithNullAnnotation() { [EOL] AnnotatedClass ac = mock(AnnotatedClass.class); [EOL] when(ac.getAnnotation(JsonFilter.class)).thenReturn(null); [EOL] Object result = findFilterId(ac); [EOL] assertNull(result); [EOL] }
public void testFindNamingStrategyWithNoAnnotation() { [EOL] AnnotatedClass ac = mock(AnnotatedClass.class); [EOL] when(ac.getAnnotation(JsonNaming.class)).thenReturn(null); [EOL] Object result = findNamingStrategy(ac); [EOL] assertNull(result); [EOL] }
public void testFindNamingStrategyWithAnnotation() { [EOL] AnnotatedClass ac = mock(AnnotatedClass.class); [EOL] JsonNaming namingAnnotation = mock(JsonNaming.class); [EOL] when(ac.getAnnotation(JsonNaming.class)).thenReturn(namingAnnotation); [EOL] when(namingAnnotation.value()).thenReturn(SomeNamingStrategy.class); [EOL] Object result = findNamingStrategy(ac); [EOL] assertEquals(SomeNamingStrategy.class, result); [EOL] }
public void testFindAutoDetectVisibilityWithNoAnnotation() { [EOL] AnnotatedClass ac = createAnnotatedClassWithoutAnnotation(); [EOL] VisibilityChecker<?> checker = createVisibilityChecker(); [EOL] VisibilityChecker<?> result = findAutoDetectVisibility(ac, checker); [EOL] assertSame("Expected the original checker to be returned when no annotation is present", checker, result); [EOL] } [EOL] public void testFindAutoDetectVisibilityWithAnnotation() { [EOL] AnnotatedClass ac = createAnnotatedClassWithJsonAutoDetectAnnotation(); [EOL] VisibilityChecker<?> checker = createVisibilityChecker(); [EOL] JsonAutoDetect ann = ac.getAnnotation(JsonAutoDetect.class); [EOL] VisibilityChecker<?> result = findAutoDetectVisibility(ac, checker); [EOL] assertNotNull("Expected a non-null VisibilityChecker when annotation is present", result); [EOL] assertNotSame("Expected a different VisibilityChecker when annotation is present", checker, result); [EOL] assertEquals("Expected the VisibilityChecker to be updated with the annotation", checker.with(ann), result); [EOL] }

public void testHasIgnoreMarkerWithIgnorableMember() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] AnnotationIntrospector introspector = mapper.getSerializationConfig().getAnnotationIntrospector(); [EOL] AnnotatedMember member = mock(AnnotatedMember.class); [EOL] when(member.hasAnnotation(JsonIgnore.class)).thenReturn(true); [EOL] boolean result = introspector.hasIgnoreMarker(member); [EOL] assertTrue(result); [EOL] }
public void testHasIgnoreMarkerWithNonIgnorableMember() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] AnnotationIntrospector introspector = mapper.getSerializationConfig().getAnnotationIntrospector(); [EOL] AnnotatedMember member = mock(AnnotatedMember.class); [EOL] when(member.hasAnnotation(JsonIgnore.class)).thenReturn(false); [EOL] boolean result = introspector.hasIgnoreMarker(member); [EOL] assertFalse(result); [EOL] }
public void testFindInjectableValueIdWithNoAnnotation() { [EOL] AnnotatedMember m = mock(AnnotatedMember.class); [EOL] when(m.getAnnotation(JacksonInject.class)).thenReturn(null); [EOL] Object result = findInjectableValueId(m); [EOL] assertNull(result); [EOL] }
public void testFindInjectableValueIdWithEmptyId() { [EOL] AnnotatedMember m = mock(AnnotatedMember.class); [EOL] JacksonInject ann = mock(JacksonInject.class); [EOL] when(m.getAnnotation(JacksonInject.class)).thenReturn(ann); [EOL] when(ann.value()).thenReturn(""); [EOL] when(m.getRawType()).thenReturn((Class) String.class); [EOL] Object result = findInjectableValueId(m); [EOL] assertEquals(String.class.getName(), result); [EOL] }
public void testFindInjectableValueIdWithEmptyIdAndAnnotatedMethod() { [EOL] AnnotatedMethod m = mock(AnnotatedMethod.class); [EOL] JacksonInject ann = mock(JacksonInject.class); [EOL] when(m.getAnnotation(JacksonInject.class)).thenReturn(ann); [EOL] when(ann.value()).thenReturn(""); [EOL] when(m.getParameterCount()).thenReturn(1); [EOL] when(m.getRawParameterType(0)).thenReturn((Class) String.class); [EOL] Object result = findInjectableValueId(m); [EOL] assertEquals(String.class.getName(), result); [EOL] }
public void testFindInjectableValueIdWithNonEmptyId() { [EOL] AnnotatedMember m = mock(AnnotatedMember.class); [EOL] JacksonInject ann = mock(JacksonInject.class); [EOL] when(m.getAnnotation(JacksonInject.class)).thenReturn(ann); [EOL] when(ann.value()).thenReturn("customId"); [EOL] Object result = findInjectableValueId(m); [EOL] assertEquals("customId", result); [EOL] }
public void testFindTypeResolverWithNullConfig() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(mapper.getDeserializationConfig(), Object.class); [EOL] JavaType baseType = mapper.constructType(Object.class); [EOL] TypeResolverBuilder<?> result = mapper.getSerializationConfig().introspectClassAnnotations(baseType).findTypeResolver(null, ac, baseType); [EOL] assertNull(result); [EOL] }
public void testFindTypeResolverWithNonNullConfig() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(mapper.getDeserializationConfig(), Object.class); [EOL] JavaType baseType = mapper.constructType(Object.class); [EOL] MapperConfig<?> config = mapper.getSerializationConfig(); [EOL] TypeResolverBuilder<?> result = config.introspectClassAnnotations(baseType).findTypeResolver(config, ac, baseType); [EOL] assertNotNull(result); [EOL] }
public void testFindSerializerWithJsonSerializeUsingNonNull() { [EOL] Annotated annotated = mock(Annotated.class); [EOL] JsonSerialize jsonSerialize = mock(JsonSerialize.class); [EOL] when(annotated.getAnnotation(JsonSerialize.class)).thenReturn(jsonSerialize); [EOL] when(jsonSerialize.using()).thenReturn((Class)CustomSerializer.class); [EOL] Object result = findSerializer(annotated); [EOL] assertNotNull(result); [EOL] assertEquals(CustomSerializer.class, result); [EOL] }
public void testFindSerializerWithJsonSerializeUsingNone() { [EOL] Annotated annotated = mock(Annotated.class); [EOL] JsonSerialize jsonSerialize = mock(JsonSerialize.class); [EOL] when(annotated.getAnnotation(JsonSerialize.class)).thenReturn(jsonSerialize); [EOL] when(jsonSerialize.using()).thenReturn((Class)JsonSerializer.None.class); [EOL] Object result = findSerializer(annotated); [EOL] assertNull(result); [EOL] }
public void testFindSerializerWithJsonRawValueTrue() { [EOL] Annotated annotated = mock(Annotated.class); [EOL] JsonRawValue jsonRawValue = mock(JsonRawValue.class); [EOL] when(annotated.getAnnotation(JsonSerialize.class)).thenReturn(null); [EOL] when(annotated.getAnnotation(JsonRawValue.class)).thenReturn(jsonRawValue); [EOL] when(jsonRawValue.value()).thenReturn(true); [EOL] when(annotated.getRawType()).thenReturn((Class)Object.class); [EOL] Object result = findSerializer(annotated); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof RawSerializer); [EOL] }
public void testFindSerializerWithNoRelevantAnnotations() { [EOL] Annotated annotated = mock(Annotated.class); [EOL] when(annotated.getAnnotation(JsonSerialize.class)).thenReturn(null); [EOL] when(annotated.getAnnotation(JsonRawValue.class)).thenReturn(null); [EOL] Object result = findSerializer(annotated); [EOL] assertNull(result); [EOL] }
public void testFindSerializationInclusionWithJsonInclude() { [EOL] Annotated annotated = mock(Annotated.class); [EOL] when(annotated.getAnnotation(JsonInclude.class)).thenReturn(JsonInclude.Include.ALWAYS); [EOL] JsonInclude.Include result = findSerializationInclusion(annotated, JsonInclude.Include.USE_DEFAULTS); [EOL] assertEquals(JsonInclude.Include.ALWAYS, result); [EOL] }
public void testFindSerializationInclusionWithJsonSerializeAlways() { [EOL] Annotated annotated = mock(Annotated.class); [EOL] when(annotated.getAnnotation(JsonInclude.class)).thenReturn(null); [EOL] JsonSerialize jsonSerialize = mock(JsonSerialize.class); [EOL] when(annotated.getAnnotation(JsonSerialize.class)).thenReturn(jsonSerialize); [EOL] when(jsonSerialize.include()).thenReturn(JsonSerialize.Inclusion.ALWAYS); [EOL] JsonInclude.Include result = findSerializationInclusion(annotated, JsonInclude.Include.USE_DEFAULTS); [EOL] assertEquals(JsonInclude.Include.ALWAYS, result); [EOL] }
public void testFindSerializationInclusionWithJsonSerializeNonNull() { [EOL] Annotated annotated = mock(Annotated.class); [EOL] when(annotated.getAnnotation(JsonInclude.class)).thenReturn(null); [EOL] JsonSerialize jsonSerialize = mock(JsonSerialize.class); [EOL] when(annotated.getAnnotation(JsonSerialize.class)).thenReturn(jsonSerialize); [EOL] when(jsonSerialize.include()).thenReturn(JsonSerialize.Inclusion.NON_NULL); [EOL] JsonInclude.Include result = findSerializationInclusion(annotated, JsonInclude.Include.USE_DEFAULTS); [EOL] assertEquals(JsonInclude.Include.NON_NULL, result); [EOL] }
public void testFindSerializationInclusionWithJsonSerializeNonDefault() { [EOL] Annotated annotated = mock(Annotated.class); [EOL] when(annotated.getAnnotation(JsonInclude.class)).thenReturn(null); [EOL] JsonSerialize jsonSerialize = mock(JsonSerialize.class); [EOL] when(annotated.getAnnotation(JsonSerialize.class)).thenReturn(jsonSerialize); [EOL] when(jsonSerialize.include()).thenReturn(JsonSerialize.Inclusion.NON_DEFAULT); [EOL] JsonInclude.Include result = findSerializationInclusion(annotated, JsonInclude.Include.USE_DEFAULTS); [EOL] assertEquals(JsonInclude.Include.NON_DEFAULT, result); [EOL] }
public void testFindSerializationInclusionWithJsonSerializeNonEmpty() { [EOL] Annotated annotated = mock(Annotated.class); [EOL] when(annotated.getAnnotation(JsonInclude.class)).thenReturn(null); [EOL] JsonSerialize jsonSerialize = mock(JsonSerialize.class); [EOL] when(annotated.getAnnotation(JsonSerialize.class)).thenReturn(jsonSerialize); [EOL] when(jsonSerialize.include()).thenReturn(JsonSerialize.Inclusion.NON_EMPTY); [EOL] JsonInclude.Include result = findSerializationInclusion(annotated, JsonInclude.Include.USE_DEFAULTS); [EOL] assertEquals(JsonInclude.Include.NON_EMPTY, result); [EOL] }
public void testFindSerializationInclusionWithDefault() { [EOL] Annotated annotated = mock(Annotated.class); [EOL] when(annotated.getAnnotation(JsonInclude.class)).thenReturn(null); [EOL] when(annotated.getAnnotation(JsonSerialize.class)).thenReturn(null); [EOL] JsonInclude.Include result = findSerializationInclusion(annotated, JsonInclude.Include.USE_DEFAULTS); [EOL] assertEquals(JsonInclude.Include.USE_DEFAULTS, result); [EOL] }
public void testFindSerializationTypeWithAnnotationPresentAndAsNotNoClass() { [EOL] Annotated am = mock(Annotated.class); [EOL] JsonSerialize ann = mock(JsonSerialize.class); [EOL] when(am.getAnnotation(JsonSerialize.class)).thenReturn(ann); [EOL] when(ann.as()).thenReturn(SomeClass.class); [EOL] Class<?> result = findSerializationType(am); [EOL] assertNotNull(result); [EOL] assertEquals(SomeClass.class, result); [EOL] }
public void testFindSerializationTypeWithAnnotationPresentAndAsNoClass() { [EOL] Annotated am = mock(Annotated.class); [EOL] JsonSerialize ann = mock(JsonSerialize.class); [EOL] when(am.getAnnotation(JsonSerialize.class)).thenReturn(ann); [EOL] when(ann.as()).thenReturn(NoClass.class); [EOL] Class<?> result = findSerializationType(am); [EOL] assertNull(result); [EOL] }
public void testFindSerializationTypeWithNoAnnotationPresent() { [EOL] Annotated am = mock(Annotated.class); [EOL] when(am.getAnnotation(JsonSerialize.class)).thenReturn(null); [EOL] Class<?> result = findSerializationType(am); [EOL] assertNull(result); [EOL] }
public void testFindSerializationConverterWithAnnotationPresentAndConverterSet() { [EOL] Annotated annotated = mock(Annotated.class); [EOL] JsonSerialize jsonSerialize = mock(JsonSerialize.class); [EOL] when(annotated.getAnnotation(JsonSerialize.class)).thenReturn(jsonSerialize); [EOL] when(jsonSerialize.converter()).thenReturn(TestConverter.class); [EOL] Object result = findSerializationConverter(annotated); [EOL] assertNotNull(result); [EOL] assertEquals(TestConverter.class, result); [EOL] }
public void testFindSerializationConverterWithAnnotationPresentAndConverterNotSet() { [EOL] Annotated annotated = mock(Annotated.class); [EOL] JsonSerialize jsonSerialize = mock(JsonSerialize.class); [EOL] when(annotated.getAnnotation(JsonSerialize.class)).thenReturn(jsonSerialize); [EOL] when(jsonSerialize.converter()).thenReturn(Converter.None.class); [EOL] Object result = findSerializationConverter(annotated); [EOL] assertNull(result); [EOL] }
public void testFindSerializationConverterWithAnnotationNotPresent() { [EOL] Annotated annotated = mock(Annotated.class); [EOL] when(annotated.getAnnotation(JsonSerialize.class)).thenReturn(null); [EOL] Object result = findSerializationConverter(annotated); [EOL] assertNull(result); [EOL] }
public void testFindObjectIdInfoWithNoAnnotation() { [EOL] Annotated ann = mock(Annotated.class); [EOL] when(ann.getAnnotation(JsonIdentityInfo.class)).thenReturn(null); [EOL] ObjectIdResolver resolver = new SimpleObjectIdResolver(); [EOL] ObjectIdInfo result = resolver.findObjectIdInfo(ann); [EOL] assertNull(result); [EOL] }
public void testFindObjectIdInfoWithNoneGenerator() { [EOL] JsonIdentityInfo info = mock(JsonIdentityInfo.class); [EOL] when(info.generator()).thenReturn(ObjectIdGenerators.None.class); [EOL] Annotated ann = mock(Annotated.class); [EOL] when(ann.getAnnotation(JsonIdentityInfo.class)).thenReturn(info); [EOL] ObjectIdResolver resolver = new SimpleObjectIdResolver(); [EOL] ObjectIdInfo result = resolver.findObjectIdInfo(ann); [EOL] assertNull(result); [EOL] }
public void testFindObjectIdInfoWithValidAnnotation() { [EOL] JsonIdentityInfo info = mock(JsonIdentityInfo.class); [EOL] when(info.generator()).thenReturn(ObjectIdGenerators.PropertyGenerator.class); [EOL] when(info.property()).thenReturn("id"); [EOL] when(info.scope()).thenReturn(Object.class); [EOL] Annotated ann = mock(Annotated.class); [EOL] when(ann.getAnnotation(JsonIdentityInfo.class)).thenReturn(info); [EOL] ObjectIdResolver resolver = new SimpleObjectIdResolver(); [EOL] ObjectIdInfo result = resolver.findObjectIdInfo(ann); [EOL] assertNotNull(result); [EOL] assertEquals("id", result.getPropertyName()); [EOL] assertEquals(Object.class, result.getScope()); [EOL] assertEquals(ObjectIdGenerators.PropertyGenerator.class, result.getGeneratorType()); [EOL] }
public void testFindFormatWithNoAnnotation() { [EOL] Annotated annotated = Mockito.mock(Annotated.class); [EOL] Mockito.when(annotated.getAnnotation(JsonFormat.class)).thenReturn(null); [EOL] JsonFormat.Value result = findFormat(annotated); [EOL] assertNull(result); [EOL] }
public void testFindFormatWithAnnotation() { [EOL] Annotated annotated = Mockito.mock(Annotated.class); [EOL] JsonFormat jsonFormat = Mockito.mock(JsonFormat.class); [EOL] Mockito.when(annotated.getAnnotation(JsonFormat.class)).thenReturn(jsonFormat); [EOL] JsonFormat.Value result = findFormat(annotated); [EOL] assertNotNull(result); [EOL] assertEquals(jsonFormat, result.getAnnotation()); [EOL] }
public void testFindSerializationPropertyOrderWithNoAnnotation() { [EOL] AnnotatedClass ac = mock(AnnotatedClass.class); [EOL] when(ac.getAnnotation(JsonPropertyOrder.class)).thenReturn(null); [EOL] String[] result = findSerializationPropertyOrder(ac); [EOL] assertNull(result); [EOL] }
public void testFindSerializationPropertyOrderWithAnnotation() { [EOL] AnnotatedClass ac = mock(AnnotatedClass.class); [EOL] JsonPropertyOrder order = mock(JsonPropertyOrder.class); [EOL] String[] propertiesOrder = new String[]{"prop1", "prop2"}; [EOL] when(ac.getAnnotation(JsonPropertyOrder.class)).thenReturn(order); [EOL] when(order.value()).thenReturn(propertiesOrder); [EOL] String[] result = findSerializationPropertyOrder(ac); [EOL] assertArrayEquals(propertiesOrder, result); [EOL] }
public void testFindSerializationSortAlphabeticallyWithNoAnnotation() { [EOL] AnnotatedClass ac = mock(AnnotatedClass.class); [EOL] when(ac.getAnnotation(JsonPropertyOrder.class)).thenReturn(null); [EOL] Boolean result = findSerializationSortAlphabetically(ac); [EOL] assertNull(result); [EOL] }
public void testFindSerializationSortAlphabeticallyWithAnnotationTrue() { [EOL] AnnotatedClass ac = mock(AnnotatedClass.class); [EOL] JsonPropertyOrder order = mock(JsonPropertyOrder.class); [EOL] when(ac.getAnnotation(JsonPropertyOrder.class)).thenReturn(order); [EOL] when(order.alphabetic()).thenReturn(true); [EOL] Boolean result = findSerializationSortAlphabetically(ac); [EOL] assertTrue(result); [EOL] }
public void testFindSerializationSortAlphabeticallyWithAnnotationFalse() { [EOL] AnnotatedClass ac = mock(AnnotatedClass.class); [EOL] JsonPropertyOrder order = mock(JsonPropertyOrder.class); [EOL] when(ac.getAnnotation(JsonPropertyOrder.class)).thenReturn(order); [EOL] when(order.alphabetic()).thenReturn(false); [EOL] Boolean result = findSerializationSortAlphabetically(ac); [EOL] assertFalse(result); [EOL] }
public void testFindNameForSerializationWithAnnotatedField() { [EOL] AnnotatedField annotatedField = createAnnotatedFieldWithName("fieldName"); [EOL] PropertyName result = findNameForSerialization(annotatedField); [EOL] assertNotNull(result); [EOL] assertEquals("fieldName", result.getSimpleName()); [EOL] }
public void testFindNameForSerializationWithAnnotatedMethod() { [EOL] AnnotatedMethod annotatedMethod = createAnnotatedMethodWithName("methodName"); [EOL] PropertyName result = findNameForSerialization(annotatedMethod); [EOL] assertNotNull(result); [EOL] assertEquals("methodName", result.getSimpleName()); [EOL] }
public void testFindNameForSerializationWithEmptyName() { [EOL] AnnotatedField annotatedField = createAnnotatedFieldWithName(""); [EOL] PropertyName result = findNameForSerialization(annotatedField); [EOL] assertSame(PropertyName.USE_DEFAULT, result); [EOL] }
public void testFindNameForSerializationWithNullAnnotated() { [EOL] Annotated notAnnotated = createNotAnnotated(); [EOL] PropertyName result = findNameForSerialization(notAnnotated); [EOL] assertNull(result); [EOL] }
public void testFindSerializationNameWithJsonProperty() { [EOL] AnnotatedField af = mock(AnnotatedField.class); [EOL] JsonProperty pann = mock(JsonProperty.class); [EOL] when(af.getAnnotation(JsonProperty.class)).thenReturn(pann); [EOL] when(pann.value()).thenReturn("testName"); [EOL] String result = findSerializationName(af); [EOL] assertEquals("testName", result); [EOL] }
public void testFindSerializationNameWithJsonSerialize() { [EOL] AnnotatedField af = mock(AnnotatedField.class); [EOL] when(af.getAnnotation(JsonProperty.class)).thenReturn(null); [EOL] when(af.hasAnnotation(JsonSerialize.class)).thenReturn(true); [EOL] String result = findSerializationName(af); [EOL] assertEquals("", result); [EOL] }
public void testFindSerializationNameWithJsonView() { [EOL] AnnotatedField af = mock(AnnotatedField.class); [EOL] when(af.getAnnotation(JsonProperty.class)).thenReturn(null); [EOL] when(af.hasAnnotation(JsonSerialize.class)).thenReturn(false); [EOL] when(af.hasAnnotation(JsonView.class)).thenReturn(true); [EOL] String result = findSerializationName(af); [EOL] assertEquals("", result); [EOL] }
public void testFindSerializationNameWithNoAnnotations() { [EOL] AnnotatedField af = mock(AnnotatedField.class); [EOL] when(af.getAnnotation(JsonProperty.class)).thenReturn(null); [EOL] when(af.hasAnnotation(JsonSerialize.class)).thenReturn(false); [EOL] when(af.hasAnnotation(JsonView.class)).thenReturn(false); [EOL] String result = findSerializationName(af); [EOL] assertNull(result); [EOL] }
public void testFindSerializationNameWithJsonGetter() { [EOL] AnnotatedMethod am = createAnnotatedMethodWithJsonGetterAnnotation("customName"); [EOL] String result = findSerializationName(am); [EOL] assertEquals("customName", result); [EOL] } [EOL] public void testFindSerializationNameWithJsonProperty() { [EOL] AnnotatedMethod am = createAnnotatedMethodWithJsonPropertyAnnotation("propertyName"); [EOL] String result = findSerializationName(am); [EOL] assertEquals("propertyName", result); [EOL] } [EOL] public void testFindSerializationNameWithJsonSerialize() { [EOL] AnnotatedMethod am = createAnnotatedMethodWithJsonSerializeAnnotation(); [EOL] String result = findSerializationName(am); [EOL] assertEquals("", result); [EOL] } [EOL] public void testFindSerializationNameWithJsonView() { [EOL] AnnotatedMethod am = createAnnotatedMethodWithJsonViewAnnotation(); [EOL] String result = findSerializationName(am); [EOL] assertEquals("", result); [EOL] } [EOL] public void testFindSerializationNameWithNoRelevantAnnotations() { [EOL] AnnotatedMethod am = createAnnotatedMethodWithNoRelevantAnnotations(); [EOL] String result = findSerializationName(am); [EOL] assertNull(result); [EOL] }

public void testHasAsValueAnnotationWithValueTrue() { [EOL] AnnotatedMethod am = mock(AnnotatedMethod.class); [EOL] JsonValue jsonValue = mock(JsonValue.class); [EOL] when(am.getAnnotation(JsonValue.class)).thenReturn(jsonValue); [EOL] when(jsonValue.value()).thenReturn(true); [EOL] boolean result = hasAsValueAnnotation(am); [EOL] assertTrue(result); [EOL] }
public void testHasAsValueAnnotationWithValueFalse() { [EOL] AnnotatedMethod am = mock(AnnotatedMethod.class); [EOL] JsonValue jsonValue = mock(JsonValue.class); [EOL] when(am.getAnnotation(JsonValue.class)).thenReturn(jsonValue); [EOL] when(jsonValue.value()).thenReturn(false); [EOL] boolean result = hasAsValueAnnotation(am); [EOL] assertFalse(result); [EOL] }
public void testHasAsValueAnnotationWithNoAnnotation() { [EOL] AnnotatedMethod am = mock(AnnotatedMethod.class); [EOL] when(am.getAnnotation(JsonValue.class)).thenReturn(null); [EOL] boolean result = hasAsValueAnnotation(am); [EOL] assertFalse(result); [EOL] }
public void testFindDeserializerWithNonNullAnnotationAndValidDeserializer() { [EOL] Annotated annotated = mock(Annotated.class); [EOL] JsonDeserialize jsonDeserialize = mock(JsonDeserialize.class); [EOL] when(annotated.getAnnotation(JsonDeserialize.class)).thenReturn(jsonDeserialize); [EOL] when(jsonDeserialize.using()).thenReturn((Class)CustomDeserializer.class); [EOL] Class<? extends JsonDeserializer<?>> result = findDeserializer(annotated); [EOL] assertNotNull(result); [EOL] assertEquals(CustomDeserializer.class, result); [EOL] }
public void testFindDeserializerWithNonNullAnnotationAndNoneDeserializer() { [EOL] Annotated annotated = mock(Annotated.class); [EOL] JsonDeserialize jsonDeserialize = mock(JsonDeserialize.class); [EOL] when(annotated.getAnnotation(JsonDeserialize.class)).thenReturn(jsonDeserialize); [EOL] when(jsonDeserialize.using()).thenReturn(JsonDeserializer.None.class); [EOL] Class<? extends JsonDeserializer<?>> result = findDeserializer(annotated); [EOL] assertNull(result); [EOL] }
public void testFindDeserializerWithNullAnnotation() { [EOL] Annotated annotated = mock(Annotated.class); [EOL] when(annotated.getAnnotation(JsonDeserialize.class)).thenReturn(null); [EOL] Class<? extends JsonDeserializer<?>> result = findDeserializer(annotated); [EOL] assertNull(result); [EOL] }
public void testFindKeyDeserializerWithNonNullAnnotationAndValidKeyDeserializer() { [EOL] Annotated annotated = mock(Annotated.class); [EOL] JsonDeserialize jsonDeserialize = mock(JsonDeserialize.class); [EOL] when(annotated.getAnnotation(JsonDeserialize.class)).thenReturn(jsonDeserialize); [EOL] when(jsonDeserialize.keyUsing()).thenReturn((Class)SomeKeyDeserializer.class); [EOL] Class<? extends KeyDeserializer> result = findKeyDeserializer(annotated); [EOL] assertNotNull(result); [EOL] assertEquals(SomeKeyDeserializer.class, result); [EOL] }
public void testFindKeyDeserializerWithNonNullAnnotationAndNoneKeyDeserializer() { [EOL] Annotated annotated = mock(Annotated.class); [EOL] JsonDeserialize jsonDeserialize = mock(JsonDeserialize.class); [EOL] when(annotated.getAnnotation(JsonDeserialize.class)).thenReturn(jsonDeserialize); [EOL] when(jsonDeserialize.keyUsing()).thenReturn((Class)KeyDeserializer.None.class); [EOL] Class<? extends KeyDeserializer> result = findKeyDeserializer(annotated); [EOL] assertNull(result); [EOL] }
public void testFindKeyDeserializerWithNullAnnotation() { [EOL] Annotated annotated = mock(Annotated.class); [EOL] when(annotated.getAnnotation(JsonDeserialize.class)).thenReturn(null); [EOL] Class<? extends KeyDeserializer> result = findKeyDeserializer(annotated); [EOL] assertNull(result); [EOL] }
public void testFindDeserializationTypeWithNonNullAnnotationAndValidClass() { [EOL] Annotated am = mock(Annotated.class); [EOL] JavaType baseType = mock(JavaType.class); [EOL] JsonDeserialize ann = mock(JsonDeserialize.class); [EOL] when(am.getAnnotation(JsonDeserialize.class)).thenReturn(ann); [EOL] when(ann.as()).thenReturn(String.class); [EOL] Class<?> result = findDeserializationType(am, baseType); [EOL] assertNotNull(result); [EOL] assertEquals(String.class, result); [EOL] }
public void testFindDeserializationTypeWithNonNullAnnotationAndNoClass() { [EOL] Annotated am = mock(Annotated.class); [EOL] JavaType baseType = mock(JavaType.class); [EOL] JsonDeserialize ann = mock(JsonDeserialize.class); [EOL] when(am.getAnnotation(JsonDeserialize.class)).thenReturn(ann); [EOL] when(ann.as()).thenReturn(NoClass.class); [EOL] Class<?> result = findDeserializationType(am, baseType); [EOL] assertNull(result); [EOL] }
public void testFindDeserializationTypeWithNullAnnotation() { [EOL] Annotated am = mock(Annotated.class); [EOL] JavaType baseType = mock(JavaType.class); [EOL] when(am.getAnnotation(JsonDeserialize.class)).thenReturn(null); [EOL] Class<?> result = findDeserializationType(am, baseType); [EOL] assertNull(result); [EOL] }
public void testFindDeserializationConverterWithNonNullConverter() { [EOL] Annotated annotated = createAnnotatedWithDeserializeAnnotation(ConverterClass.class); [EOL] Object result = findDeserializationConverter(annotated); [EOL] assertNotNull(result); [EOL] assertEquals(ConverterClass.class, result); [EOL] } [EOL] public void testFindDeserializationConverterWithNoneConverter() { [EOL] Annotated annotated = createAnnotatedWithDeserializeAnnotation(Converter.None.class); [EOL] Object result = findDeserializationConverter(annotated); [EOL] assertNull(result); [EOL] } [EOL] public void testFindDeserializationConverterWithNoAnnotation() { [EOL] Annotated annotated = createAnnotatedWithoutDeserializeAnnotation(); [EOL] Object result = findDeserializationConverter(annotated); [EOL] assertNull(result); [EOL] }

public void testFindPOJOBuilderWithNoAnnotation() { [EOL] AnnotatedClass ac = mock(AnnotatedClass.class); [EOL] when(ac.getAnnotation(JsonDeserialize.class)).thenReturn(null); [EOL] assertNull(findPOJOBuilder(ac)); [EOL] }
public void testFindPOJOBuilderWithNoClass() { [EOL] AnnotatedClass ac = mock(AnnotatedClass.class); [EOL] JsonDeserialize ann = mock(JsonDeserialize.class); [EOL] when(ac.getAnnotation(JsonDeserialize.class)).thenReturn(ann); [EOL] when(ann.builder()).thenReturn(NoClass.class); [EOL] assertNull(findPOJOBuilder(ac)); [EOL] }
public void testFindPOJOBuilderWithValidClass() { [EOL] AnnotatedClass ac = mock(AnnotatedClass.class); [EOL] JsonDeserialize ann = mock(JsonDeserialize.class); [EOL] when(ac.getAnnotation(JsonDeserialize.class)).thenReturn(ann); [EOL] when(ann.builder()).thenReturn(SomeClass.class); [EOL] assertEquals(SomeClass.class, findPOJOBuilder(ac)); [EOL] }
public void testFindNameForDeserializationWithAnnotatedField() { [EOL] AnnotatedField annotatedField = mock(AnnotatedField.class); [EOL] when(findDeserializationName(annotatedField)).thenReturn("fieldName"); [EOL] PropertyName result = findNameForDeserialization(annotatedField); [EOL] assertNotNull(result); [EOL] assertEquals("fieldName", result.getSimpleName()); [EOL] }
public void testFindNameForDeserializationWithAnnotatedMethod() { [EOL] AnnotatedMethod annotatedMethod = mock(AnnotatedMethod.class); [EOL] when(findDeserializationName(annotatedMethod)).thenReturn("methodName"); [EOL] PropertyName result = findNameForDeserialization(annotatedMethod); [EOL] assertNotNull(result); [EOL] assertEquals("methodName", result.getSimpleName()); [EOL] }
public void testFindNameForDeserializationWithAnnotatedParameter() { [EOL] AnnotatedParameter annotatedParameter = mock(AnnotatedParameter.class); [EOL] when(findDeserializationName(annotatedParameter)).thenReturn("paramName"); [EOL] PropertyName result = findNameForDeserialization(annotatedParameter); [EOL] assertNotNull(result); [EOL] assertEquals("paramName", result.getSimpleName()); [EOL] }
public void testFindNameForDeserializationWithEmptyName() { [EOL] AnnotatedField annotatedField = mock(AnnotatedField.class); [EOL] when(findDeserializationName(annotatedField)).thenReturn(""); [EOL] PropertyName result = findNameForDeserialization(annotatedField); [EOL] assertSame(PropertyName.USE_DEFAULT, result); [EOL] }
public void testFindNameForDeserializationWithNull() { [EOL] Annotated notAnnotated = mock(Annotated.class); [EOL] PropertyName result = findNameForDeserialization(notAnnotated); [EOL] assertNull(result); [EOL] }
public void testFindDeserializationNameWithJsonSetter() { [EOL] AnnotatedMethod am = mock(AnnotatedMethod.class); [EOL] JsonSetter jsonSetter = mock(JsonSetter.class); [EOL] when(am.getAnnotation(JsonSetter.class)).thenReturn(jsonSetter); [EOL] when(jsonSetter.value()).thenReturn("setterValue"); [EOL] String result = findDeserializationName(am); [EOL] assertEquals("setterValue", result); [EOL] }
public void testFindDeserializationNameWithJsonProperty() { [EOL] AnnotatedMethod am = mock(AnnotatedMethod.class); [EOL] when(am.getAnnotation(JsonSetter.class)).thenReturn(null); [EOL] JsonProperty jsonProperty = mock(JsonProperty.class); [EOL] when(am.getAnnotation(JsonProperty.class)).thenReturn(jsonProperty); [EOL] when(jsonProperty.value()).thenReturn("propertyValue"); [EOL] String result = findDeserializationName(am); [EOL] assertEquals("propertyValue", result); [EOL] }
public void testFindDeserializationNameWithOtherAnnotations() { [EOL] AnnotatedMethod am = mock(AnnotatedMethod.class); [EOL] when(am.getAnnotation(JsonSetter.class)).thenReturn(null); [EOL] when(am.getAnnotation(JsonProperty.class)).thenReturn(null); [EOL] when(am.hasAnnotation(JsonDeserialize.class)).thenReturn(true); [EOL] String result = findDeserializationName(am); [EOL] assertEquals("", result); [EOL] }
public void testFindDeserializationNameWithNoAnnotations() { [EOL] AnnotatedMethod am = mock(AnnotatedMethod.class); [EOL] when(am.getAnnotation(JsonSetter.class)).thenReturn(null); [EOL] when(am.getAnnotation(JsonProperty.class)).thenReturn(null); [EOL] when(am.hasAnnotation(JsonDeserialize.class)).thenReturn(false); [EOL] when(am.hasAnnotation(JsonView.class)).thenReturn(false); [EOL] when(am.hasAnnotation(JsonBackReference.class)).thenReturn(false); [EOL] when(am.hasAnnotation(JsonManagedReference.class)).thenReturn(false); [EOL] String result = findDeserializationName(am); [EOL] assertNull(result); [EOL] }
public void testFindDeserializationNameWithJsonProperty() { [EOL] AnnotatedField af = mock(AnnotatedField.class); [EOL] JsonProperty pann = mock(JsonProperty.class); [EOL] when(af.getAnnotation(JsonProperty.class)).thenReturn(pann); [EOL] when(pann.value()).thenReturn("testName"); [EOL] String result = findDeserializationName(af); [EOL] assertEquals("testName", result); [EOL] }
public void testFindDeserializationNameWithOtherAnnotations() { [EOL] AnnotatedField af = mock(AnnotatedField.class); [EOL] when(af.getAnnotation(JsonProperty.class)).thenReturn(null); [EOL] when(af.hasAnnotation(JsonDeserialize.class)).thenReturn(true); [EOL] String result = findDeserializationName(af); [EOL] assertEquals("", result); [EOL] }
public void testFindDeserializationNameWithNoAnnotations() { [EOL] AnnotatedField af = mock(AnnotatedField.class); [EOL] when(af.getAnnotation(JsonProperty.class)).thenReturn(null); [EOL] when(af.hasAnnotation(JsonDeserialize.class)).thenReturn(false); [EOL] when(af.hasAnnotation(JsonView.class)).thenReturn(false); [EOL] when(af.hasAnnotation(JsonBackReference.class)).thenReturn(false); [EOL] when(af.hasAnnotation(JsonManagedReference.class)).thenReturn(false); [EOL] String result = findDeserializationName(af); [EOL] assertNull(result); [EOL] }
public void testFindDeserializationNameWithNonNullParamAndNonNullAnnotation() { [EOL] AnnotatedParameter param = Mockito.mock(AnnotatedParameter.class); [EOL] JsonProperty pann = Mockito.mock(JsonProperty.class); [EOL] Mockito.when(param.getAnnotation(JsonProperty.class)).thenReturn(pann); [EOL] Mockito.when(pann.value()).thenReturn("testName"); [EOL] String result = findDeserializationName(param); [EOL] assertEquals("testName", result); [EOL] }
public void testFindDeserializationNameWithNonNullParamAndNullAnnotation() { [EOL] AnnotatedParameter param = Mockito.mock(AnnotatedParameter.class); [EOL] Mockito.when(param.getAnnotation(JsonProperty.class)).thenReturn(null); [EOL] String result = findDeserializationName(param); [EOL] assertNull(result); [EOL] }
public void testFindDeserializationNameWithNullParam() { [EOL] String result = findDeserializationName(null); [EOL] assertNull(result); [EOL] }
public void testHasAnyGetterAnnotationWithJsonAnyGetter() { [EOL] AnnotatedMethod am = mock(AnnotatedMethod.class); [EOL] when(am.hasAnnotation(JsonAnyGetter.class)).thenReturn(true); [EOL] boolean result = hasAnyGetterAnnotation(am); [EOL] assertTrue(result); [EOL] }
public void testHasAnyGetterAnnotationWithoutJsonAnyGetter() { [EOL] AnnotatedMethod am = mock(AnnotatedMethod.class); [EOL] when(am.hasAnnotation(JsonAnyGetter.class)).thenReturn(false); [EOL] boolean result = hasAnyGetterAnnotation(am); [EOL] assertFalse(result); [EOL] }
public void testHasCreatorAnnotationWithJsonCreator() { [EOL] Annotated annotatedWithCreator = mock(Annotated.class); [EOL] when(annotatedWithCreator.hasAnnotation(JsonCreator.class)).thenReturn(true); [EOL] boolean result = hasCreatorAnnotation(annotatedWithCreator); [EOL] assertTrue(result); [EOL] }
public void testHasCreatorAnnotationWithoutJsonCreator() { [EOL] Annotated annotatedWithoutCreator = mock(Annotated.class); [EOL] when(annotatedWithoutCreator.hasAnnotation(JsonCreator.class)).thenReturn(false); [EOL] boolean result = hasCreatorAnnotation(annotatedWithoutCreator); [EOL] assertFalse(result); [EOL] }
public void testIsIgnorableWithIgnoreAnnotationTrue() { [EOL] Annotated annotated = Mockito.mock(Annotated.class); [EOL] JsonIgnore jsonIgnore = Mockito.mock(JsonIgnore.class); [EOL] Mockito.when(annotated.getAnnotation(JsonIgnore.class)).thenReturn(jsonIgnore); [EOL] Mockito.when(jsonIgnore.value()).thenReturn(true); [EOL] boolean result = _isIgnorable(annotated); [EOL] assertTrue(result); [EOL] }
public void testIsIgnorableWithIgnoreAnnotationFalse() { [EOL] Annotated annotated = Mockito.mock(Annotated.class); [EOL] JsonIgnore jsonIgnore = Mockito.mock(JsonIgnore.class); [EOL] Mockito.when(annotated.getAnnotation(JsonIgnore.class)).thenReturn(jsonIgnore); [EOL] Mockito.when(jsonIgnore.value()).thenReturn(false); [EOL] boolean result = _isIgnorable(annotated); [EOL] assertFalse(result); [EOL] }
public void testIsIgnorableWithoutIgnoreAnnotation() { [EOL] Annotated annotated = Mockito.mock(Annotated.class); [EOL] Mockito.when(annotated.getAnnotation(JsonIgnore.class)).thenReturn(null); [EOL] boolean result = _isIgnorable(annotated); [EOL] assertFalse(result); [EOL] }
protected TypeResolverBuilder<?> _findTypeResolver(MapperConfig<?> config, Annotated ann, JavaType baseType) { [EOL] TypeResolverBuilder<?> b; [EOL] JsonTypeInfo info = ann.getAnnotation(JsonTypeInfo.class); [EOL] JsonTypeResolver resAnn = ann.getAnnotation(JsonTypeResolver.class); [EOL] if (resAnn != null) { [EOL] if (info == null) { [EOL] return null; [EOL] } [EOL] b = config.typeResolverBuilderInstance(ann, resAnn.value()); [EOL] } else { [EOL] if (info == null) { [EOL] return null; [EOL] } [EOL] if (info.use() == JsonTypeInfo.Id.NONE) { [EOL] return _constructNoTypeResolverBuilder(); [EOL] } [EOL] b = _constructStdTypeResolverBuilder(); [EOL] } [EOL] JsonTypeIdResolver idResInfo = ann.getAnnotation(JsonTypeIdResolver.class); [EOL] TypeIdResolver idRes = (idResInfo == null) ? null : config.typeIdResolverInstance(ann, idResInfo.value()); [EOL] if (idRes != null) { [EOL] idRes.init(baseType); [EOL] } [EOL] b = b.init(info.use(), idRes); [EOL] JsonTypeInfo.As inclusion = info.include(); [EOL] if (inclusion == JsonTypeInfo.As.EXTERNAL_PROPERTY && (ann instanceof AnnotatedClass)) { [EOL] inclusion = JsonTypeInfo.As.PROPERTY; [EOL] } [EOL] b = b.inclusion(inclusion); [EOL] b = b.typeProperty(info.property()); [EOL] Class<?> defaultImpl = info.defaultImpl(); [EOL] if (defaultImpl != JsonTypeInfo.None.class) { [EOL] b = b.defaultImpl(defaultImpl); [EOL] } [EOL] b = b.typeIdVisibility(info.visible()); [EOL] return b; [EOL] }
public void testStdScalarSerializerWithNonNullClassAndTrueDummy() { [EOL] Class<?> clazz = String.class; [EOL] StdScalarSerializer<?> serializer = new StdScalarSerializer<>(clazz, true); [EOL] assertNotNull(serializer); [EOL] }
public void testStdScalarSerializerWithNonNullClassAndFalseDummy() { [EOL] Class<?> clazz = Integer.class; [EOL] StdScalarSerializer<?> serializer = new StdScalarSerializer<>(clazz, false); [EOL] assertNotNull(serializer); [EOL] }
public void testStdScalarSerializerWithNullClassAndTrueDummy() { [EOL] Class<?> clazz = null; [EOL] try { [EOL] StdScalarSerializer<?> serializer = new StdScalarSerializer<>(clazz, true); [EOL] fail("Expected an exception to be thrown"); [EOL] } catch (NullPointerException e) { [EOL] assertNotNull(e.getMessage()); [EOL] } [EOL] }
public void testStdScalarSerializerWithNullClassAndFalseDummy() { [EOL] Class<?> clazz = null; [EOL] try { [EOL] StdScalarSerializer<?> serializer = new StdScalarSerializer<>(clazz, false); [EOL] fail("Expected an exception to be thrown"); [EOL] } catch (NullPointerException e) { [EOL] assertNotNull(e.getMessage()); [EOL] } [EOL] }
public void testSerializeWithType_NullValue() throws IOException { [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] SerializerProvider mockProvider = mock(SerializerProvider.class); [EOL] TypeSerializer mockTypeSerializer = mock(TypeSerializer.class); [EOL] serializeWithType(null, mockJsonGenerator, mockProvider, mockTypeSerializer); [EOL] verify(mockTypeSerializer).writeTypePrefixForScalar(null, mockJsonGenerator); [EOL] verify(mockTypeSerializer).writeTypeSuffixForScalar(null, mockJsonGenerator); [EOL] verifyNoMoreInteractions(mockJsonGenerator); [EOL] }
public void testSerializeWithType_NonNullValue() throws IOException { [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] SerializerProvider mockProvider = mock(SerializerProvider.class); [EOL] TypeSerializer mockTypeSerializer = mock(TypeSerializer.class); [EOL] Object value = new Object(); [EOL] serializeWithType(value, mockJsonGenerator, mockProvider, mockTypeSerializer); [EOL] verify(mockTypeSerializer).writeTypePrefixForScalar(value, mockJsonGenerator); [EOL] verify(mockTypeSerializer).writeTypeSuffixForScalar(value, mockJsonGenerator); [EOL] }
public void testObjectIdInfoWithNonNullValues() { [EOL] String propertyName = "id"; [EOL] Class<?> scope = Object.class; [EOL] Class<? extends ObjectIdGenerator<?>> generatorClass = ObjectIdGenerator.class; [EOL] ObjectIdInfo objectIdInfo = new ObjectIdInfo(propertyName, scope, generatorClass); [EOL] assertEquals(propertyName, objectIdInfo.getPropertyName()); [EOL] assertEquals(scope, objectIdInfo.getScope()); [EOL] assertEquals(generatorClass, objectIdInfo.getGeneratorType()); [EOL] assertFalse(objectIdInfo.getAlwaysAsId()); [EOL] }
public void testObjectIdInfoWithNullValues() { [EOL] ObjectIdInfo objectIdInfo = new ObjectIdInfo(null, null, null); [EOL] assertNull(objectIdInfo.getPropertyName()); [EOL] assertNull(objectIdInfo.getScope()); [EOL] assertNull(objectIdInfo.getGeneratorType()); [EOL] assertFalse(objectIdInfo.getAlwaysAsId()); [EOL] }
public void testObjectIdInfoWithAlwaysAsIdTrue() { [EOL] String propertyName = "id"; [EOL] Class<?> scope = Object.class; [EOL] Class<? extends ObjectIdGenerator<?>> generatorClass = ObjectIdGenerator.class; [EOL] boolean alwaysAsId = true; [EOL] ObjectIdInfo objectIdInfo = new ObjectIdInfo(propertyName, scope, generatorClass, alwaysAsId); [EOL] assertEquals(propertyName, objectIdInfo.getPropertyName()); [EOL] assertEquals(scope, objectIdInfo.getScope()); [EOL] assertEquals(generatorClass, objectIdInfo.getGeneratorType()); [EOL] assertTrue(objectIdInfo.getAlwaysAsId()); [EOL] }
public void testObjectIdInfoWithAlwaysAsIdFalse() { [EOL] String propertyName = "id"; [EOL] Class<?> scope = Object.class; [EOL] Class<? extends ObjectIdGenerator<?>> generatorClass = ObjectIdGenerator.class; [EOL] boolean alwaysAsId = false; [EOL] ObjectIdInfo objectIdInfo = new ObjectIdInfo(propertyName, scope, generatorClass, alwaysAsId); [EOL] assertEquals(propertyName, objectIdInfo.getPropertyName()); [EOL] assertEquals(scope, objectIdInfo.getScope()); [EOL] assertEquals(generatorClass, objectIdInfo.getGeneratorType()); [EOL] assertFalse(objectIdInfo.getAlwaysAsId()); [EOL] }
public void testGetPropertyName_Null() { [EOL] PropertyName propertyName = new PropertyName(null); [EOL] assertNull(propertyName.getPropertyName()); [EOL] }
public void testGetPropertyName_Empty() { [EOL] PropertyName propertyName = new PropertyName(""); [EOL] assertEquals("", propertyName.getPropertyName()); [EOL] }
public void testGetPropertyName_NonEmpty() { [EOL] PropertyName propertyName = new PropertyName("testName"); [EOL] assertEquals("testName", propertyName.getPropertyName()); [EOL] }
public void testGetScope() { [EOL] MyClass myObject = new MyClass(); [EOL] Class<?> expectedScope = SomeClass.class; // Replace with an actual class [EOL] myObject.setScope(expectedScope); // Assuming there's a setter; if not, use reflection [EOL] Class<?> actualScope = myObject.getScope(); [EOL] assertEquals("The scope should be the same as what was set.", expectedScope, actualScope); [EOL] }
public Class<? extends ObjectIdGenerator<?>> getGeneratorType() { [EOL] return _generator; [EOL] }
public void testGetAlwaysAsIdWhenTrue() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] SerializationConfig config = mapper.getSerializationConfig(); [EOL] config = config.with(new SimpleMixInResolver(null, config._mixIns)).withAlwaysAsId(true); [EOL] assertTrue(config.getAlwaysAsId()); [EOL] }
public void testGetAlwaysAsIdWhenFalse() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] SerializationConfig config = mapper.getSerializationConfig(); [EOL] config = config.with(new SimpleMixInResolver(null, config._mixIns)).withAlwaysAsId(false); [EOL] assertFalse(config.getAlwaysAsId()); [EOL] }
public void testDeserializationContextWithNonNullFactoryAndCache() { [EOL] DeserializerFactory factory = mock(DeserializerFactory.class); [EOL] DeserializerCache cache = new DeserializerCache(); [EOL] DeserializationContext context = new DeserializationContext(factory, cache); [EOL] assertNotNull(context); [EOL] }
public void testDeserializationContextWithNonNullFactoryAndNullCache() { [EOL] DeserializerFactory factory = mock(DeserializerFactory.class); [EOL] DeserializationContext context = new DeserializationContext(factory, null); [EOL] assertNotNull(context); [EOL] }
public void testDeserializationContextWithNullFactory() { [EOL] try { [EOL] new DeserializationContext(null, new DeserializerCache()); [EOL] fail("Expected IllegalArgumentException not thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Can not pass null DeserializerFactory", e.getMessage()); [EOL] } [EOL] }
public void testHasValueDeserializerFor_WithValueDeserializer() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] JavaType type = mapper.constructType(String.class); [EOL] boolean result = mapper.hasValueDeserializerFor(type); [EOL] assertTrue(result); [EOL] }
public void testHasValueDeserializerFor_WithoutValueDeserializer() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] JavaType type = mapper.constructType(SomeCustomClass.class); [EOL] boolean result = mapper.hasValueDeserializerFor(type); [EOL] assertFalse(result); [EOL] }
public void testFindContextualValueDeserializerWithNonNullDeserializerAndContextual() throws JsonMappingException { [EOL] DeserializationContext context = mock(DeserializationContext.class); [EOL] DeserializerFactory factory = mock(DeserializerFactory.class); [EOL] JavaType type = mock(JavaType.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] JsonDeserializer<Object> deserializer = mock(JsonDeserializer.class); [EOL] ContextualDeserializer contextualDeserializer = mock(ContextualDeserializer.class); [EOL] when(contextualDeserializer.createContextual(context, property)).thenReturn(deserializer); [EOL] when(deserializer instanceof ContextualDeserializer).thenReturn(true); [EOL] when(_cache.findValueDeserializer(context, factory, type)).thenReturn(contextualDeserializer); [EOL] JsonDeserializer<Object> result = findContextualValueDeserializer(type, property); [EOL] assertNotNull(result); [EOL] assertSame(deserializer, result); [EOL] }
public void testFindContextualValueDeserializerWithNonNullDeserializerNonContextual() throws JsonMappingException { [EOL] DeserializationContext context = mock(DeserializationContext.class); [EOL] DeserializerFactory factory = mock(DeserializerFactory.class); [EOL] JavaType type = mock(JavaType.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] JsonDeserializer<Object> deserializer = mock(JsonDeserializer.class); [EOL] when(_cache.findValueDeserializer(context, factory, type)).thenReturn(deserializer); [EOL] when(deserializer instanceof ContextualDeserializer).thenReturn(false); [EOL] JsonDeserializer<Object> result = findContextualValueDeserializer(type, property); [EOL] assertNotNull(result); [EOL] assertSame(deserializer, result); [EOL] }
public void testFindContextualValueDeserializerWithNullDeserializer() throws JsonMappingException { [EOL] DeserializationContext context = mock(DeserializationContext.class); [EOL] DeserializerFactory factory = mock(DeserializerFactory.class); [EOL] JavaType type = mock(JavaType.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] when(_cache.findValueDeserializer(context, factory, type)).thenReturn(null); [EOL] JsonDeserializer<Object> result = findContextualValueDeserializer(type, property); [EOL] assertNull(result); [EOL] }
public void testFindRootValueDeserializerWithNullDeserializer() throws JsonMappingException { [EOL] DeserializationContext context = mock(DeserializationContext.class); [EOL] DeserializerCache cache = mock(DeserializerCache.class); [EOL] DeserializerFactory factory = mock(DeserializerFactory.class); [EOL] JavaType type = mock(JavaType.class); [EOL] when(cache.findValueDeserializer(context, factory, type)).thenReturn(null); [EOL] JsonDeserializer<Object> result = context.findRootValueDeserializer(type); [EOL] assertNull(result); [EOL] }
public void testFindRootValueDeserializerWithContextualDeserializer() throws JsonMappingException { [EOL] DeserializationContext context = mock(DeserializationContext.class); [EOL] DeserializerCache cache = mock(DeserializerCache.class); [EOL] DeserializerFactory factory = mock(DeserializerFactory.class); [EOL] JavaType type = mock(JavaType.class); [EOL] ContextualDeserializer contextualDeserializer = mock(ContextualDeserializer.class); [EOL] JsonDeserializer<Object> baseDeserializer = mock(JsonDeserializer.class); [EOL] when(cache.findValueDeserializer(context, factory, type)).thenReturn((JsonDeserializer<Object>) contextualDeserializer); [EOL] when(contextualDeserializer.createContextual(context, null)).thenReturn(baseDeserializer); [EOL] JsonDeserializer<Object> result = context.findRootValueDeserializer(type); [EOL] assertNotNull(result); [EOL] assertSame(baseDeserializer, result); [EOL] }
public void testFindRootValueDeserializerWithTypeDeserializer() throws JsonMappingException { [EOL] DeserializationContext context = mock(DeserializationContext.class); [EOL] DeserializerCache cache = mock(DeserializerCache.class); [EOL] DeserializerFactory factory = mock(DeserializerFactory.class); [EOL] JavaType type = mock(JavaType.class); [EOL] JsonDeserializer<Object> baseDeserializer = mock(JsonDeserializer.class); [EOL] TypeDeserializer typeDeserializer = mock(TypeDeserializer.class); [EOL] when(cache.findValueDeserializer(context, factory, type)).thenReturn(baseDeserializer); [EOL] when(factory.findTypeDeserializer(context.getConfig(), type)).thenReturn(typeDeserializer); [EOL] when(typeDeserializer.forProperty(null)).thenReturn(typeDeserializer); [EOL] JsonDeserializer<Object> result = context.findRootValueDeserializer(type); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof TypeWrappedDeserializer); [EOL] }
public void testFindKeyDeserializerWithNonContextual() throws JsonMappingException { [EOL] JavaType keyType = mock(JavaType.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] KeyDeserializer nonContextualKeyDeserializer = mock(KeyDeserializer.class); [EOL] DeserializationContext context = mock(DeserializationContext.class); [EOL] DeserializerFactory factory = mock(DeserializerFactory.class); [EOL] DeserializerCache cache = mock(DeserializerCache.class); [EOL] when(context.getFactory()).thenReturn(factory); [EOL] when(cache.findKeyDeserializer(context, factory, keyType)).thenReturn(nonContextualKeyDeserializer); [EOL] when(context.cacheKeyDeserializer(keyType, nonContextualKeyDeserializer)).thenReturn(nonContextualKeyDeserializer); [EOL] KeyDeserializer result = context.findKeyDeserializer(keyType, property); [EOL] assertSame(nonContextualKeyDeserializer, result); [EOL] }
public void testFindKeyDeserializerWithContextual() throws JsonMappingException { [EOL] JavaType keyType = mock(JavaType.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] ContextualKeyDeserializer contextualKeyDeserializer = mock(ContextualKeyDeserializer.class); [EOL] KeyDeserializer createdKeyDeserializer = mock(KeyDeserializer.class); [EOL] DeserializationContext context = mock(DeserializationContext.class); [EOL] DeserializerFactory factory = mock(DeserializerFactory.class); [EOL] DeserializerCache cache = mock(DeserializerCache.class); [EOL] when(context.getFactory()).thenReturn(factory); [EOL] when(cache.findKeyDeserializer(context, factory, keyType)).thenReturn(contextualKeyDeserializer); [EOL] when(contextualKeyDeserializer.createContextual(context, property)).thenReturn(createdKeyDeserializer); [EOL] when(context.cacheKeyDeserializer(keyType, createdKeyDeserializer)).thenReturn(createdKeyDeserializer); [EOL] KeyDeserializer result = context.findKeyDeserializer(keyType, property); [EOL] assertSame(createdKeyDeserializer, result); [EOL] }
public void testLeaseObjectBufferWhenBufferIsNull() { [EOL] MyClass testClass = new MyClass(); [EOL] testClass._objectBuffer = null; [EOL] ObjectBuffer result = testClass.leaseObjectBuffer(); [EOL] assertNotNull(result); [EOL] assertNull(testClass._objectBuffer); [EOL] }
public void testLeaseObjectBufferWhenBufferIsNotNull() { [EOL] MyClass testClass = new MyClass(); [EOL] testClass._objectBuffer = new ObjectBuffer(); [EOL] ObjectBuffer originalBuffer = testClass._objectBuffer; [EOL] ObjectBuffer result = testClass.leaseObjectBuffer(); [EOL] assertSame(originalBuffer, result); [EOL] assertNull(testClass._objectBuffer); [EOL] }
public void testReturnObjectBufferWithNullCurrentBuffer() { [EOL] ObjectBuffer testBuffer = new ObjectBuffer(); // Assuming ObjectBuffer is a valid class and has a default constructor [EOL] MyClassUnderTest myClassUnderTest = new MyClassUnderTest(); // Replace with actual class name that contains returnObjectBuffer [EOL] myClassUnderTest.returnObjectBuffer(testBuffer); [EOL] assertEquals(testBuffer, myClassUnderTest.getObjectBuffer()); // Assuming there is a getter for _objectBuffer [EOL] }
public void testReturnObjectBufferWithSmallerInitialCapacity() { [EOL] ObjectBuffer currentBuffer = new ObjectBuffer(); // Assuming ObjectBuffer has a method to set initial capacity [EOL] currentBuffer.setInitialCapacity(10); // Set some capacity [EOL] MyClassUnderTest myClassUnderTest = new MyClassUnderTest(); [EOL] myClassUnderTest.returnObjectBuffer(currentBuffer); // Set the current buffer [EOL] ObjectBuffer newBuffer = new ObjectBuffer(); [EOL] newBuffer.setInitialCapacity(5); // Smaller capacity than currentBuffer [EOL] myClassUnderTest.returnObjectBuffer(newBuffer); [EOL] assertEquals(currentBuffer, myClassUnderTest.getObjectBuffer()); // The buffer should not change [EOL] }
public void testReturnObjectBufferWithLargerInitialCapacity() { [EOL] ObjectBuffer currentBuffer = new ObjectBuffer(); // Assuming ObjectBuffer has a method to set initial capacity [EOL] currentBuffer.setInitialCapacity(5); // Set some capacity [EOL] MyClassUnderTest myClassUnderTest = new MyClassUnderTest(); [EOL] myClassUnderTest.returnObjectBuffer(currentBuffer); // Set the current buffer [EOL] ObjectBuffer newBuffer = new ObjectBuffer(); [EOL] newBuffer.setInitialCapacity(10); // Larger capacity than currentBuffer [EOL] myClassUnderTest.returnObjectBuffer(newBuffer); [EOL] assertEquals(newBuffer, myClassUnderTest.getObjectBuffer()); // The buffer should be replaced with newBuffer [EOL] }
public void testInstantiationExceptionWithNullMessage() { [EOL] Class<?> instClass = Object.class; [EOL] JsonMappingException exception = instantiationException(instClass, null); [EOL] assertNotNull(exception); [EOL] assertTrue(exception.getMessage().contains("Can not construct instance of")); [EOL] assertTrue(exception.getMessage().contains("Object")); [EOL] assertTrue(exception.getMessage().contains("problem: null")); [EOL] }
public void testInstantiationExceptionWithEmptyMessage() { [EOL] Class<?> instClass = String.class; [EOL] JsonMappingException exception = instantiationException(instClass, ""); [EOL] assertNotNull(exception); [EOL] assertTrue(exception.getMessage().contains("Can not construct instance of")); [EOL] assertTrue(exception.getMessage().contains("String")); [EOL] assertTrue(exception.getMessage().contains("problem: ")); [EOL] }
public void testInstantiationExceptionWithNonNullMessage() { [EOL] Class<?> instClass = Integer.class; [EOL] String msg = "constructor not visible"; [EOL] JsonMappingException exception = instantiationException(instClass, msg); [EOL] assertNotNull(exception); [EOL] assertTrue(exception.getMessage().contains("Can not construct instance of")); [EOL] assertTrue(exception.getMessage().contains("Integer")); [EOL] assertTrue(exception.getMessage().contains("problem: " + msg)); [EOL] }
protected DefaultDeserializationContext(DeserializerFactory df, DeserializerCache cache) { [EOL] super(df, cache); [EOL] }
public void testDeserializerInstanceWithNull() { [EOL] JsonDeserializer<Object> result = instance.deserializerInstance(null, null); [EOL] assertNull(result); [EOL] }
public void testDeserializerInstanceWithJsonDeserializer() { [EOL] JsonDeserializer<?> deserDef = new MyJsonDeserializer(); [EOL] JsonDeserializer<Object> result = instance.deserializerInstance(null, deserDef); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof MyJsonDeserializer); [EOL] }
public void testDeserializerInstanceWithInvalidType() { [EOL] Object deserDef = new Object(); [EOL] try { [EOL] instance.deserializerInstance(null, deserDef); [EOL] fail("Expected IllegalStateException to be thrown"); [EOL] } catch (IllegalStateException e) { [EOL] assertEquals("AnnotationIntrospector returned deserializer definition of type java.lang.Object; expected type JsonDeserializer or Class<JsonDeserializer> instead", e.getMessage()); [EOL] } [EOL] }
public void testDeserializerInstanceWithJsonDeserializerNoneClass() { [EOL] JsonDeserializer<Object> result = instance.deserializerInstance(null, JsonDeserializer.None.class); [EOL] assertNull(result); [EOL] }
public void testDeserializerInstanceWithNoClass() { [EOL] JsonDeserializer<Object> result = instance.deserializerInstance(null, NoClass.class); [EOL] assertNull(result); [EOL] }
public void testDeserializerInstanceWithNonJsonDeserializerClass() { [EOL] try { [EOL] instance.deserializerInstance(null, String.class); [EOL] fail("Expected IllegalStateException to be thrown"); [EOL] } catch (IllegalStateException e) { [EOL] assertEquals("AnnotationIntrospector returned Class java.lang.String; expected Class<JsonDeserializer>", e.getMessage()); [EOL] } [EOL] }
public void testDeserializerInstanceWithResolvableDeserializer() { [EOL] JsonDeserializer<?> deserDef = new MyResolvableDeserializer(); [EOL] JsonDeserializer<Object> result = instance.deserializerInstance(null, deserDef); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof MyResolvableDeserializer); [EOL] assertTrue(((MyResolvableDeserializer) result).isResolved()); [EOL] }
public void testKeyDeserializerInstanceWithNull() throws JsonMappingException { [EOL] KeyDeserializer result = keyDeserializerInstance(null, null); [EOL] assertNull(result); [EOL] }
public void testKeyDeserializerInstanceWithKeyDeserializerInstance() throws JsonMappingException { [EOL] KeyDeserializer mockDeser = mock(KeyDeserializer.class); [EOL] KeyDeserializer result = keyDeserializerInstance(null, mockDeser); [EOL] assertSame(mockDeser, result); [EOL] }
public void testKeyDeserializerInstanceWithInvalidType() { [EOL] Object invalidDeserDef = new Object(); [EOL] try { [EOL] keyDeserializerInstance(null, invalidDeserDef); [EOL] fail("Expected IllegalStateException to be thrown"); [EOL] } catch (IllegalStateException e) { [EOL] assertEquals("AnnotationIntrospector returned key deserializer definition of type java.lang.Object; expected type KeyDeserializer or Class<KeyDeserializer> instead", e.getMessage()); [EOL] } [EOL] }
public void testKeyDeserializerInstanceWithNoneClass() throws JsonMappingException { [EOL] KeyDeserializer result = keyDeserializerInstance(null, KeyDeserializer.None.class); [EOL] assertNull(result); [EOL] }
public void testKeyDeserializerInstanceWithNoClass() throws JsonMappingException { [EOL] KeyDeserializer result = keyDeserializerInstance(null, NoClass.class); [EOL] assertNull(result); [EOL] }
public void testKeyDeserializerInstanceWithNonKeyDeserializerClass() { [EOL] Class<?> nonDeserClass = String.class; [EOL] try { [EOL] keyDeserializerInstance(null, nonDeserClass); [EOL] fail("Expected IllegalStateException to be thrown"); [EOL] } catch (IllegalStateException e) { [EOL] assertEquals("AnnotationIntrospector returned Class java.lang.String; expected Class<KeyDeserializer>", e.getMessage()); [EOL] } [EOL] }
public void testKeyDeserializerInstanceWithKeyDeserializerSubclass() throws JsonMappingException { [EOL] Class<?> deserClass = MockKeyDeserializerSubclass.class; [EOL] KeyDeserializer result = keyDeserializerInstance(null, deserClass); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof MockKeyDeserializerSubclass); [EOL] }
public void testKeyDeserializerInstanceWithResolvableDeserializer() throws JsonMappingException { [EOL] Class<?> deserClass = MockResolvableKeyDeserializer.class; [EOL] KeyDeserializer result = keyDeserializerInstance(null, deserClass); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof MockResolvableKeyDeserializer); [EOL] assertTrue(((MockResolvableKeyDeserializer) result).isResolved()); [EOL] }
public void testImplConstructorWithNonNullFactory() { [EOL] DeserializerFactory factory = new DeserializerFactoryImpl(); [EOL] Impl impl = new Impl(factory); [EOL] assertNotNull(impl); [EOL] }
public void testImplConstructorWithNullFactory() { [EOL] try { [EOL] Impl impl = new Impl(null); [EOL] fail("Should have thrown an IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testPOJOPropertyBuilderConstructor() { [EOL] String internalName = "testInternalName"; [EOL] AnnotationIntrospector annotationIntrospector = mock(AnnotationIntrospector.class); [EOL] boolean forSerialization = true; [EOL] POJOPropertyBuilder builder = new POJOPropertyBuilder(internalName, annotationIntrospector, forSerialization); [EOL] assertEquals(internalName, builder._internalName); [EOL] assertEquals(internalName, builder._name); [EOL] assertEquals(annotationIntrospector, builder._annotationIntrospector); [EOL] assertEquals(forSerialization, builder._forSerialization); [EOL] }
public void testPOJOPropertyBuilderConstructorForDeserialization() { [EOL] String internalName = "testInternalName"; [EOL] AnnotationIntrospector annotationIntrospector = mock(AnnotationIntrospector.class); [EOL] boolean forSerialization = false; [EOL] POJOPropertyBuilder builder = new POJOPropertyBuilder(internalName, annotationIntrospector, forSerialization); [EOL] assertEquals(internalName, builder._internalName); [EOL] assertEquals(internalName, builder._name); [EOL] assertEquals(annotationIntrospector, builder._annotationIntrospector); [EOL] assertEquals(forSerialization, builder._forSerialization); [EOL] }
public void testPOJOPropertyBuilderCopyConstructor() { [EOL] String newName = "newPropertyName"; [EOL] POJOPropertyBuilder original = new POJOPropertyBuilder(/* provide necessary arguments */); [EOL] POJOPropertyBuilder copy = new POJOPropertyBuilder(original, newName); [EOL] assertEquals(original.getInternalName(), copy.getInternalName()); [EOL] assertEquals(newName, copy.getName()); [EOL] assertEquals(original.getAnnotationIntrospector(), copy.getAnnotationIntrospector()); [EOL] assertEquals(original.getFields(), copy.getFields()); [EOL] assertEquals(original.getCtorParameters(), copy.getCtorParameters()); [EOL] assertEquals(original.getGetters(), copy.getGetters()); [EOL] assertEquals(original.getSetters(), copy.getSetters()); [EOL] assertEquals(original.isForSerialization(), copy.isForSerialization()); [EOL] }
public void testWithNameNonNull() { [EOL] POJOPropertyBuilder original = new POJOPropertyBuilder("originalName"); [EOL] String newName = "newName"; [EOL] POJOPropertyBuilder renamed = original.withName(newName); [EOL] assertNotNull(renamed); [EOL] assertNotSame(original, renamed); [EOL] assertEquals(newName, renamed.getName()); [EOL] }
public void testWithNameNull() { [EOL] POJOPropertyBuilder original = new POJOPropertyBuilder("originalName"); [EOL] POJOPropertyBuilder renamed = original.withName(null); [EOL] assertNotNull(renamed); [EOL] assertNotSame(original, renamed); [EOL] assertNull(renamed.getName()); [EOL] }
public void testGetName() { [EOL] YourClass instance = new YourClass("TestName"); [EOL] String expected = "TestName"; [EOL] String actual = instance.getName(); [EOL] assertEquals(expected, actual); [EOL] }
public void testGetWrapperNameWithNullMember() { [EOL] BeanProperty.Std property = new BeanProperty.Std( [EOL] null, null, null, null, null, null, null, null, null, null [EOL] ); [EOL] PropertyName result = property.getWrapperName(); [EOL] assertNull(result); [EOL] }
public void testGetWrapperNameWithNonNullMemberAndNullAnnotationIntrospector() { [EOL] AnnotatedMember member = mock(AnnotatedMember.class); [EOL] BeanProperty.Std property = new BeanProperty.Std( [EOL] null, null, null, member, null, null, null, null, null, null [EOL] ); [EOL] PropertyName result = property.getWrapperName(); [EOL] assertNull(result); [EOL] }
public void testGetWrapperNameWithNonNullMemberAndNonNullAnnotationIntrospector() { [EOL] AnnotatedMember member = mock(AnnotatedMember.class); [EOL] AnnotationIntrospector annotationIntrospector = mock(AnnotationIntrospector.class); [EOL] PropertyName expectedWrapperName = new PropertyName("testWrapper"); [EOL] when(annotationIntrospector.findWrapperName(member)).thenReturn(expectedWrapperName); [EOL] BeanProperty.Std property = new BeanProperty.Std( [EOL] null, null, null, member, null, null, annotationIntrospector, null, null, null [EOL] ); [EOL] PropertyName result = property.getWrapperName(); [EOL] assertEquals(expectedWrapperName, result); [EOL] }
public void testHasGetterWhenGettersIsNull() { [EOL] BeanPropertyDefinition beanPropDef = new BeanPropertyDefinition(); [EOL] beanPropDef._getters = null; [EOL] assertFalse(beanPropDef.hasGetter()); [EOL] }
public void testHasGetterWhenGettersIsNotNull() { [EOL] BeanPropertyDefinition beanPropDef = new BeanPropertyDefinition(); [EOL] beanPropDef._getters = new SomeTypeOfGetter(); [EOL] assertTrue(beanPropDef.hasGetter()); [EOL] }
public void testHasSetterWhenSettersIsNull() { [EOL] BeanPropertyDefinition instance = new BeanPropertyDefinition(); [EOL] instance._setters = null; // Assuming there's a way to set this, like a constructor or a setter method [EOL] boolean result = instance.hasSetter(); [EOL] assertFalse(result); [EOL] }
public void testHasSetterWhenSettersIsNotNull() { [EOL] BeanPropertyDefinition instance = new BeanPropertyDefinition(); [EOL] instance._setters = new LinkedHashMap<String, AnnotatedMethod>(); // Assuming there's a way to set this [EOL] boolean result = instance.hasSetter(); [EOL] assertTrue(result); [EOL] }
public void testHasFieldWhenFieldsAreNull() { [EOL] TargetClass target = new TargetClass(null); // Constructor that sets _fields to null [EOL] boolean result = target.hasField(); [EOL] assertFalse(result); [EOL] }
public void testHasFieldWhenFieldsAreNotNull() { [EOL] TargetClass target = new TargetClass(someNonNullFieldsValue); [EOL] boolean result = target.hasField(); [EOL] assertTrue(result); [EOL] }
public void testHasConstructorParameter_WithNonNullCtorParameters() { [EOL] BeanPropertyDefinition beanPropDef = new BeanPropertyDefinition(); [EOL] beanPropDef._ctorParameters = new Object(); // Assuming _ctorParameters is of type Object [EOL] boolean result = beanPropDef.hasConstructorParameter(); [EOL] assertTrue(result); [EOL] }
public void testHasConstructorParameter_WithNullCtorParameters() { [EOL] BeanPropertyDefinition beanPropDef = new BeanPropertyDefinition(); [EOL] beanPropDef._ctorParameters = null; [EOL] boolean result = beanPropDef.hasConstructorParameter(); [EOL] assertFalse(result); [EOL] }
public void testGetGetterWithNullGetters() { [EOL] YourClass instance = new YourClass(); [EOL] instance._getters = null; [EOL] AnnotatedMethod result = instance.getGetter(); [EOL] assertNull(result); [EOL] }
public void testGetGetterWithSingleGetter() { [EOL] YourClass instance = new YourClass(); [EOL] AnnotatedMethod mockGetter = mock(AnnotatedMethod.class); [EOL] instance._getters = new Linked<>(mockGetter, null, null, false); [EOL] AnnotatedMethod result = instance.getGetter(); [EOL] assertSame(mockGetter, result); [EOL] }
public void testGetGetterWithMultipleGettersSameClass() { [EOL] YourClass instance = new YourClass(); [EOL] AnnotatedMethod mockGetter1 = mock(AnnotatedMethod.class); [EOL] AnnotatedMethod mockGetter2 = mock(AnnotatedMethod.class); [EOL] when(mockGetter1.getDeclaringClass()).thenReturn((Class) YourClass.class); [EOL] when(mockGetter2.getDeclaringClass()).thenReturn((Class) YourClass.class); [EOL] instance._getters = new Linked<>(mockGetter1, new Linked<>(mockGetter2, null, null, false), null, false); [EOL] AnnotatedMethod result = instance.getGetter(); [EOL] assertSame(mockGetter1, result); [EOL] }
public void testGetGetterWithMultipleGettersDifferentClasses() { [EOL] YourClass instance = new YourClass(); [EOL] AnnotatedMethod mockGetter1 = mock(AnnotatedMethod.class); [EOL] AnnotatedMethod mockGetter2 = mock(AnnotatedMethod.class); [EOL] when(mockGetter1.getDeclaringClass()).thenReturn((Class) ParentClass.class); [EOL] when(mockGetter2.getDeclaringClass()).thenReturn((Class) ChildClass.class); [EOL] when(mockGetter1.getFullName()).thenReturn("ParentClass.getter"); [EOL] when(mockGetter2.getFullName()).thenReturn("ChildClass.getter"); [EOL] when(ParentClass.class.isAssignableFrom(ChildClass.class)).thenReturn(true); [EOL] instance._getters = new Linked<>(mockGetter1, new Linked<>(mockGetter2, null, null, false), null, false); [EOL] AnnotatedMethod result = instance.getGetter(); [EOL] assertSame(mockGetter2, result); [EOL] }
public void testGetGetterWithConflictingGetters() { [EOL] YourClass instance = new YourClass(); [EOL] AnnotatedMethod mockGetter1 = mock(AnnotatedMethod.class); [EOL] AnnotatedMethod mockGetter2 = mock(AnnotatedMethod.class); [EOL] when(mockGetter1.getDeclaringClass()).thenReturn((Class) ParentClass.class); [EOL] when(mockGetter2.getDeclaringClass()).thenReturn((Class) SiblingClass.class); [EOL] when(mockGetter1.getFullName()).thenReturn("ParentClass.getter"); [EOL] when(mockGetter2.getFullName()).thenReturn("SiblingClass.getter"); [EOL] when(ParentClass.class.isAssignableFrom(SiblingClass.class)).thenReturn(false); [EOL] when(SiblingClass.class.isAssignableFrom(ParentClass.class)).thenReturn(false); [EOL] instance._getters = new Linked<>(mockGetter1, new Linked<>(mockGetter2, null, null, false), null, false); [EOL] try { [EOL] instance.getGetter(); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testGetSetterWithNullSetters() { [EOL] YourClass instance = new YourClass(null); [EOL] AnnotatedMethod result = instance.getSetter(); [EOL] assertNull(result); [EOL] }
public void testGetSetterWithNonNullSetters() { [EOL] Linked<AnnotatedMethod> setters = createNonEmptyLinkedAnnotatedMethods(); [EOL] YourClass instance = new YourClass(setters); [EOL] AnnotatedMethod result = instance.getSetter(); [EOL] assertNotNull(result); [EOL] AnnotatedMethod expectedSetter = setters.value; [EOL] assertEquals(expectedSetter, result); [EOL] }
public void testGetSetterWithConflictingSetters() { [EOL] Linked<AnnotatedMethod> setters = createConflictingLinkedAnnotatedMethods(); [EOL] YourClass instance = new YourClass(setters); [EOL] try { [EOL] instance.getSetter(); [EOL] fail("Expected IllegalArgumentException for conflicting setters"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testGetFieldWhenFieldsIsNull() { [EOL] instance._fields = null; [EOL] AnnotatedField result = instance.getField(); [EOL] assertNull(result); [EOL] }
public void testGetFieldWhenFieldsIsNotNullButNoNext() { [EOL] instance._fields = new Linked<>(new AnnotatedField(...), null); [EOL] AnnotatedField result = instance.getField(); [EOL] assertNotNull(result); [EOL] assertEquals(instance._fields.value, result); [EOL] }
public void testGetFieldWhenNextFieldIsFromAssignableClass() { [EOL] AnnotatedField field1 = new AnnotatedField(...); // from class A [EOL] AnnotatedField field2 = new AnnotatedField(...); // from class B where B is a subclass of A [EOL] instance._fields = new Linked<>(field1, new Linked<>(field2, null)); [EOL] AnnotatedField result = instance.getField(); [EOL] assertNotNull(result); [EOL] assertEquals(field2, result); [EOL] }
public void testGetFieldWhenCurrentFieldIsFromAssignableClass() { [EOL] AnnotatedField field1 = new AnnotatedField(...); // from class A [EOL] AnnotatedField field2 = new AnnotatedField(...); // from class B where A is a subclass of B [EOL] instance._fields = new Linked<>(field1, new Linked<>(field2, null)); [EOL] AnnotatedField result = instance.getField(); [EOL] assertNotNull(result); [EOL] assertEquals(field1, result); [EOL] }
public void testGetFieldWhenFieldsHaveDifferentDeclaringClassesAndNoneIsAssignableFromTheOther() { [EOL] AnnotatedField field1 = new AnnotatedField(...); // from class A [EOL] AnnotatedField field2 = new AnnotatedField(...); // from class B, unrelated to A [EOL] instance._fields = new Linked<>(field1, new Linked<>(field2, null)); [EOL] try { [EOL] instance.getField(); [EOL] fail("Expected an IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testGetConstructorParameter_WithNullCtorParameters() { [EOL] MyObjectUnderTest obj = new MyObjectUnderTest(); [EOL] obj._ctorParameters = null; [EOL] AnnotatedParameter result = obj.getConstructorParameter(); [EOL] assertNull(result); [EOL] }
public void testGetConstructorParameter_WithNonConstructorOwner() { [EOL] MyObjectUnderTest obj = new MyObjectUnderTest(); [EOL] AnnotatedParameter nonConstructorParam = createAnnotatedParameterWithNonConstructorOwner(); [EOL] obj._ctorParameters = new Linked<>(nonConstructorParam, null); [EOL] AnnotatedParameter result = obj.getConstructorParameter(); [EOL] assertSame(nonConstructorParam, result); [EOL] }
public void testGetConstructorParameter_WithConstructorOwner() { [EOL] MyObjectUnderTest obj = new MyObjectUnderTest(); [EOL] AnnotatedParameter constructorParam = createAnnotatedParameterWithConstructorOwner(); [EOL] obj._ctorParameters = new Linked<>(constructorParam, null); [EOL] AnnotatedParameter result = obj.getConstructorParameter(); [EOL] assertSame(constructorParam, result); [EOL] }
public void testGetConstructorParameter_WithMultipleParameters() { [EOL] MyObjectUnderTest obj = new MyObjectUnderTest(); [EOL] AnnotatedParameter nonConstructorParam = createAnnotatedParameterWithNonConstructorOwner(); [EOL] AnnotatedParameter constructorParam = createAnnotatedParameterWithConstructorOwner(); [EOL] obj._ctorParameters = new Linked<>(nonConstructorParam, new Linked<>(constructorParam, null)); [EOL] AnnotatedParameter result = obj.getConstructorParameter(); [EOL] assertSame(constructorParam, result); [EOL] }
public void testGetAccessorWithGetter() { [EOL] MyBean bean = new MyBean(); [EOL] AnnotatedMember expectedGetter = bean.getGetter(); [EOL] AnnotatedMember actualAccessor = bean.getAccessor(); [EOL] assertEquals(expectedGetter, actualAccessor); [EOL] }
public void testGetAccessorWithField() { [EOL] MyBean bean = new MyBean(); [EOL] AnnotatedMember expectedField = bean.getField(); [EOL] bean.setGetter(null); [EOL] AnnotatedMember actualAccessor = bean.getAccessor(); [EOL] assertEquals(expectedField, actualAccessor); [EOL] }
public void testGetMutatorWithConstructorParameter() { [EOL] AnnotatedMember mockMember = mock(AnnotatedMember.class); [EOL] when(instance.getConstructorParameter()).thenReturn(mockMember); [EOL] AnnotatedMember result = instance.getMutator(); [EOL] assertNotNull(result); [EOL] verify(instance, never()).getSetter(); [EOL] verify(instance, never()).getField(); [EOL] }
public void testGetMutatorWithSetter() { [EOL] AnnotatedMember mockMember = mock(AnnotatedMember.class); [EOL] when(instance.getConstructorParameter()).thenReturn(null); [EOL] when(instance.getSetter()).thenReturn(mockMember); [EOL] AnnotatedMember result = instance.getMutator(); [EOL] assertNotNull(result); [EOL] verify(instance).getSetter(); [EOL] verify(instance, never()).getField(); [EOL] }
public void testGetMutatorWithField() { [EOL] AnnotatedMember mockMember = mock(AnnotatedMember.class); [EOL] when(instance.getConstructorParameter()).thenReturn(null); [EOL] when(instance.getSetter()).thenReturn(null); [EOL] when(instance.getField()).thenReturn(mockMember); [EOL] AnnotatedMember result = instance.getMutator(); [EOL] assertNotNull(result); [EOL] verify(instance).getSetter(); [EOL] verify(instance).getField(); [EOL] }
public void testGetPrimaryMember_ForSerializationTrue() { [EOL] MyObject underTest = new MyObject(true); // Assuming MyObject is the class containing getPrimaryMember [EOL] AnnotatedMember result = underTest.getPrimaryMember(); [EOL] AnnotatedMember expected = underTest.getAccessor(); [EOL] assertEquals(expected, result); [EOL] }
public void testGetPrimaryMember_ForSerializationFalse() { [EOL] MyObject underTest = new MyObject(false); // Assuming MyObject is the class containing getPrimaryMember [EOL] AnnotatedMember result = underTest.getPrimaryMember(); [EOL] AnnotatedMember expected = underTest.getMutator(); [EOL] assertEquals(expected, result); [EOL] }
public void testFindViewsWhenMemberHasViews() { [EOL] AnnotatedMember member = mock(AnnotatedMember.class); [EOL] AnnotationIntrospector introspector = mock(AnnotationIntrospector.class); [EOL] Class<?>[] expectedViews = new Class<?>[]{View.Public.class, View.Private.class}; [EOL] when(introspector.findViews(member)).thenReturn(expectedViews); [EOL] ObjectWithMemberAnnotations objectUnderTest = new ObjectWithMemberAnnotations(introspector); [EOL] Class<?>[] actualViews = objectUnderTest.findViews(); [EOL] assertArrayEquals(expectedViews, actualViews); [EOL] }
public void testFindViewsWhenMemberHasNoViews() { [EOL] AnnotatedMember member = mock(AnnotatedMember.class); [EOL] AnnotationIntrospector introspector = mock(AnnotationIntrospector.class); [EOL] when(introspector.findViews(member)).thenReturn(null); [EOL] ObjectWithMemberAnnotations objectUnderTest = new ObjectWithMemberAnnotations(introspector); [EOL] Class<?>[] actualViews = objectUnderTest.findViews(); [EOL] assertNull(actualViews); [EOL] }
public void testFindReferenceTypeWhenMemberHasReferenceType() { [EOL] AnnotatedMember member = mock(AnnotatedMember.class); [EOL] AnnotationIntrospector ai = mock(AnnotationIntrospector.class); [EOL] AnnotationIntrospector.ReferenceProperty expectedReferenceProperty = mock(AnnotationIntrospector.ReferenceProperty.class); [EOL] when(ai.findReferenceType(member)).thenReturn(expectedReferenceProperty); [EOL] AnnotationIntrospector.ReferenceProperty result = ai.findReferenceType(member); [EOL] assertEquals(expectedReferenceProperty, result); [EOL] }
public void testFindReferenceTypeWhenMemberHasNoReferenceType() { [EOL] AnnotatedMember member = mock(AnnotatedMember.class); [EOL] AnnotationIntrospector ai = mock(AnnotationIntrospector.class); [EOL] when(ai.findReferenceType(member)).thenReturn(null); [EOL] AnnotationIntrospector.ReferenceProperty result = ai.findReferenceType(member); [EOL] assertNull(result); [EOL] }
public void testIsTypeIdWhenTrue() { [EOL] AnnotatedMember memberMock = Mockito.mock(AnnotatedMember.class); [EOL] when(_annotationIntrospector.isTypeId(memberMock)).thenReturn(true); [EOL] boolean result = isTypeId(); [EOL] assertTrue(result); [EOL] }
public void testIsTypeIdWhenFalse() { [EOL] AnnotatedMember memberMock = Mockito.mock(AnnotatedMember.class); [EOL] when(_annotationIntrospector.isTypeId(memberMock)).thenReturn(false); [EOL] boolean result = isTypeId(); [EOL] assertFalse(result); [EOL] }
public void testIsTypeIdWhenNull() { [EOL] AnnotatedMember memberMock = Mockito.mock(AnnotatedMember.class); [EOL] when(_annotationIntrospector.isTypeId(memberMock)).thenReturn(null); [EOL] boolean result = isTypeId(); [EOL] assertFalse(result); [EOL] }
public void testIsRequiredWhenMemberIsRequired() { [EOL] AnnotatedMember member = mock(AnnotatedMember.class); [EOL] AnnotationIntrospector introspector = mock(AnnotationIntrospector.class); [EOL] when(introspector.hasRequiredMarker(member)).thenReturn(true); [EOL] MyClassUnderTest testInstance = new MyClassUnderTest(introspector); [EOL] boolean result = testInstance.isRequired(); [EOL] assertTrue(result); [EOL] }
public void testIsRequiredWhenMemberIsNotRequired() { [EOL] AnnotatedMember member = mock(AnnotatedMember.class); [EOL] AnnotationIntrospector introspector = mock(AnnotationIntrospector.class); [EOL] when(introspector.hasRequiredMarker(member)).thenReturn(false); [EOL] MyClassUnderTest testInstance = new MyClassUnderTest(introspector); [EOL] boolean result = testInstance.isRequired(); [EOL] assertFalse(result); [EOL] }
public void testIsRequiredWhenMemberAnnotationIsNull() { [EOL] AnnotatedMember member = mock(AnnotatedMember.class); [EOL] AnnotationIntrospector introspector = mock(AnnotationIntrospector.class); [EOL] when(introspector.hasRequiredMarker(member)).thenReturn(null); [EOL] MyClassUnderTest testInstance = new MyClassUnderTest(introspector); [EOL] boolean result = testInstance.isRequired(); [EOL] assertFalse(result); [EOL] }
public void testAddFieldVisibleAndNotIgnored() { [EOL] POJOPropertiesCollector collector = new POJOPropertiesCollector(...); // Provide necessary arguments [EOL] AnnotatedField annotatedField = new AnnotatedField(...); // Provide necessary arguments [EOL] String fieldName = "testField"; [EOL] boolean visible = true; [EOL] boolean ignored = false; [EOL] collector.addField(annotatedField, fieldName, visible, ignored); [EOL] assertNotNull(collector.getFields()); [EOL] assertEquals(1, collector.getFields().size()); [EOL] assertTrue(collector.getFields().get(0).visible); [EOL] assertFalse(collector.getFields().get(0).ignored); [EOL] }
public void testAddFieldNotVisibleAndIgnored() { [EOL] POJOPropertiesCollector collector = new POJOPropertiesCollector(...); // Provide necessary arguments [EOL] AnnotatedField annotatedField = new AnnotatedField(...); // Provide necessary arguments [EOL] String fieldName = "testField"; [EOL] boolean visible = false; [EOL] boolean ignored = true; [EOL] collector.addField(annotatedField, fieldName, visible, ignored); [EOL] assertNotNull(collector.getFields()); [EOL] assertEquals(1, collector.getFields().size()); [EOL] assertFalse(collector.getFields().get(0).visible); [EOL] assertTrue(collector.getFields().get(0).ignored); [EOL] }
public void testAddCtorWithVisibleAndNotIgnored() { [EOL] CreatorCollector collector = new CreatorCollector(null, false); [EOL] AnnotatedParameter param = mock(AnnotatedParameter.class); [EOL] collector.addCtor(param, "paramName", true, false); [EOL] }
public void testAddCtorWithNotVisibleAndIgnored() { [EOL] CreatorCollector collector = new CreatorCollector(null, false); [EOL] AnnotatedParameter param = mock(AnnotatedParameter.class); [EOL] collector.addCtor(param, "paramName", false, true); [EOL] }
public void testAddGetterWithVisibleAndNotIgnored() { [EOL] BeanPropertyMap beanPropertyMap = new BeanPropertyMap(false); [EOL] AnnotatedMethod annotatedMethod = new AnnotatedMethod(null, null, null, null); [EOL] String propertyName = "testProperty"; [EOL] beanPropertyMap.addGetter(annotatedMethod, propertyName, true, false); [EOL] assertTrue(beanPropertyMap.find(propertyName).isVisible()); [EOL] assertFalse(beanPropertyMap.find(propertyName).isIgnored()); [EOL] }
public void testAddGetterWithNotVisibleAndIgnored() { [EOL] BeanPropertyMap beanPropertyMap = new BeanPropertyMap(false); [EOL] AnnotatedMethod annotatedMethod = new AnnotatedMethod(null, null, null, null); [EOL] String propertyName = "testProperty"; [EOL] beanPropertyMap.addGetter(annotatedMethod, propertyName, false, true); [EOL] assertFalse(beanPropertyMap.find(propertyName).isVisible()); [EOL] assertTrue(beanPropertyMap.find(propertyName).isIgnored()); [EOL] }
public void testAddSetterWithVisibleAndNotIgnored() { [EOL] BeanPropertyMap beanPropertyMap = new BeanPropertyMap(false); [EOL] AnnotatedMethod annotatedMethod = new AnnotatedMethod(null, null, null, null); [EOL] String ename = "testProperty"; [EOL] boolean visible = true; [EOL] boolean ignored = false; [EOL] beanPropertyMap.addSetter(annotatedMethod, ename, visible, ignored); [EOL] assertNotNull(beanPropertyMap.find(ename)); [EOL] assertTrue(beanPropertyMap.find(ename).hasNext()); [EOL] assertEquals(annotatedMethod, beanPropertyMap.find(ename).next().getMember()); [EOL] }
public void testAddSetterWithNotVisibleAndNotIgnored() { [EOL] BeanPropertyMap beanPropertyMap = new BeanPropertyMap(false); [EOL] AnnotatedMethod annotatedMethod = new AnnotatedMethod(null, null, null, null); [EOL] String ename = "testProperty"; [EOL] boolean visible = false; [EOL] boolean ignored = false; [EOL] beanPropertyMap.addSetter(annotatedMethod, ename, visible, ignored); [EOL] assertNotNull(beanPropertyMap.find(ename)); [EOL] assertTrue(beanPropertyMap.find(ename).hasNext()); [EOL] assertEquals(annotatedMethod, beanPropertyMap.find(ename).next().getMember()); [EOL] }
public void testAddSetterWithVisibleAndIgnored() { [EOL] BeanPropertyMap beanPropertyMap = new BeanPropertyMap(false); [EOL] AnnotatedMethod annotatedMethod = new AnnotatedMethod(null, null, null, null); [EOL] String ename = "testProperty"; [EOL] boolean visible = true; [EOL] boolean ignored = true; [EOL] beanPropertyMap.addSetter(annotatedMethod, ename, visible, ignored); [EOL] assertNotNull(beanPropertyMap.find(ename)); [EOL] assertFalse(beanPropertyMap.find(ename).hasNext()); [EOL] }
public void testAddSetterWithNotVisibleAndIgnored() { [EOL] BeanPropertyMap beanPropertyMap = new BeanPropertyMap(false); [EOL] AnnotatedMethod annotatedMethod = new AnnotatedMethod(null, null, null, null); [EOL] String ename = "testProperty"; [EOL] boolean visible = false; [EOL] boolean ignored = true; [EOL] beanPropertyMap.addSetter(annotatedMethod, ename, visible, ignored); [EOL] assertNotNull(beanPropertyMap.find(ename)); [EOL] assertFalse(beanPropertyMap.find(ename).hasNext()); [EOL] }
public void testRemoveIgnoredWithNonNullFields() { [EOL] setupWithFields(); [EOL] removeIgnored(); [EOL] assertNotNull(_fields); [EOL] assertTrue(_fields.isEmpty()); [EOL] } [EOL] public void testRemoveIgnoredWithNonNullGetters() { [EOL] setupWithGetters(); [EOL] removeIgnored(); [EOL] assertNotNull(_getters); [EOL] assertTrue(_getters.isEmpty()); [EOL] } [EOL] public void testRemoveIgnoredWithNonNullSetters() { [EOL] setupWithSetters(); [EOL] removeIgnored(); [EOL] assertNotNull(_setters); [EOL] assertTrue(_setters.isEmpty()); [EOL] } [EOL] public void testRemoveIgnoredWithNonNullCtorParameters() { [EOL] setupWithCtorParameters(); [EOL] removeIgnored(); [EOL] assertNotNull(_ctorParameters); [EOL] assertTrue(_ctorParameters.isEmpty()); [EOL] }

public void testRemoveNonVisibleWithForce() { [EOL] initializeMembersAsVisible(); [EOL] instance.removeNonVisible(true); [EOL] assertNull(instance._getters); [EOL] assertNull(instance._ctorParameters); [EOL] assertNull(instance._fields); [EOL] assertNull(instance._setters); [EOL] } [EOL] public void testRemoveNonVisibleWithoutForceAndWithNullGetters() { [EOL] initializeMembersWithNullGetters(); [EOL] instance.removeNonVisible(false); [EOL] assertNull(instance._fields); [EOL] assertNull(instance._setters); [EOL] assertNotNull(instance._ctorParameters); [EOL] } [EOL] public void testRemoveNonVisibleWithoutForceAndNonNullGetters() { [EOL] initializeMembersAsVisible(); [EOL] instance.removeNonVisible(false); [EOL] assertNotNull(instance._fields); [EOL] assertNotNull(instance._setters); [EOL] assertNull(instance._getters); [EOL] assertNull(instance._ctorParameters); [EOL] }

public void testTrimByVisibilityWithAllVisible() { [EOL] setupWithAllVisibleMembers(); [EOL] trimByVisibility(); [EOL] assertNotNull(_fields); [EOL] assertNotNull(_getters); [EOL] assertNotNull(_setters); [EOL] assertNotNull(_ctorParameters); [EOL] assertFalse(_fields.isEmpty()); [EOL] assertFalse(_getters.isEmpty()); [EOL] assertFalse(_setters.isEmpty()); [EOL] assertFalse(_ctorParameters.isEmpty()); [EOL] }
public void testTrimByVisibilityWithAllInvisible() { [EOL] setupWithAllInvisibleMembers(); [EOL] trimByVisibility(); [EOL] assertTrue(_fields.isEmpty()); [EOL] assertTrue(_getters.isEmpty()); [EOL] assertTrue(_setters.isEmpty()); [EOL] assertTrue(_ctorParameters.isEmpty()); [EOL] }
public void testMergeAnnotationsForSerializationWithGetters() { [EOL] setup(); [EOL] _getters = createMockedAnnotatedMember(); // Mocked method to create a non-null _getters object [EOL] _fields = null; [EOL] _ctorParameters = null; [EOL] _setters = null; [EOL] mergeAnnotations(true); [EOL] assertNotNull(_getters.value.getAnnotations()); [EOL] }
public void testMergeAnnotationsForSerializationWithFields() { [EOL] setup(); [EOL] _getters = null; [EOL] _fields = createMockedAnnotatedMember(); // Mocked method to create a non-null _fields object [EOL] _ctorParameters = null; [EOL] _setters = null; [EOL] mergeAnnotations(true); [EOL] assertNotNull(_fields.value.getAnnotations()); [EOL] }
public void testMergeAnnotationsNotForSerializationWithCtorParameters() { [EOL] setup(); [EOL] _getters = null; [EOL] _fields = null; [EOL] _ctorParameters = createMockedAnnotatedMember(); // Mocked method to create a non-null _ctorParameters object [EOL] _setters = null; [EOL] mergeAnnotations(false); [EOL] assertNotNull(_ctorParameters.value.getAnnotations()); [EOL] }
public void testMergeAnnotationsNotForSerializationWithSetters() { [EOL] setup(); [EOL] _getters = null; [EOL] _fields = null; [EOL] _ctorParameters = null; [EOL] _setters = createMockedAnnotatedMember(); // Mocked method to create a non-null _setters object [EOL] mergeAnnotations(false); [EOL] assertNotNull(_setters.value.getAnnotations()); [EOL] }
public void testMergeAnnotationsNotForSerializationWithFields() { [EOL] setup(); [EOL] _getters = null; [EOL] _fields = createMockedAnnotatedMember(); // Mocked method to create a non-null _fields object [EOL] _ctorParameters = null; [EOL] _setters = null; [EOL] mergeAnnotations(false); [EOL] assertNotNull(_fields.value.getAnnotations()); [EOL] }
public void testMergeAnnotationsWithSingleElement() { [EOL] Linked<AnnotatedMember> node = createLinkedAnnotatedMemberWithAnnotations(); [EOL] AnnotationMap result = _mergeAnnotations(0, node); [EOL] assertNotNull(result); [EOL] assertEquals(node.value.getAllAnnotations(), result); [EOL] } [EOL] public void testMergeAnnotationsWithMultipleElementsAllNull() { [EOL] Linked<AnnotatedMember>[] nodes = createArrayOfLinkedAnnotatedMembers(3); [EOL] AnnotationMap result = _mergeAnnotations(0, nodes); [EOL] assertNotNull(result); [EOL] assertTrue(result.isEmpty()); [EOL] } [EOL] public void testMergeAnnotationsWithMultipleElementsSomeNonNull() { [EOL] Linked<AnnotatedMember> firstNode = createLinkedAnnotatedMemberWithAnnotations(); [EOL] Linked<AnnotatedMember>[] nodes = createArrayOfLinkedAnnotatedMembers(3); [EOL] nodes[1] = firstNode; [EOL] AnnotationMap result = _mergeAnnotations(0, nodes); [EOL] assertNotNull(result); [EOL] assertNotEquals(firstNode.value.getAllAnnotations(), result); [EOL] } [EOL] public void testMergeAnnotationsWithNonNullFollowedByNull() { [EOL] Linked<AnnotatedMember> firstNode = createLinkedAnnotatedMemberWithAnnotations(); [EOL] Linked<AnnotatedMember>[] nodes = createArrayOfLinkedAnnotatedMembers(3); [EOL] nodes[0] = firstNode; [EOL] nodes[2] = createLinkedAnnotatedMemberWithAnnotations(); [EOL] AnnotationMap result = _mergeAnnotations(0, nodes); [EOL] assertNotNull(result); [EOL] assertNotEquals(firstNode.value.getAllAnnotations(), result); [EOL] }
public void testRemoveIgnoredWithNullNode() { [EOL] Linked<Object> result = _removeIgnored(null); [EOL] assertNull(result); [EOL] }
public void testRemoveIgnoredWithNonNullNode() { [EOL] Linked<Object> mockNode = mock(Linked.class); [EOL] when(mockNode.withoutIgnored()).thenReturn(null); [EOL] Linked<Object> result = _removeIgnored(mockNode); [EOL] assertNull(result); [EOL] verify(mockNode).withoutIgnored(); [EOL] }
public void testRemoveNonVisibleWithNullNode() { [EOL] Linked<Object> result = _removeNonVisible(null); [EOL] assertNull(result); [EOL] }
public void testRemoveNonVisibleWithNonNullNode() { [EOL] Linked<Object> mockNode = mock(Linked.class); [EOL] when(mockNode.withoutNonVisible()).thenReturn(null); [EOL] Linked<Object> result = _removeNonVisible(mockNode); [EOL] assertNull(result); [EOL] verify(mockNode).withoutNonVisible(); [EOL] }
public void testTrimByVisibilityWithNullNode() { [EOL] Linked<Object> node = null; [EOL] Linked<Object> result = _trimByVisibility(node); [EOL] assertNull(result); [EOL] }
public void testTrimByVisibilityWithNonNullNode() { [EOL] Linked<Object> node = new Linked<Object>(new Object(), null, false); [EOL] Linked<Object> trimmedNode = new Linked<Object>(new Object(), null, true); [EOL] when(node.trimByVisibility()).thenReturn(trimmedNode); [EOL] Linked<Object> result = _trimByVisibility(node); [EOL] assertSame(trimmedNode, result); [EOL] }
public void testAnyVisible_allFalse() { [EOL] BeanPropertyMap beanPropertyMap = new BeanPropertyMap(false); [EOL] assertFalse(beanPropertyMap.anyVisible()); [EOL] }
public void testAnyVisible_fieldsTrue() { [EOL] BeanPropertyMap beanPropertyMap = new BeanPropertyMap(false); [EOL] beanPropertyMap.assignFields(Collections.singletonList(mock(BeanPropertyDefinition.class)), false); [EOL] assertTrue(beanPropertyMap.anyVisible()); [EOL] }
public void testAnyVisible_gettersTrue() { [EOL] BeanPropertyMap beanPropertyMap = new BeanPropertyMap(false); [EOL] beanPropertyMap.assignGetters(Collections.singletonList(mock(BeanPropertyDefinition.class)), false); [EOL] assertTrue(beanPropertyMap.anyVisible()); [EOL] }
public void testAnyVisible_settersTrue() { [EOL] BeanPropertyMap beanPropertyMap = new BeanPropertyMap(false); [EOL] beanPropertyMap.assignSetters(Collections.singletonList(mock(BeanPropertyDefinition.class)), false); [EOL] assertTrue(beanPropertyMap.anyVisible()); [EOL] }
public void testAnyVisible_ctorParametersTrue() { [EOL] BeanPropertyMap beanPropertyMap = new BeanPropertyMap(false); [EOL] beanPropertyMap.assignCtorParameters(Collections.singletonList(mock(BeanPropertyDefinition.class)), false); [EOL] assertTrue(beanPropertyMap.anyVisible()); [EOL] }
public void testAnyVisibleWithAllInvisible() { [EOL] Linked<Object> first = new Linked<>(new Object(), false, null); [EOL] Linked<Object> second = new Linked<>(new Object(), false, first); [EOL] Linked<Object> third = new Linked<>(new Object(), false, second); [EOL] assertFalse(_anyVisible(third)); [EOL] } [EOL] public void testAnyVisibleWithOneVisible() { [EOL] Linked<Object> first = new Linked<>(new Object(), true, null); [EOL] Linked<Object> second = new Linked<>(new Object(), false, first); [EOL] Linked<Object> third = new Linked<>(new Object(), false, second); [EOL] assertTrue(_anyVisible(third)); [EOL] } [EOL] public void testAnyVisibleWithMultipleVisible() { [EOL] Linked<Object> first = new Linked<>(new Object(), true, null); [EOL] Linked<Object> second = new Linked<>(new Object(), true, first); [EOL] Linked<Object> third = new Linked<>(new Object(), false, second); [EOL] assertTrue(_anyVisible(third)); [EOL] } [EOL] public void testAnyVisibleWithEmptyList() { [EOL] Linked<Object> first = null; [EOL] assertFalse(_anyVisible(first)); [EOL] }
public void testAnyIgnorals_AllFalse() { [EOL] JacksonDatabindClass instance = new JacksonDatabindClass(); [EOL] instance.setFields(false); [EOL] instance.setGetters(false); [EOL] instance.setSetters(false); [EOL] instance.setCtorParameters(false); [EOL] boolean result = instance.anyIgnorals(); [EOL] assertFalse(result); [EOL] }
public void testAnyIgnorals_FieldsTrue() { [EOL] JacksonDatabindClass instance = new JacksonDatabindClass(); [EOL] instance.setFields(true); [EOL] instance.setGetters(false); [EOL] instance.setSetters(false); [EOL] instance.setCtorParameters(false); [EOL] boolean result = instance.anyIgnorals(); [EOL] assertTrue(result); [EOL] }
public void testAnyIgnorals_GettersTrue() { [EOL] JacksonDatabindClass instance = new JacksonDatabindClass(); [EOL] instance.setFields(false); [EOL] instance.setGetters(true); [EOL] instance.setSetters(false); [EOL] instance.setCtorParameters(false); [EOL] boolean result = instance.anyIgnorals(); [EOL] assertTrue(result); [EOL] }
public void testAnyIgnorals_SettersTrue() { [EOL] JacksonDatabindClass instance = new JacksonDatabindClass(); [EOL] instance.setFields(false); [EOL] instance.setGetters(false); [EOL] instance.setSetters(true); [EOL] instance.setCtorParameters(false); [EOL] boolean result = instance.anyIgnorals(); [EOL] assertTrue(result); [EOL] }
public void testAnyIgnorals_CtorParametersTrue() { [EOL] JacksonDatabindClass instance = new JacksonDatabindClass(); [EOL] instance.setFields(false); [EOL] instance.setGetters(false); [EOL] instance.setSetters(false); [EOL] instance.setCtorParameters(true); [EOL] boolean result = instance.anyIgnorals(); [EOL] assertTrue(result); [EOL] }
public void testAnyIgnoralsWithNoIgnoredElements() { [EOL] Linked<String> first = new Linked<>("first", null, false); [EOL] Linked<String> second = new Linked<>("second", first, false); [EOL] assertFalse(_anyIgnorals(second)); [EOL] }
public void testAnyIgnoralsWithOneIgnoredElement() { [EOL] Linked<String> first = new Linked<>("first", null, true); [EOL] Linked<String> second = new Linked<>("second", first, false); [EOL] assertTrue(_anyIgnorals(second)); [EOL] }
public void testAnyIgnoralsWithAllIgnoredElements() { [EOL] Linked<String> first = new Linked<>("first", null, true); [EOL] Linked<String> second = new Linked<>("second", first, true); [EOL] assertTrue(_anyIgnorals(second)); [EOL] }
public void testFindNewNameWithNoRenamedMembers() { [EOL] setupWithNoRenamedMembers(); [EOL] String newName = findNewName(); [EOL] assertNull(newName); [EOL] }
public void testFindNewNameWithRenamedFields() { [EOL] setupWithRenamedFields(); [EOL] String newName = findNewName(); [EOL] assertNotNull(newName); [EOL] assertEquals("expectedFieldName", newName); [EOL] }
public void testFindNewNameWithRenamedGetters() { [EOL] setupWithRenamedGetters(); [EOL] String newName = findNewName(); [EOL] assertNotNull(newName); [EOL] assertEquals("expectedGetterName", newName); [EOL] }
public void testFindNewNameWithRenamedSetters() { [EOL] setupWithRenamedSetters(); [EOL] String newName = findNewName(); [EOL] assertNotNull(newName); [EOL] assertEquals("expectedSetterName", newName); [EOL] }
public void testFindNewNameWithRenamedCtorParameters() { [EOL] setupWithRenamedCtorParameters(); [EOL] String newName = findNewName(); [EOL] assertNotNull(newName); [EOL] assertEquals("expectedCtorParameterName", newName); [EOL] }
public void testFindRenamedWithNullNode() { [EOL] Linked<AnnotatedMember> result = findRenamed(null, null); [EOL] assertNull(result); [EOL] }
public void testFindRenamedWithNonNullNodeAndNullRenamed() { [EOL] Linked<AnnotatedMember> node = new Linked<>(new AnnotatedMemberDummy(), null, null, false); [EOL] Linked<AnnotatedMember> result = findRenamed(node, null); [EOL] assertNotNull(result); [EOL] assertEquals(node, result); [EOL] }
public void testFindRenamedWithNonNullNodeAndNonNullRenamedSameName() { [EOL] Linked<AnnotatedMember> node = new Linked<>(new AnnotatedMemberDummy("sameName"), null, null, false); [EOL] Linked<AnnotatedMember> renamed = new Linked<>(new AnnotatedMemberDummy("sameName"), null, null, false); [EOL] Linked<AnnotatedMember> result = findRenamed(node, renamed); [EOL] assertNotNull(result); [EOL] assertEquals(renamed, result); [EOL] }
public void testFindRenamedWithNonNullNodeAndNonNullRenamedDifferentName() { [EOL] Linked<AnnotatedMember> node = new Linked<>(new AnnotatedMemberDummy("name1"), null, null, false); [EOL] Linked<AnnotatedMember> renamed = new Linked<>(new AnnotatedMemberDummy("name2"), null, null, false); [EOL] try { [EOL] findRenamed(node, renamed); [EOL] fail("Expected IllegalStateException to be thrown"); [EOL] } catch (IllegalStateException e) { [EOL] assertEquals("Conflicting property name definitions: 'name2' (for " + renamed.value + ") vs 'name1' (for " + node.value + ")", e.getMessage()); [EOL] } [EOL] }
public void testFromMemberAnnotationsWithNullIntrospector() { [EOL] _annotationIntrospector = null; [EOL] WithMember<Object> func = mock(WithMember.class); [EOL] Object result = fromMemberAnnotations(func); [EOL] assertNull(result); [EOL] }
public void testFromMemberAnnotationsForSerializationWithGetter() { [EOL] _annotationIntrospector = mock(AnnotationIntrospector.class); [EOL] _forSerialization = true; [EOL] _getters = mock(Member.class); [EOL] WithMember<Object> func = mock(WithMember.class); [EOL] Object expected = new Object(); [EOL] when(func.withMember(_getters.value)).thenReturn(expected); [EOL] Object result = fromMemberAnnotations(func); [EOL] assertSame(expected, result); [EOL] }
public void testFromMemberAnnotationsForDeserializationWithCtorParameters() { [EOL] _annotationIntrospector = mock(AnnotationIntrospector.class); [EOL] _forSerialization = false; [EOL] _ctorParameters = mock(Member.class); [EOL] WithMember<Object> func = mock(WithMember.class); [EOL] Object expected = new Object(); [EOL] when(func.withMember(_ctorParameters.value)).thenReturn(expected); [EOL] Object result = fromMemberAnnotations(func); [EOL] assertSame(expected, result); [EOL] }
public void testFromMemberAnnotationsForDeserializationWithSetters() { [EOL] _annotationIntrospector = mock(AnnotationIntrospector.class); [EOL] _forSerialization = false; [EOL] _ctorParameters = null; [EOL] _setters = mock(Member.class); [EOL] WithMember<Object> func = mock(WithMember.class); [EOL] Object expected = new Object(); [EOL] when(func.withMember(_setters.value)).thenReturn(expected); [EOL] Object result = fromMemberAnnotations(func); [EOL] assertSame(expected, result); [EOL] }
public void testFromMemberAnnotationsForDeserializationWithFields() { [EOL] _annotationIntrospector = mock(AnnotationIntrospector.class); [EOL] _forSerialization = false; [EOL] _ctorParameters = null; [EOL] _setters = null; [EOL] _fields = mock(Member.class); [EOL] WithMember<Object> func = mock(WithMember.class); [EOL] Object expected = new Object(); [EOL] when(func.withMember(_fields.value)).thenReturn(expected); [EOL] Object result = fromMemberAnnotations(func); [EOL] assertSame(expected, result); [EOL] }
public void testLinkedConstructorWithNullName() { [EOL] Linked<Object> nextLinked = new Linked<>(new Object(), null, null, true, false); [EOL] assertNull(nextLinked.explicitName); [EOL] assertTrue(nextLinked.isVisible); [EOL] assertFalse(nextLinked.isMarkedIgnored); [EOL] }
public void testLinkedConstructorWithEmptyName() { [EOL] Linked<Object> nextLinked = new Linked<>(new Object(), null, "", true, false); [EOL] assertNull(nextLinked.explicitName); [EOL] assertTrue(nextLinked.isVisible); [EOL] assertFalse(nextLinked.isMarkedIgnored); [EOL] }
public void testLinkedConstructorWithNonEmptyName() { [EOL] Linked<Object> nextLinked = new Linked<>(new Object(), null, "name", true, false); [EOL] assertEquals("name", nextLinked.explicitName); [EOL] assertTrue(nextLinked.isVisible); [EOL] assertFalse(nextLinked.isMarkedIgnored); [EOL] }
public void testLinkedConstructorWithVisibilityAndIgnoredFlags() { [EOL] Linked<Object> nextLinked = new Linked<>(new Object(), null, "name", false, true); [EOL] assertEquals("name", nextLinked.explicitName); [EOL] assertFalse(nextLinked.isVisible); [EOL] assertTrue(nextLinked.isMarkedIgnored); [EOL] }
public void testWithValueSameValue() { [EOL] Linked<String> original = new Linked<>("value", null, null, false, false); [EOL] Linked<String> result = original.withValue("value"); [EOL] assertSame(original, result); [EOL] }
public void testWithValueDifferentValue() { [EOL] Linked<String> original = new Linked<>("value", null, null, false, false); [EOL] Linked<String> result = original.withValue("newValue"); [EOL] assertNotNull(result); [EOL] assertNotSame(original, result); [EOL] assertEquals("newValue", result.value); [EOL] }
public void testWithNextSameInstance() { [EOL] Linked<Object> original = new Linked<>(null, null, null, false, false); [EOL] Linked<Object> result = original.withNext(null); [EOL] assertSame(original, result); [EOL] }
public void testWithNextDifferentInstance() { [EOL] Linked<Object> original = new Linked<>(null, null, null, false, false); [EOL] Linked<Object> newNext = new Linked<>(null, null, null, false, false); [EOL] Linked<Object> result = original.withNext(newNext); [EOL] assertNotNull(result); [EOL] assertNotSame(original, result); [EOL] assertSame(newNext, result.next); [EOL] }
public void testWithoutIgnored_MarkedIgnoredWithNext() { [EOL] Linked<Object> nextLinked = new Linked<>(new Object(), null, false); [EOL] Linked<Object> linked = new Linked<>(new Object(), nextLinked, true); [EOL] Linked<Object> result = linked.withoutIgnored(); [EOL] assertNull(result); [EOL] }
public void testWithoutIgnored_MarkedIgnoredWithoutNext() { [EOL] Linked<Object> linked = new Linked<>(new Object(), null, true); [EOL] Linked<Object> result = linked.withoutIgnored(); [EOL] assertNull(result); [EOL] }
public void testWithoutIgnored_NotMarkedIgnoredWithUnchangedNext() { [EOL] Linked<Object> nextLinked = new Linked<>(new Object(), null, false); [EOL] Linked<Object> linked = new Linked<>(new Object(), nextLinked, false); [EOL] Linked<Object> result = linked.withoutIgnored(); [EOL] assertSame(linked, result); [EOL] }
public void testWithoutIgnored_NotMarkedIgnoredWithChangedNext() { [EOL] Linked<Object> nextLinked = new Linked<>(new Object(), null, true); [EOL] Linked<Object> newNextLinked = new Linked<>(new Object(), null, false); [EOL] Linked<Object> linked = new Linked<>(new Object(), nextLinked, false) { [EOL] @Override [EOL] public Linked<Object> withoutIgnored() { [EOL] return newNextLinked; [EOL] } [EOL] }; [EOL] Linked<Object> result = linked.withoutIgnored(); [EOL] assertNotSame(nextLinked, result.next); [EOL] assertSame(newNextLinked, result.next); [EOL] }
public void testWithoutNonVisible_IsVisibleTrue() { [EOL] Linked<Object> original = new Linked<>(new Object(), true, null); [EOL] Linked<Object> result = original.withoutNonVisible(); [EOL] assertNotNull(result); [EOL] assertTrue(result.isVisible); [EOL] assertNull(result.next); [EOL] }
public void testWithoutNonVisible_IsVisibleFalse() { [EOL] Linked<Object> original = new Linked<>(new Object(), false, null); [EOL] Linked<Object> result = original.withoutNonVisible(); [EOL] assertNull(result); [EOL] }
public void testWithoutNonVisible_WithNextVisible() { [EOL] Linked<Object> next = new Linked<>(new Object(), true, null); [EOL] Linked<Object> original = new Linked<>(new Object(), true, next); [EOL] Linked<Object> result = original.withoutNonVisible(); [EOL] assertNotNull(result); [EOL] assertNotNull(result.next); [EOL] assertTrue(result.next.isVisible); [EOL] }
public void testWithoutNonVisible_WithNextNonVisible() { [EOL] Linked<Object> next = new Linked<>(new Object(), false, null); [EOL] Linked<Object> original = new Linked<>(new Object(), true, next); [EOL] Linked<Object> result = original.withoutNonVisible(); [EOL] assertNotNull(result); [EOL] assertNull(result.next); [EOL] }
public void testWithoutNonVisible_WithMultipleNext() { [EOL] Linked<Object> nextNext = new Linked<>(new Object(), true, null); [EOL] Linked<Object> next = new Linked<>(new Object(), false, nextNext); [EOL] Linked<Object> original = new Linked<>(new Object(), true, next); [EOL] Linked<Object> result = original.withoutNonVisible(); [EOL] assertNotNull(result); [EOL] assertNotNull(result.next); [EOL] assertTrue(result.next.isVisible); [EOL] }
public void testTrimByVisibility_WithNextNull() { [EOL] Linked<Object> linked = new Linked<>(null, null, null, true); [EOL] Linked<Object> result = linked.trimByVisibility(); [EOL] assertSame(linked, result); [EOL] }
public void testTrimByVisibility_WithNextAndExplicitName() { [EOL] Linked<Object> next = new Linked<>(null, null, null, true); [EOL] Linked<Object> linked = new Linked<>(null, next, "explicitName", true); [EOL] Linked<Object> trimmedNext = next.trimByVisibility(); [EOL] Linked<Object> result = linked.trimByVisibility(); [EOL] assertNotNull(result.getNext()); [EOL] assertEquals("explicitName", result.getExplicitName()); [EOL] }
public void testTrimByVisibility_WithNextAndDifferentVisibility() { [EOL] Linked<Object> next = new Linked<>(null, null, null, false); [EOL] Linked<Object> linked = new Linked<>(null, next, null, true); [EOL] Linked<Object> result = linked.trimByVisibility(); [EOL] assertNull(result.getNext()); [EOL] }
public void testTrimByVisibility_WithNextAndSameVisibility() { [EOL] Linked<Object> next = new Linked<>(null, null, null, true); [EOL] Linked<Object> linked = new Linked<>(null, next, null, true); [EOL] Linked<Object> result = linked.trimByVisibility(); [EOL] assertNotNull(result.getNext()); [EOL] assertEquals(next, result.getNext()); [EOL] }
public void testTrimByVisibility_WithNextAndExplicitNameInNext() { [EOL] Linked<Object> next = new Linked<>(null, null, "explicitNameInNext", true); [EOL] Linked<Object> linked = new Linked<>(null, next, null, true); [EOL] Linked<Object> result = linked.trimByVisibility(); [EOL] assertEquals(next, result); [EOL] }
public void testAsTextWithPositiveValue() { [EOL] DoubleNode node = new DoubleNode(10.5); [EOL] String result = node.asText(); [EOL] assertEquals("10.5", result); [EOL] }
public void testAsTextWithNegativeValue() { [EOL] DoubleNode node = new DoubleNode(-10.5); [EOL] String result = node.asText(); [EOL] assertEquals("-10.5", result); [EOL] }
public void testAsTextWithZeroValue() { [EOL] DoubleNode node = new DoubleNode(0.0); [EOL] String result = node.asText(); [EOL] assertEquals("0.0", result); [EOL] }
public void testSerialize() throws IOException, JsonProcessingException { [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] SerializerProvider mockSerializerProvider = mock(SerializerProvider.class); [EOL] MyValueSerializer serializer = new MyValueSerializer(); [EOL] int valueToSerialize = 10; [EOL] serializer._value = valueToSerialize; // Assuming _value is a field to be serialized [EOL] serializer.serialize(mockJsonGenerator, mockSerializerProvider); [EOL] verify(mockJsonGenerator).writeNumber(valueToSerialize); [EOL] }
public void testIsValueNodeWithArrayNode() { [EOL] JsonNode arrayNode = JsonNodeFactory.instance.arrayNode(); [EOL] assertFalse(arrayNode.isValueNode()); [EOL] }
public void testIsValueNodeWithObjectNode() { [EOL] JsonNode objectNode = JsonNodeFactory.instance.objectNode(); [EOL] assertFalse(objectNode.isValueNode()); [EOL] }
public void testIsValueNodeWithMissingNode() { [EOL] JsonNode missingNode = MissingNode.getInstance(); [EOL] assertFalse(missingNode.isValueNode()); [EOL] }
public void testIsValueNodeWithValueNode() { [EOL] JsonNode valueNode = TextNode.valueOf("test"); [EOL] assertTrue(valueNode.isValueNode()); [EOL] }
public void testIsBinary_NodeTypeBinary() { [EOL] JsonNode node = mock(JsonNode.class); [EOL] when(node.getNodeType()).thenReturn(JsonNodeType.BINARY); [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] JsonNode binaryNode = mapper.getNodeFactory().binaryNode(new byte[0]); [EOL] assertTrue(binaryNode.isBinary()); [EOL] }
public void testIsBinary_NodeTypeNotBinary() { [EOL] JsonNode node = mock(JsonNode.class); [EOL] when(node.getNodeType()).thenReturn(JsonNodeType.ARRAY); [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] JsonNode arrayNode = mapper.getNodeFactory().arrayNode(); [EOL] assertFalse(arrayNode.isBinary()); [EOL] }
public boolean asBoolean_defaultValue() { [EOL] JsonNode node = new BooleanNode(true); [EOL] assertTrue(node.asBoolean()); [EOL] }
public boolean asBoolean_defaultValueFalse() { [EOL] JsonNode node = new BooleanNode(false); [EOL] assertFalse(node.asBoolean()); [EOL] }
public boolean asBooleanTestWithTrueDefault() { [EOL] boolean defaultValue = true; [EOL] boolean result = asBoolean(defaultValue); [EOL] assert result == defaultValue; [EOL] }
public boolean asBooleanTestWithFalseDefault() { [EOL] boolean defaultValue = false; [EOL] boolean result = asBoolean(defaultValue); [EOL] assert result == defaultValue; [EOL] }
public void testUpdatePropertiesWithEmptyList() { [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] List<BeanPropertyDefinition> propDefs = new ArrayList<>(); [EOL] List<BeanPropertyDefinition> result = updateProperties(config, beanDesc, propDefs); [EOL] assertTrue(result.isEmpty()); [EOL] }
public void testUpdatePropertiesWithNonEmptyList() { [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] List<BeanPropertyDefinition> propDefs = new ArrayList<>(); [EOL] propDefs.add(mock(BeanPropertyDefinition.class)); [EOL] List<BeanPropertyDefinition> result = updateProperties(config, beanDesc, propDefs); [EOL] assertFalse(result.isEmpty()); [EOL] assertEquals(propDefs.size(), result.size()); [EOL] }
public void testUpdateBuilderWithNonNullValues() { [EOL] DeserializationConfig config = new DeserializationConfig(...); // Provide actual initialization [EOL] BeanDescription beanDesc = new BeanDescription(...); // Provide actual initialization [EOL] BeanDeserializerBuilder builder = new BeanDeserializerBuilder(...); // Provide actual initialization [EOL] BeanDeserializerBuilder result = updateBuilder(config, beanDesc, builder); [EOL] assertSame("The returned builder should be the same as the passed builder", builder, result); [EOL] }
public void testModifyDeserializerReturnsSameDeserializer() { [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] JsonDeserializer<?> originalDeserializer = mock(JsonDeserializer.class); [EOL] JsonDeserializer<?> modifiedDeserializer = modifyDeserializer(config, beanDesc, originalDeserializer); [EOL] assertSame(originalDeserializer, modifiedDeserializer); [EOL] }
public void testModifyMapDeserializer_ReturnsSameDeserializer() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] DeserializationConfig config = mapper.getDeserializationConfig(); [EOL] MapType type = (MapType) mapper.getTypeFactory().constructMapType(HashMap.class, String.class, String.class); [EOL] BeanDescription beanDesc = config.introspect(type); [EOL] JsonDeserializer<?> originalDeserializer = new MapDeserializer(type, null, null, null, null); [EOL] DeserializationModifier modifier = new DeserializationModifier(); [EOL] JsonDeserializer<?> modifiedDeserializer = modifier.modifyMapDeserializer(config, type, beanDesc, originalDeserializer); [EOL] assertSame("modifyMapDeserializer should return the original deserializer", originalDeserializer, modifiedDeserializer); [EOL] }
public void testFindSuperTypesWithNullClass() { [EOL] List<Class<?>> result = ObjectMapper.findSuperTypes(null, Object.class); [EOL] assertNotNull(result); [EOL] assertTrue(result.isEmpty()); [EOL] }
public void testFindSuperTypesWithObjectClass() { [EOL] List<Class<?>> result = ObjectMapper.findSuperTypes(Object.class, null); [EOL] assertNotNull(result); [EOL] assertEquals(0, result.size()); [EOL] }
public void testFindSuperTypesWithRegularClass() { [EOL] List<Class<?>> result = ObjectMapper.findSuperTypes(String.class, Object.class); [EOL] assertNotNull(result); [EOL] assertTrue(result.contains(CharSequence.class)); [EOL] assertTrue(result.contains(Comparable.class)); [EOL] assertTrue(result.contains(Serializable.class)); [EOL] }
public void testFindSuperTypesStoppingAtEndBefore() { [EOL] List<Class<?>> result = ObjectMapper.findSuperTypes(String.class, CharSequence.class); [EOL] assertNotNull(result); [EOL] assertFalse(result.contains(CharSequence.class)); [EOL] assertTrue(result.contains(Comparable.class)); [EOL] assertTrue(result.contains(Serializable.class)); [EOL] }
public void testFindSuperTypesWithNullEndBeforeAndEmptyResult() { [EOL] List<Class<?>> result = new ArrayList<>(); [EOL] List<Class<?>> superTypes = ClassName.findSuperTypes(Object.class, null, result); [EOL] assertNotNull(superTypes); [EOL] assertTrue(superTypes.contains(Object.class)); [EOL] }
public void testFindSuperTypesWithNonNullEndBeforeAndEmptyResult() { [EOL] List<Class<?>> result = new ArrayList<>(); [EOL] List<Class<?>> superTypes = ClassName.findSuperTypes(ArrayList.class, Object.class, result); [EOL] assertNotNull(superTypes); [EOL] assertFalse(superTypes.contains(Object.class)); [EOL] assertTrue(superTypes.contains(List.class)); [EOL] assertTrue(superTypes.contains(Collection.class)); [EOL] assertTrue(superTypes.contains(Iterable.class)); [EOL] }
public void testFindSuperTypesWithNullEndBeforeAndNonEmptyResult() { [EOL] List<Class<?>> result = new ArrayList<>(); [EOL] result.add(Serializable.class); [EOL] List<Class<?>> superTypes = ClassName.findSuperTypes(ArrayList.class, null, result); [EOL] assertNotNull(superTypes); [EOL] assertTrue(superTypes.contains(Serializable.class)); [EOL] assertTrue(superTypes.contains(List.class)); [EOL] assertTrue(superTypes.contains(Collection.class)); [EOL] assertTrue(superTypes.contains(Iterable.class)); [EOL] }
public void testFindSuperTypesWithNonNullEndBeforeAndNonEmptyResult() { [EOL] List<Class<?>> result = new ArrayList<>(); [EOL] result.add(Cloneable.class); [EOL] List<Class<?>> superTypes = ClassName.findSuperTypes(ArrayList.class, Object.class, result); [EOL] assertNotNull(superTypes); [EOL] assertTrue(superTypes.contains(Cloneable.class)); [EOL] assertFalse(superTypes.contains(Object.class)); [EOL] assertTrue(superTypes.contains(List.class)); [EOL] assertTrue(superTypes.contains(Collection.class)); [EOL] assertTrue(superTypes.contains(Iterable.class)); [EOL] }
public void testAddSuperTypesWithNullClass() { [EOL] Collection<Class<?>> result = new HashSet<>(); [EOL] _addSuperTypes(null, Object.class, result, true); [EOL] assertTrue(result.isEmpty()); [EOL] }
public void testAddSuperTypesWithObjectClass() { [EOL] Collection<Class<?>> result = new HashSet<>(); [EOL] _addSuperTypes(Object.class, null, result, true); [EOL] assertTrue(result.isEmpty()); [EOL] }
public void testAddSuperTypesWithEndBeforeClass() { [EOL] Collection<Class<?>> result = new HashSet<>(); [EOL] _addSuperTypes(String.class, String.class, result, true); [EOL] assertTrue(result.isEmpty()); [EOL] }
public void testAddSuperTypesAddClassItself() { [EOL] Collection<Class<?>> result = new HashSet<>(); [EOL] _addSuperTypes(String.class, Object.class, result, true); [EOL] assertTrue(result.contains(String.class)); [EOL] }
public void testAddSuperTypesDoNotAddClassItself() { [EOL] Collection<Class<?>> result = new HashSet<>(); [EOL] _addSuperTypes(String.class, Object.class, result, false); [EOL] assertFalse(result.contains(String.class)); [EOL] }
public void testAddSuperTypesWithInterface() { [EOL] Collection<Class<?>> result = new HashSet<>(); [EOL] _addSuperTypes(ArrayList.class, Object.class, result, true); [EOL] assertTrue(result.contains(List.class)); [EOL] }
public void testAddSuperTypesWithSuperclass() { [EOL] Collection<Class<?>> result = new HashSet<>(); [EOL] _addSuperTypes(ArrayList.class, Object.class, result, true); [EOL] assertTrue(result.contains(AbstractList.class)); [EOL] }
public void testIsProxyTypeWithCglibProxy() { [EOL] boolean result = YourClass.isProxyType(net.sf.cglib.proxy.Enhancer.class); [EOL] assert result; [EOL] }
public void testIsProxyTypeWithHibernateProxy() { [EOL] boolean result = YourClass.isProxyType(org.hibernate.proxy.HibernateProxy.class); [EOL] assert result; [EOL] }
public void testIsProxyTypeWithNonProxy() { [EOL] boolean result = YourClass.isProxyType(String.class); [EOL] assert !result; [EOL] }
public void testIsCollectionMapOrArrayWithArray() { [EOL] boolean result = YourClass.isCollectionMapOrArray(String[].class); [EOL] assertTrue(result); [EOL] }
public void testIsCollectionMapOrArrayWithCollection() { [EOL] boolean result = YourClass.isCollectionMapOrArray(ArrayList.class); [EOL] assertTrue(result); [EOL] }
public void testIsCollectionMapOrArrayWithMap() { [EOL] boolean result = YourClass.isCollectionMapOrArray(HashMap.class); [EOL] assertTrue(result); [EOL] }
public void testIsCollectionMapOrArrayWithNonCollectionNonMapNonArray() { [EOL] boolean result = YourClass.isCollectionMapOrArray(String.class); [EOL] assertFalse(result); [EOL] }
public void testCollectionTypeCreation() { [EOL] Class<?> collT = List.class; [EOL] JavaType elemT = mock(JavaType.class); [EOL] Object valueHandler = mock(Object.class); [EOL] Object typeHandler = mock(Object.class); [EOL] boolean asStatic = true; [EOL] CollectionType collectionType = createCollectionType(collT, elemT, valueHandler, typeHandler, asStatic); [EOL] assertNotNull(collectionType); [EOL] assertEquals(collT, collectionType.getCollectionClass()); [EOL] assertEquals(elemT, collectionType.getContentType()); [EOL] }
public void testNarrowWithNonNullClass() { [EOL] CollectionType originalType = new CollectionType(Collection.class, SimpleType.constructUnsafe(String.class), null, null, false); [EOL] Class<?> subclass = List.class; [EOL] JavaType narrowedType = originalType._narrow(subclass); [EOL] assertNotNull(narrowedType); [EOL] assertTrue(narrowedType instanceof CollectionType); [EOL] assertEquals(subclass, narrowedType.getRawClass()); [EOL] }
public void testNarrowWithNullClass() { [EOL] CollectionType originalType = new CollectionType(Collection.class, SimpleType.constructUnsafe(String.class), null, null, false); [EOL] try { [EOL] JavaType narrowedType = originalType._narrow(null); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testNarrowContentsBy_SameClass() { [EOL] Class<?> contentClass = String.class; [EOL] JavaType elementType = TypeFactory.defaultInstance().constructType(String.class); [EOL] CollectionType collectionType = TypeFactory.defaultInstance().constructCollectionType(ArrayList.class, String.class); [EOL] JavaType result = collectionType.narrowContentsBy(contentClass); [EOL] assertSame(collectionType, result); [EOL] }
public void testNarrowContentsBy_DifferentClass() { [EOL] Class<?> contentClass = Integer.class; [EOL] JavaType elementType = TypeFactory.defaultInstance().constructType(String.class); [EOL] CollectionType collectionType = TypeFactory.defaultInstance().constructCollectionType(ArrayList.class, String.class); [EOL] JavaType result = collectionType.narrowContentsBy(contentClass); [EOL] assertNotNull(result); [EOL] assertNotSame(collectionType, result); [EOL] assertTrue(result instanceof CollectionType); [EOL] assertEquals(Integer.class, result.getContentType().getRawClass()); [EOL] }
public void testWidenContentsBy_SameClass() { [EOL] CollectionType originalType = new CollectionType(Collection.class, _elementType, null, null, false); [EOL] JavaType resultType = originalType.widenContentsBy(_elementType.getRawClass()); [EOL] assertSame("Types should be the same when widening by the same class", originalType, resultType); [EOL] }
public void testWidenContentsBy_DifferentClass() { [EOL] CollectionType originalType = new CollectionType(Collection.class, _elementType, null, null, false); [EOL] JavaType resultType = originalType.widenContentsBy(String.class); [EOL] assertNotSame("Types should not be the same when widening by a different class", originalType, resultType); [EOL] assertTrue("Result should be instance of CollectionType", resultType instanceof CollectionType); [EOL] assertEquals("Element type should be widened to the new class", String.class, resultType.getContentType().getRawClass()); [EOL] }
public void testConstructWithNonNullTypes() { [EOL] Class<?> rawType = List.class; [EOL] JavaType elemType = TypeFactory.defaultInstance().constructType(String.class); [EOL] CollectionType collectionType = CollectionType.construct(rawType, elemType); [EOL] assertNotNull(collectionType); [EOL] assertEquals(rawType, collectionType.getRawClass()); [EOL] assertEquals(elemType, collectionType.getContentType()); [EOL] }
public void testConstructWithNullTypes() { [EOL] Class<?> rawType = null; [EOL] JavaType elemType = null; [EOL] try { [EOL] CollectionType.construct(rawType, elemType); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testToString() { [EOL] CollectionType collectionType = new CollectionType(Collection.class, SimpleType.constructUnsafe(String.class)); [EOL] String result = collectionType.toString(); [EOL] assertTrue(result.contains("[collection type; class java.util.Collection, contains ")); [EOL] assertTrue(result.contains("java.lang.String")); [EOL] }
public void testStdDelegatingDeserializerWithNonNullConverter() { [EOL] Converter<Object, String> converter = new Converter<Object, String>() { [EOL] @Override [EOL] public String convert(Object value) { [EOL] return value.toString(); [EOL] } [EOL] }; [EOL] StdDelegatingDeserializer<String> deserializer = new StdDelegatingDeserializer<>(converter); [EOL] assertNotNull(deserializer); [EOL] assertEquals(converter, deserializer.getConverter()); [EOL] }
public void testStdDelegatingDeserializerWithNullConverter() { [EOL] Converter<Object, String> converter = null; [EOL] try { [EOL] new StdDelegatingDeserializer<>(converter); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testWithDelegateUsingStdDelegatingDeserializer() { [EOL] Converter<Object, String> converter = new Converter<Object, String>() { [EOL] @Override [EOL] public String convert(Object value) { [EOL] return value.toString(); [EOL] } [EOL] }; [EOL] JavaType delegateType = TypeFactory.defaultInstance().constructType(String.class); [EOL] JsonDeserializer<?> delegateDeserializer = new StdDeserializer<String>(String.class) { [EOL] @Override [EOL] public String deserialize(JsonParser p, DeserializationContext ctxt) throws IOException { [EOL] return p.getText(); [EOL] } [EOL] }; [EOL] StdDelegatingDeserializer<String> deserializer = new StdDelegatingDeserializer<>(converter, delegateType, delegateDeserializer); [EOL] StdDelegatingDeserializer<String> result = deserializer.withDelegate(converter, delegateType, delegateDeserializer); [EOL] assertNotNull(result); [EOL] }
public void testWithDelegateUsingSubClass() { [EOL] class SubClassDelegatingDeserializer extends StdDelegatingDeserializer<String> { [EOL] public SubClassDelegatingDeserializer(Converter<Object, String> converter, JavaType delegateType, JsonDeserializer<?> delegateDeserializer) { [EOL] super(converter, delegateType, delegateDeserializer); [EOL] } [EOL] @Override [EOL] protected StdDelegatingDeserializer<String> withDelegate(Converter<Object, String> converter, JavaType delegateType, JsonDeserializer<?> delegateDeserializer) { [EOL] return this; // Just return this for testing purposes [EOL] } [EOL] } [EOL] Converter<Object, String> converter = new Converter<Object, String>() { [EOL] @Override [EOL] public String convert(Object value) { [EOL] return value.toString(); [EOL] } [EOL] }; [EOL] JavaType delegateType = TypeFactory.defaultInstance().constructType(String.class); [EOL] JsonDeserializer<?> delegateDeserializer = new StdDeserializer<String>(String.class) { [EOL] @Override [EOL] public String deserialize(JsonParser p, DeserializationContext ctxt) throws IOException { [EOL] return p.getText(); [EOL] } [EOL] }; [EOL] SubClassDelegatingDeserializer deserializer = new SubClassDelegatingDeserializer(converter, delegateType, delegateDeserializer); [EOL] try { [EOL] deserializer.withDelegate(converter, delegateType, delegateDeserializer); [EOL] fail("Expected IllegalStateException to be thrown"); [EOL] } catch (IllegalStateException e) { [EOL] assertEquals("Sub-class " + deserializer.getClass().getName() + " must override 'withDelegate'", e.getMessage()); [EOL] } [EOL] }
public void testCreateContextualWithNonNullDelegateDeserializerAndContextualDeserializer() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] JsonDeserializer<?> delegateDeserializer = mock(JsonDeserializer.class); [EOL] ContextualDeserializer contextualDeserializer = mock(ContextualDeserializer.class); [EOL] JsonDeserializer<?> newDelegateDeserializer = mock(JsonDeserializer.class); [EOL] Converter<Object, Object> converter = mock(Converter.class); [EOL] JavaType delegateType = mock(JavaType.class); [EOL] when(_delegateDeserializer).thenReturn(contextualDeserializer); [EOL] when(contextualDeserializer.createContextual(ctxt, property)).thenReturn(newDelegateDeserializer); [EOL] when(newDelegateDeserializer.equals(_delegateDeserializer)).thenReturn(false); [EOL] when(_converter).thenReturn(converter); [EOL] when(_delegateType).thenReturn(delegateType); [EOL] JsonDeserializer<?> result = createContextual(ctxt, property); [EOL] verify(contextualDeserializer).createContextual(ctxt, property); [EOL] assertNotSame(_delegateDeserializer, result); [EOL] }
public void testCreateContextualWithNonNullDelegateDeserializerButNotContextual() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] JsonDeserializer<?> delegateDeserializer = mock(JsonDeserializer.class); [EOL] when(_delegateDeserializer).thenReturn(delegateDeserializer); [EOL] when(delegateDeserializer instanceof ContextualDeserializer).thenReturn(false); [EOL] JsonDeserializer<?> result = createContextual(ctxt, property); [EOL] assertSame(this, result); [EOL] }
public void testCreateContextualWithNullDelegateDeserializer() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] Converter<Object, Object> converter = mock(Converter.class); [EOL] JavaType delegateType = mock(JavaType.class); [EOL] JsonDeserializer<?> valueDeserializer = mock(JsonDeserializer.class); [EOL] TypeFactory typeFactory = mock(TypeFactory.class); [EOL] when(_delegateDeserializer).thenReturn(null); [EOL] when(_converter).thenReturn(converter); [EOL] when(ctxt.getTypeFactory()).thenReturn(typeFactory); [EOL] when(converter.getInputType(typeFactory)).thenReturn(delegateType); [EOL] when(ctxt.findContextualValueDeserializer(delegateType, property)).thenReturn(valueDeserializer); [EOL] JsonDeserializer<?> result = createContextual(ctxt, property); [EOL] verify(ctxt).findContextualValueDeserializer(delegateType, property); [EOL] assertNotNull(result); [EOL] }
public void testWithValueTypeSerializerNonNull() { [EOL] TypeSerializer typeSerializer = mock(TypeSerializer.class); [EOL] EnumMapSerializer originalSerializer = new EnumMapSerializer(null, false, null, null, null); [EOL] EnumMapSerializer newSerializer = originalSerializer._withValueTypeSerializer(typeSerializer); [EOL] assertNotNull(newSerializer); [EOL] }
public void testWithValueTypeSerializerNull() { [EOL] EnumMapSerializer originalSerializer = new EnumMapSerializer(null, false, null, null, null); [EOL] EnumMapSerializer newSerializer = originalSerializer._withValueTypeSerializer(null); [EOL] assertNotNull(newSerializer); [EOL] }
public void testCreateContextualWithNonNullPropertyAndMember() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] AnnotatedMember member = mock(AnnotatedMember.class); [EOL] JsonSerializer<Object> expectedSerializer = mock(JsonSerializer.class); [EOL] AnnotationIntrospector introspector = mock(AnnotationIntrospector.class); [EOL] when(property.getMember()).thenReturn(member); [EOL] when(provider.getAnnotationIntrospector()).thenReturn(introspector); [EOL] when(introspector.findContentSerializer(member)).thenReturn(expectedSerializer); [EOL] when(provider.serializerInstance(member, expectedSerializer)).thenReturn(expectedSerializer); [EOL] JsonSerializer<?> result = createContextual(provider, property); [EOL] assertSame(expectedSerializer, result); [EOL] }
public void testCreateContextualWithNullProperty() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] JsonSerializer<?> result = createContextual(provider, null); [EOL] assertSame(_valueSerializer, result); [EOL] }
public void testCreateContextualWithNonNullPropertyAndNullMember() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] when(property.getMember()).thenReturn(null); [EOL] JsonSerializer<?> result = createContextual(provider, property); [EOL] assertSame(_valueSerializer, result); [EOL] }
public void testCreateContextualWithStaticTyping() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] _staticTyping = true; [EOL] JsonSerializer<?> result = createContextual(provider, property); [EOL] assertNotNull(result); [EOL] assertNotSame(this, result); [EOL] }
public void testCreateContextualWithNonContextualValueSerializer() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] JsonSerializer<Object> nonContextualSerializer = mock(JsonSerializer.class); [EOL] when(_valueSerializer instanceof ContextualSerializer).thenReturn(false); [EOL] JsonSerializer<?> result = createContextual(provider, property); [EOL] assertSame(_valueSerializer, result); [EOL] }
public void testCreateContextualWithChangedValueSerializer() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] JsonSerializer<Object> newSerializer = mock(JsonSerializer.class); [EOL] ContextualSerializer contextualSerializer = mock(ContextualSerializer.class); [EOL] when(_valueSerializer instanceof ContextualSerializer).thenReturn(true); [EOL] when(((ContextualSerializer) _valueSerializer).createContextual(provider, property)).thenReturn(newSerializer); [EOL] JsonSerializer<?> result = createContextual(provider, property); [EOL] assertSame(newSerializer, result); [EOL] }
protected void serializeContents(EnumMap<? extends Enum<?>, ?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL] if (_valueSerializer != null) { [EOL] serializeContentsUsing(value, jgen, provider, _valueSerializer); [EOL] return; [EOL] } [EOL] JsonSerializer<Object> prevSerializer = null; [EOL] Class<?> prevClass = null; [EOL] EnumValues keyEnums = _keyEnums; [EOL] final boolean skipNulls = !provider.isEnabled(SerializationFeature.WRITE_NULL_MAP_VALUES); [EOL] final TypeSerializer vts = _valueTypeSerializer; [EOL] for (Map.Entry<? extends Enum<?>, ?> entry : value.entrySet()) { [EOL] final Object valueElem = entry.getValue(); [EOL] if (skipNulls && valueElem == null) { [EOL] continue; [EOL] } [EOL] Enum<?> key = entry.getKey(); [EOL] if (keyEnums == null) { [EOL] StdSerializer<?> ser = (StdSerializer<?>) provider.findValueSerializer(key.getDeclaringClass(), _property); [EOL] keyEnums = ((EnumSerializer) ser).getEnumValues(); [EOL] } [EOL] jgen.writeFieldName(keyEnums.serializedValueFor(key)); [EOL] if (valueElem == null) { [EOL] provider.defaultSerializeNull(jgen); [EOL] continue; [EOL] } [EOL] Class<?> cc = valueElem.getClass(); [EOL] JsonSerializer<Object> currSerializer; [EOL] if (cc == prevClass) { [EOL] currSerializer = prevSerializer; [EOL] } else { [EOL] currSerializer = provider.findValueSerializer(cc, _property); [EOL] prevSerializer = currSerializer; [EOL] prevClass = cc; [EOL] } [EOL] try { [EOL] if (vts == null) { [EOL] currSerializer.serialize(valueElem, jgen, provider); [EOL] } else { [EOL] currSerializer.serializeWithType(valueElem, jgen, provider, vts); [EOL] } [EOL] } catch (Exception e) { [EOL] wrapAndThrow(provider, e, value, entry.getKey().name()); [EOL] } [EOL] } [EOL] }
public void testSerializerFactoryConfigDefaultConstructor() { [EOL] SerializerFactoryConfig config = new SerializerFactoryConfig(); [EOL] assertNull(config.additionalKeySerializers()); [EOL] assertNull(config.additionalSerializers()); [EOL] assertNull(config.modifiers()); [EOL] }
public void testHasSerializerModifiers_WithModifiers() { [EOL] SerializerFactoryConfig config = new SerializerFactoryConfig(); [EOL] BeanSerializerModifier modifier = new BeanSerializerModifier() {}; [EOL] config = config.withSerializerModifier(modifier); [EOL] assertTrue(config.hasSerializerModifiers()); [EOL] }
public void testHasSerializerModifiers_WithoutModifiers() { [EOL] SerializerFactoryConfig config = new SerializerFactoryConfig(); [EOL] assertFalse(config.hasSerializerModifiers()); [EOL] }
public void testSerializersWithNonNullAdditionalSerializers() { [EOL] SimpleModule module = new SimpleModule(); [EOL] JsonSerializer<?>[] serializersArray = {new SomeSerializer(), new AnotherSerializer()}; [EOL] module.addSerializers(serializersArray); [EOL] Iterable<Serializers> serializersIterable = module.serializers(); [EOL] assertNotNull(serializersIterable); [EOL] Iterator<Serializers> iterator = serializersIterable.iterator(); [EOL] assertTrue(iterator.hasNext()); [EOL] assertSame(serializersArray[0], iterator.next()); [EOL] assertTrue(iterator.hasNext()); [EOL] assertSame(serializersArray[1], iterator.next()); [EOL] assertFalse(iterator.hasNext()); [EOL] }
public void testSerializersWithNullAdditionalSerializers() { [EOL] SimpleModule module = new SimpleModule(); [EOL] Iterable<Serializers> serializersIterable = module.serializers(); [EOL] assertNotNull(serializersIterable); [EOL] assertFalse(serializersIterable.iterator().hasNext()); [EOL] }
public void testAsArraySerializerBaseWithNonNullValues() { [EOL] AsArraySerializerBase<?> original = createAsArraySerializerBase(); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] TypeSerializer vts = mock(TypeSerializer.class); [EOL] JsonSerializer<?> elementSerializer = mock(JsonSerializer.class); [EOL] AsArraySerializerBase<?> cloned = new AsArraySerializerBase<>(original, property, vts, elementSerializer); [EOL] assertNotNull(cloned); [EOL] assertEquals(original._elementType, cloned._elementType); [EOL] assertEquals(original._staticTyping, cloned._staticTyping); [EOL] assertEquals(vts, cloned._valueTypeSerializer); [EOL] assertEquals(property, cloned._property); [EOL] assertEquals(elementSerializer, cloned._elementSerializer); [EOL] assertEquals(original._dynamicSerializers, cloned._dynamicSerializers); [EOL] }
public void testAsArraySerializerBaseWithNullValues() { [EOL] AsArraySerializerBase<?> original = createAsArraySerializerBase(); [EOL] AsArraySerializerBase<?> cloned = new AsArraySerializerBase<>(original, null, null, null); [EOL] assertNotNull(cloned); [EOL] assertEquals(original._elementType, cloned._elementType); [EOL] assertEquals(original._staticTyping, cloned._staticTyping); [EOL] assertNull(cloned._valueTypeSerializer); [EOL] assertNull(cloned._property); [EOL] assertNull(cloned._elementSerializer); [EOL] assertEquals(original._dynamicSerializers, cloned._dynamicSerializers); [EOL] }
public void testCreateContextualWithNonNullTypeSerializerAndProperty() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] TypeSerializer typeSerializer = mock(TypeSerializer.class); [EOL] JsonSerializer<Object> elementSerializer = mock(JsonSerializer.class); [EOL] AnnotatedMember member = mock(AnnotatedMember.class); [EOL] Object serDef = new Object(); [EOL] when(_valueTypeSerializer).thenReturn(typeSerializer); [EOL] when(typeSerializer.forProperty(property)).thenReturn(typeSerializer); [EOL] when(property.getMember()).thenReturn(member); [EOL] when(provider.getAnnotationIntrospector().findContentSerializer(member)).thenReturn(serDef); [EOL] when(provider.serializerInstance(member, serDef)).thenReturn(elementSerializer); [EOL] when(_elementSerializer).thenReturn(elementSerializer); [EOL] JsonSerializer<?> result = createContextual(provider, property); [EOL] assertNotSame(this, result); [EOL] }
public void testCreateContextualWithNullProperty() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] JsonSerializer<?> result = createContextual(provider, null); [EOL] assertSame(this, result); [EOL] }
public void testCreateContextualWithNonNullPropertyButNullMember() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] when(property.getMember()).thenReturn(null); [EOL] JsonSerializer<?> result = createContextual(provider, property); [EOL] assertSame(this, result); [EOL] }
public void testCreateContextualWithNonNullPropertyAndMemberButNullSerDef() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] AnnotatedMember member = mock(AnnotatedMember.class); [EOL] when(property.getMember()).thenReturn(member); [EOL] when(provider.getAnnotationIntrospector().findContentSerializer(member)).thenReturn(null); [EOL] JsonSerializer<?> result = createContextual(provider, property); [EOL] assertSame(this, result); [EOL] }
public void testCreateContextualWithStaticTyping() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] JavaType elementType = mock(JavaType.class); [EOL] when(_elementType).thenReturn(elementType); [EOL] when(_staticTyping).thenReturn(true); [EOL] JsonSerializer<?> result = createContextual(provider, property); [EOL] assertNotSame(this, result); [EOL] }
public void testCreateContextualWithContentTypeAnnotation() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] JavaType elementType = mock(JavaType.class); [EOL] when(_elementType).thenReturn(elementType); [EOL] when(hasContentTypeAnnotation(provider, property)).thenReturn(true); [EOL] JsonSerializer<?> result = createContextual(provider, property); [EOL] assertNotSame(this, result); [EOL] }
public void testCreateContextualWithNonContextualSerializer() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] JsonSerializer<Object> nonContextualSerializer = mock(JsonSerializer.class); [EOL] when(findConvertingContentSerializer(provider, property, null)).thenReturn(nonContextualSerializer); [EOL] JsonSerializer<?> result = createContextual(provider, property); [EOL] assertNotSame(this, result); [EOL] }
public void testCreateContextualWithResolved() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] TypeSerializer typeSerializer = mock(TypeSerializer.class); [EOL] JsonSerializer<Object> elementSerializer = mock(JsonSerializer.class); [EOL] ContextualSerializer contextualSerializer = mock(ContextualSerializer.class); [EOL] when(_valueTypeSerializer).thenReturn(typeSerializer); [EOL] when(typeSerializer.forProperty(property)).thenReturn(typeSerializer); [EOL] when(findConvertingContentSerializer(provider, property, null)).thenReturn(contextualSerializer); [EOL] when(contextualSerializer.createContextual(provider, property)).thenReturn(elementSerializer); [EOL] JsonSerializer<?> result = createContextual(provider, property); [EOL] assertNotSame(this, result); [EOL] }
public void testSerializeWithType_NullValue() throws IOException { [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] SerializerProvider mockProvider = mock(SerializerProvider.class); [EOL] TypeSerializer mockTypeSerializer = mock(TypeSerializer.class); [EOL] SomeTypeSerializer serializer = new SomeTypeSerializer(); [EOL] serializer.serializeWithType(null, mockJsonGenerator, mockProvider, mockTypeSerializer); [EOL] verify(mockTypeSerializer).writeTypePrefixForArray(null, mockJsonGenerator); [EOL] verify(mockTypeSerializer).writeTypeSuffixForArray(null, mockJsonGenerator); [EOL] verifyNoMoreInteractions(mockJsonGenerator); [EOL] }
public void testSerializeWithType_NonNullValue() throws IOException { [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] SerializerProvider mockProvider = mock(SerializerProvider.class); [EOL] TypeSerializer mockTypeSerializer = mock(TypeSerializer.class); [EOL] SomeValue value = new SomeValue(); [EOL] SomeTypeSerializer serializer = new SomeTypeSerializer(); [EOL] serializer.serializeWithType(value, mockJsonGenerator, mockProvider, mockTypeSerializer); [EOL] verify(mockTypeSerializer).writeTypePrefixForArray(value, mockJsonGenerator); [EOL] verify(mockTypeSerializer).writeTypeSuffixForArray(value, mockJsonGenerator); [EOL] verify(mockJsonGenerator).writeFieldName(anyString()); [EOL] }
public void testFindAndAddDynamicWithNewMap() throws JsonMappingException { [EOL] PropertySerializerMap map = PropertySerializerMap.emptyForProperties(); [EOL] Class<?> type = String.class; [EOL] SerializerProvider provider = new DefaultSerializerProvider.Impl(); [EOL] provider.setConfig(new SerializationConfig(new ObjectMapper()._deserializationConfig.getBaseSettings())); [EOL] JsonSerializer<Object> serializer = _findAndAddDynamic(map, type, provider); [EOL] assertNotNull(serializer); [EOL] assertNotSame(map, _dynamicSerializers); [EOL] }
public void testFindAndAddDynamicWithExistingMap() throws JsonMappingException { [EOL] PropertySerializerMap map = PropertySerializerMap.emptyForProperties(); [EOL] Class<?> type = String.class; [EOL] SerializerProvider provider = new DefaultSerializerProvider.Impl(); [EOL] provider.setConfig(new SerializationConfig(new ObjectMapper()._deserializationConfig.getBaseSettings())); [EOL] _findAndAddDynamic(map, type, provider); [EOL] PropertySerializerMap originalMap = _dynamicSerializers; [EOL] JsonSerializer<Object> serializer = _findAndAddDynamic(map, type, provider); [EOL] assertNotNull(serializer); [EOL] assertSame(originalMap, _dynamicSerializers); [EOL] }
public void testDeserializationConfigWithNonNullArgs() { [EOL] BaseSettings baseSettings = new BaseSettings(null, null, null, null, null, null, null, null); [EOL] SubtypeResolver subtypeResolver = new StdSubtypeResolver(); [EOL] Map<ClassKey, Class<?>> mixins = new HashMap<>(); [EOL] mixins.put(new ClassKey(String.class), Object.class); [EOL] DeserializationConfig config = new DeserializationConfig(baseSettings, subtypeResolver, mixins); [EOL] assertNotNull(config); [EOL] assertEquals(JsonNodeFactory.instance, config.getNodeFactory()); [EOL] assertNull(config.getProblemHandlers()); [EOL] }
public void testDeserializationConfigWithNullArgs() { [EOL] BaseSettings baseSettings = null; [EOL] SubtypeResolver subtypeResolver = null; [EOL] Map<ClassKey, Class<?>> mixins = null; [EOL] DeserializationConfig config = new DeserializationConfig(baseSettings, subtypeResolver, mixins); [EOL] assertNotNull(config); [EOL] assertEquals(JsonNodeFactory.instance, config.getNodeFactory()); [EOL] assertNull(config.getProblemHandlers()); [EOL] }
public void testDeserializationConfigCopyConstructor() { [EOL] int initialMapperFeatures = 0; // Assuming 0 is a valid default or placeholder value [EOL] int initialDeserFeatures = 0; // Assuming 0 is a valid default or placeholder value [EOL] JsonNodeFactory nodeFactory = JsonNodeFactory.instance; [EOL] LinkedList<DeserializationProblemHandler> problemHandlers = new LinkedList<>(); [EOL] DeserializationConfig originalConfig = new DeserializationConfig( [EOL] BaseSettings.DEFAULT, // Assuming BaseSettings.DEFAULT is a valid default or placeholder value [EOL] initialMapperFeatures, [EOL] initialDeserFeatures, [EOL] nodeFactory, [EOL] problemHandlers [EOL] ); [EOL] int newMapperFeatures = 1; // Assuming 1 is a different valid value to test change in features [EOL] int newDeserFeatures = 1; // Assuming 1 is a different valid value to test change in features [EOL] DeserializationConfig copiedConfig = new DeserializationConfig(originalConfig, newMapperFeatures, newDeserFeatures); [EOL] assertNotSame(originalConfig, copiedConfig); [EOL] assertEquals(newMapperFeatures, copiedConfig.getMapperFeatures()); [EOL] assertEquals(newDeserFeatures, copiedConfig.getDeserializationFeatures()); [EOL] assertSame(nodeFactory, copiedConfig.getNodeFactory()); [EOL] assertSame(problemHandlers, copiedConfig.getProblemHandlers()); [EOL] }
public void testDeserializationConfigCopyConstructor() { [EOL] BaseSettings baseSettings = new BaseSettings(null, null, null, null, null, null, null, null, null, null); [EOL] JsonNodeFactory nodeFactory = JsonNodeFactory.instance; [EOL] DeserializationConfig original = new DeserializationConfig( [EOL] ObjectMapper.DefaultTyping.NON_FINAL, null, null, baseSettings, null, nodeFactory, null [EOL] ); [EOL] DeserializationConfig copy = new DeserializationConfig(original, baseSettings); [EOL] assertSame(original.getBaseSettings(), copy.getBaseSettings()); [EOL] assertEquals(original.getDeserializationFeatures(), copy.getDeserializationFeatures()); [EOL] assertSame(original.getNodeFactory(), copy.getNodeFactory()); [EOL] assertSame(original.getProblemHandlers(), copy.getProblemHandlers()); [EOL] }
public void testDeserializationConfigCopyConstructorWithRootName() { [EOL] DeserializationConfig originalConfig = new DeserializationConfig(); [EOL] String rootName = "testRoot"; [EOL] DeserializationConfig copiedConfig = new DeserializationConfig(originalConfig, rootName); [EOL] assertNotNull(copiedConfig); [EOL] assertEquals(rootName, copiedConfig.getRootName()); [EOL] assertEquals(originalConfig.getDeserializationFeatures(), copiedConfig.getDeserializationFeatures()); [EOL] assertEquals(originalConfig.getProblemHandlers(), copiedConfig.getProblemHandlers()); [EOL] assertEquals(originalConfig.getNodeFactory(), copiedConfig.getNodeFactory()); [EOL] }
public void testDeserializationConfigCopyConstructor() { [EOL] Map<ClassKey, Class<?>> mixins = new HashMap<>(); [EOL] mixins.put(new ClassKey(String.class), Integer.class); [EOL] DeserializationConfig original = new DeserializationConfig(new BaseSettings(), null, null, null, null, null, null); [EOL] DeserializationConfig copy = new DeserializationConfig(original, mixins); [EOL] assertEquals(original.getDeserializationFeatures(), copy.getDeserializationFeatures()); [EOL] assertEquals(original._nodeFactory, copy._nodeFactory); [EOL] assertNotSame(original._problemHandlers, copy._problemHandlers); [EOL] assertEquals(mixins, copy.mixins()); [EOL] }
public void testWithoutWithNoFeatures() { [EOL] DeserializationConfig originalConfig = new DeserializationConfig(...); // Provide necessary initialization parameters [EOL] DeserializationConfig newConfig = originalConfig.without(); [EOL] assertEquals("Without no features should return the same config", originalConfig, newConfig); [EOL] }
public void testWithoutWithOneFeature() { [EOL] DeserializationConfig originalConfig = new DeserializationConfig(...); // Provide necessary initialization parameters [EOL] MapperFeature feature = MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES; [EOL] DeserializationConfig newConfig = originalConfig.without(feature); [EOL] assertNotEquals("Without one feature should not return the same config", originalConfig, newConfig); [EOL] }
public void testWithoutWithMultipleFeatures() { [EOL] DeserializationConfig originalConfig = new DeserializationConfig(...); // Provide necessary initialization parameters [EOL] MapperFeature feature1 = MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES; [EOL] MapperFeature feature2 = MapperFeature.AUTO_DETECT_FIELDS; [EOL] DeserializationConfig newConfig = originalConfig.without(feature1, feature2); [EOL] assertNotEquals("Without multiple features should not return the same config", originalConfig, newConfig); [EOL] }
public void testWithAnnotationIntrospectorNonNull() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] AnnotationIntrospector originalAI = mapper.getDeserializationConfig().getAnnotationIntrospector(); [EOL] AnnotationIntrospector newAI = new AnnotationIntrospector() { [EOL] }; [EOL] DeserializationConfig config = mapper.getDeserializationConfig(); [EOL] DeserializationConfig newConfig = config.with(newAI); [EOL] assertNotNull(newConfig); [EOL] assertNotSame(config, newConfig); [EOL] assertSame(newAI, newConfig.getAnnotationIntrospector()); [EOL] }
public void testWithAnnotationIntrospectorNull() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] DeserializationConfig config = mapper.getDeserializationConfig(); [EOL] DeserializationConfig newConfig = config.with((AnnotationIntrospector) null); [EOL] assertNotNull(newConfig); [EOL] assertNotSame(config, newConfig); [EOL] assertNull(newConfig.getAnnotationIntrospector()); [EOL] }
public void testWithNullTypeResolverBuilder() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] DeserializationConfig config = mapper.getDeserializationConfig(); [EOL] DeserializationConfig newConfig = config.with(null); [EOL] assertNotNull(newConfig); [EOL] assertNotSame(config, newConfig); [EOL] }
public void testWithTypeResolverBuilder() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] DeserializationConfig config = mapper.getDeserializationConfig(); [EOL] TypeResolverBuilder<?> typeResolverBuilder = new DefaultTypeResolverBuilder(ObjectMapper.DefaultTyping.NON_FINAL); [EOL] DeserializationConfig newConfig = config.with(typeResolverBuilder); [EOL] assertNotNull(newConfig); [EOL] assertNotSame(config, newConfig); [EOL] }
public void testWithPropertyNamingStrategyNull() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] DeserializationConfig config = mapper.getDeserializationConfig(); [EOL] DeserializationConfig newConfig = config.with((PropertyNamingStrategy) null); [EOL] assertNotNull(newConfig); [EOL] assertNotSame(config, newConfig); [EOL] assertNull(newConfig.getPropertyNamingStrategy()); [EOL] }
public void testWithPropertyNamingStrategyNonNull() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] DeserializationConfig config = mapper.getDeserializationConfig(); [EOL] PropertyNamingStrategy pns = PropertyNamingStrategy.SNAKE_CASE; [EOL] DeserializationConfig newConfig = config.with(pns); [EOL] assertNotNull(newConfig); [EOL] assertNotSame(config, newConfig); [EOL] assertEquals(pns, newConfig.getPropertyNamingStrategy()); [EOL] }
public void testWithRootNameWhenRootNameIsNullAndCurrentRootNameIsNull() { [EOL] DeserializationConfig config = new DeserializationConfig(); [EOL] DeserializationConfig result = config.withRootName(null); [EOL] assertSame("Expected same config since both root names are null", config, result); [EOL] }
public void testWithRootNameWhenRootNameIsNullAndCurrentRootNameIsNotNull() { [EOL] DeserializationConfig config = new DeserializationConfig(); [EOL] config = config.withRootName("existingRootName"); [EOL] DeserializationConfig result = config.withRootName(null); [EOL] assertNotSame("Expected different config since current root name is not null", config, result); [EOL] }
public void testWithRootNameWhenRootNameIsNotNullAndEqualsCurrentRootName() { [EOL] DeserializationConfig config = new DeserializationConfig(); [EOL] config = config.withRootName("rootName"); [EOL] DeserializationConfig result = config.withRootName("rootName"); [EOL] assertSame("Expected same config since root names are equal", config, result); [EOL] }
public void testWithRootNameWhenRootNameIsNotNullAndNotEqualsCurrentRootName() { [EOL] DeserializationConfig config = new DeserializationConfig(); [EOL] config = config.withRootName("rootName"); [EOL] DeserializationConfig result = config.withRootName("newRootName"); [EOL] assertNotSame("Expected different config since root names are not equal", config, result); [EOL] }
public void testWithHandlerInstantiatorNull() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] DeserializationConfig config = mapper.getDeserializationConfig(); [EOL] DeserializationConfig newConfig = config.with((HandlerInstantiator) null); [EOL] assertNotNull(newConfig); [EOL] assertNotSame(config, newConfig); [EOL] }
public void testWithHandlerInstantiatorNonNull() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] DeserializationConfig config = mapper.getDeserializationConfig(); [EOL] HandlerInstantiator hi = new HandlerInstantiator() { [EOL] }; [EOL] DeserializationConfig newConfig = config.with(hi); [EOL] assertNotNull(newConfig); [EOL] assertNotSame(config, newConfig); [EOL] assertEquals(hi, newConfig.getHandlerInstantiator()); [EOL] }
public void testWithBaseSameInstance() { [EOL] BaseSettings baseSettings = new BaseSettings(null, null, null, null, null, null, null, null, null, null); [EOL] DeserializationConfig config = new DeserializationConfig(baseSettings, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null); [EOL] DeserializationConfig newConfig = config._withBase(baseSettings); [EOL] assertSame(config, newConfig); [EOL] }
public void testWithBaseDifferentInstance() { [EOL] BaseSettings baseSettings1 = new BaseSettings(null, null, null, null, null, null, null, null, null, null); [EOL] BaseSettings baseSettings2 = new BaseSettings(null, null, null, null, null, null, null, null, null, null); [EOL] DeserializationConfig config = new DeserializationConfig(baseSettings1, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null); [EOL] DeserializationConfig newConfig = config._withBase(baseSettings2); [EOL] assertNotSame(config, newConfig); [EOL] }
public void testWithDeserializationFeatureEnabled() { [EOL] DeserializationConfig config = new DeserializationConfig(...); // provide necessary arguments [EOL] DeserializationFeature feature = DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY; // example feature [EOL] int originalDeserFeatures = config.getDeserializationFeatures(); [EOL] DeserializationConfig newConfig = config.with(feature); [EOL] int newDeserFeatures = newConfig.getDeserializationFeatures(); [EOL] assertTrue((originalDeserFeatures | feature.getMask()) == newDeserFeatures); [EOL] assertNotSame(config, newConfig); [EOL] }
public void testWithDeserializationFeatureAlreadyEnabled() { [EOL] DeserializationConfig config = new DeserializationConfig(...); // provide necessary arguments [EOL] DeserializationFeature feature = DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY; // example feature [EOL] config = config.with(feature); // enable the feature [EOL] int originalDeserFeatures = config.getDeserializationFeatures(); [EOL] DeserializationConfig newConfig = config.with(feature); // enable the feature again [EOL] assertEquals(originalDeserFeatures, newConfig.getDeserializationFeatures()); [EOL] assertSame(config, newConfig); [EOL] }
public void testUseRootWrappingWithNonNullRootName() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] mapper._rootName = "root"; [EOL] boolean result = mapper.useRootWrapping(); [EOL] assertTrue(result); [EOL] }
public void testUseRootWrappingWithEmptyRootName() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] mapper._rootName = "";// Assuming this is a valid way to set an empty root name [EOL] boolean result = mapper.useRootWrapping(); [EOL] assertFalse(result); [EOL] }
public void testUseRootWrappingWithNullRootNameAndFeatureEnabled() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] mapper._rootName = null; [EOL] mapper.enable(DeserializationFeature.UNWRAP_ROOT_VALUE); [EOL] boolean result = mapper.useRootWrapping(); [EOL] assertTrue(result); [EOL] }
public void testUseRootWrappingWithNullRootNameAndFeatureDisabled() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] mapper._rootName = null; [EOL] mapper.disable(DeserializationFeature.UNWRAP_ROOT_VALUE); [EOL] boolean result = mapper.useRootWrapping(); [EOL] assertFalse(result); [EOL] }
public void testGetDefaultVisibilityChecker_AllFeaturesEnabled() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] mapper.enable(MapperFeature.AUTO_DETECT_SETTERS); [EOL] mapper.enable(MapperFeature.AUTO_DETECT_CREATORS); [EOL] mapper.enable(MapperFeature.AUTO_DETECT_FIELDS); [EOL] VisibilityChecker<?> vchecker = mapper.getSerializationConfig().getDefaultVisibilityChecker(); [EOL] assertEquals(JsonAutoDetect.Visibility.DEFAULT, vchecker.getSetterVisibility()); [EOL] assertEquals(JsonAutoDetect.Visibility.DEFAULT, vchecker.getCreatorVisibility()); [EOL] assertEquals(JsonAutoDetect.Visibility.DEFAULT, vchecker.getFieldVisibility()); [EOL] }
public void testGetDefaultVisibilityChecker_NoAutoDetectSetters() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] mapper.disable(MapperFeature.AUTO_DETECT_SETTERS); [EOL] mapper.enable(MapperFeature.AUTO_DETECT_CREATORS); [EOL] mapper.enable(MapperFeature.AUTO_DETECT_FIELDS); [EOL] VisibilityChecker<?> vchecker = mapper.getSerializationConfig().getDefaultVisibilityChecker(); [EOL] assertEquals(JsonAutoDetect.Visibility.NONE, vchecker.getSetterVisibility()); [EOL] assertEquals(JsonAutoDetect.Visibility.DEFAULT, vchecker.getCreatorVisibility()); [EOL] assertEquals(JsonAutoDetect.Visibility.DEFAULT, vchecker.getFieldVisibility()); [EOL] }
public void testGetDefaultVisibilityChecker_NoAutoDetectCreators() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] mapper.enable(MapperFeature.AUTO_DETECT_SETTERS); [EOL] mapper.disable(MapperFeature.AUTO_DETECT_CREATORS); [EOL] mapper.enable(MapperFeature.AUTO_DETECT_FIELDS); [EOL] VisibilityChecker<?> vchecker = mapper.getSerializationConfig().getDefaultVisibilityChecker(); [EOL] assertEquals(JsonAutoDetect.Visibility.DEFAULT, vchecker.getSetterVisibility()); [EOL] assertEquals(JsonAutoDetect.Visibility.NONE, vchecker.getCreatorVisibility()); [EOL] assertEquals(JsonAutoDetect.Visibility.DEFAULT, vchecker.getFieldVisibility()); [EOL] }
public void testGetDefaultVisibilityChecker_NoAutoDetectFields() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] mapper.enable(MapperFeature.AUTO_DETECT_SETTERS); [EOL] mapper.enable(MapperFeature.AUTO_DETECT_CREATORS); [EOL] mapper.disable(MapperFeature.AUTO_DETECT_FIELDS); [EOL] VisibilityChecker<?> vchecker = mapper.getSerializationConfig().getDefaultVisibilityChecker(); [EOL] assertEquals(JsonAutoDetect.Visibility.DEFAULT, vchecker.getSetterVisibility()); [EOL] assertEquals(JsonAutoDetect.Visibility.DEFAULT, vchecker.getCreatorVisibility()); [EOL] assertEquals(JsonAutoDetect.Visibility.NONE, vchecker.getFieldVisibility()); [EOL] }
public void testGetDefaultVisibilityChecker_AllFeaturesDisabled() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] mapper.disable(MapperFeature.AUTO_DETECT_SETTERS); [EOL] mapper.disable(MapperFeature.AUTO_DETECT_CREATORS); [EOL] mapper.disable(MapperFeature.AUTO_DETECT_FIELDS); [EOL] VisibilityChecker<?> vchecker = mapper.getSerializationConfig().getDefaultVisibilityChecker(); [EOL] assertEquals(JsonAutoDetect.Visibility.NONE, vchecker.getSetterVisibility()); [EOL] assertEquals(JsonAutoDetect.Visibility.NONE, vchecker.getCreatorVisibility()); [EOL] assertEquals(JsonAutoDetect.Visibility.NONE, vchecker.getFieldVisibility()); [EOL] }
public void testIsEnabledWithFeatureEnabled() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] mapper.enable(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS); [EOL] boolean result = mapper.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS); [EOL] assertTrue(result); [EOL] }
public void testIsEnabledWithFeatureDisabled() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] mapper.disable(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS); [EOL] boolean result = mapper.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS); [EOL] assertFalse(result); [EOL] }
public void testIntrospectForCreationWithValidType() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] JavaType type = mapper.constructType(MyBean.class); [EOL] BeanDescription beanDesc = mapper.getSerializationConfig().introspectForCreation(type); [EOL] assertNotNull(beanDesc); [EOL] }
public void testIntrospectForCreationWithNullType() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] try { [EOL] BeanDescription beanDesc = mapper.getSerializationConfig().introspectForCreation(null); [EOL] fail("Expected IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testAnnotationMapConstructor() { [EOL] AnnotationMap annotationMap = new AnnotationMap(); [EOL] assertNotNull(annotationMap); [EOL] }
private AnnotationMap(HashMap<Class<? extends Annotation>, Annotation> a) { [EOL] _annotations = a; [EOL] }
public void testGetWithNullAnnotations() { [EOL] AnnotationCollector collector = new AnnotationCollector(null); [EOL] assertNull(collector.get(SomeAnnotation.class)); [EOL] }
public void testGetWithNonNullAnnotations() { [EOL] Map<Class<? extends Annotation>, Annotation> annotations = new HashMap<>(); [EOL] SomeAnnotation someAnnotation = new SomeAnnotationImpl(); [EOL] annotations.put(SomeAnnotation.class, someAnnotation); [EOL] AnnotationCollector collector = new AnnotationCollector(annotations); [EOL] assertEquals(someAnnotation, collector.get(SomeAnnotation.class)); [EOL] }
public void testMerge_BothPrimaryAndSecondaryNull() { [EOL] AnnotationMap result = AnnotationMap.merge(null, null); [EOL] assertNull(result); [EOL] }
public void testMerge_PrimaryNullSecondaryEmpty() { [EOL] AnnotationMap secondary = new AnnotationMap(); [EOL] AnnotationMap result = AnnotationMap.merge(null, secondary); [EOL] assertSame(secondary, result); [EOL] }
public void testMerge_PrimaryEmptySecondaryNull() { [EOL] AnnotationMap primary = new AnnotationMap(); [EOL] AnnotationMap result = AnnotationMap.merge(primary, null); [EOL] assertSame(primary, result); [EOL] }
public void testMerge_BothPrimaryAndSecondaryEmpty() { [EOL] AnnotationMap primary = new AnnotationMap(); [EOL] AnnotationMap secondary = new AnnotationMap(); [EOL] AnnotationMap result = AnnotationMap.merge(primary, secondary); [EOL] assertSame(primary, result); [EOL] }
public void testMerge_PrimaryHasAnnotationsSecondaryNull() { [EOL] AnnotationMap primary = new AnnotationMap(); [EOL] primary.add(NonNull.class, new NonNullImpl()); [EOL] AnnotationMap result = AnnotationMap.merge(primary, null); [EOL] assertSame(primary, result); [EOL] }
public void testMerge_PrimaryNullSecondaryHasAnnotations() { [EOL] AnnotationMap secondary = new AnnotationMap(); [EOL] secondary.add(NonNull.class, new NonNullImpl()); [EOL] AnnotationMap result = AnnotationMap.merge(null, secondary); [EOL] assertSame(secondary, result); [EOL] }
public void testMerge_BothPrimaryAndSecondaryHaveDifferentAnnotations() { [EOL] AnnotationMap primary = new AnnotationMap(); [EOL] primary.add(NonNull.class, new NonNullImpl()); [EOL] AnnotationMap secondary = new AnnotationMap(); [EOL] secondary.add(Deprecated.class, new DeprecatedImpl()); [EOL] AnnotationMap result = AnnotationMap.merge(primary, secondary); [EOL] assertNotNull(result); [EOL] assertEquals(2, result.size()); [EOL] assertNotNull(result.get(NonNull.class)); [EOL] assertNotNull(result.get(Deprecated.class)); [EOL] }
public void testMerge_BothPrimaryAndSecondaryHaveSameAnnotations() { [EOL] AnnotationMap primary = new AnnotationMap(); [EOL] primary.add(NonNull.class, new NonNullImpl()); [EOL] AnnotationMap secondary = new AnnotationMap(); [EOL] secondary.add(NonNull.class, new NonNullImpl()); [EOL] AnnotationMap result = AnnotationMap.merge(primary, secondary); [EOL] assertNotNull(result); [EOL] assertEquals(1, result.size()); [EOL] assertNotNull(result.get(NonNull.class)); [EOL] }
public void testAddIfNotPresentWithNullAnnotations() { [EOL] AnnotationMap map = new AnnotationMap(); [EOL] Annotation ann = new SomeAnnotationImpl(); [EOL] map.addIfNotPresent(ann); [EOL] assertTrue(map.has(ann.annotationType())); [EOL] }
public void testAddIfNotPresentWithExistingAnnotation() { [EOL] AnnotationMap map = new AnnotationMap(); [EOL] Annotation ann1 = new SomeAnnotationImpl(); [EOL] map.add(ann1); [EOL] int sizeBefore = map.size(); [EOL] Annotation ann2 = new SomeAnnotationImpl(); [EOL] map.addIfNotPresent(ann2); [EOL] assertEquals(sizeBefore, map.size()); [EOL] }
public void testToStringWithNullAnnotations() { [EOL] AnnotationCollector ac = new AnnotationCollector(null); [EOL] String result = ac.toString(); [EOL] assertEquals("[null]", result); [EOL] }
public void testToStringWithNonNullAnnotations() { [EOL] AnnotationCollector ac = new AnnotationCollector(new HashMap<Class<? extends Annotation>, Annotation>()); [EOL] ac.add(Override.class, null); [EOL] String result = ac.toString(); [EOL] assertNotNull(result); [EOL] assertFalse(result.equals("[null]")); [EOL] }
public void testAddAnnotationWhenAnnotationsIsNull() { [EOL] AnnotationCollector collector = new AnnotationCollector(null); [EOL] collector._add(SomeAnnotation.class.getAnnotation(Deprecated.class)); [EOL] assertNotNull(collector._annotations); [EOL] assertTrue(collector._annotations.containsKey(Deprecated.class)); [EOL] assertNotNull(collector._annotations.get(Deprecated.class)); [EOL] }
public void testAddAnnotationWhenAnnotationsIsNotNull() { [EOL] AnnotationCollector collector = new AnnotationCollector(null); [EOL] collector._add(SomeAnnotation.class.getAnnotation(Deprecated.class)); [EOL] collector._add(SomeOtherAnnotation.class.getAnnotation(Override.class)); [EOL] assertNotNull(collector._annotations); [EOL] assertTrue(collector._annotations.containsKey(Deprecated.class)); [EOL] assertTrue(collector._annotations.containsKey(Override.class)); [EOL] assertNotNull(collector._annotations.get(Deprecated.class)); [EOL] assertNotNull(collector._annotations.get(Override.class)); [EOL] }
public void testStringDeserializerConstructor() { [EOL] StringDeserializer deserializer = new StringDeserializer(); [EOL] assertNotNull(deserializer); [EOL] assertEquals(String.class, deserializer.handledType()); [EOL] }
public void testAsArrayTypeDeserializerConstructor() { [EOL] JavaType bt = mock(JavaType.class); [EOL] TypeIdResolver idRes = mock(TypeIdResolver.class); [EOL] String typePropertyName = "typeProperty"; [EOL] boolean typeIdVisible = true; [EOL] Class<?> defaultImpl = Object.class; [EOL] AsArrayTypeDeserializer deserializer = new AsArrayTypeDeserializer(bt, idRes, typePropertyName, typeIdVisible, defaultImpl); [EOL] assertNotNull(deserializer); [EOL] }
public void testAsArrayTypeDeserializerWithNullProperty() { [EOL] AsArrayTypeDeserializer original = new AsArrayTypeDeserializer(); [EOL] AsArrayTypeDeserializer copy = new AsArrayTypeDeserializer(original, null); [EOL] assertNotNull(copy); [EOL] }
public void testAsArrayTypeDeserializerWithNonNullProperty() { [EOL] AsArrayTypeDeserializer original = new AsArrayTypeDeserializer(); [EOL] BeanProperty property = new BeanProperty.Bogus(); [EOL] AsArrayTypeDeserializer copy = new AsArrayTypeDeserializer(original, property); [EOL] assertNotNull(copy); [EOL] assertEquals(property, copy.getProperty()); [EOL] }
public void testForPropertyWithSameProperty() { [EOL] BeanProperty prop = createMockBeanProperty(); [EOL] AsArrayTypeDeserializer instance = new AsArrayTypeDeserializer(null, prop); [EOL] TypeDeserializer result = instance.forProperty(prop); [EOL] assertSame(instance, result); [EOL] }
public void testForPropertyWithDifferentProperty() { [EOL] BeanProperty prop1 = createMockBeanProperty(); [EOL] BeanProperty prop2 = createMockBeanProperty(); [EOL] AsArrayTypeDeserializer instance = new AsArrayTypeDeserializer(null, prop1); [EOL] TypeDeserializer result = instance.forProperty(prop2); [EOL] assertNotNull(result); [EOL] assertNotSame(instance, result); [EOL] assertTrue(result instanceof AsArrayTypeDeserializer); [EOL] }
public void testDeserializeTypedFromAnyWithValidParserAndContext() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object expectedResult = new Object(); [EOL] when(_deserialize(jp, ctxt)).thenReturn(expectedResult); [EOL] Object result = deserializeTypedFromAny(jp, ctxt); [EOL] assertEquals(expectedResult, result); [EOL] }
public void testDeserializeTypedFromAnyWithIOException() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(_deserialize(jp, ctxt)).thenThrow(new IOException()); [EOL] assertThrows(IOException.class, () -> { [EOL] deserializeTypedFromAny(jp, ctxt); [EOL] }); [EOL] }
public void testDeserializeTypedFromAnyWithJsonProcessingException() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(_deserialize(jp, ctxt)).thenThrow(new JsonProcessingException("") {}); [EOL] assertThrows(JsonProcessingException.class, () -> { [EOL] deserializeTypedFromAny(jp, ctxt); [EOL] }); [EOL] }
public void testDeserializeWithStartArrayToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JsonDeserializer<Object> deser = mock(JsonDeserializer.class); [EOL] when(jp.isExpectedStartArrayToken()).thenReturn(true); [EOL] when(jp.nextToken()).thenReturn(JsonToken.END_ARRAY); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); [EOL] when(ctxt.wrongTokenException(any(JsonParser.class), any(JsonToken.class), anyString())) [EOL] .thenThrow(new JsonMappingException(jp, "expected closing END_ARRAY after type information and deserialized value")); [EOL] String typeId = "testType"; [EOL] when(_locateTypeId(jp, ctxt)).thenReturn(typeId); [EOL] when(_findDeserializer(ctxt, typeId)).thenReturn(deser); [EOL] when(deser.deserialize(jp, ctxt)).thenReturn(new Object()); [EOL] Object result = _deserialize(jp, ctxt); [EOL] verify(deser).deserialize(jp, ctxt); [EOL] assertEquals("The result should be the object returned by the deserializer", new Object(), result); [EOL] }
public void testDeserializeWithoutStartArrayToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JsonDeserializer<Object> deser = mock(JsonDeserializer.class); [EOL] when(jp.isExpectedStartArrayToken()).thenReturn(false); [EOL] when(jp.nextToken()).thenReturn(JsonToken.NOT_AVAILABLE); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.NOT_AVAILABLE); [EOL] String typeId = "testType"; [EOL] when(_locateTypeId(jp, ctxt)).thenReturn(typeId); [EOL] when(_findDeserializer(ctxt, typeId)).thenReturn(deser); [EOL] when(deser.deserialize(jp, ctxt)).thenReturn(new Object()); [EOL] Object result = _deserialize(jp, ctxt); [EOL] verify(deser).deserialize(jp, ctxt); [EOL] assertEquals("The result should be the object returned by the deserializer", new Object(), result); [EOL] }
public void testDeserializeWithTypeIdVisible() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JsonDeserializer<Object> deser = mock(JsonDeserializer.class); [EOL] when(jp.isExpectedStartArrayToken()).thenReturn(false); [EOL] when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); [EOL] _typeIdVisible = true; [EOL] String typeId = "testType"; [EOL] when(_locateTypeId(jp, ctxt)).thenReturn(typeId); [EOL] when(_findDeserializer(ctxt, typeId)).thenReturn(deser); [EOL] when(deser.deserialize(jp, ctxt)).thenReturn(new Object()); [EOL] Object result = _deserialize(jp, ctxt); [EOL] verify(deser).deserialize(jp, ctxt); [EOL] assertEquals("The result should be the object returned by the deserializer", new Object(), result); [EOL] }
public void testLocateTypeIdWithNonArrayTokenAndDefaultImpl() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.isExpectedStartArrayToken()).thenReturn(false); [EOL] when(_defaultImpl).thenReturn(mock(Object.class)); [EOL] when(_idResolver.idFromBaseType()).thenReturn("typeId"); [EOL] String result = _locateTypeId(jp, ctxt); [EOL] assertEquals("typeId", result); [EOL] }
public void testLocateTypeIdWithNonArrayTokenAndNoDefaultImpl() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.isExpectedStartArrayToken()).thenReturn(false); [EOL] when(_defaultImpl).thenReturn(null); [EOL] try { [EOL] _locateTypeId(jp, ctxt); [EOL] fail("Expected JsonProcessingException"); [EOL] } catch (JsonProcessingException e) { [EOL] } [EOL] }
public void testLocateTypeIdWithArrayTokenAndStringValue() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.isExpectedStartArrayToken()).thenReturn(true); [EOL] when(jp.nextToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("typeId"); [EOL] String result = _locateTypeId(jp, ctxt); [EOL] assertEquals("typeId", result); [EOL] }
public void testLocateTypeIdWithArrayTokenAndNonStringValueAndDefaultImpl() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.isExpectedStartArrayToken()).thenReturn(true); [EOL] when(jp.nextToken()).thenReturn(JsonToken.NOT_AVAILABLE); [EOL] when(_defaultImpl).thenReturn(mock(Object.class)); [EOL] when(_idResolver.idFromBaseType()).thenReturn("typeId"); [EOL] String result = _locateTypeId(jp, ctxt); [EOL] assertEquals("typeId", result); [EOL] }
public void testLocateTypeIdWithArrayTokenAndNonStringValueAndNoDefaultImpl() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.isExpectedStartArrayToken()).thenReturn(true); [EOL] when(jp.nextToken()).thenReturn(JsonToken.NOT_AVAILABLE); [EOL] when(_defaultImpl).thenReturn(null); [EOL] try { [EOL] _locateTypeId(jp, ctxt); [EOL] fail("Expected JsonProcessingException"); [EOL] } catch (JsonProcessingException e) { [EOL] } [EOL] }
public void testWithAnnotationsSameAnnotations() { [EOL] AnnotationMap originalAnnotations = new AnnotationMap(); [EOL] AnnotatedParameter originalParameter = new AnnotatedParameter(owner, index, originalAnnotations); [EOL] AnnotatedParameter result = originalParameter.withAnnotations(originalAnnotations); [EOL] assertSame(originalParameter, result); [EOL] }
public void testWithAnnotationsDifferentAnnotations() { [EOL] AnnotationMap originalAnnotations = new AnnotationMap(); [EOL] AnnotationMap newAnnotations = new AnnotationMap(); [EOL] newAnnotations.add(someAnnotation); // Assuming someAnnotation is a valid annotation instance [EOL] AnnotatedParameter originalParameter = new AnnotatedParameter(owner, index, originalAnnotations); [EOL] AnnotatedParameter result = originalParameter.withAnnotations(newAnnotations); [EOL] assertNotSame(originalParameter, result); [EOL] assertTrue(_owner.verifyParameterAnnotations(index, newAnnotations)); [EOL] }
public void testGetParameterType() { [EOL] MyObject obj = new MyObject(); [EOL] Type expectedType = /* some type */; [EOL] obj._type = expectedType; [EOL] Type result = obj.getParameterType(); [EOL] assertEquals(expectedType, result); [EOL] }
public AnnotatedWithParams getOwner() { [EOL] return _owner; [EOL] }
public void testGetIndex() { [EOL] YourClass instance = new YourClass(5); // Assuming there's a constructor that sets _index [EOL] int expected = 5; [EOL] int actual = instance.getIndex(); [EOL] assertEquals(expected, actual); [EOL] }
public void testFilterOutAllExceptWithEmptyArray() { [EOL] SimpleBeanPropertyFilter filter = SimpleBeanPropertyFilter.filterOutAllExcept(); [EOL] assertNotNull(filter); [EOL] assertTrue(filter.getProperties().isEmpty()); [EOL] }
public void testFilterOutAllExceptWithSingleProperty() { [EOL] SimpleBeanPropertyFilter filter = SimpleBeanPropertyFilter.filterOutAllExcept("propertyOne"); [EOL] assertNotNull(filter); [EOL] assertTrue(filter.getProperties().contains("propertyOne")); [EOL] assertEquals(1, filter.getProperties().size()); [EOL] }
public void testFilterOutAllExceptWithMultipleProperties() { [EOL] SimpleBeanPropertyFilter filter = SimpleBeanPropertyFilter.filterOutAllExcept("propertyOne", "propertyTwo"); [EOL] assertNotNull(filter); [EOL] assertTrue(filter.getProperties().contains("propertyOne")); [EOL] assertTrue(filter.getProperties().contains("propertyTwo")); [EOL] assertEquals(2, filter.getProperties().size()); [EOL] }
public void testFilterExceptFilterWithNonNullSet() { [EOL] Set<String> properties = new HashSet<>(); [EOL] properties.add("property1"); [EOL] properties.add("property2"); [EOL] FilterExceptFilter filter = new FilterExceptFilter(properties); [EOL] assertNotNull(filter._propertiesToInclude); [EOL] assertEquals(2, filter._propertiesToInclude.size()); [EOL] assertTrue(filter._propertiesToInclude.contains("property1")); [EOL] assertTrue(filter._propertiesToInclude.contains("property2")); [EOL] }
public void testFilterExceptFilterWithEmptySet() { [EOL] Set<String> properties = new HashSet<>(); [EOL] FilterExceptFilter filter = new FilterExceptFilter(properties); [EOL] assertNotNull(filter._propertiesToInclude); [EOL] assertTrue(filter._propertiesToInclude.isEmpty()); [EOL] }
public void testFilterExceptFilterWithNull() { [EOL] FilterExceptFilter filter = new FilterExceptFilter(null); [EOL] assertNull(filter._propertiesToInclude); [EOL] }
protected SettableBeanProperty(BeanPropertyDefinition propDef, JavaType type, TypeDeserializer typeDeser, Annotations contextAnnotations) { [EOL] this(propDef.getName(), type, propDef.getWrapperName(), typeDeser, contextAnnotations, propDef.isRequired()); [EOL] }
public void testSettableBeanPropertyWithEmptyPropName() { [EOL] String propName = ""; [EOL] JavaType type = mock(JavaType.class); [EOL] PropertyName wrapper = mock(PropertyName.class); [EOL] TypeDeserializer typeDeser = mock(TypeDeserializer.class); [EOL] Annotations contextAnnotations = mock(Annotations.class); [EOL] boolean isRequired = false; [EOL] SettableBeanProperty property = new SettableBeanProperty(propName, type, wrapper, typeDeser, contextAnnotations, isRequired); [EOL] assertEquals("", property.getName()); [EOL] assertEquals(type, property.getType()); [EOL] assertEquals(wrapper, property.getWrapperName()); [EOL] assertEquals(isRequired, property.isRequired()); [EOL] assertNull(property.getValueTypeDeserializer()); [EOL] assertNotNull(property.getValueDeserializer()); [EOL] }
public void testSettableBeanPropertyWithNonNullPropName() { [EOL] String propName = "testProperty"; [EOL] JavaType type = mock(JavaType.class); [EOL] PropertyName wrapper = mock(PropertyName.class); [EOL] TypeDeserializer typeDeser = mock(TypeDeserializer.class); [EOL] Annotations contextAnnotations = mock(Annotations.class); [EOL] boolean isRequired = true; [EOL] SettableBeanProperty property = new SettableBeanProperty(propName, type, wrapper, typeDeser, contextAnnotations, isRequired); [EOL] assertEquals("testProperty", property.getName()); [EOL] assertEquals(type, property.getType()); [EOL] assertEquals(wrapper, property.getWrapperName()); [EOL] assertEquals(isRequired, property.isRequired()); [EOL] assertNotNull(property.getValueTypeDeserializer()); [EOL] assertNotNull(property.getValueDeserializer()); [EOL] }
public void testSettableBeanPropertyWithTypeDeserializerNull() { [EOL] String propName = "testProperty"; [EOL] JavaType type = mock(JavaType.class); [EOL] PropertyName wrapper = mock(PropertyName.class); [EOL] TypeDeserializer typeDeser = null; [EOL] Annotations contextAnnotations = mock(Annotations.class); [EOL] boolean isRequired = true; [EOL] SettableBeanProperty property = new SettableBeanProperty(propName, type, wrapper, typeDeser, contextAnnotations, isRequired); [EOL] assertEquals("testProperty", property.getName()); [EOL] assertEquals(type, property.getType()); [EOL] assertEquals(wrapper, property.getWrapperName()); [EOL] assertEquals(isRequired, property.isRequired()); [EOL] assertNull(property.getValueTypeDeserializer()); [EOL] assertNotNull(property.getValueDeserializer()); [EOL] }
public void testSettableBeanPropertyWithNullDeserializer() { [EOL] SettableBeanProperty src = createMockSettableBeanProperty(); [EOL] SettableBeanProperty property = new SettableBeanProperty(src, null); [EOL] assertNull(property._nullProvider); [EOL] assertSame(SettableBeanProperty.MISSING_VALUE_DESERIALIZER, property._valueDeserializer); [EOL] assertEquals(src._propName, property._propName); [EOL] assertEquals(src._type, property._type); [EOL] assertEquals(src._wrapperName, property._wrapperName); [EOL] assertEquals(src._isRequired, property._isRequired); [EOL] assertEquals(src._contextAnnotations, property._contextAnnotations); [EOL] assertEquals(src._valueTypeDeserializer, property._valueTypeDeserializer); [EOL] assertEquals(src._managedReferenceName, property._managedReferenceName); [EOL] assertEquals(src._propertyIndex, property._propertyIndex); [EOL] assertEquals(src._viewMatcher, property._viewMatcher); [EOL] }
public void testSettableBeanPropertyWithNonNullDeserializer() { [EOL] SettableBeanProperty src = createMockSettableBeanProperty(); [EOL] JsonDeserializer<?> deser = createMockJsonDeserializer(); [EOL] when(deser.getNullValue()).thenReturn(null); [EOL] SettableBeanProperty property = new SettableBeanProperty(src, deser); [EOL] assertNull(property._nullProvider); [EOL] assertSame(deser, property._valueDeserializer); [EOL] assertEquals(src._propName, property._propName); [EOL] assertEquals(src._type, property._type); [EOL] assertEquals(src._wrapperName, property._wrapperName); [EOL] assertEquals(src._isRequired, property._isRequired); [EOL] assertEquals(src._contextAnnotations, property._contextAnnotations); [EOL] assertEquals(src._valueTypeDeserializer, property._valueTypeDeserializer); [EOL] assertEquals(src._managedReferenceName, property._managedReferenceName); [EOL] assertEquals(src._propertyIndex, property._propertyIndex); [EOL] assertEquals(src._viewMatcher, property._viewMatcher); [EOL] }
public void testSettableBeanPropertyWithNonNullDeserializerAndNonNullNullValue() { [EOL] SettableBeanProperty src = createMockSettableBeanProperty(); [EOL] JsonDeserializer<?> deser = createMockJsonDeserializer(); [EOL] Object nullValue = new Object(); [EOL] when(deser.getNullValue()).thenReturn(nullValue); [EOL] SettableBeanProperty property = new SettableBeanProperty(src, deser); [EOL] assertNotNull(property._nullProvider); [EOL] assertSame(deser, property._valueDeserializer); [EOL] assertEquals(src._propName, property._propName); [EOL] assertEquals(src._type, property._type); [EOL] assertEquals(src._wrapperName, property._wrapperName); [EOL] assertEquals(src._isRequired, property._isRequired); [EOL] assertEquals(src._contextAnnotations, property._contextAnnotations); [EOL] assertEquals(src._valueTypeDeserializer, property._valueTypeDeserializer); [EOL] assertEquals(src._managedReferenceName, property._managedReferenceName); [EOL] assertEquals(src._propertyIndex, property._propertyIndex); [EOL] assertEquals(src._viewMatcher, property._viewMatcher); [EOL] }
public void testSetViewsNull() { [EOL] YourClass instance = new YourClass(); [EOL] instance.setViews(null); [EOL] assertNull(instance._viewMatcher); [EOL] }
public void testSetViewsNonNull() { [EOL] YourClass instance = new YourClass(); [EOL] Class<?>[] views = new Class<?>[] {View1.class, View2.class}; [EOL] instance.setViews(views); [EOL] assertNotNull(instance._viewMatcher); [EOL] }
public void testAssignIndexWithUnassignedProperty() { [EOL] BeanPropertyWriter bpw = new BeanPropertyWriter(); // Assuming a constructor exists [EOL] int index = 1; [EOL] bpw.assignIndex(index); [EOL] assertEquals(index, bpw._propertyIndex); // Assuming a getter or public access exists [EOL] }
public void testAssignIndexWithAlreadyAssignedProperty() { [EOL] BeanPropertyWriter bpw = new BeanPropertyWriter(); // Assuming a constructor exists [EOL] int firstIndex = 1; [EOL] bpw.assignIndex(firstIndex); [EOL] int secondIndex = 2; [EOL] try { [EOL] bpw.assignIndex(secondIndex); [EOL] fail("Expected IllegalStateException not thrown"); [EOL] } catch (IllegalStateException e) { [EOL] assertEquals("Property '" + bpw.getName() + "' already had index (" + firstIndex + "), trying to assign " + secondIndex, e.getMessage()); [EOL] } [EOL] }
public void testGetName() { [EOL] PropertyName propertyName = new PropertyName("testName"); [EOL] String result = propertyName.getName(); [EOL] assert "testName".equals(result); [EOL] }
public void testGetType() { [EOL] MyClass instance = new MyClass(); [EOL] JavaType expectedType = //... initialize with a JavaType instance [EOL] instance.setType(expectedType); [EOL] JavaType result = instance.getType(); [EOL] assertEquals(expectedType, result); [EOL] }
public void testGetManagedReferenceName_Null() { [EOL] BeanPropertyWriter bpw = new BeanPropertyWriter(); [EOL] assertNull(bpw.getManagedReferenceName()); [EOL] }
public void testGetManagedReferenceName_NonNull() { [EOL] BeanPropertyWriter bpw = new BeanPropertyWriter(); [EOL] bpw._managedReferenceName = "managedRef"; [EOL] assertEquals("managedRef", bpw.getManagedReferenceName()); [EOL] }
public void testHasValueDeserializer_WithValueDeserializer() { [EOL] BeanProperty.Bogus _valueDeserializer = new BeanProperty.Bogus(); // Assuming Bogus is a placeholder for the actual type [EOL] BeanProperty property = new BeanProperty(_valueDeserializer); [EOL] boolean result = property.hasValueDeserializer(); [EOL] assert result == true; [EOL] }
public void testHasValueDeserializer_WithMissingValueDeserializer() { [EOL] BeanProperty property = new BeanProperty(BeanProperty.MISSING_VALUE_DESERIALIZER); [EOL] boolean result = property.hasValueDeserializer(); [EOL] assert result == false; [EOL] }
public void testHasValueDeserializer_WithNullValueDeserializer() { [EOL] BeanProperty property = new BeanProperty(null); [EOL] boolean result = property.hasValueDeserializer(); [EOL] assert result == false; [EOL] }
public void testHasValueTypeDeserializer_WithValueTypeDeserializer() { [EOL] BeanProperty.Bogus bogusProperty = new BeanProperty.Bogus(); [EOL] bogusProperty._valueTypeDeserializer = new StdTypeResolverBuilder(); [EOL] boolean result = bogusProperty.hasValueTypeDeserializer(); [EOL] assertTrue(result); [EOL] }
public void testHasValueTypeDeserializer_WithoutValueTypeDeserializer() { [EOL] BeanProperty.Bogus bogusProperty = new BeanProperty.Bogus(); [EOL] bogusProperty._valueTypeDeserializer = null; [EOL] boolean result = bogusProperty.hasValueTypeDeserializer(); [EOL] assertFalse(result); [EOL] }
public void testGetValueDeserializerWhenDeserializerIsMissing() { [EOL] MyClass instance = new MyClass(); [EOL] instance._valueDeserializer = MyClass.MISSING_VALUE_DESERIALIZER; [EOL] JsonDeserializer<Object> result = instance.getValueDeserializer(); [EOL] assertNull(result); [EOL] }
public void testGetValueDeserializerWhenDeserializerIsPresent() { [EOL] MyClass instance = new MyClass(); [EOL] JsonDeserializer<Object> expectedDeserializer = new SomeJsonDeserializerImplementation(); [EOL] instance._valueDeserializer = expectedDeserializer; [EOL] JsonDeserializer<Object> result = instance.getValueDeserializer(); [EOL] assertSame(expectedDeserializer, result); [EOL] }
public void testGetValueTypeDeserializer() { [EOL] BeanProperty.Bogus bogusProperty = new BeanProperty.Bogus(); [EOL] assertNull(bogusProperty.getValueTypeDeserializer()); [EOL] }
public void testHasViewsWhenViewMatcherIsNull() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] SerializationConfig config = mapper.getSerializationConfig(); [EOL] assertFalse(config.hasViews()); [EOL] }
public void testHasViewsWhenViewMatcherIsNotNull() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] mapper.disable(MapperFeature.DEFAULT_VIEW_INCLUSION); [EOL] mapper.setConfig(mapper.getSerializationConfig().withView(Object.class)); [EOL] SerializationConfig config = mapper.getSerializationConfig(); [EOL] assertTrue(config.hasViews()); [EOL] }
public void testDeserializeWithNullToken() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NULL); [EOL] ObjectDeserializer deserializer = new ObjectDeserializer(null, null, null); [EOL] Object result = deserializer.deserialize(jp, ctxt); [EOL] assertNull(result); [EOL] }
public void testDeserializeWithNonNullTokenAndNullProvider() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] ObjectDeserializer deserializer = new ObjectDeserializer(null, null, null); [EOL] Object result = deserializer.deserialize(jp, ctxt); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeWithType() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] ValueTypeDeserializer vtd = mock(ValueTypeDeserializer.class); [EOL] ValueDeserializer vd = mock(ValueDeserializer.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(vd.deserializeWithType(jp, ctxt, vtd)).thenReturn(new Object()); [EOL] ObjectDeserializer deserializer = new ObjectDeserializer(vd, vtd, null); [EOL] Object result = deserializer.deserialize(jp, ctxt); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeWithoutType() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] ValueDeserializer vd = mock(ValueDeserializer.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(vd.deserialize(jp, ctxt)).thenReturn(new Object()); [EOL] ObjectDeserializer deserializer = new ObjectDeserializer(vd, null, null); [EOL] Object result = deserializer.deserialize(jp, ctxt); [EOL] assertNotNull(result); [EOL] }
public void testWritableObjectIdWithNonNullGenerator() { [EOL] ObjectIdGenerator<?> generator = new ObjectIdGenerator<Object>() { [EOL] @Override [EOL] public boolean canUseFor(ObjectIdGenerator<?> gen) { [EOL] return false; [EOL] } [EOL] @Override [EOL] public ObjectIdGenerator<Object> forScope(Class<?> scope) { [EOL] return null; [EOL] } [EOL] @Override [EOL] public ObjectIdGenerator<Object> newForSerialization(Object context) { [EOL] return null; [EOL] } [EOL] @Override [EOL] public IdKey key(Object key) { [EOL] return null; [EOL] } [EOL] @Override [EOL] public Object generateId(Object forPojo) { [EOL] return null; [EOL] } [EOL] }; [EOL] WritableObjectId writableObjectId = new WritableObjectId(generator); [EOL] assertNotNull(writableObjectId.generator); [EOL] }
public void testWriteAsIdWithNonNullIdAndIdWritten() throws IOException { [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] ObjectIdWriter w = mock(ObjectIdWriter.class); [EOL] Object id = new Object(); [EOL] JsonSerializer<Object> serializer = mock(JsonSerializer.class); [EOL] when(w.alwaysAsId).thenReturn(false); [EOL] SomeType instance = new SomeType(id); [EOL] instance.idWritten = true; [EOL] w.serializer = serializer; [EOL] boolean result = instance.writeAsId(jgen, provider, w); [EOL] assertTrue(result); [EOL] verify(serializer).serialize(id, jgen, provider); [EOL] }
public void testWriteAsIdWithNonNullIdAndAlwaysAsId() throws IOException { [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] ObjectIdWriter w = mock(ObjectIdWriter.class); [EOL] Object id = new Object(); [EOL] JsonSerializer<Object> serializer = mock(JsonSerializer.class); [EOL] when(w.alwaysAsId).thenReturn(true); [EOL] SomeType instance = new SomeType(id); [EOL] instance.idWritten = false; [EOL] w.serializer = serializer; [EOL] boolean result = instance.writeAsId(jgen, provider, w); [EOL] assertTrue(result); [EOL] verify(serializer).serialize(id, jgen, provider); [EOL] }
public void testWriteAsIdWithNullId() throws IOException { [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] ObjectIdWriter w = mock(ObjectIdWriter.class); [EOL] JsonSerializer<Object> serializer = mock(JsonSerializer.class); [EOL] when(w.alwaysAsId).thenReturn(true); [EOL] SomeType instance = new SomeType(null); [EOL] instance.idWritten = false; [EOL] w.serializer = serializer; [EOL] boolean result = instance.writeAsId(jgen, provider, w); [EOL] assertFalse(result); [EOL] verify(serializer, never()).serialize(any(), eq(jgen), eq(provider)); [EOL] }
public void testGenerateIdWithNonNullPojo() { [EOL] IdGenerator mockGenerator = mock(IdGenerator.class); [EOL] when(mockGenerator.generateId(any())).thenReturn("generatedId"); [EOL] MyClass myClass = new MyClass(mockGenerator); [EOL] Object pojo = new Object(); [EOL] Object result = myClass.generateId(pojo); [EOL] verify(mockGenerator).generateId(pojo); [EOL] assertEquals("generatedId", result); [EOL] }
public void testGenerateIdWithNullPojo() { [EOL] IdGenerator mockGenerator = mock(IdGenerator.class); [EOL] when(mockGenerator.generateId(null)).thenReturn("generatedIdForNull"); [EOL] MyClass myClass = new MyClass(mockGenerator); [EOL] Object result = myClass.generateId(null); [EOL] verify(mockGenerator).generateId(null); [EOL] assertEquals("generatedIdForNull", result); [EOL] }
public void writeAsField_withNonNullPropertyName() throws IOException { [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] ObjectIdWriter w = mock(ObjectIdWriter.class); [EOL] SerializedString name = mock(SerializedString.class); [EOL] when(w.propertyName).thenReturn(name); [EOL] JsonSerializer<Object> serializer = mock(JsonSerializer.class); [EOL] w.serializer = serializer; [EOL] Object id = new Object(); [EOL] w.id = id; [EOL] writeAsField(jgen, provider, w); [EOL] verify(jgen).writeFieldName(name); [EOL] verify(serializer).serialize(id, jgen, provider); [EOL] assertTrue(idWritten); [EOL] }
public void writeAsField_withNullPropertyName() throws IOException { [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] ObjectIdWriter w = mock(ObjectIdWriter.class); [EOL] when(w.propertyName).thenReturn(null); [EOL] Object id = new Object(); [EOL] w.id = id; [EOL] writeAsField(jgen, provider, w); [EOL] verify(jgen, never()).writeFieldName(any(SerializedString.class)); [EOL] assertFalse(idWritten); [EOL] }
public void testDeserializeFromObjectWithPropertyBasedCreator() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(_propertyBasedCreator).thenReturn(true); [EOL] Object result = deserializeFromObject(jp, ctxt); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeFromObjectWithDelegateDeserializer() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(_propertyBasedCreator).thenReturn(null); [EOL] when(_delegateDeserializer).thenReturn(true); [EOL] Object result = deserializeFromObject(jp, ctxt); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeFromObjectWithAbstractBeanType() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(_propertyBasedCreator).thenReturn(null); [EOL] when(_delegateDeserializer).thenReturn(null); [EOL] when(_beanType.isAbstract()).thenReturn(true); [EOL] assertThrows(JsonMappingException.class, () -> { [EOL] deserializeFromObject(jp, ctxt); [EOL] }); [EOL] }
public void testDeserializeFromObjectWithoutStringCreatorAndDefaultCtor() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(_propertyBasedCreator).thenReturn(null); [EOL] when(_delegateDeserializer).thenReturn(null); [EOL] when(_beanType.isAbstract()).thenReturn(false); [EOL] when(_valueInstantiator.canCreateFromString()).thenReturn(false); [EOL] when(_valueInstantiator.canCreateUsingDefault()).thenReturn(false); [EOL] assertThrows(JsonMappingException.class, () -> { [EOL] deserializeFromObject(jp, ctxt); [EOL] }); [EOL] }
public void testDeserializeFromObjectWithPendingProperties() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(_propertyBasedCreator).thenReturn(null); [EOL] when(_delegateDeserializer).thenReturn(null); [EOL] when(_beanType.isAbstract()).thenReturn(false); [EOL] when(_valueInstantiator.canCreateFromString()).thenReturn(false); [EOL] when(_valueInstantiator.canCreateUsingDefault()).thenReturn(true); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.FIELD_NAME, JsonToken.VALUE_STRING, JsonToken.END_OBJECT); [EOL] when(jp.getCurrentName()).thenReturn("someProperty"); [EOL] SettableBeanProperty prop = mock(SettableBeanProperty.class); [EOL] when(_beanProperties.find("someProperty")).thenReturn(prop); [EOL] Object result = deserializeFromObject(jp, ctxt); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeFromObjectWithIgnorableProps() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(_propertyBasedCreator).thenReturn(null); [EOL] when(_delegateDeserializer).thenReturn(null); [EOL] when(_beanType.isAbstract()).thenReturn(false); [EOL] when(_valueInstantiator.canCreateFromString()).thenReturn(false); [EOL] when(_valueInstantiator.canCreateUsingDefault()).thenReturn(true); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.FIELD_NAME, JsonToken.END_OBJECT); [EOL] when(jp.getCurrentName()).thenReturn("ignorableProperty"); [EOL] when(_ignorableProps.contains("ignorableProperty")).thenReturn(true); [EOL] Object result = deserializeFromObject(jp, ctxt); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeFromObjectWithAnySetter() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(_propertyBasedCreator).thenReturn(null); [EOL] when(_delegateDeserializer).thenReturn(null); [EOL] when(_beanType.isAbstract()).thenReturn(false); [EOL] when(_valueInstantiator.canCreateFromString()).thenReturn(false); [EOL] when(_valueInstantiator.canCreateUsingDefault()).thenReturn(true); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.FIELD_NAME, JsonToken.END_OBJECT); [EOL] when(jp.getCurrentName()).thenReturn("anySetterProperty"); [EOL] when(_anySetter).thenReturn(true); [EOL] Object result = deserializeFromObject(jp, ctxt); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeFromObjectHandleUnknownProperty() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(_propertyBasedCreator).thenReturn(null); [EOL] when(_delegateDeserializer).thenReturn(null); [EOL] when(_beanType.isAbstract()).thenReturn(false); [EOL] when(_valueInstantiator.canCreateFromString()).thenReturn(false); [EOL] when(_valueInstantiator.canCreateUsingDefault()).thenReturn(true); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.FIELD_NAME, JsonToken.END_OBJECT); [EOL] when(jp.getCurrentName()).thenReturn("unknownProperty"); [EOL] when(_ignorableProps.contains("unknownProperty")).thenReturn(false); [EOL] when(_anySetter).thenReturn(null); [EOL] Object result = deserializeFromObject(jp, ctxt); [EOL] assertNotNull(result); [EOL] }
public void testAnnotatedFieldCreationWithNonNullValues() { [EOL] Field field = String.class.getDeclaredFields()[0]; [EOL] AnnotationMap annMap = new AnnotationMap(); [EOL] AnnotatedField annotatedField = new AnnotatedField(field, annMap); [EOL] assertNotNull(annotatedField); [EOL] } [EOL] public void testAnnotatedFieldCreationWithNullField() { [EOL] AnnotationMap annMap = new AnnotationMap(); [EOL] try { [EOL] AnnotatedField annotatedField = new AnnotatedField(null, annMap); [EOL] fail("Expected an exception to be thrown"); [EOL] } catch (NullPointerException e) { [EOL] assertNotNull(e); [EOL] } [EOL] } [EOL] public void testAnnotatedFieldCreationWithNullAnnotationMap() { [EOL] Field field = String.class.getDeclaredFields()[0]; [EOL] try { [EOL] AnnotatedField annotatedField = new AnnotatedField(field, null); [EOL] fail("Expected an exception to be thrown"); [EOL] } catch (NullPointerException e) { [EOL] assertNotNull(e); [EOL] } [EOL] }
public void testAnnotatedFieldCreationWithBothNull() { [EOL] try { [EOL] AnnotatedField annotatedField = new AnnotatedField(null, null); [EOL] fail("Expected an exception to be thrown"); [EOL] } catch (NullPointerException e) { [EOL] assertNotNull(e); [EOL] } [EOL] }
public void testWithAnnotationsNonNull() { [EOL] Field field = String.class.getDeclaredFields()[0]; [EOL] AnnotationMap ann = new AnnotationMap(); [EOL] AnnotatedField annotatedField = new AnnotatedField(field, new AnnotationMap()); [EOL] AnnotatedField newAnnotatedField = annotatedField.withAnnotations(ann); [EOL] assertNotNull(newAnnotatedField); [EOL] assertEquals(ann, newAnnotatedField.getAllAnnotations()); [EOL] }
public void testWithAnnotationsNull() { [EOL] Field field = String.class.getDeclaredFields()[0]; [EOL] AnnotatedField annotatedField = new AnnotatedField(field, new AnnotationMap()); [EOL] AnnotatedField newAnnotatedField = annotatedField.withAnnotations(null); [EOL] assertNotNull(newAnnotatedField); [EOL] assertNull(newAnnotatedField.getAllAnnotations()); [EOL] }
public void testGetAnnotated() { [EOL] Field expectedField = SomeClass.class.getDeclaredField("someFieldName"); [EOL] AnnotatedField af = new AnnotatedField(expectedField); [EOL] Field actualField = af.getAnnotated(); [EOL] assertEquals(expectedField, actualField); [EOL] }
public void testGetModifiers() { [EOL] Field field = String.class.getDeclaredField("value"); [EOL] JacksonField jacksonField = new JacksonField(field); [EOL] int modifiers = jacksonField.getModifiers(); [EOL] assertEquals(field.getModifiers(), modifiers); [EOL] }
public void testGetName() { [EOL] Field field = SomeClass.class.getDeclaredField("someFieldName"); [EOL] field.setAccessible(true); [EOL] PropertyName propertyName = new PropertyName(field.getName()); [EOL] assertEquals("someFieldName", propertyName.getName()); [EOL] }
public void testGetAnnotationWithNullAnnotations() { [EOL] AnnotationCollector ac = new AnnotationCollector(null); [EOL] assertNull(ac.getAnnotation(Deprecated.class)); [EOL] }
public void testGetAnnotationWithNonNullAnnotations() { [EOL] AnnotationCollector ac = new AnnotationCollector(new HashMap<Class<? extends Annotation>, Annotation>()); [EOL] ac._annotations.put(Deprecated.class, Deprecated.class.getAnnotation(Deprecated.class)); [EOL] assertNotNull(ac.getAnnotation(Deprecated.class)); [EOL] }
public void testGetGenericType() throws Exception { [EOL] Field field = SampleClass.class.getDeclaredField("sampleField"); [EOL] JacksonFieldWrapper wrapper = new JacksonFieldWrapper(field); [EOL] Type result = wrapper.getGenericType(); [EOL] assertNotNull(result); [EOL] assertEquals(field.getGenericType(), result); [EOL] }
public void testGetRawType() { [EOL] Field field = String.class.getDeclaredField("value"); [EOL] AnnotatedField annotatedField = new AnnotatedField(null, field, null); [EOL] Class<?> rawType = annotatedField.getRawType(); [EOL] assertEquals(String.class, rawType); [EOL] }
public void testGetMemberWhenFieldIsNull() { [EOL] YourClass instance = new YourClass(null); [EOL] Member result = instance.getMember(); [EOL] assertNull(result); [EOL] }
public void testGetMemberWhenFieldIsNotNull() { [EOL] Member expectedMember = new Member(); [EOL] YourClass instance = new YourClass(expectedMember); [EOL] Member result = instance.getMember(); [EOL] assertSame(expectedMember, result); [EOL] }
public void testSetAndReturnWithNonNullValueAndIsContainerTrueAndValueIsArray() throws IOException { [EOL] Object instance = new Object(); [EOL] Object[] value = new Object[] { new Object(), null }; [EOL] Object result = setAndReturn(instance, value); [EOL] assertNotNull(result); [EOL] }
public void testSetAndReturnWithNonNullValueAndIsContainerTrueAndValueIsCollection() throws IOException { [EOL] Object instance = new Object(); [EOL] Collection<Object> value = Arrays.asList(new Object(), null); [EOL] Object result = setAndReturn(instance, value); [EOL] assertNotNull(result); [EOL] }
public void testSetAndReturnWithNonNullValueAndIsContainerTrueAndValueIsMap() throws IOException { [EOL] Object instance = new Object(); [EOL] Map<String, Object> value = new HashMap<>(); [EOL] value.put("key1", new Object()); [EOL] value.put("key2", null); [EOL] Object result = setAndReturn(instance, value); [EOL] assertNotNull(result); [EOL] }
public void testSetAndReturnWithNonNullValueAndIsContainerFalse() throws IOException { [EOL] Object instance = new Object(); [EOL] Object value = new Object(); [EOL] Object result = setAndReturn(instance, value); [EOL] assertNotNull(result); [EOL] }
public void testSetAndReturnWithNullValue() throws IOException { [EOL] Object instance = new Object(); [EOL] Object value = null; [EOL] Object result = setAndReturn(instance, value); [EOL] assertNull(value); [EOL] assertNotNull(result); [EOL] }
public void testSetAndReturnWithUnsupportedContainerType() { [EOL] Object instance = new Object(); [EOL] Object value = new UnsupportedContainerType(); [EOL] assertThrows(IllegalStateException.class, () -> setAndReturn(instance, value)); [EOL] } [EOL] class UnsupportedContainerType { [EOL] }
protected BeanSerializerBase asArraySerializer() { [EOL] if ((_objectIdWriter == null) && (_anyGetterWriter == null) && (_propertyFilterId == null)) { [EOL] return new BeanAsArraySerializer(this); [EOL] } [EOL] return this; [EOL] }
public void testMissingNodeConstructorIsPrivate() throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException { [EOL] Constructor<MissingNode> constructor = MissingNode.class.getDeclaredConstructor(); [EOL] assertTrue(Modifier.isPrivate(constructor.getModifiers())); [EOL] constructor.setAccessible(true); [EOL] try { [EOL] constructor.newInstance(); [EOL] fail("Expected IllegalAccessException to be thrown"); [EOL] } catch (IllegalAccessException e) { [EOL] } [EOL] }
public void testGetInstance_CoversSingletonInstance() { [EOL] MissingNode firstInstance = MissingNode.getInstance(); [EOL] MissingNode secondInstance = MissingNode.getInstance(); [EOL] assertSame("Instances should be the same as MissingNode is a singleton", firstInstance, secondInstance); [EOL] }
public void testGetNodeType() { [EOL] JsonNode node = MissingNode.getInstance(); [EOL] assertEquals(JsonNodeType.MISSING, node.getNodeType()); [EOL] }
public void testAsToken() { [EOL] YourType obj = new YourType(); [EOL] assertEquals(JsonToken.NOT_AVAILABLE, obj.asToken()); [EOL] }
public void testAsTextReturnsEmptyString() { [EOL] JsonNode node = new TextNode(""); [EOL] String result = node.asText(); [EOL] assertEquals("", result); [EOL] }
public void testEqualsWithSameObject() { [EOL] Object obj = new Object(); [EOL] assertTrue(obj.equals(obj)); [EOL] }
public void testEqualsWithDifferentObject() { [EOL] Object obj1 = new Object(); [EOL] Object obj2 = new Object(); [EOL] assertFalse(obj1.equals(obj2)); [EOL] }
public String toStringTest() { [EOL] MyClass obj = new MyClass(); [EOL] String result = obj.toString(); [EOL] assert "".equals(result); [EOL] }
public void testWriteTypePrefixForScalar() throws IOException, JsonProcessingException { [EOL] Object value = new Object(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] writeTypePrefixForScalar(value, jgen); [EOL] verify(jgen).writeFieldName(anyString()); [EOL] }
public void testWriteTypeSuffixForScalarWithNullValue() throws IOException, JsonProcessingException { [EOL] TypeNameIdResolver resolver = TypeNameIdResolver.construct(mock(MapperConfig.class), mock(JavaType.class), Collections.emptyList(), false, false); [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] Object value = null; [EOL] resolver.writeTypeSuffixForScalar(value, mockJsonGenerator); [EOL] verify(mockJsonGenerator, never()).writeString(anyString()); [EOL] }
public void testWriteTypeSuffixForScalarWithNonNullValue() throws IOException, JsonProcessingException { [EOL] TypeNameIdResolver resolver = TypeNameIdResolver.construct(mock(MapperConfig.class), mock(JavaType.class), Collections.emptyList(), false, false); [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] Object value = new Object(); [EOL] when(resolver.idFromValue(value)).thenReturn("typeId"); [EOL] resolver.writeTypeSuffixForScalar(value, mockJsonGenerator); [EOL] verify(mockJsonGenerator).writeString("typeId"); [EOL] }
public void testWriteScalarPrefixWithNullValue() throws IOException, JsonProcessingException { [EOL] Object value = null; [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] _writeScalarPrefix(value, jgen); [EOL] } [EOL] public void testWriteScalarPrefixWithNonNullValue() throws IOException, JsonProcessingException { [EOL] Object value = new Object(); // Replace with a meaningful instance [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] _writeScalarPrefix(value, jgen); [EOL] }
public void testWriteScalarSuffixWithNonNullValues() throws IOException, JsonProcessingException { [EOL] Object value = new Object(); [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] String typeId = "testTypeId"; [EOL] String typePropertyName = "_typePropertyName"; [EOL] TestClass testInstance = new TestClass(typePropertyName); // Assuming TestClass is the enclosing class of _writeScalarSuffix [EOL] testInstance._writeScalarSuffix(value, mockJsonGenerator, typeId); [EOL] verify(mockJsonGenerator).writeStringField(typePropertyName, typeId); [EOL] }
public void testWriteScalarSuffixWithNullTypeId() throws IOException, JsonProcessingException { [EOL] Object value = new Object(); [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] String typeId = null; [EOL] String typePropertyName = "_typePropertyName"; [EOL] TestClass testInstance = new TestClass(typePropertyName); // Assuming TestClass is the enclosing class of _writeScalarSuffix [EOL] testInstance._writeScalarSuffix(value, mockJsonGenerator, typeId); [EOL] verify(mockJsonGenerator, never()).writeStringField(anyString(), anyString()); [EOL] }
public void testHandlePropertyValueWithUnknownProperty() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] String propName = "unknownProperty"; [EOL] Object bean = new Object(); [EOL] boolean result = handlePropertyValue(jp, ctxt, propName, bean); [EOL] assertFalse(result); [EOL] }
public void testHandlePropertyValueWithTypePropertyName() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] String propName = "typePropertyName"; [EOL] Object bean = new Object(); [EOL] when(_nameToPropertyIndex.get(propName)).thenReturn(0); [EOL] ExtTypedProperty prop = mock(ExtTypedProperty.class); [EOL] when(prop.hasTypePropertyName(propName)).thenReturn(true); [EOL] when(jp.getText()).thenReturn("typeId"); [EOL] _properties[0] = prop; [EOL] boolean result = handlePropertyValue(jp, ctxt, propName, bean); [EOL] assertTrue(result); [EOL] assertEquals("typeId", _typeIds[0]); [EOL] assertNull(_tokens[0]); [EOL] }
public void testHandlePropertyValueWithRegularProperty() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] String propName = "regularProperty"; [EOL] Object bean = new Object(); [EOL] when(_nameToPropertyIndex.get(propName)).thenReturn(0); [EOL] ExtTypedProperty prop = mock(ExtTypedProperty.class); [EOL] when(prop.hasTypePropertyName(propName)).thenReturn(false); [EOL] TokenBuffer tokens = new TokenBuffer(jp.getCodec()); [EOL] _properties[0] = prop; [EOL] boolean result = handlePropertyValue(jp, ctxt, propName, bean); [EOL] assertTrue(result); [EOL] assertNotNull(_tokens[0]); [EOL] }
public void testHandlePropertyValueWithNullBean() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] String propName = "propertyWithNullBean"; [EOL] Object bean = null; [EOL] when(_nameToPropertyIndex.get(propName)).thenReturn(0); [EOL] ExtTypedProperty prop = mock(ExtTypedProperty.class); [EOL] when(prop.hasTypePropertyName(propName)).thenReturn(false); [EOL] TokenBuffer tokens = new TokenBuffer(jp.getCodec()); [EOL] _properties[0] = prop; [EOL] boolean result = handlePropertyValue(jp, ctxt, propName, bean); [EOL] assertTrue(result); [EOL] assertNull(_typeIds[0]); [EOL] }
public void testJsonSerializerMapWithEmptyMap() { [EOL] Map<TypeKey, JsonSerializer<Object>> serializers = new HashMap<>(); [EOL] JsonSerializerMap serializerMap = new JsonSerializerMap(serializers); [EOL] assertNotNull(serializerMap); [EOL] assertEquals(0, serializerMap.size()); [EOL] }
public void testJsonSerializerMapWithSingleElement() { [EOL] Map<TypeKey, JsonSerializer<Object>> serializers = new HashMap<>(); [EOL] TypeKey key = new TypeKey(SomeClass.class, false); [EOL] JsonSerializer<Object> serializer = new SomeJsonSerializer(); [EOL] serializers.put(key, serializer); [EOL] JsonSerializerMap serializerMap = new JsonSerializerMap(serializers); [EOL] assertNotNull(serializerMap); [EOL] assertEquals(1, serializerMap.size()); [EOL] assertSame(serializer, serializerMap.find(key)); [EOL] }
public void testJsonSerializerMapWithCollisions() { [EOL] Map<TypeKey, JsonSerializer<Object>> serializers = new HashMap<>(); [EOL] TypeKey key1 = new TypeKey(SomeClass.class, false); [EOL] TypeKey key2 = new TypeKey(AnotherClass.class, false) { [EOL] @Override [EOL] public int hashCode() { [EOL] return key1.hashCode(); // Force a collision [EOL] } [EOL] }; [EOL] JsonSerializer<Object> serializer1 = new SomeJsonSerializer(); [EOL] JsonSerializer<Object> serializer2 = new AnotherJsonSerializer(); [EOL] serializers.put(key1, serializer1); [EOL] serializers.put(key2, serializer2); [EOL] JsonSerializerMap serializerMap = new JsonSerializerMap(serializers); [EOL] assertNotNull(serializerMap); [EOL] assertEquals(2, serializerMap.size()); [EOL] assertSame(serializer1, serializerMap.find(key1)); [EOL] assertSame(serializer2, serializerMap.find(key2)); [EOL] }
public void testFindSizeForSizeLessThanOrEqualTo64() { [EOL] int size = 32; // Any value less than or equal to 64 [EOL] int expected = 64; // The smallest power of 2 that is greater than or equal to (size + size) [EOL] int actual = findSize(size); [EOL] assertEquals(expected, actual); [EOL] }
public void testFindSizeForSizeGreaterThan64() { [EOL] int size = 100; // Any value greater than 64 [EOL] int expected = 128; // The smallest power of 2 that is greater than or equal to (size + (size >> 2)) [EOL] int actual = findSize(size); [EOL] assertEquals(expected, actual); [EOL] }
public void testFindWithNullBucket() { [EOL] TypeKey key = new TypeKey(SomeClass.class, false); [EOL] JsonSerializer<Object> result = find(key); [EOL] assertNull(result); [EOL] }
public void testFindWithMatchingKeyInFirstBucket() { [EOL] TypeKey key = new TypeKey(SomeClass.class, false); [EOL] Bucket bucket = new Bucket(key, new SomeJsonSerializer(), null); [EOL] _buckets[key.hashCode() & (_buckets.length - 1)] = bucket; [EOL] JsonSerializer<Object> result = find(key); [EOL] assertNotNull(result); [EOL] assertSame(bucket.value, result); [EOL] }
public void testFindWithMatchingKeyInSubsequentBucket() { [EOL] TypeKey key = new TypeKey(SomeClass.class, false); [EOL] Bucket bucket1 = new Bucket(new TypeKey(OtherClass.class, false), new SomeJsonSerializer(), null); [EOL] Bucket bucket2 = new Bucket(key, new SomeJsonSerializer(), null); [EOL] bucket1.next = bucket2; [EOL] _buckets[key.hashCode() & (_buckets.length - 1)] = bucket1; [EOL] JsonSerializer<Object> result = find(key); [EOL] assertNotNull(result); [EOL] assertSame(bucket2.value, result); [EOL] }
public void testMapperConfigWithNonNullBaseSettings() { [EOL] BaseSettings baseSettings = new BaseSettings(null, null, null, null, null, null, null, null, null, null, null, null); [EOL] int mapperFeatures = 0; [EOL] MapperConfig<?> mapperConfig = new MapperConfig<>(baseSettings, mapperFeatures); [EOL] assertNotNull(mapperConfig); [EOL] assertEquals(baseSettings, mapperConfig.getBaseSettings()); [EOL] assertEquals(mapperFeatures, mapperConfig.getMapperFeatures()); [EOL] }
public void testMapperConfigWithDifferentMapperFeatures() { [EOL] BaseSettings baseSettings = new BaseSettings(null, null, null, null, null, null, null, null, null, null, null, null); [EOL] int mapperFeatures = 123; [EOL] MapperConfig<?> mapperConfig = new MapperConfig<>(baseSettings, mapperFeatures); [EOL] assertNotNull(mapperConfig); [EOL] assertEquals(baseSettings, mapperConfig.getBaseSettings()); [EOL] assertEquals(mapperFeatures, mapperConfig.getMapperFeatures()); [EOL] }
protected void testMapperConfigCopyConstructor() { [EOL] MapperConfig<?> original = createOriginalMapperConfig(); [EOL] MapperConfig<?> copy = new MapperConfig<>(original); [EOL] assertEquals(original._base, copy._base); [EOL] assertEquals(original._mapperFeatures, copy._mapperFeatures); [EOL] }
public void testCollectFeatureDefaultsAllEnabled() { [EOL] int flags = ClassName.collectFeatureDefaults(AllEnabledEnum.class); [EOL] assertEquals(AllEnabledEnum.ALL.getMask(), flags); [EOL] } [EOL] public void testCollectFeatureDefaultsNoneEnabled() { [EOL] int flags = ClassName.collectFeatureDefaults(NoneEnabledEnum.class); [EOL] assertEquals(0, flags); [EOL] } [EOL] public void testCollectFeatureDefaultsSomeEnabled() { [EOL] int flags = ClassName.collectFeatureDefaults(SomeEnabledEnum.class); [EOL] int expectedFlags = SomeEnabledEnum.FIRST.getMask() | SomeEnabledEnum.SECOND.getMask(); [EOL] assertEquals(expectedFlags, flags); [EOL] }

public void testIsEnabledWithFeatureEnabled() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] mapper.enable(MapperFeature.USE_ANNOTATIONS); [EOL] assertTrue(mapper.isEnabled(MapperFeature.USE_ANNOTATIONS)); [EOL] }
public void testIsEnabledWithFeatureDisabled() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] mapper.disable(MapperFeature.USE_ANNOTATIONS); [EOL] assertFalse(mapper.isEnabled(MapperFeature.USE_ANNOTATIONS)); [EOL] }
public void testIsAnnotationProcessingEnabled_WhenUseAnnotationsEnabled() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] mapper.enable(MapperFeature.USE_ANNOTATIONS); [EOL] assertTrue(mapper.isAnnotationProcessingEnabled()); [EOL] }
public void testIsAnnotationProcessingEnabled_WhenUseAnnotationsDisabled() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] mapper.disable(MapperFeature.USE_ANNOTATIONS); [EOL] assertFalse(mapper.isAnnotationProcessingEnabled()); [EOL] }
public void testCanOverrideAccessModifiers_Enabled() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] mapper.enable(MapperFeature.CAN_OVERRIDE_ACCESS_MODIFIERS); [EOL] assertTrue(mapper.getDeserializationConfig().canOverrideAccessModifiers()); [EOL] }
public void testCanOverrideAccessModifiers_Disabled() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] mapper.disable(MapperFeature.CAN_OVERRIDE_ACCESS_MODIFIERS); [EOL] assertFalse(mapper.getDeserializationConfig().canOverrideAccessModifiers()); [EOL] }
public void testShouldSortPropertiesAlphabetically_Enabled() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] mapper.enable(MapperFeature.SORT_PROPERTIES_ALPHABETICALLY); [EOL] boolean result = mapper.getSerializationConfig().shouldSortPropertiesAlphabetically(); [EOL] assertTrue(result); [EOL] }
public void testShouldSortPropertiesAlphabetically_Disabled() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] mapper.disable(MapperFeature.SORT_PROPERTIES_ALPHABETICALLY); [EOL] boolean result = mapper.getSerializationConfig().shouldSortPropertiesAlphabetically(); [EOL] assertFalse(result); [EOL] }
public void testGetClassIntrospector() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] ClassIntrospector introspector = mapper.getSerializationConfig().getClassIntrospector(); [EOL] assertNotNull(introspector); [EOL] }
public void testGetAnnotationIntrospector() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] AnnotationIntrospector introspector = mapper.getSerializationConfig().getAnnotationIntrospector(); [EOL] assertNotNull(introspector); [EOL] }
public void testGetDefaultVisibilityChecker() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] VisibilityChecker<?> visibilityChecker = mapper.getSerializationConfig().getDefaultVisibilityChecker(); [EOL] assertNotNull(visibilityChecker); [EOL] }
public void testGetPropertyNamingStrategy() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] assertNull(mapper.getPropertyNamingStrategy()); [EOL] PropertyNamingStrategy strategy = PropertyNamingStrategy.SNAKE_CASE; [EOL] mapper.setPropertyNamingStrategy(strategy); [EOL] assertSame(strategy, mapper.getPropertyNamingStrategy()); [EOL] }
public void testGetHandlerInstantiatorWithNonNullBase() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] HandlerInstantiator hi = new HandlerInstantiator() {}; [EOL] mapper.setHandlerInstantiator(hi); [EOL] assertEquals(hi, mapper.getHandlerInstantiator()); [EOL] }
public void testGetHandlerInstantiatorWithNullBase() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] assertNull(mapper.getHandlerInstantiator()); [EOL] }
public void testGetDefaultTyperWithNonNullBaseType() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] JavaType baseType = mapper.constructType(Object.class); [EOL] TypeResolverBuilder<?> result = mapper.getSerializationConfig().getDefaultTyper(baseType); [EOL] assertNotNull(result); [EOL] }
public void testGetDefaultTyperWithNullBaseType() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] TypeResolverBuilder<?> result = mapper.getSerializationConfig().getDefaultTyper(null); [EOL] assertNull(result); [EOL] }
public void testGetTypeFactory() { [EOL] ObjectMapper objectMapper = new ObjectMapper(); [EOL] TypeFactory typeFactory = objectMapper.getTypeFactory(); [EOL] assertNotNull(typeFactory); [EOL] }
public void testConstructTypeWithNonNullClass() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] JavaType javaType = mapper.constructType(String.class); [EOL] assertNotNull(javaType); [EOL] assertEquals(String.class, javaType.getRawClass()); [EOL] }
public void testConstructTypeWithNullClass() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] try { [EOL] mapper.constructType(null); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testConstructSpecializedTypeWithValidInput() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] JavaType baseType = mapper.getTypeFactory().constructType(BaseClass.class); [EOL] JavaType specializedType = mapper.constructSpecializedType(baseType, SubClass.class); [EOL] assertNotNull(specializedType); [EOL] assertEquals(SubClass.class, specializedType.getRawClass()); [EOL] }
public void testConstructSpecializedTypeWithNullBaseType() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] try { [EOL] mapper.constructSpecializedType(null, SubClass.class); [EOL] fail("Expected IllegalArgumentException for null baseType"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testConstructSpecializedTypeWithNullSubclass() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] JavaType baseType = mapper.getTypeFactory().constructType(BaseClass.class); [EOL] try { [EOL] mapper.constructSpecializedType(baseType, null); [EOL] fail("Expected IllegalArgumentException for null subclass"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testIntrospectClassAnnotationsWithNullClass() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] BeanDescription result = mapper.getSerializationConfig().introspectClassAnnotations(null); [EOL] assertNull(result); [EOL] }
public void testIntrospectClassAnnotationsWithValidClass() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] BeanDescription result = mapper.getSerializationConfig().introspectClassAnnotations(Object.class); [EOL] assertNotNull(result); [EOL] assertEquals(Object.class, result.getClassInfo().getAnnotated()); [EOL] }
public void testMapperFeatureWithTrue() { [EOL] MapperFeature feature = new MapperFeature(true); [EOL] assertTrue(feature._defaultState); [EOL] }
public void testMapperFeatureWithFalse() { [EOL] MapperFeature feature = new MapperFeature(false); [EOL] assertFalse(feature._defaultState); [EOL] }
public void testEnabledByDefaultWhenDefaultStateIsTrue() { [EOL] Feature feature = new Feature() { [EOL] public boolean enabledByDefault() { [EOL] return true; [EOL] } [EOL] }; [EOL] assertTrue(feature.enabledByDefault()); [EOL] }
public void testEnabledByDefaultWhenDefaultStateIsFalse() { [EOL] Feature feature = new Feature() { [EOL] public boolean enabledByDefault() { [EOL] return false; [EOL] } [EOL] }; [EOL] assertFalse(feature.enabledByDefault()); [EOL] }
public void testGetMaskForFirstEnumConstant() { [EOL] EnumType firstEnumConstant = EnumType.FIRST_CONSTANT; [EOL] int expectedMask = 1; // Assuming FIRST_CONSTANT is the first enum constant [EOL] int actualMask = firstEnumConstant.getMask(); [EOL] assertEquals(expectedMask, actualMask); [EOL] }
public void testGetMaskForSecondEnumConstant() { [EOL] EnumType secondEnumConstant = EnumType.SECOND_CONSTANT; [EOL] int expectedMask = 2; // Assuming SECOND_CONSTANT is the second enum constant [EOL] int actualMask = secondEnumConstant.getMask(); [EOL] assertEquals(expectedMask, actualMask); [EOL] }
public void testGetMaskForThirdEnumConstant() { [EOL] EnumType thirdEnumConstant = EnumType.THIRD_CONSTANT; [EOL] int expectedMask = 4; // Assuming THIRD_CONSTANT is the third enum constant [EOL] int actualMask = thirdEnumConstant.getMask(); [EOL] assertEquals(expectedMask, actualMask); [EOL] }
public void testDeepCopy() { [EOL] JsonNode originalNode = new TextNode("test"); [EOL] JsonNode copiedNode = originalNode.deepCopy(); [EOL] assertNotSame(originalNode, copiedNode); [EOL] assertEquals(originalNode, copiedNode); [EOL] }
public void testStdTypeResolverBuilderConstructor() { [EOL] StdTypeResolverBuilder builder = new StdTypeResolverBuilder(); [EOL] assertNotNull(builder); [EOL] }
public void testInitWithNonNullIdTypeAndNullIdResolver() { [EOL] StdTypeResolverBuilder builder = new StdTypeResolverBuilder(); [EOL] JsonTypeInfo.Id idType = JsonTypeInfo.Id.CLASS; [EOL] builder.init(idType, null); [EOL] assertEquals(idType, builder._idType); [EOL] assertNull(builder._customIdResolver); [EOL] assertEquals(idType.getDefaultPropertyName(), builder._typeProperty); [EOL] }
public void testInitWithNullIdType() { [EOL] try { [EOL] StdTypeResolverBuilder builder = new StdTypeResolverBuilder(); [EOL] builder.init(null, null); [EOL] fail("Expected IllegalArgumentException not thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("idType can not be null", e.getMessage()); [EOL] } [EOL] }
public void testBuildTypeSerializerWithIdNone() { [EOL] SerializationConfig config = new SerializationConfig(); [EOL] JavaType baseType = new JavaType(); [EOL] Collection<NamedType> subtypes = new ArrayList<>(); [EOL] JsonTypeInfo.Id _idType = JsonTypeInfo.Id.NONE; [EOL] TypeSerializer result = buildTypeSerializer(config, baseType, subtypes); [EOL] assertNull(result); [EOL] }
public void testBuildTypeSerializerWithWrapperArray() { [EOL] SerializationConfig config = new SerializationConfig(); [EOL] JavaType baseType = new JavaType(); [EOL] Collection<NamedType> subtypes = new ArrayList<>(); [EOL] JsonTypeInfo.Id _idType = JsonTypeInfo.Id.CUSTOM; // Assuming CUSTOM is a valid Id for this context [EOL] JsonTypeInfo.As _includeAs = JsonTypeInfo.As.WRAPPER_ARRAY; [EOL] TypeSerializer result = buildTypeSerializer(config, baseType, subtypes); [EOL] assertTrue(result instanceof AsArrayTypeSerializer); [EOL] }
public void testBuildTypeSerializerWithProperty() { [EOL] SerializationConfig config = new SerializationConfig(); [EOL] JavaType baseType = new JavaType(); [EOL] Collection<NamedType> subtypes = new ArrayList<>(); [EOL] JsonTypeInfo.Id _idType = JsonTypeInfo.Id.CUSTOM; [EOL] JsonTypeInfo.As _includeAs = JsonTypeInfo.As.PROPERTY; [EOL] String _typeProperty = "typeProperty"; [EOL] TypeSerializer result = buildTypeSerializer(config, baseType, subtypes); [EOL] assertTrue(result instanceof AsPropertyTypeSerializer); [EOL] }
public void testBuildTypeSerializerWithWrapperObject() { [EOL] SerializationConfig config = new SerializationConfig(); [EOL] JavaType baseType = new JavaType(); [EOL] Collection<NamedType> subtypes = new ArrayList<>(); [EOL] JsonTypeInfo.Id _idType = JsonTypeInfo.Id.CUSTOM; [EOL] JsonTypeInfo.As _includeAs = JsonTypeInfo.As.WRAPPER_OBJECT; [EOL] TypeSerializer result = buildTypeSerializer(config, baseType, subtypes); [EOL] assertTrue(result instanceof AsWrapperTypeSerializer); [EOL] }
public void testBuildTypeSerializerWithExternalProperty() { [EOL] SerializationConfig config = new SerializationConfig(); [EOL] JavaType baseType = new JavaType(); [EOL] Collection<NamedType> subtypes = new ArrayList<>(); [EOL] JsonTypeInfo.Id _idType = JsonTypeInfo.Id.CUSTOM; [EOL] JsonTypeInfo.As _includeAs = JsonTypeInfo.As.EXTERNAL_PROPERTY; [EOL] String _typeProperty = "typeProperty"; [EOL] TypeSerializer result = buildTypeSerializer(config, baseType, subtypes); [EOL] assertTrue(result instanceof AsExternalTypeSerializer); [EOL] }
public void testBuildTypeSerializerWithIllegalStateException() { [EOL] SerializationConfig config = new SerializationConfig(); [EOL] JavaType baseType = new JavaType(); [EOL] Collection<NamedType> subtypes = new ArrayList<>(); [EOL] JsonTypeInfo.Id _idType = JsonTypeInfo.Id.CUSTOM; [EOL] JsonTypeInfo.As _includeAs = JsonTypeInfo.As.OTHER; // Assuming OTHER is a value that leads to the default case [EOL] assertThrows(IllegalStateException.class, () -> { [EOL] buildTypeSerializer(config, baseType, subtypes); [EOL] }); [EOL] }
public void testBuildTypeDeserializerWithIdTypeNone() { [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] JavaType baseType = mock(JavaType.class); [EOL] Collection<NamedType> subtypes = mock(Collection.class); [EOL] StdTypeResolverBuilder builder = new StdTypeResolverBuilder(); [EOL] builder.init(JsonTypeInfo.Id.NONE, null); [EOL] TypeDeserializer result = builder.buildTypeDeserializer(config, baseType, subtypes); [EOL] assertNull(result); [EOL] }
public void testBuildTypeDeserializerWithWrapperArray() { [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] JavaType baseType = mock(JavaType.class); [EOL] Collection<NamedType> subtypes = mock(Collection.class); [EOL] StdTypeResolverBuilder builder = new StdTypeResolverBuilder(); [EOL] builder.init(JsonTypeInfo.Id.CLASS, null); [EOL] builder.inclusion(JsonTypeInfo.As.WRAPPER_ARRAY); [EOL] TypeDeserializer result = builder.buildTypeDeserializer(config, baseType, subtypes); [EOL] assertTrue(result instanceof AsArrayTypeDeserializer); [EOL] }
public void testBuildTypeDeserializerWithProperty() { [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] JavaType baseType = mock(JavaType.class); [EOL] Collection<NamedType> subtypes = mock(Collection.class); [EOL] StdTypeResolverBuilder builder = new StdTypeResolverBuilder(); [EOL] builder.init(JsonTypeInfo.Id.CLASS, null); [EOL] builder.inclusion(JsonTypeInfo.As.PROPERTY); [EOL] TypeDeserializer result = builder.buildTypeDeserializer(config, baseType, subtypes); [EOL] assertTrue(result instanceof AsPropertyTypeDeserializer); [EOL] }
public void testBuildTypeDeserializerWithWrapperObject() { [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] JavaType baseType = mock(JavaType.class); [EOL] Collection<NamedType> subtypes = mock(Collection.class); [EOL] StdTypeResolverBuilder builder = new StdTypeResolverBuilder(); [EOL] builder.init(JsonTypeInfo.Id.CLASS, null); [EOL] builder.inclusion(JsonTypeInfo.As.WRAPPER_OBJECT); [EOL] TypeDeserializer result = builder.buildTypeDeserializer(config, baseType, subtypes); [EOL] assertTrue(result instanceof AsWrapperTypeDeserializer); [EOL] }
public void testBuildTypeDeserializerWithExternalProperty() { [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] JavaType baseType = mock(JavaType.class); [EOL] Collection<NamedType> subtypes = mock(Collection.class); [EOL] StdTypeResolverBuilder builder = new StdTypeResolverBuilder(); [EOL] builder.init(JsonTypeInfo.Id.CLASS, null); [EOL] builder.inclusion(JsonTypeInfo.As.EXTERNAL_PROPERTY); [EOL] TypeDeserializer result = builder.buildTypeDeserializer(config, baseType, subtypes); [EOL] assertTrue(result instanceof AsExternalTypeDeserializer); [EOL] }
public void testBuildTypeDeserializerWithIllegalStateException() { [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] JavaType baseType = mock(JavaType.class); [EOL] Collection<NamedType> subtypes = mock(Collection.class); [EOL] StdTypeResolverBuilder builder = new StdTypeResolverBuilder(); [EOL] builder.init(JsonTypeInfo.Id.CLASS, null); [EOL] builder.inclusion(null); [EOL] Exception exception = assertThrows(IllegalStateException.class, () -> { [EOL] builder.buildTypeDeserializer(config, baseType, subtypes); [EOL] }); [EOL] String expectedMessage = "Do not know how to construct standard type serializer for inclusion type: null"; [EOL] String actualMessage = exception.getMessage(); [EOL] assertTrue(actualMessage.contains(expectedMessage)); [EOL] }
public void testInclusionWithNull() { [EOL] StdTypeResolverBuilder builder = new StdTypeResolverBuilder(); [EOL] try { [EOL] builder.inclusion(null); [EOL] fail("Expected IllegalArgumentException not thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("includeAs can not be null", e.getMessage()); [EOL] } [EOL] }
public void testInclusionWithNonNull() { [EOL] StdTypeResolverBuilder builder = new StdTypeResolverBuilder(); [EOL] StdTypeResolverBuilder result = builder.inclusion(JsonTypeInfo.As.PROPERTY); [EOL] assertNotNull(result); [EOL] assertSame(builder, result); [EOL] }
public void testTypePropertyWithNull() { [EOL] StdTypeResolverBuilder builder = new StdTypeResolverBuilder(); [EOL] StdTypeResolverBuilder result = builder.typeProperty(null); [EOL] assertNotNull(result); [EOL] assertEquals(builder.getDefaultPropertyName(), builder.typeProperty); [EOL] }
public void testTypePropertyWithEmptyString() { [EOL] StdTypeResolverBuilder builder = new StdTypeResolverBuilder(); [EOL] StdTypeResolverBuilder result = builder.typeProperty(""); [EOL] assertNotNull(result); [EOL] assertEquals(builder.getDefaultPropertyName(), builder.typeProperty); [EOL] }
public void testTypePropertyWithNonEmptyString() { [EOL] StdTypeResolverBuilder builder = new StdTypeResolverBuilder(); [EOL] String nonEmptyString = "typeId"; [EOL] StdTypeResolverBuilder result = builder.typeProperty(nonEmptyString); [EOL] assertNotNull(result); [EOL] assertEquals(nonEmptyString, builder.typeProperty); [EOL] }
public void testTypeIdVisibilityTrue() { [EOL] StdTypeResolverBuilder builder = new StdTypeResolverBuilder(); [EOL] StdTypeResolverBuilder result = builder.typeIdVisibility(true); [EOL] assertTrue(builder._typeIdVisible); [EOL] assertSame(builder, result); [EOL] }
public void testTypeIdVisibilityFalse() { [EOL] StdTypeResolverBuilder builder = new StdTypeResolverBuilder(); [EOL] StdTypeResolverBuilder result = builder.typeIdVisibility(false); [EOL] assertFalse(builder._typeIdVisible); [EOL] assertSame(builder, result); [EOL] }
protected TypeIdResolver idResolver(MapperConfig<?> config, JavaType baseType, Collection<NamedType> subtypes, boolean forSer, boolean forDeser) { [EOL] if (_customIdResolver != null) { [EOL] return _customIdResolver; [EOL] } [EOL] if (_idType == null) { [EOL] throw new IllegalStateException("Can not build, 'init()' not yet called"); [EOL] } [EOL] switch(_idType) { [EOL] case CLASS: [EOL] return new ClassNameIdResolver(baseType, config.getTypeFactory()); [EOL] case MINIMAL_CLASS: [EOL] return new MinimalClassNameIdResolver(baseType, config.getTypeFactory()); [EOL] case NAME: [EOL] return TypeNameIdResolver.construct(config, baseType, subtypes, forSer, forDeser); [EOL] case NONE: [EOL] return null; [EOL] case CUSTOM: [EOL] } [EOL] throw new IllegalStateException("Do not know how to construct standard type id resolver for idType: " + _idType); [EOL] }
public void testWithContentTypeHandlerSameHandler() { [EOL] ArrayType original = //... initialize with _componentType, _emptyArray, _valueHandler, _typeHandler, _asStatic [EOL] Object sameHandler = original.getComponentType().getTypeHandler(); [EOL] ArrayType result = original.withContentTypeHandler(sameHandler); [EOL] assertSame("Should return the same ArrayType object if handler is the same", original, result); [EOL] }
public void testWithContentTypeHandlerDifferentHandler() { [EOL] ArrayType original = //... initialize with _componentType, _emptyArray, _valueHandler, _typeHandler, _asStatic [EOL] Object newHandler = //... create a different handler [EOL] ArrayType result = original.withContentTypeHandler(newHandler); [EOL] assertNotSame("Should return a new ArrayType object if handler is different", original, result); [EOL] assertNotNull("New ArrayType object should not be null", result); [EOL] }
public void testNarrowWithNonArrayClass() { [EOL] try { [EOL] instance._narrow(String.class); [EOL] fail("Expected IllegalArgumentException for non-array class"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Incompatible narrowing operation: trying to narrow " + javaTypeInstance.toString() + " to class java.lang.String", e.getMessage()); [EOL] } [EOL] }
public void testNarrowWithArrayClass() { [EOL] JavaType result = instance._narrow(String[].class); [EOL] assertNotNull(result); [EOL] }
public void testFailingDeserializerWithNullMessage() { [EOL] FailingDeserializer deserializer = new FailingDeserializer(null); [EOL] assertNull(deserializer.getMessage()); [EOL] }
public void testFailingDeserializerWithEmptyMessage() { [EOL] FailingDeserializer deserializer = new FailingDeserializer(""); [EOL] assertEquals("", deserializer.getMessage()); [EOL] }
public void testFailingDeserializerWithNonEmptyMessage() { [EOL] String testMessage = "Test Message"; [EOL] FailingDeserializer deserializer = new FailingDeserializer(testMessage); [EOL] assertEquals(testMessage, deserializer.getMessage()); [EOL] }
public void testAddAll() { [EOL] Map<String, JsonSerializer<?>> allDeserializers = new HashMap<>(); [EOL] StdSerializer.addAll(allDeserializers); // Assuming the method is in StdSerializer class [EOL] assertTrue(allDeserializers.containsKey(Integer.class.getName())); [EOL] assertTrue(allDeserializers.get(Integer.class.getName()) instanceof IntegerSerializer); [EOL] assertTrue(allDeserializers.containsKey(Integer.TYPE.getName())); [EOL] assertTrue(allDeserializers.get(Integer.TYPE.getName()) instanceof IntegerSerializer); [EOL] assertTrue(allDeserializers.containsKey(Long.class.getName())); [EOL] assertSame(allDeserializers.get(Long.class.getName()), LongSerializer.instance); [EOL] assertTrue(allDeserializers.containsKey(Long.TYPE.getName())); [EOL] assertSame(allDeserializers.get(Long.TYPE.getName()), LongSerializer.instance); [EOL] assertTrue(allDeserializers.containsKey(Byte.class.getName())); [EOL] assertSame(allDeserializers.get(Byte.class.getName()), IntLikeSerializer.instance); [EOL] assertTrue(allDeserializers.containsKey(Byte.TYPE.getName())); [EOL] assertSame(allDeserializers.get(Byte.TYPE.getName()), IntLikeSerializer.instance); [EOL] assertTrue(allDeserializers.containsKey(Short.class.getName())); [EOL] assertSame(allDeserializers.get(Short.class.getName()), ShortSerializer.instance); [EOL] assertTrue(allDeserializers.containsKey(Short.TYPE.getName())); [EOL] assertSame(allDeserializers.get(Short.TYPE.getName()), ShortSerializer.instance); [EOL] assertTrue(allDeserializers.containsKey(Float.class.getName())); [EOL] assertSame(allDeserializers.get(Float.class.getName()), FloatSerializer.instance); [EOL] assertTrue(allDeserializers.containsKey(Float.TYPE.getName())); [EOL] assertSame(allDeserializers.get(Float.TYPE.getName()), FloatSerializer.instance); [EOL] assertTrue(allDeserializers.containsKey(Double.class.getName())); [EOL] assertSame(allDeserializers.get(Double.class.getName()), DoubleSerializer.instance); [EOL] assertTrue(allDeserializers.containsKey(Double.TYPE.getName())); [EOL] assertSame(allDeserializers.get(Double.TYPE.getName()), DoubleSerializer.instance); [EOL] }
public void testShortSerializerConstructor() { [EOL] ShortSerializer serializer = new ShortSerializer(); [EOL] assertNotNull(serializer); [EOL] }
public void testIntegerSerializerConstructor() { [EOL] IntegerSerializer serializer = new IntegerSerializer(); [EOL] assertNotNull(serializer); [EOL] }
public void testSerializeWithNonNullValue() throws IOException { [EOL] Integer value = 123; [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] SerializerProvider mockSerializerProvider = mock(SerializerProvider.class); [EOL] new IntegerSerializer().serialize(value, mockJsonGenerator, mockSerializerProvider); [EOL] verify(mockJsonGenerator).writeNumber(value.intValue()); [EOL] }
public void testSerializeWithNullValue() throws IOException { [EOL] Integer value = null; [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] SerializerProvider mockSerializerProvider = mock(SerializerProvider.class); [EOL] new IntegerSerializer().serialize(value, mockJsonGenerator, mockSerializerProvider); [EOL] verify(mockJsonGenerator, never()).writeNumber(anyInt()); [EOL] }
public void testIntLikeSerializerConstructor() { [EOL] IntLikeSerializer serializer = new IntLikeSerializer(); [EOL] assertNotNull(serializer); [EOL] assertEquals(Number.class, serializer.handledType()); [EOL] }
public void testLongSerializerConstructor() { [EOL] LongSerializer serializer = new LongSerializer(); [EOL] assertNotNull(serializer); [EOL] }
public void testSerializeWithNonNullValue() throws IOException { [EOL] Long testValue = 12345L; [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] SerializerProvider mockSerializerProvider = mock(SerializerProvider.class); [EOL] new LongSerializer().serialize(testValue, mockJsonGenerator, mockSerializerProvider); [EOL] verify(mockJsonGenerator).writeNumber(testValue.longValue()); [EOL] }
public void testSerializeWithNullValue() throws IOException { [EOL] Long testValue = null; [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] SerializerProvider mockSerializerProvider = mock(SerializerProvider.class); [EOL] new LongSerializer().serialize(testValue, mockJsonGenerator, mockSerializerProvider); [EOL] verify(mockJsonGenerator, never()).writeNumber(anyLong()); [EOL] }
public void testFloatSerializerConstructor() { [EOL] FloatSerializer serializer = new FloatSerializer(); [EOL] assertNotNull(serializer); [EOL] }
public void testDoubleSerializerConstructor() { [EOL] DoubleSerializer serializer = new DoubleSerializer(); [EOL] assertNotNull(serializer); [EOL] }
public void testNumberSerializerConstructor() { [EOL] NumberSerializer serializer = new NumberSerializer(); [EOL] assertNotNull(serializer); [EOL] }
public void testSerializeContentsEmptyArray() throws IOException { [EOL] String[] value = new String[0]; [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] serializeContents(value, jgen, provider); [EOL] verifyNoInteractions(jgen); [EOL] }
public void testSerializeContentsWithElementSerializer() throws IOException { [EOL] String[] value = new String[]{"a", "b", "c"}; [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] JsonSerializer<Object> elementSerializer = mock(JsonSerializer.class); [EOL] _elementSerializer = elementSerializer; [EOL] serializeContents(value, jgen, provider); [EOL] verify(elementSerializer, times(value.length)).serialize(any(), eq(jgen), eq(provider)); [EOL] }
public void testSerializeContentsWithNullElement() throws IOException { [EOL] String[] value = new String[]{null}; [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] serializeContents(value, jgen, provider); [EOL] verify(jgen).writeNull(); [EOL] }
public void testSerializeContentsWithNonNullElements() throws IOException { [EOL] String[] value = new String[]{"a", "b"}; [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] serializeContents(value, jgen, provider); [EOL] verify(jgen).writeString("a"); [EOL] verify(jgen).writeString("b"); [EOL] }
public void testAsBooleanWithTrueValue() { [EOL] JsonNode node = new TextNode("true"); [EOL] boolean result = node.asBoolean(false); [EOL] assert result; [EOL] }
public void testAsBooleanWithFalseValue() { [EOL] JsonNode node = new TextNode("false"); [EOL] boolean result = node.asBoolean(true); [EOL] assert !result; [EOL] }
public void testAsBooleanWithNullValue() { [EOL] JsonNode node = new TextNode(null); [EOL] boolean result = node.asBoolean(true); [EOL] assert result; [EOL] }
public void testAsBooleanWithTrimmedTrueValue() { [EOL] JsonNode node = new TextNode("  true  "); [EOL] boolean result = node.asBoolean(false); [EOL] assert result; [EOL] }
public void testAsBooleanWithNonTrueValue() { [EOL] JsonNode node = new TextNode("notTrue"); [EOL] boolean result = node.asBoolean(true); [EOL] assert result; [EOL] }
public void testDeserializeWithNonArrayToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.isExpectedStartArrayToken()).thenReturn(false); [EOL] StringDeserializer deserializer = new StringDeserializer(); [EOL] String[] result = deserializer.deserialize(jp, ctxt); [EOL] assertNull(result); [EOL] }
public void testDeserializeWithCustomDeserializer() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.isExpectedStartArrayToken()).thenReturn(true); [EOL] StringDeserializer deserializer = new StringDeserializer(); [EOL] deserializer._elementDeserializer = mock(JsonDeserializer.class); [EOL] String[] result = deserializer.deserialize(jp, ctxt); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeWithArrayTokenAndStrings() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.isExpectedStartArrayToken()).thenReturn(true); [EOL] when(jp.nextToken()).thenReturn(JsonToken.VALUE_STRING, JsonToken.VALUE_STRING, JsonToken.END_ARRAY); [EOL] when(jp.getText()).thenReturn("string1", "string2"); [EOL] StringDeserializer deserializer = new StringDeserializer(); [EOL] String[] result = deserializer.deserialize(jp, ctxt); [EOL] assertArrayEquals(new String[]{"string1", "string2"}, result); [EOL] }
public void testDeserializeWithArrayTokenAndNulls() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.isExpectedStartArrayToken()).thenReturn(true); [EOL] when(jp.nextToken()).thenReturn(JsonToken.VALUE_NULL, JsonToken.END_ARRAY); [EOL] StringDeserializer deserializer = new StringDeserializer(); [EOL] String[] result = deserializer.deserialize(jp, ctxt); [EOL] assertArrayEquals(new String[]{null}, result); [EOL] }
public void testDeserializeWithArrayTokenAndNonStringValues() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.isExpectedStartArrayToken()).thenReturn(true); [EOL] when(jp.nextToken()).thenReturn(JsonToken.VALUE_NUMBER_INT, JsonToken.END_ARRAY); [EOL] when(jp.getText()).thenReturn("1"); [EOL] StringDeserializer deserializer = new StringDeserializer(); [EOL] deserializer._parseString = mock(Function.class); [EOL] when(deserializer._parseString.apply(any(), any())).thenReturn("parsedString"); [EOL] String[] result = deserializer.deserialize(jp, ctxt); [EOL] assertArrayEquals(new String[]{"parsedString"}, result); [EOL] }
public void testHandleNonArrayWithFeatureDisabled() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY)).thenReturn(false); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)).thenReturn(false); [EOL] when(ctxt.mappingException(any(Class.class))).thenThrow(new JsonMappingException("Mapping exception")); [EOL] try { [EOL] handleNonArray(jp, ctxt); [EOL] fail("Expected JsonMappingException"); [EOL] } catch (JsonMappingException e) { [EOL] } [EOL] }
public void testHandleNonArrayWithEmptyString() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY)).thenReturn(false); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn(""); [EOL] when(ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)).thenReturn(true); [EOL] String[] result = handleNonArray(jp, ctxt); [EOL] assertNull(result); [EOL] }
public void testHandleNonArrayWithSingleValueAsArray() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY)).thenReturn(true); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("test"); [EOL] when(ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)).thenReturn(false); [EOL] String[] result = handleNonArray(jp, ctxt); [EOL] assertNotNull(result); [EOL] assertEquals(1, result.length); [EOL] assertEquals("test", result[0]); [EOL] }
public void testHandleNonArrayWithNullValue() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY)).thenReturn(true); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NULL); [EOL] String[] result = handleNonArray(jp, ctxt); [EOL] assertNotNull(result); [EOL] assertEquals(1, result.length); [EOL] assertNull(result[0]); [EOL] }
public void testBeanDeserializerBuilderWithDefaultViewInclusionEnabled() { [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] when(config.isEnabled(MapperFeature.DEFAULT_VIEW_INCLUSION)).thenReturn(true); [EOL] BeanDeserializerBuilder builder = new BeanDeserializerBuilder(beanDesc, config); [EOL] assertTrue(builder._defaultViewInclusion); [EOL] }
public void testBeanDeserializerBuilderWithDefaultViewInclusionDisabled() { [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] when(config.isEnabled(MapperFeature.DEFAULT_VIEW_INCLUSION)).thenReturn(false); [EOL] BeanDeserializerBuilder builder = new BeanDeserializerBuilder(beanDesc, config); [EOL] assertFalse(builder._defaultViewInclusion); [EOL] }
public void testAddProperty() { [EOL] BeanPropertyMap map = new BeanPropertyMap(false); [EOL] SettableBeanProperty prop = new MockSettableBeanProperty("propName"); [EOL] map.addOrReplaceProperty(prop, false); [EOL] assertTrue(map.find("propName") == prop); [EOL] }
public void testReplaceProperty() { [EOL] BeanPropertyMap map = new BeanPropertyMap(false); [EOL] SettableBeanProperty prop1 = new MockSettableBeanProperty("propName"); [EOL] SettableBeanProperty prop2 = new MockSettableBeanProperty("propName"); [EOL] map.addOrReplaceProperty(prop1, false); [EOL] map.addOrReplaceProperty(prop2, true); [EOL] assertTrue(map.find("propName") == prop2); [EOL] assertFalse(map.find("propName") == prop1); [EOL] }
public void testAddProperty_NewProperty() { [EOL] BeanDescription beanDesc = createMockBeanDescription(); [EOL] PropertyMap propertyMap = new PropertyMap(beanDesc); [EOL] SettableBeanProperty newProperty = createMockSettableBeanProperty("newProperty"); [EOL] propertyMap.addProperty(newProperty); [EOL] assertEquals(newProperty, propertyMap.get("newProperty")); [EOL] }
public void testAddProperty_DuplicatePropertyThrowsException() { [EOL] BeanDescription beanDesc = createMockBeanDescription(); [EOL] PropertyMap propertyMap = new PropertyMap(beanDesc); [EOL] SettableBeanProperty property1 = createMockSettableBeanProperty("duplicateProperty"); [EOL] SettableBeanProperty property2 = createMockSettableBeanProperty("duplicateProperty"); [EOL] propertyMap.addProperty(property1); [EOL] try { [EOL] propertyMap.addProperty(property2); [EOL] fail("Expected IllegalArgumentException for duplicate property"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testAddProperty_SamePropertyTwice() { [EOL] BeanDescription beanDesc = createMockBeanDescription(); [EOL] PropertyMap propertyMap = new PropertyMap(beanDesc); [EOL] SettableBeanProperty property = createMockSettableBeanProperty("sameProperty"); [EOL] propertyMap.addProperty(property); [EOL] propertyMap.addProperty(property); // Should not throw an exception [EOL] assertEquals(property, propertyMap.get("sameProperty")); [EOL] }
public void testAddIgnorableWithNullSet() { [EOL] BeanPropertyMap beanPropertyMap = new BeanPropertyMap(false, Collections.emptyList()); [EOL] beanPropertyMap.addIgnorable("propName"); [EOL] assertTrue(beanPropertyMap.hasIgnorable("propName")); [EOL] }
public void testAddIgnorableWithNonNullSet() { [EOL] BeanPropertyMap beanPropertyMap = new BeanPropertyMap(false, Collections.emptyList()); [EOL] beanPropertyMap.addIgnorable("initialProp"); [EOL] beanPropertyMap.addIgnorable("propName"); [EOL] assertTrue(beanPropertyMap.hasIgnorable("propName")); [EOL] assertTrue(beanPropertyMap.hasIgnorable("initialProp")); [EOL] }
public void testAddCreatorPropertyWithNonNullProperty() { [EOL] BeanPropertyMap beanPropertyMap = new BeanPropertyMap(false); [EOL] SettableBeanProperty property = new MockSettableBeanProperty("testProperty"); [EOL] beanPropertyMap.addCreatorProperty(property); [EOL] assertTrue(beanPropertyMap.find("testProperty") != null); [EOL] }
public void testAddCreatorPropertyWithNullProperty() { [EOL] BeanPropertyMap beanPropertyMap = new BeanPropertyMap(false); [EOL] try { [EOL] beanPropertyMap.addCreatorProperty(null); [EOL] fail("Should not be able to add null property"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testSetAnySetterWithNull() { [EOL] YourClass instance = new YourClass(); [EOL] SettableAnyProperty anySetter = null; [EOL] instance.setAnySetter(anySetter); [EOL] assertNull(instance.getAnySetter()); [EOL] }
public void testSetAnySetterWithNonNull() { [EOL] YourClass instance = new YourClass(); [EOL] SettableAnyProperty anySetter = new SettableAnyProperty(); [EOL] instance.setAnySetter(anySetter); [EOL] assertEquals(anySetter, instance.getAnySetter()); [EOL] }
public void testSetAnySetterWhenAlreadySet() { [EOL] YourClass instance = new YourClass(); [EOL] SettableAnyProperty anySetter1 = new SettableAnyProperty(); [EOL] SettableAnyProperty anySetter2 = new SettableAnyProperty(); [EOL] instance.setAnySetter(anySetter1); [EOL] try { [EOL] instance.setAnySetter(anySetter2); [EOL] fail("Expected an IllegalStateException to be thrown"); [EOL] } catch (IllegalStateException e) { [EOL] assertEquals("_anySetter already set to non-null", e.getMessage()); [EOL] } [EOL] assertEquals(anySetter1, instance.getAnySetter()); [EOL] }
public void testSetIgnoreUnknownPropertiesTrue() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] mapper.setIgnoreUnknownProperties(true); [EOL] assertTrue(mapper._ignoreAllUnknown); [EOL] }
public void testSetIgnoreUnknownPropertiesFalse() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] mapper.setIgnoreUnknownProperties(false); [EOL] assertFalse(mapper._ignoreAllUnknown); [EOL] }
public void testSetValueInstantiator() { [EOL] MyClass obj = new MyClass(); [EOL] ValueInstantiator inst = new ValueInstantiator(); [EOL] obj.setValueInstantiator(inst); [EOL] assertEquals(inst, obj.getValueInstantiator()); [EOL] }
public void testFindPropertyWhenPropertyExists() { [EOL] String existingPropertyName = "existingProperty"; [EOL] SettableBeanProperty mockProperty = mock(SettableBeanProperty.class); [EOL] Map<String, SettableBeanProperty> properties = new HashMap<>(); [EOL] properties.put(existingPropertyName, mockProperty); [EOL] BeanPropertyMap beanPropertyMap = new BeanPropertyMap(properties); [EOL] SettableBeanProperty result = beanPropertyMap.findProperty(existingPropertyName); [EOL] assertNotNull(result); [EOL] assertEquals(mockProperty, result); [EOL] }
public void testFindPropertyWhenPropertyDoesNotExist() { [EOL] String nonExistingPropertyName = "nonExistingProperty"; [EOL] Map<String, SettableBeanProperty> properties = new HashMap<>(); [EOL] BeanPropertyMap beanPropertyMap = new BeanPropertyMap(properties); [EOL] SettableBeanProperty result = beanPropertyMap.findProperty(nonExistingPropertyName); [EOL] assertNull(result); [EOL] }
public void testGetAnySetterWhenAnySetterIsNull() { [EOL] BeanDescription beanDesc = createMockBeanDescriptionWithAnySetter(null); [EOL] SettableAnyProperty result = beanDesc.getAnySetter(); [EOL] assertNull(result); [EOL] } [EOL] public void testGetAnySetterWhenAnySetterIsNotNull() { [EOL] SettableAnyProperty expectedAnySetter = new SettableAnyProperty(null, null); [EOL] BeanDescription beanDesc = createMockBeanDescriptionWithAnySetter(expectedAnySetter); [EOL] SettableAnyProperty result = beanDesc.getAnySetter(); [EOL] assertSame(expectedAnySetter, result); [EOL] } [EOL] private BeanDescription createMockBeanDescriptionWithAnySetter(SettableAnyProperty anySetter) { [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] when(beanDesc.getAnySetter()).thenReturn(anySetter); [EOL] return beanDesc; [EOL] }
public void testGetValueInstantiator() { [EOL] YourClass instance = new YourClass(); [EOL] ValueInstantiator expected = new ValueInstantiator(); // Assuming a constructor or a method to create an instance [EOL] instance._valueInstantiator = expected; // Directly setting the field, assuming it's accessible [EOL] ValueInstantiator actual = instance.getValueInstantiator(); [EOL] assertSame("The returned ValueInstantiator should be the same as the one set.", expected, actual); [EOL] }
public void testGetInjectablesWhenInjectablesAreNull() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] InjectableValues injectableValues = mapper.getInjectableValues(); [EOL] assertNull(injectableValues.getInjectables()); [EOL] }
public void testGetInjectablesWhenInjectablesAreNotNull() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] InjectableValues.Std injectableValues = new InjectableValues.Std(); [EOL] injectableValues.addValue("key", "value"); [EOL] mapper.setInjectableValues(injectableValues); [EOL] List<ValueInjector> injectables = mapper.getInjectableValues().getInjectables(); [EOL] assertNotNull(injectables); [EOL] assertFalse(injectables.isEmpty()); [EOL] }
public void testGetObjectIdReaderIsNull() { [EOL] DeserializationContext context = new DeserializationContext(...); // Provide actual arguments [EOL] ObjectIdReader objectIdReader = null; [EOL] context._objectIdReader = objectIdReader; [EOL] assertNull(context.getObjectIdReader()); [EOL] }
public void testGetObjectIdReaderIsNotNull() { [EOL] DeserializationContext context = new DeserializationContext(...); // Provide actual arguments [EOL] ObjectIdReader objectIdReader = new ObjectIdReader(...); // Provide actual arguments [EOL] context._objectIdReader = objectIdReader; [EOL] assertSame(objectIdReader, context.getObjectIdReader()); [EOL] }
public void testBuildWithDefaultViewInclusionAndNoViews() { [EOL] BeanDeserializerBuilder builder = new BeanDeserializerBuilder(null, null); [EOL] builder._defaultViewInclusion = true; [EOL] builder._properties.put("prop", new SettableBeanProperty.Dummy("prop", null, false)); [EOL] JsonDeserializer<?> deserializer = builder.build(); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof BeanDeserializer); [EOL] BeanDeserializer beanDeserializer = (BeanDeserializer) deserializer; [EOL] assertFalse(beanDeserializer.usesObjectId()); [EOL] assertFalse(beanDeserializer.hasViews()); [EOL] }
public void testBuildWithDefaultViewInclusionAndViewProperty() { [EOL] BeanDeserializerBuilder builder = new BeanDeserializerBuilder(null, null); [EOL] builder._defaultViewInclusion = true; [EOL] SettableBeanProperty propWithView = new SettableBeanProperty.Dummy("prop", null, true); [EOL] builder._properties.put("prop", propWithView); [EOL] JsonDeserializer<?> deserializer = builder.build(); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof BeanDeserializer); [EOL] BeanDeserializer beanDeserializer = (BeanDeserializer) deserializer; [EOL] assertFalse(beanDeserializer.usesObjectId()); [EOL] assertTrue(beanDeserializer.hasViews()); [EOL] }
public void testBuildWithObjectIdReader() { [EOL] BeanDeserializerBuilder builder = new BeanDeserializerBuilder(null, null); [EOL] builder._objectIdReader = ObjectIdReader.construct(null, null, null); [EOL] builder._properties.put("prop", new SettableBeanProperty.Dummy("prop", null, false)); [EOL] JsonDeserializer<?> deserializer = builder.build(); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof BeanDeserializer); [EOL] BeanDeserializer beanDeserializer = (BeanDeserializer) deserializer; [EOL] assertTrue(beanDeserializer.usesObjectId()); [EOL] }
public void testBuildAbstract() { [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] Map<String, SettableBeanProperty> backRefProperties = new HashMap<>(); [EOL] AbstractDeserializer actual = new AbstractDeserializer(beanDesc, backRefProperties); [EOL] assertNotNull(actual); [EOL] }
public void testClassDeserializerConstructor() { [EOL] ClassDeserializer deserializer = new ClassDeserializer(); [EOL] assertNotNull(deserializer); [EOL] assertEquals(Class.class, deserializer.handledType()); [EOL] }
public void testAppendCompletedChunkWithEmptyBuffer() { [EOL] LinkedNode<Integer> testInstance = new LinkedNode<>(); [EOL] Integer[] fullChunk = new Integer[]{1, 2, 3}; [EOL] int fullChunkLength = 3; [EOL] Integer[] result = testInstance.appendCompletedChunk(fullChunk, fullChunkLength); [EOL] assertNotNull(result); [EOL] assertEquals(fullChunkLength * 2, result.length); // Assuming SMALL_CHUNK_SIZE is larger than 3 [EOL] }
public void testAppendCompletedChunkWithNonEmptyBuffer() { [EOL] LinkedNode<Integer> testInstance = new LinkedNode<>(); [EOL] Integer[] initialChunk = new Integer[]{1, 2, 3}; [EOL] testInstance.appendCompletedChunk(initialChunk, 3); // Set initial state with a chunk [EOL] Integer[] fullChunk = new Integer[]{4, 5, 6, 7, 8, 9, 10}; [EOL] int fullChunkLength = 7; [EOL] Integer[] result = testInstance.appendCompletedChunk(fullChunk, fullChunkLength); [EOL] assertNotNull(result); [EOL] assertTrue(fullChunkLength < SMALL_CHUNK_SIZE); [EOL] assertEquals(fullChunkLength * 2, result.length); // This assertion depends on the actual SMALL_CHUNK_SIZE value [EOL] }
public void testAppendCompletedChunkWithLargeChunk() { [EOL] LinkedNode<Integer> testInstance = new LinkedNode<>(); [EOL] Integer[] fullChunk = new Integer[SMALL_CHUNK_SIZE + 1]; // Create a chunk larger than SMALL_CHUNK_SIZE [EOL] int fullChunkLength = SMALL_CHUNK_SIZE + 1; [EOL] Integer[] result = testInstance.appendCompletedChunk(fullChunk, fullChunkLength); [EOL] assertNotNull(result); [EOL] assertTrue(fullChunkLength >= SMALL_CHUNK_SIZE); [EOL] assertEquals(fullChunkLength + (fullChunkLength >> 2), result.length); // This assertion depends on the actual SMALL_CHUNK_SIZE value [EOL] }
public void testHierarchicTypeWithClassType() { [EOL] Class<?> clazz = String.class; [EOL] HierarchicType hierarchicType = new HierarchicType(clazz); [EOL] assertNotNull(hierarchicType._actualType); [EOL] assertEquals(clazz, hierarchicType._rawClass); [EOL] assertNull(hierarchicType._genericType); [EOL] }
public void testHierarchicTypeWithParameterizedType() { [EOL] Type type = new ParameterizedType() { [EOL] @Override [EOL] public Type[] getActualTypeArguments() { [EOL] return new Type[] {String.class}; [EOL] } [EOL] @Override [EOL] public Type getRawType() { [EOL] return List.class; [EOL] } [EOL] @Override [EOL] public Type getOwnerType() { [EOL] return null; [EOL] } [EOL] }; [EOL] HierarchicType hierarchicType = new HierarchicType(type); [EOL] assertNotNull(hierarchicType._actualType); [EOL] assertEquals(List.class, hierarchicType._rawClass); [EOL] assertEquals(type, hierarchicType._genericType); [EOL] }
public void testHierarchicTypeWithUnsupportedType() { [EOL] Type type = new Type() { [EOL] @Override [EOL] public String getTypeName() { [EOL] return "UnsupportedType"; [EOL] } [EOL] }; [EOL] try { [EOL] new HierarchicType(type); [EOL] fail("Expected IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Type " + type.getClass().getName() + " can not be used to construct HierarchicType", e.getMessage()); [EOL] } [EOL] }
public void testSetSuperTypeWithNull() { [EOL] HierarchicType subType = new HierarchicType(SomeClass.class); [EOL] subType.setSuperType(null); [EOL] assertNull(subType.getSuperType()); [EOL] }
public void testSetSuperTypeWithNonNull() { [EOL] HierarchicType subType = new HierarchicType(SomeClass.class); [EOL] HierarchicType superType = new HierarchicType(AnotherClass.class); [EOL] subType.setSuperType(superType); [EOL] assertEquals(superType, subType.getSuperType()); [EOL] }
public void testGetSuperType() { [EOL] HierarchicType hierarchicType = new HierarchicType(SomeType.class); // Assuming SomeType is a placeholder for an actual type [EOL] HierarchicType expectedSuperType = new HierarchicType(AnotherType.class); // Assuming AnotherType is a placeholder for an actual type [EOL] hierarchicType._superType = expectedSuperType; // Directly setting the private field, assuming we have access to it [EOL] HierarchicType result = hierarchicType.getSuperType(); [EOL] assertEquals("The superType should be the expected one", expectedSuperType, result); [EOL] }
public void testSetSubTypeWithNull() { [EOL] HierarchicType subType = null; [EOL] TypeBase typeBase = new TypeBase(); [EOL] typeBase.setSubType(subType); [EOL] assertNull(typeBase.getSubType()); [EOL] }
public void testSetSubTypeWithNonNull() { [EOL] HierarchicType subType = new HierarchicType(); [EOL] TypeBase typeBase = new TypeBase(); [EOL] typeBase.setSubType(subType); [EOL] assertEquals(subType, typeBase.getSubType()); [EOL] }
public void testIsGenericTrue() { [EOL] TypeBase typeBase = new TypeBase() { [EOL] @Override [EOL] public StringBuilder getGenericSignature(StringBuilder sb) { [EOL] return null; [EOL] } [EOL] }; [EOL] typeBase._genericType = new Type() { [EOL] @Override [EOL] public String getTypeName() { [EOL] return "Generic"; [EOL] } [EOL] }; [EOL] assertTrue(typeBase.isGeneric()); [EOL] }
public void testIsGenericFalse() { [EOL] TypeBase typeBase = new TypeBase() { [EOL] @Override [EOL] public StringBuilder getGenericSignature(StringBuilder sb) { [EOL] return null; [EOL] } [EOL] }; [EOL] typeBase._genericType = null; [EOL] assertFalse(typeBase.isGeneric()); [EOL] }
public void testAsGenericWithNonNullGenericType() { [EOL] MyClass instance = new MyClass(); [EOL] ParameterizedType expected = mock(ParameterizedType.class); [EOL] instance._genericType = expected; [EOL] ParameterizedType actual = instance.asGeneric(); [EOL] assertSame("The returned type should be the same as the _genericType field", expected, actual); [EOL] }
public void testAsGenericWithNullGenericType() { [EOL] MyClass instance = new MyClass(); [EOL] instance._genericType = null; [EOL] ParameterizedType actual = instance.asGeneric(); [EOL] assertNull("The returned type should be null as the _genericType field is null", actual); [EOL] }
public void testGetRawClass() { [EOL] Class<?> expectedClass = String.class; [EOL] MyClass instance = new MyClass(expectedClass); [EOL] Class<?> result = instance.getRawClass(); [EOL] assertEquals(expectedClass, result); [EOL] }
public void testDOMSerializerConstructorSuccess() { [EOL] try { [EOL] DOMSerializer serializer = new DOMSerializer(); [EOL] assertNotNull(serializer); [EOL] } catch (Exception e) { [EOL] fail("Expected constructor to succeed without exceptions."); [EOL] } [EOL] }
public void testDOMSerializerConstructorFailure() { [EOL] System.setProperty(DOMImplementationRegistry.PROPERTY, "invalid.class.name"); [EOL] try { [EOL] new DOMSerializer(); [EOL] fail("Expected IllegalStateException due to invalid DOMImplementationRegistry property."); [EOL] } catch (IllegalStateException e) { [EOL] } finally { [EOL] System.clearProperty(DOMImplementationRegistry.PROPERTY); [EOL] } [EOL] }
public void testSerializeWithNullDomImpl() throws IOException { [EOL] Node value = mock(Node.class); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] DomSerializer serializer = new DomSerializer(null); [EOL] try { [EOL] serializer.serialize(value, jgen, provider); [EOL] fail("Expected IllegalStateException"); [EOL] } catch (IllegalStateException e) { [EOL] assertEquals("Could not find DOM LS", e.getMessage()); [EOL] } [EOL] }
public void testSerializeWithNonNullDomImpl() throws IOException { [EOL] Node value = mock(Node.class); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] DOMImplementationLS domImpl = mock(DOMImplementationLS.class); [EOL] LSSerializer writer = mock(LSSerializer.class); [EOL] when(domImpl.createLSSerializer()).thenReturn(writer); [EOL] when(writer.writeToString(value)).thenReturn("mockStringValue"); [EOL] DomSerializer serializer = new DomSerializer(domImpl); [EOL] serializer.serialize(value, jgen, provider); [EOL] verify(jgen).writeString("mockStringValue"); [EOL] }
public void testBeanAsArraySerializerConstructor() { [EOL] BeanSerializerBase src = mock(BeanSerializerBase.class); [EOL] BeanAsArraySerializer serializer = new BeanAsArraySerializer(src); [EOL] assertNotNull(serializer); [EOL] assertSame(src, serializer._defaultSerializer); [EOL] }
public void testSerializeWithSingleElementArrayUnwrapped() throws IOException { [EOL] Object bean = ...; // Initialize bean with a single element array [EOL] JsonGenerator jgen = ...; // Mock JsonGenerator [EOL] SerializerProvider provider = ...; // Mock SerializerProvider [EOL] when(provider.isEnabled(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED)).thenReturn(true); [EOL] when(hasSingleElement(provider)).thenReturn(true); [EOL] serialize(bean, jgen, provider); [EOL] verify(jgen, never()).writeStartArray(); [EOL] verify(jgen, never()).writeEndArray(); [EOL] verify(serializeAsArray(bean, jgen, provider)).times(1); [EOL] }
public void testSerializeWithNonSingleElementArray() throws IOException { [EOL] Object bean = ...; // Initialize bean with a non-single element array [EOL] JsonGenerator jgen = ...; // Mock JsonGenerator [EOL] SerializerProvider provider = ...; // Mock SerializerProvider [EOL] when(provider.isEnabled(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED)).thenReturn(false); [EOL] when(hasSingleElement(provider)).thenReturn(false); [EOL] serialize(bean, jgen, provider); [EOL] verify(jgen).writeStartArray(); [EOL] verify(jgen).writeEndArray(); [EOL] verify(serializeAsArray(bean, jgen, provider)).times(1); [EOL] }
public void testSerializeWithSingleElementArrayWrapped() throws IOException { [EOL] Object bean = ...; // Initialize bean with a single element array [EOL] JsonGenerator jgen = ...; // Mock JsonGenerator [EOL] SerializerProvider provider = ...; // Mock SerializerProvider [EOL] when(provider.isEnabled(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED)).thenReturn(false); [EOL] when(hasSingleElement(provider)).thenReturn(true); [EOL] serialize(bean, jgen, provider); [EOL] verify(jgen).writeStartArray(); [EOL] verify(jgen).writeEndArray(); [EOL] verify(serializeAsArray(bean, jgen, provider)).times(1); [EOL] }
public void testHasSingleElementWithActiveViewAndFilteredProps() { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] when(provider.getActiveView()).thenReturn(Object.class); [EOL] BeanPropertyWriter[] filteredProps = new BeanPropertyWriter[1]; [EOL] YourClass instance = new YourClass(filteredProps, null); [EOL] assertTrue(instance.hasSingleElement(provider)); [EOL] }
public void testHasSingleElementWithNoActiveView() { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] when(provider.getActiveView()).thenReturn(null); [EOL] BeanPropertyWriter[] props = new BeanPropertyWriter[1]; [EOL] YourClass instance = new YourClass(null, props); [EOL] assertTrue(instance.hasSingleElement(provider)); [EOL] }
public void testHasSingleElementWithMultipleElements() { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] when(provider.getActiveView()).thenReturn(null); [EOL] BeanPropertyWriter[] props = new BeanPropertyWriter[2]; [EOL] YourClass instance = new YourClass(null, props); [EOL] assertFalse(instance.hasSingleElement(provider)); [EOL] }
public void testHasSingleElementWithActiveViewAndNoFilteredProps() { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] when(provider.getActiveView()).thenReturn(Object.class); [EOL] BeanPropertyWriter[] props = new BeanPropertyWriter[1]; [EOL] YourClass instance = new YourClass(null, props); [EOL] assertTrue(instance.hasSingleElement(provider)); [EOL] }
public void testSerializeAsArrayWithActiveView() throws IOException { [EOL] Object bean = new Object(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanPropertyWriter[] filteredProps = new BeanPropertyWriter[1]; [EOL] filteredProps[0] = mock(BeanPropertyWriter.class); [EOL] when(provider.getActiveView()).thenReturn(Class.class); [EOL] serializeAsArray(bean, jgen, provider, filteredProps, null); [EOL] verify(filteredProps[0]).serializeAsColumn(bean, jgen, provider); [EOL] }
public void testSerializeAsArrayWithoutActiveView() throws IOException { [EOL] Object bean = new Object(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanPropertyWriter[] props = new BeanPropertyWriter[1]; [EOL] props[0] = mock(BeanPropertyWriter.class); [EOL] serializeAsArray(bean, jgen, provider, null, props); [EOL] verify(props[0]).serializeAsColumn(bean, jgen, provider); [EOL] }
public void testSerializeAsArrayWithNullProperty() throws IOException { [EOL] Object bean = new Object(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanPropertyWriter[] props = new BeanPropertyWriter[1]; [EOL] serializeAsArray(bean, jgen, provider, null, props); [EOL] verify(jgen).writeNull(); [EOL] }
public void testSerializeAsArrayWithException() throws IOException { [EOL] Object bean = new Object(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanPropertyWriter[] props = new BeanPropertyWriter[2]; [EOL] props[0] = mock(BeanPropertyWriter.class); [EOL] props[1] = mock(BeanPropertyWriter.class); [EOL] doThrow(new IOException()).when(props[1]).serializeAsColumn(bean, jgen, provider); [EOL] try { [EOL] serializeAsArray(bean, jgen, provider, null, props); [EOL] fail("IOException expected"); [EOL] } catch (Exception e) { [EOL] } [EOL] }
public void testSerializeAsArrayWithStackOverflowError() { [EOL] Object bean = new Object(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanPropertyWriter[] props = new BeanPropertyWriter[1]; [EOL] props[0] = mock(BeanPropertyWriter.class); [EOL] doThrow(new StackOverflowError()).when(props[0]).serializeAsColumn(bean, jgen, provider); [EOL] try { [EOL] serializeAsArray(bean, jgen, provider, null, props); [EOL] fail("JsonMappingException expected"); [EOL] } catch (JsonMappingException e) { [EOL] } [EOL] }
public void testMapLikeTypeWithNonNullTypes() { [EOL] Class<?> mapType = HashMap.class; [EOL] JavaType keyType = TypeFactory.defaultInstance().constructType(String.class); [EOL] JavaType valueType = TypeFactory.defaultInstance().constructType(Integer.class); [EOL] Object valueHandler = new Object(); [EOL] Object typeHandler = new Object(); [EOL] boolean asStatic = true; [EOL] MapLikeType mapLikeType = new MapLikeType(mapType, keyType, valueType, valueHandler, typeHandler, asStatic); [EOL] assertNotNull(mapLikeType); [EOL] assertEquals(mapType, mapLikeType.getRawClass()); [EOL] assertEquals(keyType, mapLikeType.getKeyType()); [EOL] assertEquals(valueType, mapLikeType.getContentType()); [EOL] assertEquals(valueHandler, mapLikeType.getValueHandler()); [EOL] assertEquals(typeHandler, mapLikeType.getTypeHandler()); [EOL] assertEquals(asStatic, mapLikeType.isStatic()); [EOL] }
public void testMapLikeTypeWithNullHandlers() { [EOL] Class<?> mapType = HashMap.class; [EOL] JavaType keyType = TypeFactory.defaultInstance().constructType(String.class); [EOL] JavaType valueType = TypeFactory.defaultInstance().constructType(Integer.class); [EOL] Object valueHandler = null; [EOL] Object typeHandler = null; [EOL] boolean asStatic = false; [EOL] MapLikeType mapLikeType = new MapLikeType(mapType, keyType, valueType, valueHandler, typeHandler, asStatic); [EOL] assertNotNull(mapLikeType); [EOL] assertEquals(mapType, mapLikeType.getRawClass()); [EOL] assertEquals(keyType, mapLikeType.getKeyType()); [EOL] assertEquals(valueType, mapLikeType.getContentType()); [EOL] assertNull(mapLikeType.getValueHandler()); [EOL] assertNull(mapLikeType.getTypeHandler()); [EOL] assertEquals(asStatic, mapLikeType.isStatic()); [EOL] }
public void testIsContainerType() { [EOL] ExtendedType type = new ExtendedType(); [EOL] boolean result = type.isContainerType(); [EOL] assertTrue(result); [EOL] }
public void testIsMapLikeType() { [EOL] MapLikeTypeSubclass instance = new MapLikeTypeSubclass(); [EOL] boolean result = instance.isMapLikeType(); [EOL] assertTrue(result); [EOL] }
public void testGetKeyType_WhenCalled_ReturnsKeyType() { [EOL] MyClass instance = new MyClass(keyTypeInstance); [EOL] JavaType result = instance.getKeyType(); [EOL] assertEquals(keyTypeInstance, result); [EOL] }
public void testGetContentTypeWhenValueTypeIsNull() { [EOL] MyType instance = new MyType(null); // Assuming MyType is the class where getContentType is defined [EOL] JavaType result = instance.getContentType(); [EOL] assertNull(result); [EOL] }
public void testGetContentTypeWhenValueTypeIsNotNull() { [EOL] JavaType expectedType = new ConcreteJavaType(); // Assuming ConcreteJavaType is a valid subtype of JavaType [EOL] MyType instance = new MyType(expectedType); // Assuming MyType is the class where getContentType is defined [EOL] JavaType result = instance.getContentType(); [EOL] assertNotNull(result); [EOL] assertSame(expectedType, result); [EOL] }
public void testContainedTypeForKeyType() { [EOL] MyType instance = new MyType(keyType, valueType); [EOL] JavaType result = instance.containedType(0); [EOL] assertEquals(keyType, result); [EOL] }
public void testContainedTypeForValueType() { [EOL] MyType instance = new MyType(keyType, valueType); [EOL] JavaType result = instance.containedType(1); [EOL] assertEquals(valueType, result); [EOL] }
public void testContainedTypeForInvalidIndex() { [EOL] MyType instance = new MyType(keyType, valueType); [EOL] JavaType result = instance.containedType(2); [EOL] assertNull(result); [EOL] }
public void testIsTrueMapTypeWithMapClass() { [EOL] ResolvedType resolvedType = new SimpleType(Map.class); [EOL] assertTrue(resolvedType.isTrueMapType()); [EOL] }
public void testIsTrueMapTypeWithNonMapClass() { [EOL] ResolvedType resolvedType = new SimpleType(String.class); [EOL] assertFalse(resolvedType.isTrueMapType()); [EOL] }
public void testEquals_sameObject() { [EOL] MapLikeType mapLikeType = new MapLikeType(...); // Provide necessary arguments for instantiation [EOL] boolean result = mapLikeType.equals(mapLikeType); [EOL] assertTrue(result); [EOL] }
public void testEquals_nullObject() { [EOL] MapLikeType mapLikeType = new MapLikeType(...); // Provide necessary arguments for instantiation [EOL] boolean result = mapLikeType.equals(null); [EOL] assertFalse(result); [EOL] }
public void testEquals_differentClass() { [EOL] MapLikeType mapLikeType = new MapLikeType(...); // Provide necessary arguments for instantiation [EOL] Object other = new Object(); [EOL] boolean result = mapLikeType.equals(other); [EOL] assertFalse(result); [EOL] }
public void testEquals_equalObjects() { [EOL] MapLikeType mapLikeType1 = new MapLikeType(...); // Provide necessary arguments for instantiation [EOL] MapLikeType mapLikeType2 = new MapLikeType(...); // Provide necessary arguments for instantiation [EOL] boolean result = mapLikeType1.equals(mapLikeType2); [EOL] assertTrue(result); [EOL] }
public void testEquals_differentKeyTypes() { [EOL] MapLikeType mapLikeType1 = new MapLikeType(...); // Provide necessary arguments for instantiation [EOL] MapLikeType mapLikeType2 = new MapLikeType(...); // Provide necessary arguments for instantiation with different _keyType [EOL] boolean result = mapLikeType1.equals(mapLikeType2); [EOL] assertFalse(result); [EOL] }
public void testEquals_differentValueTypes() { [EOL] MapLikeType mapLikeType1 = new MapLikeType(...); // Provide necessary arguments for instantiation [EOL] MapLikeType mapLikeType2 = new MapLikeType(...); // Provide necessary arguments for instantiation with different _valueType [EOL] boolean result = mapLikeType1.equals(mapLikeType2); [EOL] assertFalse(result); [EOL] }
public void testSimpleModuleWithName() { [EOL] String moduleName = "TestModule"; [EOL] SimpleModule module = new SimpleModule(moduleName); [EOL] assertNotNull(module); [EOL] assertEquals(moduleName, module.getModuleName()); [EOL] assertEquals(Version.unknownVersion(), module.version()); [EOL] }
public void testSetDeserializerModifierWithNonNull() { [EOL] SimpleModule module = new SimpleModule(); [EOL] BeanDeserializerModifier modifier = new BeanDeserializerModifier() { }; [EOL] SimpleModule result = module.setDeserializerModifier(modifier); [EOL] assertNotNull(result); [EOL] assertSame(modifier, result.getDeserializerModifier()); [EOL] }
public void testSetDeserializerModifierWithNull() { [EOL] SimpleModule module = new SimpleModule(); [EOL] SimpleModule result = module.setDeserializerModifier(null); [EOL] assertNotNull(result); [EOL] assertNull(result.getDeserializerModifier()); [EOL] }
public void testSetupModuleWithAllFieldsNull() { [EOL] SetupContext context = mock(SetupContext.class); [EOL] setupModule(context); [EOL] verifyNoInteractions(context); [EOL] }
public void testSetupModuleWithNonNullSerializers() { [EOL] SetupContext context = mock(SetupContext.class); [EOL] _serializers = mock(Serializers.class); [EOL] setupModule(context); [EOL] verify(context).addSerializers(_serializers); [EOL] }
public void testSetupModuleWithNonNullDeserializers() { [EOL] SetupContext context = mock(SetupContext.class); [EOL] _deserializers = mock(Deserializers.class); [EOL] setupModule(context); [EOL] verify(context).addDeserializers(_deserializers); [EOL] }
public void testSetupModuleWithNonNullKeySerializers() { [EOL] SetupContext context = mock(SetupContext.class); [EOL] _keySerializers = mock(Serializers.class); [EOL] setupModule(context); [EOL] verify(context).addKeySerializers(_keySerializers); [EOL] }
public void testSetupModuleWithNonNullKeyDeserializers() { [EOL] SetupContext context = mock(SetupContext.class); [EOL] _keyDeserializers = mock(KeyDeserializers.class); [EOL] setupModule(context); [EOL] verify(context).addKeyDeserializers(_keyDeserializers); [EOL] }
public void testSetupModuleWithNonNullAbstractTypes() { [EOL] SetupContext context = mock(SetupContext.class); [EOL] _abstractTypes = mock(AbstractTypeResolver.class); [EOL] setupModule(context); [EOL] verify(context).addAbstractTypeResolver(_abstractTypes); [EOL] }
public void testSetupModuleWithNonNullValueInstantiators() { [EOL] SetupContext context = mock(SetupContext.class); [EOL] _valueInstantiators = mock(ValueInstantiators.class); [EOL] setupModule(context); [EOL] verify(context).addValueInstantiators(_valueInstantiators); [EOL] }
public void testSetupModuleWithNonNullDeserializerModifier() { [EOL] SetupContext context = mock(SetupContext.class); [EOL] _deserializerModifier = mock(BeanDeserializerModifier.class); [EOL] setupModule(context); [EOL] verify(context).addBeanDeserializerModifier(_deserializerModifier); [EOL] }
public void testSetupModuleWithNonNullSerializerModifier() { [EOL] SetupContext context = mock(SetupContext.class); [EOL] _serializerModifier = mock(BeanSerializerModifier.class); [EOL] setupModule(context); [EOL] verify(context).addBeanSerializerModifier(_serializerModifier); [EOL] }
public void testSetupModuleWithNonEmptySubtypes() { [EOL] SetupContext context = mock(SetupContext.class); [EOL] _subtypes = new ArrayList<>(); [EOL] _subtypes.add(mock(NamedType.class)); [EOL] setupModule(context); [EOL] verify(context).registerSubtypes(any(NamedType[].class)); [EOL] }
public void testSetupModuleWithNonNullMixins() { [EOL] SetupContext context = mock(SetupContext.class); [EOL] _mixins = new HashMap<>(); [EOL] _mixins.put(String.class, Integer.class); [EOL] setupModule(context); [EOL] verify(context).setMixInAnnotations(String.class, Integer.class); [EOL] }
public void testAsWrapperTypeSerializerWithNonNullIdResAndProperty() { [EOL] TypeIdResolver idRes = mock(TypeIdResolver.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] AsWrapperTypeSerializer serializer = new AsWrapperTypeSerializer(idRes, property); [EOL] assertNotNull(serializer); [EOL] } [EOL] public void testAsWrapperTypeSerializerWithNullIdRes() { [EOL] TypeIdResolver idRes = null; [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] try { [EOL] AsWrapperTypeSerializer serializer = new AsWrapperTypeSerializer(idRes, property); [EOL] fail("Expected IllegalArgumentException not thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] } [EOL] public void testAsWrapperTypeSerializerWithNullProperty() { [EOL] TypeIdResolver idRes = mock(TypeIdResolver.class); [EOL] BeanProperty property = null; [EOL] AsWrapperTypeSerializer serializer = new AsWrapperTypeSerializer(idRes, property); [EOL] assertNotNull(serializer); [EOL] }
public void testForPropertyWithSameProperty() { [EOL] BeanProperty prop = mock(BeanProperty.class); [EOL] AsWrapperTypeSerializer serializer = new AsWrapperTypeSerializer(mock(TypeIdResolver.class), prop); [EOL] AsWrapperTypeSerializer result = serializer.forProperty(prop); [EOL] assertSame(serializer, result); [EOL] }
public void testForPropertyWithDifferentProperty() { [EOL] BeanProperty prop1 = mock(BeanProperty.class); [EOL] BeanProperty prop2 = mock(BeanProperty.class); [EOL] AsWrapperTypeSerializer serializer = new AsWrapperTypeSerializer(mock(TypeIdResolver.class), prop1); [EOL] AsWrapperTypeSerializer result = serializer.forProperty(prop2); [EOL] assertNotSame(serializer, result); [EOL] assertNotNull(result); [EOL] }
public void testWriteTypePrefixForObject_NullValue() throws IOException { [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] TypeNameIdResolver mockIdResolver = mock(TypeNameIdResolver.class); [EOL] when(mockIdResolver.idFromValue(null)).thenReturn("nullType"); [EOL] mockIdResolver.writeTypePrefixForObject(null, mockJsonGenerator); [EOL] verify(mockJsonGenerator).writeStartObject(); [EOL] verify(mockJsonGenerator).writeObjectFieldStart("nullType"); [EOL] }
public void testWriteTypePrefixForObject_NonNullValue() throws IOException { [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] TypeNameIdResolver mockIdResolver = mock(TypeNameIdResolver.class); [EOL] Object value = new Object(); [EOL] when(mockIdResolver.idFromValue(value)).thenReturn("objectType"); [EOL] mockIdResolver.writeTypePrefixForObject(value, mockJsonGenerator); [EOL] verify(mockJsonGenerator).writeStartObject(); [EOL] verify(mockJsonGenerator).writeObjectFieldStart("objectType"); [EOL] }
public void testWriteTypeSuffixForObject_NullJsonGenerator() throws IOException { [EOL] try { [EOL] writeTypeSuffixForObject(new Object(), null); [EOL] fail("Expected IOException was not thrown"); [EOL] } catch (IOException e) { [EOL] } [EOL] }
public void testWriteTypeSuffixForObject_ValidJsonGenerator() throws IOException { [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] Object dummyObject = new Object(); [EOL] writeTypeSuffixForObject(dummyObject, mockJsonGenerator); [EOL] verify(mockJsonGenerator, times(2)).writeEndObject(); [EOL] }
public void testSimpleTypeWithNullParameters() { [EOL] Class<?> cls = Object.class; [EOL] SimpleType simpleType = new SimpleType(cls); [EOL] assertNotNull(simpleType); [EOL] assertEquals(cls, simpleType.getRawClass()); [EOL] assertNull(simpleType.getValueHandler()); [EOL] assertNull(simpleType.getTypeHandler()); [EOL] assertNull(simpleType.getContentType()); [EOL] assertNull(simpleType.getContentTypeHandler()); [EOL] assertNull(simpleType.getContentValueHandler()); [EOL] assertFalse(simpleType.isAbstract()); [EOL] }
public void testSimpleTypeWithNullTypeNames() { [EOL] Class<?> cls = Object.class; [EOL] SimpleType simpleType = new SimpleType(cls, null, null, null, null, true); [EOL] assertNull(simpleType._typeNames); [EOL] assertNull(simpleType._typeParameters); [EOL] }
public void testSimpleTypeWithEmptyTypeNames() { [EOL] Class<?> cls = Object.class; [EOL] String[] typeNames = {}; [EOL] JavaType[] typeParams = {}; [EOL] SimpleType simpleType = new SimpleType(cls, typeNames, typeParams, null, null, true); [EOL] assertNull(simpleType._typeNames); [EOL] assertNull(simpleType._typeParameters); [EOL] }
public void testSimpleTypeWithNonNullTypeNames() { [EOL] Class<?> cls = Object.class; [EOL] String[] typeNames = {"type1", "type2"}; [EOL] JavaType[] typeParams = {new JavaType(), new JavaType()}; [EOL] SimpleType simpleType = new SimpleType(cls, typeNames, typeParams, null, null, true); [EOL] assertNotNull(simpleType._typeNames); [EOL] assertNotNull(simpleType._typeParameters); [EOL] assertArrayEquals(typeNames, simpleType._typeNames); [EOL] assertArrayEquals(typeParams, simpleType._typeParameters); [EOL] }
public void testConstructWithMapClass() { [EOL] try { [EOL] SimpleType.construct(java.util.HashMap.class); [EOL] fail("Expected IllegalArgumentException for Map class"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Can not construct SimpleType for a Map (class: java.util.HashMap)", e.getMessage()); [EOL] } [EOL] }
public void testConstructWithCollectionClass() { [EOL] try { [EOL] SimpleType.construct(java.util.ArrayList.class); [EOL] fail("Expected IllegalArgumentException for Collection class"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Can not construct SimpleType for a Collection (class: java.util.ArrayList)", e.getMessage()); [EOL] } [EOL] }
public void testConstructWithArrayClass() { [EOL] try { [EOL] SimpleType.construct(String[].class); [EOL] fail("Expected IllegalArgumentException for array class"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Can not construct SimpleType for an array (class: [Ljava.lang.String;)", e.getMessage()); [EOL] } [EOL] }
public void testConstructWithRegularClass() { [EOL] SimpleType type = SimpleType.construct(String.class); [EOL] assertNotNull(type); [EOL] assertEquals(String.class, type.getRawClass()); [EOL] }
public void testIsContainerType() { [EOL] TestClass instance = new TestClass(); [EOL] boolean result = instance.isContainerType(); [EOL] assert !result; // The method is expected to always return false [EOL] }
public void testContainedTypeCountWithNullTypeParameters() { [EOL] TestClass instance = new TestClass(); // Replace 'TestClass' with the actual class name [EOL] instance._typeParameters = null; // Assuming direct access to the field is possible, otherwise use a setter or constructor [EOL] int result = instance.containedTypeCount(); [EOL] assert result == 0 : "Expected count to be 0 when type parameters are null"; [EOL] }
public void testContainedTypeCountWithEmptyTypeParameters() { [EOL] TestClass instance = new TestClass(); // Replace 'TestClass' with the actual class name [EOL] instance._typeParameters = new Type[0]; // Replace 'Type' with the actual type parameter class [EOL] int result = instance.containedTypeCount(); [EOL] assert result == 0 : "Expected count to be 0 when type parameters are empty"; [EOL] }
public void testContainedTypeCountWithNonEmptyTypeParameters() { [EOL] TestClass instance = new TestClass(); // Replace 'TestClass' with the actual class name [EOL] instance._typeParameters = new Type[3]; // Replace 'Type' with the actual type parameter class, and 3 with any positive number [EOL] int result = instance.containedTypeCount(); [EOL] assert result == 3 : "Expected count to be equal to the length of type parameters array"; [EOL] }
public void testContainedTypeWithNegativeIndex() { [EOL] JavaType result = instance.containedType(-1); [EOL] assertNull(result); [EOL] }
public void testContainedTypeWithIndexOutOfBounds() { [EOL] JavaType result = instance.containedType(2); [EOL] assertNull(result); [EOL] }
public void testContainedTypeWithNullTypeParameters() { [EOL] instance.setTypeParameters(null); [EOL] JavaType result = instance.containedType(0); [EOL] assertNull(result); [EOL] }
public void testContainedTypeWithValidIndex() { [EOL] JavaType result = instance.containedType(0); [EOL] assertNotNull(result); [EOL] assertEquals(expectedTypeParameter, result); [EOL] }
public void testEquals_Reflexive() { [EOL] SimpleType type = new SimpleType(String.class); [EOL] assertTrue(type.equals(type)); [EOL] }
public void testEquals_Null() { [EOL] SimpleType type = new SimpleType(String.class); [EOL] assertFalse(type.equals(null)); [EOL] }
public void testEquals_DifferentClass() { [EOL] SimpleType type = new SimpleType(String.class); [EOL] Object other = new Object(); [EOL] assertFalse(type.equals(other)); [EOL] }
public void testEquals_DifferentTypeClass() { [EOL] SimpleType type1 = new SimpleType(String.class); [EOL] SimpleType type2 = new SimpleType(Integer.class); [EOL] assertFalse(type1.equals(type2)); [EOL] }
public void testEquals_SameTypeClassNoTypeParameters() { [EOL] SimpleType type1 = new SimpleType(String.class); [EOL] SimpleType type2 = new SimpleType(String.class); [EOL] assertTrue(type1.equals(type2)); [EOL] }
public void testEquals_SameTypeClassWithTypeParameters_NullAndEmpty() { [EOL] SimpleType type1 = new SimpleType(String.class, null); [EOL] SimpleType type2 = new SimpleType(String.class, new JavaType[0]); [EOL] assertTrue(type1.equals(type2)); [EOL] }
public void testEquals_SameTypeClassWithTypeParameters_BothNull() { [EOL] SimpleType type1 = new SimpleType(String.class, null); [EOL] SimpleType type2 = new SimpleType(String.class, null); [EOL] assertTrue(type1.equals(type2)); [EOL] }
public void testEquals_SameTypeClassWithTypeParameters_OneNull() { [EOL] SimpleType type1 = new SimpleType(String.class, null); [EOL] SimpleType type2 = new SimpleType(String.class, new JavaType[]{new SimpleType(Integer.class)}); [EOL] assertFalse(type1.equals(type2)); [EOL] }
public void testEquals_SameTypeClassWithTypeParameters_DifferentLengths() { [EOL] SimpleType type1 = new SimpleType(String.class, new JavaType[]{new SimpleType(Integer.class)}); [EOL] SimpleType type2 = new SimpleType(String.class, new JavaType[]{new SimpleType(Integer.class), new SimpleType(Boolean.class)}); [EOL] assertFalse(type1.equals(type2)); [EOL] }
public void testEquals_SameTypeClassWithTypeParameters_SameLengthDifferentElements() { [EOL] SimpleType type1 = new SimpleType(String.class, new JavaType[]{new SimpleType(Integer.class)}); [EOL] SimpleType type2 = new SimpleType(String.class, new JavaType[]{new SimpleType(Boolean.class)}); [EOL] assertFalse(type1.equals(type2)); [EOL] }
public void testEquals_SameTypeClassWithTypeParameters_SameLengthSameElements() { [EOL] SimpleType type1 = new SimpleType(String.class, new JavaType[]{new SimpleType(Integer.class)}); [EOL] SimpleType type2 = new SimpleType(String.class, new JavaType[]{new SimpleType(Integer.class)}); [EOL] assertTrue(type1.equals(type2)); [EOL] }
public void testFindTypeParametersWithExactType() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] JavaType type = mapper.constructType(List.class); [EOL] JavaType[] typeParameters = findTypeParameters(type, List.class); [EOL] assertNull(typeParameters); [EOL] } [EOL] public void testFindTypeParametersWithSubType() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] JavaType type = mapper.constructType(ArrayList.class); [EOL] JavaType[] typeParameters = findTypeParameters(type, List.class); [EOL] assertNotNull(typeParameters); [EOL] assertEquals(1, typeParameters.length); [EOL] } [EOL] public void testFindTypeParametersWithNoContainedTypes() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] JavaType type = mapper.constructType(String.class); [EOL] JavaType[] typeParameters = findTypeParameters(type, String.class); [EOL] assertNull(typeParameters); [EOL] } [EOL] public void testFindTypeParametersWithMultipleContainedTypes() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] JavaType type = mapper.constructType(Map.Entry.class); [EOL] JavaType[] typeParameters = findTypeParameters(type, Map.Entry.class); [EOL] assertNotNull(typeParameters); [EOL] assertEquals(2, typeParameters.length); [EOL] }

public void testFindTypeParametersWithNonSubtype() { [EOL] try { [EOL] TypeFactory typeFactory = TypeFactory.defaultInstance(); [EOL] Class<?> clz = String.class; [EOL] Class<?> expType = Integer.class; [EOL] TypeBindings bindings = new TypeBindings(typeFactory, clz); [EOL] typeFactory.findTypeParameters(clz, expType, bindings); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testFindTypeParametersWithDirectSubtype() { [EOL] TypeFactory typeFactory = TypeFactory.defaultInstance(); [EOL] Class<?> clz = ArrayList.class; [EOL] Class<?> expType = List.class; [EOL] TypeBindings bindings = new TypeBindings(typeFactory, clz); [EOL] JavaType[] types = typeFactory.findTypeParameters(clz, expType, bindings); [EOL] assertNotNull("Type parameters should not be null", types); [EOL] }
public void testFindTypeParametersWithIndirectSubtype() { [EOL] TypeFactory typeFactory = TypeFactory.defaultInstance(); [EOL] Class<?> clz = Integer.class; [EOL] Class<?> expType = Number.class; [EOL] TypeBindings bindings = new TypeBindings(typeFactory, clz); [EOL] JavaType[] types = typeFactory.findTypeParameters(clz, expType, bindings); [EOL] assertNull("Type parameters should be null for non-generic type", types); [EOL] }
public void testFindTypeParametersWithGenericSubtype() { [EOL] TypeFactory typeFactory = TypeFactory.defaultInstance(); [EOL] Class<?> clz = HashMap.class; [EOL] Class<?> expType = Map.class; [EOL] TypeBindings bindings = new TypeBindings(typeFactory, clz); [EOL] JavaType[] types = typeFactory.findTypeParameters(clz, expType, bindings); [EOL] assertNotNull("Type parameters should not be null for generic type", types); [EOL] assertEquals("Expected two type parameters", 2, types.length); [EOL] }
public void testConstructTypeWithNullType() { [EOL] TypeBindings bindings = new TypeBindings(null, null, null); [EOL] try { [EOL] JavaType result = constructType(null, bindings); [EOL] assertNull(result); [EOL] } catch (Exception e) { [EOL] fail("Exception should not be thrown for null Type"); [EOL] } [EOL] }
public void testConstructTypeWithNonNullType() { [EOL] TypeBindings bindings = new TypeBindings(null, null, null); [EOL] Type type = String.class; [EOL] JavaType result = constructType(type, bindings); [EOL] assertNotNull(result); [EOL] assertEquals(StringType.class, result.getClass()); [EOL] }
public void testConstructCollectionTypeWithValidClasses() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] CollectionType type = mapper.getTypeFactory().constructCollectionType(ArrayList.class, String.class); [EOL] assertNotNull(type); [EOL] assertEquals(ArrayList.class, type.getRawClass()); [EOL] assertEquals(String.class, type.getContentType().getRawClass()); [EOL] }
public void testConstructCollectionTypeWithNullCollectionClass() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] try { [EOL] mapper.getTypeFactory().constructCollectionType(null, String.class); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testConstructCollectionTypeWithNullElementClass() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] try { [EOL] mapper.getTypeFactory().constructCollectionType(ArrayList.class, null); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testConstructCollectionTypeWithValidParameters() { [EOL] JavaType elementType = TypeFactory.defaultInstance().constructType(String.class); [EOL] CollectionType collectionType = constructCollectionType(ArrayList.class, elementType); [EOL] assertNotNull(collectionType); [EOL] assertEquals(ArrayList.class, collectionType.getRawClass()); [EOL] assertEquals(elementType, collectionType.getContentType()); [EOL] }
public void testConstructCollectionTypeWithNullCollectionClass() { [EOL] try { [EOL] JavaType elementType = TypeFactory.defaultInstance().constructType(String.class); [EOL] constructCollectionType(null, elementType); [EOL] fail("Expected IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testConstructCollectionTypeWithNullElementType() { [EOL] try { [EOL] constructCollectionType(ArrayList.class, null); [EOL] fail("Expected IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testConstructMapTypeWithValidParameters() { [EOL] Class<? extends Map> mapClass = HashMap.class; [EOL] JavaType keyType = TypeFactory.defaultInstance().constructType(String.class); [EOL] JavaType valueType = TypeFactory.defaultInstance().constructType(Integer.class); [EOL] MapType result = constructMapType(mapClass, keyType, valueType); [EOL] assertNotNull(result); [EOL] assertEquals(mapClass, result.getRawClass()); [EOL] assertEquals(keyType, result.getKeyType()); [EOL] assertEquals(valueType, result.getContentType()); [EOL] }
public void testConstructMapTypeWithNullMapClass() { [EOL] Class<? extends Map> mapClass = null; [EOL] JavaType keyType = TypeFactory.defaultInstance().constructType(String.class); [EOL] JavaType valueType = TypeFactory.defaultInstance().constructType(Integer.class); [EOL] try { [EOL] constructMapType(mapClass, keyType, valueType); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testConstructMapTypeWithNullKeyType() { [EOL] Class<? extends Map> mapClass = HashMap.class; [EOL] JavaType keyType = null; [EOL] JavaType valueType = TypeFactory.defaultInstance().constructType(Integer.class); [EOL] try { [EOL] constructMapType(mapClass, keyType, valueType); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testConstructMapTypeWithNullValueType() { [EOL] Class<? extends Map> mapClass = HashMap.class; [EOL] JavaType keyType = TypeFactory.defaultInstance().constructType(String.class); [EOL] JavaType valueType = null; [EOL] try { [EOL] constructMapType(mapClass, keyType, valueType); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testConstructMapLikeTypeWithValidParameters() { [EOL] Class<?> mapClass = HashMap.class; [EOL] JavaType keyType = TypeFactory.defaultInstance().constructType(String.class); [EOL] JavaType valueType = TypeFactory.defaultInstance().constructType(Integer.class); [EOL] MapLikeType result = constructMapLikeType(mapClass, keyType, valueType); [EOL] assertNotNull(result); [EOL] assertEquals(mapClass, result.getRawClass()); [EOL] assertEquals(keyType, result.getKeyType()); [EOL] assertEquals(valueType, result.getContentType()); [EOL] }
public void testConstructMapLikeTypeWithNullMapClass() { [EOL] Class<?> mapClass = null; [EOL] JavaType keyType = TypeFactory.defaultInstance().constructType(String.class); [EOL] JavaType valueType = TypeFactory.defaultInstance().constructType(Integer.class); [EOL] try { [EOL] constructMapLikeType(mapClass, keyType, valueType); [EOL] fail("Expected IllegalArgumentException for null mapClass"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testConstructMapLikeTypeWithNullKeyType() { [EOL] Class<?> mapClass = HashMap.class; [EOL] JavaType keyType = null; [EOL] JavaType valueType = TypeFactory.defaultInstance().constructType(Integer.class); [EOL] try { [EOL] constructMapLikeType(mapClass, keyType, valueType); [EOL] fail("Expected IllegalArgumentException for null keyType"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testConstructMapLikeTypeWithNullValueType() { [EOL] Class<?> mapClass = HashMap.class; [EOL] JavaType keyType = TypeFactory.defaultInstance().constructType(String.class); [EOL] JavaType valueType = null; [EOL] try { [EOL] constructMapLikeType(mapClass, keyType, valueType); [EOL] fail("Expected IllegalArgumentException for null valueType"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testConstructSimpleTypeWithMatchingParameters() { [EOL] Class<?> rawType = Map.class; [EOL] JavaType[] parameterTypes = new JavaType[] { [EOL] TypeFactory.defaultInstance().constructSimpleType(String.class, null), [EOL] TypeFactory.defaultInstance().constructSimpleType(Integer.class, null) [EOL] }; [EOL] JavaType resultType = constructSimpleType(rawType, parameterTypes); [EOL] assertNotNull(resultType); [EOL] assertTrue(resultType instanceof SimpleType); [EOL] assertEquals(rawType, resultType.getRawClass()); [EOL] assertEquals(parameterTypes.length, resultType.containedTypeCount()); [EOL] }
public void testConstructSimpleTypeWithMismatchedParameters() { [EOL] Class<?> rawType = Map.class; [EOL] JavaType[] parameterTypes = new JavaType[] { [EOL] TypeFactory.defaultInstance().constructSimpleType(String.class, null) [EOL] }; [EOL] try { [EOL] constructSimpleType(rawType, parameterTypes); [EOL] fail("Expected IllegalArgumentException due to parameter type mismatch"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testUncheckedSimpleTypeWithNonNullClass() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] JavaType javaType = mapper.getTypeFactory().uncheckedSimpleType(String.class); [EOL] assertNotNull(javaType); [EOL] assertTrue(javaType instanceof SimpleType); [EOL] assertEquals(String.class, javaType.getRawClass()); [EOL] }
public void testUncheckedSimpleTypeWithPrimitiveClass() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] JavaType javaType = mapper.getTypeFactory().uncheckedSimpleType(int.class); [EOL] assertNotNull(javaType); [EOL] assertTrue(javaType instanceof SimpleType); [EOL] assertEquals(int.class, javaType.getRawClass()); [EOL] }
public void testConstructParametricTypeWithEmptyParameters() { [EOL] JavaType result = constructParametricType(SomeClass.class); [EOL] assertNotNull(result); [EOL] assertTrue(result.isContainerType()); [EOL] }
public void testConstructParametricTypeWithSingleParameter() { [EOL] JavaType result = constructParametricType(Map.class, String.class); [EOL] assertNotNull(result); [EOL] assertTrue(result.hasGenericTypes()); [EOL] assertEquals(String.class, result.containedType(0).getRawClass()); [EOL] }
public void testConstructParametricTypeWithMultipleParameters() { [EOL] JavaType result = constructParametricType(Map.class, String.class, Integer.class); [EOL] assertNotNull(result); [EOL] assertTrue(result.hasGenericTypes()); [EOL] assertEquals(String.class, result.containedType(0).getRawClass()); [EOL] assertEquals(Integer.class, result.containedType(1).getRawClass()); [EOL] }
public void testConstructParametricTypeWithArrayAndOneParameterType() { [EOL] JavaType[] parameterTypes = new JavaType[] { TypeFactory.defaultInstance().constructSimpleType(String.class, null) }; [EOL] JavaType resultType = constructParametricType(String[].class, parameterTypes); [EOL] assertNotNull(resultType); [EOL] assertTrue(resultType.isArrayType()); [EOL] }
public void testConstructParametricTypeWithArrayAndIncorrectParameterCount() { [EOL] JavaType[] parameterTypes = new JavaType[] {}; [EOL] try { [EOL] constructParametricType(String[].class, parameterTypes); [EOL] fail("Expected IllegalArgumentException for empty parameter types"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Need exactly 1 parameter type for arrays (java.lang.String[])", e.getMessage()); [EOL] } [EOL] }
public void testConstructParametricTypeWithMapAndTwoParameterTypes() { [EOL] JavaType[] parameterTypes = new JavaType[] { [EOL] TypeFactory.defaultInstance().constructSimpleType(String.class, null), [EOL] TypeFactory.defaultInstance().constructSimpleType(Integer.class, null) [EOL] }; [EOL] JavaType resultType = constructParametricType(HashMap.class, parameterTypes); [EOL] assertNotNull(resultType); [EOL] assertTrue(resultType.isMapLikeType()); [EOL] }
public void testConstructParametricTypeWithMapAndIncorrectParameterCount() { [EOL] JavaType[] parameterTypes = new JavaType[] { TypeFactory.defaultInstance().constructSimpleType(String.class, null) }; [EOL] try { [EOL] constructParametricType(HashMap.class, parameterTypes); [EOL] fail("Expected IllegalArgumentException for incorrect number of parameter types"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Need exactly 2 parameter types for Map types (java.util.HashMap)", e.getMessage()); [EOL] } [EOL] }
public void testConstructParametricTypeWithCollectionAndOneParameterType() { [EOL] JavaType[] parameterTypes = new JavaType[] { TypeFactory.defaultInstance().constructSimpleType(String.class, null) }; [EOL] JavaType resultType = constructParametricType(ArrayList.class, parameterTypes); [EOL] assertNotNull(resultType); [EOL] assertTrue(resultType.isCollectionLikeType()); [EOL] }
public void testConstructParametricTypeWithCollectionAndIncorrectParameterCount() { [EOL] JavaType[] parameterTypes = new JavaType[] {}; [EOL] try { [EOL] constructParametricType(ArrayList.class, parameterTypes); [EOL] fail("Expected IllegalArgumentException for empty parameter types"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Need exactly 1 parameter type for Collection types (java.util.ArrayList)", e.getMessage()); [EOL] } [EOL] }
public void testConstructParametricTypeWithSimpleTypeAndVariableParameterTypes() { [EOL] JavaType[] parameterTypes = new JavaType[] { [EOL] TypeFactory.defaultInstance().constructSimpleType(String.class, null), [EOL] TypeFactory.defaultInstance().constructSimpleType(Integer.class, null) [EOL] }; [EOL] JavaType resultType = constructParametricType(CustomClass.class, parameterTypes); [EOL] assertNotNull(resultType); [EOL] assertFalse(resultType.isArrayType()); [EOL] assertFalse(resultType.isMapLikeType()); [EOL] assertFalse(resultType.isCollectionLikeType()); [EOL] }
protected JavaType _fromParamType(ParameterizedType type, TypeBindings context) { [EOL] Class<?> rawType = (Class<?>) type.getRawType(); [EOL] Type[] args = type.getActualTypeArguments(); [EOL] int paramCount = (args == null) ? 0 : args.length; [EOL] JavaType[] pt; [EOL] if (paramCount == 0) { [EOL] pt = NO_TYPES; [EOL] } else { [EOL] pt = new JavaType[paramCount]; [EOL] for (int i = 0; i < paramCount; ++i) { [EOL] pt[i] = _constructType(args[i], context); [EOL] } [EOL] } [EOL] if (Map.class.isAssignableFrom(rawType)) { [EOL] JavaType subtype = constructSimpleType(rawType, pt); [EOL] JavaType[] mapParams = findTypeParameters(subtype, Map.class); [EOL] if (mapParams.length != 2) { [EOL] throw new IllegalArgumentException("Could not find 2 type parameters for Map class " + rawType.getName() + " (found " + mapParams.length + ")"); [EOL] } [EOL] return MapType.construct(rawType, mapParams[0], mapParams[1]); [EOL] } [EOL] if (Collection.class.isAssignableFrom(rawType)) { [EOL] JavaType subtype = constructSimpleType(rawType, pt); [EOL] JavaType[] collectionParams = findTypeParameters(subtype, Collection.class); [EOL] if (collectionParams.length != 1) { [EOL] throw new IllegalArgumentException("Could not find 1 type parameter for Collection class " + rawType.getName() + " (found " + collectionParams.length + ")"); [EOL] } [EOL] return CollectionType.construct(rawType, collectionParams[0]); [EOL] } [EOL] if (paramCount == 0) { [EOL] return new SimpleType(rawType); [EOL] } [EOL] return constructSimpleType(rawType, pt); [EOL] }
public void testFromVariableWithNullContext() { [EOL] TypeVariable<?> typeVariable = mock(TypeVariable.class); [EOL] JavaType result = _fromVariable(typeVariable, null); [EOL] assertNotNull(result); [EOL] }
public void testFromVariableWithKnownType() { [EOL] TypeVariable<?> typeVariable = mock(TypeVariable.class); [EOL] when(typeVariable.getName()).thenReturn("T"); [EOL] TypeBindings context = mock(TypeBindings.class); [EOL] JavaType expectedType = mock(JavaType.class); [EOL] when(context.findType("T")).thenReturn(expectedType); [EOL] JavaType result = _fromVariable(typeVariable, context); [EOL] assertSame(expectedType, result); [EOL] }
public void testFromVariableWithUnknownTypeAndBounds() { [EOL] TypeVariable<?> typeVariable = mock(TypeVariable.class); [EOL] when(typeVariable.getName()).thenReturn("T"); [EOL] when(typeVariable.getBounds()).thenReturn(new Type[] {String.class}); [EOL] TypeBindings context = mock(TypeBindings.class); [EOL] when(context.findType("T")).thenReturn(null); [EOL] doNothing().when(context)._addPlaceholder("T"); [EOL] JavaType result = _fromVariable(typeVariable, context); [EOL] assertNotNull(result); [EOL] }
public void testMapTypeWithNullTypeParameters() { [EOL] Class<?> rawClass = HashMap.class; // Use any Map implementation [EOL] JavaType result = _mapType(rawClass); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof MapType); [EOL] assertEquals(_unknownType(), ((MapType) result).getKeyType()); [EOL] assertEquals(_unknownType(), ((MapType) result).getContentType()); [EOL] }
public void testMapTypeWithInvalidTypeParameters() { [EOL] Class<?> rawClass = CustomMapWithInvalidTypeParameters.class; // Custom class with incorrect type parameters [EOL] try { [EOL] _mapType(rawClass); [EOL] fail("Expected IllegalArgumentException for incorrect type parameters"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testMapTypeWithValidTypeParameters() { [EOL] Class<?> rawClass = HashMap.class; // Use any Map implementation with known type parameters [EOL] JavaType result = _mapType(rawClass); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof MapType); [EOL] JavaType keyType = ((MapType) result).getKeyType(); [EOL] JavaType contentType = ((MapType) result).getContentType(); [EOL] assertNotNull(keyType); [EOL] assertNotNull(contentType); [EOL] assertEquals(String.class, keyType.getRawClass()); [EOL] assertEquals(Integer.class, contentType.getRawClass()); [EOL] }
protected HierarchicType _findSuperTypeChain(Class<?> subtype, Class<?> supertype) { [EOL] if (supertype.isInterface()) { [EOL] return _findSuperInterfaceChain(subtype, supertype); [EOL] } [EOL] return _findSuperClassChain(subtype, supertype); [EOL] }
protected HierarchicType _findSuperClassChain(Type currentType, Class<?> target) { [EOL] HierarchicType current = new HierarchicType(currentType); [EOL] Class<?> raw = current.getRawClass(); [EOL] if (raw == target) { [EOL] return current; [EOL] } [EOL] Type parent = raw.getGenericSuperclass(); [EOL] if (parent != null) { [EOL] HierarchicType sup = _findSuperClassChain(parent, target); [EOL] if (sup != null) { [EOL] sup.setSubType(current); [EOL] current.setSuperType(sup); [EOL] return current; [EOL] } [EOL] } [EOL] return null; [EOL] }
protected HierarchicType _findSuperInterfaceChain(Type currentType, Class<?> target) { [EOL] HierarchicType current = new HierarchicType(currentType); [EOL] Class<?> raw = current.getRawClass(); [EOL] if (raw == target) { [EOL] return new HierarchicType(currentType); [EOL] } [EOL] if (raw == HashMap.class) { [EOL] if (target == Map.class) { [EOL] return _hashMapSuperInterfaceChain(current); [EOL] } [EOL] } [EOL] if (raw == ArrayList.class) { [EOL] if (target == List.class) { [EOL] return _arrayListSuperInterfaceChain(current); [EOL] } [EOL] } [EOL] return _doFindSuperInterfaceChain(current, target); [EOL] }
public void testDoFindSuperInterfaceChainWithInterface() { [EOL] HierarchicType current = new HierarchicType(SomeInterface.class); [EOL] HierarchicType result = _doFindSuperInterfaceChain(current, TargetInterface.class); [EOL] assertNotNull(result); [EOL] assertEquals(TargetInterface.class, result.getRawClass()); [EOL] } [EOL] public void testDoFindSuperInterfaceChainWithSuperclass() { [EOL] HierarchicType current = new HierarchicType(SomeClass.class); [EOL] HierarchicType result = _doFindSuperInterfaceChain(current, TargetSuperclass.class); [EOL] assertNotNull(result); [EOL] assertEquals(TargetSuperclass.class, result.getRawClass()); [EOL] } [EOL] public void testDoFindSuperInterfaceChainWithNoSuperType() { [EOL] HierarchicType current = new HierarchicType(Object.class); [EOL] HierarchicType result = _doFindSuperInterfaceChain(current, TargetInterface.class); [EOL] assertNull(result); [EOL] }
public void testDoFindSuperInterfaceChainWithNullCurrent() { [EOL] HierarchicType result = _doFindSuperInterfaceChain(null, TargetInterface.class); [EOL] assertNull(result); [EOL] }
public void testAsPropertyTypeDeserializer() { [EOL] JavaType bt = ...; // Initialize with a valid JavaType instance [EOL] TypeIdResolver idRes = ...; // Initialize with a valid TypeIdResolver instance [EOL] String typePropertyName = "type"; [EOL] boolean typeIdVisible = true; [EOL] Class<?> defaultImpl = Object.class; [EOL] AsPropertyTypeDeserializer deserializer = new AsPropertyTypeDeserializer(bt, idRes, typePropertyName, typeIdVisible, defaultImpl); [EOL] assertEquals(bt, deserializer.baseType); // Replace 'baseType' with the actual field name or getter method [EOL] assertEquals(idRes, deserializer.idResolver); // Replace 'idResolver' with the actual field name or getter method [EOL] assertEquals(typePropertyName, deserializer.typePropertyName); // Replace 'typePropertyName' with the actual field name or getter method [EOL] assertEquals(typeIdVisible, deserializer.typeIdVisible); // Replace 'typeIdVisible' with the actual field name or getter method [EOL] assertEquals(defaultImpl, deserializer.defaultImpl); // Replace 'defaultImpl' with the actual field name or getter method [EOL] }
public void testAsPropertyTypeDeserializerWithNullProperty() { [EOL] AsPropertyTypeDeserializer original = new AsPropertyTypeDeserializer(/* parameters to create an instance */); [EOL] AsPropertyTypeDeserializer copy = new AsPropertyTypeDeserializer(original, null); [EOL] assertNull(copy.getProperty()); [EOL] }
public void testAsPropertyTypeDeserializerWithNonNullProperty() { [EOL] AsPropertyTypeDeserializer original = new AsPropertyTypeDeserializer(/* parameters to create an instance */); [EOL] BeanProperty property = new BeanProperty.Std(/* parameters to create a BeanProperty.Std instance */); [EOL] AsPropertyTypeDeserializer copy = new AsPropertyTypeDeserializer(original, property); [EOL] assertNotNull(copy.getProperty()); [EOL] assertEquals(property, copy.getProperty()); [EOL] }
public void testForPropertySameProperty() { [EOL] BeanProperty prop = createMockProperty(); [EOL] AsPropertyTypeDeserializer deserializer = new AsPropertyTypeDeserializer(createBaseDeserializer(), prop); [EOL] TypeDeserializer result = deserializer.forProperty(prop); [EOL] assertSame(deserializer, result); [EOL] }
public void testForPropertyDifferentProperty() { [EOL] BeanProperty prop1 = createMockProperty(); [EOL] BeanProperty prop2 = createMockProperty(); [EOL] AsPropertyTypeDeserializer deserializer = new AsPropertyTypeDeserializer(createBaseDeserializer(), prop1); [EOL] TypeDeserializer result = deserializer.forProperty(prop2); [EOL] assertNotNull(result); [EOL] assertNotSame(deserializer, result); [EOL] assertTrue(result instanceof AsPropertyTypeDeserializer); [EOL] }
public void testGetTypeInclusion() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] JsonTypeInfo info = mapper.getSerializationConfig().getDefaultPropertyInclusion().getValueInclusion(); [EOL] assertEquals(JsonTypeInfo.As.PROPERTY, info.getTypeInclusion()); [EOL] }
public void testDeserializeTypedFromObjectWithStartObjectToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); [EOL] when(jp.nextToken()).thenReturn(JsonToken.END_OBJECT); [EOL] Object result = deserializeTypedFromObject(jp, ctxt); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeTypedFromObjectWithStartArrayToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_ARRAY); [EOL] Object result = deserializeTypedFromObject(jp, ctxt); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeTypedFromObjectWithFieldNameToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] TokenBuffer tb = new TokenBuffer(null); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.FIELD_NAME); [EOL] when(jp.nextToken()).thenReturn(JsonToken.END_OBJECT); [EOL] when(jp.getCurrentName()).thenReturn("typePropertyName"); [EOL] Object result = deserializeTypedFromObject(jp, ctxt); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeTypedFromObjectWithUnexpectedToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] Object result = deserializeTypedFromObject(jp, ctxt); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeTypedUsingDefaultImplWithDeserializer() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] TokenBuffer tb = mock(TokenBuffer.class); [EOL] JsonDeserializer<Object> deser = mock(JsonDeserializer.class); [EOL] when(_findDefaultImplDeserializer(ctxt)).thenReturn(deser); [EOL] when(deser.deserialize(jp, ctxt)).thenReturn(new Object()); [EOL] Object result = _deserializeTypedUsingDefaultImpl(jp, ctxt, tb); [EOL] assertNotNull(result); [EOL] verify(deser).deserialize(jp, ctxt); [EOL] }
public void testDeserializeTypedUsingDefaultImplWithTokenBuffer() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] TokenBuffer tb = new TokenBuffer(jp, ctxt); [EOL] when(_findDefaultImplDeserializer(ctxt)).thenReturn(null); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_ARRAY); [EOL] Object result = _deserializeTypedUsingDefaultImpl(jp, ctxt, tb); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeTypedUsingDefaultImplWithNaturalType() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(_findDefaultImplDeserializer(ctxt)).thenReturn(null); [EOL] when(TypeDeserializer.deserializeIfNatural(jp, ctxt, _baseType)).thenReturn(new Object()); [EOL] Object result = _deserializeTypedUsingDefaultImpl(jp, ctxt, null); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeTypedUsingDefaultImplWithWrongTokenException() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(_findDefaultImplDeserializer(ctxt)).thenReturn(null); [EOL] when(TypeDeserializer.deserializeIfNatural(jp, ctxt, _baseType)).thenReturn(null); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.NOT_AVAILABLE); [EOL] assertThrows(JsonProcessingException.class, () -> { [EOL] _deserializeTypedUsingDefaultImpl(jp, ctxt, null); [EOL] }); [EOL] }
public void testMapperConfigBaseWithNonNullValues() { [EOL] BaseSettings baseSettings = new BaseSettings(null, null, null, null, null, null, null, null); [EOL] SubtypeResolver subtypeResolver = new StdSubtypeResolver(); [EOL] Map<ClassKey, Class<?>> mixins = new HashMap<>(); [EOL] mixins.put(new ClassKey(String.class), Object.class); [EOL] MapperConfigBase configBase = new MapperConfigBase(baseSettings, subtypeResolver, mixins); [EOL] assertNotNull(configBase); [EOL] assertEquals(subtypeResolver, configBase.getSubtypeResolver()); [EOL] assertEquals(mixins, configBase.mixInAnnotations()); [EOL] assertNull(configBase.getRootName()); [EOL] assertNull(configBase.getView()); [EOL] }
public void testMapperConfigBaseWithNullValues() { [EOL] BaseSettings baseSettings = new BaseSettings(null, null, null, null, null, null, null, null); [EOL] MapperConfigBase configBase = new MapperConfigBase(baseSettings, null, null); [EOL] assertNotNull(configBase); [EOL] assertNull(configBase.getSubtypeResolver()); [EOL] assertTrue(configBase.mixInAnnotations().isEmpty()); [EOL] assertNull(configBase.getRootName()); [EOL] assertNull(configBase.getView()); [EOL] }
public void testMapperConfigBaseCopyConstructor() { [EOL] BaseSettings baseSettings = new BaseSettings(null, null, null, null, null, null, null, null, null, null, null); [EOL] MapperConfigBase<?, ?> original = new MapperConfigBase<Object, Object>(baseSettings, 0); [EOL] MapperConfigBase<?, ?> copy = new MapperConfigBase<Object, Object>(original, baseSettings); [EOL] assertEquals(original._mixInAnnotations, copy._mixInAnnotations); [EOL] assertEquals(original._subtypeResolver, copy._subtypeResolver); [EOL] assertEquals(original._rootName, copy._rootName); [EOL] assertEquals(original._view, copy._view); [EOL] }
public void testMapperConfigBaseCopyConstructor() { [EOL] int mapperFeatures = 123; // Example feature flags [EOL] SimpleModule module = new SimpleModule("TestModule"); [EOL] ObjectMapper originalMapper = new ObjectMapper(); [EOL] originalMapper.registerModule(module); [EOL] SerializationConfig originalConfig = originalMapper.getSerializationConfig(); [EOL] SerializationConfig copiedConfig = new SerializationConfig(originalConfig, mapperFeatures); [EOL] assertEquals(copiedConfig.getMapperFeatures(), mapperFeatures); [EOL] assertEquals(copiedConfig.getMixInAnnotations(), originalConfig.getMixInAnnotations()); [EOL] assertEquals(copiedConfig.getSubtypeResolver(), originalConfig.getSubtypeResolver()); [EOL] assertEquals(copiedConfig.getRootName(), originalConfig.getRootName()); [EOL] assertEquals(copiedConfig.getActiveView(), originalConfig.getActiveView()); [EOL] }
public void testMapperConfigBaseCopyConstructorWithNonNullRootName() { [EOL] ConcreteMapperConfigBase original = new ConcreteMapperConfigBase(); [EOL] String rootName = "newRoot"; [EOL] ConcreteMapperConfigBase copied = new ConcreteMapperConfigBase(original, rootName); [EOL] assertNotNull(copied); [EOL] assertEquals(rootName, copied._rootName); [EOL] assertSame(original._mixInAnnotations, copied._mixInAnnotations); [EOL] assertSame(original._subtypeResolver, copied._subtypeResolver); [EOL] assertSame(original._view, copied._view); [EOL] }
public void testMapperConfigBaseCopyConstructorWithNullRootName() { [EOL] ConcreteMapperConfigBase original = new ConcreteMapperConfigBase(); [EOL] String rootName = null; [EOL] ConcreteMapperConfigBase copied = new ConcreteMapperConfigBase(original, rootName); [EOL] assertNotNull(copied); [EOL] assertNull(copied._rootName); [EOL] assertSame(original._mixInAnnotations, copied._mixInAnnotations); [EOL] assertSame(original._subtypeResolver, copied._subtypeResolver); [EOL] assertSame(original._view, copied._view); [EOL] }
public void testMapperConfigBaseCopyConstructor() { [EOL] TestMapperConfigBase original = new TestMapperConfigBase(); [EOL] Class<?> viewClass = String.class; // Example view class [EOL] original.setMixInAnnotations(new HashMap<Class<?>, Class<?>>()); [EOL] original.setSubtypeResolver(new StdSubtypeResolver()); [EOL] original.setRootName(new PropertyName("root")); [EOL] TestMapperConfigBase copy = new TestMapperConfigBase(original, viewClass); [EOL] assertEquals(original.getMixInAnnotations(), copy.getMixInAnnotations()); [EOL] assertEquals(original.getSubtypeResolver(), copy.getSubtypeResolver()); [EOL] assertEquals(original.getRootName(), copy.getRootName()); [EOL] assertEquals(viewClass, copy.getView()); [EOL] }
public void testMapperConfigBaseCopyConstructor() { [EOL] Map<ClassKey, Class<?>> mixins = new HashMap<>(); [EOL] mixins.put(new ClassKey(String.class), Object.class); [EOL] MapperConfigBase<?, ?> original = createMapperConfigBase(); [EOL] MapperConfigBase<?, ?> copy = new MapperConfigBase<>(original, mixins); [EOL] assertNotNull(copy); [EOL] assertEquals(mixins, copy._mixInAnnotations); [EOL] assertSame(original._subtypeResolver, copy._subtypeResolver); [EOL] assertEquals(original._rootName, copy._rootName); [EOL] assertEquals(original._view, copy._view); [EOL] }
public void testGetRootNameWhenRootNameIsNull() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] assertNull(mapper.getRootName()); [EOL] }
public void testGetRootNameWhenRootNameIsSet() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] mapper.setRootName("testRoot"); [EOL] assertEquals("testRoot", mapper.getRootName()); [EOL] }
public void testGetActiveView_WithNonNullView() { [EOL] Class<?> expectedView = SomeViewClass.class; [EOL] ObjectMapper mapper = new ObjectMapper().setConfig(mapper.getSerializationConfig().withView(expectedView)); [EOL] Class<?> actualView = mapper.getSerializationConfig().getActiveView(); [EOL] assertEquals("The active view should be the one that was set", expectedView, actualView); [EOL] }
public void testGetActiveView_WithNullView() { [EOL] ObjectMapper mapper = new ObjectMapper(); // By default, the view is null [EOL] Class<?> actualView = mapper.getSerializationConfig().getActiveView(); [EOL] assertNull("The active view should be null", actualView); [EOL] }
public void testFindMixInClassFor_NullMixIns() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] assertNull(mapper.getSerializationConfig().findMixInClassFor(Object.class)); [EOL] }
public void testFindMixInClassFor_WithMixIns() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] mapper.addMixInAnnotations(Object.class, String.class); [EOL] assertEquals(String.class, mapper.getSerializationConfig().findMixInClassFor(Object.class)); [EOL] }
public void testMixInCountWhenMixInAnnotationsIsNull() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] assertEquals(0, mapper.mixInCount()); [EOL] }
public void testMixInCountWhenMixInAnnotationsIsNotNull() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] mapper.addMixIn(Object.class, String.class); [EOL] assertTrue(mapper.mixInCount() > 0); [EOL] }
public void testWriteNumberWithNullValue() throws IOException { [EOL] JsonGenerator generator = createGenerator(); [EOL] generator.writeNumber((BigInteger) null); [EOL] verifyWriteNull(generator); [EOL] }
public void testWriteNumberWithNonNullValue() throws IOException { [EOL] JsonGenerator generator = createGenerator(); [EOL] BigInteger value = new BigInteger("12345"); [EOL] generator.writeNumber(value); [EOL] verifyAppend(generator, JsonToken.VALUE_NUMBER_INT, value); [EOL] }
public void testGetTokenLocation() { [EOL] JsonParser parser = createParserWithContent("{}"); [EOL] JsonLocation location = parser.getTokenLocation(); [EOL] assertNotNull(location); [EOL] assertEquals(0, location.getLineNr()); [EOL] assertEquals(0, location.getColumnNr()); [EOL] }
public void testGetCurrentLocationWhenLocationIsNull() { [EOL] JsonParser parser = createParserWithNullLocation(); [EOL] JsonLocation location = parser.getCurrentLocation(); [EOL] assertEquals(JsonLocation.NA, location); [EOL] } [EOL] public void testGetCurrentLocationWhenLocationIsNotNull() { [EOL] JsonLocation expectedLocation = new JsonLocation(...); // Provide actual initialization [EOL] JsonParser parser = createParserWithNonNullLocation(expectedLocation); [EOL] JsonLocation location = parser.getCurrentLocation(); [EOL] assertEquals(expectedLocation, location); [EOL] }
public void testGetLongValueWithInt() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserWithNumber("123"); [EOL] assertEquals(123L, parser.getLongValue()); [EOL] } [EOL] public void testGetLongValueWithLong() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserWithNumber("9223372036854775807"); [EOL] assertEquals(9223372036854775807L, parser.getLongValue()); [EOL] } [EOL] public void testGetLongValueWithDouble() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserWithNumber("123.456"); [EOL] try { [EOL] parser.getLongValue(); [EOL] fail("Expected JsonParseException"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] } [EOL] public void testGetLongValueWithNonNumber() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserWithNonNumber("true"); [EOL] try { [EOL] parser.getLongValue(); [EOL] fail("Expected JsonParseException"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] } [EOL] private JsonParser createParserWithNumber(String number) { [EOL] return null; [EOL] } [EOL] private JsonParser createParserWithNonNumber(String nonNumber) { [EOL] return null; [EOL] }

public void testJavaTypeConstructor() { [EOL] Class<?> rawClass = Object.class; [EOL] int additionalHash = 1; [EOL] Object valueHandler = new Object(); [EOL] Object typeHandler = new Object(); [EOL] boolean asStatic = true; [EOL] JavaType javaType = new JavaType(rawClass, additionalHash, valueHandler, typeHandler, asStatic); [EOL] assertEquals(rawClass, javaType._class); [EOL] assertEquals(rawClass.getName().hashCode() + additionalHash, javaType._hashCode); [EOL] assertEquals(valueHandler, javaType._valueHandler); [EOL] assertEquals(typeHandler, javaType._typeHandler); [EOL] assertEquals(asStatic, javaType._asStatic); [EOL] }
public void testNarrowByWithSameClass() { [EOL] JavaType originalType = constructJavaType(); // Replace with actual method to construct JavaType [EOL] JavaType resultType = originalType.narrowBy(originalType.getRawClass()); [EOL] assertSame("Narrowing with the same class should return the original JavaType", originalType, resultType); [EOL] }
public void testNarrowByWithSubclass() { [EOL] JavaType originalType = constructJavaType(); // Replace with actual method to construct JavaType [EOL] Class<?> subclass = getSubclass(originalType.getRawClass()); // Replace with actual method to get a subclass [EOL] JavaType resultType = originalType.narrowBy(subclass); [EOL] assertNotSame("Narrowing with a subclass should not return the original JavaType", originalType, resultType); [EOL] assertEquals("The subclass should be set correctly", subclass, resultType.getRawClass()); [EOL] }
public void testNarrowByWithDifferentValueHandler() { [EOL] JavaType originalType = constructJavaTypeWithValueHandler(); // Replace with actual method to construct JavaType with a value handler [EOL] Class<?> subclass = getSubclass(originalType.getRawClass()); // Replace with actual method to get a subclass [EOL] JavaType resultType = originalType.narrowBy(subclass); [EOL] assertSame("Value handler should be preserved when narrowing", originalType.getValueHandler(), resultType.getValueHandler()); [EOL] }
public void testNarrowByWithDifferentTypeHandler() { [EOL] JavaType originalType = constructJavaTypeWithTypeHandler(); // Replace with actual method to construct JavaType with a type handler [EOL] Class<?> subclass = getSubclass(originalType.getRawClass()); // Replace with actual method to get a subclass [EOL] JavaType resultType = originalType.narrowBy(subclass); [EOL] assertSame("Type handler should be preserved when narrowing", originalType.getTypeHandler(), resultType.getTypeHandler()); [EOL] }
public void testWidenByWithSameClass() { [EOL] JavaType javaType = obtainJavaTypeInstance(); // Replace with actual method to obtain JavaType instance [EOL] Class<?> clazz = javaType.getRawClass(); [EOL] JavaType result = javaType.widenBy(clazz); [EOL] assertEquals(javaType, result); [EOL] }
public void testWidenByWithSubclass() { [EOL] JavaType javaType = obtainJavaTypeInstance(); // Replace with actual method to obtain JavaType instance [EOL] Class<?> clazz = javaType.getRawClass(); [EOL] Class<?> subclass = obtainSubclass(clazz); // Replace with actual method to obtain a subclass of clazz [EOL] JavaType result = javaType.widenBy(subclass); [EOL] assertNotSame(javaType, result); [EOL] assertEquals(subclass, result.getRawClass()); [EOL] }
public void testWidenByWithNonSubclass() { [EOL] JavaType javaType = obtainJavaTypeInstance(); // Replace with actual method to obtain JavaType instance [EOL] Class<?> clazz = javaType.getRawClass(); [EOL] Class<?> nonSubclass = obtainNonSubclass(clazz); // Replace with actual method to obtain a non-subclass of clazz [EOL] try { [EOL] javaType.widenBy(nonSubclass); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
protected JavaType _widen(Class<?> superclass) { [EOL] return _narrow(superclass); [EOL] }
public void testGetRawClass() { [EOL] MyClass instance = new MyClass(); [EOL] Class<?> expected = MyClass.class; [EOL] Class<?> actual = instance.getRawClass(); [EOL] assertEquals(expected, actual); [EOL] }
public void testHasRawClassWithSameClass() { [EOL] JavaType javaType = new SimpleType(String.class); [EOL] assertTrue(javaType.hasRawClass(String.class)); [EOL] }
public void testHasRawClassWithDifferentClass() { [EOL] JavaType javaType = new SimpleType(String.class); [EOL] assertFalse(javaType.hasRawClass(Integer.class)); [EOL] }
public void testIsConcreteWithNonConcreteClass() { [EOL] _class = NonConcreteClass.class; // Replace NonConcreteClass with an actual non-concrete class [EOL] boolean result = isConcrete(); [EOL] assertFalse(result); [EOL] }
public void testIsConcreteWithConcreteClass() { [EOL] _class = ConcreteClass.class; // Replace ConcreteClass with an actual concrete class [EOL] boolean result = isConcrete(); [EOL] assertTrue(result); [EOL] }
public void testIsConcreteWithPrimitiveType() { [EOL] _class = int.class; // Example with a primitive type [EOL] boolean result = isConcrete(); [EOL] assertTrue(result); [EOL] }
public void testIsArrayType() { [EOL] ExtendedClass testInstance = new ExtendedClass(); [EOL] boolean result = testInstance.isArrayType(); [EOL] assert !result; // isArrayType() is expected to return false [EOL] }
public void testIsEnumType_EnumClass() { [EOL] JavaType javaType = TypeFactory.defaultInstance().constructType(MyEnum.class); [EOL] assertTrue(javaType.isEnumType()); [EOL] }
public void testIsEnumType_NonEnumClass() { [EOL] JavaType javaType = TypeFactory.defaultInstance().constructType(String.class); [EOL] assertFalse(javaType.isEnumType()); [EOL] }
public void testIsInterface_WhenClassIsInterface_ShouldReturnTrue() { [EOL] Class<?> mockClass = mock(Class.class); [EOL] when(mockClass.isInterface()).thenReturn(true); [EOL] JavaType javaType = new SimpleType(mockClass); [EOL] boolean result = javaType.isInterface(); [EOL] assertTrue(result); [EOL] }
public void testIsInterface_WhenClassIsNotInterface_ShouldReturnFalse() { [EOL] Class<?> mockClass = mock(Class.class); [EOL] when(mockClass.isInterface()).thenReturn(false); [EOL] JavaType javaType = new SimpleType(mockClass); [EOL] boolean result = javaType.isInterface(); [EOL] assertFalse(result); [EOL] }
public void testIsPrimitiveWithPrimitiveClass() { [EOL] JavaType javaType = new SimpleType(int.class); [EOL] boolean result = javaType.isPrimitive(); [EOL] assert result : "Expected primitive type to be recognized as primitive"; [EOL] }
public void testIsPrimitiveWithNonPrimitiveClass() { [EOL] JavaType javaType = new SimpleType(String.class); [EOL] boolean result = javaType.isPrimitive(); [EOL] assert !result : "Expected non-primitive type to not be recognized as primitive"; [EOL] }
public void testIsFinalWithFinalClass() { [EOL] Class<?> finalClass = java.lang.String.class; // String is a final class [EOL] BeanDescription beanDesc = new BasicBeanDescription(null, null, finalClass); [EOL] boolean result = beanDesc.isFinal(); [EOL] assertTrue(result); [EOL] }
public void testIsFinalWithNonFinalClass() { [EOL] Class<?> nonFinalClass = java.lang.Object.class; // Object is not a final class [EOL] BeanDescription beanDesc = new BasicBeanDescription(null, null, nonFinalClass); [EOL] boolean result = beanDesc.isFinal(); [EOL] assertFalse(result); [EOL] }
public void testUseStaticType_True() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] SerializationConfig config = mapper.getSerializationConfig().with(Feature.USE_STATIC_TYPING); [EOL] assertTrue(config.useStaticType()); [EOL] }
public void testUseStaticType_False() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] SerializationConfig config = mapper.getSerializationConfig().without(Feature.USE_STATIC_TYPING); [EOL] assertFalse(config.useStaticType()); [EOL] }
public void testGetContentTypeReturnsNull() { [EOL] MyClass instance = new MyClass(); [EOL] JavaType result = instance.getContentType(); [EOL] assertNull(result); [EOL] }
public void testAssertSubclassWithAssignableClasses() { [EOL] Class<?> superClass = java.util.ArrayList.class; [EOL] Class<?> subclass = java.util.List.class; [EOL] _assertSubclass(subclass, superClass); [EOL] } [EOL] public void testAssertSubclassWithNonAssignableClasses() { [EOL] try { [EOL] Class<?> superClass = java.util.List.class; [EOL] Class<?> subclass = java.util.ArrayList.class; [EOL] _assertSubclass(subclass, superClass); [EOL] fail("Expected IllegalArgumentException not thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Class java.util.ArrayList is not assignable to java.util.List", e.getMessage()); [EOL] } [EOL] }
public void testAsBooleanWithTrue() { [EOL] JsonNode node = new BooleanNode(true); [EOL] boolean result = node.asBoolean(false); [EOL] assert result == true; [EOL] } [EOL] public void testAsBooleanWithFalse() { [EOL] JsonNode node = new BooleanNode(false); [EOL] boolean result = node.asBoolean(true); [EOL] assert result == false; [EOL] } [EOL] public void testAsBooleanWithNullValue() { [EOL] JsonNode node = new NullNode(); [EOL] boolean result = node.asBoolean(true); [EOL] assert result == true; [EOL] } [EOL] public void testAsBooleanWithDefaultValue() { [EOL] JsonNode node = new TextNode("not a boolean"); [EOL] boolean result = node.asBoolean(true); [EOL] assert result == true; [EOL] }
public void testContainerSerializerConstructor() { [EOL] Class<?> t = Object.class; // Use Object.class as a placeholder for the actual type parameter [EOL] ContainerSerializer<?> serializer = new ContainerSerializer<Object>(t); [EOL] assertNotNull(serializer); [EOL] }
protected ContainerSerializer(Class<?> t, boolean dummy) { [EOL] super(t, dummy); [EOL] }
protected ContainerSerializer<?> createContainerSerializerInstance(Class<?> handledType) { [EOL] return new ContainerSerializer<Object>(handledType) { [EOL] @Override [EOL] public JavaType getContentType() { [EOL] return null; [EOL] } [EOL] @Override [EOL] public JsonSerializer<?> getContentSerializer() { [EOL] return null; [EOL] } [EOL] @Override [EOL] public boolean hasSingleElement(Object value) { [EOL] return false; [EOL] } [EOL] @Override [EOL] protected ContainerSerializer<?> _withValueTypeSerializer(TypeSerializer vts) { [EOL] return null; [EOL] } [EOL] @Override [EOL] public void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException { [EOL] } [EOL] @Override [EOL] public void serializeWithType(Object value, JsonGenerator gen, SerializerProvider provider, TypeSerializer typeSer) throws IOException { [EOL] } [EOL] }; [EOL] } [EOL] public void testContainerSerializerCopyConstructor() { [EOL] Class<?> handledType = List.class; [EOL] ContainerSerializer<?> original = createContainerSerializerInstance(handledType); [EOL] ContainerSerializer<?> copy = new ContainerSerializer<Object>(original) { [EOL] @Override [EOL] public JavaType getContentType() { [EOL] return null; [EOL] } [EOL] @Override [EOL] public JsonSerializer<?> getContentSerializer() { [EOL] return null; [EOL] } [EOL] @Override [EOL] public boolean hasSingleElement(Object value) { [EOL] return false; [EOL] } [EOL] @Override [EOL] protected ContainerSerializer<?> _withValueTypeSerializer(TypeSerializer vts) { [EOL] return null; [EOL] } [EOL] @Override [EOL] public void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException { [EOL] } [EOL] @Override [EOL] public void serializeWithType(Object value, JsonGenerator gen, SerializerProvider provider, TypeSerializer typeSer) throws IOException { [EOL] } [EOL] }; [EOL] assertNotNull(copy); [EOL] assertEquals(handledType, copy.handledType()); [EOL] }
public void testHasContentTypeAnnotationWithNullProperty() { [EOL] SerializerProvider provider = createMockSerializerProvider(); [EOL] boolean result = hasContentTypeAnnotation(provider, null); [EOL] assertFalse(result); [EOL] } [EOL] public void testHasContentTypeAnnotationWithNullIntrospector() { [EOL] SerializerProvider provider = createMockSerializerProviderWithNullIntrospector(); [EOL] BeanProperty property = createMockBeanProperty(); [EOL] boolean result = hasContentTypeAnnotation(provider, property); [EOL] assertFalse(result); [EOL] } [EOL] public void testHasContentTypeAnnotationWithNonNullIntrospectorAndContentType() { [EOL] SerializerProvider provider = createMockSerializerProvider(); [EOL] BeanProperty property = createMockBeanPropertyWithContentType(); [EOL] boolean result = hasContentTypeAnnotation(provider, property); [EOL] assertTrue(result); [EOL] } [EOL] public void testHasContentTypeAnnotationWithNonNullIntrospectorAndNoContentType() { [EOL] SerializerProvider provider = createMockSerializerProvider(); [EOL] BeanProperty property = createMockBeanPropertyWithoutContentType(); [EOL] boolean result = hasContentTypeAnnotation(provider, property); [EOL] assertFalse(result); [EOL] }

public void testPropertyBasedObjectIdGeneratorWithValidScope() { [EOL] Class<?> scope = Object.class; [EOL] PropertyBasedObjectIdGenerator generator = new PropertyBasedObjectIdGenerator(scope); [EOL] assertNotNull(generator); [EOL] assertEquals(Object.class, generator.getScope()); [EOL] }
public void testKeyWithNull() { [EOL] ObjectIdGenerator<?> generator = new ObjectIdGenerator<Object>() { [EOL] @Override [EOL] public Class<?> getScope() { [EOL] return Object.class; [EOL] } [EOL] @Override [EOL] public Object generateId(Object forPojo) { [EOL] return null; [EOL] } [EOL] @Override [EOL] public ObjectIdGenerator<Object> forScope(Class<?> scope) { [EOL] return null; [EOL] } [EOL] @Override [EOL] public ObjectIdGenerator<Object> newForSerialization(Object context) { [EOL] return null; [EOL] } [EOL] @Override [EOL] public com.fasterxml.jackson.annotation.ObjectIdGenerator.IdKey key(Object key) { [EOL] return new IdKey(getClass(), _scope, key); [EOL] } [EOL] @Override [EOL] public boolean canUseFor(ObjectIdGenerator<?> gen) { [EOL] return false; [EOL] } [EOL] }; [EOL] ObjectIdGenerator.IdKey idKey = generator.key(null); [EOL] assertNull(idKey.key); [EOL] }
public void testKeyWithNonNull() { [EOL] ObjectIdGenerator<?> generator = new ObjectIdGenerator<Object>() { [EOL] @Override [EOL] public Class<?> getScope() { [EOL] return Object.class; [EOL] } [EOL] @Override [EOL] public Object generateId(Object forPojo) { [EOL] return null; [EOL] } [EOL] @Override [EOL] public ObjectIdGenerator<Object> forScope(Class<?> scope) { [EOL] return null; [EOL] } [EOL] @Override [EOL] public ObjectIdGenerator<Object> newForSerialization(Object context) { [EOL] return null; [EOL] } [EOL] @Override [EOL] public com.fasterxml.jackson.annotation.ObjectIdGenerator.IdKey key(Object key) { [EOL] return new IdKey(getClass(), _scope, key); [EOL] } [EOL] @Override [EOL] public boolean canUseFor(ObjectIdGenerator<?> gen) { [EOL] return false; [EOL] } [EOL] }; [EOL] Object nonNullKey = new Object(); [EOL] ObjectIdGenerator.IdKey idKey = generator.key(nonNullKey); [EOL] assertSame(nonNullKey, idKey.key); [EOL] }
public void testDefaultTypeResolverBuilderWithNull() { [EOL] DefaultTypeResolverBuilder builder = new DefaultTypeResolverBuilder(null); [EOL] assertNull(builder._appliesFor); [EOL] }
public void testDefaultTypeResolverBuilderWithNonNull() { [EOL] DefaultTypeResolverBuilder builder = new DefaultTypeResolverBuilder(DefaultTyping.NON_CONCRETE_AND_ARRAYS); [EOL] assertEquals(DefaultTyping.NON_CONCRETE_AND_ARRAYS, builder._appliesFor); [EOL] }
public void testBuildTypeSerializerWithUseForTypeTrue() { [EOL] SerializationConfig config = new SerializationConfig(); [EOL] JavaType baseType = new JavaType(); [EOL] Collection<NamedType> subtypes = new ArrayList<>(); [EOL] setUseForTypeReturnValue(true); [EOL] TypeSerializer result = buildTypeSerializer(config, baseType, subtypes); [EOL] assertNotNull(result); [EOL] }
public void testBuildTypeSerializerWithUseForTypeFalse() { [EOL] SerializationConfig config = new SerializationConfig(); [EOL] JavaType baseType = new JavaType(); [EOL] Collection<NamedType> subtypes = new ArrayList<>(); [EOL] setUseForTypeReturnValue(false); [EOL] TypeSerializer result = buildTypeSerializer(config, baseType, subtypes); [EOL] assertNull(result); [EOL] }
public void testUseForTypeWithNonConcreteAndArrays() { [EOL] JavaType arrayType = createArrayType(); // This should be an array type [EOL] boolean result = useForType(arrayType); [EOL] assertTrue(result); // Assuming the logic expects true for array types [EOL] }
public void testUseForTypeWithObjectAndNonConcrete() { [EOL] JavaType objectType = createJavaType(Object.class); // This should represent Object class [EOL] boolean result = useForType(objectType); [EOL] assertTrue(result); // Assuming the logic expects true for Object class [EOL] JavaType nonConcreteType = createNonConcreteType(); // This should be a non-concrete type [EOL] result = useForType(nonConcreteType); [EOL] assertTrue(result); // Assuming the logic expects true for non-concrete types [EOL] }
public void testUseForTypeWithNonFinal() { [EOL] JavaType nonFinalType = createNonFinalType(); // This should be a non-final type [EOL] boolean result = useForType(nonFinalType); [EOL] assertTrue(result); // Assuming the logic expects true for non-final types [EOL] }
public void testUseForTypeWithDefaultCase() { [EOL] JavaType someOtherType = createOtherType(); // This should not be Object class or an array [EOL] boolean result = useForType(someOtherType); [EOL] assertFalse(result); // Assuming the logic expects false for types other than Object class [EOL] }
public void testObjectMapperWithNullJsonFactory() { [EOL] ObjectMapper mapper = new ObjectMapper((JsonFactory) null); [EOL] assertNull(mapper.getFactory()); [EOL] }
public void testObjectMapperWithNonNullJsonFactory() { [EOL] JsonFactory jsonFactory = new JsonFactory(); [EOL] ObjectMapper mapper = new ObjectMapper(jsonFactory); [EOL] assertNotNull(mapper.getFactory()); [EOL] assertSame(jsonFactory, mapper.getFactory()); [EOL] }
public void testObjectMapperCopyConstructor() { [EOL] ObjectMapper original = new ObjectMapper(); [EOL] ObjectMapper copy = new ObjectMapper(original); [EOL] assertNotSame(original.getFactory(), copy.getFactory()); [EOL] assertNotSame(original.getSerializationConfig(), copy.getSerializationConfig()); [EOL] assertNotSame(original.getDeserializationConfig(), copy.getDeserializationConfig()); [EOL] assertNotSame(original.getSerializerProvider(), copy.getSerializerProvider()); [EOL] assertNotSame(original.getDeserializationContext(), copy.getDeserializationContext()); [EOL] assertNotSame(original.getSerializerFactory(), copy.getSerializerFactory()); [EOL] assertNotSame(original.getTypeFactory(), copy.getTypeFactory()); [EOL] assertNotSame(original.getSubtypeResolver(), copy.getSubtypeResolver()); [EOL] assertNotNull(copy.getFactory().getCodec()); [EOL] }
public void testObjectMapperWithNullJsonFactory() { [EOL] ObjectMapper mapper = new ObjectMapper(null, null, null); [EOL] assertNotNull(mapper); [EOL] assertTrue(mapper.getFactory() instanceof MappingJsonFactory); [EOL] assertNotNull(mapper.getSerializationConfig()); [EOL] assertNotNull(mapper.getDeserializationConfig()); [EOL] assertTrue(mapper.getSerializerProvider() instanceof DefaultSerializerProvider); [EOL] assertTrue(mapper.getDeserializationContext() instanceof DefaultDeserializationContext); [EOL] }
public void testObjectMapperWithNonNullJsonFactoryAndNullCodec() { [EOL] JsonFactory jsonFactory = new JsonFactory(); [EOL] assertNull(jsonFactory.getCodec()); [EOL] ObjectMapper mapper = new ObjectMapper(jsonFactory, null, null); [EOL] assertNotNull(mapper); [EOL] assertSame(jsonFactory, mapper.getFactory()); [EOL] assertSame(mapper, jsonFactory.getCodec()); [EOL] assertNotNull(mapper.getSerializationConfig()); [EOL] assertNotNull(mapper.getDeserializationConfig()); [EOL] assertTrue(mapper.getSerializerProvider() instanceof DefaultSerializerProvider); [EOL] assertTrue(mapper.getDeserializationContext() instanceof DefaultDeserializationContext); [EOL] }
public void testObjectMapperWithNonNullJsonFactoryAndNonNullCodec() { [EOL] JsonFactory jsonFactory = new JsonFactory(); [EOL] ObjectMapper codec = new ObjectMapper(); [EOL] jsonFactory.setCodec(codec); [EOL] assertNotNull(jsonFactory.getCodec()); [EOL] ObjectMapper mapper = new ObjectMapper(jsonFactory, null, null); [EOL] assertNotNull(mapper); [EOL] assertSame(jsonFactory, mapper.getFactory()); [EOL] assertSame(codec, jsonFactory.getCodec()); [EOL] assertNotNull(mapper.getSerializationConfig()); [EOL] assertNotNull(mapper.getDeserializationConfig()); [EOL] assertTrue(mapper.getSerializerProvider() instanceof DefaultSerializerProvider); [EOL] assertTrue(mapper.getDeserializationContext() instanceof DefaultDeserializationContext); [EOL] }
public void testCopy() { [EOL] ObjectMapper original = new ObjectMapper(); [EOL] ObjectMapper copy = original.copy(); [EOL] assertNotNull(copy); [EOL] assertNotSame(original, copy); [EOL] }
public void testCopyWithInvalidClass() { [EOL] ObjectMapper original = new ObjectMapper() { [EOL] @Override [EOL] public ObjectMapper copy() { [EOL] _checkInvalidCopy(ObjectMapper.class); [EOL] return new ObjectMapper(this); [EOL] } [EOL] }; [EOL] try { [EOL] original.copy(); [EOL] fail("Should not be able to copy with invalid class"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testCheckInvalidCopyWithCorrectClass() { [EOL] MyClass instance = new MyClass(); [EOL] try { [EOL] instance._checkInvalidCopy(MyClass.class); [EOL] } catch (IllegalStateException e) { [EOL] fail("Should not throw an exception for the correct class"); [EOL] } [EOL] }
public void testCheckInvalidCopyWithIncorrectClass() { [EOL] MyClass instance = new MyClass(); [EOL] try { [EOL] instance._checkInvalidCopy(OtherClass.class); [EOL] fail("Should have thrown an exception for the incorrect class"); [EOL] } catch (IllegalStateException e) { [EOL] assertEquals("Failed copy(): " + instance.getClass().getName() + " (version: " + instance.version() + ") does not override copy(); it has to", e.getMessage()); [EOL] } [EOL] }
public void testRegisterModuleWithNullName() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] Module module = new Module() { [EOL] @Override [EOL] public String getModuleName() { [EOL] return null; [EOL] } [EOL] @Override [EOL] public Version version() { [EOL] return new Version(1, 0, 0, null, null, null); [EOL] } [EOL] @Override [EOL] public void setupModule(SetupContext context) { [EOL] } [EOL] }; [EOL] try { [EOL] mapper.registerModule(module); [EOL] fail("Expected IllegalArgumentException for null module name"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Module without defined name", e.getMessage()); [EOL] } [EOL] }
public void testRegisterModuleWithNullVersion() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] Module module = new Module() { [EOL] @Override [EOL] public String getModuleName() { [EOL] return "TestModule"; [EOL] } [EOL] @Override [EOL] public Version version() { [EOL] return null; [EOL] } [EOL] @Override [EOL] public void setupModule(SetupContext context) { [EOL] } [EOL] }; [EOL] try { [EOL] mapper.registerModule(module); [EOL] fail("Expected IllegalArgumentException for null module version"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Module without defined version", e.getMessage()); [EOL] } [EOL] }
public void testRegisterModuleSuccessfully() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] Module module = new Module() { [EOL] @Override [EOL] public String getModuleName() { [EOL] return "TestModule"; [EOL] } [EOL] @Override [EOL] public Version version() { [EOL] return new Version(1, 0, 0, null, null, null); [EOL] } [EOL] @Override [EOL] public void setupModule(SetupContext context) { [EOL] } [EOL] }; [EOL] ObjectMapper result = mapper.registerModule(module); [EOL] assertSame("Expected the same ObjectMapper instance to be returned", mapper, result); [EOL] }
public void testSetSerializerFactoryWithNonNull() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] SerializerFactory factory = new SerializerFactory() { [EOL] }; [EOL] ObjectMapper result = mapper.setSerializerFactory(factory); [EOL] assertNotNull(result); [EOL] assertSame(factory, result.getSerializerFactory()); [EOL] }
public void testSetSerializerFactoryWithNull() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] ObjectMapper result = mapper.setSerializerFactory(null); [EOL] assertNotNull(result); [EOL] assertNull(result.getSerializerFactory()); [EOL] }
public void testAddMixInAnnotationsWithNonNullClasses() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] Class<?> target = Object.class; [EOL] Class<?> mixinSource = String.class; [EOL] mapper.addMixInAnnotations(target, mixinSource); [EOL] assertSame(mixinSource, mapper.findMixInClassFor(target)); [EOL] }
public void testAddMixInAnnotationsWithNullTarget() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] Class<?> mixinSource = String.class; [EOL] try { [EOL] mapper.addMixInAnnotations(null, mixinSource); [EOL] fail("Should not allow null target class"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testAddMixInAnnotationsWithNullMixinSource() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] Class<?> target = Object.class; [EOL] mapper.addMixInAnnotations(target, null); [EOL] assertNull(mapper.findMixInClassFor(target)); [EOL] }
public void testSetAnnotationIntrospectorWithNonNull() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] AnnotationIntrospector introspector = new NopAnnotationIntrospector(); [EOL] ObjectMapper result = mapper.setAnnotationIntrospector(introspector); [EOL] assertSame(result, mapper); [EOL] assertSame(introspector, result.getSerializationConfig().getAnnotationIntrospector()); [EOL] assertSame(introspector, result.getDeserializationConfig().getAnnotationIntrospector()); [EOL] }
public void testSetAnnotationIntrospectorWithNull() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] ObjectMapper result = mapper.setAnnotationIntrospector(null); [EOL] assertSame(result, mapper); [EOL] assertNull(result.getSerializationConfig().getAnnotationIntrospector()); [EOL] assertNull(result.getDeserializationConfig().getAnnotationIntrospector()); [EOL] }
public void testSetPropertyNamingStrategyWithNull() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] mapper.setPropertyNamingStrategy(null); [EOL] assertNull(mapper.getSerializationConfig().getPropertyNamingStrategy()); [EOL] assertNull(mapper.getDeserializationConfig().getPropertyNamingStrategy()); [EOL] }
public void testSetPropertyNamingStrategyWithNonNull() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] PropertyNamingStrategy strategy = new PropertyNamingStrategy.SnakeCaseStrategy(); [EOL] mapper.setPropertyNamingStrategy(strategy); [EOL] assertEquals(strategy, mapper.getSerializationConfig().getPropertyNamingStrategy()); [EOL] assertEquals(strategy, mapper.getDeserializationConfig().getPropertyNamingStrategy()); [EOL] }
public void testEnableDefaultTypingAsPropertyWithNonNullPropertyName() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] String propertyName = "type"; [EOL] mapper.enableDefaultTypingAsProperty(ObjectMapper.DefaultTyping.OBJECT_AND_NON_CONCRETE, propertyName); [EOL] } [EOL] public void testEnableDefaultTypingAsPropertyWithNullPropertyName() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] String propertyName = null; [EOL] try { [EOL] mapper.enableDefaultTypingAsProperty(ObjectMapper.DefaultTyping.OBJECT_AND_NON_CONCRETE, propertyName); [EOL] fail("Should not allow null property name"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testDisableDefaultTyping() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] mapper.enableDefaultTyping(); // Assuming default typing is not enabled by default [EOL] assertNotNull(mapper.getDefaultTyping()); // Assuming there's a method to get the default typing [EOL] mapper.disableDefaultTyping(); [EOL] assertNull(mapper.getDefaultTyping()); [EOL] }
public void testSetDefaultTypingWithNonNullTyper() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] TypeResolverBuilder<?> typer = new DefaultTypeResolverBuilder(ObjectMapper.DefaultTyping.NON_FINAL); [EOL] ObjectMapper result = mapper.setDefaultTyping(typer); [EOL] assertNotNull(result); [EOL] assertSame(mapper, result); [EOL] assertNotNull(result.getSerializationConfig().getDefaultTyper()); [EOL] assertNotNull(result.getDeserializationConfig().getDefaultTyper()); [EOL] }
public void testSetDefaultTypingWithNullTyper() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] ObjectMapper result = mapper.setDefaultTyping(null); [EOL] assertNotNull(result); [EOL] assertSame(mapper, result); [EOL] assertNull(result.getSerializationConfig().getDefaultTyper()); [EOL] assertNull(result.getDeserializationConfig().getDefaultTyper()); [EOL] }
public void testSetFiltersWithNonNullFilterProvider() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] FilterProvider filters = new SimpleFilterProvider(); [EOL] mapper.setFilters(filters); [EOL] SerializationConfig config = mapper.getSerializationConfig(); [EOL] assertNotNull(config); [EOL] assertSame(filters, config.getFilterProvider()); [EOL] } [EOL] public void testSetFiltersWithNullFilterProvider() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] mapper.setFilters(null); [EOL] SerializationConfig config = mapper.getSerializationConfig(); [EOL] assertNotNull(config); [EOL] assertNull(config.getFilterProvider()); [EOL] }
public void testSetHandlerInstantiatorWithNonNull() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] HandlerInstantiator hi = new HandlerInstantiator() {}; [EOL] Object result = mapper.setHandlerInstantiator(hi); [EOL] assertSame(mapper, result); [EOL] assertNotNull(mapper.getDeserializationConfig().getHandlerInstantiator()); [EOL] assertNotNull(mapper.getSerializationConfig().getHandlerInstantiator()); [EOL] }
public void testSetHandlerInstantiatorWithNull() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] Object result = mapper.setHandlerInstantiator(null); [EOL] assertSame(mapper, result); [EOL] assertNull(mapper.getDeserializationConfig().getHandlerInstantiator()); [EOL] assertNull(mapper.getSerializationConfig().getHandlerInstantiator()); [EOL] }
public void testConfigureEnableFeature() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] MapperFeature feature = MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES; [EOL] boolean state = true; [EOL] ObjectMapper result = mapper.configure(feature, state); [EOL] assertTrue(result.getSerializationConfig().hasFeature(feature)); [EOL] assertTrue(result.getDeserializationConfig().hasFeature(feature)); [EOL] }
public void testConfigureDisableFeature() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] MapperFeature feature = MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES; [EOL] boolean state = false; [EOL] ObjectMapper result = mapper.configure(feature, state); [EOL] assertFalse(result.getSerializationConfig().hasFeature(feature)); [EOL] assertFalse(result.getDeserializationConfig().hasFeature(feature)); [EOL] }
public void testConfigureEnableDeserializationFeature() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] DeserializationFeature feature = DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES; [EOL] boolean originalState = mapper.getDeserializationConfig().isEnabled(feature); [EOL] mapper.configure(feature, !originalState); [EOL] boolean newState = mapper.getDeserializationConfig().isEnabled(feature); [EOL] assertNotEquals(originalState, newState); [EOL] }
public void testConfigureDisableDeserializationFeature() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] DeserializationFeature feature = DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES; [EOL] boolean originalState = mapper.getDeserializationConfig().isEnabled(feature); [EOL] mapper.configure(feature, originalState); [EOL] boolean newState = mapper.getDeserializationConfig().isEnabled(feature); [EOL] assertEquals(originalState, newState); [EOL] }
public void testEnableWithNullFeatures() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] ObjectMapper result = mapper.enable((MapperFeature) null); [EOL] assertNotNull(result); [EOL] assertSame(mapper, result); [EOL] }
public void testEnableWithEmptyFeatures() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] ObjectMapper result = mapper.enable(new MapperFeature[0]); [EOL] assertNotNull(result); [EOL] assertSame(mapper, result); [EOL] }
public void testEnableWithSingleFeature() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] ObjectMapper result = mapper.enable(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES); [EOL] assertTrue(result.getDeserializationConfig().isEnabled(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES)); [EOL] assertTrue(result.getSerializationConfig().isEnabled(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES)); [EOL] }
public void testEnableWithMultipleFeatures() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] ObjectMapper result = mapper.enable(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES, MapperFeature.AUTO_DETECT_FIELDS); [EOL] assertTrue(result.getDeserializationConfig().isEnabled(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES)); [EOL] assertTrue(result.getSerializationConfig().isEnabled(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES)); [EOL] assertTrue(result.getDeserializationConfig().isEnabled(MapperFeature.AUTO_DETECT_FIELDS)); [EOL] assertTrue(result.getSerializationConfig().isEnabled(MapperFeature.AUTO_DETECT_FIELDS)); [EOL] }
public void testEnableDeserializationFeature() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] DeserializationFeature feature = DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES; [EOL] assertFalse(mapper.getDeserializationConfig().isEnabled(feature)); [EOL] mapper.enable(feature); [EOL] assertTrue(mapper.getDeserializationConfig().isEnabled(feature)); [EOL] }
public void testEnableDeserializationFeatureAlreadyEnabled() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] DeserializationFeature feature = DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES; [EOL] mapper.enable(feature); [EOL] assertTrue(mapper.getDeserializationConfig().isEnabled(feature)); [EOL] mapper.enable(feature); [EOL] assertTrue(mapper.getDeserializationConfig().isEnabled(feature)); [EOL] }
public void testDisableDeserializationFeature() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] DeserializationFeature feature = DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES; [EOL] assertTrue(mapper.getDeserializationConfig().isEnabled(feature)); [EOL] mapper.disable(feature); [EOL] assertFalse(mapper.getDeserializationConfig().isEnabled(feature)); [EOL] }
public void testDisableAlreadyDisabledDeserializationFeature() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] DeserializationFeature feature = DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES; [EOL] mapper.disable(feature); [EOL] assertFalse(mapper.getDeserializationConfig().isEnabled(feature)); [EOL] mapper.disable(feature); [EOL] assertFalse(mapper.getDeserializationConfig().isEnabled(feature)); [EOL] }
public void testEnableSerializationFeature() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] SerializationFeature feature = SerializationFeature.INDENT_OUTPUT; [EOL] assertFalse(mapper.getSerializationConfig().isEnabled(feature)); [EOL] mapper.enable(feature); [EOL] assertTrue(mapper.getSerializationConfig().isEnabled(feature)); [EOL] }
public void testIsEnabledWithEnabledFeature() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] mapper.configure(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES, true); [EOL] assertTrue(mapper.isEnabled(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES)); [EOL] }
public void testIsEnabledWithDisabledFeature() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] mapper.configure(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES, false); [EOL] assertFalse(mapper.isEnabled(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES)); [EOL] }
public void testIsEnabledWithFeatureEnabled() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] mapper.enable(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS); [EOL] assertTrue(mapper.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)); [EOL] }
public void testIsEnabledWithFeatureDisabled() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] mapper.disable(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS); [EOL] assertFalse(mapper.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)); [EOL] }
public void testReadTreeWithValidInputStream() throws IOException { [EOL] InputStream in = new ByteArrayInputStream("{\"key\":\"value\"}".getBytes()); [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] JsonNode result = mapper.readTree(in); [EOL] assertNotNull(result); [EOL] assertEquals("value", result.get("key").asText()); [EOL] } [EOL] public void testReadTreeWithEmptyInputStream() throws IOException { [EOL] InputStream in = new ByteArrayInputStream("{}".getBytes()); [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] JsonNode result = mapper.readTree(in); [EOL] assertNotNull(result); [EOL] assertTrue(result.isObject()); [EOL] assertEquals(0, result.size()); [EOL] } [EOL] public void testReadTreeWithNullInputStream() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] InputStream in = null; [EOL] try { [EOL] mapper.readTree(in); [EOL] fail("Expected IOException"); [EOL] } catch (IOException e) { [EOL] } [EOL] } [EOL] public void testReadTreeWithClosedInputStream() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] InputStream in = new ByteArrayInputStream("{\"key\":\"value\"}".getBytes()); [EOL] try { [EOL] in.close(); [EOL] mapper.readTree(in); [EOL] fail("Expected IOException"); [EOL] } catch (IOException e) { [EOL] } [EOL] }
public void testReadTreeWithValidReader() throws IOException, JsonProcessingException { [EOL] Reader reader = new StringReader("{\"key\":\"value\"}"); [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] JsonNode result = mapper.readTree(reader); [EOL] assertNotNull(result); [EOL] assertTrue(result.isObject()); [EOL] assertEquals("value", result.get("key").asText()); [EOL] }
public void testReadTreeWithNullReader() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] try { [EOL] mapper.readTree((Reader) null); [EOL] fail("Expected IOException"); [EOL] } catch (IOException e) { [EOL] } [EOL] }
public void testReadTreeWithEmptyReader() throws IOException, JsonProcessingException { [EOL] Reader reader = new StringReader(""); [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] JsonNode result = mapper.readTree(reader); [EOL] assertTrue(result.isNull()); [EOL] }
public void testReadTreeWithValidJson() throws IOException { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] String validJson = "{\"key\":\"value\"}"; [EOL] JsonNode result = mapper.readTree(validJson); [EOL] assertNotNull(result); [EOL] assertTrue(result.isObject()); [EOL] assertEquals("value", result.get("key").asText()); [EOL] }
public void testReadTreeWithInvalidJson() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] String invalidJson = "{key:\"value\"}"; [EOL] try { [EOL] mapper.readTree(invalidJson); [EOL] fail("Expected IOException was not thrown"); [EOL] } catch (IOException e) { [EOL] } [EOL] }
public void testReadTreeWithNull() throws IOException { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] JsonNode result = mapper.readTree((String) null); [EOL] assertTrue(result.isNull()); [EOL] }
public void testCanSerializeWithSerializableClass() { [EOL] ObjectMapper objectMapper = new ObjectMapper(); [EOL] boolean result = objectMapper.canSerialize(String.class); [EOL] assertTrue(result); [EOL] }
public void testCanSerializeWithNonSerializableClass() { [EOL] ObjectMapper objectMapper = new ObjectMapper(); [EOL] boolean result = objectMapper.canSerialize(Object.class); [EOL] assertFalse(result); [EOL] }
public void testCanDeserializeWithNonNullType() { [EOL] ObjectMapper objectMapper = new ObjectMapper(); [EOL] JavaType javaType = objectMapper.constructType(String.class); [EOL] boolean result = objectMapper.canDeserialize(javaType); [EOL] assertTrue(result); [EOL] }
public void testCanDeserializeWithNullType() { [EOL] ObjectMapper objectMapper = new ObjectMapper(); [EOL] JavaType javaType = null; [EOL] try { [EOL] objectMapper.canDeserialize(javaType); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testWriterWithView_NullView() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] ObjectWriter writer = mapper.writerWithView(null); [EOL] assertNotNull(writer); [EOL] }
public void testWriterWithView_NonNullView() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] ObjectWriter writer = mapper.writerWithView(SomeViewClass.class); [EOL] assertNotNull(writer); [EOL] assertEquals(SomeViewClass.class, writer.getConfig().getActiveView()); [EOL] }
public void testWriterWithNullFilterProvider() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] ObjectWriter writer = mapper.writer((FilterProvider) null); [EOL] assertNotNull(writer); [EOL] }
public void testWriterWithNonNullFilterProvider() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] SimpleFilterProvider filterProvider = new SimpleFilterProvider(); [EOL] ObjectWriter writer = mapper.writer(filterProvider); [EOL] assertNotNull(writer); [EOL] }
public void testReaderWithViewNonNull() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] Class<?> viewClass = SomeViewClass.class; // Replace with an actual view class [EOL] ObjectReader reader = mapper.readerWithView(viewClass); [EOL] assertNotNull(reader); [EOL] assertEquals(viewClass, reader.getConfig().getActiveView()); [EOL] }
public void testReaderWithViewNull() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] ObjectReader reader = mapper.readerWithView(null); [EOL] assertNotNull(reader); [EOL] assertNull(reader.getConfig().getActiveView()); [EOL] }
public void test_convert_withAssignableTargetType() throws IllegalArgumentException { [EOL] Object fromValue = new String("test"); [EOL] JavaType toValueType = TypeFactory.defaultInstance().constructType(Object.class); [EOL] Object result = _convert(fromValue, toValueType); [EOL] assertSame("The result should be the same as fromValue when targetType is assignable from fromValue", fromValue, result); [EOL] }
public void test_convert_withGenericTargetType() throws IllegalArgumentException { [EOL] Object fromValue = new String("test"); [EOL] JavaType toValueType = TypeFactory.defaultInstance().constructType(List.class); [EOL] Object result = _convert(fromValue, toValueType); [EOL] assertNotNull("The result should not be null for generic target type", result); [EOL] }
public void test_convert_withUnassignableTargetType() throws IllegalArgumentException { [EOL] Object fromValue = new Integer(123); [EOL] JavaType toValueType = TypeFactory.defaultInstance().constructType(String.class); [EOL] try { [EOL] Object result = _convert(fromValue, toValueType); [EOL] fail("Expected IllegalArgumentException for unassignable target type"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void test_convert_withNullValue() throws IllegalArgumentException { [EOL] Object fromValue = null; [EOL] JavaType toValueType = TypeFactory.defaultInstance().constructType(String.class); [EOL] Object result = _convert(fromValue, toValueType); [EOL] assertNull("The result should be null when fromValue is null", result); [EOL] }
public void test_convert_withEndArrayToken() throws IllegalArgumentException { [EOL] Object fromValue = new ArrayList<>(); [EOL] JavaType toValueType = TypeFactory.defaultInstance().constructType(List.class); [EOL] TokenBuffer buf = new TokenBuffer(null); [EOL] buf.writeEndArray(); [EOL] JsonParser jp = buf.asParser(); [EOL] when(_initForReading(jp)).thenReturn(JsonToken.END_ARRAY); [EOL] Object result = _convert(fromValue, toValueType); [EOL] assertNull("The result should be null when JsonToken is END_ARRAY", result); [EOL] }
public void test_convert_withEndObjectToken() throws IllegalArgumentException { [EOL] Object fromValue = new HashMap<>(); [EOL] JavaType toValueType = TypeFactory.defaultInstance().constructType(Map.class); [EOL] TokenBuffer buf = new TokenBuffer(null); [EOL] buf.writeEndObject(); [EOL] JsonParser jp = buf.asParser(); [EOL] when(_initForReading(jp)).thenReturn(JsonToken.END_OBJECT); [EOL] Object result = _convert(fromValue, toValueType); [EOL] assertNull("The result should be null when JsonToken is END_OBJECT", result); [EOL] }
public void testFindRootDeserializerWithCachedDeserializer() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JavaType valueType = mock(JavaType.class); [EOL] JsonDeserializer<Object> expectedDeserializer = mock(JsonDeserializer.class); [EOL] ConcurrentHashMap<JavaType, JsonDeserializer<Object>> rootDeserializers = new ConcurrentHashMap<>(); [EOL] rootDeserializers.put(valueType, expectedDeserializer); [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] mapper._rootDeserializers = rootDeserializers; [EOL] JsonDeserializer<Object> actualDeserializer = mapper._findRootDeserializer(ctxt, valueType); [EOL] assertSame(expectedDeserializer, actualDeserializer); [EOL] }
public void testFindRootDeserializerWithoutCachedDeserializer() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JavaType valueType = mock(JavaType.class); [EOL] JsonDeserializer<Object> expectedDeserializer = mock(JsonDeserializer.class); [EOL] when(ctxt.findRootValueDeserializer(valueType)).thenReturn(expectedDeserializer); [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] mapper._rootDeserializers = new ConcurrentHashMap<>(); [EOL] JsonDeserializer<Object> actualDeserializer = mapper._findRootDeserializer(ctxt, valueType); [EOL] assertSame(expectedDeserializer, actualDeserializer); [EOL] assertTrue(mapper._rootDeserializers.containsKey(valueType)); [EOL] assertSame(expectedDeserializer, mapper._rootDeserializers.get(valueType)); [EOL] }
public void testFindRootDeserializerThrowsException() { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JavaType valueType = mock(JavaType.class); [EOL] when(ctxt.findRootValueDeserializer(valueType)).thenReturn(null); [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] mapper._rootDeserializers = new ConcurrentHashMap<>(); [EOL] Exception exception = assertThrows(JsonMappingException.class, () -> { [EOL] mapper._findRootDeserializer(ctxt, valueType); [EOL] }); [EOL] assertEquals("Can not find a deserializer for type " + valueType, exception.getMessage()); [EOL] }
public void testCanCreateUsingDelegate() { [EOL] YourClass instance = new YourClass(); [EOL] boolean result = instance.canCreateUsingDelegate(); [EOL] assertFalse(result); [EOL] }
public void testBeanAsArrayBuilderDeserializerWithNonNullValues() { [EOL] BeanDeserializerBase delegate = mock(BeanDeserializerBase.class); [EOL] SettableBeanProperty[] ordered = new SettableBeanProperty[0]; [EOL] AnnotatedMethod buildMethod = mock(AnnotatedMethod.class); [EOL] BeanAsArrayBuilderDeserializer deserializer = new BeanAsArrayBuilderDeserializer(delegate, ordered, buildMethod); [EOL] assertNotNull(deserializer); [EOL] assertSame(delegate, deserializer._delegate); [EOL] assertSame(ordered, deserializer._orderedProperties); [EOL] assertSame(buildMethod, deserializer._buildMethod); [EOL] }
public void testBeanAsArrayBuilderDeserializerWithNullValues() { [EOL] BeanDeserializerBase delegate = null; [EOL] SettableBeanProperty[] ordered = null; [EOL] AnnotatedMethod buildMethod = null; [EOL] BeanAsArrayBuilderDeserializer deserializer = new BeanAsArrayBuilderDeserializer(delegate, ordered, buildMethod); [EOL] assertNotNull(deserializer); [EOL] assertNull(deserializer._delegate); [EOL] assertNull(deserializer._orderedProperties); [EOL] assertNull(deserializer._buildMethod); [EOL] }
public void testFinishBuildWithValidBuilder() throws Exception { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object builder = new Object(); [EOL] Method buildMethod = Object.class.getMethod("toString"); [EOL] Field buildMethodField = BuilderBasedDeserializer.class.getDeclaredField("_buildMethod"); [EOL] buildMethodField.setAccessible(true); [EOL] buildMethodField.set(deserializer, new AnnotatedMethod(null, buildMethod, null, null)); [EOL] Object result = deserializer.finishBuild(ctxt, builder); [EOL] assertNotNull(result); [EOL] }
public void testFinishBuildWithInvocationTargetException() throws Exception { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object builder = new Object(); [EOL] Method buildMethod = Object.class.getMethod("toString"); [EOL] InvocationTargetException exception = new InvocationTargetException(new IOException()); [EOL] Method mockMethod = mock(Method.class); [EOL] when(mockMethod.invoke(any())).thenThrow(exception); [EOL] Field buildMethodField = BuilderBasedDeserializer.class.getDeclaredField("_buildMethod"); [EOL] buildMethodField.setAccessible(true); [EOL] buildMethodField.set(deserializer, new AnnotatedMethod(null, mockMethod, null, null)); [EOL] Object result = null; [EOL] try { [EOL] result = deserializer.finishBuild(ctxt, builder); [EOL] } catch (IOException e) { [EOL] } [EOL] assertNull(result); [EOL] }
public void testFinishBuildWithIllegalAccessException() throws Exception { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object builder = new Object(); [EOL] IllegalAccessException illegalAccessException = new IllegalAccessException(); [EOL] Method mockMethod = mock(Method.class); [EOL] when(mockMethod.invoke(any())).thenThrow(illegalAccessException); [EOL] Field buildMethodField = BuilderBasedDeserializer.class.getDeclaredField("_buildMethod"); [EOL] buildMethodField.setAccessible(true); [EOL] buildMethodField.set(deserializer, new AnnotatedMethod(null, mockMethod, null, null)); [EOL] Object result = null; [EOL] try { [EOL] result = deserializer.finishBuild(ctxt, builder); [EOL] } catch (IOException e) { [EOL] } [EOL] assertNull(result); [EOL] }
public void testDeserializeWithNonArrayToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] Object result = deserialize(jp, ctxt); [EOL] assertNotNull(result); [EOL] verify(ctxt, times(1)).handleUnexpectedToken(any(), any()); [EOL] }
public void testDeserializeWithNonVanillaProcessing() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_ARRAY); [EOL] when(_vanillaProcessing).thenReturn(false); [EOL] Object result = deserialize(jp, ctxt); [EOL] assertNotNull(result); [EOL] verify(ctxt, times(1)).handleUnexpectedToken(any(), any()); [EOL] }
public void testDeserializeWithVanillaProcessingAndEndArray() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_ARRAY); [EOL] when(_vanillaProcessing).thenReturn(true); [EOL] when(jp.nextToken()).thenReturn(JsonToken.END_ARRAY); [EOL] Object result = deserialize(jp, ctxt); [EOL] assertNotNull(result); [EOL] verify(ctxt, never()).handleUnexpectedToken(any(), any()); [EOL] }
public void testDeserializeWithVanillaProcessingAndProperties() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] SettableBeanProperty prop = mock(SettableBeanProperty.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_ARRAY); [EOL] when(_vanillaProcessing).thenReturn(true); [EOL] when(jp.nextToken()).thenReturn(JsonToken.VALUE_STRING).thenReturn(JsonToken.END_ARRAY); [EOL] when(_orderedProperties).thenReturn(new SettableBeanProperty[]{prop}); [EOL] when(prop.deserializeSetAndReturn(jp, ctxt, any())).thenReturn(new Object()); [EOL] Object result = deserialize(jp, ctxt); [EOL] assertNotNull(result); [EOL] verify(prop, times(1)).deserializeSetAndReturn(jp, ctxt, any()); [EOL] }
public void testDeserializeWithVanillaProcessingAndNullProperty() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_ARRAY); [EOL] when(_vanillaProcessing).thenReturn(true); [EOL] when(jp.nextToken()).thenReturn(JsonToken.VALUE_STRING).thenReturn(JsonToken.END_ARRAY); [EOL] when(_orderedProperties).thenReturn(new SettableBeanProperty[]{null}); [EOL] Object result = deserialize(jp, ctxt); [EOL] assertNotNull(result); [EOL] verify(jp, times(1)).skipChildren(); [EOL] }
public void testDeserializeWithVanillaProcessingAndIgnoreAllUnknown() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_ARRAY); [EOL] when(_vanillaProcessing).thenReturn(true); [EOL] when(_ignoreAllUnknown).thenReturn(true); [EOL] when(jp.nextToken()).thenReturn(JsonToken.VALUE_STRING).thenReturn(JsonToken.END_ARRAY); [EOL] when(_orderedProperties).thenReturn(new SettableBeanProperty[0]); [EOL] Object result = deserialize(jp, ctxt); [EOL] assertNotNull(result); [EOL] verify(jp, times(1)).skipChildren(); [EOL] }
public void testDeserializeWithVanillaProcessingAndUnexpectedToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_ARRAY); [EOL] when(_vanillaProcessing).thenReturn(true); [EOL] when(_ignoreAllUnknown).thenReturn(false); [EOL] when(jp.nextToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(_orderedProperties).thenReturn(new SettableBeanProperty[0]); [EOL] Exception exception = assertThrows(JsonMappingException.class, () -> { [EOL] deserialize(jp, ctxt); [EOL] }); [EOL] assertEquals("Unexpected JSON values; expected at most 0 properties (in JSON Array)", exception.getMessage()); [EOL] }
public void testDeserializeNonVanillaWithNonStandardCreation() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(_nonStandardCreation).thenReturn(true); [EOL] _deserializeNonVanilla(jp, ctxt); [EOL] verify(_valueInstantiator, never()).createUsingDefault(ctxt); [EOL] }
public void testDeserializeNonVanillaWithStandardCreationAndInjectables() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(_nonStandardCreation).thenReturn(false); [EOL] when(_injectables).isNotNull(); [EOL] Object builder = new Object(); [EOL] when(_valueInstantiator.createUsingDefault(ctxt)).thenReturn(builder); [EOL] _deserializeNonVanilla(jp, ctxt); [EOL] verify(ctxt, atLeastOnce()).findInjectableValue(anyString(), any(), any()); [EOL] }
public void testDeserializeNonVanillaWithStandardCreationAndViewProcessing() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(_nonStandardCreation).thenReturn(false); [EOL] when(_needViewProcesing).thenReturn(true); [EOL] when(ctxt.getActiveView()).thenReturn(Object.class); [EOL] Object builder = new Object(); [EOL] when(_valueInstantiator.createUsingDefault(ctxt)).thenReturn(builder); [EOL] SettableBeanProperty[] props = new SettableBeanProperty[1]; [EOL] props[0] = mock(SettableBeanProperty.class); [EOL] when(_orderedProperties).thenReturn(props); [EOL] when(jp.nextToken()).thenReturn(JsonToken.VALUE_STRING).thenReturn(JsonToken.END_ARRAY); [EOL] _deserializeNonVanilla(jp, ctxt); [EOL] verify(props[0]).deserializeSetAndReturn(jp, ctxt, builder); [EOL] }
public void testDeserializeNonVanillaWithStandardCreationAndIgnoreAllUnknown() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(_nonStandardCreation).thenReturn(false); [EOL] when(_ignoreAllUnknown).thenReturn(true); [EOL] Object builder = new Object(); [EOL] when(_valueInstantiator.createUsingDefault(ctxt)).thenReturn(builder); [EOL] SettableBeanProperty[] props = new SettableBeanProperty[0]; [EOL] when(_orderedProperties).thenReturn(props); [EOL] when(jp.nextToken()).thenReturn(JsonToken.VALUE_STRING).thenReturn(JsonToken.END_ARRAY); [EOL] _deserializeNonVanilla(jp, ctxt); [EOL] verify(ctxt, never()).mappingException(anyString()); [EOL] }
public void testDeserializeNonVanillaWithStandardCreationAndUnknownPropertyException() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(_nonStandardCreation).thenReturn(false); [EOL] when(_ignoreAllUnknown).thenReturn(false); [EOL] Object builder = new Object(); [EOL] when(_valueInstantiator.createUsingDefault(ctxt)).thenReturn(builder); [EOL] SettableBeanProperty[] props = new SettableBeanProperty[0]; [EOL] when(_orderedProperties).thenReturn(props); [EOL] when(jp.nextToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] assertThrows(JsonMappingException.class, () -> _deserializeNonVanilla(jp, ctxt)); [EOL] }
public void testAsBooleanTrue() { [EOL] BooleanNode node = new BooleanNode(true); [EOL] assertTrue(node.asBoolean()); [EOL] }
public void testAsBooleanFalse() { [EOL] BooleanNode node = new BooleanNode(false); [EOL] assertFalse(node.asBoolean()); [EOL] }
public void testSerializeWithType_NullValue() throws IOException, JsonGenerationException { [EOL] final JsonSerializer<Object> serializer = new TestSerializer(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] TypeSerializer typeSer = mock(TypeSerializer.class); [EOL] serializer.serializeWithType(null, jgen, provider, typeSer); [EOL] verify(jgen, never()).writeStartObject(); [EOL] verify(jgen, never()).writeFieldName(anyString()); [EOL] verify(jgen, never()).writeString(anyString()); [EOL] verify(jgen, never()).writeEndObject(); [EOL] }
public void testSerializeWithType_NonNullValue() throws IOException, JsonGenerationException { [EOL] final JsonSerializer<Object> serializer = new TestSerializer(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] TypeSerializer typeSer = mock(TypeSerializer.class); [EOL] Object value = new Object(); [EOL] serializer.serializeWithType(value, jgen, provider, typeSer); [EOL] verify(jgen).writeStartObject(); [EOL] verify(jgen).writeFieldName(anyString()); [EOL] verify(jgen).writeString(anyString()); [EOL] verify(jgen).writeEndObject(); [EOL] }
public void testIsDefaultKeyDeserializerWithNonNullKeyDeserializerAndJacksonStdImplAnnotation() { [EOL] KeyDeserializer keyDeser = new KeyDeserializer() { [EOL] @JacksonStdImpl [EOL] public Object deserializeKey(String key, DeserializationContext ctxt) throws IOException { [EOL] return null; [EOL] } [EOL] }; [EOL] boolean result = isDefaultKeyDeserializer(keyDeser); [EOL] assertTrue(result); [EOL] }
public void testIsDefaultKeyDeserializerWithNonNullKeyDeserializerWithoutJacksonStdImplAnnotation() { [EOL] KeyDeserializer keyDeser = new KeyDeserializer() { [EOL] public Object deserializeKey(String key, DeserializationContext ctxt) throws IOException { [EOL] return null; [EOL] } [EOL] }; [EOL] boolean result = isDefaultKeyDeserializer(keyDeser); [EOL] assertFalse(result); [EOL] }
public void testIsDefaultKeyDeserializerWithNullKeyDeserializer() { [EOL] KeyDeserializer keyDeser = null; [EOL] boolean result = isDefaultKeyDeserializer(keyDeser); [EOL] assertFalse(result); [EOL] }
public void testParseBooleanPrimitiveWithTrueValue() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_TRUE); [EOL] boolean result = _parseBooleanPrimitive(jp, ctxt); [EOL] assertTrue(result); [EOL] }
public void testParseBooleanPrimitiveWithFalseValue() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_FALSE); [EOL] boolean result = _parseBooleanPrimitive(jp, ctxt); [EOL] assertFalse(result); [EOL] }
public void testParseBooleanPrimitiveWithNullValue() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NULL); [EOL] boolean result = _parseBooleanPrimitive(jp, ctxt); [EOL] assertFalse(result); [EOL] }
public void testParseBooleanPrimitiveWithNonZeroNumber() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); [EOL] when(jp.getNumberType()).thenReturn(NumberType.INT); [EOL] when(jp.getIntValue()).thenReturn(1); [EOL] boolean result = _parseBooleanPrimitive(jp, ctxt); [EOL] assertTrue(result); [EOL] }
public void testParseBooleanPrimitiveWithZeroNumber() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); [EOL] when(jp.getNumberType()).thenReturn(NumberType.INT); [EOL] when(jp.getIntValue()).thenReturn(0); [EOL] boolean result = _parseBooleanPrimitive(jp, ctxt); [EOL] assertFalse(result); [EOL] }
public void testParseBooleanPrimitiveWithTrueString() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("true"); [EOL] boolean result = _parseBooleanPrimitive(jp, ctxt); [EOL] assertTrue(result); [EOL] }
public void testParseBooleanPrimitiveWithFalseString() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("false"); [EOL] boolean result = _parseBooleanPrimitive(jp, ctxt); [EOL] assertFalse(result); [EOL] }
public void testParseBooleanPrimitiveWithEmptyString() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn(""); [EOL] boolean result = _parseBooleanPrimitive(jp, ctxt); [EOL] assertFalse(result); [EOL] }
public void testParseBooleanPrimitiveWithInvalidString() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("invalid"); [EOL] try { [EOL] _parseBooleanPrimitive(jp, ctxt); [EOL] fail("Expected weirdStringException to be thrown"); [EOL] } catch (JsonProcessingException e) { [EOL] } [EOL] }
public void testParseBooleanPrimitiveWithInvalidToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.NOT_AVAILABLE); [EOL] try { [EOL] _parseBooleanPrimitive(jp, ctxt); [EOL] fail("Expected mappingException to be thrown"); [EOL] } catch (JsonMappingException e) { [EOL] } [EOL] }
public void testParseBooleanWithTrueToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_TRUE); [EOL] Boolean result = _parseBoolean(jp, ctxt); [EOL] assertTrue(result); [EOL] }
public void testParseBooleanWithFalseToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_FALSE); [EOL] Boolean result = _parseBoolean(jp, ctxt); [EOL] assertFalse(result); [EOL] }
public void testParseBooleanWithNumberIntTokenZero() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); [EOL] when(jp.getNumberType()).thenReturn(NumberType.INT); [EOL] when(jp.getIntValue()).thenReturn(0); [EOL] Boolean result = _parseBoolean(jp, ctxt); [EOL] assertFalse(result); [EOL] }
public void testParseBooleanWithNumberIntTokenNonZero() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); [EOL] when(jp.getNumberType()).thenReturn(NumberType.INT); [EOL] when(jp.getIntValue()).thenReturn(1); [EOL] Boolean result = _parseBoolean(jp, ctxt); [EOL] assertTrue(result); [EOL] }
public void testParseBooleanWithNumberIntTokenNotInt() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); [EOL] when(jp.getNumberType()).thenReturn(NumberType.LONG); // Assuming _parseBooleanFromNumber handles non-INT types [EOL] when(jp.getLongValue()).thenReturn(1L); [EOL] when(ctxt.weirdStringException(anyString(), any(Class.class), anyString())).thenThrow(new JsonProcessingException("") {}); [EOL] assertThrows(JsonProcessingException.class, () -> _parseBoolean(jp, ctxt)); [EOL] }
public void testParseBooleanWithNullToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NULL); [EOL] when(ctxt.getNullValue()).thenReturn(null); [EOL] Boolean result = _parseBoolean(jp, ctxt); [EOL] assertNull(result); [EOL] }
public void testParseBooleanWithStringTokenTrue() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("true"); [EOL] Boolean result = _parseBoolean(jp, ctxt); [EOL] assertTrue(result); [EOL] }
public void testParseBooleanWithStringTokenFalse() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("false"); [EOL] Boolean result = _parseBoolean(jp, ctxt); [EOL] assertFalse(result); [EOL] }
public void testParseBooleanWithStringTokenEmpty() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn(""); [EOL] when(ctxt.getEmptyValue()).thenReturn(Boolean.FALSE); [EOL] Boolean result = _parseBoolean(jp, ctxt); [EOL] assertFalse(result); [EOL] }
public void testParseBooleanWithStringTokenInvalid() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("invalid"); [EOL] when(ctxt.weirdStringException(anyString(), any(Class.class), anyString())).thenThrow(new JsonProcessingException("") {}); [EOL] assertThrows(JsonProcessingException.class, () -> _parseBoolean(jp, ctxt)); [EOL] }
public void testParseBooleanWithInvalidToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.NOT_AVAILABLE); [EOL] when(ctxt.mappingException(any(Class.class), any(JsonToken.class))).thenThrow(new JsonMappingException((Closeable) jp, "Error")); [EOL] assertThrows(JsonMappingException.class, () -> _parseBoolean(jp, ctxt)); [EOL] }
public void testParseByteWithNumberIntToken() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); [EOL] when(jp.getByteValue()).thenReturn((byte) 10); [EOL] byte result = _parseByte(jp, ctxt); [EOL] assertEquals((byte) 10, result); [EOL] }
public void testParseByteWithNumberFloatToken() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_FLOAT); [EOL] when(jp.getByteValue()).thenReturn((byte) 10); [EOL] byte result = _parseByte(jp, ctxt); [EOL] assertEquals((byte) 10, result); [EOL] }
public void testParseByteWithEmptyString() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn(""); [EOL] Byte result = _parseByte(jp, ctxt); [EOL] assertNull(result); [EOL] }
public void testParseByteWithValidString() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("10"); [EOL] Byte result = _parseByte(jp, ctxt); [EOL] assertEquals(Byte.valueOf((byte) 10), result); [EOL] }
public void testParseByteWithInvalidString() { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("invalid"); [EOL] try { [EOL] _parseByte(jp, ctxt); [EOL] fail("Expected JsonProcessingException to be thrown"); [EOL] } catch (JsonProcessingException e) { [EOL] } catch (IOException e) { [EOL] fail("Expected JsonProcessingException, not IOException"); [EOL] } [EOL] }
public void testParseByteWithOverflowString() { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("256"); [EOL] try { [EOL] _parseByte(jp, ctxt); [EOL] fail("Expected JsonProcessingException to be thrown"); [EOL] } catch (JsonProcessingException e) { [EOL] } catch (IOException e) { [EOL] fail("Expected JsonProcessingException, not IOException"); [EOL] } [EOL] }
public void testParseByteWithNullToken() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NULL); [EOL] Byte result = _parseByte(jp, ctxt); [EOL] assertNull(result); [EOL] }
public void testParseByteWithUnexpectedToken() { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.NOT_AVAILABLE); [EOL] try { [EOL] _parseByte(jp, ctxt); [EOL] fail("Expected JsonMappingException to be thrown"); [EOL] } catch (JsonMappingException e) { [EOL] } catch (IOException e) { [EOL] fail("Expected JsonMappingException, not IOException"); [EOL] } [EOL] }
public void testParseShortWithNumberIntToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); [EOL] when(jp.getShortValue()).thenReturn((short) 10); [EOL] Short result = _parseShort(jp, ctxt); [EOL] assertEquals(Short.valueOf((short) 10), result); [EOL] }
public void testParseShortWithNumberFloatToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_FLOAT); [EOL] when(jp.getShortValue()).thenReturn((short) -10); [EOL] Short result = _parseShort(jp, ctxt); [EOL] assertEquals(Short.valueOf((short) -10), result); [EOL] }
public void testParseShortWithStringTokenEmptyString() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn(""); [EOL] when(ctxt.getEmptyValue()).thenReturn(Short.valueOf((short) 0)); [EOL] Short result = _parseShort(jp, ctxt); [EOL] assertEquals(Short.valueOf((short) 0), result); [EOL] }
public void testParseShortWithStringTokenValidShort() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("15"); [EOL] Short result = _parseShort(jp, ctxt); [EOL] assertEquals(Short.valueOf((short) 15), result); [EOL] }
public void testParseShortWithStringTokenInvalidShort() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("not a number"); [EOL] try { [EOL] _parseShort(jp, ctxt); [EOL] fail("Expected an exception to be thrown"); [EOL] } catch (JsonProcessingException e) { [EOL] } [EOL] }
public void testParseShortWithStringTokenOverflow() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn(String.valueOf((int) Short.MAX_VALUE + 1)); [EOL] try { [EOL] _parseShort(jp, ctxt); [EOL] fail("Expected an exception to be thrown"); [EOL] } catch (JsonProcessingException e) { [EOL] } [EOL] }
public void testParseShortWithNullToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NULL); [EOL] when(ctxt.getNullValue()).thenReturn(null); [EOL] Short result = _parseShort(jp, ctxt); [EOL] assertNull(result); [EOL] }
public void testParseShortWithUnexpectedToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_ARRAY); [EOL] try { [EOL] _parseShort(jp, ctxt); [EOL] fail("Expected an exception to be thrown"); [EOL] } catch (JsonMappingException e) { [EOL] } [EOL] }
public void testParseShortPrimitiveValidValue() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getIntValue()).thenReturn((int) Short.MAX_VALUE); [EOL] short result = _parseShortPrimitive(jp, ctxt); [EOL] assertEquals(Short.MAX_VALUE, result); [EOL] }
public void testParseShortPrimitiveUnderflow() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getIntValue()).thenReturn(Integer.MIN_VALUE); [EOL] try { [EOL] _parseShortPrimitive(jp, ctxt); [EOL] fail("Expected weirdStringException for underflow"); [EOL] } catch (JsonProcessingException e) { [EOL] } [EOL] }
public void testParseShortPrimitiveOverflow() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getIntValue()).thenReturn(Integer.MAX_VALUE); [EOL] try { [EOL] _parseShortPrimitive(jp, ctxt); [EOL] fail("Expected weirdStringException for overflow"); [EOL] } catch (JsonProcessingException e) { [EOL] } [EOL] }
public void testParseIntegerWithNumberIntToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); [EOL] when(jp.getIntValue()).thenReturn(123); [EOL] Integer result = _parseInteger(jp, ctxt); [EOL] assertEquals(Integer.valueOf(123), result); [EOL] }
public void testParseIntegerWithNumberFloatToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_FLOAT); [EOL] when(jp.getIntValue()).thenReturn(456); [EOL] Integer result = _parseInteger(jp, ctxt); [EOL] assertEquals(Integer.valueOf(456), result); [EOL] }
public void testParseIntegerWithStringToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("789"); [EOL] Integer result = _parseInteger(jp, ctxt); [EOL] assertEquals(Integer.valueOf(789), result); [EOL] }
public void testParseIntegerWithStringTokenLeadingToOverflow() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn(String.valueOf(Long.MAX_VALUE)); [EOL] try { [EOL] _parseInteger(jp, ctxt); [EOL] fail("Expected JsonProcessingException due to overflow"); [EOL] } catch (JsonProcessingException e) { [EOL] } [EOL] }
public void testParseIntegerWithStringTokenEmpty() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn(""); [EOL] Integer result = _parseInteger(jp, ctxt); [EOL] assertEquals(getEmptyValue(), result); [EOL] }
public void testParseIntegerWithNullToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NULL); [EOL] Integer result = _parseInteger(jp, ctxt); [EOL] assertEquals(getNullValue(), result); [EOL] }
public void testParseIntegerWithInvalidToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.NOT_AVAILABLE); [EOL] try { [EOL] _parseInteger(jp, ctxt); [EOL] fail("Expected JsonMappingException"); [EOL] } catch (JsonMappingException e) { [EOL] } [EOL] }
protected final Long _parseLong(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL] JsonToken t = jp.getCurrentToken(); [EOL] if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL] return jp.getLongValue(); [EOL] } [EOL] if (t == JsonToken.VALUE_STRING) { [EOL] String text = jp.getText().trim(); [EOL] if (text.length() == 0) { [EOL] return (Long) getEmptyValue(); [EOL] } [EOL] try { [EOL] return Long.valueOf(NumberInput.parseLong(text)); [EOL] } catch (IllegalArgumentException iae) { [EOL] } [EOL] throw ctxt.weirdStringException(text, _valueClass, "not a valid Long value"); [EOL] } [EOL] if (t == JsonToken.VALUE_NULL) { [EOL] return (Long) getNullValue(); [EOL] } [EOL] throw ctxt.mappingException(_valueClass, t); [EOL] }
public void testParseFloatWithNumberIntToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); [EOL] when(jp.getFloatValue()).thenReturn(10.0f); [EOL] Float result = _parseFloat(jp, ctxt); [EOL] assertEquals(Float.valueOf(10.0f), result); [EOL] }
public void testParseFloatWithNumberFloatToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_FLOAT); [EOL] when(jp.getFloatValue()).thenReturn(20.0f); [EOL] Float result = _parseFloat(jp, ctxt); [EOL] assertEquals(Float.valueOf(20.0f), result); [EOL] }
public void testParseFloatWithStringTokenEmpty() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn(""); [EOL] when(ctxt.getEmptyValue()).thenReturn(Float.valueOf(0.0f)); [EOL] Float result = _parseFloat(jp, ctxt); [EOL] assertEquals(Float.valueOf(0.0f), result); [EOL] }
public void testParseFloatWithStringTokenInfinity() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("Infinity"); [EOL] Float result = _parseFloat(jp, ctxt); [EOL] assertEquals(Float.POSITIVE_INFINITY, result, 0.0f); [EOL] }
public void testParseFloatWithStringTokenNegativeInfinity() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("-Infinity"); [EOL] Float result = _parseFloat(jp, ctxt); [EOL] assertEquals(Float.NEGATIVE_INFINITY, result, 0.0f); [EOL] }
public void testParseFloatWithStringTokenNaN() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("NaN"); [EOL] Float result = _parseFloat(jp, ctxt); [EOL] assertEquals(Float.NaN, result, 0.0f); [EOL] }
public void testParseFloatWithStringTokenInvalid() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("invalid"); [EOL] when(ctxt.weirdStringException(anyString(), any(Class.class), anyString())) [EOL] .thenThrow(new JsonProcessingException("") {}); [EOL] assertThrows(JsonProcessingException.class, () -> _parseFloat(jp, ctxt)); [EOL] }
public void testParseFloatWithNullToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NULL); [EOL] when(ctxt.getNullValue()).thenReturn(null); [EOL] Float result = _parseFloat(jp, ctxt); [EOL] assertNull(result); [EOL] }
public void testParseFloatWithUnexpectedToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_ARRAY); [EOL] when(ctxt.mappingException(any(Class.class), any(JsonToken.class))) [EOL] .thenThrow(new JsonMappingException("")); [EOL] assertThrows(JsonMappingException.class, () -> _parseFloat(jp, ctxt)); [EOL] }
protected final Double _parseDouble(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL] JsonToken t = jp.getCurrentToken(); [EOL] if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL] return jp.getDoubleValue(); [EOL] } [EOL] if (t == JsonToken.VALUE_STRING) { [EOL] String text = jp.getText().trim(); [EOL] if (text.length() == 0) { [EOL] return (Double) getEmptyValue(); [EOL] } [EOL] switch(text.charAt(0)) { [EOL] case 'I': [EOL] if ("Infinity".equals(text) || "INF".equals(text)) { [EOL] return Double.POSITIVE_INFINITY; [EOL] } [EOL] break; [EOL] case 'N': [EOL] if ("NaN".equals(text)) { [EOL] return Double.NaN; [EOL] } [EOL] break; [EOL] case '-': [EOL] if ("-Infinity".equals(text) || "-INF".equals(text)) { [EOL] return Double.NEGATIVE_INFINITY; [EOL] } [EOL] break; [EOL] } [EOL] try { [EOL] return parseDouble(text); [EOL] } catch (IllegalArgumentException iae) { [EOL] } [EOL] throw ctxt.weirdStringException(text, _valueClass, "not a valid Double value"); [EOL] } [EOL] if (t == JsonToken.VALUE_NULL) { [EOL] return (Double) getNullValue(); [EOL] } [EOL] throw ctxt.mappingException(_valueClass, t); [EOL] }
protected JsonDeserializer<?> findConvertingContentDeserializer(DeserializationContext ctxt, BeanProperty prop, JsonDeserializer<?> existingDeserializer) throws JsonMappingException { [EOL] final AnnotationIntrospector intr = ctxt.getAnnotationIntrospector(); [EOL] if (intr != null && prop != null) { [EOL] Object convDef = intr.findDeserializationContentConverter(prop.getMember()); [EOL] if (convDef != null) { [EOL] Converter<Object, Object> conv = ctxt.converterInstance(prop.getMember(), convDef); [EOL] JavaType delegateType = conv.getInputType(ctxt.getTypeFactory()); [EOL] if (existingDeserializer == null) { [EOL] existingDeserializer = ctxt.findContextualValueDeserializer(delegateType, prop); [EOL] } [EOL] return new StdDelegatingDeserializer<Object>(conv, delegateType, existingDeserializer); [EOL] } [EOL] } [EOL] return existingDeserializer; [EOL] }
public void testSerializeContentsWithEmptyIterable() throws IOException { [EOL] Iterable<?> value = Collections.emptyList(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] serializeContents(value, jgen, provider); [EOL] verifyNoInteractions(jgen); [EOL] verifyNoInteractions(provider); [EOL] }
public void testSerializeContentsWithNullElement() throws IOException { [EOL] Iterable<?> value = Arrays.asList(null); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] serializeContents(value, jgen, provider); [EOL] verify(provider).defaultSerializeNull(jgen); [EOL] }
public void testSerializeContentsWithNonNullElement() throws IOException { [EOL] Iterable<?> value = Arrays.asList("test"); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] JsonSerializer<Object> serializer = mock(JsonSerializer.class); [EOL] when(provider.findValueSerializer(String.class, null)).thenReturn(serializer); [EOL] serializeContents(value, jgen, provider); [EOL] verify(serializer).serialize("test", jgen, provider); [EOL] }
public void testSerializeContentsWithMultipleElementsOfSameType() throws IOException { [EOL] Iterable<?> value = Arrays.asList("test1", "test2"); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] JsonSerializer<Object> serializer = mock(JsonSerializer.class); [EOL] when(provider.findValueSerializer(String.class, null)).thenReturn(serializer); [EOL] serializeContents(value, jgen, provider); [EOL] verify(serializer, times(2)).serialize(anyString(), eq(jgen), eq(provider)); [EOL] }
public void testSerializeContentsWithMultipleElementsOfDifferentTypes() throws IOException { [EOL] Iterable<?> value = Arrays.asList("test", 1); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] JsonSerializer<Object> stringSerializer = mock(JsonSerializer.class); [EOL] JsonSerializer<Object> integerSerializer = mock(JsonSerializer.class); [EOL] when(provider.findValueSerializer(String.class, null)).thenReturn(stringSerializer); [EOL] when(provider.findValueSerializer(Integer.class, null)).thenReturn(integerSerializer); [EOL] serializeContents(value, jgen, provider); [EOL] verify(stringSerializer).serialize("test", jgen, provider); [EOL] verify(integerSerializer).serialize(1, jgen, provider); [EOL] }
public void testSerializeContentsWithTypeSerializer() throws IOException { [EOL] Iterable<?> value = Arrays.asList("test"); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] JsonSerializer<Object> serializer = mock(JsonSerializer.class); [EOL] TypeSerializer typeSer = mock(TypeSerializer.class); [EOL] when(provider.findValueSerializer(String.class, null)).thenReturn(serializer); [EOL] serializeContents(value, jgen, provider, typeSer); [EOL] verify(serializer).serializeWithType("test", jgen, provider, typeSer); [EOL] }
public void testSerializationConfigCopyConstructor() { [EOL] SerializationConfig src = new SerializationConfig(...); // Provide actual arguments [EOL] int mapperFeatures = ...; // Provide actual value [EOL] int serFeatures = ...; // Provide actual value [EOL] SerializationConfig newConfig = new SerializationConfig(src, mapperFeatures, serFeatures); [EOL] assertEquals(mapperFeatures, newConfig.getMapperFeatures()); [EOL] assertEquals(serFeatures, newConfig.getSerializationFeatures()); [EOL] assertEquals(src.getSerializationInclusion(), newConfig.getSerializationInclusion()); [EOL] assertEquals(src.getFilterProvider(), newConfig.getFilterProvider()); [EOL] }
public void testSerializationConfigCopyConstructor() { [EOL] BaseSettings baseSettings = new BaseSettings(null, null, null, null, null, null, null, null, null, null); [EOL] FilterProvider filterProvider = new SimpleFilterProvider(); [EOL] SerializationConfig src = new SerializationConfig( [EOL] new ObjectMapper().getSerializationConfig(), [EOL] JsonInclude.Include.ALWAYS, [EOL] 123, // Example feature int [EOL] filterProvider [EOL] ); [EOL] SerializationConfig copy = new SerializationConfig(src, baseSettings); [EOL] assertEquals(src.getSerializationInclusion(), copy.getSerializationInclusion()); [EOL] assertEquals(src.getFilterProvider(), copy.getFilterProvider()); [EOL] assertEquals(src.getSerializationFeatures(), copy.getSerializationFeatures()); [EOL] }
public void testSerializationConfigCopyConstructorWithNullFilters() { [EOL] SerializationConfig src = new SerializationConfig(...); // provide necessary arguments [EOL] SerializationConfig copy = new SerializationConfig(src, null); [EOL] assertEquals(src.getSerializationFeatures(), copy.getSerializationFeatures()); [EOL] assertEquals(src.getSerializationInclusion(), copy.getSerializationInclusion()); [EOL] assertNull(copy.getFilterProvider()); [EOL] }
public void testSerializationConfigCopyConstructorWithNonNullFilters() { [EOL] SerializationConfig src = new SerializationConfig(...); // provide necessary arguments [EOL] FilterProvider filters = new SimpleFilterProvider(); // or any other FilterProvider implementation [EOL] SerializationConfig copy = new SerializationConfig(src, filters); [EOL] assertEquals(src.getSerializationFeatures(), copy.getSerializationFeatures()); [EOL] assertEquals(src.getSerializationInclusion(), copy.getSerializationInclusion()); [EOL] assertSame(filters, copy.getFilterProvider()); [EOL] }
public void testSerializationConfigCopyConstructorWithView() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] SerializationConfig originalConfig = mapper.getSerializationConfig(); [EOL] Class<?> viewClass = String.class; // Use any class for the view [EOL] SerializationConfig copiedConfig = new SerializationConfig(originalConfig, viewClass); [EOL] assertEquals(originalConfig.getSerializationFeatures(), copiedConfig.getSerializationFeatures()); [EOL] assertEquals(originalConfig.getSerializationInclusion(), copiedConfig.getSerializationInclusion()); [EOL] assertEquals(originalConfig.getFilterProvider(), copiedConfig.getFilterProvider()); [EOL] assertEquals(viewClass, copiedConfig.getActiveView()); [EOL] }
public void testSerializationConfigCopyConstructorWithRootName() { [EOL] SerializationConfig src = new SerializationConfig(); [EOL] String rootName = "testRoot"; [EOL] SerializationConfig copiedConfig = new SerializationConfig(src, rootName); [EOL] assertNotNull(copiedConfig); [EOL] assertEquals(rootName, copiedConfig.getRootName()); [EOL] assertEquals(src.getSerializationFeatures(), copiedConfig.getSerializationFeatures()); [EOL] assertEquals(src.getSerializationInclusion(), copiedConfig.getSerializationInclusion()); [EOL] assertEquals(src.getFilterProvider(), copiedConfig.getFilterProvider()); [EOL] }
public void testSerializationConfigCopyConstructor() { [EOL] Map<ClassKey, Class<?>> mixins = new HashMap<>(); [EOL] mixins.put(new ClassKey(String.class), Integer.class); [EOL] SerializationConfig src = new SerializationConfig(new BaseSettings(), new SubtypeResolver(), mixins); [EOL] SerializationConfig copy = new SerializationConfig(src, mixins); [EOL] assertEquals(src.getSerializationFeatures(), copy.getSerializationFeatures()); [EOL] assertEquals(src.getSerializationInclusion(), copy.getSerializationInclusion()); [EOL] assertEquals(src.getFilterProvider(), copy.getFilterProvider()); [EOL] }
public void testWithoutWithNoFeatures() { [EOL] SerializationConfig config = new SerializationConfig(...); // provide necessary arguments [EOL] SerializationConfig newConfig = config.without(); [EOL] assertSame("Without no features should return the same config", config, newConfig); [EOL] }
public void testWithoutWithOneFeature() { [EOL] SerializationConfig config = new SerializationConfig(...); // provide necessary arguments [EOL] MapperFeature feature = MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES; [EOL] SerializationConfig newConfig = config.without(feature); [EOL] assertNotSame("Without one feature should return a new config", config, newConfig); [EOL] assertFalse("New config should not have the feature", newConfig.isEnabled(feature)); [EOL] }
public void testWithoutWithMultipleFeatures() { [EOL] SerializationConfig config = new SerializationConfig(...); // provide necessary arguments [EOL] MapperFeature firstFeature = MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES; [EOL] MapperFeature secondFeature = MapperFeature.AUTO_DETECT_FIELDS; [EOL] SerializationConfig newConfig = config.without(firstFeature, secondFeature); [EOL] assertNotSame("Without multiple features should return a new config", config, newConfig); [EOL] assertFalse("New config should not have the first feature", newConfig.isEnabled(firstFeature)); [EOL] assertFalse("New config should not have the second feature", newConfig.isEnabled(secondFeature)); [EOL] }
public void testWithAnnotationIntrospector() { [EOL] SerializationConfig config = new SerializationConfig(...); // Provide necessary initialization parameters [EOL] AnnotationIntrospector ai = new MyAnnotationIntrospector(); // Substitute with an actual implementation [EOL] SerializationConfig newConfig = config.with(ai); [EOL] assertNotNull(newConfig); [EOL] assertNotSame(config, newConfig); [EOL] assertEquals(ai, newConfig.getAnnotationIntrospector()); [EOL] }
public void testWithHandlerInstantiator() { [EOL] SerializationConfig config = new SerializationConfig(...); // provide necessary initialization parameters [EOL] HandlerInstantiator hi = new HandlerInstantiator() { [EOL] }; [EOL] SerializationConfig newConfig = config.with(hi); [EOL] assertNotNull(newConfig); [EOL] assertNotSame(config, newConfig); // Ensure a new instance is returned [EOL] assertEquals(hi, newConfig.getHandlerInstantiator()); // Verify the handler instantiator is set correctly [EOL] }
public void testWithRootNameWhenRootNameIsNullAndCurrentRootNameIsNull() { [EOL] SerializationConfig config = new SerializationConfig(); [EOL] SerializationConfig newConfig = config.withRootName(null); [EOL] assertSame(config, newConfig); [EOL] }
public void testWithRootNameWhenRootNameIsNullAndCurrentRootNameIsNotNull() { [EOL] SerializationConfig config = new SerializationConfig(); [EOL] config = config.withRootName("existingRootName"); [EOL] SerializationConfig newConfig = config.withRootName(null); [EOL] assertNotSame(config, newConfig); [EOL] }
public void testWithRootNameWhenRootNameIsNotNullAndEqualsCurrentRootName() { [EOL] SerializationConfig config = new SerializationConfig(); [EOL] config = config.withRootName("existingRootName"); [EOL] SerializationConfig newConfig = config.withRootName("existingRootName"); [EOL] assertSame(config, newConfig); [EOL] }
public void testWithRootNameWhenRootNameIsNotNullAndNotEqualsCurrentRootName() { [EOL] SerializationConfig config = new SerializationConfig(); [EOL] config = config.withRootName("existingRootName"); [EOL] SerializationConfig newConfig = config.withRootName("newRootName"); [EOL] assertNotSame(config, newConfig); [EOL] }
public void testWithNewTypeFactory() { [EOL] TypeFactory typeFactory = new TypeFactory(); [EOL] SerializationConfig config = new SerializationConfig(); [EOL] SerializationConfig newConfig = config.with(typeFactory); [EOL] assertNotNull(newConfig); [EOL] assertNotSame(config, newConfig); [EOL] assertEquals(typeFactory, newConfig.getTypeFactory()); [EOL] }
public void testWithView_SameView() { [EOL] SerializationConfig config = new SerializationConfig(); [EOL] Class<?> viewClass = SomeViewClass.class; [EOL] config = config.withView(viewClass); // Initial set up with a view [EOL] SerializationConfig newConfig = config.withView(viewClass); // Attempt to set the same view [EOL] assertSame("Should return the same config object for the same view", config, newConfig); [EOL] }
public void testWithView_DifferentView() { [EOL] SerializationConfig config = new SerializationConfig(); [EOL] Class<?> viewClass1 = SomeViewClass.class; [EOL] Class<?> viewClass2 = AnotherViewClass.class; [EOL] config = config.withView(viewClass1); // Initial set up with a view [EOL] SerializationConfig newConfig = config.withView(viewClass2); // Attempt to set a different view [EOL] assertNotSame("Should return a new config object for a different view", config, newConfig); [EOL] }
public void testWithBaseSameInstance() { [EOL] BaseSettings baseSettings = new BaseSettings(null, null, null, null, null, null, null, null, null, null, null); [EOL] SerializationConfig config = new SerializationConfig(baseSettings, null, null); [EOL] SerializationConfig newConfig = config._withBase(baseSettings); [EOL] assertSame(config, newConfig); [EOL] }
public void testWithBaseDifferentInstance() { [EOL] BaseSettings baseSettings = new BaseSettings(null, null, null, null, null, null, null, null, null, null, null); [EOL] BaseSettings newBaseSettings = new BaseSettings(null, null, null, null, null, null, null, null, null, null, null); [EOL] SerializationConfig config = new SerializationConfig(baseSettings, null, null); [EOL] SerializationConfig newConfig = config._withBase(newBaseSettings); [EOL] assertNotSame(config, newConfig); [EOL] assertNotSame(config.getBaseSettings(), newConfig.getBaseSettings()); [EOL] }
public void testWithSameFeature() { [EOL] SerializationFeature feature = SerializationFeature.WRAP_ROOT_VALUE; [EOL] SerializationConfig config = new SerializationConfig(...); // provide necessary arguments [EOL] int oldSerFeatures = config.getSerializationFeatures(); [EOL] SerializationConfig newConfig = config.with(feature); [EOL] assertEquals(oldSerFeatures, newConfig.getSerializationFeatures()); [EOL] }
public void testWithDifferentFeature() { [EOL] SerializationFeature feature = SerializationFeature.INDENT_OUTPUT; [EOL] SerializationConfig config = new SerializationConfig(...); // provide necessary arguments [EOL] int oldSerFeatures = config.getSerializationFeatures(); [EOL] SerializationConfig newConfig = config.with(feature); [EOL] assertNotEquals(oldSerFeatures, newConfig.getSerializationFeatures()); [EOL] }
public void testWithFiltersSameProvider() { [EOL] FilterProvider filterProvider = new SimpleFilterProvider(); [EOL] SerializationConfig config = new SerializationConfig(...); // provide necessary initialization parameters [EOL] SerializationConfig newConfig = config.withFilters(filterProvider); [EOL] assertSame(config, newConfig); [EOL] }
public void testWithFiltersDifferentProvider() { [EOL] FilterProvider filterProvider1 = new SimpleFilterProvider(); [EOL] FilterProvider filterProvider2 = new SimpleFilterProvider(); [EOL] SerializationConfig config = new SerializationConfig(...); // provide necessary initialization parameters [EOL] SerializationConfig newConfig = config.withFilters(filterProvider2); [EOL] assertNotSame(config, newConfig); [EOL] assertSame(filterProvider2, newConfig.getFilterProvider()); [EOL] }
public void testGetAnnotationIntrospectorWhenUseAnnotationsEnabled() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] mapper.enable(MapperFeature.USE_ANNOTATIONS); [EOL] AnnotationIntrospector result = mapper.getAnnotationIntrospector(); [EOL] assertNotNull(result); [EOL] assertNotSame(AnnotationIntrospector.nopInstance(), result); [EOL] }
public void testGetAnnotationIntrospectorWhenUseAnnotationsDisabled() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] mapper.disable(MapperFeature.USE_ANNOTATIONS); [EOL] AnnotationIntrospector result = mapper.getAnnotationIntrospector(); [EOL] assertNotNull(result); [EOL] assertSame(AnnotationIntrospector.nopInstance(), result); [EOL] }
public void testIntrospectClassAnnotationsWithNonNullType() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] JavaType type = mapper.constructType(Object.class); [EOL] BeanDescription result = mapper.getSerializationConfig().introspectClassAnnotations(type); [EOL] assertNotNull(result); [EOL] assertEquals(type, result.getType()); [EOL] }
public void testIntrospectClassAnnotationsWithNullType() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] try { [EOL] mapper.getSerializationConfig().introspectClassAnnotations(null); [EOL] fail("Expected IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testGetDefaultVisibilityChecker_AllFeaturesEnabled() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] mapper.enable(MapperFeature.AUTO_DETECT_GETTERS); [EOL] mapper.enable(MapperFeature.AUTO_DETECT_IS_GETTERS); [EOL] mapper.enable(MapperFeature.AUTO_DETECT_FIELDS); [EOL] VisibilityChecker<?> vchecker = mapper.getSerializationConfig().getDefaultVisibilityChecker(); [EOL] assertEquals(Visibility.ANY, vchecker.getGetterVisibility()); [EOL] assertEquals(Visibility.ANY, vchecker.getIsGetterVisibility()); [EOL] assertEquals(Visibility.ANY, vchecker.getFieldVisibility()); [EOL] }
public void testGetDefaultVisibilityChecker_GettersDisabled() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] mapper.disable(MapperFeature.AUTO_DETECT_GETTERS); [EOL] VisibilityChecker<?> vchecker = mapper.getSerializationConfig().getDefaultVisibilityChecker(); [EOL] assertEquals(Visibility.NONE, vchecker.getGetterVisibility()); [EOL] assertEquals(Visibility.ANY, vchecker.getIsGetterVisibility()); [EOL] assertEquals(Visibility.ANY, vchecker.getFieldVisibility()); [EOL] }
public void testGetDefaultVisibilityChecker_IsGettersDisabled() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] mapper.disable(MapperFeature.AUTO_DETECT_IS_GETTERS); [EOL] VisibilityChecker<?> vchecker = mapper.getSerializationConfig().getDefaultVisibilityChecker(); [EOL] assertEquals(Visibility.ANY, vchecker.getGetterVisibility()); [EOL] assertEquals(Visibility.NONE, vchecker.getIsGetterVisibility()); [EOL] assertEquals(Visibility.ANY, vchecker.getFieldVisibility()); [EOL] }
public void testGetDefaultVisibilityChecker_FieldsDisabled() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] mapper.disable(MapperFeature.AUTO_DETECT_FIELDS); [EOL] VisibilityChecker<?> vchecker = mapper.getSerializationConfig().getDefaultVisibilityChecker(); [EOL] assertEquals(Visibility.ANY, vchecker.getGetterVisibility()); [EOL] assertEquals(Visibility.ANY, vchecker.getIsGetterVisibility()); [EOL] assertEquals(Visibility.NONE, vchecker.getFieldVisibility()); [EOL] }
public void testGetDefaultVisibilityChecker_AllFeaturesDisabled() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] mapper.disable(MapperFeature.AUTO_DETECT_GETTERS); [EOL] mapper.disable(MapperFeature.AUTO_DETECT_IS_GETTERS); [EOL] mapper.disable(MapperFeature.AUTO_DETECT_FIELDS); [EOL] VisibilityChecker<?> vchecker = mapper.getSerializationConfig().getDefaultVisibilityChecker(); [EOL] assertEquals(Visibility.NONE, vchecker.getGetterVisibility()); [EOL] assertEquals(Visibility.NONE, vchecker.getIsGetterVisibility()); [EOL] assertEquals(Visibility.NONE, vchecker.getFieldVisibility()); [EOL] }
public void testIsEnabledWithFeatureEnabled() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] mapper.enable(SerializationFeature.INDENT_OUTPUT); [EOL] assertTrue(mapper.isEnabled(SerializationFeature.INDENT_OUTPUT)); [EOL] }
public void testIsEnabledWithFeatureDisabled() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] mapper.disable(SerializationFeature.INDENT_OUTPUT); [EOL] assertFalse(mapper.isEnabled(SerializationFeature.INDENT_OUTPUT)); [EOL] }
public void testGetSerializationInclusionNonNull() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] mapper.setSerializationInclusion(JsonInclude.Include.NON_NULL); [EOL] assertEquals(JsonInclude.Include.NON_NULL, mapper.getSerializationInclusion()); [EOL] }
public void testGetSerializationInclusionDefault() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] assertEquals(JsonInclude.Include.ALWAYS, mapper.getSerializationInclusion()); [EOL] }
public void testGetFilterProvider_Null() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] assertNull(mapper.getSerializationConfig().getFilterProvider()); [EOL] }
public void testGetFilterProvider_NonNull() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] FilterProvider filterProvider = new SimpleFilterProvider(); [EOL] mapper.setFilterProvider(filterProvider); [EOL] assertSame(filterProvider, mapper.getSerializationConfig().getFilterProvider()); [EOL] }
public void testIntrospectWithValidType() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] JavaType type = mapper.constructType(MyBean.class); [EOL] BeanDescription beanDesc = mapper.getSerializationConfig().introspect(type); [EOL] assertNotNull(beanDesc); [EOL] assertTrue(beanDesc instanceof BeanDescription); [EOL] }
public void testIntrospectWithNullType() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] try { [EOL] mapper.getSerializationConfig().introspect(null); [EOL] fail("Expected IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Cannot introspect null type", e.getMessage()); [EOL] } [EOL] }
public void testFindWithUnregisteredClassName() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(URI.class, "UnregisteredClassName"); [EOL] assertNull(deserializer); [EOL] }
public void testFindWithURIClass() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(URI.class, "java.net.URI"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof URIDeserializer); [EOL] }
public void testFindWithURLClass() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(URL.class, "java.net.URL"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof URLDeserializer); [EOL] }
public void testFindWithFileClass() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(File.class, "java.io.File"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof FileDeserializer); [EOL] }
public void testFindWithUUIDClass() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(UUID.class, "java.util.UUID"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof UUIDDeserializer); [EOL] }
public void testFindWithCurrencyClass() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(Currency.class, "java.util.Currency"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof CurrencyDeserializer); [EOL] }
public void testFindWithPatternClass() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(Pattern.class, "java.util.regex.Pattern"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof PatternDeserializer); [EOL] }
public void testFindWithLocaleClass() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(Locale.class, "java.util.Locale"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof LocaleDeserializer); [EOL] }
public void testFindWithInetAddressClass() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(InetAddress.class, "java.net.InetAddress"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof InetAddressDeserializer); [EOL] }
public void testFindWithCharsetClass() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(Charset.class, "java.nio.charset.Charset"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof CharsetDeserializer); [EOL] }
public void testFindWithClassClass() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(Class.class, "java.lang.Class"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof ClassDeserializer); [EOL] }
public void testFindWithStackTraceElementClass() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(StackTraceElement.class, "java.lang.StackTraceElement"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof StackTraceElementDeserializer); [EOL] }
public void testFindWithAtomicBooleanClass() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(AtomicBoolean.class, "java.util.concurrent.atomic.AtomicBoolean"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof AtomicBooleanDeserializer); [EOL] }
public void testFindWithInvalidClass() { [EOL] try { [EOL] YourClass.find(Object.class, "java.lang.Object"); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testUUIDDeserializerConstructor() { [EOL] UUIDDeserializer deserializer = new UUIDDeserializer(); [EOL] assertNotNull(deserializer); [EOL] assertEquals(UUID.class, deserializer.handledType()); [EOL] }
public void testDeserializeValidUUID() throws IOException { [EOL] String validUUIDString = "123e4567-e89b-12d3-a456-426614174000"; [EOL] UUID expectedUUID = UUID.fromString(validUUIDString); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] UUID result = _deserialize(validUUIDString, ctxt); [EOL] assertEquals(expectedUUID, result); [EOL] }
public void testDeserializeInvalidUUID() { [EOL] String invalidUUIDString = "invalid-uuid"; [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] try { [EOL] _deserialize(invalidUUIDString, ctxt); [EOL] fail("Expected an exception to be thrown"); [EOL] } catch (IOException e) { [EOL] assertTrue(e instanceof IllegalArgumentException); [EOL] } [EOL] }
public void testLocaleDeserializerConstructor() { [EOL] LocaleDeserializer deserializer = new LocaleDeserializer(); [EOL] assertNotNull(deserializer); [EOL] }
public void testDeserializeNoUnderscore() throws IOException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] String value = "en"; [EOL] Locale result = _deserialize(value, ctxt); [EOL] assertEquals(new Locale("en"), result); [EOL] }
public void testDeserializeOneUnderscore() throws IOException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] String value = "en_US"; [EOL] Locale result = _deserialize(value, ctxt); [EOL] assertEquals(new Locale("en", "US"), result); [EOL] }
public void testDeserializeTwoUnderscores() throws IOException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] String value = "en_US_NY"; [EOL] Locale result = _deserialize(value, ctxt); [EOL] assertEquals(new Locale("en", "US", "NY"), result); [EOL] }
public void testDeserializeWithStartObjectToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); [EOL] when(jp.nextValue()).thenReturn(JsonToken.VALUE_STRING).thenReturn(JsonToken.END_OBJECT); [EOL] when(jp.getCurrentName()).thenReturn("className").thenReturn("methodName").thenReturn("fileName").thenReturn("lineNumber"); [EOL] when(jp.getText()).thenReturn("com.example.ClassName").thenReturn("methodName").thenReturn("sourceFile.java"); [EOL] when(jp.getIntValue()).thenReturn(123); [EOL] StackTraceElementDeserializer deserializer = new StackTraceElementDeserializer(); [EOL] StackTraceElement result = deserializer.deserialize(jp, ctxt); [EOL] assertEquals("com.example.ClassName", result.getClassName()); [EOL] assertEquals("methodName", result.getMethodName()); [EOL] assertEquals("sourceFile.java", result.getFileName()); [EOL] assertEquals(123, result.getLineNumber()); [EOL] }
public void testDeserializeWithNonNumericLineNumber() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); [EOL] when(jp.nextValue()).thenReturn(JsonToken.VALUE_STRING).thenReturn(JsonToken.VALUE_STRING).thenReturn(JsonToken.VALUE_FALSE); [EOL] when(jp.getCurrentName()).thenReturn("className").thenReturn("methodName").thenReturn("lineNumber"); [EOL] when(jp.getText()).thenReturn("com.example.ClassName").thenReturn("methodName"); [EOL] when(jp.getIntValue()).thenThrow(new JsonParseException(jp, "Non-numeric token")); [EOL] StackTraceElementDeserializer deserializer = new StackTraceElementDeserializer(); [EOL] assertThrows(JsonMappingException.class, () -> deserializer.deserialize(jp, ctxt)); [EOL] }
public void testDeserializeWithUnexpectedToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] StackTraceElementDeserializer deserializer = new StackTraceElementDeserializer(); [EOL] assertThrows(JsonMappingException.class, () -> deserializer.deserialize(jp, ctxt)); [EOL] }
public void testDeserializeWithUnknownProperty() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); [EOL] when(jp.nextValue()).thenReturn(JsonToken.VALUE_STRING).thenReturn(JsonToken.END_OBJECT); [EOL] when(jp.getCurrentName()).thenReturn("unknownProperty"); [EOL] doNothing().when(ctxt).handleUnknownProperty(any(JsonParser.class), any(DeserializationContext.class), any(Class.class), anyString()); [EOL] StackTraceElementDeserializer deserializer = new StackTraceElementDeserializer(); [EOL] deserializer.deserialize(jp, ctxt); [EOL] verify(ctxt, times(1)).handleUnknownProperty(jp, ctxt, StackTraceElement.class, "unknownProperty"); [EOL] }
public void testAsPropertyTypeSerializerWithNonNullValues() { [EOL] TypeIdResolver idRes = mock(TypeIdResolver.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] String propName = "typeName"; [EOL] AsPropertyTypeSerializer serializer = new AsPropertyTypeSerializer(idRes, property, propName); [EOL] assertNotNull(serializer); [EOL] assertEquals("typeName", serializer._typePropertyName); [EOL] }
public void testAsPropertyTypeSerializerWithNullValues() { [EOL] AsPropertyTypeSerializer serializer = new AsPropertyTypeSerializer(null, null, null); [EOL] assertNotNull(serializer); [EOL] assertNull(serializer._typePropertyName); [EOL] }
public void testFieldPropertyWithNonNullValues() { [EOL] BeanPropertyDefinition propDef = mock(BeanPropertyDefinition.class); [EOL] JavaType type = mock(JavaType.class); [EOL] TypeDeserializer typeDeser = mock(TypeDeserializer.class); [EOL] Annotations contextAnnotations = mock(Annotations.class); [EOL] AnnotatedField field = mock(AnnotatedField.class); [EOL] Field javaField = mock(Field.class); [EOL] when(field.getAnnotated()).thenReturn(javaField); [EOL] FieldProperty fieldProperty = new FieldProperty(propDef, type, typeDeser, contextAnnotations, field); [EOL] assertNotNull(fieldProperty); [EOL] assertEquals(javaField, fieldProperty.getField()); [EOL] }
public void testFieldPropertyWithNullField() { [EOL] BeanPropertyDefinition propDef = mock(BeanPropertyDefinition.class); [EOL] JavaType type = mock(JavaType.class); [EOL] TypeDeserializer typeDeser = mock(TypeDeserializer.class); [EOL] Annotations contextAnnotations = mock(Annotations.class); [EOL] FieldProperty fieldProperty = new FieldProperty(propDef, type, typeDeser, contextAnnotations, null); [EOL] assertNotNull(fieldProperty); [EOL] assertNull(fieldProperty.getField()); [EOL] }
public void testFieldPropertyConstructorWithDeserializer() { [EOL] FieldProperty original = new FieldProperty(/* parameters to create a FieldProperty */); [EOL] JsonDeserializer<?> deserializer = /* instantiate a JsonDeserializer */; [EOL] FieldProperty copy = new FieldProperty(original, deserializer); [EOL] assertNotNull(copy); [EOL] assertSame(deserializer, copy.getDeserializer()); [EOL] assertSame(original.getAnnotated(), copy.getAnnotated()); [EOL] assertSame(original.getField(), copy.getField()); [EOL] }
public void testWithValueDeserializerNonNull() { [EOL] JsonDeserializer<?> originalDeserializer = mock(JsonDeserializer.class); [EOL] FieldProperty original = new FieldProperty(/* parameters to create a FieldProperty instance */); [EOL] JsonDeserializer<?> newDeserializer = mock(JsonDeserializer.class); [EOL] FieldProperty result = original.withValueDeserializer(newDeserializer); [EOL] assertNotNull(result); [EOL] assertNotSame(original, result); [EOL] assertSame(newDeserializer, result.getValueDeserializer()); [EOL] }
public void testWithValueDeserializerNull() { [EOL] FieldProperty original = new FieldProperty(/* parameters to create a FieldProperty instance */); [EOL] FieldProperty result = original.withValueDeserializer(null); [EOL] assertNotNull(result); [EOL] assertNotSame(original, result); [EOL] assertNull(result.getValueDeserializer()); [EOL] }
public void testGetMember() { [EOL] AnnotatedMember annotatedMember = new AnnotatedMemberImpl(); [EOL] PropertyImpl property = new PropertyImpl(annotatedMember); [EOL] AnnotatedMember result = property.getMember(); [EOL] assertNotNull(result); [EOL] assertEquals(annotatedMember, result); [EOL] }
public void testDeserializeAndSet_NullInstance() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object instance = null; [EOL] try { [EOL] deserializeAndSet(jp, ctxt, instance); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testDeserializeAndSet_ValidInstance() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object instance = new Object(); [EOL] when(deserialize(jp, ctxt)).thenReturn(new Object()); [EOL] deserializeAndSet(jp, ctxt, instance); [EOL] verify(instance).set(eq(instance), any()); [EOL] }
public void testSetWithValidInstanceAndValue() throws IOException { [EOL] MyObject instance = new MyObject(); [EOL] Object value = "someValue"; [EOL] FieldProperty fieldProperty = new FieldProperty(MyObject.class.getDeclaredField("myField")); [EOL] fieldProperty.set(instance, value); [EOL] assertEquals("someValue", instance.getMyField()); [EOL] } [EOL] public void testSetWithInvalidInstance() { [EOL] MyObject instance = null; [EOL] Object value = "someValue"; [EOL] FieldProperty fieldProperty = new FieldProperty(MyObject.class.getDeclaredField("myField")); [EOL] try { [EOL] fieldProperty.set(instance, value); [EOL] fail("Expected IOException not thrown"); [EOL] } catch (IOException expected) { [EOL] } [EOL] } [EOL] public void testSetWithInaccessibleField() { [EOL] MyObject instance = new MyObject(); [EOL] Object value = "someValue"; [EOL] FieldProperty fieldProperty = new FieldProperty(MyObject.class.getDeclaredField("privateField")); [EOL] try { [EOL] fieldProperty.set(instance, value); [EOL] fail("Expected IOException not thrown"); [EOL] } catch (IOException expected) { [EOL] } [EOL] } [EOL] public void testSetWithExceptionOnFieldSet() { [EOL] MyObject instance = new MyObject(); [EOL] Object value = new Object(); // Assuming this value is not compatible with the field type [EOL] FieldProperty fieldProperty = new FieldProperty(MyObject.class.getDeclaredField("myField")); [EOL] try { [EOL] fieldProperty.set(instance, value); [EOL] fail("Expected IOException not thrown"); [EOL] } catch (IOException expected) { [EOL] } [EOL] }
public void testBeanDeserializerBaseWithNonNullValues() { [EOL] BeanDeserializerBuilder builder = mock(BeanDeserializerBuilder.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] BeanPropertyMap properties = mock(BeanPropertyMap.class); [EOL] Map<String, SettableBeanProperty> backRefs = new HashMap<>(); [EOL] HashSet<String> ignorableProps = new HashSet<>(); [EOL] boolean ignoreAllUnknown = true; [EOL] boolean hasViews = true; [EOL] when(builder.getValueInstantiator()).thenReturn(mock(ValueInstantiator.class)); [EOL] when(builder.getAnySetter()).thenReturn(mock(SettableAnyProperty.class)); [EOL] when(builder.getInjectables()).thenReturn(Collections.singletonList(mock(ValueInjector.class))); [EOL] when(builder.getObjectIdReader()).thenReturn(mock(ObjectIdReader.class)); [EOL] when(beanDesc.getType()).thenReturn(mock(JavaType.class)); [EOL] when(beanDesc.getClassInfo()).thenReturn(mock(AnnotatedClass.class)); [EOL] when(beanDesc.getClassInfo().getAnnotations()).thenReturn(mock(Annotations.class)); [EOL] when(beanDesc.findExpectedFormat(null)).thenReturn(mock(JsonFormat.Value.class)); [EOL] BeanDeserializerBase deserializer = new BeanDeserializerBase(builder, beanDesc, properties, backRefs, ignorableProps, ignoreAllUnknown, hasViews); [EOL] assertNotNull(deserializer); [EOL] }
public void testBeanDeserializerBaseWithNullValues() { [EOL] BeanDeserializerBuilder builder = mock(BeanDeserializerBuilder.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] BeanPropertyMap properties = mock(BeanPropertyMap.class); [EOL] Map<String, SettableBeanProperty> backRefs = null; [EOL] HashSet<String> ignorableProps = null; [EOL] boolean ignoreAllUnknown = false; [EOL] boolean hasViews = false; [EOL] when(builder.getValueInstantiator()).thenReturn(mock(ValueInstantiator.class)); [EOL] when(builder.getAnySetter()).thenReturn(null); [EOL] when(builder.getInjectables()).thenReturn(null); [EOL] when(builder.getObjectIdReader()).thenReturn(null); [EOL] when(beanDesc.getType()).thenReturn(mock(JavaType.class)); [EOL] when(beanDesc.getClassInfo()).thenReturn(mock(AnnotatedClass.class)); [EOL] when(beanDesc.getClassInfo().getAnnotations()).thenReturn(mock(Annotations.class)); [EOL] when(beanDesc.findExpectedFormat(null)).thenReturn(null); [EOL] BeanDeserializerBase deserializer = new BeanDeserializerBase(builder, beanDesc, properties, backRefs, ignorableProps, ignoreAllUnknown, hasViews); [EOL] assertNotNull(deserializer); [EOL] }
public void testBeanDeserializerBaseWithIgnoreAllUnknownTrue() { [EOL] BeanDeserializerBase original = createBeanDeserializerBase(); [EOL] BeanDeserializerBase copy = new BeanDeserializerBase(original, true); [EOL] assertNotNull(copy); [EOL] assertEquals(original._classAnnotations, copy._classAnnotations); [EOL] assertEquals(original._beanType, copy._beanType); [EOL] assertEquals(original._valueInstantiator, copy._valueInstantiator); [EOL] assertEquals(original._delegateDeserializer, copy._delegateDeserializer); [EOL] assertEquals(original._propertyBasedCreator, copy._propertyBasedCreator); [EOL] assertEquals(original._beanProperties, copy._beanProperties); [EOL] assertEquals(original._backRefs, copy._backRefs); [EOL] assertEquals(original._ignorableProps, copy._ignorableProps); [EOL] assertTrue(copy._ignoreAllUnknown); [EOL] assertEquals(original._anySetter, copy._anySetter); [EOL] assertEquals(original._injectables, copy._injectables); [EOL] assertEquals(original._objectIdReader, copy._objectIdReader); [EOL] assertEquals(original._nonStandardCreation, copy._nonStandardCreation); [EOL] assertEquals(original._unwrappedPropertyHandler, copy._unwrappedPropertyHandler); [EOL] assertEquals(original._needViewProcesing, copy._needViewProcesing); [EOL] assertEquals(original._serializationShape, copy._serializationShape); [EOL] assertEquals(original._vanillaProcessing, copy._vanillaProcessing); [EOL] }
public void testBeanDeserializerBaseWithIgnoreAllUnknownFalse() { [EOL] BeanDeserializerBase original = createBeanDeserializerBase(); [EOL] BeanDeserializerBase copy = new BeanDeserializerBase(original, false); [EOL] assertNotNull(copy); [EOL] assertEquals(original._classAnnotations, copy._classAnnotations); [EOL] assertEquals(original._beanType, copy._beanType); [EOL] assertEquals(original._valueInstantiator, copy._valueInstantiator); [EOL] assertEquals(original._delegateDeserializer, copy._delegateDeserializer); [EOL] assertEquals(original._propertyBasedCreator, copy._propertyBasedCreator); [EOL] assertEquals(original._beanProperties, copy._beanProperties); [EOL] assertEquals(original._backRefs, copy._backRefs); [EOL] assertEquals(original._ignorableProps, copy._ignorableProps); [EOL] assertFalse(copy._ignoreAllUnknown); [EOL] assertEquals(original._anySetter, copy._anySetter); [EOL] assertEquals(original._injectables, copy._injectables); [EOL] assertEquals(original._objectIdReader, copy._objectIdReader); [EOL] assertEquals(original._nonStandardCreation, copy._nonStandardCreation); [EOL] assertEquals(original._unwrappedPropertyHandler, copy._unwrappedPropertyHandler); [EOL] assertEquals(original._needViewProcesing, copy._needViewProcesing); [EOL] assertEquals(original._serializationShape, copy._serializationShape); [EOL] assertEquals(original._vanillaProcessing, copy._vanillaProcessing); [EOL] }
public void testResolveWithCanCreateFromObjectWith() throws JsonMappingException { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] ValueInstantiator valueInstantiator = createValueInstantiator(true, true, false); [EOL] BeanDeserializerBuilder builder = createBeanDeserializerBuilder(valueInstantiator); [EOL] builder.resolve(ctxt); [EOL] assertNotNull(builder._propertyBasedCreator); [EOL] assertNotNull(builder._externalTypeIdHandler); [EOL] assertTrue(builder._nonStandardCreation); [EOL] }
public void testResolveWithUnwrappedPropertyHandler() throws JsonMappingException { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] ValueInstantiator valueInstantiator = createValueInstantiator(false, false, false); [EOL] BeanDeserializerBuilder builder = createBeanDeserializerBuilder(valueInstantiator); [EOL] builder.resolve(ctxt); [EOL] assertNotNull(builder._unwrappedPropertyHandler); [EOL] assertTrue(builder._nonStandardCreation); [EOL] }
public void testResolveWithDelegateType() throws JsonMappingException { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] ValueInstantiator valueInstantiator = createValueInstantiator(false, false, true); [EOL] BeanDeserializerBuilder builder = createBeanDeserializerBuilder(valueInstantiator); [EOL] builder.resolve(ctxt); [EOL] assertNotNull(builder._delegateDeserializer); [EOL] }
public void testResolveWithInvalidDelegateType() { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] ValueInstantiator valueInstantiator = createValueInstantiator(false, false, true, true); [EOL] BeanDeserializerBuilder builder = createBeanDeserializerBuilder(valueInstantiator); [EOL] Exception exception = assertThrows(IllegalArgumentException.class, () -> builder.resolve(ctxt)); [EOL] assertTrue(exception.getMessage().contains("Invalid delegate-creator definition for")); [EOL] }
public void testResolveWithVanillaProcessing() throws JsonMappingException { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] ValueInstantiator valueInstantiator = createValueInstantiator(false, false, false); [EOL] BeanDeserializerBuilder builder = createBeanDeserializerBuilder(valueInstantiator); [EOL] builder.resolve(ctxt); [EOL] assertTrue(builder._vanillaProcessing); [EOL] }
public void testFindConvertingDeserializerWithNonNullIntrospectorAndConverter() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] SettableBeanProperty prop = mock(SettableBeanProperty.class); [EOL] AnnotationIntrospector intr = mock(AnnotationIntrospector.class); [EOL] Converter<Object, Object> conv = mock(Converter.class); [EOL] JavaType delegateType = mock(JavaType.class); [EOL] JsonDeserializer<?> ser = mock(JsonDeserializer.class); [EOL] Member member = mock(Member.class); [EOL] when(ctxt.getAnnotationIntrospector()).thenReturn(intr); [EOL] when(intr.findDeserializationConverter(any(Member.class))).thenReturn(new Object()); [EOL] when(ctxt.converterInstance(any(Member.class), any())).thenReturn(conv); [EOL] when(conv.getInputType(any(TypeFactory.class))).thenReturn(delegateType); [EOL] when(ctxt.findContextualValueDeserializer(any(JavaType.class), any(SettableBeanProperty.class))).thenReturn(ser); [EOL] when(prop.getMember()).thenReturn(member); [EOL] StdDelegatingDeserializer<Object> result = (StdDelegatingDeserializer<Object>) findConvertingDeserializer(ctxt, prop); [EOL] assertNotNull(result); [EOL] assertEquals(conv, result.getConverter()); [EOL] assertEquals(delegateType, result.getDelegateType()); [EOL] assertEquals(ser, result.getDelegatee()); [EOL] }
public void testFindConvertingDeserializerWithNullIntrospector() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] SettableBeanProperty prop = mock(SettableBeanProperty.class); [EOL] when(ctxt.getAnnotationIntrospector()).thenReturn(null); [EOL] JsonDeserializer<Object> result = findConvertingDeserializer(ctxt, prop); [EOL] assertNull(result); [EOL] }
public void testFindConvertingDeserializerWithNonNullIntrospectorAndNullConverter() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] SettableBeanProperty prop = mock(SettableBeanProperty.class); [EOL] AnnotationIntrospector intr = mock(AnnotationIntrospector.class); [EOL] Member member = mock(Member.class); [EOL] when(ctxt.getAnnotationIntrospector()).thenReturn(intr); [EOL] when(intr.findDeserializationConverter(any(Member.class))).thenReturn(null); [EOL] when(prop.getMember()).thenReturn(member); [EOL] JsonDeserializer<Object> result = findConvertingDeserializer(ctxt, prop); [EOL] assertNull(result); [EOL] }
public void testCreateContextualWithNullPropertyAndIntr() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanProperty property = null; [EOL] JsonDeserializer<?> result = createContextual(ctxt, property); [EOL] assertNotNull(result); [EOL] }
public void testCreateContextualWithNonNullPropertyAndNullIntr() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] when(ctxt.getAnnotationIntrospector()).thenReturn(null); [EOL] JsonDeserializer<?> result = createContextual(ctxt, property); [EOL] assertNotNull(result); [EOL] }
public void testCreateContextualWithNonNullPropertyAndIntrIgnoringProperties() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] AnnotationIntrospector intr = mock(AnnotationIntrospector.class); [EOL] AnnotatedMember accessor = mock(AnnotatedMember.class); [EOL] when(ctxt.getAnnotationIntrospector()).thenReturn(intr); [EOL] when(property.getMember()).thenReturn(accessor); [EOL] when(intr.findPropertiesToIgnore(accessor)).thenReturn(new String[]{"propToIgnore"}); [EOL] JsonDeserializer<?> result = createContextual(ctxt, property); [EOL] assertNotNull(result); [EOL] }
public void testCreateContextualWithObjectIdInfoAndPropertyGenerator() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] AnnotationIntrospector intr = mock(AnnotationIntrospector.class); [EOL] AnnotatedMember accessor = mock(AnnotatedMember.class); [EOL] ObjectIdInfo objectIdInfo = mock(ObjectIdInfo.class); [EOL] when(ctxt.getAnnotationIntrospector()).thenReturn(intr); [EOL] when(property.getMember()).thenReturn(accessor); [EOL] when(intr.findObjectIdInfo(accessor)).thenReturn(objectIdInfo); [EOL] when(objectIdInfo.getGeneratorType()).thenReturn(ObjectIdGenerators.PropertyGenerator.class); [EOL] when(objectIdInfo.getPropertyName()).thenReturn("id"); [EOL] when(objectIdInfo.getScope()).thenReturn(Object.class); [EOL] SettableBeanProperty idProp = mock(SettableBeanProperty.class); [EOL] when(idProp.getName()).thenReturn("id"); [EOL] when(idProp.getType()).thenReturn(mock(JavaType.class)); [EOL] when(this.findProperty("id")).thenReturn(idProp); [EOL] JsonDeserializer<?> result = createContextual(ctxt, property); [EOL] assertNotNull(result); [EOL] }
public void testCreateContextualWithObjectIdInfoAndNonPropertyGenerator() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] AnnotationIntrospector intr = mock(AnnotationIntrospector.class); [EOL] AnnotatedMember accessor = mock(AnnotatedMember.class); [EOL] ObjectIdInfo objectIdInfo = mock(ObjectIdInfo.class); [EOL] when(ctxt.getAnnotationIntrospector()).thenReturn(intr); [EOL] when(property.getMember()).thenReturn(accessor); [EOL] when(intr.findObjectIdInfo(accessor)).thenReturn(objectIdInfo); [EOL] when(objectIdInfo.getGeneratorType()).thenReturn(ObjectIdGenerators.IntSequenceGenerator.class); [EOL] when(objectIdInfo.getPropertyName()).thenReturn("id"); [EOL] when(objectIdInfo.getScope()).thenReturn(Object.class); [EOL] JavaType type = mock(JavaType.class); [EOL] when(ctxt.constructType(ObjectIdGenerators.IntSequenceGenerator.class)).thenReturn(type); [EOL] when(ctxt.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)).thenReturn(new JavaType[]{mock(JavaType.class)}); [EOL] when(ctxt.objectIdGeneratorInstance(accessor, objectIdInfo)).thenReturn(mock(ObjectIdGenerator.class)); [EOL] JsonDeserializer<?> result = createContextual(ctxt, property); [EOL] assertNotNull(result); [EOL] }
public void testCreateContextualWithFormatShapeArray() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] AnnotationIntrospector intr = mock(AnnotationIntrospector.class); [EOL] AnnotatedMember accessor = mock(AnnotatedMember.class); [EOL] JsonFormat.Value format = mock(JsonFormat.Value.class); [EOL] when(ctxt.getAnnotationIntrospector()).thenReturn(intr); [EOL] when(property.getMember()).thenReturn(accessor); [EOL] when(intr.findFormat(accessor)).thenReturn(format); [EOL] when(format.getShape()).thenReturn(JsonFormat.Shape.ARRAY); [EOL] JsonDeserializer<?> result = createContextual(ctxt, property); [EOL] assertNotNull(result); [EOL] }
public void testResolveManagedReferencePropertyWithNullRefName() { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] SettableBeanProperty prop = createSettableBeanPropertyWithNullRefName(); [EOL] SettableBeanProperty result = _resolveManagedReferenceProperty(ctxt, prop); [EOL] assertSame("Property should be the same when refName is null", prop, result); [EOL] } [EOL] public void testResolveManagedReferencePropertyWithBeanDeserializerBase() { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] SettableBeanProperty prop = createSettableBeanPropertyWithRefName(); [EOL] when(prop.getValueDeserializer()).thenReturn(createBeanDeserializerBase()); [EOL] SettableBeanProperty result = _resolveManagedReferenceProperty(ctxt, prop); [EOL] assertNotNull("Result should not be null for BeanDeserializerBase", result); [EOL] assertTrue("Result should be instance of ManagedReferenceProperty", result instanceof ManagedReferenceProperty); [EOL] }
public void testResolveManagedReferencePropertyWithContainerDeserializerBaseAndInvalidContentDeserializer() { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] SettableBeanProperty prop = createSettableBeanPropertyWithRefName(); [EOL] when(prop.getValueDeserializer()).thenReturn(createContainerDeserializerBaseWithInvalidContentDeserializer()); [EOL] try { [EOL] _resolveManagedReferenceProperty(ctxt, prop); [EOL] fail("IllegalArgumentException expected for invalid content deserializer"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testResolveManagedReferencePropertyWithContainerDeserializerBaseAndBeanDeserializerBase() { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] SettableBeanProperty prop = createSettableBeanPropertyWithRefName(); [EOL] when(prop.getValueDeserializer()).thenReturn(createContainerDeserializerBaseWithBeanDeserializerBase()); [EOL] SettableBeanProperty result = _resolveManagedReferenceProperty(ctxt, prop); [EOL] assertNotNull("Result should not be null for valid ContainerDeserializerBase", result); [EOL] assertTrue("Result should be instance of ManagedReferenceProperty", result instanceof ManagedReferenceProperty); [EOL] }
public void testResolveManagedReferencePropertyWithAbstractDeserializer() { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] SettableBeanProperty prop = createSettableBeanPropertyWithRefName(); [EOL] when(prop.getValueDeserializer()).thenReturn(createAbstractDeserializer()); [EOL] SettableBeanProperty result = _resolveManagedReferenceProperty(ctxt, prop); [EOL] assertNotNull("Result should not be null for AbstractDeserializer", result); [EOL] assertTrue("Result should be instance of ManagedReferenceProperty", result instanceof ManagedReferenceProperty); [EOL] }
public void testResolveManagedReferencePropertyWithInvalidDeserializerType() { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] SettableBeanProperty prop = createSettableBeanPropertyWithRefName(); [EOL] when(prop.getValueDeserializer()).thenReturn(createInvalidDeserializer()); [EOL] try { [EOL] _resolveManagedReferenceProperty(ctxt, prop); [EOL] fail("IllegalArgumentException expected for invalid deserializer type"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testResolveManagedReferencePropertyWithNoBackReferencePropertyFound() { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] SettableBeanProperty prop = createSettableBeanPropertyWithRefName(); [EOL] when(prop.getValueDeserializer()).thenReturn(createDeserializerWithNoBackReference()); [EOL] try { [EOL] _resolveManagedReferenceProperty(ctxt, prop); [EOL] fail("IllegalArgumentException expected when no back reference property is found"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testResolveManagedReferencePropertyWithIncompatibleTypes() { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] SettableBeanProperty prop = createSettableBeanPropertyWithRefName(); [EOL] when(prop.getValueDeserializer()).thenReturn(createDeserializerWithIncompatibleTypes()); [EOL] try { [EOL] _resolveManagedReferenceProperty(ctxt, prop); [EOL] fail("IllegalArgumentException expected for incompatible types"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testResolveUnwrappedPropertyWithNonNullMemberAndUnwrapper() { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] SettableBeanProperty prop = mock(SettableBeanProperty.class); [EOL] AnnotatedMember am = mock(AnnotatedMember.class); [EOL] NameTransformer unwrapper = mock(NameTransformer.class); [EOL] JsonDeserializer<Object> orig = mock(JsonDeserializer.class); [EOL] JsonDeserializer<Object> unwrapping = mock(JsonDeserializer.class); [EOL] when(prop.getMember()).thenReturn(am); [EOL] when(ctxt.getAnnotationIntrospector().findUnwrappingNameTransformer(am)).thenReturn(unwrapper); [EOL] when(prop.getValueDeserializer()).thenReturn(orig); [EOL] when(orig.unwrappingDeserializer(unwrapper)).thenReturn(unwrapping); [EOL] SettableBeanProperty result = _resolveUnwrappedProperty(ctxt, prop); [EOL] assertNotNull(result); [EOL] assertSame(unwrapping, result.getValueDeserializer()); [EOL] }
public void testResolveUnwrappedPropertyWithNonNullMemberAndNoUnwrapper() { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] SettableBeanProperty prop = mock(SettableBeanProperty.class); [EOL] AnnotatedMember am = mock(AnnotatedMember.class); [EOL] when(prop.getMember()).thenReturn(am); [EOL] when(ctxt.getAnnotationIntrospector().findUnwrappingNameTransformer(am)).thenReturn(null); [EOL] SettableBeanProperty result = _resolveUnwrappedProperty(ctxt, prop); [EOL] assertNull(result); [EOL] }
public void testResolveUnwrappedPropertyWithNullMember() { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] SettableBeanProperty prop = mock(SettableBeanProperty.class); [EOL] when(prop.getMember()).thenReturn(null); [EOL] SettableBeanProperty result = _resolveUnwrappedProperty(ctxt, prop); [EOL] assertNull(result); [EOL] }
public void testResolveUnwrappedPropertyWithUnchangedDeserializer() { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] SettableBeanProperty prop = mock(SettableBeanProperty.class); [EOL] AnnotatedMember am = mock(AnnotatedMember.class); [EOL] NameTransformer unwrapper = mock(NameTransformer.class); [EOL] JsonDeserializer<Object> orig = mock(JsonDeserializer.class); [EOL] when(prop.getMember()).thenReturn(am); [EOL] when(ctxt.getAnnotationIntrospector().findUnwrappingNameTransformer(am)).thenReturn(unwrapper); [EOL] when(prop.getValueDeserializer()).thenReturn(orig); [EOL] when(orig.unwrappingDeserializer(unwrapper)).thenReturn(orig); [EOL] SettableBeanProperty result = _resolveUnwrappedProperty(ctxt, prop); [EOL] assertNull(result); [EOL] }
public void testResolveInnerClassValuedPropertyWithNonBeanDeserializer() { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] SettableBeanProperty prop = createSettableBeanPropertyWithNonBeanDeserializer(); [EOL] SettableBeanProperty result = _resolveInnerClassValuedProperty(ctxt, prop); [EOL] assertSame("Property should not change when deserializer is not BeanDeserializerBase", prop, result); [EOL] }
public void testResolveInnerClassValuedPropertyWithBeanDeserializerAndNoDefaultCreator() { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] SettableBeanProperty prop = createSettableBeanPropertyWithBeanDeserializer(); [EOL] mockValueInstantiatorToReturnFalseForCanCreateUsingDefault(prop); [EOL] SettableBeanProperty result = _resolveInnerClassValuedProperty(ctxt, prop); [EOL] assertSame("Property should not change when ValueInstantiator cannot create using default", prop, result); [EOL] }
public void testResolveInnerClassValuedPropertyWithEnclosingClassMismatch() { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] SettableBeanProperty prop = createSettableBeanPropertyWithBeanDeserializer(); [EOL] mockValueInstantiatorToReturnTrueForCanCreateUsingDefault(prop); [EOL] mockPropertyTypeToReturnNonEnclosingClass(prop); [EOL] SettableBeanProperty result = _resolveInnerClassValuedProperty(ctxt, prop); [EOL] assertSame("Property should not change when enclosing class does not match", prop, result); [EOL] }
public void testResolveInnerClassValuedPropertyWithEnclosingClassMatchAndAccessibleConstructor() { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] SettableBeanProperty prop = createSettableBeanPropertyWithBeanDeserializer(); [EOL] mockValueInstantiatorToReturnTrueForCanCreateUsingDefault(prop); [EOL] mockPropertyTypeToReturnEnclosingClass(prop); [EOL] mockConfigToAllowOverrideAccessModifiers(ctxt); [EOL] mockAccessibleConstructorForPropertyType(prop); [EOL] SettableBeanProperty result = _resolveInnerClassValuedProperty(ctxt, prop); [EOL] assertTrue("Property should be replaced with InnerClassProperty when conditions are met", result instanceof InnerClassProperty); [EOL] }
public void testResolveInnerClassValuedPropertyWithEnclosingClassMatchAndInaccessibleConstructor() { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] SettableBeanProperty prop = createSettableBeanPropertyWithBeanDeserializer(); [EOL] mockValueInstantiatorToReturnTrueForCanCreateUsingDefault(prop); [EOL] mockPropertyTypeToReturnEnclosingClass(prop); [EOL] mockConfigToDisallowOverrideAccessModifiers(ctxt); [EOL] mockInaccessibleConstructorForPropertyType(prop); [EOL] SettableBeanProperty result = _resolveInnerClassValuedProperty(ctxt, prop); [EOL] assertSame("Property should not change when constructor is not accessible", prop, result); [EOL] }
public void testIsCachable() { [EOL] ObjectMapper objectMapper = new ObjectMapper(); [EOL] boolean result = objectMapper.isCachable(); [EOL] assertTrue(result); [EOL] }
public void testGetKnownPropertyNames_Empty() { [EOL] BeanPropertyMap beanPropertyMap = new BeanPropertyMap(false, Collections.emptyList(), Collections.emptyMap()); [EOL] Collection<Object> names = beanPropertyMap.getKnownPropertyNames(); [EOL] assertTrue(names.isEmpty()); [EOL] }
public void testGetKnownPropertyNames_NonEmpty() { [EOL] List<SettableBeanProperty> properties = new ArrayList<>(); [EOL] SettableBeanProperty prop1 = mock(SettableBeanProperty.class); [EOL] SettableBeanProperty prop2 = mock(SettableBeanProperty.class); [EOL] when(prop1.getName()).thenReturn("prop1"); [EOL] when(prop2.getName()).thenReturn("prop2"); [EOL] properties.add(prop1); [EOL] properties.add(prop2); [EOL] BeanPropertyMap beanPropertyMap = new BeanPropertyMap(false, properties, Collections.emptyMap()); [EOL] Collection<Object> names = beanPropertyMap.getKnownPropertyNames(); [EOL] assertEquals(2, names.size()); [EOL] assertTrue(names.contains("prop1")); [EOL] assertTrue(names.contains("prop2")); [EOL] }
public void testFindPropertyWithNullBeanProperties() { [EOL] MyClass instance = new MyClass(null, null); // _beanProperties and _propertyBasedCreator are null [EOL] SettableBeanProperty result = instance.findProperty("propertyName"); [EOL] assertNull(result); [EOL] }
public void testFindPropertyWithNonNullBeanPropertiesButPropertyNotFound() { [EOL] BeanProperties mockBeanProperties = mock(BeanProperties.class); [EOL] when(mockBeanProperties.find("propertyName")).thenReturn(null); [EOL] MyClass instance = new MyClass(mockBeanProperties, null); // _propertyBasedCreator is null [EOL] SettableBeanProperty result = instance.findProperty("propertyName"); [EOL] assertNull(result); [EOL] }
public void testFindPropertyWithNonNullBeanPropertiesAndPropertyFound() { [EOL] SettableBeanProperty mockProperty = mock(SettableBeanProperty.class); [EOL] BeanProperties mockBeanProperties = mock(BeanProperties.class); [EOL] when(mockBeanProperties.find("propertyName")).thenReturn(mockProperty); [EOL] MyClass instance = new MyClass(mockBeanProperties, null); // _propertyBasedCreator is null [EOL] SettableBeanProperty result = instance.findProperty("propertyName"); [EOL] assertNotNull(result); [EOL] assertEquals(mockProperty, result); [EOL] }
public void testFindPropertyWithNullBeanPropertiesAndNonNullPropertyBasedCreatorButPropertyNotFound() { [EOL] PropertyBasedCreator mockPropertyBasedCreator = mock(PropertyBasedCreator.class); [EOL] when(mockPropertyBasedCreator.findCreatorProperty("propertyName")).thenReturn(null); [EOL] MyClass instance = new MyClass(null, mockPropertyBasedCreator); [EOL] SettableBeanProperty result = instance.findProperty("propertyName"); [EOL] assertNull(result); [EOL] }
public void testFindPropertyWithNonNullBeanPropertiesAndNonNullPropertyBasedCreatorAndPropertyFoundInCreator() { [EOL] SettableBeanProperty mockProperty = mock(SettableBeanProperty.class); [EOL] BeanProperties mockBeanProperties = mock(BeanProperties.class); [EOL] PropertyBasedCreator mockPropertyBasedCreator = mock(PropertyBasedCreator.class); [EOL] when(mockBeanProperties.find("propertyName")).thenReturn(null); [EOL] when(mockPropertyBasedCreator.findCreatorProperty("propertyName")).thenReturn(mockProperty); [EOL] MyClass instance = new MyClass(mockBeanProperties, mockPropertyBasedCreator); [EOL] SettableBeanProperty result = instance.findProperty("propertyName"); [EOL] assertNotNull(result); [EOL] assertEquals(mockProperty, result); [EOL] }
public void testDeserializeWithTypeWithObjectIdReaderNotNullAndScalarToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] TypeDeserializer typeDeserializer = mock(TypeDeserializer.class); [EOL] ObjectIdReader objectIdReader = mock(ObjectIdReader.class); [EOL] when(_objectIdReader).thenReturn(objectIdReader); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] Object result = deserializeWithType(jp, ctxt, typeDeserializer); [EOL] verify(jp).getCurrentToken(); [EOL] verify(_objectIdReader).deserializeFromObjectId(jp, ctxt); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeWithTypeWithObjectIdReaderNull() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] TypeDeserializer typeDeserializer = mock(TypeDeserializer.class); [EOL] when(_objectIdReader).thenReturn(null); [EOL] Object result = deserializeWithType(jp, ctxt, typeDeserializer); [EOL] verify(typeDeserializer).deserializeTypedFromObject(jp, ctxt); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeWithTypeWithObjectIdReaderNotNullAndNonScalarToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] TypeDeserializer typeDeserializer = mock(TypeDeserializer.class); [EOL] ObjectIdReader objectIdReader = mock(ObjectIdReader.class); [EOL] when(_objectIdReader).thenReturn(objectIdReader); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); [EOL] Object result = deserializeWithType(jp, ctxt, typeDeserializer); [EOL] verify(jp).getCurrentToken(); [EOL] verify(typeDeserializer).deserializeTypedFromObject(jp, ctxt); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeFromObjectIdWithResolvedId() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] ObjectIdReader objectIdReader = mock(ObjectIdReader.class); [EOL] ReadableObjectId roid = mock(ReadableObjectId.class); [EOL] Object expectedPojo = new Object(); [EOL] Object id = new Object(); [EOL] when(objectIdReader.deserializer.deserialize(jp, ctxt)).thenReturn(id); [EOL] when(ctxt.findObjectId(id, objectIdReader.generator)).thenReturn(roid); [EOL] when(roid.item).thenReturn(expectedPojo); [EOL] MyBeanDeserializerBase deserializerBase = new MyBeanDeserializerBase(objectIdReader); [EOL] Object result = deserializerBase.deserializeFromObjectId(jp, ctxt); [EOL] assertEquals(expectedPojo, result); [EOL] }
public void testDeserializeFromObjectIdWithUnresolvedId() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] ObjectIdReader objectIdReader = mock(ObjectIdReader.class); [EOL] ReadableObjectId roid = mock(ReadableObjectId.class); [EOL] Object id = new Object(); [EOL] when(objectIdReader.deserializer.deserialize(jp, ctxt)).thenReturn(id); [EOL] when(ctxt.findObjectId(id, objectIdReader.generator)).thenReturn(roid); [EOL] when(roid.item).thenReturn(null); [EOL] MyBeanDeserializerBase deserializerBase = new MyBeanDeserializerBase(objectIdReader); [EOL] try { [EOL] deserializerBase.deserializeFromObjectId(jp, ctxt); [EOL] fail("Expected IllegalStateException to be thrown"); [EOL] } catch (IllegalStateException e) { [EOL] assertEquals("Could not resolve Object Id [" + id + "] (for " + deserializerBase._beanType + ") -- unresolved forward-reference?", e.getMessage()); [EOL] } [EOL] }
public void testDeserializeFromObjectUsingNonDefaultWithDelegateDeserializer() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] ValueInstantiator valueInstantiator = mock(ValueInstantiator.class); [EOL] JsonDeserializer<Object> delegateDeserializer = mock(JsonDeserializer.class); [EOL] when(_delegateDeserializer.deserialize(jp, ctxt)).thenReturn(new Object()); [EOL] when(_valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt))).thenReturn(new Object()); [EOL] Object result = deserializeFromObjectUsingNonDefault(jp, ctxt); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeFromObjectUsingNonDefaultWithPropertyBasedCreator() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] PropertyBasedCreator propertyBasedCreator = mock(PropertyBasedCreator.class); [EOL] when(_propertyBasedCreator).thenReturn(propertyBasedCreator); [EOL] Object result = deserializeFromObjectUsingNonDefault(jp, ctxt); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeFromObjectUsingNonDefaultWithAbstractBeanType() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JavaType beanType = mock(JavaType.class); [EOL] when(_beanType.isAbstract()).thenReturn(true); [EOL] when(_beanType.toString()).thenReturn("abstractBeanType"); [EOL] Exception exception = assertThrows(JsonMappingException.class, () -> { [EOL] deserializeFromObjectUsingNonDefault(jp, ctxt); [EOL] }); [EOL] assertTrue(exception.getMessage().contains("Can not instantiate abstract type abstractBeanType")); [EOL] }
public void testDeserializeFromObjectUsingNonDefaultWithNoSuitableConstructor() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JavaType beanType = mock(JavaType.class); [EOL] when(_beanType.isAbstract()).thenReturn(false); [EOL] when(_beanType.toString()).thenReturn("noConstructorBeanType"); [EOL] Exception exception = assertThrows(JsonMappingException.class, () -> { [EOL] deserializeFromObjectUsingNonDefault(jp, ctxt); [EOL] }); [EOL] assertTrue(exception.getMessage().contains("No suitable constructor found for type noConstructorBeanType")); [EOL] }
public void testDeserializeFromNumberWithObjectId() throws IOException, JsonProcessingException { [EOL] when(_objectIdReader).thenReturn(mock(ObjectIdReader.class)); [EOL] Object expected = new Object(); [EOL] when(deserializeFromObjectId(jp, ctxt)).thenReturn(expected); [EOL] Object result = deserializeFromNumber(jp, ctxt); [EOL] assertEquals(expected, result); [EOL] }
public void testDeserializeFromNumberWithIntTypeAndDelegateDeserializer() throws IOException, JsonProcessingException { [EOL] when(jp.getNumberType()).thenReturn(JsonParser.NumberType.INT); [EOL] when(_delegateDeserializer).thenReturn(mock(JsonDeserializer.class)); [EOL] when(_valueInstantiator.canCreateFromInt()).thenReturn(false); [EOL] Object delegateResult = new Object(); [EOL] when(_delegateDeserializer.deserialize(jp, ctxt)).thenReturn(delegateResult); [EOL] Object expected = new Object(); [EOL] when(_valueInstantiator.createUsingDelegate(ctxt, delegateResult)).thenReturn(expected); [EOL] Object result = deserializeFromNumber(jp, ctxt); [EOL] assertEquals(expected, result); [EOL] }
public void testDeserializeFromNumberWithIntTypeWithoutDelegateDeserializer() throws IOException, JsonProcessingException { [EOL] when(jp.getNumberType()).thenReturn(JsonParser.NumberType.INT); [EOL] when(_delegateDeserializer).thenReturn(null); [EOL] when(_valueInstantiator.canCreateFromInt()).thenReturn(true); [EOL] int intValue = 123; [EOL] when(jp.getIntValue()).thenReturn(intValue); [EOL] Object expected = new Object(); [EOL] when(_valueInstantiator.createFromInt(ctxt, intValue)).thenReturn(expected); [EOL] Object result = deserializeFromNumber(jp, ctxt); [EOL] assertEquals(expected, result); [EOL] }
public void testDeserializeFromNumberWithLongTypeAndDelegateDeserializer() throws IOException, JsonProcessingException { [EOL] when(jp.getNumberType()).thenReturn(JsonParser.NumberType.LONG); [EOL] when(_delegateDeserializer).thenReturn(mock(JsonDeserializer.class)); [EOL] when(_valueInstantiator.canCreateFromInt()).thenReturn(false); [EOL] Object delegateResult = new Object(); [EOL] when(_delegateDeserializer.deserialize(jp, ctxt)).thenReturn(delegateResult); [EOL] Object expected = new Object(); [EOL] when(_valueInstantiator.createUsingDelegate(ctxt, delegateResult)).thenReturn(expected); [EOL] Object result = deserializeFromNumber(jp, ctxt); [EOL] assertEquals(expected, result); [EOL] }
public void testDeserializeFromNumberWithLongTypeWithoutDelegateDeserializer() throws IOException, JsonProcessingException { [EOL] when(jp.getNumberType()).thenReturn(JsonParser.NumberType.LONG); [EOL] when(_delegateDeserializer).thenReturn(null); [EOL] when(_valueInstantiator.canCreateFromInt()).thenReturn(true); [EOL] long longValue = 123L; [EOL] when(jp.getLongValue()).thenReturn(longValue); [EOL] Object expected = new Object(); [EOL] when(_valueInstantiator.createFromLong(ctxt, longValue)).thenReturn(expected); [EOL] Object result = deserializeFromNumber(jp, ctxt); [EOL] assertEquals(expected, result); [EOL] }
public void testDeserializeFromNumberWithDelegateDeserializerButNoSuitableCreator() throws IOException, JsonProcessingException { [EOL] when(_delegateDeserializer).thenReturn(mock(JsonDeserializer.class)); [EOL] when(jp.getNumberType()).thenReturn(null); // Simulate no matching number type [EOL] Object delegateResult = new Object(); [EOL] when(_delegateDeserializer.deserialize(jp, ctxt)).thenReturn(delegateResult); [EOL] Object expected = new Object(); [EOL] when(_valueInstantiator.createUsingDelegate(ctxt, delegateResult)).thenReturn(expected); [EOL] Object result = deserializeFromNumber(jp, ctxt); [EOL] assertEquals(expected, result); [EOL] }
public void testDeserializeFromNumberWithNoSuitableCreatorThrowsException() throws IOException, JsonProcessingException { [EOL] when(_delegateDeserializer).thenReturn(null); [EOL] when(jp.getNumberType()).thenReturn(null); // Simulate no matching number type [EOL] assertThrows(JsonMappingException.class, () -> { [EOL] deserializeFromNumber(jp, ctxt); [EOL] }); [EOL] }
public void testDeserializeFromStringWithObjectId() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(_objectIdReader).thenReturn(mock(ObjectIdReader.class)); [EOL] Object expected = new Object(); [EOL] when(deserializeFromObjectId(jp, ctxt)).thenReturn(expected); [EOL] Object result = deserializeFromString(jp, ctxt); [EOL] assertSame(expected, result); [EOL] }
public void testDeserializeFromStringWithDelegate() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(_delegateDeserializer).thenReturn(mock(JsonDeserializer.class)); [EOL] when(_valueInstantiator.canCreateFromString()).thenReturn(false); [EOL] Object delegateResult = new Object(); [EOL] when(_delegateDeserializer.deserialize(jp, ctxt)).thenReturn(delegateResult); [EOL] Object expected = new Object(); [EOL] when(_valueInstantiator.createUsingDelegate(ctxt, delegateResult)).thenReturn(expected); [EOL] Object result = deserializeFromString(jp, ctxt); [EOL] assertSame(expected, result); [EOL] }
public void testDeserializeFromStringCreateFromString() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(_objectIdReader).thenReturn(null); [EOL] when(_delegateDeserializer).thenReturn(null); [EOL] when(_valueInstantiator.canCreateFromString()).thenReturn(true); [EOL] String text = "some text"; [EOL] when(jp.getText()).thenReturn(text); [EOL] Object expected = new Object(); [EOL] when(_valueInstantiator.createFromString(ctxt, text)).thenReturn(expected); [EOL] Object result = deserializeFromString(jp, ctxt); [EOL] assertSame(expected, result); [EOL] }
public void testDeserializeFromDoubleWithDelegateDeserializerAndCannotCreateFromDouble() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getNumberType()).thenReturn(JsonParser.NumberType.DOUBLE); [EOL] when(_delegateDeserializer.deserialize(jp, ctxt)).thenReturn(new Object()); [EOL] when(_valueInstantiator.canCreateFromDouble()).thenReturn(false); [EOL] when(_valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt))).thenReturn(new Object()); [EOL] Object result = deserializeFromDouble(jp, ctxt); [EOL] assertNotNull(result); [EOL] verify(_valueInstantiator, times(1)).createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL] }
public void testDeserializeFromDoubleWithDelegateDeserializerAndCanCreateFromDouble() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getNumberType()).thenReturn(JsonParser.NumberType.DOUBLE); [EOL] when(jp.getDoubleValue()).thenReturn(0.0); [EOL] when(_delegateDeserializer.deserialize(jp, ctxt)).thenReturn(new Object()); [EOL] when(_valueInstantiator.canCreateFromDouble()).thenReturn(true); [EOL] Object result = deserializeFromDouble(jp, ctxt); [EOL] assertNotNull(result); [EOL] verify(_valueInstantiator, times(1)).createFromDouble(ctxt, jp.getDoubleValue()); [EOL] }
public void testDeserializeFromDoubleWithoutDelegateDeserializer() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getNumberType()).thenReturn(JsonParser.NumberType.DOUBLE); [EOL] when(jp.getDoubleValue()).thenReturn(0.0); [EOL] when(_valueInstantiator.canCreateFromDouble()).thenReturn(true); [EOL] Object result = deserializeFromDouble(jp, ctxt); [EOL] assertNotNull(result); [EOL] verify(_valueInstantiator, times(1)).createFromDouble(ctxt, jp.getDoubleValue()); [EOL] }
public void testDeserializeFromDoubleThrowsException() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getNumberType()).thenReturn(JsonParser.NumberType.INT); // Use a type that is not FLOAT or DOUBLE [EOL] when(_delegateDeserializer.deserialize(jp, ctxt)).thenReturn(new Object()); [EOL] assertThrows(JsonMappingException.class, () -> { [EOL] deserializeFromDouble(jp, ctxt); [EOL] }); [EOL] }
public void testDeserializeFromBooleanWithDelegateDeserializerAndCannotCreateFromBoolean() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] ValueInstantiator valueInstantiator = mock(ValueInstantiator.class); [EOL] JsonDeserializer<Object> delegateDeserializer = mock(JsonDeserializer.class); [EOL] when(_delegateDeserializer).thenReturn(delegateDeserializer); [EOL] when(_valueInstantiator).thenReturn(valueInstantiator); [EOL] when(valueInstantiator.canCreateFromBoolean()).thenReturn(false); [EOL] when(delegateDeserializer.deserialize(jp, ctxt)).thenReturn(new Object()); [EOL] when(valueInstantiator.createUsingDelegate(ctxt, new Object())).thenReturn(new Object()); [EOL] Object result = deserializeFromBoolean(jp, ctxt); [EOL] assertNotNull(result); [EOL] verify(valueInstantiator).createUsingDelegate(ctxt, new Object()); [EOL] if (_injectables != null) { [EOL] verify(this).injectValues(ctxt, result); [EOL] } [EOL] }
public void testDeserializeFromBooleanWithDelegateDeserializerAndCanCreateFromBoolean() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] ValueInstantiator valueInstantiator = mock(ValueInstantiator.class); [EOL] JsonDeserializer<Object> delegateDeserializer = mock(JsonDeserializer.class); [EOL] when(_delegateDeserializer).thenReturn(delegateDeserializer); [EOL] when(_valueInstantiator).thenReturn(valueInstantiator); [EOL] when(valueInstantiator.canCreateFromBoolean()).thenReturn(true); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_TRUE); [EOL] Object result = deserializeFromBoolean(jp, ctxt); [EOL] assertNotNull(result); [EOL] verify(valueInstantiator).createFromBoolean(ctxt, true); [EOL] }
public void testDeserializeFromBooleanWithoutDelegateDeserializer() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] ValueInstantiator valueInstantiator = mock(ValueInstantiator.class); [EOL] when(_delegateDeserializer).thenReturn(null); [EOL] when(_valueInstantiator).thenReturn(valueInstantiator); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_FALSE); [EOL] Object result = deserializeFromBoolean(jp, ctxt); [EOL] assertNotNull(result); [EOL] verify(valueInstantiator).createFromBoolean(ctxt, false); [EOL] }
public void testDeserializeFromArrayWithDelegateDeserializer() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] ValueInstantiator valueInstantiator = mock(ValueInstantiator.class); [EOL] JsonDeserializer<Object> delegateDeserializer = mock(JsonDeserializer.class); [EOL] InjectableValues injectables = mock(InjectableValues.class); [EOL] Object expectedBean = new Object(); [EOL] when(_delegateDeserializer.deserialize(jp, ctxt)).thenReturn(expectedBean); [EOL] when(_valueInstantiator.createUsingDelegate(ctxt, expectedBean)).thenReturn(expectedBean); [EOL] setField(_beanDeserializer, "_delegateDeserializer", delegateDeserializer); [EOL] setField(_beanDeserializer, "_valueInstantiator", valueInstantiator); [EOL] setField(_beanDeserializer, "_injectables", injectables); [EOL] Object result = _beanDeserializer.deserializeFromArray(jp, ctxt); [EOL] verify(injectables).injectValues(ctxt, expectedBean); [EOL] assertEquals(expectedBean, result); [EOL] }
public void testDeserializeFromArrayWithoutDelegateDeserializer() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] setField(_beanDeserializer, "_delegateDeserializer", null); [EOL] try { [EOL] _beanDeserializer.deserializeFromArray(jp, ctxt); [EOL] fail("Expected mappingException to be thrown"); [EOL] } catch (JsonMappingException e) { [EOL] } [EOL] }
public void testDeserializeFromArrayWithDelegateDeserializerThrowsException() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] ValueInstantiator valueInstantiator = mock(ValueInstantiator.class); [EOL] JsonDeserializer<Object> delegateDeserializer = mock(JsonDeserializer.class); [EOL] when(_delegateDeserializer.deserialize(jp, ctxt)).thenThrow(new IOException()); [EOL] setField(_beanDeserializer, "_delegateDeserializer", delegateDeserializer); [EOL] setField(_beanDeserializer, "_valueInstantiator", valueInstantiator); [EOL] try { [EOL] _beanDeserializer.deserializeFromArray(jp, ctxt); [EOL] fail("Expected wrapInstantiationProblem to be called"); [EOL] } catch (JsonMappingException e) { [EOL] } [EOL] }
public void testHandleUnknownPropertyWithIgnoreAllUnknown() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object beanOrClass = new Object(); [EOL] String propName = "unknownProperty"; [EOL] MyBeanDeserializer deserializer = new MyBeanDeserializer(); [EOL] deserializer._ignoreAllUnknown = true; [EOL] deserializer.handleUnknownProperty(jp, ctxt, beanOrClass, propName); [EOL] verify(jp).skipChildren(); [EOL] }
public void testHandleUnknownPropertyWithIgnorableProps() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object beanOrClass = new Object(); [EOL] String propName = "ignorableProperty"; [EOL] MyBeanDeserializer deserializer = new MyBeanDeserializer(); [EOL] deserializer._ignorableProps = new HashSet<>(); [EOL] deserializer._ignorableProps.add(propName); [EOL] deserializer.handleUnknownProperty(jp, ctxt, beanOrClass, propName); [EOL] verify(jp).skipChildren(); [EOL] }
public void testHandleUnknownPropertyWithoutIgnore() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object beanOrClass = new Object(); [EOL] String propName = "notIgnoredProperty"; [EOL] MyBeanDeserializer deserializer = new MyBeanDeserializer(); [EOL] deserializer.handleUnknownProperty(jp, ctxt, beanOrClass, propName); [EOL] verify(jp, never()).skipChildren(); [EOL] verify(ctxt).handleUnknownProperty(jp, beanOrClass, propName); [EOL] }
public void testAsArrayDeserializer() { [EOL] BeanAsArrayBuilderDeserializerTest testInstance = new BeanAsArrayBuilderDeserializerTest(); [EOL] BeanAsArrayBuilderDeserializer result = testInstance.asArrayDeserializer(); [EOL] assertNotNull(result); [EOL] assertArrayEquals(testInstance._beanProperties.getPropertiesInInsertionOrder(), result._properties); [EOL] assertEquals(testInstance._buildMethod, result._buildMethod); [EOL] }
public void testDeserializeWithInjectables() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object builder = new Object(); [EOL] _injectables = new InjectableValues.Std(); [EOL] injectValues(ctxt, builder); // Assuming this method is implemented somewhere [EOL] Object result = _deserialize(jp, ctxt, builder); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeWithUnwrapped() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object builder = new Object(); [EOL] _unwrappedPropertyHandler = mock(UnwrappedPropertyHandler.class); [EOL] when(_unwrappedPropertyHandler.deserializeWithUnwrapped(jp, ctxt, builder)).thenReturn(builder); [EOL] Object result = _deserialize(jp, ctxt, builder); [EOL] assertSame(builder, result); [EOL] }
public void testDeserializeWithExternalTypeId() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object builder = new Object(); [EOL] _externalTypeIdHandler = mock(ExternalTypeIdHandler.class); [EOL] when(_externalTypeIdHandler.deserializeWithExternalTypeId(jp, ctxt, builder)).thenReturn(builder); [EOL] Object result = _deserialize(jp, ctxt, builder); [EOL] assertSame(builder, result); [EOL] }
public void testDeserializeWithView() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object builder = new Object(); [EOL] _needViewProcesing = true; [EOL] Class<?> view = Object.class; [EOL] when(ctxt.getActiveView()).thenReturn(view); [EOL] Object result = _deserialize(jp, ctxt, builder); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeWithStartObjectToken() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object builder = new Object(); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); [EOL] when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); [EOL] Object result = _deserialize(jp, ctxt, builder); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeWithFieldNameToken() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object builder = new Object(); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.FIELD_NAME); [EOL] when(jp.nextToken()).thenReturn(JsonToken.END_OBJECT); [EOL] when(jp.getCurrentName()).thenReturn("fieldName"); [EOL] SettableBeanProperty prop = mock(SettableBeanProperty.class); [EOL] _beanProperties = mock(BeanPropertyMap.class); [EOL] when(_beanProperties.find("fieldName")).thenReturn(prop); [EOL] when(prop.deserializeSetAndReturn(jp, ctxt, builder)).thenReturn(builder); [EOL] Object result = _deserialize(jp, ctxt, builder); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeWithIgnorableProps() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object builder = new Object(); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.FIELD_NAME); [EOL] when(jp.nextToken()).thenReturn(JsonToken.END_OBJECT); [EOL] when(jp.getCurrentName()).thenReturn("ignorableProp"); [EOL] _ignorableProps = new HashSet<>(); [EOL] _ignorableProps.add("ignorableProp"); [EOL] Object result = _deserialize(jp, ctxt, builder); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeWithAnySetter() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object builder = new Object(); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.FIELD_NAME); [EOL] when(jp.nextToken()).thenReturn(JsonToken.END_OBJECT); [EOL] when(jp.getCurrentName()).thenReturn("anySetterProp"); [EOL] _anySetter = mock(AnySetter.class); [EOL] doNothing().when(_anySetter).deserializeAndSet(jp, ctxt, builder, "anySetterProp"); [EOL] Object result = _deserialize(jp, ctxt, builder); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeHandleUnknownProperty() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object builder = new Object(); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.FIELD_NAME); [EOL] when(jp.nextToken()).thenReturn(JsonToken.END_OBJECT); [EOL] when(jp.getCurrentName()).thenReturn("unknownProp"); [EOL] doNothing().when(this).handleUnknownProperty(jp, ctxt, builder, "unknownProp"); [EOL] Object result = _deserialize(jp, ctxt, builder); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeFromObjectWithNonStandardCreationAndUnwrapped() throws IOException, JsonProcessingException { [EOL] setupNonStandardCreationWithUnwrapped(); [EOL] JsonParser jp = createJsonParser(); [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] Object result = deserializeFromObject(jp, ctxt); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeFromObjectWithNonStandardCreationAndExternalTypeId() throws IOException, JsonProcessingException { [EOL] setupNonStandardCreationWithExternalTypeId(); [EOL] JsonParser jp = createJsonParser(); [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] Object result = deserializeFromObject(jp, ctxt); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeFromObjectUsingNonDefault() throws IOException, JsonProcessingException { [EOL] setupNonStandardCreationWithoutHandlers(); [EOL] JsonParser jp = createJsonParser(); [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] Object result = deserializeFromObject(jp, ctxt); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeFromObjectWithInjectables() throws IOException, JsonProcessingException { [EOL] setupWithInjectables(); [EOL] JsonParser jp = createJsonParser(); [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] Object bean = _valueInstantiator.createUsingDefault(ctxt); [EOL] injectValues(ctxt, bean); [EOL] assertInjectablesSet(bean); [EOL] }
public void testDeserializeFromObjectWithViewProcessing() throws IOException, JsonProcessingException { [EOL] setupWithViewProcessing(); [EOL] JsonParser jp = createJsonParser(); [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] Class<?> view = createViewClass(); [EOL] Object bean = _valueInstantiator.createUsingDefault(ctxt); [EOL] Object result = deserializeWithView(jp, ctxt, bean, view); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeFromObjectWithKnownProperties() throws IOException, JsonProcessingException { [EOL] setupWithKnownProperties(); [EOL] JsonParser jp = createJsonParser(); [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] Object bean = _valueInstantiator.createUsingDefault(ctxt); [EOL] jp.nextToken(); // Move to the first property [EOL] String propName = jp.getCurrentName(); [EOL] jp.nextToken(); // Move to the value of the property [EOL] SettableBeanProperty prop = _beanProperties.find(propName); [EOL] bean = prop.deserializeSetAndReturn(jp, ctxt, bean); [EOL] assertKnownPropertySet(bean, propName); [EOL] }
public void testDeserializeFromObjectWithIgnorableProperties() throws IOException, JsonProcessingException { [EOL] setupWithIgnorableProperties(); [EOL] JsonParser jp = createJsonParser(); [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] Object bean = _valueInstantiator.createUsingDefault(ctxt); [EOL] jp.nextToken(); // Move to the ignorable property [EOL] String propName = jp.getCurrentName(); [EOL] jp.nextToken(); // Move to the value of the property [EOL] jp.skipChildren(); // Skip the ignorable property [EOL] assertIgnorablePropertySkipped(bean, propName); [EOL] }
public void testDeserializeFromObjectWithAnySetter() throws IOException, JsonProcessingException { [EOL] setupWithAnySetter(); [EOL] JsonParser jp = createJsonParser(); [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] Object bean = _valueInstantiator.createUsingDefault(ctxt); [EOL] jp.nextToken(); // Move to the property handled by any setter [EOL] String propName = jp.getCurrentName(); [EOL] jp.nextToken(); // Move to the value of the property [EOL] _anySetter.deserializeAndSet(jp, ctxt, bean, propName); [EOL] assertAnySetterCalled(bean, propName); [EOL] }
public void testDeserializeFromObjectWithUnknownProperties() throws IOException, JsonProcessingException { [EOL] setupWithUnknownProperties(); [EOL] JsonParser jp = createJsonParser(); [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] Object bean = _valueInstantiator.createUsingDefault(ctxt); [EOL] jp.nextToken(); // Move to the unknown property [EOL] String propName = jp.getCurrentName(); [EOL] jp.nextToken(); // Move to the value of the property [EOL] handleUnknownProperty(jp, ctxt, bean, propName); [EOL] assertUnknownPropertyHandled(bean, propName); [EOL] }
public void testDeserializeUsingPropertyBased() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.FIELD_NAME, JsonToken.END_OBJECT); [EOL] when(jp.getCurrentName()).thenReturn("propName"); [EOL] when(jp.nextToken()).thenReturn(JsonToken.VALUE_STRING, JsonToken.END_OBJECT); [EOL] Object result = _deserializeUsingPropertyBased(jp, ctxt); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeUsingPropertyBasedWithCreatorProp() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.FIELD_NAME, JsonToken.END_OBJECT); [EOL] when(jp.getCurrentName()).thenReturn("creatorPropName"); [EOL] when(jp.nextToken()).thenReturn(JsonToken.VALUE_STRING, JsonToken.END_OBJECT); [EOL] Object result = _deserializeUsingPropertyBased(jp, ctxt); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeUsingPropertyBasedWithIgnorableProps() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.FIELD_NAME, JsonToken.END_OBJECT); [EOL] when(jp.getCurrentName()).thenReturn("ignorablePropName"); [EOL] when(jp.nextToken()).thenReturn(JsonToken.VALUE_STRING, JsonToken.END_OBJECT); [EOL] Object result = _deserializeUsingPropertyBased(jp, ctxt); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeUsingPropertyBasedWithAnySetter() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.FIELD_NAME, JsonToken.END_OBJECT); [EOL] when(jp.getCurrentName()).thenReturn("anySetterPropName"); [EOL] when(jp.nextToken()).thenReturn(JsonToken.VALUE_STRING, JsonToken.END_OBJECT); [EOL] Object result = _deserializeUsingPropertyBased(jp, ctxt); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeUsingPropertyBasedWithUnknownProperties() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.FIELD_NAME, JsonToken.END_OBJECT); [EOL] when(jp.getCurrentName()).thenReturn("unknownPropName"); [EOL] when(jp.nextToken()).thenReturn(JsonToken.VALUE_STRING, JsonToken.END_OBJECT); [EOL] Object result = _deserializeUsingPropertyBased(jp, ctxt); [EOL] assertNotNull(result); [EOL] }
public void testConstructWithNullViews() { [EOL] ViewMatcher result = ViewMatcher.construct(null); [EOL] assertTrue(result instanceof ViewMatcher.Empty); [EOL] }
public void testConstructWithEmptyViewsArray() { [EOL] ViewMatcher result = ViewMatcher.construct(new Class<?>[0]); [EOL] assertTrue(result instanceof ViewMatcher.Empty); [EOL] }
public void testConstructWithSingleView() { [EOL] Class<?>[] singleView = {Object.class}; [EOL] ViewMatcher result = ViewMatcher.construct(singleView); [EOL] assertTrue(result instanceof ViewMatcher.Single); [EOL] assertEquals(Object.class, ((ViewMatcher.Single) result).getView()); [EOL] }
public void testConstructWithMultipleViews() { [EOL] Class<?>[] multipleViews = {Object.class, String.class}; [EOL] ViewMatcher result = ViewMatcher.construct(multipleViews); [EOL] assertTrue(result instanceof ViewMatcher.Multi); [EOL] assertArrayEquals(multipleViews, ((ViewMatcher.Multi) result).getViews()); [EOL] }
public void testMultiConstructorWithNull() { [EOL] Multi multi = new Multi(null); [EOL] assertNull(multi._views); [EOL] }
public void testMultiConstructorWithEmptyArray() { [EOL] Multi multi = new Multi(new Class<?>[0]); [EOL] assertEquals(0, multi._views.length); [EOL] }
public void testMultiConstructorWithNonEmptyArray() { [EOL] Class<?>[] views = {String.class, Integer.class}; [EOL] Multi multi = new Multi(views); [EOL] assertArrayEquals(views, multi._views); [EOL] }
public void testIsVisibleForViewWithExactMatch() { [EOL] Class<?>[] views = new Class<?>[] {String.class, Integer.class}; [EOL] VisibilityChecker checker = new VisibilityChecker(views); [EOL] boolean result = checker.isVisibleForView(String.class); [EOL] assertTrue(result); [EOL] } [EOL] public void testIsVisibleForViewWithAssignableMatch() { [EOL] Class<?>[] views = new Class<?>[] {Number.class, Integer.class}; [EOL] VisibilityChecker checker = new VisibilityChecker(views); [EOL] boolean result = checker.isVisibleForView(Integer.class); [EOL] assertTrue(result); [EOL] } [EOL] public void testIsVisibleForViewWithNoMatch() { [EOL] Class<?>[] views = new Class<?>[] {String.class, Integer.class}; [EOL] VisibilityChecker checker = new VisibilityChecker(views); [EOL] boolean result = checker.isVisibleForView(Double.class); [EOL] assertFalse(result); [EOL] }
public void testBeanDeserializerFactoryConstructor() { [EOL] DeserializerFactoryConfig config = new DeserializerFactoryConfig(); [EOL] BeanDeserializerFactory factory = new BeanDeserializerFactory(config); [EOL] assertNotNull(factory); [EOL] }
public void testWithConfig() { [EOL] DeserializerFactoryConfig config = new DeserializerFactoryConfig(); [EOL] BeanDeserializerFactory factory = new BeanDeserializerFactory(config); [EOL] DeserializerFactoryConfig newConfig = new DeserializerFactoryConfig(); [EOL] DeserializerFactory factoryWithNewConfig = factory.withConfig(newConfig); [EOL] assertNotNull(factoryWithNewConfig); [EOL] }
public void testFindCustomBeanDeserializer() throws JsonMappingException { [EOL] JavaType type = mock(JavaType.class); [EOL] DeserializationConfig deserializationConfig = mock(DeserializationConfig.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] BeanDeserializerFactory factory = new BeanDeserializerFactory(new DeserializerFactoryConfig()); [EOL] JsonDeserializer<Object> deserializer = factory._findCustomBeanDeserializer(type, deserializationConfig, beanDesc); [EOL] assertNull(deserializer); [EOL] }
public void testCreateBeanDeserializer() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JavaType type = mock(JavaType.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] BeanDeserializerFactory factory = new BeanDeserializerFactory(new DeserializerFactoryConfig()); [EOL] JsonDeserializer<Object> deserializer = factory.createBeanDeserializer(ctxt, type, beanDesc); [EOL] assertNotNull(deserializer); [EOL] }
public void testCreateBuilderBasedDeserializer() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JavaType valueType = mock(JavaType.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] Class<?> builderClass = Object.class; [EOL] BeanDeserializerFactory factory = new BeanDeserializerFactory(new DeserializerFactoryConfig()); [EOL] JsonDeserializer<Object> deserializer = factory.createBuilderBasedDeserializer(ctxt, valueType, beanDesc, builderClass); [EOL] assertNotNull(deserializer); [EOL] }
public void testFindStdDeserializer() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JavaType type = mock(JavaType.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] BeanDeserializerFactory factory = new BeanDeserializerFactory(new DeserializerFactoryConfig()); [EOL] JsonDeserializer<?> deserializer = factory.findStdDeserializer(ctxt, type, beanDesc); [EOL] assertNull(deserializer); [EOL] }
public void testFindOptionalStdDeserializer() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JavaType type = mock(JavaType.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] BeanDeserializerFactory factory = new BeanDeserializerFactory(new DeserializerFactoryConfig()); [EOL] JsonDeserializer<?> deserializer = factory.findOptionalStdDeserializer(ctxt, type, beanDesc); [EOL] assertNull(deserializer); [EOL] }
public void testMaterializeAbstractType() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JavaType type = mock(JavaType.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] BeanDeserializerFactory factory = new BeanDeserializerFactory(new DeserializerFactoryConfig()); [EOL] JavaType materializedType = factory.materializeAbstractType(ctxt, type, beanDesc); [EOL] assertNull(materializedType); [EOL] }
public void testBuildBeanDeserializer() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JavaType type = mock(JavaType.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] BeanDeserializerFactory factory = new BeanDeserializerFactory(new DeserializerFactoryConfig()); [EOL] JsonDeserializer<Object> deserializer = factory.buildBeanDeserializer(ctxt, type, beanDesc); [EOL] assertNotNull(deserializer); [EOL] }
public void testBuildBuilderBasedDeserializer() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JavaType valueType = mock(JavaType.class); [EOL] BeanDescription builderDesc = mock(BeanDescription.class); [EOL] BeanDeserializerFactory factory = new BeanDeserializerFactory(new DeserializerFactoryConfig()); [EOL] JsonDeserializer<Object> deserializer = factory.buildBuilderBasedDeserializer(ctxt, valueType, builderDesc); [EOL] assertNotNull(deserializer); [EOL] }
public void testAddObjectIdReader() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] BeanDeserializerBuilder builder = mock(BeanDeserializerBuilder.class); [EOL] BeanDeserializerFactory factory = new BeanDeserializerFactory(new DeserializerFactoryConfig()); [EOL] factory.addObjectIdReader(ctxt, beanDesc, builder); [EOL] }
public void testBuildThrowableDeserializer() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JavaType type = mock(JavaType.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] BeanDeserializerFactory factory = new BeanDeserializerFactory(new DeserializerFactoryConfig()); [EOL] JsonDeserializer<Object> deserializer = factory.buildThrowableDeserializer(ctxt, type, beanDesc); [EOL] assertNotNull(deserializer); [EOL] }
public void testConstructBeanDeserializerBuilder() { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] BeanDeserializerFactory factory = new BeanDeserializerFactory(new DeserializerFactoryConfig()); [EOL] BeanDeserializerBuilder builder = factory.constructBeanDeserializerBuilder(ctxt, beanDesc); [EOL] assertNotNull(builder); [EOL] }
public void testAddBeanProps() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] BeanDeserializerBuilder builder = mock(BeanDeserializerBuilder.class); [EOL] BeanDeserializerFactory factory = new BeanDeserializerFactory(new DeserializerFactoryConfig()); [EOL] factory.addBeanProps(ctxt, beanDesc, builder); [EOL] }
public void testFilterBeanProps() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] BeanDeserializerBuilder builder = mock(BeanDeserializerBuilder.class); [EOL] List<BeanPropertyDefinition> propDefsIn = new ArrayList<>(); [EOL] Set<String> ignored = new HashSet<>(); [EOL] BeanDeserializerFactory factory = new BeanDeserializerFactory(new DeserializerFactoryConfig()); [EOL] List<BeanPropertyDefinition> filteredProps = factory.filterBeanProps(ctxt, beanDesc, builder, propDefsIn, ignored); [EOL] assertNotNull(filteredProps); [EOL] }
public void testAddReferenceProperties() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] BeanDeserializerBuilder builder = mock(BeanDeserializerBuilder.class); [EOL] BeanDeserializerFactory factory = new BeanDeserializerFactory(new DeserializerFactoryConfig()); [EOL] factory.addReferenceProperties(ctxt, beanDesc, builder); [EOL] }
public void testAddInjectables() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] BeanDeserializerBuilder builder = mock(BeanDeserializerBuilder.class); [EOL] BeanDeserializerFactory factory = new BeanDeserializerFactory(new DeserializerFactoryConfig()); [EOL] factory.addInjectables(ctxt, beanDesc, builder); [EOL] }
public void testConstructAnySetter() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] AnnotatedMethod setter = mock(AnnotatedMethod.class); [EOL] BeanDeserializerFactory factory = new BeanDeserializerFactory(new DeserializerFactoryConfig()); [EOL] SettableAnyProperty anyProperty = factory.constructAnySetter(ctxt, beanDesc, setter); [EOL] assertNotNull(anyProperty); [EOL] }
public void testConstructSettableProperty() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] BeanPropertyDefinition propDef = mock(BeanPropertyDefinition.class); [EOL] Type jdkType = mock(Type.class); [EOL] BeanDeserializerFactory factory = new BeanDeserializerFactory(new DeserializerFactoryConfig()); [EOL] SettableBeanProperty property = factory.constructSettableProperty(ctxt, beanDesc, propDef, jdkType); [EOL] assertNotNull(property); [EOL] }
public void testConstructSetterlessProperty() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] BeanPropertyDefinition propDef = mock(BeanPropertyDefinition.class); [EOL] BeanDeserializerFactory factory = new BeanDeserializerFactory(new DeserializerFactoryConfig()); [EOL] SettableBeanProperty property = factory.constructSetterlessProperty(ctxt, beanDesc, propDef); [EOL] assertNotNull(property); [EOL] }
public void testIsPotentialBeanType() { [EOL] Class<?> type = Object.class; [EOL] BeanDeserializerFactory factory = new BeanDeserializerFactory(new DeserializerFactoryConfig()); [EOL] boolean isPotentialBean = factory.isPotentialBeanType(type); [EOL] assertFalse(isPotentialBean); [EOL] }
public void testIsIgnorableType() { [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] Class<?> type = Object.class; [EOL] Map<Class<?>, Boolean> ignoredTypes = new HashMap<>(); [EOL] BeanDeserializerFactory factory = new BeanDeserializerFactory(new DeserializerFactoryConfig()); [EOL] boolean isIgnorable = factory.isIgnorableType(config, beanDesc, type, ignoredTypes); [EOL] assertFalse(isIgnorable); [EOL] }
@Override [EOL] public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException { [EOL] final DeserializationConfig config = ctxt.getConfig(); [EOL] JsonDeserializer<Object> custom = _findCustomBeanDeserializer(type, config, beanDesc); [EOL] if (custom != null) { [EOL] return custom; [EOL] } [EOL] if (type.isThrowable()) { [EOL] return buildThrowableDeserializer(ctxt, type, beanDesc); [EOL] } [EOL] if (type.isAbstract()) { [EOL] JavaType concreteType = materializeAbstractType(ctxt, type, beanDesc); [EOL] if (concreteType != null) { [EOL] beanDesc = config.introspect(concreteType); [EOL] return buildBeanDeserializer(ctxt, concreteType, beanDesc); [EOL] } [EOL] } [EOL] @SuppressWarnings("unchecked") [EOL] JsonDeserializer<Object> deser = (JsonDeserializer<Object>) findStdDeserializer(ctxt, type, beanDesc); [EOL] if (deser != null) { [EOL] return deser; [EOL] } [EOL] if (!isPotentialBeanType(type.getRawClass())) { [EOL] return null; [EOL] } [EOL] return buildBeanDeserializer(ctxt, type, beanDesc); [EOL] } [EOL] public BeanDeserializerFactory(DeserializerFactoryConfig config); [EOL] public DeserializerFactory withConfig(DeserializerFactoryConfig config); [EOL] protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; [EOL] public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; [EOL] public JsonDeserializer<Object> createBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription beanDesc, Class<?> builderClass) throws JsonMappingException; [EOL] protected JsonDeserializer<?> findStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; [EOL] protected JsonDeserializer<?> findOptionalStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; [EOL] protected JavaType materializeAbstractType(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; [EOL] public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; [EOL] protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException; [EOL] protected void addObjectIdReader(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; [EOL] public JsonDeserializer<Object> buildThrowableDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; [EOL] protected BeanDeserializerBuilder constructBeanDeserializerBuilder(DeserializationContext ctxt, BeanDescription beanDesc); [EOL] protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; [EOL] protected List<BeanPropertyDefinition> filterBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder, List<BeanPropertyDefinition> propDefsIn, Set<String> ignored) throws JsonMappingException; [EOL] protected void addReferenceProperties(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; [EOL] protected void addInjectables(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; [EOL] protected SettableAnyProperty constructAnySetter(DeserializationContext ctxt, BeanDescription beanDesc, AnnotatedMethod setter) throws JsonMappingException; [EOL] protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef, Type jdkType) throws JsonMappingException; [EOL] protected SettableBeanProperty constructSetterlessProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef) throws JsonMappingException; [EOL] protected boolean isPotentialBeanType(Class<?> type); [EOL] protected boolean isIgnorableType(DeserializationConfig config, BeanDescription beanDesc, Class<?> type, Map<Class<?>, Boolean> ignoredTypes); [EOL] long serialVersionUID=Optional[1]; [EOL] Class<?>[] INIT_CAUSE_PARAMS=Optional[new Class<?>[] { Throwable.class }];
public void testBuildThrowableDeserializerWithNonNullInitCause() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JavaType type = mock(JavaType.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] AnnotatedMethod am = mock(AnnotatedMethod.class); [EOL] when(beanDesc.findMethod("initCause", INIT_CAUSE_PARAMS)).thenReturn(am); [EOL] when(ctxt.getConfig()).thenReturn(mock(DeserializationConfig.class)); [EOL] JsonDeserializer<Object> result = buildThrowableDeserializer(ctxt, type, beanDesc); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof ThrowableDeserializer); [EOL] }
public void testBuildThrowableDeserializerWithNullInitCause() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JavaType type = mock(JavaType.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] when(beanDesc.findMethod("initCause", INIT_CAUSE_PARAMS)).thenReturn(null); [EOL] when(ctxt.getConfig()).thenReturn(mock(DeserializationConfig.class)); [EOL] JsonDeserializer<Object> result = buildThrowableDeserializer(ctxt, type, beanDesc); [EOL] assertNotNull(result); [EOL] assertFalse(result instanceof ThrowableDeserializer); [EOL] }
public void testBuildThrowableDeserializerWithDeserializerModifiers() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JavaType type = mock(JavaType.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] BeanDeserializerModifier modifier = mock(BeanDeserializerModifier.class); [EOL] DeserializerFactoryConfig factoryConfig = mock(DeserializerFactoryConfig.class); [EOL] when(ctxt.getConfig()).thenReturn(config); [EOL] when(factoryConfig.hasDeserializerModifiers()).thenReturn(true); [EOL] when(factoryConfig.deserializerModifiers()).thenReturn(Collections.singletonList(modifier)); [EOL] setFactoryConfig(factoryConfig); [EOL] JsonDeserializer<Object> result = buildThrowableDeserializer(ctxt, type, beanDesc); [EOL] assertNotNull(result); [EOL] verify(modifier, times(2)).modifyDeserializer(any(DeserializationConfig.class), any(BeanDescription.class), any(JsonDeserializer.class)); [EOL] }
protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException { [EOL] final SettableBeanProperty[] creatorProps = builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig()); [EOL] AnnotationIntrospector intr = ctxt.getAnnotationIntrospector(); [EOL] boolean ignoreAny = false; [EOL] { [EOL] Boolean B = intr.findIgnoreUnknownProperties(beanDesc.getClassInfo()); [EOL] if (B != null) { [EOL] ignoreAny = B.booleanValue(); [EOL] builder.setIgnoreUnknownProperties(ignoreAny); [EOL] } [EOL] } [EOL] Set<String> ignored = ArrayBuilders.arrayToSet(intr.findPropertiesToIgnore(beanDesc.getClassInfo())); [EOL] for (String propName : ignored) { [EOL] builder.addIgnorable(propName); [EOL] } [EOL] AnnotatedMethod anySetter = beanDesc.findAnySetter(); [EOL] if (anySetter != null) { [EOL] builder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetter)); [EOL] } [EOL] if (anySetter == null) { [EOL] Collection<String> ignored2 = beanDesc.getIgnoredPropertyNames(); [EOL] if (ignored2 != null) { [EOL] for (String propName : ignored2) { [EOL] builder.addIgnorable(propName); [EOL] } [EOL] } [EOL] } [EOL] final boolean useGettersAsSetters = (ctxt.isEnabled(MapperFeature.USE_GETTERS_AS_SETTERS) && ctxt.isEnabled(MapperFeature.AUTO_DETECT_GETTERS)); [EOL] List<BeanPropertyDefinition> propDefs = filterBeanProps(ctxt, beanDesc, builder, beanDesc.findProperties(), ignored); [EOL] if (_factoryConfig.hasDeserializerModifiers()) { [EOL] for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) { [EOL] propDefs = mod.updateProperties(ctxt.getConfig(), beanDesc, propDefs); [EOL] } [EOL] } [EOL] for (BeanPropertyDefinition propDef : propDefs) { [EOL] SettableBeanProperty prop = null; [EOL] if (propDef.hasConstructorParameter()) { [EOL] final String name = propDef.getName(); [EOL] if (creatorProps != null) { [EOL] for (SettableBeanProperty cp : creatorProps) { [EOL] if (name.equals(cp.getName())) { [EOL] prop = cp; [EOL] break; [EOL] } [EOL] } [EOL] } [EOL] if (prop == null) { [EOL] throw ctxt.mappingException("Could not find creator property with name '" + name + "' (in class " + beanDesc.getBeanClass().getName() + ")"); [EOL] } [EOL] builder.addCreatorProperty(prop); [EOL] continue; [EOL] } [EOL] if (propDef.hasSetter()) { [EOL] Type propertyType = propDef.getSetter().getGenericParameterType(0); [EOL] prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType); [EOL] } else if (propDef.hasField()) { [EOL] Type propertyType = propDef.getField().getGenericType(); [EOL] prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType); [EOL] } else if (useGettersAsSetters && propDef.hasGetter()) { [EOL] AnnotatedMethod getter = propDef.getGetter(); [EOL] Class<?> rawPropertyType = getter.getRawType(); [EOL] if (Collection.class.isAssignableFrom(rawPropertyType) || Map.class.isAssignableFrom(rawPropertyType)) { [EOL] prop = constructSetterlessProperty(ctxt, beanDesc, propDef); [EOL] } [EOL] } [EOL] if (prop != null) { [EOL] Class<?>[] views = propDef.findViews(); [EOL] if (views == null) { [EOL] if (!ctxt.isEnabled(MapperFeature.DEFAULT_VIEW_INCLUSION)) { [EOL] views = NO_VIEWS; [EOL] } [EOL] } [EOL] prop.setViews(views); [EOL] builder.addProperty(prop); [EOL] } [EOL] } [EOL] }
protected List<BeanPropertyDefinition> filterBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder, List<BeanPropertyDefinition> propDefsIn, Set<String> ignored) throws JsonMappingException { [EOL] ArrayList<BeanPropertyDefinition> result = new ArrayList<BeanPropertyDefinition>(Math.max(4, propDefsIn.size())); [EOL] HashMap<Class<?>, Boolean> ignoredTypes = new HashMap<Class<?>, Boolean>(); [EOL] for (BeanPropertyDefinition property : propDefsIn) { [EOL] String name = property.getName(); [EOL] if (ignored.contains(name)) { [EOL] continue; [EOL] } [EOL] if (!property.hasConstructorParameter()) { [EOL] Class<?> rawPropertyType = null; [EOL] if (property.hasSetter()) { [EOL] rawPropertyType = property.getSetter().getRawParameterType(0); [EOL] } else if (property.hasField()) { [EOL] rawPropertyType = property.getField().getRawType(); [EOL] } [EOL] if ((rawPropertyType != null) && (isIgnorableType(ctxt.getConfig(), beanDesc, rawPropertyType, ignoredTypes))) { [EOL] builder.addIgnorable(name); [EOL] continue; [EOL] } [EOL] } [EOL] result.add(property); [EOL] } [EOL] return result; [EOL] }
protected SettableAnyProperty constructAnySetter(DeserializationContext ctxt, BeanDescription beanDesc, AnnotatedMethod setter) throws JsonMappingException { [EOL] if (ctxt.canOverrideAccessModifiers()) { [EOL] setter.fixAccess(); [EOL] } [EOL] JavaType type = beanDesc.bindingsForBeanType().resolveType(setter.getGenericParameterType(1)); [EOL] BeanProperty.Std property = new BeanProperty.Std(setter.getName(), type, null, beanDesc.getClassAnnotations(), setter, false); [EOL] type = resolveType(ctxt, beanDesc, type, setter); [EOL] JsonDeserializer<Object> deser = findDeserializerFromAnnotation(ctxt, setter); [EOL] if (deser != null) { [EOL] return new SettableAnyProperty(property, setter, type, deser); [EOL] } [EOL] type = modifyTypeByAnnotation(ctxt, setter, type); [EOL] return new SettableAnyProperty(property, setter, type, null); [EOL] } [EOL] public BeanDeserializerFactory(DeserializerFactoryConfig config); [EOL] public DeserializerFactory withConfig(DeserializerFactoryConfig config); [EOL] protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; [EOL] public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; [EOL] public JsonDeserializer<Object> createBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription beanDesc, Class<?> builderClass) throws JsonMappingException; [EOL] protected JsonDeserializer<?> findStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; [EOL] protected JsonDeserializer<?> findOptionalStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; [EOL] protected JavaType materializeAbstractType(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; [EOL] public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; [EOL] protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException; [EOL] protected void addObjectIdReader(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; [EOL] public JsonDeserializer<Object> buildThrowableDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; [EOL] protected BeanDeserializerBuilder constructBeanDeserializerBuilder(DeserializationContext ctxt, BeanDescription beanDesc); [EOL] protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; [EOL] protected List<BeanPropertyDefinition> filterBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder, List<BeanPropertyDefinition> propDefsIn, Set<String> ignored) throws JsonMappingException; [EOL] protected void addReferenceProperties(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; [EOL] protected void addInjectables(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; [EOL] protected SettableAnyProperty constructAnySetter(DeserializationContext ctxt, BeanDescription beanDesc, AnnotatedMethod setter) throws JsonMappingException; [EOL] protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef, Type jdkType) throws JsonMappingException; [EOL] protected SettableBeanProperty constructSetterlessProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef) throws JsonMappingException; [EOL] protected boolean isPotentialBeanType(Class<?> type); [EOL] protected boolean isIgnorableType(DeserializationConfig config, BeanDescription beanDesc, Class<?> type, Map<Class<?>, Boolean> ignoredTypes); [EOL] long serialVersionUID=Optional[1]; [EOL] Class<?>[] INIT_CAUSE_PARAMS=Optional[new Class<?>[] { Throwable.class }];
protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef, Type jdkType) throws JsonMappingException { [EOL] AnnotatedMember mutator = propDef.getMutator(); [EOL] if (ctxt.canOverrideAccessModifiers()) { [EOL] mutator.fixAccess(); [EOL] } [EOL] JavaType t0 = beanDesc.resolveType(jdkType); [EOL] BeanProperty.Std property = new BeanProperty.Std(propDef.getName(), t0, propDef.getWrapperName(), beanDesc.getClassAnnotations(), mutator, propDef.isRequired()); [EOL] JavaType type = resolveType(ctxt, beanDesc, t0, mutator); [EOL] if (type != t0) { [EOL] property = property.withType(type); [EOL] } [EOL] JsonDeserializer<Object> propDeser = findDeserializerFromAnnotation(ctxt, mutator); [EOL] type = modifyTypeByAnnotation(ctxt, mutator, type); [EOL] TypeDeserializer typeDeser = type.getTypeHandler(); [EOL] SettableBeanProperty prop; [EOL] if (mutator instanceof AnnotatedMethod) { [EOL] prop = new MethodProperty(propDef, type, typeDeser, beanDesc.getClassAnnotations(), (AnnotatedMethod) mutator); [EOL] } else { [EOL] prop = new FieldProperty(propDef, type, typeDeser, beanDesc.getClassAnnotations(), (AnnotatedField) mutator); [EOL] } [EOL] if (propDeser != null) { [EOL] prop = prop.withValueDeserializer(propDeser); [EOL] } [EOL] AnnotationIntrospector.ReferenceProperty ref = propDef.findReferenceType(); [EOL] if (ref != null && ref.isManagedReference()) { [EOL] prop.setManagedReferenceName(ref.getName()); [EOL] } [EOL] return prop; [EOL] }
public void testSetFailOnUnknownId_True() { [EOL] SimpleFilterProvider provider = new SimpleFilterProvider(); [EOL] provider.setFailOnUnknownId(true); [EOL] assertTrue(provider._cfgFailOnUnknownId); [EOL] }
public void testSetFailOnUnknownId_False() { [EOL] SimpleFilterProvider provider = new SimpleFilterProvider(); [EOL] provider.setFailOnUnknownId(false); [EOL] assertFalse(provider._cfgFailOnUnknownId); [EOL] }
public void testGetAnnotationWithNullMember() { [EOL] instanceUnderTest._member = null; [EOL] Annotation result = instanceUnderTest.getAnnotation(SomeAnnotation.class); [EOL] assertNull(result); [EOL] }
public void testGetAnnotationWithNonNullMemberAndAnnotationPresent() { [EOL] MockMember mockMember = new MockMember(); [EOL] SomeAnnotation expectedAnnotation = new SomeAnnotationImpl(); [EOL] when(mockMember.getAnnotation(SomeAnnotation.class)).thenReturn(expectedAnnotation); [EOL] instanceUnderTest._member = mockMember; [EOL] Annotation result = instanceUnderTest.getAnnotation(SomeAnnotation.class); [EOL] assertSame(expectedAnnotation, result); [EOL] }
public void testGetAnnotationWithNonNullMemberAndAnnotationAbsent() { [EOL] MockMember mockMember = new MockMember(); [EOL] when(mockMember.getAnnotation(SomeAnnotation.class)).thenReturn(null); [EOL] instanceUnderTest._member = mockMember; [EOL] Annotation result = instanceUnderTest.getAnnotation(SomeAnnotation.class); [EOL] assertNull(result); [EOL] }
public void testGetWrapperName_Null() { [EOL] BeanPropertyImpl beanProperty = new BeanPropertyImpl(null, null, null); [EOL] assertNull(beanProperty.getWrapperName()); [EOL] }
public void testGetWrapperName_NonNull() { [EOL] PropertyName propertyName = new PropertyName("wrapperName"); [EOL] BeanPropertyImpl beanProperty = new BeanPropertyImpl(null, null, propertyName); [EOL] assertEquals(propertyName, beanProperty.getWrapperName()); [EOL] }
public void testIsRequiredWhenTrue() { [EOL] YourClass instance = new YourClass(true); [EOL] boolean result = instance.isRequired(); [EOL] assert result : "The isRequired method should return true when _isRequired is true"; [EOL] } [EOL] public void testIsRequiredWhenFalse() { [EOL] YourClass instance = new YourClass(false); [EOL] boolean result = instance.isRequired(); [EOL] assert !result : "The isRequired method should return false when _isRequired is false"; [EOL] }
public void testGetMemberReturnsCorrectMember() { [EOL] AnnotatedMember member = mock(AnnotatedMember.class); [EOL] SomeClass instance = new SomeClass(member); [EOL] AnnotatedMember result = instance.getMember(); [EOL] assertSame("The getMember method should return the same member that was set", member, result); [EOL] }
public void testSerializeWithNonNullValue() throws IOException { [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] SerializerProvider mockProvider = mock(SerializerProvider.class); [EOL] Object value = "TestValue"; [EOL] new TestSerializer().serialize(value, mockJsonGenerator, mockProvider); [EOL] verify(mockJsonGenerator).writeString("TestValue"); [EOL] }
public void testSerializeWithNullValue() throws IOException { [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] SerializerProvider mockProvider = mock(SerializerProvider.class); [EOL] Object value = null; [EOL] try { [EOL] new TestSerializer().serialize(value, mockJsonGenerator, mockProvider); [EOL] fail("Expected NullPointerException to be thrown"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testObjectIdWriterConstruction() { [EOL] JavaType idType = mock(JavaType.class); [EOL] SerializedString propertyName = new SerializedString("testProperty"); [EOL] ObjectIdGenerator<?> generator = mock(ObjectIdGenerator.class); [EOL] JsonSerializer<?> serializer = mock(JsonSerializer.class); [EOL] boolean alwaysAsId = true; [EOL] ObjectIdWriter writer = new ObjectIdWriter(idType, propertyName, generator, serializer, alwaysAsId); [EOL] assertEquals(idType, writer.idType); [EOL] assertEquals(propertyName, writer.propertyName); [EOL] assertEquals(generator, writer.generator); [EOL] assertSame(serializer, writer.serializer); [EOL] assertTrue(writer.alwaysAsId); [EOL] }
public void testConstructWithNonNullPropName() { [EOL] JavaType idType = SimpleType.constructUnsafe(String.class); [EOL] String propName = "testProperty"; [EOL] ObjectIdGenerator<?> generator = new ObjectIdGenerators.IntSequenceGenerator(); [EOL] boolean alwaysAsId = true; [EOL] ObjectIdWriter result = ObjectIdWriter.construct(idType, propName, generator, alwaysAsId); [EOL] assertNotNull(result); [EOL] assertEquals(idType, result.idType); [EOL] assertNotNull(result.propertyName); [EOL] assertEquals("testProperty", result.propertyName.getValue()); [EOL] assertEquals(generator, result.generator); [EOL] assertNull(result.alwaysAsId); [EOL] assertTrue(result.alwaysAsId); [EOL] }
public void testConstructWithNullPropName() { [EOL] JavaType idType = SimpleType.constructUnsafe(String.class); [EOL] String propName = null; [EOL] ObjectIdGenerator<?> generator = new ObjectIdGenerators.IntSequenceGenerator(); [EOL] boolean alwaysAsId = false; [EOL] ObjectIdWriter result = ObjectIdWriter.construct(idType, propName, generator, alwaysAsId); [EOL] assertNotNull(result); [EOL] assertEquals(idType, result.idType); [EOL] assertNull(result.propertyName); [EOL] assertEquals(generator, result.generator); [EOL] assertNull(result.alwaysAsId); [EOL] assertFalse(result.alwaysAsId); [EOL] }
public void testWithSerializer_NullSerializer() { [EOL] ObjectIdGenerator<?> generator = mock(ObjectIdGenerator.class); [EOL] JavaType idType = mock(JavaType.class); [EOL] PropertyName propertyName = new PropertyName("test"); [EOL] ObjectIdWriter originalWriter = new ObjectIdWriter(idType, propertyName, generator, null, true); [EOL] ObjectIdWriter resultWriter = originalWriter.withSerializer(null); [EOL] assertNull(resultWriter.serializer); [EOL] }
public void testWithSerializer_NonNullSerializer() { [EOL] ObjectIdGenerator<?> generator = mock(ObjectIdGenerator.class); [EOL] JavaType idType = mock(JavaType.class); [EOL] PropertyName propertyName = new PropertyName("test"); [EOL] JsonSerializer<?> serializer = mock(JsonSerializer.class); [EOL] ObjectIdWriter originalWriter = new ObjectIdWriter(idType, propertyName, generator, null, true); [EOL] ObjectIdWriter resultWriter = originalWriter.withSerializer(serializer); [EOL] assertNotNull(resultWriter.serializer); [EOL] assertSame(serializer, resultWriter.serializer); [EOL] }
public void testCreateTypeSerializerWithNullTypeResolverBuilderAndNoDefaultTyper() { [EOL] SerializationConfig config = new SerializationConfig(...); // provide necessary initialization [EOL] JavaType baseType = ...; // provide necessary initialization [EOL] TypeSerializer result = createTypeSerializer(config, baseType); [EOL] assertNull(result); [EOL] }
public void testCreateTypeSerializerWithNonNullTypeResolverBuilder() { [EOL] SerializationConfig config = new SerializationConfig(...); // provide necessary initialization [EOL] JavaType baseType = ...; // provide necessary initialization [EOL] TypeSerializer result = createTypeSerializer(config, baseType); [EOL] assertNotNull(result); [EOL] }
public void testCreateTypeSerializerWithTypeResolverBuilderAndSubtypes() { [EOL] SerializationConfig config = new SerializationConfig(...); // provide necessary initialization [EOL] JavaType baseType = ...; // provide necessary initialization [EOL] TypeSerializer result = createTypeSerializer(config, baseType); [EOL] assertNotNull(result); [EOL] }
public void testFindSerializerByLookupWithConcrete() { [EOL] JavaType type = mock(JavaType.class); [EOL] SerializationConfig config = mock(SerializationConfig.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] when(type.getRawClass()).thenReturn(String.class); [EOL] JsonSerializer<?> expectedSerializer = mock(JsonSerializer.class); [EOL] _concrete.put(String.class.getName(), expectedSerializer); [EOL] JsonSerializer<?> result = findSerializerByLookup(type, config, beanDesc, true); [EOL] assertNotNull(result); [EOL] assertSame(expectedSerializer, result); [EOL] }
public void testFindSerializerByLookupWithConcreteLazy() throws Exception { [EOL] JavaType type = mock(JavaType.class); [EOL] SerializationConfig config = mock(SerializationConfig.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] when(type.getRawClass()).thenReturn(String.class); [EOL] Class<? extends JsonSerializer<?>> serClass = mock(Class.class); [EOL] JsonSerializer<?> expectedSerializer = mock(JsonSerializer.class); [EOL] when(serClass.newInstance()).thenReturn(expectedSerializer); [EOL] _concreteLazy.put(String.class.getName(), serClass); [EOL] JsonSerializer<?> result = findSerializerByLookup(type, config, beanDesc, true); [EOL] assertNotNull(result); [EOL] assertSame(expectedSerializer, result); [EOL] }
public void testFindSerializerByLookupWithInstantiationException() throws Exception { [EOL] JavaType type = mock(JavaType.class); [EOL] SerializationConfig config = mock(SerializationConfig.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] when(type.getRawClass()).thenReturn(String.class); [EOL] Class<? extends JsonSerializer<?>> serClass = mock(Class.class); [EOL] when(serClass.newInstance()).thenThrow(new InstantiationException()); [EOL] _concreteLazy.put(String.class.getName(), serClass); [EOL] try { [EOL] findSerializerByLookup(type, config, beanDesc, true); [EOL] fail("Expected IllegalStateException to be thrown"); [EOL] } catch (IllegalStateException e) { [EOL] } [EOL] }
public void testFindSerializerByLookupWithIllegalAccessException() throws Exception { [EOL] JavaType type = mock(JavaType.class); [EOL] SerializationConfig config = mock(SerializationConfig.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] when(type.getRawClass()).thenReturn(String.class); [EOL] Class<? extends JsonSerializer<?>> serClass = mock(Class.class); [EOL] when(serClass.newInstance()).thenThrow(new IllegalAccessException()); [EOL] _concreteLazy.put(String.class.getName(), serClass); [EOL] try { [EOL] findSerializerByLookup(type, config, beanDesc, true); [EOL] fail("Expected IllegalStateException to be thrown"); [EOL] } catch (IllegalStateException e) { [EOL] } [EOL] }
public void testFindSerializerByLookupWithNoSerializerFound() { [EOL] JavaType type = mock(JavaType.class); [EOL] SerializationConfig config = mock(SerializationConfig.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] when(type.getRawClass()).thenReturn(Object.class); [EOL] JsonSerializer<?> result = findSerializerByLookup(type, config, beanDesc, true); [EOL] assertNull(result); [EOL] }
public void testFindSerializerByAnnotationsWithJsonSerializable() throws JsonMappingException { [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] JavaType type = mock(JavaType.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] when(type.getRawClass()).thenReturn((Class)JsonSerializable.class); [EOL] JsonSerializer<?> result = findSerializerByAnnotations(prov, type, beanDesc); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof SerializableSerializer); [EOL] }
public void testFindSerializerByAnnotationsWithJsonValueMethod() throws JsonMappingException { [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] JavaType type = mock(JavaType.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] AnnotatedMethod valueMethod = mock(AnnotatedMethod.class); [EOL] Method m = mock(Method.class); [EOL] when(type.getRawClass()).thenReturn((Class)Object.class); [EOL] when(beanDesc.findJsonValueMethod()).thenReturn(valueMethod); [EOL] when(valueMethod.getAnnotated()).thenReturn(m); [EOL] when(prov.canOverrideAccessModifiers()).thenReturn(true); [EOL] JsonSerializer<Object> ser = mock(JsonSerializer.class); [EOL] when(findSerializerFromAnnotation(prov, valueMethod)).thenReturn(ser); [EOL] JsonSerializer<?> result = findSerializerByAnnotations(prov, type, beanDesc); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof JsonValueSerializer); [EOL] }
public void testFindSerializerByAnnotationsReturnsNull() throws JsonMappingException { [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] JavaType type = mock(JavaType.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] when(type.getRawClass()).thenReturn((Class)Object.class); [EOL] when(beanDesc.findJsonValueMethod()).thenReturn(null); [EOL] JsonSerializer<?> result = findSerializerByAnnotations(prov, type, beanDesc); [EOL] assertNull(result); [EOL] }
public void testFindSerializerByPrimaryTypeWithInetAddress() { [EOL] SerializerProvider prov = null; // Mock or create instance [EOL] JavaType type = SimpleType.constructUnsafe(InetAddress.class); [EOL] BeanDescription beanDesc = null; // Mock or create instance [EOL] JsonSerializer<?> result = findSerializerByPrimaryType(prov, type, beanDesc, true); [EOL] assertTrue(result instanceof InetAddressSerializer); [EOL] }
public void testFindSerializerByPrimaryTypeWithTimeZone() { [EOL] SerializerProvider prov = null; // Mock or create instance [EOL] JavaType type = SimpleType.constructUnsafe(TimeZone.class); [EOL] BeanDescription beanDesc = null; // Mock or create instance [EOL] JsonSerializer<?> result = findSerializerByPrimaryType(prov, type, beanDesc, true); [EOL] assertTrue(result instanceof TimeZoneSerializer); [EOL] }
public void testFindSerializerByPrimaryTypeWithCharset() { [EOL] SerializerProvider prov = null; // Mock or create instance [EOL] JavaType type = SimpleType.constructUnsafe(java.nio.charset.Charset.class); [EOL] BeanDescription beanDesc = null; // Mock or create instance [EOL] JsonSerializer<?> result = findSerializerByPrimaryType(prov, type, beanDesc, true); [EOL] assertTrue(result instanceof ToStringSerializer); [EOL] }
public void testFindSerializerByPrimaryTypeWithOptionalStdSerializer() { [EOL] SerializerProvider prov = null; // Mock or create instance [EOL] JavaType type = SimpleType.constructUnsafe(SomeClassThatHasOptionalStdSerializer.class); [EOL] BeanDescription beanDesc = null; // Mock or create instance [EOL] JsonSerializer<?> result = findSerializerByPrimaryType(prov, type, beanDesc, true); [EOL] assertNotNull(result); [EOL] }
public void testFindSerializerByPrimaryTypeWithNumber() { [EOL] SerializerProvider prov = null; // Mock or create instance [EOL] JavaType type = SimpleType.constructUnsafe(Number.class); [EOL] BeanDescription beanDesc = null; // Mock or create instance [EOL] JsonSerializer<?> result = findSerializerByPrimaryType(prov, type, beanDesc, true); [EOL] assertTrue(result instanceof NumberSerializers.NumberSerializer); [EOL] }
public void testFindSerializerByPrimaryTypeWithEnum() { [EOL] SerializerProvider prov = null; // Mock or create instance [EOL] JavaType type = SimpleType.constructUnsafe(Enum.class); [EOL] BeanDescription beanDesc = null; // Mock or create instance [EOL] JsonSerializer<?> result = findSerializerByPrimaryType(prov, type, beanDesc, true); [EOL] assertNotNull(result); [EOL] }
public void testFindSerializerByPrimaryTypeWithCalendar() { [EOL] SerializerProvider prov = null; // Mock or create instance [EOL] JavaType type = SimpleType.constructUnsafe(Calendar.class); [EOL] BeanDescription beanDesc = null; // Mock or create instance [EOL] JsonSerializer<?> result = findSerializerByPrimaryType(prov, type, beanDesc, true); [EOL] assertTrue(result instanceof CalendarSerializer); [EOL] }
public void testFindSerializerByPrimaryTypeWithDate() { [EOL] SerializerProvider prov = null; // Mock or create instance [EOL] JavaType type = SimpleType.constructUnsafe(java.util.Date.class); [EOL] BeanDescription beanDesc = null; // Mock or create instance [EOL] JsonSerializer<?> result = findSerializerByPrimaryType(prov, type, beanDesc, true); [EOL] assertTrue(result instanceof DateSerializer); [EOL] }
public void testFindSerializerByPrimaryTypeWithNull() { [EOL] SerializerProvider prov = null; // Mock or create instance [EOL] JavaType type = SimpleType.constructUnsafe(SomeClassWithoutSerializer.class); [EOL] BeanDescription beanDesc = null; // Mock or create instance [EOL] JsonSerializer<?> result = findSerializerByPrimaryType(prov, type, beanDesc, true); [EOL] assertNull(result); [EOL] }
protected JsonSerializer<?> findOptionalStdSerializer(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { [EOL] return OptionalHandlerFactory.instance.findSerializer(prov.getConfig(), type, beanDesc); [EOL] }
public void testFindSerializerByIteratorType() throws JsonMappingException { [EOL] SerializationConfig config = new SerializationConfig(...); // Provide actual initialization [EOL] JavaType javaType = TypeFactory.defaultInstance().constructType(Iterator.class); [EOL] BeanDescription beanDesc = ...; // Provide actual initialization [EOL] boolean staticTyping = false; // or true, depending on what you want to test [EOL] JsonSerializer<?> serializer = findSerializerByAddonType(config, javaType, beanDesc, staticTyping); [EOL] assertNotNull(serializer); [EOL] assertTrue(serializer instanceof IteratorSerializer); // Assuming IteratorSerializer is the expected type [EOL] }
public void testFindSerializerByIterableType() throws JsonMappingException { [EOL] SerializationConfig config = new SerializationConfig(...); // Provide actual initialization [EOL] JavaType javaType = TypeFactory.defaultInstance().constructType(Iterable.class); [EOL] BeanDescription beanDesc = ...; // Provide actual initialization [EOL] boolean staticTyping = false; // or true, depending on what you want to test [EOL] JsonSerializer<?> serializer = findSerializerByAddonType(config, javaType, beanDesc, staticTyping); [EOL] assertNotNull(serializer); [EOL] assertTrue(serializer instanceof IterableSerializer); // Assuming IterableSerializer is the expected type [EOL] }
public void testFindSerializerByCharSequenceType() throws JsonMappingException { [EOL] SerializationConfig config = new SerializationConfig(...); // Provide actual initialization [EOL] JavaType javaType = TypeFactory.defaultInstance().constructType(CharSequence.class); [EOL] BeanDescription beanDesc = ...; // Provide actual initialization [EOL] boolean staticTyping = false; // or true, depending on what you want to test [EOL] JsonSerializer<?> serializer = findSerializerByAddonType(config, javaType, beanDesc, staticTyping); [EOL] assertNotNull(serializer); [EOL] assertSame(ToStringSerializer.instance, serializer); [EOL] }
public void testFindSerializerByUnknownType() throws JsonMappingException { [EOL] SerializationConfig config = new SerializationConfig(...); // Provide actual initialization [EOL] JavaType javaType = TypeFactory.defaultInstance().constructType(Object.class); [EOL] BeanDescription beanDesc = ...; // Provide actual initialization [EOL] boolean staticTyping = false; // or true, depending on what you want to test [EOL] JsonSerializer<?> serializer = findSerializerByAddonType(config, javaType, beanDesc, staticTyping); [EOL] assertNull(serializer); [EOL] }
public void testFindSerializerFromAnnotationWithNullSerDef() throws JsonMappingException { [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] Annotated a = mock(Annotated.class); [EOL] when(prov.getAnnotationIntrospector().findSerializer(a)).thenReturn(null); [EOL] JsonSerializer<Object> result = findSerializerFromAnnotation(prov, a); [EOL] assertNull(result); [EOL] }
public void testFindSerializerFromAnnotationWithNonNullSerDef() throws JsonMappingException { [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] Annotated a = mock(Annotated.class); [EOL] Object serDef = new Object(); [EOL] JsonSerializer<Object> expectedSerializer = mock(JsonSerializer.class); [EOL] when(prov.getAnnotationIntrospector().findSerializer(a)).thenReturn(serDef); [EOL] when(prov.serializerInstance(a, serDef)).thenReturn(expectedSerializer); [EOL] when(findConvertingSerializer(prov, a, expectedSerializer)).thenReturn(expectedSerializer); [EOL] JsonSerializer<Object> result = findSerializerFromAnnotation(prov, a); [EOL] assertSame(expectedSerializer, result); [EOL] }
public void testFindConvertingSerializerWithNullConverter() throws JsonMappingException { [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] Annotated a = mock(Annotated.class); [EOL] JsonSerializer<?> ser = mock(JsonSerializer.class); [EOL] when(findConverter(prov, a)).thenReturn(null); [EOL] JsonSerializer<?> result = findConvertingSerializer(prov, a, ser); [EOL] assertSame(ser, result); [EOL] }
public void testFindConvertingSerializerWithNonNullConverter() throws JsonMappingException { [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] Annotated a = mock(Annotated.class); [EOL] JsonSerializer<?> ser = mock(JsonSerializer.class); [EOL] Converter<Object, Object> conv = mock(Converter.class); [EOL] JavaType delegateType = mock(JavaType.class); [EOL] when(findConverter(prov, a)).thenReturn(conv); [EOL] when(conv.getOutputType(any(TypeFactory.class))).thenReturn(delegateType); [EOL] JsonSerializer<?> result = findConvertingSerializer(prov, a, ser); [EOL] assertTrue(result instanceof StdDelegatingSerializer); [EOL] }
public void testFindConverterWithNullConverterDef() throws JsonMappingException { [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] Annotated a = mock(Annotated.class); [EOL] when(prov.getAnnotationIntrospector().findSerializationConverter(a)).thenReturn(null); [EOL] Converter<Object, Object> result = findConverter(prov, a); [EOL] assertNull(result); [EOL] }
public void testFindConverterWithNonNullConverterDef() throws JsonMappingException { [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] Annotated a = mock(Annotated.class); [EOL] Object convDef = new Object(); [EOL] Converter<Object, Object> expectedConverter = mock(Converter.class); [EOL] when(prov.getAnnotationIntrospector().findSerializationConverter(a)).thenReturn(convDef); [EOL] when(prov.converterInstance(a, convDef)).thenReturn(expectedConverter); [EOL] Converter<Object, Object> result = findConverter(prov, a); [EOL] assertSame(expectedConverter, result); [EOL] }
public void testBuildContainerSerializerWithStaticTypingAndNonContainerType() throws JsonMappingException { [EOL] SerializerProvider prov = createMockSerializerProvider(); [EOL] JavaType type = createMockJavaType(false, false, true, Object.class); [EOL] BeanDescription beanDesc = createMockBeanDescription(); [EOL] JsonSerializer<?> result = buildContainerSerializer(prov, type, beanDesc, false); [EOL] assertNotNull(result); [EOL] }
public void testBuildContainerSerializerWithMapLikeType() throws JsonMappingException { [EOL] SerializerProvider prov = createMockSerializerProvider(); [EOL] JavaType type = createMockJavaType(true, true, false, null); [EOL] BeanDescription beanDesc = createMockBeanDescription(); [EOL] JsonSerializer<?> result = buildContainerSerializer(prov, type, beanDesc, false); [EOL] assertNotNull(result); [EOL] }
public void testBuildContainerSerializerWithCollectionLikeType() throws JsonMappingException { [EOL] SerializerProvider prov = createMockSerializerProvider(); [EOL] JavaType type = createMockJavaType(true, false, true, null); [EOL] BeanDescription beanDesc = createMockBeanDescription(); [EOL] JsonSerializer<?> result = buildContainerSerializer(prov, type, beanDesc, false); [EOL] assertNotNull(result); [EOL] }
public void testBuildContainerSerializerWithArrayType() throws JsonMappingException { [EOL] SerializerProvider prov = createMockSerializerProvider(); [EOL] JavaType type = createMockJavaType(false, false, false, null); [EOL] BeanDescription beanDesc = createMockBeanDescription(); [EOL] JsonSerializer<?> result = buildContainerSerializer(prov, type, beanDesc, false); [EOL] assertNotNull(result); [EOL] }
public void testBuildCollectionSerializerWithCustomSerializer() { [EOL] SerializationConfig config = new SerializationConfig(); [EOL] CollectionType type = new CollectionType(); [EOL] BeanDescription beanDesc = new BeanDescription(); [EOL] TypeSerializer elementTypeSerializer = new TypeSerializer(); [EOL] JsonSerializer<Object> elementValueSerializer = new CustomSerializer(); [EOL] JsonSerializer<?> result = buildCollectionSerializer(config, type, beanDesc, false, elementTypeSerializer, elementValueSerializer); [EOL] assertNotNull(result); [EOL] }
public void testBuildCollectionSerializerWithNullCustomSerializerAndEnumSet() { [EOL] SerializationConfig config = new SerializationConfig(); [EOL] CollectionType type = CollectionType.construct(EnumSet.class, BasicBeanDescription.constructForType(EnumType.class)); [EOL] BeanDescription beanDesc = new BeanDescription(); [EOL] TypeSerializer elementTypeSerializer = new TypeSerializer(); [EOL] JsonSerializer<?> result = buildCollectionSerializer(config, type, beanDesc, false, elementTypeSerializer, null); [EOL] assertTrue(result instanceof StdContainerSerializers.EnumSetSerializer); [EOL] }
public void testBuildCollectionSerializerWithNullCustomSerializerAndIndexedList() { [EOL] SerializationConfig config = new SerializationConfig(); [EOL] CollectionType type = CollectionType.construct(ArrayList.class, BasicBeanDescription.constructForType(String.class)); [EOL] BeanDescription beanDesc = new BeanDescription(); [EOL] TypeSerializer elementTypeSerializer = new TypeSerializer(); [EOL] JsonSerializer<?> result = buildCollectionSerializer(config, type, beanDesc, false, elementTypeSerializer, null); [EOL] assertTrue(result instanceof IndexedStringListSerializer); [EOL] }
public void testBuildCollectionSerializerWithNullCustomSerializerAndStringCollection() { [EOL] SerializationConfig config = new SerializationConfig(); [EOL] CollectionType type = CollectionType.construct(HashSet.class, BasicBeanDescription.constructForType(String.class)); [EOL] BeanDescription beanDesc = new BeanDescription(); [EOL] TypeSerializer elementTypeSerializer = new TypeSerializer(); [EOL] JsonSerializer<?> result = buildCollectionSerializer(config, type, beanDesc, false, elementTypeSerializer, null); [EOL] assertTrue(result instanceof StringCollectionSerializer); [EOL] }
public void testBuildCollectionSerializerWithNullCustomSerializerAndOtherCollection() { [EOL] SerializationConfig config = new SerializationConfig(); [EOL] CollectionType type = CollectionType.construct(LinkedList.class, BasicBeanDescription.constructForType(Object.class)); [EOL] BeanDescription beanDesc = new BeanDescription(); [EOL] TypeSerializer elementTypeSerializer = new TypeSerializer(); [EOL] JsonSerializer<?> result = buildCollectionSerializer(config, type, beanDesc, false, elementTypeSerializer, null); [EOL] assertNotNull(result); [EOL] assertFalse(result instanceof StdContainerSerializers.EnumSetSerializer); [EOL] assertFalse(result instanceof IndexedStringListSerializer); [EOL] assertFalse(result instanceof StringCollectionSerializer); [EOL] }
public void testBuildCollectionSerializerWithSerializerModifiers() { [EOL] SerializationConfig config = new SerializationConfig(); [EOL] CollectionType type = new CollectionType(); [EOL] BeanDescription beanDesc = new BeanDescription(); [EOL] TypeSerializer elementTypeSerializer = new TypeSerializer(); [EOL] JsonSerializer<Object> elementValueSerializer = new CustomSerializer(); [EOL] _factoryConfig = new SerializerFactoryConfig(); [EOL] _factoryConfig.addSerializerModifier(new BeanSerializerModifier()); [EOL] JsonSerializer<?> result = buildCollectionSerializer(config, type, beanDesc, false, elementTypeSerializer, elementValueSerializer); [EOL] assertNotNull(result); [EOL] }
protected boolean isIndexedList(Class<?> cls) { [EOL] return RandomAccess.class.isAssignableFrom(cls); [EOL] }
protected JsonSerializer<?> buildMapSerializer(SerializationConfig config, MapType type, BeanDescription beanDesc, boolean staticTyping, JsonSerializer<Object> keySerializer, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException { [EOL] JsonSerializer<?> ser = null; [EOL] for (Serializers serializers : customSerializers()) { [EOL] ser = serializers.findMapSerializer(config, type, beanDesc, keySerializer, elementTypeSerializer, elementValueSerializer); [EOL] if (ser != null) { [EOL] break; [EOL] } [EOL] } [EOL] if (ser == null) { [EOL] if (EnumMap.class.isAssignableFrom(type.getRawClass())) { [EOL] JavaType keyType = type.getKeyType(); [EOL] EnumValues enums = null; [EOL] if (keyType.isEnumType()) { [EOL] Class<Enum<?>> enumClass = (Class<Enum<?>>) keyType.getRawClass(); [EOL] enums = EnumValues.construct(enumClass, config.getAnnotationIntrospector()); [EOL] } [EOL] ser = new EnumMapSerializer(type.getContentType(), staticTyping, enums, elementTypeSerializer, elementValueSerializer); [EOL] } else { [EOL] ser = MapSerializer.construct(config.getAnnotationIntrospector().findPropertiesToIgnore(beanDesc.getClassInfo()), type, staticTyping, elementTypeSerializer, keySerializer, elementValueSerializer); [EOL] } [EOL] } [EOL] if (_factoryConfig.hasSerializerModifiers()) { [EOL] for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL] ser = mod.modifyMapSerializer(config, type, beanDesc, ser); [EOL] } [EOL] } [EOL] return ser; [EOL] }
protected JsonSerializer<?> buildArraySerializer(SerializationConfig config, ArrayType type, BeanDescription beanDesc, boolean staticTyping, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException { [EOL] JsonSerializer<?> ser = null; [EOL] for (Serializers serializers : customSerializers()) { [EOL] ser = serializers.findArraySerializer(config, type, beanDesc, elementTypeSerializer, elementValueSerializer); [EOL] if (ser != null) { [EOL] break; [EOL] } [EOL] } [EOL] if (ser == null) { [EOL] Class<?> raw = type.getRawClass(); [EOL] if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) { [EOL] if (String[].class == raw) { [EOL] ser = StringArraySerializer.instance; [EOL] } else { [EOL] ser = StdArraySerializers.findStandardImpl(raw); [EOL] } [EOL] } [EOL] if (ser == null) { [EOL] ser = new ObjectArraySerializer(type.getContentType(), staticTyping, elementTypeSerializer, elementValueSerializer); [EOL] } [EOL] } [EOL] if (_factoryConfig.hasSerializerModifiers()) { [EOL] for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL] ser = mod.modifyArraySerializer(config, type, beanDesc, ser); [EOL] } [EOL] } [EOL] return ser; [EOL] }
public void testBuildIterableSerializerWithNonNullValueType() throws JsonMappingException { [EOL] SerializationConfig config = new SerializationConfig(...); // Provide actual initialization [EOL] JavaType type = ...; // Provide actual initialization [EOL] BeanDescription beanDesc = ...; // Provide actual initialization [EOL] boolean staticTyping = ...; // Provide actual value [EOL] JsonSerializer<?> result = buildIterableSerializer(config, type, beanDesc, staticTyping); [EOL] assertNotNull(result); [EOL] }
public void testBuildIterableSerializerWithNullValueType() throws JsonMappingException { [EOL] SerializationConfig config = new SerializationConfig(...); // Provide actual initialization [EOL] JavaType type = ...; // Provide actual initialization with type.containedType(0) == null [EOL] BeanDescription beanDesc = ...; // Provide actual initialization [EOL] boolean staticTyping = ...; // Provide actual value [EOL] JsonSerializer<?> result = buildIterableSerializer(config, type, beanDesc, staticTyping); [EOL] assertNotNull(result); [EOL] }
protected <T extends JavaType> T modifyTypeByAnnotation(SerializationConfig config, Annotated a, T type) { [EOL] Class<?> superclass = config.getAnnotationIntrospector().findSerializationType(a); [EOL] if (superclass != null) { [EOL] try { [EOL] type = (T) type.widenBy(superclass); [EOL] } catch (IllegalArgumentException iae) { [EOL] throw new IllegalArgumentException("Failed to widen type " + type + " with concrete-type annotation (value " + superclass.getName() + "), method '" + a.getName() + "': " + iae.getMessage()); [EOL] } [EOL] } [EOL] return modifySecondaryTypesByAnnotation(config, a, type); [EOL] }
public void testModifySecondaryTypesByAnnotationWithNonMapType() { [EOL] SerializationConfig config = new SerializationConfig(); [EOL] Annotated a = mock(Annotated.class); [EOL] JavaType type = mock(JavaType.class); [EOL] when(type.isContainerType()).thenReturn(true); [EOL] when(type.getKeyType()).thenReturn(mock(JavaType.class)); [EOL] AnnotationIntrospector intr = mock(AnnotationIntrospector.class); [EOL] when(config.getAnnotationIntrospector()).thenReturn(intr); [EOL] when(intr.findSerializationKeyType(a, type.getKeyType())).thenReturn(String.class); [EOL] try { [EOL] ObjectMapper.modifySecondaryTypesByAnnotation(config, a, type); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Illegal key-type annotation: type " + type + " is not a Map type", e.getMessage()); [EOL] } [EOL] }
public void testModifySecondaryTypesByAnnotationWithMapTypeKeyAnnotation() { [EOL] SerializationConfig config = new SerializationConfig(); [EOL] Annotated a = mock(Annotated.class); [EOL] MapType type = mock(MapType.class); [EOL] when(type.isContainerType()).thenReturn(true); [EOL] when(type.getKeyType()).thenReturn(mock(JavaType.class)); [EOL] AnnotationIntrospector intr = mock(AnnotationIntrospector.class); [EOL] when(config.getAnnotationIntrospector()).thenReturn(intr); [EOL] Class<?> keyClass = String.class; [EOL] when(intr.findSerializationKeyType(a, type.getKeyType())).thenReturn(keyClass); [EOL] when(type.widenKey(keyClass)).thenReturn(type); [EOL] JavaType result = ObjectMapper.modifySecondaryTypesByAnnotation(config, a, type); [EOL] assertSame(type, result); [EOL] }
public void testModifySecondaryTypesByAnnotationWithMapTypeContentAnnotation() { [EOL] SerializationConfig config = new SerializationConfig(); [EOL] Annotated a = mock(Annotated.class); [EOL] MapType type = mock(MapType.class); [EOL] when(type.isContainerType()).thenReturn(true); [EOL] when(type.getContentType()).thenReturn(mock(JavaType.class)); [EOL] AnnotationIntrospector intr = mock(AnnotationIntrospector.class); [EOL] when(config.getAnnotationIntrospector()).thenReturn(intr); [EOL] Class<?> contentType = String.class; [EOL] when(intr.findSerializationContentType(a, type.getContentType())).thenReturn(contentType); [EOL] when(type.widenContentsBy(contentType)).thenReturn(type); [EOL] JavaType result = ObjectMapper.modifySecondaryTypesByAnnotation(config, a, type); [EOL] assertSame(type, result); [EOL] }
public void testModifySecondaryTypesByAnnotationWithNonContainerType() { [EOL] SerializationConfig config = new SerializationConfig(); [EOL] Annotated a = mock(Annotated.class); [EOL] JavaType type = mock(JavaType.class); [EOL] when(type.isContainerType()).thenReturn(false); [EOL] AnnotationIntrospector intr = mock(AnnotationIntrospector.class); [EOL] when(config.getAnnotationIntrospector()).thenReturn(intr); [EOL] JavaType result = ObjectMapper.modifySecondaryTypesByAnnotation(config, a, type); [EOL] assertSame(type, result); [EOL] }
public void testFindContentSerializerWithNonNullSerializer() throws JsonMappingException { [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] Annotated a = mock(Annotated.class); [EOL] AnnotationIntrospector intr = mock(AnnotationIntrospector.class); [EOL] JsonSerializer<Object> expectedSerializer = mock(JsonSerializer.class); [EOL] when(prov.getAnnotationIntrospector()).thenReturn(intr); [EOL] when(intr.findContentSerializer(a)).thenReturn(expectedSerializer); [EOL] when(prov.serializerInstance(a, expectedSerializer)).thenReturn(expectedSerializer); [EOL] JsonSerializer<Object> result = _findContentSerializer(prov, a); [EOL] assertNotNull(result); [EOL] assertSame(expectedSerializer, result); [EOL] }
public void testFindContentSerializerWithNullSerializer() throws JsonMappingException { [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] Annotated a = mock(Annotated.class); [EOL] AnnotationIntrospector intr = mock(AnnotationIntrospector.class); [EOL] when(prov.getAnnotationIntrospector()).thenReturn(intr); [EOL] when(intr.findContentSerializer(a)).thenReturn(null); [EOL] JsonSerializer<Object> result = _findContentSerializer(prov, a); [EOL] assertNull(result); [EOL] }
public void testUsesStaticTypingWithTypeSerializerNotNull() { [EOL] SerializationConfig config = mock(SerializationConfig.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] TypeSerializer typeSer = mock(TypeSerializer.class); [EOL] boolean result = usesStaticTyping(config, beanDesc, typeSer); [EOL] assertFalse(result); [EOL] }
public void testUsesStaticTypingWithAnnotationTypingStatic() { [EOL] SerializationConfig config = mock(SerializationConfig.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] AnnotationIntrospector intr = mock(AnnotationIntrospector.class); [EOL] when(config.getAnnotationIntrospector()).thenReturn(intr); [EOL] when(intr.findSerializationTyping(any())).thenReturn(JsonSerialize.Typing.STATIC); [EOL] boolean result = usesStaticTyping(config, beanDesc, null); [EOL] assertTrue(result); [EOL] }
public void testUsesStaticTypingWithAnnotationTypingNonStatic() { [EOL] SerializationConfig config = mock(SerializationConfig.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] AnnotationIntrospector intr = mock(AnnotationIntrospector.class); [EOL] when(config.getAnnotationIntrospector()).thenReturn(intr); [EOL] when(intr.findSerializationTyping(any())).thenReturn(JsonSerialize.Typing.DYNAMIC); [EOL] boolean result = usesStaticTyping(config, beanDesc, null); [EOL] assertFalse(result); [EOL] }
public void testUsesStaticTypingWithAnnotationTypingNullConfigEnabled() { [EOL] SerializationConfig config = mock(SerializationConfig.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] when(config.getAnnotationIntrospector()).thenReturn(mock(AnnotationIntrospector.class)); [EOL] when(config.isEnabled(MapperFeature.USE_STATIC_TYPING)).thenReturn(true); [EOL] boolean result = usesStaticTyping(config, beanDesc, null); [EOL] assertTrue(result); [EOL] }
public void testUsesStaticTypingWithAnnotationTypingNullConfigDisabled() { [EOL] SerializationConfig config = mock(SerializationConfig.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] when(config.getAnnotationIntrospector()).thenReturn(mock(AnnotationIntrospector.class)); [EOL] when(config.isEnabled(MapperFeature.USE_STATIC_TYPING)).thenReturn(false); [EOL] boolean result = usesStaticTyping(config, beanDesc, null); [EOL] assertFalse(result); [EOL] }
public void testAnnotatedMemberWithNullAnnotations() { [EOL] AnnotatedMember annotatedMember = new AnnotatedMember(null); [EOL] assertNull(annotatedMember._annotations); [EOL] }
public void testAnnotatedMemberWithNonNullAnnotations() { [EOL] AnnotationMap annotations = new AnnotationMap(); [EOL] AnnotatedMember annotatedMember = new AnnotatedMember(annotations); [EOL] assertNotNull(annotatedMember._annotations); [EOL] assertSame(annotations, annotatedMember._annotations); [EOL] }
public void testGetAllAnnotations() { [EOL] MyObject obj = new MyObject(); [EOL] AnnotationMap expectedAnnotations = new AnnotationMap(); [EOL] obj._annotations = expectedAnnotations; [EOL] AnnotationMap actualAnnotations = obj.getAllAnnotations(); [EOL] assertSame("The annotations should be the same", expectedAnnotations, actualAnnotations); [EOL] }
public void testAddIfNotPresentWithNonNullAnnotation() { [EOL] AnnotationCollector collector = new AnnotationCollector(); [EOL] Annotation annotation = new SomeAnnotationImpl(); [EOL] collector.addIfNotPresent(annotation); [EOL] assertTrue(collector.has(annotation)); [EOL] }
public void testAddIfNotPresentWithNullAnnotation() { [EOL] AnnotationCollector collector = new AnnotationCollector(); [EOL] collector.addIfNotPresent(null); [EOL] assertFalse(collector.has(null)); [EOL] }
public void testFixAccessWithAccessibleMember() { [EOL] MemberClass member = new MemberClass(); [EOL] member.makeAccessible(); // Hypothetical method to make the member accessible [EOL] JacksonMember jacksonMember = new JacksonMember(member); // Hypothetical wrapper class [EOL] jacksonMember.fixAccess(); [EOL] assertTrue(member.isAccessible()); // Assuming isAccessible() method exists to check access [EOL] }
public void testFixAccessWithInaccessibleMember() { [EOL] MemberClass member = new MemberClass(); [EOL] JacksonMember jacksonMember = new JacksonMember(member); // Hypothetical wrapper class [EOL] jacksonMember.fixAccess(); [EOL] assertTrue(member.isAccessible()); // Assuming isAccessible() method exists to check access [EOL] }
public void testSerializeWithFailOnEmptyBeansEnabled() throws IOException { [EOL] Object value = new Object(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] when(provider.isEnabled(SerializationFeature.FAIL_ON_EMPTY_BEANS)).thenReturn(true); [EOL] try { [EOL] serialize(value, jgen, provider); [EOL] fail("Expected JsonMappingException"); [EOL] } catch (JsonMappingException e) { [EOL] } [EOL] verify(jgen, never()).writeStartObject(); [EOL] verify(jgen, never()).writeEndObject(); [EOL] }
public void testSerializeWithFailOnEmptyBeansDisabled() throws IOException { [EOL] Object value = new Object(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] when(provider.isEnabled(SerializationFeature.FAIL_ON_EMPTY_BEANS)).thenReturn(false); [EOL] serialize(value, jgen, provider); [EOL] verify(jgen).writeStartObject(); [EOL] verify(jgen).writeEndObject(); [EOL] }
public void testSerializeWithType_WithFailOnEmptyBeansEnabled() throws IOException { [EOL] Object value = new Object(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] TypeSerializer typeSer = mock(TypeSerializer.class); [EOL] when(provider.isEnabled(SerializationFeature.FAIL_ON_EMPTY_BEANS)).thenReturn(true); [EOL] try { [EOL] serializeWithType(value, jgen, provider, typeSer); [EOL] fail("Expected an exception for empty beans"); [EOL] } catch (JsonMappingException e) { [EOL] } [EOL] verify(typeSer, never()).writeTypePrefixForObject(any(), any()); [EOL] verify(typeSer, never()).writeTypeSuffixForObject(any(), any()); [EOL] }
public void testSerializeWithType_WithFailOnEmptyBeansDisabled() throws IOException { [EOL] Object value = new Object(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] TypeSerializer typeSer = mock(TypeSerializer.class); [EOL] when(provider.isEnabled(SerializationFeature.FAIL_ON_EMPTY_BEANS)).thenReturn(false); [EOL] serializeWithType(value, jgen, provider, typeSer); [EOL] verify(typeSer).writeTypePrefixForObject(value, jgen); [EOL] verify(typeSer).writeTypeSuffixForObject(value, jgen); [EOL] }
public void testGetAnnotationWithNullAnnotations() { [EOL] initializeWithNullAnnotations(); [EOL] Annotation result = getAnnotation(SomeAnnotation.class); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof SomeAnnotation); [EOL] }
public void testGetAnnotationWithNonNullAnnotations() { [EOL] initializeWithNonNullAnnotations(); [EOL] Annotation result = getAnnotation(SomeAnnotation.class); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof SomeAnnotation); [EOL] }
public void testGetAnnotationWithNonExistentAnnotation() { [EOL] initializeWithNonNullAnnotations(); [EOL] Annotation result = getAnnotation(SomeOtherAnnotation.class); [EOL] assertNull(result); [EOL] }
public void testGetAnnotationsWhenClassAnnotationsAreNull() { [EOL] MyClass instance = createInstanceWithNullClassAnnotations(); [EOL] Annotations result = instance.getAnnotations(); [EOL] assertNotNull(result); [EOL] verifyResolveClassAnnotationsWasCalled(); [EOL] }
public void testGetAnnotationsWhenClassAnnotationsAreNotNull() { [EOL] MyClass instance = createInstanceWithNonNullClassAnnotations(); [EOL] Annotations expected = instance._classAnnotations; [EOL] Annotations result = instance.getAnnotations(); [EOL] assertSame(expected, result); [EOL] verifyResolveClassAnnotationsWasNotCalled(); [EOL] }
public void testGetDefaultConstructorWhenCreatorsNotResolved() { [EOL] MyClass obj = new MyClass(); // Replace MyClass with the actual class name that contains getDefaultConstructor [EOL] obj._creatorsResolved = false; // Assuming _creatorsResolved is accessible, otherwise use reflection or appropriate method [EOL] AnnotatedConstructor result = obj.getDefaultConstructor(); [EOL] assertNotNull(result); [EOL] assertTrue(obj._creatorsResolved); [EOL] }
public void testGetDefaultConstructorWhenCreatorsResolved() { [EOL] MyClass obj = new MyClass(); // Replace MyClass with the actual class name that contains getDefaultConstructor [EOL] obj._creatorsResolved = true; // Assuming _creatorsResolved is accessible, otherwise use reflection or appropriate method [EOL] AnnotatedConstructor expectedConstructor = new AnnotatedConstructor(); // Replace with actual constructor object if needed [EOL] obj._defaultConstructor = expectedConstructor; // Assuming _defaultConstructor is accessible, otherwise use reflection or appropriate method [EOL] AnnotatedConstructor result = obj.getDefaultConstructor(); [EOL] assertSame(expectedConstructor, result); [EOL] }
public void testGetConstructors_creatorsNotResolved() { [EOL] List<AnnotatedConstructor> constructors = instance.getConstructors(); [EOL] assertNotNull(constructors); [EOL] assertTrue(wasResolveCreatorsCalled()); [EOL] } [EOL] public void testGetConstructors_creatorsAlreadyResolved() { [EOL] setCreatorsResolved(true); // Method to set _creatorsResolved to true [EOL] List<AnnotatedConstructor> constructors = instance.getConstructors(); [EOL] assertNotNull(constructors); [EOL] assertFalse(wasResolveCreatorsCalled()); [EOL] }

public void testGetStaticMethods_NotResolved() { [EOL] List<AnnotatedMethod> methods = instance.getStaticMethods(); [EOL] assertNotNull(methods); [EOL] }
public void testGetStaticMethods_AlreadyResolved() { [EOL] instance.setCreatorsResolved(true); [EOL] List<AnnotatedMethod> methods = instance.getStaticMethods(); [EOL] assertNotNull(methods); [EOL] }
public void testMemberMethodsWhenUninitialized() { [EOL] YourClass instance = new YourClass(); [EOL] Iterable<AnnotatedMethod> methods = instance.memberMethods(); [EOL] assertNotNull(methods); [EOL] assertTrue(instance.isResolveMemberMethodsCalled()); [EOL] }
public void testMemberMethodsWhenInitialized() { [EOL] YourClass instance = new YourClass(); [EOL] instance.initializeMemberMethodsManually(); [EOL] Iterable<AnnotatedMethod> methods = instance.memberMethods(); [EOL] assertNotNull(methods); [EOL] assertFalse(instance.isResolveMemberMethodsCalled()); [EOL] }
public void testFindMethodWithNullMemberMethods() { [EOL] instance.resolveMemberMethods(); // This call is to ensure _memberMethods is not null [EOL] AnnotatedMethod result = instance.findMethod("someMethod", new Class<?>[]{String.class, Integer.class}); [EOL] assertNotNull(result); [EOL] }
public void testFindMethodWithNonNullMemberMethods() { [EOL] AnnotatedMethod result = instance.findMethod("someMethod", new Class<?>[]{String.class, Integer.class}); [EOL] assertNotNull(result); [EOL] }
public void testFieldsWhenFieldsAreNull() { [EOL] YourClass instance = new YourClass(); [EOL] Iterable<AnnotatedField> result = instance.fields(); [EOL] assertNotNull(result); [EOL] assertTrue(instance.isResolveFieldsCalled()); [EOL] }
public void testFieldsWhenFieldsAreNotNull() { [EOL] YourClass instance = new YourClass(); [EOL] instance.initializeFields(); // This method should set _fields to a non-null value [EOL] Iterable<AnnotatedField> result = instance.fields(); [EOL] assertNotNull(result); [EOL] assertFalse(instance.isResolveFieldsCalled()); [EOL] }
public void testResolveClassAnnotationsWithNonNullIntrospectorAndPrimaryMixIn() { [EOL] _annotationIntrospector = Mockito.mock(AnnotationIntrospector.class); [EOL] _primaryMixIn = Object.class; [EOL] _class = String.class; [EOL] _superTypes = new ArrayList<>(); [EOL] _superTypes.add(Number.class); [EOL] _superTypes.add(Object.class); [EOL] resolveClassAnnotations(); [EOL] assertNotNull(_classAnnotations); [EOL] }
public void testResolveClassAnnotationsWithNonNullIntrospectorNoPrimaryMixIn() { [EOL] _annotationIntrospector = Mockito.mock(AnnotationIntrospector.class); [EOL] _primaryMixIn = null; [EOL] _class = String.class; [EOL] _superTypes = new ArrayList<>(); [EOL] _superTypes.add(Number.class); [EOL] _superTypes.add(Object.class); [EOL] resolveClassAnnotations(); [EOL] assertNotNull(_classAnnotations); [EOL] }
public void testResolveClassAnnotationsWithNullIntrospector() { [EOL] _annotationIntrospector = null; [EOL] _primaryMixIn = null; [EOL] _class = String.class; [EOL] _superTypes = new ArrayList<>(); [EOL] resolveClassAnnotations(); [EOL] assertNull(_classAnnotations); [EOL] }
public void testResolveCreatorsWithNoDeclaredConstructorsAndNoDeclaredMethods() { [EOL] _class = SomeClassWithNoDeclaredConstructorsOrMethods.class; [EOL] _constructConstructor = (ctor, bool) -> new AnnotatedConstructor(ctor); [EOL] _constructCreatorMethod = (method) -> new AnnotatedMethod(method); [EOL] _annotationIntrospector = null; [EOL] _primaryMixIn = null; [EOL] resolveCreators(); [EOL] assertTrue(_constructors.isEmpty()); [EOL] assertTrue(_creatorMethods.isEmpty()); [EOL] assertTrue(_creatorsResolved); [EOL] }
public void testResolveCreatorsWithDefaultConstructorOnly() { [EOL] _class = SomeClassWithDefaultConstructorOnly.class; [EOL] _constructConstructor = (ctor, bool) -> new AnnotatedConstructor(ctor); [EOL] _constructCreatorMethod = (method) -> new AnnotatedMethod(method); [EOL] _annotationIntrospector = null; [EOL] _primaryMixIn = null; [EOL] resolveCreators(); [EOL] assertNotNull(_defaultConstructor); [EOL] assertTrue(_constructors.isEmpty()); [EOL] assertTrue(_creatorMethods.isEmpty()); [EOL] assertTrue(_creatorsResolved); [EOL] }
public void testResolveCreatorsWithMultipleConstructorsAndMethods() { [EOL] _class = SomeClassWithMultipleConstructorsAndMethods.class; [EOL] _constructConstructor = (ctor, bool) -> new AnnotatedConstructor(ctor); [EOL] _constructCreatorMethod = (method) -> new AnnotatedMethod(method); [EOL] _annotationIntrospector = new AnnotationIntrospectorStub(); [EOL] _primaryMixIn = SomeMixinClass.class; [EOL] resolveCreators(); [EOL] assertNotNull(_defaultConstructor); [EOL] assertFalse(_constructors.isEmpty()); [EOL] assertFalse(_creatorMethods.isEmpty()); [EOL] assertTrue(_creatorsResolved); [EOL] }
public void testResolveCreatorsWithIgnoredElements() { [EOL] _class = SomeClassWithIgnoredConstructorsAndMethods.class; [EOL] _constructConstructor = (ctor, bool) -> new AnnotatedConstructor(ctor); [EOL] _constructCreatorMethod = (method) -> new AnnotatedMethod(method); [EOL] _annotationIntrospector = new AnnotationIntrospectorStub() { [EOL] @Override [EOL] public boolean hasIgnoreMarker(AnnotatedMember m) { [EOL] return true; // Simulate all members have an ignore marker [EOL] } [EOL] }; [EOL] _primaryMixIn = null; [EOL] resolveCreators(); [EOL] assertNull(_defaultConstructor); [EOL] assertTrue(_constructors.isEmpty()); [EOL] assertTrue(_creatorMethods.isEmpty()); [EOL] assertTrue(_creatorsResolved); [EOL] }
public void testResolveMemberMethods_NoMixinsNoAnnotationIntrospector() { [EOL] initTestEnvironment(null, null, null, null); [EOL] resolveMemberMethods(); [EOL] assertNotNull(_memberMethods); [EOL] assertTrue(_memberMethods.isEmpty()); [EOL] }
public void testResolveMemberMethods_WithMixinsNoAnnotationIntrospector() { [EOL] MixInResolver mockMixInResolver = createMockMixInResolver(); [EOL] initTestEnvironment(mockMixInResolver, null, null, null); [EOL] resolveMemberMethods(); [EOL] assertNotNull(_memberMethods); [EOL] assertFalse(_memberMethods.isEmpty()); [EOL] }
public void testResolveMemberMethods_NoMixinsWithAnnotationIntrospector() { [EOL] AnnotationIntrospector mockAnnotationIntrospector = createMockAnnotationIntrospector(); [EOL] initTestEnvironment(null, mockAnnotationIntrospector, null, null); [EOL] resolveMemberMethods(); [EOL] assertNotNull(_memberMethods); [EOL] }
public void testResolveMemberMethods_WithMixinsAndAnnotationIntrospector() { [EOL] MixInResolver mockMixInResolver = createMockMixInResolver(); [EOL] AnnotationIntrospector mockAnnotationIntrospector = createMockAnnotationIntrospector(); [EOL] initTestEnvironment(mockMixInResolver, mockAnnotationIntrospector, null, null); [EOL] resolveMemberMethods(); [EOL] assertNotNull(_memberMethods); [EOL] assertFalse(_memberMethods.isEmpty()); [EOL] }
public void testResolveMemberMethods_WithExceptionInMixInProcessing() { [EOL] MixInResolver mockMixInResolver = createMockMixInResolver(); [EOL] AnnotationIntrospector mockAnnotationIntrospector = createMockAnnotationIntrospectorThatThrows(); [EOL] initTestEnvironment(mockMixInResolver, mockAnnotationIntrospector, null, null); [EOL] resolveMemberMethods(); [EOL] assertNotNull(_memberMethods); [EOL] }
protected void _addClassMixIns(AnnotationMap annotations, Class<?> toMask) { [EOL] if (_mixInResolver != null) { [EOL] _addClassMixIns(annotations, toMask, _mixInResolver.findMixInClassFor(toMask)); [EOL] } [EOL] }
public void testAddClassMixIns_withNullMixin() { [EOL] AnnotationMap annotations = new AnnotationMap(); [EOL] Class<?> toMask = Object.class; [EOL] Class<?> mixin = null; [EOL] _addClassMixIns(annotations, toMask, mixin); [EOL] assertTrue(annotations.isEmpty()); [EOL] }
public void testAddClassMixIns_withValidMixinNoSuperTypes() { [EOL] AnnotationMap annotations = new AnnotationMap(); [EOL] Class<?> toMask = Object.class; [EOL] Class<?> mixin = String.class; // Assuming String.class has no custom annotations [EOL] _addClassMixIns(annotations, toMask, mixin); [EOL] assertTrue(annotations.isEmpty()); // Assuming String.class has no annotations to add [EOL] }
public void testAddClassMixIns_withValidMixinAndSuperTypes() { [EOL] AnnotationMap annotations = new AnnotationMap(); [EOL] Class<?> toMask = Object.class; [EOL] Class<?> mixin = CustomClassWithAnnotations.class; // Custom class with annotations [EOL] _addClassMixIns(annotations, toMask, mixin); [EOL] assertFalse(annotations.isEmpty()); // Assuming CustomClassWithAnnotations.class or its supertypes have annotations [EOL] }
public void testAddMemberMethods_WithNonNullMixIn() { [EOL] Class<?> cls = MyClass.class; [EOL] AnnotatedMethodMap methods = new AnnotatedMethodMap(); [EOL] Class<?> mixInCls = MyMixIn.class; [EOL] AnnotatedMethodMap mixIns = new AnnotatedMethodMap(); [EOL] _addMemberMethods(cls, methods, mixInCls, mixIns); [EOL] } [EOL] public void testAddMemberMethods_WithNullMixIn() { [EOL] Class<?> cls = MyClass.class; [EOL] AnnotatedMethodMap methods = new AnnotatedMethodMap(); [EOL] Class<?> mixInCls = null; [EOL] AnnotatedMethodMap mixIns = new AnnotatedMethodMap(); [EOL] _addMemberMethods(cls, methods, mixInCls, mixIns); [EOL] } [EOL] public void testAddMemberMethods_WithNullCls() { [EOL] Class<?> cls = null; [EOL] AnnotatedMethodMap methods = new AnnotatedMethodMap(); [EOL] Class<?> mixInCls = MyMixIn.class; [EOL] AnnotatedMethodMap mixIns = new AnnotatedMethodMap(); [EOL] _addMemberMethods(cls, methods, mixInCls, mixIns); [EOL] } [EOL] public void testAddMemberMethods_WithIncludableMemberMethod() { [EOL] Class<?> cls = MyClassWithIncludableMethod.class; [EOL] AnnotatedMethodMap methods = new AnnotatedMethodMap(); [EOL] Class<?> mixInCls = null; [EOL] AnnotatedMethodMap mixIns = new AnnotatedMethodMap(); [EOL] _addMemberMethods(cls, methods, mixInCls, mixIns); [EOL] } [EOL] public void testAddMemberMethods_WithNonIncludableMemberMethod() { [EOL] Class<?> cls = MyClassWithNonIncludableMethod.class; [EOL] AnnotatedMethodMap methods = new AnnotatedMethodMap(); [EOL] Class<?> mixInCls = null; [EOL] AnnotatedMethodMap mixIns = new AnnotatedMethodMap(); [EOL] _addMemberMethods(cls, methods, mixInCls, mixIns); [EOL] } [EOL] public void testAddMemberMethods_WithExistingMethodInMethodsMap() { [EOL] Class<?> cls = MyClassWithExistingMethod.class; [EOL] AnnotatedMethodMap methods = new AnnotatedMethodMap(); [EOL] Method existingMethod = cls.getDeclaredMethod("existingMethod"); [EOL] methods.add(_constructMethod(existingMethod)); [EOL] Class<?> mixInCls = null; [EOL] AnnotatedMethodMap mixIns = new AnnotatedMethodMap(); [EOL] _addMemberMethods(cls, methods, mixInCls, mixIns); [EOL] } [EOL] public void testAddMemberMethods_WithExistingMethodInMixInsMap() { [EOL] Class<?> cls = MyClassWithExistingMethod.class; [EOL] AnnotatedMethodMap methods = new AnnotatedMethodMap(); [EOL] Class<?> mixInCls = MyMixInWithExistingMethod.class; [EOL] AnnotatedMethodMap mixIns = new AnnotatedMethodMap(); [EOL] Method existingMethod = mixInCls.getDeclaredMethod("existingMethod"); [EOL] mixIns.add(_constructMethod(existingMethod)); [EOL] _addMemberMethods(cls, methods, mixInCls, mixIns); [EOL] } [EOL] public void testAddMemberMethods_WithInterfaceDeclaringClass() { [EOL] Class<?> cls = MyClassImplementingInterface.class; [EOL] AnnotatedMethodMap methods = new AnnotatedMethodMap(); [EOL] Class<?> mixInCls = null; [EOL] AnnotatedMethodMap mixIns = new AnnotatedMethodMap(); [EOL] _addMemberMethods(cls, methods, mixInCls, mixIns); [EOL] }
public void testFindFieldsWithNullParent() { [EOL] Map<String, AnnotatedField> fields = new LinkedHashMap<>(); [EOL] Map<String, AnnotatedField> result = _findFields(Object.class, fields); [EOL] assertTrue(result.isEmpty()); [EOL] }
public void testFindFieldsWithNonNullParent() { [EOL] Map<String, AnnotatedField> fields = new LinkedHashMap<>(); [EOL] Map<String, AnnotatedField> result = _findFields(ChildClass.class, fields); [EOL] assertFalse(result.isEmpty()); [EOL] assertNotNull(result.get("childField")); [EOL] }
public void testFindFieldsWithMixIn() { [EOL] Map<String, AnnotatedField> fields = new LinkedHashMap<>(); [EOL] _mixInResolver = new MixInResolver() { [EOL] @Override [EOL] public Class<?> findMixInClassFor(Class<?> cls) { [EOL] return MixIn.class; [EOL] } [EOL] }; [EOL] Map<String, AnnotatedField> result = _findFields(ChildClass.class, fields); [EOL] assertFalse(result.isEmpty()); [EOL] assertNotNull(result.get("mixinField")); [EOL] }
public void test_constructMethodWithNullIntrospector() { [EOL] Method method = String.class.getMethod("toString"); [EOL] MyClass instance = new MyClass(null); // Assuming the constructor takes an AnnotationIntrospector [EOL] AnnotatedMethod result = instance._constructMethod(method); [EOL] assertNotNull(result); [EOL] assertEquals(method, result.getAnnotated()); [EOL] assertTrue(result.getAnnotations().isEmpty()); [EOL] }
public void test_constructMethodWithNonNullIntrospector() { [EOL] Method method = String.class.getMethod("toString"); [EOL] MyClass instance = new MyClass(new AnnotationIntrospectorStub()); // Assuming the constructor takes an AnnotationIntrospector [EOL] AnnotatedMethod result = instance._constructMethod(method); [EOL] assertNotNull(result); [EOL] assertEquals(method, result.getAnnotated()); [EOL] assertFalse(result.getAnnotations().isEmpty()); // Assuming the introspector adds some annotations [EOL] }
public void testConstructConstructorWithNullIntrospectorAndDefaultCtor() { [EOL] Constructor<?> ctor = SomeClass.class.getDeclaredConstructors()[0]; [EOL] AnnotatedConstructor result = _constructConstructor(ctor, true); [EOL] assertNotNull(result); [EOL] }
public void testConstructConstructorWithNullIntrospectorAndNonDefaultCtor() { [EOL] Constructor<?> ctor = SomeOtherClass.class.getDeclaredConstructors()[0]; [EOL] AnnotatedConstructor result = _constructConstructor(ctor, false); [EOL] assertNotNull(result); [EOL] }
public void testConstructConstructorWithMismatchedAnnotations() { [EOL] Constructor<?> ctor = MismatchedAnnotationsClass.class.getDeclaredConstructors()[0]; [EOL] try { [EOL] _constructConstructor(ctor, false); [EOL] fail("Expected IllegalStateException due to mismatched annotations"); [EOL] } catch (IllegalStateException e) { [EOL] } [EOL] }
public void testConstructConstructorWithEnumClass() { [EOL] Constructor<?> ctor = EnumClass.class.getDeclaredConstructors()[0]; [EOL] AnnotatedConstructor result = _constructConstructor(ctor, false); [EOL] assertNotNull(result); [EOL] }
public void testConstructConstructorWithMemberClass() { [EOL] Constructor<?> ctor = MemberClass.class.getDeclaredConstructors()[0]; [EOL] AnnotatedConstructor result = _constructConstructor(ctor, false); [EOL] assertNotNull(result); [EOL] }
public void testConstructCreatorMethodWithNullIntrospector() { [EOL] Method m = MyTestClass.class.getDeclaredMethod("myTestMethod"); [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] AnnotatedMethod am = mapper._constructCreatorMethod(m); [EOL] assertNotNull(am); [EOL] assertEquals(m, am.getAnnotated()); [EOL] assertTrue(am.getAllAnnotations().isEmpty()); [EOL] for (AnnotationMap paramAnnotations : am.getParameterAnnotations()) { [EOL] assertTrue(paramAnnotations.isEmpty()); [EOL] } [EOL] }
public void testConstructCreatorMethodWithNonNullIntrospector() { [EOL] Method m = MyTestClass.class.getDeclaredMethod("myTestMethod"); [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] mapper.setAnnotationIntrospector(new JacksonAnnotationIntrospector()); [EOL] AnnotatedMethod am = mapper._constructCreatorMethod(m); [EOL] assertNotNull(am); [EOL] assertEquals(m, am.getAnnotated()); [EOL] assertFalse(am.getAllAnnotations().isEmpty()); [EOL] for (AnnotationMap paramAnnotations : am.getParameterAnnotations()) { [EOL] assertFalse(paramAnnotations.isEmpty()); [EOL] } [EOL] }
public void testIsIncludableMemberMethod_StaticMethod() { [EOL] Method staticMethod = MyClass.class.getDeclaredMethod("staticMethod", null); [EOL] boolean result = _isIncludableMemberMethod(staticMethod); [EOL] assertFalse(result); [EOL] } [EOL] public void testIsIncludableMemberMethod_SyntheticMethod() { [EOL] Method syntheticMethod = MySyntheticClass.class.getDeclaredMethod("syntheticMethod", null); [EOL] boolean result = _isIncludableMemberMethod(syntheticMethod); [EOL] assertFalse(result); [EOL] } [EOL] public void testIsIncludableMemberMethod_BridgeMethod() { [EOL] Method bridgeMethod = MyBridgeClass.class.getDeclaredMethod("bridgeMethod", null); [EOL] boolean result = _isIncludableMemberMethod(bridgeMethod); [EOL] assertFalse(result); [EOL] } [EOL] public void testIsIncludableMemberMethod_WithZeroParameters() { [EOL] Method noParamMethod = MyRegularClass.class.getDeclaredMethod("noParamMethod", null); [EOL] boolean result = _isIncludableMemberMethod(noParamMethod); [EOL] assertTrue(result); [EOL] } [EOL] public void testIsIncludableMemberMethod_WithOneParameter() { [EOL] Method oneParamMethod = MyRegularClass.class.getDeclaredMethod("oneParamMethod", String.class); [EOL] boolean result = _isIncludableMemberMethod(oneParamMethod); [EOL] assertTrue(result); [EOL] } [EOL] public void testIsIncludableMemberMethod_WithTwoParameters() { [EOL] Method twoParamMethod = MyRegularClass.class.getDeclaredMethod("twoParamMethod", String.class, Integer.TYPE); [EOL] boolean result = _isIncludableMemberMethod(twoParamMethod); [EOL] assertTrue(result); [EOL] } [EOL] public void testIsIncludableMemberMethod_WithThreeParameters() { [EOL] Method threeParamMethod = MyRegularClass.class.getDeclaredMethod("threeParamMethod", String.class, Integer.TYPE, Boolean.TYPE); [EOL] boolean result = _isIncludableMemberMethod(threeParamMethod); [EOL] assertFalse(result); [EOL] }

public void testIsIncludableField_Synthetic() { [EOL] Field syntheticField = getSyntheticField(); // Assume this method provides a synthetic field [EOL] boolean result = _isIncludableField(syntheticField); [EOL] assertFalse(result); [EOL] } [EOL] public void testIsIncludableField_Static() { [EOL] Field staticField = getStaticField(); // Assume this method provides a static field [EOL] boolean result = _isIncludableField(staticField); [EOL] assertFalse(result); [EOL] } [EOL] public void testIsIncludableField_Transient() { [EOL] Field transientField = getTransientField(); // Assume this method provides a transient field [EOL] boolean result = _isIncludableField(transientField); [EOL] assertFalse(result); [EOL] } [EOL] public void testIsIncludableField_Includable() { [EOL] Field includableField = getIncludableField(); // Assume this method provides a non-static, non-transient, non-synthetic field [EOL] boolean result = _isIncludableField(includableField); [EOL] assertTrue(result); [EOL] }
private Field getSyntheticField() { [EOL] } [EOL] private Field getStaticField() { [EOL] } [EOL] private Field getTransientField() { [EOL] } [EOL] private Field getIncludableField() { [EOL] }
public void testCollectRelevantAnnotationsEmpty() { [EOL] Annotation[][] anns = new Annotation[0][]; [EOL] AnnotationMap[] result = _collectRelevantAnnotations(anns); [EOL] assertNotNull(result); [EOL] assertEquals(0, result.length); [EOL] }
public void testCollectRelevantAnnotationsSingleElement() { [EOL] Annotation[][] anns = new Annotation[1][]; [EOL] anns[0] = new Annotation[] { /* mock or create an annotation instance */ }; [EOL] AnnotationMap[] result = _collectRelevantAnnotations(anns); [EOL] assertNotNull(result); [EOL] assertEquals(1, result.length); [EOL] assertNotNull(result[0]); [EOL] }
public void testCollectRelevantAnnotationsMultipleElements() { [EOL] Annotation[][] anns = new Annotation[2][]; [EOL] anns[0] = new Annotation[] { /* mock or create an annotation instance */ }; [EOL] anns[1] = new Annotation[] { /* mock or create another annotation instance */ }; [EOL] AnnotationMap[] result = _collectRelevantAnnotations(anns); [EOL] assertNotNull(result); [EOL] assertEquals(2, result.length); [EOL] assertNotNull(result[0]); [EOL] assertNotNull(result[1]); [EOL] }
public void testAddAnnotationsIfNotPresentWithNullAnnotations() { [EOL] AnnotatedMember target = mock(AnnotatedMember.class); [EOL] _addAnnotationsIfNotPresent(target, null); [EOL] verify(target, never()).addIfNotPresent(any(Annotation.class)); [EOL] }
public void testAddAnnotationsIfNotPresentWithEmptyAnnotations() { [EOL] AnnotatedMember target = mock(AnnotatedMember.class); [EOL] _addAnnotationsIfNotPresent(target, new Annotation[0]); [EOL] verify(target, never()).addIfNotPresent(any(Annotation.class)); [EOL] }
public void testAddAnnotationsIfNotPresentWithNonBundleAnnotations() { [EOL] AnnotatedMember target = mock(AnnotatedMember.class); [EOL] Annotation ann = mock(Annotation.class); [EOL] when(_isAnnotationBundle(ann)).thenReturn(false); [EOL] _addAnnotationsIfNotPresent(target, new Annotation[]{ann}); [EOL] verify(target).addIfNotPresent(ann); [EOL] }
public void testAddAnnotationsIfNotPresentWithBundleAnnotations() { [EOL] AnnotatedMember target = mock(AnnotatedMember.class); [EOL] Annotation ann = mock(Annotation.class); [EOL] when(_isAnnotationBundle(ann)).thenReturn(true); [EOL] when(ann.annotationType()).thenReturn((Class) DummyAnnotation.class); [EOL] _addAnnotationsIfNotPresent(target, new Annotation[]{ann}); [EOL] verify(target, never()).addIfNotPresent(ann); [EOL] verify(target, atLeastOnce()).addIfNotPresent(any(Annotation.class)); [EOL] }
public void testAddAnnotationsIfNotPresentWithMixedAnnotations() { [EOL] AnnotatedMember target = mock(AnnotatedMember.class); [EOL] Annotation bundleAnn = mock(Annotation.class); [EOL] Annotation nonBundleAnn = mock(Annotation.class); [EOL] when(_isAnnotationBundle(bundleAnn)).thenReturn(true); [EOL] when(_isAnnotationBundle(nonBundleAnn)).thenReturn(false); [EOL] when(bundleAnn.annotationType()).thenReturn((Class) DummyAnnotation.class); [EOL] _addAnnotationsIfNotPresent(target, new Annotation[]{bundleAnn, nonBundleAnn}); [EOL] verify(target).addIfNotPresent(nonBundleAnn); [EOL] verify(target, atLeastOnce()).addIfNotPresent(any(Annotation.class)); [EOL] }
public void testToString() { [EOL] AnnotedClass instance = new AnnotedClass(SomeClass.class); [EOL] String expected = "[AnnotedClass SomeClass]"; [EOL] String actual = instance.toString(); [EOL] assertEquals(expected, actual); [EOL] }
public void testTypeDeserializerBaseWithNullDefaultImpl() { [EOL] JavaType baseType = mock(JavaType.class); [EOL] TypeIdResolver idRes = mock(TypeIdResolver.class); [EOL] String typePropertyName = "type"; [EOL] boolean typeIdVisible = true; [EOL] TypeDeserializerBase deserializer = new TypeDeserializerBase(baseType, idRes, typePropertyName, typeIdVisible, null); [EOL] assertNull(deserializer._defaultImpl); [EOL] assertEquals(baseType, deserializer._baseType); [EOL] assertEquals(idRes, deserializer._idResolver); [EOL] assertEquals(typePropertyName, deserializer._typePropertyName); [EOL] assertTrue(deserializer._typeIdVisible); [EOL] assertNotNull(deserializer._deserializers); [EOL] assertNull(deserializer._property); [EOL] }
public void testTypeDeserializerBaseWithNonNullDefaultImpl() { [EOL] JavaType baseType = mock(JavaType.class); [EOL] TypeIdResolver idRes = mock(TypeIdResolver.class); [EOL] String typePropertyName = "type"; [EOL] boolean typeIdVisible = true; [EOL] Class<?> defaultImpl = Object.class; [EOL] when(baseType.forcedNarrowBy(defaultImpl)).thenReturn(baseType); [EOL] TypeDeserializerBase deserializer = new TypeDeserializerBase(baseType, idRes, typePropertyName, typeIdVisible, defaultImpl); [EOL] assertNotNull(deserializer._defaultImpl); [EOL] assertEquals(baseType, deserializer._baseType); [EOL] assertEquals(idRes, deserializer._idResolver); [EOL] assertEquals(typePropertyName, deserializer._typePropertyName); [EOL] assertTrue(deserializer._typeIdVisible); [EOL] assertNotNull(deserializer._deserializers); [EOL] assertNull(deserializer._property); [EOL] }
public void testTypeDeserializerBaseCopyConstructor() { [EOL] JavaType baseType = mock(JavaType.class); [EOL] TypeIdResolver idResolver = mock(TypeIdResolver.class); [EOL] String typePropertyName = "type"; [EOL] boolean typeIdVisible = true; [EOL] HashMap<JavaType, JsonDeserializer<Object>> deserializers = new HashMap<>(); [EOL] JavaType defaultImpl = mock(JavaType.class); [EOL] JsonDeserializer<Object> defaultImplDeserializer = mock(JsonDeserializer.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] TypeDeserializerBase original = new TypeDeserializerBase(baseType, idResolver, typePropertyName, typeIdVisible, defaultImpl); [EOL] original._deserializers = deserializers; [EOL] original._defaultImplDeserializer = defaultImplDeserializer; [EOL] TypeDeserializerBase copy = new TypeDeserializerBase(original, property); [EOL] assertEquals(original._baseType, copy._baseType); [EOL] assertEquals(original._idResolver, copy._idResolver); [EOL] assertEquals(original._typePropertyName, copy._typePropertyName); [EOL] assertEquals(original._typeIdVisible, copy._typeIdVisible); [EOL] assertEquals(original._deserializers, copy._deserializers); [EOL] assertEquals(original._defaultImpl, copy._defaultImpl); [EOL] assertEquals(original._defaultImplDeserializer, copy._defaultImplDeserializer); [EOL] assertEquals(property, copy._property); [EOL] }
public void testGetPropertyNameWhenTypePropertyNameIsNull() { [EOL] TypeIdResolver typeIdResolver = new MyTypeIdResolver(null); [EOL] String propertyName = typeIdResolver.getPropertyName(); [EOL] assertNull(propertyName); [EOL] }
public void testGetPropertyNameWhenTypePropertyNameIsNonNull() { [EOL] String expectedPropertyName = "typeName"; [EOL] TypeIdResolver typeIdResolver = new MyTypeIdResolver(expectedPropertyName); [EOL] String propertyName = typeIdResolver.getPropertyName(); [EOL] assertEquals(expectedPropertyName, propertyName); [EOL] }
public void testFindDeserializerWithUnknownTypeId() throws IOException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] String typeId = "unknownTypeId"; [EOL] when(_idResolver.typeFromId(typeId)).thenReturn(null); [EOL] when(ctxt.unknownTypeException(_baseType, typeId)).thenThrow(new JsonMappingException("Unknown type")); [EOL] try { [EOL] _findDeserializer(ctxt, typeId); [EOL] fail("Should have thrown JsonMappingException"); [EOL] } catch (JsonMappingException e) { [EOL] } [EOL] }
public void testFindDeserializerWithKnownTypeId() throws IOException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] String typeId = "knownTypeId"; [EOL] JavaType type = mock(JavaType.class); [EOL] JsonDeserializer<Object> expectedDeserializer = mock(JsonDeserializer.class); [EOL] when(_idResolver.typeFromId(typeId)).thenReturn(type); [EOL] when(ctxt.findContextualValueDeserializer(type, _property)).thenReturn(expectedDeserializer); [EOL] JsonDeserializer<Object> actualDeserializer = _findDeserializer(ctxt, typeId); [EOL] assertSame("Deserializers should be the same", expectedDeserializer, actualDeserializer); [EOL] }
public void testFindDeserializerWithDefaultImpl() throws IOException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] String typeId = "defaultImplTypeId"; [EOL] when(_idResolver.typeFromId(typeId)).thenReturn(null); [EOL] JsonDeserializer<Object> defaultDeserializer = mock(JsonDeserializer.class); [EOL] when(_findDefaultImplDeserializer(ctxt)).thenReturn(defaultDeserializer); [EOL] _defaultImpl = new Object(); [EOL] JsonDeserializer<Object> actualDeserializer = _findDeserializer(ctxt, typeId); [EOL] assertSame("Deserializers should be the same", defaultDeserializer, actualDeserializer); [EOL] }
public void testFindDeserializerWithBaseTypeNarrowing() throws IOException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] String typeId = "baseTypeNarrowingTypeId"; [EOL] JavaType baseType = mock(JavaType.class); [EOL] JavaType narrowType = mock(JavaType.class); [EOL] Class<?> rawClass = Object.class; [EOL] JsonDeserializer<Object> expectedDeserializer = mock(JsonDeserializer.class); [EOL] when(_idResolver.typeFromId(typeId)).thenReturn(narrowType); [EOL] when(baseType.getClass()).thenReturn(JavaType.class); [EOL] when(narrowType.getClass()).thenReturn(JavaType.class); [EOL] when(narrowType.getRawClass()).thenReturn(rawClass); [EOL] when(baseType.narrowBy(rawClass)).thenReturn(narrowType); [EOL] when(ctxt.findContextualValueDeserializer(narrowType, _property)).thenReturn(expectedDeserializer); [EOL] _baseType = baseType; [EOL] JsonDeserializer<Object> actualDeserializer = _findDeserializer(ctxt, typeId); [EOL] assertSame("Deserializers should be the same", expectedDeserializer, actualDeserializer); [EOL] }
public void testFindDefaultImplDeserializerWithNullDefaultImplAndFailOnInvalidSubtypeDisabled() throws IOException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(ctxt.isEnabled(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE)).thenReturn(false); [EOL] JsonDeserializer<Object> result = _findDefaultImplDeserializer(ctxt); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof NullifyingDeserializer); [EOL] }
public void testFindDefaultImplDeserializerWithNullDefaultImplAndFailOnInvalidSubtypeEnabled() throws IOException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(ctxt.isEnabled(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE)).thenReturn(true); [EOL] JsonDeserializer<Object> result = _findDefaultImplDeserializer(ctxt); [EOL] assertNull(result); [EOL] }
public void testFindDefaultImplDeserializerWithNonNullDefaultImplAndNoClass() throws IOException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] _defaultImpl = JavaType.constructFromCanonical(NoClass.class.getCanonicalName()); [EOL] JsonDeserializer<Object> result = _findDefaultImplDeserializer(ctxt); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof NullifyingDeserializer); [EOL] }
public void testFindDefaultImplDeserializerWithNonNullDefaultImplAndValidClass() throws IOException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JavaType mockJavaType = mock(JavaType.class); [EOL] when(mockJavaType.getRawClass()).thenReturn(String.class); [EOL] _defaultImpl = mockJavaType; [EOL] JsonDeserializer<Object> mockDeserializer = mock(JsonDeserializer.class); [EOL] when(ctxt.findContextualValueDeserializer(any(JavaType.class), any(BeanProperty.class))).thenReturn(mockDeserializer); [EOL] JsonDeserializer<Object> result = _findDefaultImplDeserializer(ctxt); [EOL] assertNotNull(result); [EOL] assertSame(mockDeserializer, result); [EOL] }
public void testDeserializerForCreatorWithStringParameter() { [EOL] DeserializationConfig config = new DeserializationConfig(...); // Provide actual initialization [EOL] Class<?> enumClass = ...; // Provide actual enum class [EOL] AnnotatedMethod factory = ...; // Provide actual AnnotatedMethod with String parameter [EOL] JsonDeserializer<?> deserializer = deserializerForCreator(config, enumClass, factory); [EOL] assertNull(((FactoryBasedDeserializer) deserializer).getValueInstantiator().getParameterType()); [EOL] }
public void testDeserializerForCreatorWithIntegerParameter() { [EOL] DeserializationConfig config = new DeserializationConfig(...); // Provide actual initialization [EOL] Class<?> enumClass = ...; // Provide actual enum class [EOL] AnnotatedMethod factory = ...; // Provide actual AnnotatedMethod with Integer parameter [EOL] JsonDeserializer<?> deserializer = deserializerForCreator(config, enumClass, factory); [EOL] assertEquals(Integer.class, ((FactoryBasedDeserializer) deserializer).getValueInstantiator().getParameterType()); [EOL] }
public void testDeserializerForCreatorWithLongParameter() { [EOL] DeserializationConfig config = new DeserializationConfig(...); // Provide actual initialization [EOL] Class<?> enumClass = ...; // Provide actual enum class [EOL] AnnotatedMethod factory = ...; // Provide actual AnnotatedMethod with Long parameter [EOL] JsonDeserializer<?> deserializer = deserializerForCreator(config, enumClass, factory); [EOL] assertEquals(Long.class, ((FactoryBasedDeserializer) deserializer).getValueInstantiator().getParameterType()); [EOL] }
public void testDeserializerForCreatorWithInvalidParameter() { [EOL] DeserializationConfig config = new DeserializationConfig(...); // Provide actual initialization [EOL] Class<?> enumClass = ...; // Provide actual enum class [EOL] AnnotatedMethod factory = ...; // Provide actual AnnotatedMethod with invalid parameter [EOL] try { [EOL] deserializerForCreator(config, enumClass, factory); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testDeserializeWithValueString() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("ENUM_VALUE"); [EOL] Enum<?> result = deserialize(jp, ctxt); [EOL] assertNotNull(result); [EOL] assertEquals("ENUM_VALUE", result.name()); [EOL] }
public void testDeserializeWithFieldName() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.FIELD_NAME); [EOL] when(jp.getText()).thenReturn("ENUM_VALUE"); [EOL] Enum<?> result = deserialize(jp, ctxt); [EOL] assertNotNull(result); [EOL] assertEquals("ENUM_VALUE", result.name()); [EOL] }
public void testDeserializeWithEmptyStringAndAcceptEmptyAsNull() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn(""); [EOL] when(ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)).thenReturn(true); [EOL] Enum<?> result = deserialize(jp, ctxt); [EOL] assertNull(result); [EOL] }
public void testDeserializeWithUnknownEnumName() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("UNKNOWN_ENUM"); [EOL] when(ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)).thenReturn(false); [EOL] assertThrows(JsonProcessingException.class, () -> deserialize(jp, ctxt)); [EOL] }
public void testDeserializeWithNumberAndFailOnNumbersForEnums() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); [EOL] when(ctxt.isEnabled(DeserializationFeature.FAIL_ON_NUMBERS_FOR_ENUMS)).thenReturn(true); [EOL] assertThrows(JsonMappingException.class, () -> deserialize(jp, ctxt)); [EOL] }
public void testDeserializeWithValidNumber() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); [EOL] when(jp.getIntValue()).thenReturn(1); [EOL] Enum<?> result = deserialize(jp, ctxt); [EOL] assertNotNull(result); [EOL] assertEquals("ENUM_VALUE", result.name()); [EOL] }
public void testDeserializeWithInvalidNumber() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); [EOL] when(jp.getIntValue()).thenReturn(-1); [EOL] when(ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)).thenReturn(false); [EOL] assertThrows(JsonMappingException.class, () -> deserialize(jp, ctxt)); [EOL] }
public void testDeserializeWithInvalidToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); [EOL] assertThrows(JsonMappingException.class, () -> deserialize(jp, ctxt)); [EOL] }
public void testFactoryBasedDeserializerWithValidInput() { [EOL] Class<?> cls = MyEnum.class; // Assuming MyEnum is an enum type for this test [EOL] AnnotatedMethod f = createAnnotatedMethod(); // Stub method to create AnnotatedMethod [EOL] Class<?> inputType = String.class; // Assuming factory method takes a String as input [EOL] FactoryBasedDeserializer deserializer = new FactoryBasedDeserializer(cls, f, inputType); [EOL] assertNotNull(deserializer); [EOL] assertEquals(MyEnum.class, deserializer._enumClass); [EOL] assertEquals(f.getAnnotated(), deserializer._factory); [EOL] assertEquals(String.class, deserializer._inputType); [EOL] }
public void testDeserializeWithNullInputType() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getText()).thenReturn("test"); [EOL] CustomDeserializer deserializer = new CustomDeserializer(null, null, null); [EOL] Object result = deserializer.deserialize(jp, ctxt); [EOL] assertEquals("test", result); [EOL] }
public void testDeserializeWithIntegerInputType() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getValueAsInt()).thenReturn(123); [EOL] CustomDeserializer deserializer = new CustomDeserializer(Integer.class, null, null); [EOL] Object result = deserializer.deserialize(jp, ctxt); [EOL] assertEquals(Integer.valueOf(123), result); [EOL] }
public void testDeserializeWithLongInputType() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getValueAsLong()).thenReturn(123L); [EOL] CustomDeserializer deserializer = new CustomDeserializer(Long.class, null, null); [EOL] Object result = deserializer.deserialize(jp, ctxt); [EOL] assertEquals(Long.valueOf(123L), result); [EOL] }
public void testDeserializeWithInvalidInputType() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(ctxt.mappingException(any(Class.class))).thenThrow(new JsonMappingException("error")); [EOL] CustomDeserializer deserializer = new CustomDeserializer(String.class, null, null); [EOL] try { [EOL] deserializer.deserialize(jp, ctxt); [EOL] fail("Expected JsonMappingException to be thrown"); [EOL] } catch (JsonMappingException e) { [EOL] assertEquals("error", e.getMessage()); [EOL] } [EOL] }
public void testDeserializeWithInvocationTargetException() throws IOException, IllegalAccessException, InvocationTargetException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Method factory = CustomEnum.class.getMethod("fromValue", Object.class); [EOL] when(jp.getText()).thenReturn("test"); [EOL] when(factory.invoke(any(), any())).thenThrow(new InvocationTargetException(new Exception("invocation error"))); [EOL] CustomDeserializer deserializer = new CustomDeserializer(null, factory, CustomEnum.class); [EOL] try { [EOL] deserializer.deserialize(jp, ctxt); [EOL] fail("Expected IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertTrue(e.getCause() instanceof InvocationTargetException); [EOL] assertEquals("invocation error", e.getCause().getMessage()); [EOL] } [EOL] }
public void testBasicClassIntrospectorConstructor() { [EOL] new BasicClassIntrospector(); [EOL] }
public void testForSerializationWithCachedDesc() { [EOL] SerializationConfig cfg = new SerializationConfig(...); // Provide actual initialization [EOL] JavaType type = ...; // Provide actual initialization [EOL] MixInResolver r = ...; // Provide actual initialization [EOL] BasicBeanDescription expectedDesc = ...; // Provide actual initialization [EOL] _putCachedDesc(type, expectedDesc); // Assuming there is a method to cache the description [EOL] BasicBeanDescription result = forSerialization(cfg, type, r); [EOL] assertSame("Should return cached BasicBeanDescription", expectedDesc, result); [EOL] }
public void testForSerializationWithoutCachedDesc() { [EOL] SerializationConfig cfg = new SerializationConfig(...); // Provide actual initialization [EOL] JavaType type = ...; // Provide actual initialization [EOL] MixInResolver r = ...; // Provide actual initialization [EOL] BasicBeanDescription result = forSerialization(cfg, type, r); [EOL] assertNotNull("Should create a new BasicBeanDescription", result); [EOL] }
public void testForCreationWithCachedDesc() { [EOL] DeserializationConfig cfg = createDeserializationConfigMock(); [EOL] JavaType type = createJavaTypeMock(); [EOL] MixInResolver r = createMixInResolverMock(); [EOL] BasicBeanDescription expectedDesc = createBasicBeanDescriptionMock(); [EOL] BeanDescriptionCache cache = createBeanDescriptionCacheWithDesc(type, expectedDesc); [EOL] BasicBeanDescriptionFactory factory = new BasicBeanDescriptionFactory(cache); [EOL] BasicBeanDescription result = factory.forCreation(cfg, type, r); [EOL] assertSame(expectedDesc, result); [EOL] } [EOL] public void testForCreationWithoutCachedDesc() { [EOL] DeserializationConfig cfg = createDeserializationConfigMock(); [EOL] JavaType type = createJavaTypeMock(); [EOL] MixInResolver r = createMixInResolverMock(); [EOL] BasicBeanDescription expectedDesc = createBasicBeanDescriptionMock(); [EOL] BeanDescriptionCache cache = createEmptyBeanDescriptionCache(); [EOL] BasicBeanDescriptionFactory factory = new BasicBeanDescriptionFactory(cache); [EOL] BasicBeanDescription result = factory.forCreation(cfg, type, r); [EOL] assertNotNull(result); [EOL] verify(collectProperties(cfg, type, r, false, "set")); [EOL] verify(BasicBeanDescription.forDeserialization(any())); [EOL] }

public void testForClassAnnotationsWithAnnotationProcessingEnabled() { [EOL] MapperConfig<?> cfg = mock(MapperConfig.class); [EOL] JavaType type = mock(JavaType.class); [EOL] MixInResolver r = mock(MixInResolver.class); [EOL] when(cfg.isAnnotationProcessingEnabled()).thenReturn(true); [EOL] when(type.getRawClass()).thenReturn(Object.class); [EOL] when(cfg.getAnnotationIntrospector()).thenReturn(mock(AnnotationIntrospector.class)); [EOL] BasicBeanDescription result = forClassAnnotations(cfg, type, r); [EOL] assertNotNull(result); [EOL] }
public void testForClassAnnotationsWithAnnotationProcessingDisabled() { [EOL] MapperConfig<?> cfg = mock(MapperConfig.class); [EOL] JavaType type = mock(JavaType.class); [EOL] MixInResolver r = mock(MixInResolver.class); [EOL] when(cfg.isAnnotationProcessingEnabled()).thenReturn(false); [EOL] when(type.getRawClass()).thenReturn(Object.class); [EOL] when(cfg.getAnnotationIntrospector()).thenReturn(null); [EOL] BasicBeanDescription result = forClassAnnotations(cfg, type, r); [EOL] assertNotNull(result); [EOL] }
public void testCollectPropertiesWithAnnotationsEnabledForSerialization() { [EOL] MapperConfig<?> config = mock(MapperConfig.class); [EOL] JavaType type = mock(JavaType.class); [EOL] MixInResolver mixInResolver = mock(MixInResolver.class); [EOL] when(config.isAnnotationProcessingEnabled()).thenReturn(true); [EOL] when(type.getRawClass()).thenReturn(Object.class); [EOL] POJOPropertiesCollector collector = new POJOPropertiesCollector(config, type, mixInResolver, true, "set"); [EOL] POJOPropertiesCollector result = collector.collectProperties(config, type, mixInResolver, true, "set"); [EOL] assertNotNull(result); [EOL] }
public void testCollectPropertiesWithAnnotationsDisabledForSerialization() { [EOL] MapperConfig<?> config = mock(MapperConfig.class); [EOL] JavaType type = mock(JavaType.class); [EOL] MixInResolver mixInResolver = mock(MixInResolver.class); [EOL] when(config.isAnnotationProcessingEnabled()).thenReturn(false); [EOL] when(type.getRawClass()).thenReturn(Object.class); [EOL] POJOPropertiesCollector collector = new POJOPropertiesCollector(config, type, mixInResolver, true, "set"); [EOL] POJOPropertiesCollector result = collector.collectProperties(config, type, mixInResolver, true, "set"); [EOL] assertNotNull(result); [EOL] }
public void testCollectPropertiesWithAnnotationsEnabledForDeserialization() { [EOL] MapperConfig<?> config = mock(MapperConfig.class); [EOL] JavaType type = mock(JavaType.class); [EOL] MixInResolver mixInResolver = mock(MixInResolver.class); [EOL] when(config.isAnnotationProcessingEnabled()).thenReturn(true); [EOL] when(type.getRawClass()).thenReturn(Object.class); [EOL] POJOPropertiesCollector collector = new POJOPropertiesCollector(config, type, mixInResolver, false, "set"); [EOL] POJOPropertiesCollector result = collector.collectProperties(config, type, mixInResolver, false, "set"); [EOL] assertNotNull(result); [EOL] }
public void testCollectPropertiesWithAnnotationsDisabledForDeserialization() { [EOL] MapperConfig<?> config = mock(MapperConfig.class); [EOL] JavaType type = mock(JavaType.class); [EOL] MixInResolver mixInResolver = mock(MixInResolver.class); [EOL] when(config.isAnnotationProcessingEnabled()).thenReturn(false); [EOL] when(type.getRawClass()).thenReturn(Object.class); [EOL] POJOPropertiesCollector collector = new POJOPropertiesCollector(config, type, mixInResolver, false, "set"); [EOL] POJOPropertiesCollector result = collector.collectProperties(config, type, mixInResolver, false, "set"); [EOL] assertNotNull(result); [EOL] }
public void testConstructPropertyCollectorForSerialization() { [EOL] MapperConfig<?> config = mock(MapperConfig.class); [EOL] AnnotatedClass ac = mock(AnnotatedClass.class); [EOL] JavaType type = mock(JavaType.class); [EOL] boolean forSerialization = true; [EOL] String mutatorPrefix = "set"; [EOL] POJOPropertiesCollector result = constructPropertyCollector(config, ac, type, forSerialization, mutatorPrefix); [EOL] assertNotNull(result); [EOL] assertTrue(result.isForSerialization()); [EOL] assertEquals(type, result.getType()); [EOL] assertEquals(ac, result.getClassDef()); [EOL] assertEquals(mutatorPrefix, result.getMutatorPrefix()); [EOL] }
public void testConstructPropertyCollectorForDeserialization() { [EOL] MapperConfig<?> config = mock(MapperConfig.class); [EOL] AnnotatedClass ac = mock(AnnotatedClass.class); [EOL] JavaType type = mock(JavaType.class); [EOL] boolean forSerialization = false; [EOL] String mutatorPrefix = "get"; [EOL] POJOPropertiesCollector result = constructPropertyCollector(config, ac, type, forSerialization, mutatorPrefix); [EOL] assertNotNull(result); [EOL] assertFalse(result.isForSerialization()); [EOL] assertEquals(type, result.getType()); [EOL] assertEquals(ac, result.getClassDef()); [EOL] assertEquals(mutatorPrefix, result.getMutatorPrefix()); [EOL] }
public void testFindCachedDescWithStringType() { [EOL] JavaType stringType = TypeFactory.defaultInstance().constructType(String.class); [EOL] BasicBeanDescription result = _findCachedDesc(stringType); [EOL] assertSame(STRING_DESC, result); [EOL] }
public void testFindCachedDescWithBooleanType() { [EOL] JavaType booleanType = TypeFactory.defaultInstance().constructType(Boolean.TYPE); [EOL] BasicBeanDescription result = _findCachedDesc(booleanType); [EOL] assertSame(BOOLEAN_DESC, result); [EOL] }
public void testFindCachedDescWithIntegerType() { [EOL] JavaType integerType = TypeFactory.defaultInstance().constructType(Integer.TYPE); [EOL] BasicBeanDescription result = _findCachedDesc(integerType); [EOL] assertSame(INT_DESC, result); [EOL] }
public void testFindCachedDescWithLongType() { [EOL] JavaType longType = TypeFactory.defaultInstance().constructType(Long.TYPE); [EOL] BasicBeanDescription result = _findCachedDesc(longType); [EOL] assertSame(LONG_DESC, result); [EOL] }
public void testFindCachedDescWithUnrecognizedType() { [EOL] JavaType unrecognizedType = TypeFactory.defaultInstance().constructType(Object.class); [EOL] BasicBeanDescription result = _findCachedDesc(unrecognizedType); [EOL] assertNull(result); [EOL] }
public void testClassNameIdResolverWithNonNullBaseTypeAndTypeFactory() { [EOL] JavaType baseType = mock(JavaType.class); [EOL] TypeFactory typeFactory = mock(TypeFactory.class); [EOL] ClassNameIdResolver resolver = new ClassNameIdResolver(baseType, typeFactory); [EOL] assertNotNull(resolver); [EOL] }
public void testClassNameIdResolverWithNullBaseType() { [EOL] TypeFactory typeFactory = mock(TypeFactory.class); [EOL] try { [EOL] new ClassNameIdResolver(null, typeFactory); [EOL] fail("Expected IllegalArgumentException for null baseType"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testClassNameIdResolverWithNullTypeFactory() { [EOL] JavaType baseType = mock(JavaType.class); [EOL] try { [EOL] new ClassNameIdResolver(baseType, null); [EOL] fail("Expected IllegalArgumentException for null typeFactory"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testIdFromValueWithNonNullValue() { [EOL] TypeNameIdResolver resolver = new TypeNameIdResolver(null, null, false); [EOL] Object value = new Object(); [EOL] String id = resolver.idFromValue(value); [EOL] assertNotNull(id); [EOL] assertEquals(value.getClass().getName(), id); [EOL] }
public void testIdFromValueWithNullValue() { [EOL] TypeNameIdResolver resolver = new TypeNameIdResolver(null, null, false); [EOL] Object value = null; [EOL] try { [EOL] resolver.idFromValue(value); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testTypeFromIdWithGenerics() { [EOL] String id = "java.util.List<String>"; [EOL] JavaType result = typeFromId(id); [EOL] assertNotNull(result); [EOL] assertEquals("java.util.List<java.lang.String>", result.toCanonical()); [EOL] }
public void testTypeFromIdWithClassNotFound() { [EOL] String id = "com.nonexistent.FakeClass"; [EOL] try { [EOL] typeFromId(id); [EOL] fail("Expected IllegalArgumentException for non-existent class"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertTrue(e.getMessage().contains("no such class found")); [EOL] } [EOL] }
public void testTypeFromIdWithOtherException() { [EOL] String id = "java.util.List<<String>>"; // This should cause a generic parsing exception [EOL] try { [EOL] typeFromId(id); [EOL] fail("Expected IllegalArgumentException for invalid type id"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertTrue(e.getMessage().contains("Invalid type id")); [EOL] } [EOL] }
protected final String _idFrom(Object value, Class<?> cls) { [EOL] if (Enum.class.isAssignableFrom(cls)) { [EOL] if (!cls.isEnum()) { [EOL] cls = cls.getSuperclass(); [EOL] } [EOL] } [EOL] String str = cls.getName(); [EOL] if (str.startsWith("java.util")) { [EOL] if (value instanceof EnumSet<?>) { [EOL] Class<?> enumClass = ClassUtil.findEnumType((EnumSet<?>) value); [EOL] str = TypeFactory.defaultInstance().constructCollectionType(EnumSet.class, enumClass).toCanonical(); [EOL] } else if (value instanceof EnumMap<?, ?>) { [EOL] Class<?> enumClass = ClassUtil.findEnumType((EnumMap<?, ?>) value); [EOL] Class<?> valueClass = Object.class; [EOL] str = TypeFactory.defaultInstance().constructMapType(EnumMap.class, enumClass, valueClass).toCanonical(); [EOL] } else { [EOL] String end = str.substring(9); [EOL] if ((end.startsWith(".Arrays$") || end.startsWith(".Collections$")) && str.indexOf("List") >= 0) { [EOL] str = "java.util.ArrayList"; [EOL] } [EOL] } [EOL] } else if (str.indexOf('$') >= 0) { [EOL] Class<?> outer = ClassUtil.getOuterClass(cls); [EOL] if (outer != null) { [EOL] Class<?> staticType = _baseType.getRawClass(); [EOL] if (ClassUtil.getOuterClass(staticType) == null) { [EOL] cls = _baseType.getRawClass(); [EOL] str = cls.getName(); [EOL] } [EOL] } [EOL] } [EOL] return str; [EOL] }
public void testPropertyBuilderWithNonNullConfigAndBeanDesc() { [EOL] SerializationConfig config = new SerializationConfig(...); // Provide necessary parameters [EOL] BeanDescription beanDesc = new BeanDescription(...); // Provide necessary parameters [EOL] PropertyBuilder propertyBuilder = new PropertyBuilder(config, beanDesc); [EOL] assertNotNull(propertyBuilder); [EOL] assertEquals(config, propertyBuilder.getConfig()); [EOL] assertEquals(beanDesc, propertyBuilder.getBeanDesc()); [EOL] assertNotNull(propertyBuilder.getOutputProps()); [EOL] assertNotNull(propertyBuilder.getAnnotationIntrospector()); [EOL] }
public void testGetClassAnnotations() { [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] Annotations expectedAnnotations = mock(Annotations.class); [EOL] when(beanDesc.getClassAnnotations()).thenReturn(expectedAnnotations); [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] AnnotatedClass ac = AnnotatedClass.construct(mapper.constructType(Object.class), mapper.getSerializationConfig()); [EOL] BeanDescription beanDescription = mapper.getSerializationConfig().introspect(ac); [EOL] assertEquals(expectedAnnotations, beanDescription.getClassAnnotations()); [EOL] }
public void testBuildWriterWithContentTypeSerializerAndNonNullSerializationType() { [EOL] BeanPropertyDefinition propDef = mock(BeanPropertyDefinition.class); [EOL] JavaType declaredType = mock(JavaType.class); [EOL] JsonSerializer<?> ser = mock(JsonSerializer.class); [EOL] TypeSerializer typeSer = mock(TypeSerializer.class); [EOL] TypeSerializer contentTypeSer = mock(TypeSerializer.class); [EOL] AnnotatedMember am = mock(AnnotatedMember.class); [EOL] boolean defaultUseStaticTyping = false; [EOL] JavaType contentType = mock(JavaType.class); [EOL] when(declaredType.getContentType()).thenReturn(contentType); [EOL] when(declaredType.withContentTypeHandler(any())).thenReturn(declaredType); [EOL] BeanPropertyWriter writer = buildWriter(propDef, declaredType, ser, typeSer, contentTypeSer, am, defaultUseStaticTyping); [EOL] assertNotNull(writer); [EOL] }
public void testBuildWriterWithNullSerializationTypeAndNonNullContentTypeSerializer() { [EOL] BeanPropertyDefinition propDef = mock(BeanPropertyDefinition.class); [EOL] JavaType declaredType = mock(JavaType.class); [EOL] JsonSerializer<?> ser = mock(JsonSerializer.class); [EOL] TypeSerializer typeSer = mock(TypeSerializer.class); [EOL] TypeSerializer contentTypeSer = mock(TypeSerializer.class); [EOL] AnnotatedMember am = mock(AnnotatedMember.class); [EOL] boolean defaultUseStaticTyping = false; [EOL] when(declaredType.getContentType()).thenReturn(null); [EOL] assertThrows(IllegalStateException.class, () -> { [EOL] buildWriter(propDef, declaredType, ser, typeSer, contentTypeSer, am, defaultUseStaticTyping); [EOL] }); [EOL] }
public void testBuildWriterWithSerializationInclusionNonDefault() { [EOL] BeanPropertyDefinition propDef = mock(BeanPropertyDefinition.class); [EOL] JavaType declaredType = mock(JavaType.class); [EOL] JsonSerializer<?> ser = mock(JsonSerializer.class); [EOL] TypeSerializer typeSer = mock(TypeSerializer.class); [EOL] TypeSerializer contentTypeSer = null; [EOL] AnnotatedMember am = mock(AnnotatedMember.class); [EOL] boolean defaultUseStaticTyping = false; [EOL] when(_annotationIntrospector.findSerializationInclusion(am, _outputProps)).thenReturn(JsonInclude.Include.NON_DEFAULT); [EOL] BeanPropertyWriter writer = buildWriter(propDef, declaredType, ser, typeSer, contentTypeSer, am, defaultUseStaticTyping); [EOL] assertNotNull(writer); [EOL] }
public void testBuildWriterWithSerializationInclusionNonEmpty() { [EOL] BeanPropertyDefinition propDef = mock(BeanPropertyDefinition.class); [EOL] JavaType declaredType = mock(JavaType.class); [EOL] JsonSerializer<?> ser = mock(JsonSerializer.class); [EOL] TypeSerializer typeSer = mock(TypeSerializer.class); [EOL] TypeSerializer contentTypeSer = null; [EOL] AnnotatedMember am = mock(AnnotatedMember.class); [EOL] boolean defaultUseStaticTyping = false; [EOL] when(_annotationIntrospector.findSerializationInclusion(am, _outputProps)).thenReturn(JsonInclude.Include.NON_EMPTY); [EOL] BeanPropertyWriter writer = buildWriter(propDef, declaredType, ser, typeSer, contentTypeSer, am, defaultUseStaticTyping); [EOL] assertNotNull(writer); [EOL] }
public void testBuildWriterWithSerializationInclusionAlwaysAndContainerType() { [EOL] BeanPropertyDefinition propDef = mock(BeanPropertyDefinition.class); [EOL] JavaType declaredType = mock(JavaType.class); [EOL] JsonSerializer<?> ser = mock(JsonSerializer.class); [EOL] TypeSerializer typeSer = mock(TypeSerializer.class); [EOL] TypeSerializer contentTypeSer = null; [EOL] AnnotatedMember am = mock(AnnotatedMember.class); [EOL] boolean defaultUseStaticTyping = false; [EOL] when(_annotationIntrospector.findSerializationInclusion(am, _outputProps)).thenReturn(JsonInclude.Include.ALWAYS); [EOL] when(declaredType.isContainerType()).thenReturn(true); [EOL] when(_config.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS)).thenReturn(false); [EOL] BeanPropertyWriter writer = buildWriter(propDef, declaredType, ser, typeSer, contentTypeSer, am, defaultUseStaticTyping); [EOL] assertNotNull(writer); [EOL] }
public void testBuildWriterWithUnwrappingNameTransformer() { [EOL] BeanPropertyDefinition propDef = mock(BeanPropertyDefinition.class); [EOL] JavaType declaredType = mock(JavaType.class); [EOL] JsonSerializer<?> ser = mock(JsonSerializer.class); [EOL] TypeSerializer typeSer = mock(TypeSerializer.class); [EOL] TypeSerializer contentTypeSer = null; [EOL] AnnotatedMember am = mock(AnnotatedMember.class); [EOL] boolean defaultUseStaticTyping = false; [EOL] NameTransformer unwrapper = mock(NameTransformer.class); [EOL] when(_annotationIntrospector.findUnwrappingNameTransformer(am)).thenReturn(unwrapper); [EOL] BeanPropertyWriter writer = buildWriter(propDef, declaredType, ser, typeSer, contentTypeSer, am, defaultUseStaticTyping); [EOL] assertNotNull(writer); [EOL] }
public void testFindSerializationTypeWithNonNullSerClassAndAssignableRawDeclared() { [EOL] Annotated a = mock(Annotated.class); [EOL] JavaType declaredType = mock(JavaType.class); [EOL] Class<?> rawDeclared = Object.class; [EOL] Class<?> serClass = Object.class; [EOL] when(_annotationIntrospector.findSerializationType(a)).thenReturn(serClass); [EOL] when(declaredType.getRawClass()).thenReturn(rawDeclared); [EOL] when(declaredType.widenBy(serClass)).thenReturn(declaredType); [EOL] JavaType result = findSerializationType(a, false, declaredType); [EOL] verify(declaredType).widenBy(serClass); [EOL] assertNotNull(result); [EOL] }
public void testFindSerializationTypeWithNonNullSerClassAndNonAssignableRawDeclared() { [EOL] Annotated a = mock(Annotated.class); [EOL] JavaType declaredType = mock(JavaType.class); [EOL] Class<?> rawDeclared = String.class; [EOL] Class<?> serClass = Integer.class; [EOL] when(_annotationIntrospector.findSerializationType(a)).thenReturn(serClass); [EOL] when(declaredType.getRawClass()).thenReturn(rawDeclared); [EOL] Exception exception = assertThrows(IllegalArgumentException.class, () -> { [EOL] findSerializationType(a, false, declaredType); [EOL] }); [EOL] String expectedMessage = "Illegal concrete-type annotation for method"; [EOL] String actualMessage = exception.getMessage(); [EOL] assertTrue(actualMessage.contains(expectedMessage)); [EOL] }
public void testFindSerializationTypeWithSecondaryType() { [EOL] Annotated a = mock(Annotated.class); [EOL] JavaType declaredType = mock(JavaType.class); [EOL] JavaType secondaryType = mock(JavaType.class); [EOL] when(_annotationIntrospector.findSerializationType(a)).thenReturn(null); [EOL] when(BeanSerializerFactory.modifySecondaryTypesByAnnotation(_config, a, declaredType)).thenReturn(secondaryType); [EOL] JavaType result = findSerializationType(a, false, declaredType); [EOL] assertSame(secondaryType, result); [EOL] }
public void testFindSerializationTypeWithUseStaticTyping() { [EOL] Annotated a = mock(Annotated.class); [EOL] JavaType declaredType = mock(JavaType.class); [EOL] when(_annotationIntrospector.findSerializationType(a)).thenReturn(null); [EOL] when(BeanSerializerFactory.modifySecondaryTypesByAnnotation(_config, a, declaredType)).thenReturn(declaredType); [EOL] when(_annotationIntrospector.findSerializationTyping(a)).thenReturn(JsonSerialize.Typing.STATIC); [EOL] JavaType result = findSerializationType(a, false, declaredType); [EOL] assertSame(declaredType, result); [EOL] }
public void testFindSerializationTypeWithoutUseStaticTyping() { [EOL] Annotated a = mock(Annotated.class); [EOL] JavaType declaredType = mock(JavaType.class); [EOL] when(_annotationIntrospector.findSerializationType(a)).thenReturn(null); [EOL] when(BeanSerializerFactory.modifySecondaryTypesByAnnotation(_config, a, declaredType)).thenReturn(declaredType); [EOL] when(_annotationIntrospector.findSerializationTyping(a)).thenReturn(null); [EOL] JavaType result = findSerializationType(a, false, declaredType); [EOL] assertNull(result); [EOL] }
public void testGetDefaultBeanWithNullDefaultBeanAndCanOverrideAccessModifiers() { [EOL] _defaultBean = null; [EOL] when(_config.canOverrideAccessModifiers()).thenReturn(true); [EOL] when(_beanDesc.instantiateBean(true)).thenReturn(new Object()); [EOL] Object result = getDefaultBean(); [EOL] assertNotNull(result); [EOL] assertSame(result, getDefaultBean()); [EOL] }
public void testGetDefaultBeanWithNullDefaultBeanAndCannotOverrideAccessModifiers() { [EOL] _defaultBean = null; [EOL] when(_config.canOverrideAccessModifiers()).thenReturn(false); [EOL] when(_beanDesc.instantiateBean(false)).thenReturn(new Object()); [EOL] Object result = getDefaultBean(); [EOL] assertNotNull(result); [EOL] assertSame(result, getDefaultBean()); [EOL] }
public void testGetDefaultBeanWithNullDefaultBeanAndInstantiationFails() { [EOL] _defaultBean = null; [EOL] when(_config.canOverrideAccessModifiers()).thenReturn(true); [EOL] when(_beanDesc.instantiateBean(true)).thenReturn(null); [EOL] Class<?> cls = Object.class; // Assuming Object.class is the class returned by _beanDesc.getClassInfo().getAnnotated() [EOL] when(_beanDesc.getClassInfo().getAnnotated()).thenReturn(cls); [EOL] try { [EOL] getDefaultBean(); [EOL] fail("Expected an IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Class " + cls.getName() + " has no default constructor; can not instantiate default bean value to support 'properties=JsonSerialize.Inclusion.NON_DEFAULT' annotation", e.getMessage()); [EOL] } [EOL] }
public void testGetDefaultBeanWithNonNullDefaultBean() { [EOL] Object existingDefaultBean = new Object(); [EOL] _defaultBean = existingDefaultBean; [EOL] Object result = getDefaultBean(); [EOL] assertSame(existingDefaultBean, result); [EOL] }
public void testGetDefaultValueWithValidMember() throws Exception { [EOL] String name = "validName"; [EOL] AnnotatedMember member = mock(AnnotatedMember.class); [EOL] Object expectedValue = new Object(); [EOL] when(member.getValue(any())).thenReturn(expectedValue); [EOL] Object actualValue = getDefaultValue(name, member); [EOL] assertEquals(expectedValue, actualValue); [EOL] }
public void testGetDefaultValueWithException() throws Exception { [EOL] String name = "invalidName"; [EOL] AnnotatedMember member = mock(AnnotatedMember.class); [EOL] Object defaultBean = getDefaultBean(); [EOL] when(member.getValue(any())).thenThrow(new Exception("Test Exception")); [EOL] try { [EOL] getDefaultValue(name, member); [EOL] fail("Expected an exception to be thrown"); [EOL] } catch (Exception e) { [EOL] assertEquals("Test Exception", e.getCause().getMessage()); [EOL] } [EOL] }
public void testBaseSettingsWithAllParameters() { [EOL] ClassIntrospector ci = mock(ClassIntrospector.class); [EOL] AnnotationIntrospector ai = mock(AnnotationIntrospector.class); [EOL] VisibilityChecker<?> vc = mock(VisibilityChecker.class); [EOL] PropertyNamingStrategy pns = mock(PropertyNamingStrategy.class); [EOL] TypeFactory tf = TypeFactory.defaultInstance(); [EOL] TypeResolverBuilder<?> typer = mock(TypeResolverBuilder.class); [EOL] DateFormat dateFormat = new SimpleDateFormat(); [EOL] HandlerInstantiator hi = mock(HandlerInstantiator.class); [EOL] Locale locale = Locale.getDefault(); [EOL] TimeZone tz = TimeZone.getDefault(); [EOL] Base64Variant defaultBase64 = Base64Variants.getDefaultVariant(); [EOL] BaseSettings settings = new BaseSettings(ci, ai, vc, pns, tf, typer, dateFormat, hi, locale, tz, defaultBase64); [EOL] assertNotNull(settings); [EOL] assertSame(ci, settings.getClassIntrospector()); [EOL] assertSame(ai, settings.getAnnotationIntrospector()); [EOL] assertSame(vc, settings.getVisibilityChecker()); [EOL] assertSame(pns, settings.getPropertyNamingStrategy()); [EOL] assertSame(tf, settings.getTypeFactory()); [EOL] assertSame(typer, settings.getTypeResolverBuilder()); [EOL] assertSame(dateFormat, settings.getDateFormat()); [EOL] assertSame(hi, settings.getHandlerInstantiator()); [EOL] assertEquals(locale, settings.getLocale()); [EOL] assertEquals(tz, settings.getTimeZone()); [EOL] assertSame(defaultBase64, settings.getDefaultBase64Variant()); [EOL] }
public void testWithAnnotationIntrospector_SameInstance() { [EOL] AnnotationIntrospector ai = _baseSettings.getAnnotationIntrospector(); [EOL] BaseSettings result = _baseSettings.withAnnotationIntrospector(ai); [EOL] assertSame(_baseSettings, result); [EOL] }
public void testWithAnnotationIntrospector_NewInstance() { [EOL] AnnotationIntrospector newAi = new SomeAnnotationIntrospectorImplementation(); [EOL] BaseSettings result = _baseSettings.withAnnotationIntrospector(newAi); [EOL] assertNotNull(result); [EOL] assertNotSame(_baseSettings, result); [EOL] assertSame(newAi, result.getAnnotationIntrospector()); [EOL] }
public void testWithPropertyNamingStrategySameInstance() { [EOL] PropertyNamingStrategy pns = new PropertyNamingStrategy.LowerCaseStrategy(); [EOL] BaseSettings baseSettings = new BaseSettings(null, null, null, pns, null, null, null, null, null, null, null); [EOL] BaseSettings newBaseSettings = baseSettings.withPropertyNamingStrategy(pns); [EOL] assertSame(baseSettings, newBaseSettings); [EOL] }
public void testWithPropertyNamingStrategyDifferentInstance() { [EOL] PropertyNamingStrategy pns1 = new PropertyNamingStrategy.LowerCaseStrategy(); [EOL] PropertyNamingStrategy pns2 = new PropertyNamingStrategy.UpperCamelCaseStrategy(); [EOL] BaseSettings baseSettings = new BaseSettings(null, null, null, pns1, null, null, null, null, null, null, null); [EOL] BaseSettings newBaseSettings = baseSettings.withPropertyNamingStrategy(pns2); [EOL] assertNotSame(baseSettings, newBaseSettings); [EOL] assertSame(pns2, newBaseSettings.getPropertyNamingStrategy()); [EOL] }
public void testWithTypeResolverBuilderSameInstance() { [EOL] TypeResolverBuilder<?> originalTyper = new MyTypeResolverBuilder(); [EOL] BaseSettings originalSettings = new BaseSettings(null, null, null, null, null, originalTyper, null, null, null, null, null); [EOL] BaseSettings resultSettings = originalSettings.withTypeResolverBuilder(originalTyper); [EOL] assertSame("Should return the same BaseSettings instance if the typer is the same", originalSettings, resultSettings); [EOL] }
public void testWithTypeResolverBuilderDifferentInstance() { [EOL] TypeResolverBuilder<?> originalTyper = new MyTypeResolverBuilder(); [EOL] TypeResolverBuilder<?> newTyper = new MyTypeResolverBuilder(); [EOL] BaseSettings originalSettings = new BaseSettings(null, null, null, null, null, originalTyper, null, null, null, null, null); [EOL] BaseSettings resultSettings = originalSettings.withTypeResolverBuilder(newTyper); [EOL] assertNotSame("Should return a new BaseSettings instance if the typer is different", originalSettings, resultSettings); [EOL] assertNotNull("The result should not be null", resultSettings); [EOL] assertSame("The type resolver builder should be the new instance", newTyper, resultSettings.getTypeResolverBuilder()); [EOL] }
public void testWithHandlerInstantiator_SameInstance() { [EOL] HandlerInstantiator hi = new HandlerInstantiator() {}; [EOL] BaseSettings baseSettings = new BaseSettings(null, null, null, null, null, null, null, hi, null, null, null); [EOL] BaseSettings result = baseSettings.withHandlerInstantiator(hi); [EOL] assertSame(baseSettings, result); [EOL] }
public void testWithHandlerInstantiator_NewInstance() { [EOL] HandlerInstantiator originalHi = new HandlerInstantiator() {}; [EOL] HandlerInstantiator newHi = new HandlerInstantiator() {}; [EOL] BaseSettings baseSettings = new BaseSettings(null, null, null, null, null, null, null, originalHi, null, null, null); [EOL] BaseSettings result = baseSettings.withHandlerInstantiator(newHi); [EOL] assertNotSame(baseSettings, result); [EOL] assertNotNull(result); [EOL] assertSame(newHi, result.getHandlerInstantiator()); [EOL] }
public void testGetClassIntrospector() { [EOL] ObjectMapper objectMapper = new ObjectMapper(); [EOL] ClassIntrospector introspector = objectMapper.getClassIntrospector(); [EOL] assertNotNull(introspector); [EOL] }
public void testGetAnnotationIntrospector() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] AnnotationIntrospector introspector = mapper.getSerializationConfig().getAnnotationIntrospector(); [EOL] assertNotNull(introspector); [EOL] }
public void testGetVisibilityChecker() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] VisibilityChecker<?> visibilityChecker = mapper.getSerializationConfig().getVisibilityChecker(); [EOL] assertNotNull(visibilityChecker); [EOL] }
public void testGetPropertyNamingStrategy() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] assertNull(mapper.getPropertyNamingStrategy()); [EOL] PropertyNamingStrategy strategy = new PropertyNamingStrategy.SnakeCaseStrategy(); [EOL] mapper.setPropertyNamingStrategy(strategy); [EOL] assertSame(strategy, mapper.getPropertyNamingStrategy()); [EOL] }
public void testGetTypeFactory() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] TypeFactory typeFactory = mapper.getTypeFactory(); [EOL] assertNotNull(typeFactory); [EOL] }
public void testGetTypeResolverBuilder() { [EOL] MyClass instance = new MyClass(); [EOL] TypeResolverBuilder<?> result = instance.getTypeResolverBuilder(); [EOL] assertNull(result); [EOL] }
public void testGetHandlerInstantiatorWhenNull() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] assertNull(mapper.getHandlerInstantiator()); [EOL] }
public void testGetHandlerInstantiatorWhenNotNull() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] HandlerInstantiator instantiator = new HandlerInstantiator() { [EOL] }; [EOL] mapper.setHandlerInstantiator(instantiator); [EOL] assertSame(instantiator, mapper.getHandlerInstantiator()); [EOL] }
public void testGetBooleanBuilder_WhenBuilderIsNull() { [EOL] MyClass instance = new MyClass(); [EOL] BooleanBuilder result = instance.getBooleanBuilder(); [EOL] assertNotNull(result); [EOL] BooleanBuilder secondCallResult = instance.getBooleanBuilder(); [EOL] assertSame(result, secondCallResult); // should return the same instance as before [EOL] }
public void testGetBooleanBuilder_WhenBuilderIsNotNull() { [EOL] MyClass instance = new MyClass(); [EOL] BooleanBuilder preInitializedBuilder = new BooleanBuilder(); [EOL] instance.setBooleanBuilder(preInitializedBuilder); // Assuming there's a setter for _booleanBuilder [EOL] BooleanBuilder result = instance.getBooleanBuilder(); [EOL] assertSame(preInitializedBuilder, result); // should return the pre-initialized instance [EOL] }
public void testBooleanBuilderConstructor() { [EOL] BooleanBuilder booleanBuilder = new BooleanBuilder(); [EOL] }
public void shouldConstructEmptyBooleanArrayForZeroLength() { [EOL] final int len = 0; [EOL] boolean[] result = _constructArray(len); [EOL] assertNotNull(result); [EOL] assertEquals(0, result.length); [EOL] }
public void shouldConstructBooleanArrayWithGivenLength() { [EOL] final int len = 10; [EOL] boolean[] result = _constructArray(len); [EOL] assertNotNull(result); [EOL] assertEquals(len, result.length); [EOL] }
public void testArrayToSetWithNonNullElements() { [EOL] Integer[] elements = new Integer[]{1, 2, 3, 4}; [EOL] HashSet<Integer> resultSet = ClassName.arrayToSet(elements); [EOL] assertEquals(4, resultSet.size()); [EOL] assertTrue(resultSet.contains(1)); [EOL] assertTrue(resultSet.contains(2)); [EOL] assertTrue(resultSet.contains(3)); [EOL] assertTrue(resultSet.contains(4)); [EOL] }
public void testArrayToSetWithNull() { [EOL] Integer[] elements = null; [EOL] HashSet<Integer> resultSet = ClassName.arrayToSet(elements); [EOL] assertTrue(resultSet.isEmpty()); [EOL] }
public void testArrayToSetWithEmptyArray() { [EOL] Integer[] elements = new Integer[]{}; [EOL] HashSet<Integer> resultSet = ClassName.arrayToSet(elements); [EOL] assertTrue(resultSet.isEmpty()); [EOL] }
public void testArrayToSetWithDuplicateElements() { [EOL] Integer[] elements = new Integer[]{1, 2, 2, 3, 3, 3}; [EOL] HashSet<Integer> resultSet = ClassName.arrayToSet(elements); [EOL] assertEquals(3, resultSet.size()); [EOL] assertTrue(resultSet.contains(1)); [EOL] assertTrue(resultSet.contains(2)); [EOL] assertTrue(resultSet.contains(3)); [EOL] }
public static <T> Iterable<T> arrayAsIterable(T[] array) { [EOL] return new ArrayIterator<T>(array); [EOL] }
public void testArrayIteratorWithNonNullArray() { [EOL] Integer[] array = new Integer[]{1, 2, 3}; [EOL] ArrayIterator<Integer> iterator = new ArrayIterator<>(array); [EOL] assertNotNull(iterator._array); [EOL] assertEquals(0, iterator._index); [EOL] }
public void testArrayIteratorWithEmptyArray() { [EOL] Integer[] array = new Integer[]{}; [EOL] ArrayIterator<Integer> iterator = new ArrayIterator<>(array); [EOL] assertNotNull(iterator._array); [EOL] assertEquals(0, iterator._index); [EOL] }
public void testArrayIteratorWithNullArray() { [EOL] ArrayIterator<Integer> iterator = new ArrayIterator<>(null); [EOL] assertNull(iterator._array); [EOL] assertEquals(0, iterator._index); [EOL] }
public void testHasNext_WhenIndexIsLessThanArrayLength_ShouldReturnTrue() { [EOL] JsonNodeTraverser traverser = new JsonNodeTraverser(new ArrayNode()); // Assuming ArrayNode is a valid type for _array [EOL] traverser._index = 0; // Assuming _index is accessible or use a constructor/setter [EOL] traverser._array = new JsonNode[1]; // Assuming _array is accessible or use a constructor/setter [EOL] boolean result = traverser.hasNext(); [EOL] assert(result); // Assuming a simple assert, replace with appropriate assertion method [EOL] }
public void testHasNext_WhenIndexIsEqualToArrayLength_ShouldReturnFalse() { [EOL] JsonNodeTraverser traverser = new JsonNodeTraverser(new ArrayNode()); // Assuming ArrayNode is a valid type for _array [EOL] traverser._index = 1; // Assuming _index is accessible or use a constructor/setter [EOL] traverser._array = new JsonNode[1]; // Assuming _array is accessible or use a constructor/setter [EOL] boolean result = traverser.hasNext(); [EOL] assert(!result); // Assuming a simple assert, replace with appropriate assertion method [EOL] }
public void testNextWithEmptyArray() { [EOL] ArrayIterator<Object> iterator = new ArrayIterator<>(new Object[0]); [EOL] try { [EOL] iterator.next(); [EOL] fail("Expected an exception to be thrown"); [EOL] } catch (NoSuchElementException e) { [EOL] } [EOL] }
public void testNextWithNonEmptyArray() { [EOL] Object[] array = new Object[] { "element" }; [EOL] ArrayIterator<Object> iterator = new ArrayIterator<>(array); [EOL] Object element = iterator.next(); [EOL] assertEquals("element", element); [EOL] }
public void testIteratorMethod() { [EOL] YourIterableClass<String> instance = new YourIterableClass<>(); [EOL] Iterator<String> iterator = instance.iterator(); [EOL] assertTrue(iterator == instance); [EOL] }
public void testDeserializerFactoryConfigDefaultConstructor() { [EOL] DeserializerFactoryConfig config = new DeserializerFactoryConfig(); [EOL] assertFalse(config.hasDeserializers()); [EOL] assertFalse(config.hasKeyDeserializers()); [EOL] assertFalse(config.hasDeserializerModifiers()); [EOL] assertFalse(config.hasAbstractTypeResolvers()); [EOL] assertFalse(config.hasValueInstantiators()); [EOL] }
public void testDeserializerFactoryConfigWithAdditionalDeserializers() { [EOL] DeserializerFactoryConfig config = new DeserializerFactoryConfig(); [EOL] Deserializers additional = mock(Deserializers.class); [EOL] DeserializerFactoryConfig newConfig = config.withAdditionalDeserializers(additional); [EOL] assertTrue(newConfig.hasDeserializers()); [EOL] }
public void testDeserializerFactoryConfigWithAdditionalKeyDeserializers() { [EOL] DeserializerFactoryConfig config = new DeserializerFactoryConfig(); [EOL] KeyDeserializers additional = mock(KeyDeserializers.class); [EOL] DeserializerFactoryConfig newConfig = config.withAdditionalKeyDeserializers(additional); [EOL] assertTrue(newConfig.hasKeyDeserializers()); [EOL] }
public void testDeserializerFactoryConfigWithDeserializerModifier() { [EOL] DeserializerFactoryConfig config = new DeserializerFactoryConfig(); [EOL] BeanDeserializerModifier modifier = mock(BeanDeserializerModifier.class); [EOL] DeserializerFactoryConfig newConfig = config.withDeserializerModifier(modifier); [EOL] assertTrue(newConfig.hasDeserializerModifiers()); [EOL] }
public void testDeserializerFactoryConfigWithAbstractTypeResolver() { [EOL] DeserializerFactoryConfig config = new DeserializerFactoryConfig(); [EOL] AbstractTypeResolver resolver = mock(AbstractTypeResolver.class); [EOL] DeserializerFactoryConfig newConfig = config.withAbstractTypeResolver(resolver); [EOL] assertTrue(newConfig.hasAbstractTypeResolvers()); [EOL] }
public void testDeserializerFactoryConfigWithValueInstantiators() { [EOL] DeserializerFactoryConfig config = new DeserializerFactoryConfig(); [EOL] ValueInstantiators instantiators = mock(ValueInstantiators.class); [EOL] DeserializerFactoryConfig newConfig = config.withValueInstantiators(instantiators); [EOL] assertTrue(newConfig.hasValueInstantiators()); [EOL] }
public void testDeserializerFactoryConfigWithNullArguments() { [EOL] DeserializerFactoryConfig config = new DeserializerFactoryConfig(null, null, null, null, null); [EOL] assertFalse(config.hasDeserializers()); [EOL] assertFalse(config.hasKeyDeserializers()); [EOL] assertFalse(config.hasDeserializerModifiers()); [EOL] assertFalse(config.hasAbstractTypeResolvers()); [EOL] assertFalse(config.hasValueInstantiators()); [EOL] } [EOL] public void testDeserializerFactoryConfigWithNonNullArguments() { [EOL] Deserializers[] deserializers = new Deserializers[] { mock(Deserializers.class) }; [EOL] KeyDeserializers[] keyDeserializers = new KeyDeserializers[] { mock(KeyDeserializers.class) }; [EOL] BeanDeserializerModifier[] modifiers = new BeanDeserializerModifier[] { mock(BeanDeserializerModifier.class) }; [EOL] AbstractTypeResolver[] abstractTypeResolvers = new AbstractTypeResolver[] { mock(AbstractTypeResolver.class) }; [EOL] ValueInstantiators[] valueInstantiators = new ValueInstantiators[] { mock(ValueInstantiators.class) }; [EOL] DeserializerFactoryConfig config = new DeserializerFactoryConfig(deserializers, keyDeserializers, modifiers, abstractTypeResolvers, valueInstantiators); [EOL] assertTrue(config.hasDeserializers()); [EOL] assertTrue(config.hasKeyDeserializers()); [EOL] assertTrue(config.hasDeserializerModifiers()); [EOL] assertTrue(config.hasAbstractTypeResolvers()); [EOL] assertTrue(config.hasValueInstantiators()); [EOL] }
public void testDeserializerFactoryConfigWithAdditionalDeserializers() { [EOL] DeserializerFactoryConfig config = new DeserializerFactoryConfig(null, null, null, null, null); [EOL] Deserializers additional = mock(Deserializers.class); [EOL] DeserializerFactoryConfig updatedConfig = config.withAdditionalDeserializers(additional); [EOL] assertTrue(updatedConfig.hasDeserializers()); [EOL] } [EOL] public void testDeserializerFactoryConfigWithAdditionalKeyDeserializers() { [EOL] DeserializerFactoryConfig config = new DeserializerFactoryConfig(null, null, null, null, null); [EOL] KeyDeserializers additional = mock(KeyDeserializers.class); [EOL] DeserializerFactoryConfig updatedConfig = config.withAdditionalKeyDeserializers(additional); [EOL] assertTrue(updatedConfig.hasKeyDeserializers()); [EOL] } [EOL] public void testDeserializerFactoryConfigWithDeserializerModifier() { [EOL] DeserializerFactoryConfig config = new DeserializerFactoryConfig(null, null, null, null, null); [EOL] BeanDeserializerModifier modifier = mock(BeanDeserializerModifier.class); [EOL] DeserializerFactoryConfig updatedConfig = config.withDeserializerModifier(modifier); [EOL] assertTrue(updatedConfig.hasDeserializerModifiers()); [EOL] } [EOL] public void testDeserializerFactoryConfigWithAbstractTypeResolver() { [EOL] DeserializerFactoryConfig config = new DeserializerFactoryConfig(null, null, null, null, null); [EOL] AbstractTypeResolver resolver = mock(AbstractTypeResolver.class); [EOL] DeserializerFactoryConfig updatedConfig = config.withAbstractTypeResolver(resolver); [EOL] assertTrue(updatedConfig.hasAbstractTypeResolvers()); [EOL] } [EOL] public void testDeserializerFactoryConfigWithValueInstantiators() { [EOL] DeserializerFactoryConfig config = new DeserializerFactoryConfig(null, null, null, null, null); [EOL] ValueInstantiators instantiators = mock(ValueInstantiators.class); [EOL] DeserializerFactoryConfig updatedConfig = config.withValueInstantiators(instantiators); [EOL] assertTrue(updatedConfig.hasValueInstantiators()); [EOL] }
public void testWithAdditionalKeyDeserializers_NullInput() { [EOL] DeserializerFactoryConfig config = new DeserializerFactoryConfig(); [EOL] try { [EOL] config.withAdditionalKeyDeserializers(null); [EOL] fail("Expected IllegalArgumentException for null input"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Can not pass null KeyDeserializers", e.getMessage()); [EOL] } [EOL] }
public void testWithAdditionalKeyDeserializers_ValidInput() { [EOL] DeserializerFactoryConfig config = new DeserializerFactoryConfig(); [EOL] KeyDeserializers additional = new KeyDeserializers() { [EOL] }; [EOL] DeserializerFactoryConfig newConfig = config.withAdditionalKeyDeserializers(additional); [EOL] assertNotNull(newConfig); [EOL] assertNotSame(config, newConfig); [EOL] assertTrue(newConfig.hasKeyDeserializers()); [EOL] }
public void testWithValueInstantiators_NullValue() { [EOL] DeserializerFactoryConfig config = new DeserializerFactoryConfig(); [EOL] try { [EOL] config.withValueInstantiators(null); [EOL] fail("IllegalArgumentException expected"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Can not pass null resolver", e.getMessage()); [EOL] } [EOL] }
public void testWithValueInstantiators_ValidValue() { [EOL] DeserializerFactoryConfig config = new DeserializerFactoryConfig(); [EOL] ValueInstantiators instantiators = new ValueInstantiators() { [EOL] }; [EOL] DeserializerFactoryConfig newConfig = config.withValueInstantiators(instantiators); [EOL] assertNotNull(newConfig); [EOL] assertTrue(newConfig.hasValueInstantiators()); [EOL] }
public void testHasKeyDeserializers_WithEmptyKeyDeserializers_ShouldReturnFalse() { [EOL] DeserializerFactoryConfig config = new DeserializerFactoryConfig(); [EOL] assertFalse(config.hasKeyDeserializers()); [EOL] }
public void testHasKeyDeserializers_WithNonEmptyKeyDeserializers_ShouldReturnTrue() { [EOL] KeyDeserializers[] keyDeserializers = new KeyDeserializers[] { mock(KeyDeserializers.class) }; [EOL] DeserializerFactoryConfig config = new DeserializerFactoryConfig( [EOL] new Deserializers[0], keyDeserializers, new BeanDeserializerModifier[0], [EOL] new AbstractTypeResolver[0], new ValueInstantiators[0] [EOL] ); [EOL] assertTrue(config.hasKeyDeserializers()); [EOL] }
public void testKeyDeserializersWithDefault() { [EOL] DeserializerFactoryConfig config = new DeserializerFactoryConfig(); [EOL] Iterable<KeyDeserializers> keyDeserializers = config.keyDeserializers(); [EOL] assertNotNull(keyDeserializers); [EOL] assertTrue(keyDeserializers.iterator().hasNext()); [EOL] assertEquals(StdKeyDeserializers.class, keyDeserializers.iterator().next().getClass()); [EOL] } [EOL] public void testKeyDeserializersWithAdditional() { [EOL] DeserializerFactoryConfig config = new DeserializerFactoryConfig(); [EOL] KeyDeserializers additional = mock(KeyDeserializers.class); [EOL] config = config.withAdditionalKeyDeserializers(additional); [EOL] Iterable<KeyDeserializers> keyDeserializers = config.keyDeserializers(); [EOL] assertNotNull(keyDeserializers); [EOL] assertTrue(keyDeserializers.iterator().hasNext()); [EOL] assertSame(additional, keyDeserializers.iterator().next()); [EOL] }
public void testKeyDeserializersEmpty() { [EOL] DeserializerFactoryConfig config = new DeserializerFactoryConfig(new Deserializers[0], new KeyDeserializers[0], new BeanDeserializerModifier[0], new AbstractTypeResolver[0], new ValueInstantiators[0]); [EOL] Iterable<KeyDeserializers> keyDeserializers = config.keyDeserializers(); [EOL] assertNotNull(keyDeserializers); [EOL] assertFalse(keyDeserializers.iterator().hasNext()); [EOL] }
public void testValueInstantiatorsWithNonNull() { [EOL] DeserializerFactoryConfig config = new DeserializerFactoryConfig(); [EOL] ValueInstantiators instantiators = new ValueInstantiators() { [EOL] }; [EOL] DeserializerFactoryConfig newConfig = config.withValueInstantiators(instantiators); [EOL] Iterable<ValueInstantiators> iterable = newConfig.valueInstantiators(); [EOL] assertNotNull(iterable); [EOL] assertTrue(iterable.iterator().hasNext()); [EOL] assertEquals(instantiators, iterable.iterator().next()); [EOL] } [EOL] public void testValueInstantiatorsWithNull() { [EOL] DeserializerFactoryConfig config = new DeserializerFactoryConfig(); [EOL] DeserializerFactoryConfig newConfig = config.withValueInstantiators(null); [EOL] Iterable<ValueInstantiators> iterable = newConfig.valueInstantiators(); [EOL] assertNotNull(iterable); [EOL] assertFalse(iterable.iterator().hasNext()); [EOL] } [EOL] public void testHasValueInstantiators() { [EOL] DeserializerFactoryConfig config = new DeserializerFactoryConfig(); [EOL] assertFalse(config.hasValueInstantiators()); [EOL] ValueInstantiators instantiators = new ValueInstantiators() { [EOL] }; [EOL] DeserializerFactoryConfig newConfig = config.withValueInstantiators(instantiators); [EOL] assertTrue(newConfig.hasValueInstantiators()); [EOL] }
public void testDeserializersWithNonNull() { [EOL] DeserializerFactoryConfig config = new DeserializerFactoryConfig(); [EOL] Deserializers deserializers = new Deserializers() { [EOL] }; [EOL] DeserializerFactoryConfig newConfig = config.withAdditionalDeserializers(deserializers); [EOL] Iterable<Deserializers> iterable = newConfig.deserializers(); [EOL] assertNotNull(iterable); [EOL] assertTrue(iterable.iterator().hasNext()); [EOL] assertEquals(deserializers, iterable.iterator().next()); [EOL] } [EOL] public void testDeserializersWithNull() { [EOL] DeserializerFactoryConfig config = new DeserializerFactoryConfig(); [EOL] DeserializerFactoryConfig newConfig = config.withAdditionalDeserializers(null); [EOL] Iterable<Deserializers> iterable = newConfig.deserializers(); [EOL] assertNotNull(iterable); [EOL] assertFalse(iterable.iterator().hasNext()); [EOL] } [EOL] public void testHasKeyDeserializers() { [EOL] DeserializerFactoryConfig config = new DeserializerFactoryConfig(); [EOL] assertFalse(config.hasKeyDeserializers()); [EOL] KeyDeserializers keyDeserializers = new KeyDeserializers() { [EOL] }; [EOL] DeserializerFactoryConfig newConfig = config.withAdditionalKeyDeserializers(keyDeserializers); [EOL] assertTrue(newConfig.hasKeyDeserializers()); [EOL] }
public void testKeyDeserializersWithNonNull() { [EOL] DeserializerFactoryConfig config = new DeserializerFactoryConfig(); [EOL] KeyDeserializers keyDeserializers = new KeyDeserializers() { [EOL] }; [EOL] DeserializerFactoryConfig newConfig = config.withAdditionalKeyDeserializers(keyDeserializers); [EOL] Iterable<KeyDeserializers> iterable = newConfig.keyDeserializers(); [EOL] assertNotNull(iterable); [EOL] assertTrue(iterable.iterator().hasNext()); [EOL] assertEquals(keyDeserializers, iterable.iterator().next()); [EOL] } [EOL] public void testKeyDeserializersWithNull() { [EOL] DeserializerFactoryConfig config = new DeserializerFactoryConfig(); [EOL] DeserializerFactoryConfig newConfig = config.withAdditionalKeyDeserializers(null); [EOL] Iterable<KeyDeserializers> iterable = newConfig.keyDeserializers(); [EOL] assertNotNull(iterable); [EOL] assertFalse(iterable.iterator().hasNext()); [EOL] }
public void testDeserializerModifiersWithNonNull() { [EOL] DeserializerFactoryConfig config = new DeserializerFactoryConfig(); [EOL] BeanDeserializerModifier modifier = new BeanDeserializerModifier() { [EOL] }; [EOL] DeserializerFactoryConfig newConfig = config.withDeserializerModifier(modifier); [EOL] Iterable<BeanDeserializerModifier> iterable = newConfig.deserializerModifiers(); [EOL] assertNotNull(iterable); [EOL] assertTrue(iterable.iterator().hasNext()); [EOL] assertEquals(modifier, iterable.iterator().next()); [EOL] } [EOL] public void testDeserializerModifiersWithNull() { [EOL] DeserializerFactoryConfig config = new DeserializerFactoryConfig(); [EOL] DeserializerFactoryConfig newConfig = config.withDeserializerModifier(null); [EOL] Iterable<BeanDeserializerModifier> iterable = newConfig.deserializerModifiers(); [EOL] assertNotNull(iterable); [EOL] assertFalse(iterable.iterator().hasNext()); [EOL] } [EOL] public void testHasDeserializerModifiers() { [EOL] DeserializerFactoryConfig config = new DeserializerFactoryConfig(); [EOL] assertFalse(config.hasDeserializerModifiers()); [EOL] BeanDeserializerModifier modifier = new BeanDeserializerModifier() { [EOL] }; [EOL] DeserializerFactoryConfig newConfig = config.withDeserializerModifier(modifier); [EOL] assertTrue(newConfig.hasDeserializerModifiers()); [EOL] }
public void testAbstractTypeResolversWithNonNull() { [EOL] DeserializerFactoryConfig config = new DeserializerFactoryConfig(); [EOL] AbstractTypeResolver resolver = new AbstractTypeResolver() { [EOL] }; [EOL] DeserializerFactoryConfig newConfig = config.withAbstractTypeResolver(resolver); [EOL] Iterable<AbstractTypeResolver> iterable = newConfig.abstractTypeResolvers(); [EOL] assertNotNull(iterable); [EOL] assertTrue(iterable.iterator().hasNext()); [EOL] assertEquals(resolver, iterable.iterator().next()); [EOL] } [EOL] public void testAbstractTypeResolversWithNull() { [EOL] DeserializerFactoryConfig config = new DeserializerFactoryConfig(); [EOL] DeserializerFactoryConfig newConfig = config.withAbstractTypeResolver(null); [EOL] Iterable<AbstractTypeResolver> iterable = newConfig.abstractTypeResolvers(); [EOL] assertNotNull(iterable); [EOL] assertFalse(iterable.iterator().hasNext()); [EOL] } [EOL] public void testHasAbstractTypeResolvers() { [EOL] DeserializerFactoryConfig config = new DeserializerFactoryConfig(); [EOL] assertFalse(config.hasAbstractTypeResolvers()); [EOL] AbstractTypeResolver resolver = new AbstractTypeResolver() { [EOL] }; [EOL] DeserializerFactoryConfig newConfig = config.withAbstractTypeResolver(resolver); [EOL] assertTrue(newConfig.hasAbstractTypeResolvers()); [EOL] }
public void testTypeIdResolverBaseWithNonNullValues() { [EOL] JavaType baseType = new SimpleType(Object.class); [EOL] TypeFactory typeFactory = TypeFactory.defaultInstance(); [EOL] TypeIdResolverBase resolver = new TypeIdResolverBase(baseType, typeFactory); [EOL] assertNotNull(resolver); [EOL] }
public void testTypeIdResolverBaseWithNullValues() { [EOL] TypeIdResolverBase resolver = new TypeIdResolverBase(null, null); [EOL] assertNotNull(resolver); [EOL] }
public void testBeanSerializerBaseWithNullBuilder() { [EOL] JavaType type = mock(JavaType.class); [EOL] BeanPropertyWriter[] properties = new BeanPropertyWriter[0]; [EOL] BeanPropertyWriter[] filteredProperties = new BeanPropertyWriter[0]; [EOL] BeanSerializerBase serializer = new BeanSerializerBase(type, null, properties, filteredProperties); [EOL] assertNull(serializer._typeId); [EOL] assertNull(serializer._anyGetterWriter); [EOL] assertNull(serializer._propertyFilterId); [EOL] assertNull(serializer._objectIdWriter); [EOL] assertNull(serializer._serializationShape); [EOL] }
public void testBeanSerializerBaseWithNonNullBuilder() { [EOL] JavaType type = mock(JavaType.class); [EOL] BeanSerializerBuilder builder = mock(BeanSerializerBuilder.class); [EOL] BeanPropertyWriter[] properties = new BeanPropertyWriter[0]; [EOL] BeanPropertyWriter[] filteredProperties = new BeanPropertyWriter[0]; [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] JsonFormat.Value format = mock(JsonFormat.Value.class); [EOL] when(builder.getTypeId()).thenReturn("typeId"); [EOL] when(builder.getAnyGetter()).thenReturn(mock(AnyGetterWriter.class)); [EOL] when(builder.getFilterId()).thenReturn("filterId"); [EOL] when(builder.getObjectIdWriter()).thenReturn(mock(ObjectIdWriter.class)); [EOL] when(builder.getBeanDescription()).thenReturn(beanDesc); [EOL] when(beanDesc.findExpectedFormat(null)).thenReturn(format); [EOL] when(format.getShape()).thenReturn(JsonFormat.Shape.STRING); [EOL] BeanSerializerBase serializer = new BeanSerializerBase(type, builder, properties, filteredProperties); [EOL] assertEquals("typeId", serializer._typeId); [EOL] assertNotNull(serializer._anyGetterWriter); [EOL] assertEquals("filterId", serializer._propertyFilterId); [EOL] assertNotNull(serializer._objectIdWriter); [EOL] assertEquals(JsonFormat.Shape.STRING, serializer._serializationShape); [EOL] }
public void testBeanSerializerBaseWithNonNullObjectIdWriter() { [EOL] BeanSerializerBase original = createBeanSerializerBase(); [EOL] ObjectIdWriter objectIdWriter = createObjectIdWriter(); [EOL] BeanSerializerBase cloned = new BeanSerializerBase(original, objectIdWriter); [EOL] assertNotNull(cloned); [EOL] assertEquals(original._handledType, cloned._handledType); [EOL] assertArrayEquals(original._props, cloned._props); [EOL] assertArrayEquals(original._filteredProps, cloned._filteredProps); [EOL] assertEquals(original._typeId, cloned._typeId); [EOL] assertEquals(original._anyGetterWriter, cloned._anyGetterWriter); [EOL] assertEquals(objectIdWriter, cloned._objectIdWriter); [EOL] assertEquals(original._propertyFilterId, cloned._propertyFilterId); [EOL] assertEquals(original._serializationShape, cloned._serializationShape); [EOL] }
public void testBeanSerializerBaseWithNullObjectIdWriter() { [EOL] BeanSerializerBase original = createBeanSerializerBase(); [EOL] ObjectIdWriter objectIdWriter = null; [EOL] BeanSerializerBase cloned = new BeanSerializerBase(original, objectIdWriter); [EOL] assertNotNull(cloned); [EOL] assertEquals(original._handledType, cloned._handledType); [EOL] assertArrayEquals(original._props, cloned._props); [EOL] assertArrayEquals(original._filteredProps, cloned._filteredProps); [EOL] assertEquals(original._typeId, cloned._typeId); [EOL] assertEquals(original._anyGetterWriter, cloned._anyGetterWriter); [EOL] assertNull(cloned._objectIdWriter); [EOL] assertEquals(original._propertyFilterId, cloned._propertyFilterId); [EOL] assertEquals(original._serializationShape, cloned._serializationShape); [EOL] }
public void testResolveWithNullFilteredPropsAndNoNullSerializer() throws JsonMappingException { [EOL] SerializerProvider provider = createMockSerializerProvider(); [EOL] BeanPropertyWriter[] props = createBeanPropertyWriters(2, false, false); [EOL] BeanPropertyWriter[] filteredProps = null; [EOL] TestBeanSerializerModifier modifier = new TestBeanSerializerModifier(props, filteredProps); [EOL] modifier.resolve(provider); [EOL] } [EOL] public void testResolveWithNonNullFilteredPropsAndNullSerializer() throws JsonMappingException { [EOL] SerializerProvider provider = createMockSerializerProvider(); [EOL] BeanPropertyWriter[] props = createBeanPropertyWriters(2, true, false); [EOL] BeanPropertyWriter[] filteredProps = createBeanPropertyWriters(2, true, true); [EOL] TestBeanSerializerModifier modifier = new TestBeanSerializerModifier(props, filteredProps); [EOL] modifier.resolve(provider); [EOL] } [EOL] public void testResolveWithNonNullFilteredPropsAndNonNullSerializer() throws JsonMappingException { [EOL] SerializerProvider provider = createMockSerializerProvider(); [EOL] BeanPropertyWriter[] props = createBeanPropertyWriters(2, true, true); [EOL] BeanPropertyWriter[] filteredProps = createBeanPropertyWriters(2, true, true); [EOL] TestBeanSerializerModifier modifier = new TestBeanSerializerModifier(props, filteredProps); [EOL] modifier.resolve(provider); [EOL] } [EOL] public void testResolveWithContainerTypeAndNonNullTypeSerializer() throws JsonMappingException { [EOL] SerializerProvider provider = createMockSerializerProvider(); [EOL] BeanPropertyWriter[] props = createBeanPropertyWritersWithContainerType(1, true); [EOL] BeanPropertyWriter[] filteredProps = createBeanPropertyWritersWithContainerType(1, true); [EOL] TestBeanSerializerModifier modifier = new TestBeanSerializerModifier(props, filteredProps); [EOL] modifier.resolve(provider); [EOL] } [EOL] public void testResolveWithAnyGetterWriter() throws JsonMappingException { [EOL] SerializerProvider provider = createMockSerializerProvider(); [EOL] BeanPropertyWriter[] props = createBeanPropertyWriters(1, false, false); [EOL] BeanPropertyWriter[] filteredProps = null; [EOL] AnyGetterWriter anyGetterWriter = createMockAnyGetterWriter(); [EOL] TestBeanSerializerModifier modifier = new TestBeanSerializerModifier(props, filteredProps, anyGetterWriter); [EOL] modifier.resolve(provider); [EOL] }

public void testFindConvertingSerializerWithNonNullIntrospectorAndConverter() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanPropertyWriter prop = mock(BeanPropertyWriter.class); [EOL] AnnotationIntrospector intr = mock(AnnotationIntrospector.class); [EOL] Converter<Object, Object> conv = mock(Converter.class); [EOL] JavaType delegateType = mock(JavaType.class); [EOL] JsonSerializer<Object> ser = mock(JsonSerializer.class); [EOL] Object convDef = new Object(); [EOL] AnnotatedMember member = mock(AnnotatedMember.class); [EOL] when(provider.getAnnotationIntrospector()).thenReturn(intr); [EOL] when(prop.getMember()).thenReturn(member); [EOL] when(intr.findSerializationConverter(member)).thenReturn(convDef); [EOL] when(provider.converterInstance(member, convDef)).thenReturn(conv); [EOL] when(conv.getOutputType(provider.getTypeFactory())).thenReturn(delegateType); [EOL] when(provider.findValueSerializer(delegateType, prop)).thenReturn(ser); [EOL] JsonSerializer<Object> result = findConvertingSerializer(provider, prop); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof StdDelegatingSerializer); [EOL] }
public void testFindConvertingSerializerWithNullIntrospector() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanPropertyWriter prop = mock(BeanPropertyWriter.class); [EOL] when(provider.getAnnotationIntrospector()).thenReturn(null); [EOL] JsonSerializer<Object> result = findConvertingSerializer(provider, prop); [EOL] assertNull(result); [EOL] }
public void testFindConvertingSerializerWithNonNullIntrospectorAndNullConverter() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanPropertyWriter prop = mock(BeanPropertyWriter.class); [EOL] AnnotationIntrospector intr = mock(AnnotationIntrospector.class); [EOL] AnnotatedMember member = mock(AnnotatedMember.class); [EOL] when(provider.getAnnotationIntrospector()).thenReturn(intr); [EOL] when(prop.getMember()).thenReturn(member); [EOL] when(intr.findSerializationConverter(member)).thenReturn(null); [EOL] JsonSerializer<Object> result = findConvertingSerializer(provider, prop); [EOL] assertNull(result); [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL] ObjectIdWriter oiw = _objectIdWriter; [EOL] String[] ignorals = null; [EOL] final AnnotationIntrospector intr = provider.getAnnotationIntrospector(); [EOL] final AnnotatedMember accessor = (property == null || intr == null) ? null : property.getMember(); [EOL] if (accessor != null) { [EOL] ignorals = intr.findPropertiesToIgnore(accessor); [EOL] ObjectIdInfo objectIdInfo = intr.findObjectIdInfo(accessor); [EOL] if (objectIdInfo == null) { [EOL] if (oiw != null) { [EOL] objectIdInfo = intr.findObjectReferenceInfo(accessor, new ObjectIdInfo("", null, null)); [EOL] oiw = _objectIdWriter.withAlwaysAsId(objectIdInfo.getAlwaysAsId()); [EOL] } [EOL] } else { [EOL] objectIdInfo = intr.findObjectReferenceInfo(accessor, objectIdInfo); [EOL] ObjectIdGenerator<?> gen; [EOL] Class<?> implClass = objectIdInfo.getGeneratorType(); [EOL] JavaType type = provider.constructType(implClass); [EOL] JavaType idType = provider.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0]; [EOL] if (implClass == ObjectIdGenerators.PropertyGenerator.class) { [EOL] String propName = objectIdInfo.getPropertyName(); [EOL] BeanPropertyWriter idProp = null; [EOL] for (int i = 0, len = _props.length; ; ++i) { [EOL] if (i == len) { [EOL] throw new IllegalArgumentException("Invalid Object Id definition for " + _handledType.getName() + ": can not find property with name '" + propName + "'"); [EOL] } [EOL] BeanPropertyWriter prop = _props[i]; [EOL] if (propName.equals(prop.getName())) { [EOL] idProp = prop; [EOL] if (i > 0) { [EOL] System.arraycopy(_props, 0, _props, 1, i); [EOL] _props[0] = idProp; [EOL] if (_filteredProps != null) { [EOL] BeanPropertyWriter fp = _filteredProps[i]; [EOL] System.arraycopy(_filteredProps, 0, _filteredProps, 1, i); [EOL] _filteredProps[0] = fp; [EOL] } [EOL] } [EOL] break; [EOL] } [EOL] } [EOL] idType = idProp.getType(); [EOL] gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp); [EOL] oiw = ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId()); [EOL] } else { [EOL] gen = provider.objectIdGeneratorInstance(accessor, objectIdInfo); [EOL] oiw = ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen, objectIdInfo.getAlwaysAsId()); [EOL] } [EOL] } [EOL] } [EOL] BeanSerializerBase contextual = this; [EOL] if (oiw != null) { [EOL] JsonSerializer<?> ser = provider.findValueSerializer(oiw.idType, property); [EOL] oiw = oiw.withSerializer(ser); [EOL] if (oiw != _objectIdWriter) { [EOL] contextual = contextual.withObjectIdWriter(oiw); [EOL] } [EOL] } [EOL] if (ignorals != null && ignorals.length != 0) { [EOL] contextual = contextual.withIgnorals(ignorals); [EOL] } [EOL] JsonFormat.Shape shape = null; [EOL] if (accessor != null) { [EOL] JsonFormat.Value format = intr.findFormat((Annotated) accessor); [EOL] if (format != null) { [EOL] shape = format.getShape(); [EOL] } [EOL] } [EOL] if (shape == null) { [EOL] shape = _serializationShape; [EOL] } [EOL] if (shape == JsonFormat.Shape.ARRAY) { [EOL] contextual = contextual.asArraySerializer(); [EOL] } [EOL] return contextual; [EOL] }
public void testUsesObjectIdWhenObjectIdWriterIsNull() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] SerializationConfig config = mapper.getSerializationConfig(); [EOL] JsonSerializer<Object> serializer = config.findValueSerializer(Object.class, null); [EOL] BeanPropertyWriter writer = new BeanPropertyWriter(); [EOL] writer.assignSerializer(serializer); [EOL] assertFalse(writer.usesObjectId()); [EOL] }
public void testUsesObjectIdWhenObjectIdWriterIsNotNull() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] SerializationConfig config = mapper.getSerializationConfig(); [EOL] JsonSerializer<Object> serializer = config.findValueSerializer(Object.class, null); [EOL] BeanPropertyWriter writer = new BeanPropertyWriter(); [EOL] writer.assignSerializer(serializer); [EOL] ObjectIdWriter objectIdWriter = ObjectIdWriter.construct(new SimpleType(Object.class), null, null, false, null); [EOL] writer.assignObjectIdWriter(objectIdWriter); [EOL] assertTrue(writer.usesObjectId()); [EOL] }
public void testSerializeFieldsWithActiveView() throws IOException { [EOL] Object bean = new Object(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] when(provider.getActiveView()).thenReturn(Object.class); [EOL] BeanPropertyWriter[] filteredProps = new BeanPropertyWriter[1]; [EOL] filteredProps[0] = mock(BeanPropertyWriter.class); [EOL] setFilteredProps(filteredProps); [EOL] serializeFields(bean, jgen, provider); [EOL] verify(filteredProps[0]).serializeAsField(bean, jgen, provider); [EOL] }
public void testSerializeFieldsWithoutActiveView() throws IOException { [EOL] Object bean = new Object(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] when(provider.getActiveView()).thenReturn(null); [EOL] BeanPropertyWriter[] props = new BeanPropertyWriter[1]; [EOL] props[0] = mock(BeanPropertyWriter.class); [EOL] setProps(props); [EOL] serializeFields(bean, jgen, provider); [EOL] verify(props[0]).serializeAsField(bean, jgen, provider); [EOL] }
public void testSerializeFieldsWithAnyGetterWriter() throws IOException { [EOL] Object bean = new Object(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] setProps(new BeanPropertyWriter[0]); // No properties to serialize [EOL] AnyGetterWriter anyGetterWriter = mock(AnyGetterWriter.class); [EOL] setAnyGetterWriter(anyGetterWriter); [EOL] serializeFields(bean, jgen, provider); [EOL] verify(anyGetterWriter).getAndSerialize(bean, jgen, provider); [EOL] }
public void testSerializeFieldsExceptionHandling() throws IOException { [EOL] Object bean = new Object(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanPropertyWriter[] props = new BeanPropertyWriter[1]; [EOL] BeanPropertyWriter prop = mock(BeanPropertyWriter.class); [EOL] props[0] = prop; [EOL] setProps(props); [EOL] doThrow(new IOException()).when(prop).serializeAsField(bean, jgen, provider); [EOL] try { [EOL] serializeFields(bean, jgen, provider); [EOL] fail("IOException expected"); [EOL] } catch (IOException e) { [EOL] } [EOL] }
public void testSerializeFieldsStackOverflowError() { [EOL] Object bean = new Object(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanPropertyWriter[] props = new BeanPropertyWriter[1]; [EOL] BeanPropertyWriter prop = mock(BeanPropertyWriter.class); [EOL] props[0] = prop; [EOL] setProps(props); [EOL] doThrow(new StackOverflowError()).when(prop).serializeAsField(bean, jgen, provider); [EOL] try { [EOL] serializeFields(bean, jgen, provider); [EOL] fail("JsonMappingException expected"); [EOL] } catch (JsonMappingException e) { [EOL] } [EOL] }
public void testSerializeFieldsFilteredWithActiveViewAndFilter() throws IOException { [EOL] Object bean = new Object(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] when(provider.getActiveView()).thenReturn(Object.class); [EOL] BeanPropertyWriter[] filteredProps = new BeanPropertyWriter[1]; [EOL] BeanPropertyWriter prop = mock(BeanPropertyWriter.class); [EOL] filteredProps[0] = prop; [EOL] BeanPropertyFilter filter = mock(BeanPropertyFilter.class); [EOL] MyBeanSerializerBase serializer = new MyBeanSerializerBase(filteredProps, null); [EOL] serializer.serializeFieldsFiltered(bean, jgen, provider); [EOL] verify(filter).serializeAsField(eq(bean), eq(jgen), eq(provider), any(BeanPropertyWriter.class)); [EOL] }
public void testSerializeFieldsFilteredWithNoActiveView() throws IOException { [EOL] Object bean = new Object(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] when(provider.getActiveView()).thenReturn(null); [EOL] BeanPropertyWriter[] props = new BeanPropertyWriter[1]; [EOL] BeanPropertyWriter prop = mock(BeanPropertyWriter.class); [EOL] props[0] = prop; [EOL] MyBeanSerializerBase serializer = new MyBeanSerializerBase(props, null); [EOL] serializer.serializeFieldsFiltered(bean, jgen, provider); [EOL] verify(prop).serializeAsField(eq(bean), eq(jgen), eq(provider)); [EOL] }
public void testSerializeFieldsFilteredWithNullFilter() throws IOException { [EOL] Object bean = new Object(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] MyBeanSerializerBase serializer = new MyBeanSerializerBase(null, null); [EOL] serializer.serializeFieldsFiltered(bean, jgen, provider); [EOL] verify(serializer).serializeFields(eq(bean), eq(jgen), eq(provider)); [EOL] }
public void testSerializeFieldsFilteredWithException() throws IOException { [EOL] Object bean = new Object(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanPropertyWriter[] props = new BeanPropertyWriter[1]; [EOL] BeanPropertyWriter prop = mock(BeanPropertyWriter.class); [EOL] props[0] = prop; [EOL] BeanPropertyFilter filter = mock(BeanPropertyFilter.class); [EOL] doThrow(new IOException()).when(filter).serializeAsField(eq(bean), eq(jgen), eq(provider), any(BeanPropertyWriter.class)); [EOL] MyBeanSerializerBase serializer = new MyBeanSerializerBase(props, null); [EOL] try { [EOL] serializer.serializeFieldsFiltered(bean, jgen, provider); [EOL] fail("IOException expected"); [EOL] } catch (IOException e) { [EOL] } [EOL] }
public void testSerializeFieldsFilteredWithStackOverflowError() { [EOL] Object bean = new Object(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanPropertyWriter[] props = new BeanPropertyWriter[1]; [EOL] BeanPropertyWriter prop = mock(BeanPropertyWriter.class); [EOL] props[0] = prop; [EOL] BeanPropertyFilter filter = mock(BeanPropertyFilter.class); [EOL] doThrow(new StackOverflowError()).when(filter).serializeAsField(eq(bean), eq(jgen), eq(provider), any(BeanPropertyWriter.class)); [EOL] MyBeanSerializerBase serializer = new MyBeanSerializerBase(props, null); [EOL] try { [EOL] serializer.serializeFieldsFiltered(bean, jgen, provider); [EOL] fail("JsonMappingException expected"); [EOL] } catch (JsonMappingException e) { [EOL] } [EOL] }
public void testFindFilterWithNullFilterProvider() { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] when(provider.getFilterProvider()).thenReturn(null); [EOL] try { [EOL] findFilter(provider); [EOL] fail("Should have thrown JsonMappingException"); [EOL] } catch (JsonMappingException e) { [EOL] assertEquals("Can not resolve BeanPropertyFilter with id 'null'; no FilterProvider configured", e.getMessage()); [EOL] } [EOL] }
public void testFindFilterWithNonNullFilterProvider() { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] FilterProvider filterProvider = mock(FilterProvider.class); [EOL] BeanPropertyFilter expectedFilter = mock(BeanPropertyFilter.class); [EOL] Object filterId = "filterId"; [EOL] when(provider.getFilterProvider()).thenReturn(filterProvider); [EOL] when(filterProvider.findFilter(filterId)).thenReturn(expectedFilter); [EOL] setPropertyFilterId(filterId); // Assuming there is a method to set _propertyFilterId [EOL] BeanPropertyFilter actualFilter = findFilter(provider); [EOL] assertSame(expectedFilter, actualFilter); [EOL] }
public void testConstructViewBasedWithSingleView() { [EOL] BeanPropertyWriter base = createMockBeanPropertyWriter(); [EOL] Class<?>[] viewsToIncludeIn = new Class<?>[] { View.class }; [EOL] BeanPropertyWriter result = BeanPropertyWriter.constructViewBased(base, viewsToIncludeIn); [EOL] assertTrue(result instanceof SingleView); [EOL] }
public void testConstructViewBasedWithMultipleViews() { [EOL] BeanPropertyWriter base = createMockBeanPropertyWriter(); [EOL] Class<?>[] viewsToIncludeIn = new Class<?>[] { View.class, AnotherView.class }; [EOL] BeanPropertyWriter result = BeanPropertyWriter.constructViewBased(base, viewsToIncludeIn); [EOL] assertTrue(result instanceof MultiView); [EOL] }
public void testMultiViewConstructorWithNullDelegate() { [EOL] Class<?>[] views = new Class<?>[] {Object.class, String.class}; [EOL] try { [EOL] new MultiView(null, views); [EOL] fail("Expected IllegalArgumentException for null delegate"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testMultiViewConstructorWithNullViews() { [EOL] BeanPropertyWriter delegate = new BeanPropertyWriter(); [EOL] try { [EOL] new MultiView(delegate, null); [EOL] fail("Expected NullPointerException for null views array"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testMultiViewConstructorWithValidArguments() { [EOL] BeanPropertyWriter delegate = new BeanPropertyWriter(); [EOL] Class<?>[] views = new Class<?>[] {Object.class, String.class}; [EOL] MultiView multiView = new MultiView(delegate, views); [EOL] assertNotNull(multiView); [EOL] assertSame(delegate, multiView._delegate); [EOL] assertArrayEquals(views, multiView._views); [EOL] }
public void testAssignSerializerWithNonNullSerializer() { [EOL] MyDelegateClass _delegate = Mockito.mock(MyDelegateClass.class); [EOL] MyClass myClass = new MyClass(_delegate); [EOL] JsonSerializer<Object> serializer = Mockito.mock(JsonSerializer.class); [EOL] myClass.assignSerializer(serializer); [EOL] Mockito.verify(_delegate).assignSerializer(serializer); [EOL] }
public void testAssignSerializerWithNullSerializer() { [EOL] MyDelegateClass _delegate = Mockito.mock(MyDelegateClass.class); [EOL] MyClass myClass = new MyClass(_delegate); [EOL] JsonSerializer<Object> serializer = null; [EOL] myClass.assignSerializer(serializer); [EOL] Mockito.verify(_delegate).assignSerializer(serializer); [EOL] }
public void testAssignNullSerializerWithNonNullSerializer() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] JsonSerializer<Object> nullSerializer = new JsonSerializer<Object>() { [EOL] @Override [EOL] public void serialize(Object value, JsonGenerator gen, SerializerProvider serializers) throws IOException { [EOL] } [EOL] }; [EOL] SimpleModule module = new SimpleModule(); [EOL] module.addSerializer(Object.class, nullSerializer); [EOL] mapper.registerModule(module); [EOL] JsonSerializer<Object> actualNullSerializer = mapper.getSerializerProviderInstance().findNullValueSerializer(null); [EOL] assertSame("Expected custom null serializer to be assigned", nullSerializer, actualNullSerializer); [EOL] }
public void testAssignNullSerializerWithNull() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] JsonSerializer<Object> nullSerializer = null; [EOL] SimpleModule module = new SimpleModule(); [EOL] module.addSerializer(Object.class, nullSerializer); [EOL] mapper.registerModule(module); [EOL] JsonSerializer<Object> actualNullSerializer = mapper.getSerializerProviderInstance().findNullValueSerializer(null); [EOL] assertNull("Expected null serializer to be null", actualNullSerializer); [EOL] }
public void testSerializeAsFieldWithActiveView() throws Exception { [EOL] Object bean = new Object(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] Class<?> activeView = SomeViewClass.class; [EOL] when(prov.getActiveView()).thenReturn(activeView); [EOL] BeanPropertyWriter writer = new BeanPropertyWriter() { [EOL] @Override [EOL] public void serializeAsField(Object bean, JsonGenerator jgen, SerializerProvider prov) throws Exception { [EOL] final Class<?> activeView = prov.getActiveView(); [EOL] if (activeView != null) { [EOL] int i = 0, len = _views.length; [EOL] for (; i < len; ++i) { [EOL] if (_views[i].isAssignableFrom(activeView)) [EOL] break; [EOL] } [EOL] if (i == len) { [EOL] return; [EOL] } [EOL] } [EOL] _delegate.serializeAsField(bean, jgen, prov); [EOL] } [EOL] }; [EOL] writer.serializeAsField(bean, jgen, prov); [EOL] verify(prov).getActiveView(); [EOL] verify(_delegate).serializeAsField(bean, jgen, prov); [EOL] }
public void testSerializeAsFieldWithoutActiveView() throws Exception { [EOL] Object bean = new Object(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] when(prov.getActiveView()).thenReturn(null); [EOL] BeanPropertyWriter writer = new BeanPropertyWriter() { [EOL] @Override [EOL] public void serializeAsField(Object bean, JsonGenerator jgen, SerializerProvider prov) throws Exception { [EOL] final Class<?> activeView = prov.getActiveView(); [EOL] if (activeView != null) { [EOL] int i = 0, len = _views.length; [EOL] for (; i < len; ++i) { [EOL] if (_views[i].isAssignableFrom(activeView)) [EOL] break; [EOL] } [EOL] if (i == len) { [EOL] return; [EOL] } [EOL] } [EOL] _delegate.serializeAsField(bean, jgen, prov); [EOL] } [EOL] }; [EOL] writer.serializeAsField(bean, jgen, prov); [EOL] verify(prov).getActiveView(); [EOL] verify(_delegate).serializeAsField(bean, jgen, prov); [EOL] }
public void testGetAnyGetterWithNullAnyGetters() { [EOL] AnnotatedMember result = instance.getAnyGetter(); [EOL] assertNull(result); [EOL] }
public void testGetAnyGetterWithEmptyAnyGetters() { [EOL] instance.setAnyGetters(new LinkedList<>()); [EOL] AnnotatedMember result = instance.getAnyGetter(); [EOL] assertNull(result); [EOL] }
public void testGetAnyGetterWithOneAnyGetter() { [EOL] LinkedList<AnnotatedMember> anyGetters = new LinkedList<>(); [EOL] AnnotatedMember mockMember = mock(AnnotatedMember.class); [EOL] anyGetters.add(mockMember); [EOL] instance.setAnyGetters(anyGetters); [EOL] AnnotatedMember result = instance.getAnyGetter(); [EOL] assertSame(mockMember, result); [EOL] }
public void testGetAnyGetterWithMultipleAnyGetters() { [EOL] LinkedList<AnnotatedMember> anyGetters = new LinkedList<>(); [EOL] AnnotatedMember mockMember1 = mock(AnnotatedMember.class); [EOL] AnnotatedMember mockMember2 = mock(AnnotatedMember.class); [EOL] anyGetters.add(mockMember1); [EOL] anyGetters.add(mockMember2); [EOL] instance.setAnyGetters(anyGetters); [EOL] Exception exception = assertThrows(IllegalStateException.class, () -> { [EOL] instance.getAnyGetter(); [EOL] }); [EOL] String expectedMessage = "Multiple 'any-getters' defined (" + mockMember1 + " vs " + mockMember2 + ")"; [EOL] String actualMessage = exception.getMessage(); [EOL] assertTrue(actualMessage.contains(expectedMessage)); [EOL] }
public void testGetAnySetterMethodWithNoAnySetters() { [EOL] assertNull(objectUnderTest.getAnySetterMethod()); [EOL] }
public void testGetAnySetterMethodWithOneAnySetter() { [EOL] objectUnderTest.addAnySetter(mock(AnnotatedMethod.class)); [EOL] assertNotNull(objectUnderTest.getAnySetterMethod()); [EOL] }
public void testGetAnySetterMethodWithMultipleAnySetters() { [EOL] objectUnderTest.addAnySetter(mock(AnnotatedMethod.class)); [EOL] objectUnderTest.addAnySetter(mock(AnnotatedMethod.class)); [EOL] try { [EOL] objectUnderTest.getAnySetterMethod(); [EOL] fail("Expected an exception due to multiple any-setters"); [EOL] } catch (Exception e) { [EOL] assertTrue(e.getMessage().contains("Multiple 'any-setters' defined")); [EOL] } [EOL] }
public void testCollectWithNonNullNamingStrategy() { [EOL] POJOPropertiesCollector collector = createCollectorWithMockedMethods(); [EOL] PropertyNamingStrategy namingStrategy = Mockito.mock(PropertyNamingStrategy.class); [EOL] Mockito.when(collector._findNamingStrategy()).thenReturn(namingStrategy); [EOL] POJOPropertiesCollector result = collector.collect(); [EOL] Mockito.verify(collector)._renameUsing(namingStrategy); [EOL] assertNotNull(result); [EOL] } [EOL] public void testCollectWithNullNamingStrategy() { [EOL] POJOPropertiesCollector collector = createCollectorWithMockedMethods(); [EOL] Mockito.when(collector._findNamingStrategy()).thenReturn(null); [EOL] POJOPropertiesCollector result = collector.collect(); [EOL] Mockito.verify(collector, Mockito.never())._renameUsing(Mockito.any(PropertyNamingStrategy.class)); [EOL] assertNotNull(result); [EOL] } [EOL] public void testCollectWithWrapperNameAsPropertyNameEnabled() { [EOL] POJOPropertiesCollector collector = createCollectorWithMockedMethods(); [EOL] Mockito.when(collector._config.isEnabled(MapperFeature.USE_WRAPPER_NAME_AS_PROPERTY_NAME)).thenReturn(true); [EOL] POJOPropertiesCollector result = collector.collect(); [EOL] Mockito.verify(collector)._renameWithWrappers(); [EOL] assertNotNull(result); [EOL] } [EOL] public void testCollectWithWrapperNameAsPropertyNameDisabled() { [EOL] POJOPropertiesCollector collector = createCollectorWithMockedMethods(); [EOL] Mockito.when(collector._config.isEnabled(MapperFeature.USE_WRAPPER_NAME_AS_PROPERTY_NAME)).thenReturn(false); [EOL] POJOPropertiesCollector result = collector.collect(); [EOL] Mockito.verify(collector, Mockito.never())._renameWithWrappers(); [EOL] assertNotNull(result); [EOL] }
private POJOPropertiesCollector createCollectorWithMockedMethods() { [EOL] POJOPropertiesCollector collector = Mockito.mock(POJOPropertiesCollector.class); [EOL] Mockito.doCallRealMethod().when(collector).collect(); [EOL] Mockito.doNothing().when(collector)._addFields(); [EOL] Mockito.doNothing().when(collector)._addMethods(); [EOL] Mockito.doNothing().when(collector)._addCreators(); [EOL] Mockito.doNothing().when(collector)._addInjectables(); [EOL] Mockito.doNothing().when(collector)._removeUnwantedProperties(); [EOL] Mockito.doNothing().when(collector)._renameProperties(); [EOL] Mockito.doNothing().when(collector)._sortProperties(); [EOL] return collector; [EOL] }
public void testSortPropertiesWithNullIntrAndAlpha() { [EOL] _annotationIntrospector = null; [EOL] _classDef = null; // Assuming _classDef is a field that can be set to null [EOL] _config = mock(SerializationConfig.class); [EOL] when(_config.shouldSortPropertiesAlphabetically()).thenReturn(false); [EOL] _properties = new LinkedHashMap<>(); [EOL] _creatorProperties = null; [EOL] _sortProperties(); [EOL] assertTrue("Properties should not be sorted", _properties instanceof LinkedHashMap); [EOL] }
public void testSortPropertiesWithNonNullIntrAndAlphaTrue() { [EOL] _annotationIntrospector = mock(AnnotationIntrospector.class); [EOL] _classDef = mock(AnnotatedClass.class); [EOL] when(_annotationIntrospector.findSerializationSortAlphabetically(_classDef)).thenReturn(Boolean.TRUE); [EOL] _properties = new LinkedHashMap<>(); [EOL] _creatorProperties = null; [EOL] _sortProperties(); [EOL] assertTrue("Properties should be sorted", _properties instanceof TreeMap); [EOL] }
public void testSortPropertiesWithNonNullIntrAndAlphaFalse() { [EOL] _annotationIntrospector = mock(AnnotationIntrospector.class); [EOL] _classDef = mock(AnnotatedClass.class); [EOL] when(_annotationIntrospector.findSerializationSortAlphabetically(_classDef)).thenReturn(Boolean.FALSE); [EOL] _properties = new LinkedHashMap<>(); [EOL] _creatorProperties = null; [EOL] _sortProperties(); [EOL] assertTrue("Properties should not be sorted", _properties instanceof LinkedHashMap); [EOL] }
public void testSortPropertiesWithNonNullIntrAndPropertyOrder() { [EOL] _annotationIntrospector = mock(AnnotationIntrospector.class); [EOL] _classDef = mock(AnnotatedClass.class); [EOL] when(_annotationIntrospector.findSerializationSortAlphabetically(_classDef)).thenReturn(null); [EOL] when(_annotationIntrospector.findSerializationPropertyOrder(_classDef)).thenReturn(new String[]{"prop1", "prop2"}); [EOL] _properties = new LinkedHashMap<>(); [EOL] _creatorProperties = null; [EOL] _sortProperties(); [EOL] assertNotNull("Properties should be ordered", _properties.get("prop1")); [EOL] assertNotNull("Properties should be ordered", _properties.get("prop2")); [EOL] }
public void testSortPropertiesWithNonNullIntrPropertyOrderAndCreatorProperties() { [EOL] _annotationIntrospector = mock(AnnotationIntrospector.class); [EOL] _classDef = mock(AnnotatedClass.class); [EOL] when(_annotationIntrospector.findSerializationSortAlphabetically(_classDef)).thenReturn(null); [EOL] when(_annotationIntrospector.findSerializationPropertyOrder(_classDef)).thenReturn(new String[]{"prop1", "prop2"}); [EOL] _properties = new LinkedHashMap<>(); [EOL] _creatorProperties = new ArrayList<>(); [EOL] POJOPropertyBuilder propBuilder = mock(POJOPropertyBuilder.class); [EOL] when(propBuilder.getName()).thenReturn("creatorProp"); [EOL] _creatorProperties.add(propBuilder); [EOL] _sortProperties(); [EOL] assertNotNull("Properties should include creator properties", _properties.get("creatorProp")); [EOL] }
public void testAddFieldsWithNullAnnotationIntrospectorAndSerialization() { [EOL] _forSerialization = true; [EOL] _annotationIntrospector = null; [EOL] _addFields(); [EOL] }
public void testAddFieldsWithNonNullAnnotationIntrospectorAndSerialization() { [EOL] _forSerialization = true; [EOL] _annotationIntrospector = createMockAnnotationIntrospectorWithSerialization(); [EOL] _addFields(); [EOL] }
public void testAddFieldsWithNonNullAnnotationIntrospectorAndDeserialization() { [EOL] _forSerialization = false; [EOL] _annotationIntrospector = createMockAnnotationIntrospectorWithDeserialization(); [EOL] _addFields(); [EOL] }
public void testAddFieldsWithPruneFinalFields() { [EOL] _forSerialization = false; [EOL] _config = createConfigWithFinalFieldsAsMutatorsDisabled(); [EOL] _annotationIntrospector = createMockAnnotationIntrospectorWithIgnoreMarker(); [EOL] _addFields(); [EOL] }
public void testAddFieldsWithVisibleFields() { [EOL] _visibilityChecker = createVisibilityCheckerWithVisibleFields(); [EOL] _addFields(); [EOL] }
public void testAddFieldsWithIgnoredFields() { [EOL] _annotationIntrospector = createMockAnnotationIntrospectorWithIgnoreMarker(); [EOL] _addFields(); [EOL] }
public void testAddCreatorsWithNullAnnotationIntrospector() { [EOL] setupWithNullAnnotationIntrospector(); // Mock _annotationIntrospector to return null [EOL] _addCreators(); [EOL] assertNull(_creatorProperties); // Assert that _creatorProperties remains null [EOL] }
public void testAddCreatorsWithEmptyConstructorsAndFactoryMethods() { [EOL] setupWithMockAnnotationIntrospector(); // Mock _annotationIntrospector and other necessary objects [EOL] mockEmptyConstructorsAndFactoryMethods(); // Mock _classDef to return empty constructors and factory methods [EOL] _addCreators(); [EOL] assertNull(_creatorProperties); // Assert that _creatorProperties remains null [EOL] }
public void testAddCreatorsWithNonEmptyConstructors() { [EOL] setupWithMockAnnotationIntrospector(); // Mock _annotationIntrospector and other necessary objects [EOL] mockNonEmptyConstructors(); // Mock _classDef to return non-empty constructors [EOL] _addCreators(); [EOL] assertNotNull(_creatorProperties); // Assert that _creatorProperties is not null [EOL] assertFalse(_creatorProperties.isEmpty()); // Assert that _creatorProperties is populated [EOL] }
public void testAddCreatorsWithNonEmptyFactoryMethods() { [EOL] setupWithMockAnnotationIntrospector(); // Mock _annotationIntrospector and other necessary objects [EOL] mockNonEmptyFactoryMethods(); // Mock _classDef to return non-empty factory methods [EOL] _addCreators(); [EOL] assertNotNull(_creatorProperties); // Assert that _creatorProperties is not null [EOL] assertFalse(_creatorProperties.isEmpty()); // Assert that _creatorProperties is populated [EOL] }
public void testAddCreatorsWithNamedParametersInConstructors() { [EOL] setupWithMockAnnotationIntrospector(); // Mock _annotationIntrospector and other necessary objects [EOL] mockConstructorsWithNamedParameters(); // Mock _classDef and _annotationIntrospector to simulate named parameters in constructors [EOL] _addCreators(); [EOL] assertNotNull(_creatorProperties); // Assert that _creatorProperties is not null [EOL] for (POJOPropertyBuilder prop : _creatorProperties) { [EOL] assertNotNull(prop.getName()); [EOL] } [EOL] }
public void testAddCreatorsWithNamedParametersInFactoryMethods() { [EOL] setupWithMockAnnotationIntrospector(); // Mock _annotationIntrospector and other necessary objects [EOL] mockFactoryMethodsWithNamedParameters(); // Mock _classDef and _annotationIntrospector to simulate named parameters in factory methods [EOL] _addCreators(); [EOL] assertNotNull(_creatorProperties); // Assert that _creatorProperties is not null [EOL] for (POJOPropertyBuilder prop : _creatorProperties) { [EOL] assertNotNull(prop.getName()); [EOL] } [EOL] }
public void testAddMethodsWithZeroParameters() { [EOL] AnnotatedMethod mockMethod = Mockito.mock(AnnotatedMethod.class); [EOL] Mockito.when(mockMethod.getParameterCount()).thenReturn(0); [EOL] Mockito.when(_classDef.memberMethods()).thenReturn(Collections.singletonList(mockMethod)); [EOL] _addMethods(); [EOL] Mockito.verify(this)._addGetterMethod(mockMethod, _annotationIntrospector); [EOL] }
public void testAddMethodsWithOneParameter() { [EOL] AnnotatedMethod mockMethod = Mockito.mock(AnnotatedMethod.class); [EOL] Mockito.when(mockMethod.getParameterCount()).thenReturn(1); [EOL] Mockito.when(_classDef.memberMethods()).thenReturn(Collections.singletonList(mockMethod)); [EOL] _addMethods(); [EOL] Mockito.verify(this)._addSetterMethod(mockMethod, _annotationIntrospector); [EOL] }
public void testAddMethodsWithTwoParametersWithoutAnySetterAnnotation() { [EOL] AnnotatedMethod mockMethod = Mockito.mock(AnnotatedMethod.class); [EOL] Mockito.when(mockMethod.getParameterCount()).thenReturn(2); [EOL] Mockito.when(_classDef.memberMethods()).thenReturn(Collections.singletonList(mockMethod)); [EOL] Mockito.when(_annotationIntrospector.hasAnySetterAnnotation(mockMethod)).thenReturn(false); [EOL] _addMethods(); [EOL] Assert.assertTrue(_anySetters == null || _anySetters.isEmpty()); [EOL] }
public void testAddMethodsWithTwoParametersWithAnySetterAnnotation() { [EOL] AnnotatedMethod mockMethod = Mockito.mock(AnnotatedMethod.class); [EOL] Mockito.when(mockMethod.getParameterCount()).thenReturn(2); [EOL] Mockito.when(_classDef.memberMethods()).thenReturn(Collections.singletonList(mockMethod)); [EOL] Mockito.when(_annotationIntrospector.hasAnySetterAnnotation(mockMethod)).thenReturn(true); [EOL] _addMethods(); [EOL] Assert.assertNotNull(_anySetters); [EOL] Assert.assertTrue(_anySetters.contains(mockMethod)); [EOL] }
public void testAddGetterMethodWithNonNullAnnotationIntrospectorAndAnyGetterAnnotation() { [EOL] AnnotationIntrospector ai = Mockito.mock(AnnotationIntrospector.class); [EOL] AnnotatedMethod m = Mockito.mock(AnnotatedMethod.class); [EOL] Mockito.when(ai.hasAnyGetterAnnotation(m)).thenReturn(true); [EOL] _addGetterMethod(m, ai); [EOL] assertNotNull(_anyGetters); [EOL] assertTrue(_anyGetters.contains(m)); [EOL] }
public void testAddGetterMethodWithNonNullAnnotationIntrospectorAndJsonValueAnnotation() { [EOL] AnnotationIntrospector ai = Mockito.mock(AnnotationIntrospector.class); [EOL] AnnotatedMethod m = Mockito.mock(AnnotatedMethod.class); [EOL] Mockito.when(ai.hasAnyGetterAnnotation(m)).thenReturn(false); [EOL] Mockito.when(ai.hasAsValueAnnotation(m)).thenReturn(true); [EOL] _addGetterMethod(m, ai); [EOL] assertNotNull(_jsonValueGetters); [EOL] assertTrue(_jsonValueGetters.contains(m)); [EOL] }
public void testAddGetterMethodWithNullAnnotationIntrospector() { [EOL] AnnotatedMethod m = Mockito.mock(AnnotatedMethod.class); [EOL] _addGetterMethod(m, null); [EOL] }
public void testAddGetterMethodWithNonNullAnnotationIntrospectorAndNoRelevantAnnotations() { [EOL] AnnotationIntrospector ai = Mockito.mock(AnnotationIntrospector.class); [EOL] AnnotatedMethod m = Mockito.mock(AnnotatedMethod.class); [EOL] Mockito.when(ai.hasAnyGetterAnnotation(m)).thenReturn(false); [EOL] Mockito.when(ai.hasAsValueAnnotation(m)).thenReturn(false); [EOL] Mockito.when(ai.findNameForSerialization(m)).thenReturn(null); [EOL] Mockito.when(BeanUtil.okNameForRegularGetter(m, m.getName())).thenReturn(null); [EOL] Mockito.when(BeanUtil.okNameForIsGetter(m, m.getName())).thenReturn(null); [EOL] _addGetterMethod(m, ai); [EOL] }
public void testAddGetterMethodWithNonNullAnnotationIntrospectorAndExplicitName() { [EOL] AnnotationIntrospector ai = Mockito.mock(AnnotationIntrospector.class); [EOL] AnnotatedMethod m = Mockito.mock(AnnotatedMethod.class); [EOL] PropertyName pn = new PropertyName("explicitName"); [EOL] Mockito.when(ai.hasAnyGetterAnnotation(m)).thenReturn(false); [EOL] Mockito.when(ai.hasAsValueAnnotation(m)).thenReturn(false); [EOL] Mockito.when(ai.findNameForSerialization(m)).thenReturn(pn); [EOL] _addGetterMethod(m, ai); [EOL] }
public void testAddGetterMethodWithNonNullAnnotationIntrospectorAndIgnoreMarker() { [EOL] AnnotationIntrospector ai = Mockito.mock(AnnotationIntrospector.class); [EOL] AnnotatedMethod m = Mockito.mock(AnnotatedMethod.class); [EOL] Mockito.when(ai.hasAnyGetterAnnotation(m)).thenReturn(false); [EOL] Mockito.when(ai.hasAsValueAnnotation(m)).thenReturn(false); [EOL] Mockito.when(ai.findNameForSerialization(m)).thenReturn(null); [EOL] Mockito.when(BeanUtil.okNameForRegularGetter(m, m.getName())).thenReturn("implName"); [EOL] Mockito.when(ai.hasIgnoreMarker(m)).thenReturn(true); [EOL] _addGetterMethod(m, ai); [EOL] }
public void testDoAddInjectableWithNullId() { [EOL] Object id = null; [EOL] AnnotatedMember m = mock(AnnotatedMember.class); [EOL] _doAddInjectable(id, m); [EOL] }
public void testDoAddInjectableWithNonNullIdAndNoPreviousInjectables() { [EOL] Object id = "testId"; [EOL] AnnotatedMember m = mock(AnnotatedMember.class); [EOL] _doAddInjectable(id, m); [EOL] assertNotNull(_injectables); [EOL] assertTrue(_injectables.containsKey(id)); [EOL] assertEquals(m, _injectables.get(id)); [EOL] }
public void testDoAddInjectableWithNonNullIdAndPreviousInjectables() { [EOL] Object id = "testId"; [EOL] AnnotatedMember m1 = mock(AnnotatedMember.class); [EOL] AnnotatedMember m2 = mock(AnnotatedMember.class); [EOL] _doAddInjectable(id, m1); [EOL] assertNotNull(_injectables); [EOL] assertTrue(_injectables.containsKey(id)); [EOL] assertEquals(m1, _injectables.get(id)); [EOL] try { [EOL] _doAddInjectable(id, m2); [EOL] fail("Expected IllegalArgumentException for duplicate injectable id"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testRemoveUnwantedProperties_AllInvisible() { [EOL] _initProperties(Collections.emptyMap()); [EOL] _removeUnwantedProperties(); [EOL] assertTrue(_properties.isEmpty()); [EOL] }
public void testRemoveUnwantedProperties_WithIgnoralsNotExplicitlyIncluded() { [EOL] _initProperties(Collections.singletonMap("ignoredProperty", createPropertyBuilderWithIgnorals(false))); [EOL] _removeUnwantedProperties(); [EOL] assertTrue(_properties.isEmpty()); [EOL] assertTrue(_ignored.contains("ignoredProperty")); [EOL] }
public void testRemoveUnwantedProperties_WithIgnoralsExplicitlyIncluded() { [EOL] _initProperties(Collections.singletonMap("includedProperty", createPropertyBuilderWithIgnorals(true))); [EOL] _removeUnwantedProperties(); [EOL] assertFalse(_properties.isEmpty()); [EOL] assertEquals(1, _properties.size()); [EOL] assertTrue(_properties.containsKey("includedProperty")); [EOL] }
public void testRemoveUnwantedProperties_WithNonVisibleRemoval() { [EOL] _initProperties(Collections.singletonMap("nonVisibleProperty", createPropertyBuilderNonVisible())); [EOL] _config.disable(MapperFeature.INFER_PROPERTY_MUTATORS); [EOL] _removeUnwantedProperties(); [EOL] assertTrue(_properties.isEmpty()); [EOL] }
public void testRemoveUnwantedProperties_WithoutNonVisibleRemoval() { [EOL] _initProperties(Collections.singletonMap("nonVisibleProperty", createPropertyBuilderNonVisible())); [EOL] _config.enable(MapperFeature.INFER_PROPERTY_MUTATORS); [EOL] _removeUnwantedProperties(); [EOL] assertFalse(_properties.isEmpty()); [EOL] assertEquals(1, _properties.size()); [EOL] assertTrue(_properties.containsKey("nonVisibleProperty")); [EOL] }
public void testRemoveUnwantedProperties_WithDeserializeIgnored() { [EOL] _initProperties(Collections.singletonMap("ignoredDeserializeProperty", createPropertyBuilderIgnoredDeserialize())); [EOL] _forSerialization = false; [EOL] _removeUnwantedProperties(); [EOL] assertTrue(_ignored.contains("ignoredDeserializeProperty")); [EOL] }
public void testAddIgnoredForSerializationFalseAndIgnoredPropertyNamesNull() { [EOL] MyObjectMapperUnderTest mapper = new MyObjectMapperUnderTest(false); [EOL] mapper.addIgnored("newIgnoredPropertyName"); [EOL] assertTrue(mapper.getIgnoredPropertyNames().contains("newIgnoredPropertyName")); [EOL] }
public void testAddIgnoredForSerializationFalseAndIgnoredPropertyNamesNotNull() { [EOL] MyObjectMapperUnderTest mapper = new MyObjectMapperUnderTest(false); [EOL] mapper.addIgnored("existingIgnoredPropertyName"); [EOL] mapper.addIgnored("newIgnoredPropertyName"); [EOL] assertTrue(mapper.getIgnoredPropertyNames().contains("existingIgnoredPropertyName")); [EOL] assertTrue(mapper.getIgnoredPropertyNames().contains("newIgnoredPropertyName")); [EOL] }
public void testAddIgnoredForSerializationTrue() { [EOL] MyObjectMapperUnderTest mapper = new MyObjectMapperUnderTest(true); [EOL] mapper.addIgnored("ignoredPropertyName"); [EOL] assertNull(mapper.getIgnoredPropertyNames()); [EOL] }
public void testRenamePropertiesWithNewName() { [EOL] POJOPropertyBuilder prop = createPropertyBuilderWithName("oldName"); [EOL] when(prop.findNewName()).thenReturn("newName"); [EOL] Map<String, POJOPropertyBuilder> properties = new HashMap<>(); [EOL] properties.put("oldName", prop); [EOL] setPropertiesField(properties); [EOL] _renameProperties(); [EOL] assertNull(properties.get("oldName")); [EOL] assertNotNull(properties.get("newName")); [EOL] assertEquals(prop, properties.get("newName")); [EOL] }
public void testRenamePropertiesWithoutNewName() { [EOL] POJOPropertyBuilder prop = createPropertyBuilderWithName("name"); [EOL] when(prop.findNewName()).thenReturn(null); [EOL] Map<String, POJOPropertyBuilder> properties = new HashMap<>(); [EOL] properties.put("name", prop); [EOL] setPropertiesField(properties); [EOL] _renameProperties(); [EOL] assertNotNull(properties.get("name")); [EOL] assertEquals(prop, properties.get("name")); [EOL] }
public void testRenamePropertiesWithCreatorProperties() { [EOL] POJOPropertyBuilder prop = createPropertyBuilderWithName("oldName"); [EOL] when(prop.findNewName()).thenReturn("newName"); [EOL] Map<String, POJOPropertyBuilder> properties = new HashMap<>(); [EOL] properties.put("oldName", prop); [EOL] setPropertiesField(properties); [EOL] List<POJOPropertyBuilder> creatorProperties = new ArrayList<>(); [EOL] creatorProperties.add(prop); [EOL] setCreatorPropertiesField(creatorProperties); [EOL] _renameProperties(); [EOL] assertNull(properties.get("oldName")); [EOL] assertNotNull(properties.get("newName")); [EOL] assertEquals(prop, properties.get("newName")); [EOL] assertEquals(prop, creatorProperties.get(0)); [EOL] }
public void testRenamePropertiesWithExistingProperty() { [EOL] POJOPropertyBuilder prop1 = createPropertyBuilderWithName("oldName"); [EOL] POJOPropertyBuilder prop2 = createPropertyBuilderWithName("newName"); [EOL] when(prop1.findNewName()).thenReturn("newName"); [EOL] Map<String, POJOPropertyBuilder> properties = new HashMap<>(); [EOL] properties.put("oldName", prop1); [EOL] properties.put("newName", prop2); [EOL] setPropertiesField(properties); [EOL] _renameProperties(); [EOL] assertNull(properties.get("oldName")); [EOL] assertNotNull(properties.get("newName")); [EOL] assertNotEquals(prop1, properties.get("newName")); [EOL] assertEquals(prop2, properties.get("newName")); [EOL] verify(prop2).addAll(prop1); [EOL] }
public void testRenameUsingSerializationWithGetter() { [EOL] PropertyNamingStrategy naming = mock(PropertyNamingStrategy.class); [EOL] POJOPropertyBuilder prop = mock(POJOPropertyBuilder.class); [EOL] when(prop.getName()).thenReturn("originalName"); [EOL] when(prop.hasGetter()).thenReturn(true); [EOL] when(naming.nameForGetterMethod(any(), any(), any())).thenReturn("renamedName"); [EOL] _renameUsing(naming); [EOL] assertEquals("renamedName", prop.getName()); [EOL] }
public void testRenameUsingSerializationWithField() { [EOL] PropertyNamingStrategy naming = mock(PropertyNamingStrategy.class); [EOL] POJOPropertyBuilder prop = mock(POJOPropertyBuilder.class); [EOL] when(prop.getName()).thenReturn("originalName"); [EOL] when(prop.hasField()).thenReturn(true); [EOL] when(naming.nameForField(any(), any(), any())).thenReturn("renamedName"); [EOL] _renameUsing(naming); [EOL] assertEquals("renamedName", prop.getName()); [EOL] }
public void testRenameUsingDeserializationWithSetter() { [EOL] PropertyNamingStrategy naming = mock(PropertyNamingStrategy.class); [EOL] POJOPropertyBuilder prop = mock(POJOPropertyBuilder.class); [EOL] when(prop.getName()).thenReturn("originalName"); [EOL] when(prop.hasSetter()).thenReturn(true); [EOL] when(naming.nameForSetterMethod(any(), any(), any())).thenReturn("renamedName"); [EOL] _renameUsing(naming); [EOL] assertEquals("renamedName", prop.getName()); [EOL] }
public void testRenameUsingDeserializationWithConstructorParameter() { [EOL] PropertyNamingStrategy naming = mock(PropertyNamingStrategy.class); [EOL] POJOPropertyBuilder prop = mock(POJOPropertyBuilder.class); [EOL] when(prop.getName()).thenReturn("originalName"); [EOL] when(prop.hasConstructorParameter()).thenReturn(true); [EOL] when(naming.nameForConstructorParameter(any(), any(), any())).thenReturn("renamedName"); [EOL] _renameUsing(naming); [EOL] assertEquals("renamedName", prop.getName()); [EOL] }
public void testRenameUsingDeserializationWithField() { [EOL] PropertyNamingStrategy naming = mock(PropertyNamingStrategy.class); [EOL] POJOPropertyBuilder prop = mock(POJOPropertyBuilder.class); [EOL] when(prop.getName()).thenReturn("originalName"); [EOL] when(prop.hasField()).thenReturn(true); [EOL] when(naming.nameForField(any(), any(), any())).thenReturn("renamedName"); [EOL] _renameUsing(naming); [EOL] assertEquals("renamedName", prop.getName()); [EOL] }
public void testRenameUsingDeserializationWithGetter() { [EOL] PropertyNamingStrategy naming = mock(PropertyNamingStrategy.class); [EOL] POJOPropertyBuilder prop = mock(POJOPropertyBuilder.class); [EOL] when(prop.getName()).thenReturn("originalName"); [EOL] when(prop.hasGetter()).thenReturn(true); [EOL] when(naming.nameForGetterMethod(any(), any(), any())).thenReturn("renamedName"); [EOL] _renameUsing(naming); [EOL] assertEquals("renamedName", prop.getName()); [EOL] }
public void testRenameUsingNoChanges() { [EOL] PropertyNamingStrategy naming = mock(PropertyNamingStrategy.class); [EOL] POJOPropertyBuilder prop = mock(POJOPropertyBuilder.class); [EOL] when(prop.getName()).thenReturn("originalName"); [EOL] when(prop.hasGetter()).thenReturn(false); [EOL] when(prop.hasSetter()).thenReturn(false); [EOL] when(prop.hasField()).thenReturn(false); [EOL] when(prop.hasConstructorParameter()).thenReturn(false); [EOL] _renameUsing(naming); [EOL] assertEquals("originalName", prop.getName()); [EOL] }
protected void reportProblem(String msg) { [EOL] throw new IllegalArgumentException("Problem with definition of " + _classDef + ": " + msg); [EOL] }
public void testEnumResolverWithNonNullValues() { [EOL] Class<YourEnum> enumClass = YourEnum.class; [EOL] YourEnum[] enums = YourEnum.values(); [EOL] HashMap<String, YourEnum> map = new HashMap<>(); [EOL] for (YourEnum e : enums) { [EOL] map.put(e.name(), e); [EOL] } [EOL] EnumResolver<YourEnum> resolver = new EnumResolver<>(enumClass, enums, map); [EOL] assertEquals(enumClass, resolver.getEnumClass()); [EOL] assertArrayEquals(enums, resolver.getRawEnums()); [EOL] assertEquals(map, resolver.getEnumsById()); [EOL] }
public void testEnumResolverWithNullValues() { [EOL] EnumResolver<YourEnum> resolver = new EnumResolver<>(null, null, null); [EOL] assertNull(resolver.getEnumClass()); [EOL] assertNull(resolver.getRawEnums()); [EOL] assertNull(resolver.getEnumsById()); [EOL] }
public void testConstructFor_WithValidEnumAndIntrospector() { [EOL] Class<YourEnum> enumCls = YourEnum.class; [EOL] AnnotationIntrospector ai = Mockito.mock(AnnotationIntrospector.class); [EOL] Mockito.when(ai.findEnumValue(Mockito.any())).thenReturn("ENUM_VALUE"); [EOL] EnumResolver<YourEnum> resolver = EnumResolver.constructFor(enumCls, ai); [EOL] assertNotNull(resolver); [EOL] assertEquals(YourEnum.class, resolver.getEnumClass()); [EOL] assertEquals(YourEnum.ENUM_VALUE, resolver.getEnum("ENUM_VALUE")); [EOL] }
public void testConstructFor_WithInvalidEnum_ExpectIllegalArgumentException() { [EOL] Class<InvalidEnum> enumCls = InvalidEnum.class; [EOL] AnnotationIntrospector ai = Mockito.mock(AnnotationIntrospector.class); [EOL] try { [EOL] EnumResolver.constructFor(enumCls, ai); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("No enum constants for class " + enumCls.getName(), e.getMessage()); [EOL] } [EOL] }
public void testConstructUnsafeWithValidEnum() { [EOL] Class<?> rawEnumCls = MyEnum.class; [EOL] AnnotationIntrospector ai = new AnnotationIntrospectorStub(); [EOL] EnumResolver<?> resolver = EnumResolver.constructUnsafe(rawEnumCls, ai); [EOL] assertNotNull(resolver); [EOL] }
public void testConstructUnsafeWithNullEnum() { [EOL] Class<?> rawEnumCls = null; [EOL] AnnotationIntrospector ai = new AnnotationIntrospectorStub(); [EOL] try { [EOL] EnumResolver.constructUnsafe(rawEnumCls, ai); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testConstructUnsafeWithNonEnumClass() { [EOL] Class<?> rawEnumCls = String.class; [EOL] AnnotationIntrospector ai = new AnnotationIntrospectorStub(); [EOL] try { [EOL] EnumResolver.constructUnsafe(rawEnumCls, ai); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public T findEnum(String key) { [EOL] return _enumsById.get(key); [EOL] }
public void testAbstractDeserializerWithStringClass() { [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] JavaType javaType = mock(JavaType.class); [EOL] when(beanDesc.getType()).thenReturn(javaType); [EOL] when(javaType.getRawClass()).thenReturn(String.class); [EOL] BeanDeserializerBuilder builder = mock(BeanDeserializerBuilder.class); [EOL] when(builder.getObjectIdReader()).thenReturn(null); [EOL] Map<String, SettableBeanProperty> backRefProps = new HashMap<>(); [EOL] AbstractDeserializer ad = new AbstractDeserializer(builder, beanDesc, backRefProps); [EOL] assertTrue(ad._acceptString); [EOL] assertFalse(ad._acceptBoolean); [EOL] assertFalse(ad._acceptInt); [EOL] assertFalse(ad._acceptDouble); [EOL] }
public void testAbstractDeserializerWithBooleanClass() { [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] JavaType javaType = mock(JavaType.class); [EOL] when(beanDesc.getType()).thenReturn(javaType); [EOL] when(javaType.getRawClass()).thenReturn(Boolean.class); [EOL] BeanDeserializerBuilder builder = mock(BeanDeserializerBuilder.class); [EOL] when(builder.getObjectIdReader()).thenReturn(null); [EOL] Map<String, SettableBeanProperty> backRefProps = new HashMap<>(); [EOL] AbstractDeserializer ad = new AbstractDeserializer(builder, beanDesc, backRefProps); [EOL] assertFalse(ad._acceptString); [EOL] assertTrue(ad._acceptBoolean); [EOL] assertFalse(ad._acceptInt); [EOL] assertFalse(ad._acceptDouble); [EOL] }
public void testAbstractDeserializerWithIntClass() { [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] JavaType javaType = mock(JavaType.class); [EOL] when(beanDesc.getType()).thenReturn(javaType); [EOL] when(javaType.getRawClass()).thenReturn(Integer.class); [EOL] BeanDeserializerBuilder builder = mock(BeanDeserializerBuilder.class); [EOL] when(builder.getObjectIdReader()).thenReturn(null); [EOL] Map<String, SettableBeanProperty> backRefProps = new HashMap<>(); [EOL] AbstractDeserializer ad = new AbstractDeserializer(builder, beanDesc, backRefProps); [EOL] assertFalse(ad._acceptString); [EOL] assertFalse(ad._acceptBoolean); [EOL] assertTrue(ad._acceptInt); [EOL] assertFalse(ad._acceptDouble); [EOL] }
public void testAbstractDeserializerWithDoubleClass() { [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] JavaType javaType = mock(JavaType.class); [EOL] when(beanDesc.getType()).thenReturn(javaType); [EOL] when(javaType.getRawClass()).thenReturn(Double.class); [EOL] BeanDeserializerBuilder builder = mock(BeanDeserializerBuilder.class); [EOL] when(builder.getObjectIdReader()).thenReturn(null); [EOL] Map<String, SettableBeanProperty> backRefProps = new HashMap<>(); [EOL] AbstractDeserializer ad = new AbstractDeserializer(builder, beanDesc, backRefProps); [EOL] assertFalse(ad._acceptString); [EOL] assertFalse(ad._acceptBoolean); [EOL] assertFalse(ad._acceptInt); [EOL] assertTrue(ad._acceptDouble); [EOL] }
public void testDeserializeWithTypeWithObjectId() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] TypeDeserializer typeDeserializer = mock(TypeDeserializer.class); [EOL] ObjectIdReader objectIdReader = mock(ObjectIdReader.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(_objectIdReader).thenReturn(objectIdReader); [EOL] Object expected = new Object(); [EOL] when(_deserializeFromObjectId(jp, ctxt)).thenReturn(expected); [EOL] Object result = deserializeWithType(jp, ctxt, typeDeserializer); [EOL] assertSame(expected, result); [EOL] }
public void testDeserializeWithTypeWithNaturalType() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] TypeDeserializer typeDeserializer = mock(TypeDeserializer.class); [EOL] when(_objectIdReader).thenReturn(null); [EOL] when(_deserializeIfNatural(jp, ctxt)).thenReturn("natural"); [EOL] Object result = deserializeWithType(jp, ctxt, typeDeserializer); [EOL] assertEquals("natural", result); [EOL] }
public void testDeserializeWithTypeUsingTypeDeserializer() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] TypeDeserializer typeDeserializer = mock(TypeDeserializer.class); [EOL] when(_objectIdReader).thenReturn(null); [EOL] when(_deserializeIfNatural(jp, ctxt)).thenReturn(null); [EOL] Object expected = new Object(); [EOL] when(typeDeserializer.deserializeTypedFromObject(jp, ctxt)).thenReturn(expected); [EOL] Object result = deserializeWithType(jp, ctxt, typeDeserializer); [EOL] assertSame(expected, result); [EOL] }
public void testDeserializeThrowsInstantiationException() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] AbstractDeserializer deserializer = new AbstractDeserializer(null); [EOL] try { [EOL] deserializer.deserialize(jp, ctxt); [EOL] fail("Expected an InstantiationException to be thrown"); [EOL] } catch (InstantiationException e) { [EOL] assertNotNull(e.getMessage()); [EOL] } [EOL] }
public void testDeserializeIfNaturalWithStringTokenAndAcceptStringTrue() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("testString"); [EOL] YourDeserializer deserializer = new YourDeserializer(true, false, false, false); [EOL] Object result = deserializer._deserializeIfNatural(jp, ctxt); [EOL] assertEquals("testString", result); [EOL] }
public void testDeserializeIfNaturalWithIntTokenAndAcceptIntTrue() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); [EOL] when(jp.getIntValue()).thenReturn(123); [EOL] YourDeserializer deserializer = new YourDeserializer(false, true, false, false); [EOL] Object result = deserializer._deserializeIfNatural(jp, ctxt); [EOL] assertEquals(123, result); [EOL] }
public void testDeserializeIfNaturalWithFloatTokenAndAcceptDoubleTrue() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_FLOAT); [EOL] when(jp.getDoubleValue()).thenReturn(45.67); [EOL] YourDeserializer deserializer = new YourDeserializer(false, false, true, false); [EOL] Object result = deserializer._deserializeIfNatural(jp, ctxt); [EOL] assertEquals(Double.valueOf(45.67), result); [EOL] }
public void testDeserializeIfNaturalWithTrueTokenAndAcceptBooleanTrue() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_TRUE); [EOL] YourDeserializer deserializer = new YourDeserializer(false, false, false, true); [EOL] Object result = deserializer._deserializeIfNatural(jp, ctxt); [EOL] assertEquals(Boolean.TRUE, result); [EOL] }
public void testDeserializeIfNaturalWithFalseTokenAndAcceptBooleanTrue() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_FALSE); [EOL] YourDeserializer deserializer = new YourDeserializer(false, false, false, true); [EOL] Object result = deserializer._deserializeIfNatural(jp, ctxt); [EOL] assertEquals(Boolean.FALSE, result); [EOL] }
public void testDeserializeIfNaturalWithUnsupportedToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NULL); [EOL] YourDeserializer deserializer = new YourDeserializer(false, false, false, false); [EOL] Object result = deserializer._deserializeIfNatural(jp, ctxt); [EOL] assertNull(result); [EOL] }
public void testSetterlessPropertyWithNonNullValues() { [EOL] BeanPropertyDefinition propDef = mock(BeanPropertyDefinition.class); [EOL] JavaType type = mock(JavaType.class); [EOL] TypeDeserializer typeDeser = mock(TypeDeserializer.class); [EOL] Annotations contextAnnotations = mock(Annotations.class); [EOL] AnnotatedMethod method = mock(AnnotatedMethod.class); [EOL] when(method.getAnnotated()).thenReturn(mock(Method.class)); [EOL] SetterlessProperty property = new SetterlessProperty(propDef, type, typeDeser, contextAnnotations, method); [EOL] assertNotNull(property); [EOL] assertEquals(method, property.getAnnotated()); [EOL] assertEquals(method.getAnnotated(), property.getGetter()); [EOL] }
public void testSetterlessPropertyCopyConstructor() { [EOL] AnnotatedMethod annotatedMethod = new AnnotatedMethod(null, null, null, null); [EOL] JsonDeserializer<Object> originalDeserializer = new SomeJsonDeserializerImplementation(); [EOL] JsonDeserializer<Object> newDeserializer = new SomeJsonDeserializerImplementation(); [EOL] SetterlessProperty original = new SetterlessProperty("propertyName", null, null, annotatedMethod, originalDeserializer); [EOL] SetterlessProperty copy = new SetterlessProperty(original, newDeserializer); [EOL] assertNotNull(copy); [EOL] assertSame("The annotated field should reference the same object", original._annotated, copy._annotated); [EOL] assertSame("The getter field should reference the same object", original._getter, copy._getter); [EOL] assertNotSame("The deserializer should be a new instance", original.getDeserializer(), copy.getDeserializer()); [EOL] }
public void testWithValueDeserializer_NewDeserializer() { [EOL] SetterlessProperty original = new SetterlessProperty(/* provide necessary arguments */); [EOL] JsonDeserializer<?> newDeserializer = /* instantiate a new JsonDeserializer */; [EOL] SetterlessProperty result = original.withValueDeserializer(newDeserializer); [EOL] assertNotNull(result); [EOL] assertNotSame(original, result); [EOL] assertEquals(newDeserializer, result.getValueDeserializer()); [EOL] }
public void testWithValueDeserializer_SameDeserializer() { [EOL] JsonDeserializer<?> originalDeserializer = /* instantiate a JsonDeserializer */; [EOL] SetterlessProperty original = new SetterlessProperty(/* provide necessary arguments */, originalDeserializer); [EOL] SetterlessProperty result = original.withValueDeserializer(originalDeserializer); [EOL] assertNotNull(result); [EOL] assertNotSame(original, result); [EOL] assertEquals(originalDeserializer, result.getValueDeserializer()); [EOL] }
public void testDeserializeAndSetWithNullValue() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object instance = new Object(); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NULL); [EOL] deserializeAndSet(jp, ctxt, instance); [EOL] verify(jp).getCurrentToken(); [EOL] verifyNoMoreInteractions(jp, ctxt); [EOL] }
public void testDeserializeAndSetWithGetterException() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object instance = new Object(); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); // Not VALUE_NULL [EOL] when(_getter.invoke(instance)).thenThrow(new Exception("Getter exception")); [EOL] try { [EOL] deserializeAndSet(jp, ctxt, instance); [EOL] fail("Expected an IOException to be thrown"); [EOL] } catch (IOException e) { [EOL] } [EOL] verify(jp).getCurrentToken(); [EOL] verify(_getter).invoke(instance); [EOL] }
public void testDeserializeAndSetWithGetterReturnsNull() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object instance = new Object(); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); // Not VALUE_NULL [EOL] when(_getter.invoke(instance)).thenReturn(null); [EOL] try { [EOL] deserializeAndSet(jp, ctxt, instance); [EOL] fail("Expected a JsonMappingException to be thrown"); [EOL] } catch (JsonMappingException e) { [EOL] assertEquals("Problem deserializing 'setterless' property '" + getName() + "': get method returned null", e.getMessage()); [EOL] } [EOL] verify(jp).getCurrentToken(); [EOL] verify(_getter).invoke(instance); [EOL] }
public void testDeserializeAndSetWithValidGetter() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object instance = new Object(); [EOL] Object toModify = new Object(); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); // Not VALUE_NULL [EOL] when(_getter.invoke(instance)).thenReturn(toModify); [EOL] deserializeAndSet(jp, ctxt, instance); [EOL] verify(jp).getCurrentToken(); [EOL] verify(_getter).invoke(instance); [EOL] verify(_valueDeserializer).deserialize(jp, ctxt, toModify); [EOL] }
public void testWithDeserializationFeatureEnabled() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] DeserializationFeature feature = DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY; [EOL] ObjectReader reader = mapper.reader(); [EOL] ObjectReader newReader = reader.with(feature); [EOL] assertTrue(newReader.isEnabled(feature)); [EOL] }
public void testWithDeserializationFeatureDisabled() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] DeserializationFeature feature = DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY; [EOL] ObjectReader reader = mapper.reader().without(feature); [EOL] ObjectReader newReader = reader.with(feature); [EOL] assertTrue(newReader.isEnabled(feature)); [EOL] }
public void testWithRootName_Null() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] ObjectReader reader = mapper.reader(); [EOL] ObjectReader newReader = reader.withRootName(null); [EOL] assertNotNull(newReader); [EOL] assertNotSame(reader, newReader); [EOL] }
public void testWithRootName_NonNull() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] ObjectReader reader = mapper.reader(); [EOL] ObjectReader newReader = reader.withRootName("myRoot"); [EOL] assertNotNull(newReader); [EOL] assertNotSame(reader, newReader); [EOL] assertEquals("myRoot", newReader.getConfig().getRootName()); [EOL] }
protected Object _bindAndClose(JsonParser jp, Object valueToUpdate) throws IOException, JsonParseException, JsonMappingException { [EOL] if (_schema != null) { [EOL] jp.setSchema(_schema); [EOL] } [EOL] try { [EOL] Object result; [EOL] JsonToken t = _initForReading(jp); [EOL] if (t == JsonToken.VALUE_NULL) { [EOL] if (valueToUpdate == null) { [EOL] DeserializationContext ctxt = createDeserializationContext(jp, _config); [EOL] result = _findRootDeserializer(ctxt, _valueType).getNullValue(); [EOL] } else { [EOL] result = valueToUpdate; [EOL] } [EOL] } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) { [EOL] result = valueToUpdate; [EOL] } else { [EOL] DeserializationContext ctxt = createDeserializationContext(jp, _config); [EOL] JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, _valueType); [EOL] if (_unwrapRoot) { [EOL] result = _unwrapAndDeserialize(jp, ctxt, _valueType, deser); [EOL] } else { [EOL] if (valueToUpdate == null) { [EOL] result = deser.deserialize(jp, ctxt); [EOL] } else { [EOL] deser.deserialize(jp, ctxt, valueToUpdate); [EOL] result = valueToUpdate; [EOL] } [EOL] } [EOL] } [EOL] return result; [EOL] } finally { [EOL] try { [EOL] jp.close(); [EOL] } catch (IOException ioe) { [EOL] } [EOL] } [EOL] }
public void testPrefetchRootDeserializerWithNullValueType() { [EOL] DeserializationConfig config = new DeserializationConfig(...); // Provide necessary initialization [EOL] JavaType valueType = null; [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] JsonDeserializer<Object> result = mapper._prefetchRootDeserializer(config, valueType); [EOL] assertNull(result); [EOL] }
public void testPrefetchRootDeserializerWithEagerDeserializerFetchDisabled() { [EOL] DeserializationConfig config = new DeserializationConfig(...); // Provide necessary initialization [EOL] config.disable(DeserializationFeature.EAGER_DESERIALIZER_FETCH); [EOL] JavaType valueType = ...; // Provide necessary initialization [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] JsonDeserializer<Object> result = mapper._prefetchRootDeserializer(config, valueType); [EOL] assertNull(result); [EOL] }
public void testPrefetchRootDeserializerWithEagerDeserializerFetchEnabledAndDeserializerNotFound() { [EOL] DeserializationConfig config = new DeserializationConfig(...); // Provide necessary initialization [EOL] config.enable(DeserializationFeature.EAGER_DESERIALIZER_FETCH); [EOL] JavaType valueType = ...; // Provide necessary initialization [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] JsonDeserializer<Object> result = mapper._prefetchRootDeserializer(config, valueType); [EOL] assertNotNull(result); [EOL] }
public void testPrefetchRootDeserializerWithEagerDeserializerFetchEnabledAndDeserializerFound() { [EOL] DeserializationConfig config = new DeserializationConfig(...); // Provide necessary initialization [EOL] config.enable(DeserializationFeature.EAGER_DESERIALIZER_FETCH); [EOL] JavaType valueType = ...; // Provide necessary initialization [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] mapper._rootDeserializers.put(valueType, ...); // Provide necessary initialization for the deserializer [EOL] JsonDeserializer<Object> result = mapper._prefetchRootDeserializer(config, valueType); [EOL] assertNotNull(result); [EOL] }
public void testPrefetchRootDeserializerWithEagerDeserializerFetchEnabledAndExceptionThrown() { [EOL] DeserializationConfig config = new DeserializationConfig(...); // Provide necessary initialization [EOL] config.enable(DeserializationFeature.EAGER_DESERIALIZER_FETCH); [EOL] JavaType valueType = ...; // Provide necessary initialization that will cause an exception [EOL] ObjectMapper mapper = new ObjectMapper() { [EOL] @Override [EOL] protected DeserializationContext createDeserializationContext(JsonParser p, DeserializationConfig cfg) { [EOL] return new DeserializationContext(...) { // Provide necessary initialization [EOL] @Override [EOL] public JsonDeserializer<Object> findRootValueDeserializer(JavaType type) throws JsonProcessingException { [EOL] throw new JsonProcessingException("") {}; [EOL] } [EOL] }; [EOL] } [EOL] }; [EOL] JsonDeserializer<Object> result = null; [EOL] try { [EOL] result = mapper._prefetchRootDeserializer(config, valueType); [EOL] } catch (JsonProcessingException e) { [EOL] } [EOL] assertNull(result); [EOL] }
public void testUnwrapAndDeserializeWithNullRootNameAndStartObjectToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JavaType rootType = mock(JavaType.class); [EOL] JsonDeserializer<Object> deser = mock(JsonDeserializer.class); [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] ObjectReader reader = mapper.reader(); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); [EOL] when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); [EOL] when(jp.getCurrentName()).thenReturn("expectedRootName"); [EOL] when(deser.deserialize(jp, ctxt)).thenReturn(new Object()); [EOL] Object result = reader._unwrapAndDeserialize(jp, ctxt, rootType, deser); [EOL] assertNotNull(result); [EOL] }
public void testUnwrapAndDeserializeWithNonNullRootNameAndMismatchingFieldName() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JavaType rootType = mock(JavaType.class); [EOL] JsonDeserializer<Object> deser = mock(JsonDeserializer.class); [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] ObjectReader reader = mapper.reader(); [EOL] reader._config = mapper.getDeserializationConfig(); [EOL] reader._config = reader._config.withRootName("expectedRootName"); [EOL] reader._rootNames = new RootNameLookup(); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); [EOL] when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME); [EOL] when(jp.getCurrentName()).thenReturn("unexpectedRootName"); [EOL] assertThrows(JsonMappingException.class, () -> { [EOL] reader._unwrapAndDeserialize(jp, ctxt, rootType, deser); [EOL] }); [EOL] }
public void testUnwrapAndDeserializeWithIncorrectStartToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JavaType rootType = mock(JavaType.class); [EOL] JsonDeserializer<Object> deser = mock(JsonDeserializer.class); [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] ObjectReader reader = mapper.reader(); [EOL] reader._config = mapper.getDeserializationConfig(); [EOL] reader._config = reader._config.withRootName("expectedRootName"); [EOL] reader._rootNames = new RootNameLookup(); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] assertThrows(JsonMappingException.class, () -> { [EOL] reader._unwrapAndDeserialize(jp, ctxt, rootType, deser); [EOL] }); [EOL] }
public void testUnwrapAndDeserializeWithIncorrectTokenAfterFieldName() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JavaType rootType = mock(JavaType.class); [EOL] JsonDeserializer<Object> deser = mock(JsonDeserializer.class); [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] ObjectReader reader = mapper.reader(); [EOL] reader._config = mapper.getDeserializationConfig(); [EOL] reader._config = reader._config.withRootName("expectedRootName"); [EOL] reader._rootNames = new RootNameLookup(); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); [EOL] when(jp.nextToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] assertThrows(JsonMappingException.class, () -> { [EOL] reader._unwrapAndDeserialize(jp, ctxt, rootType, deser); [EOL] }); [EOL] }
public void testUnwrapAndDeserializeWithIncorrectEndToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JavaType rootType = mock(JavaType.class); [EOL] JsonDeserializer<Object> deser = mock(JsonDeserializer.class); [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] ObjectReader reader = mapper.reader(); [EOL] reader._config = mapper.getDeserializationConfig(); [EOL] reader._config = reader._config.withRootName("expectedRootName"); [EOL] reader._rootNames = new RootNameLookup(); [EOL] reader._valueToUpdate = new Object(); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); [EOL] when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME).thenReturn(JsonToken.VALUE_STRING).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getCurrentName()).thenReturn("expectedRootName"); [EOL] when(deser.deserialize(jp, ctxt, reader._valueToUpdate)).thenReturn(reader._valueToUpdate); [EOL] assertThrows(JsonMappingException.class, () -> { [EOL] reader._unwrapAndDeserialize(jp, ctxt, rootType, deser); [EOL] }); [EOL] }
public void testPropertyNameWithSimpleName() { [EOL] String simpleName = "testName"; [EOL] PropertyName propertyName = new PropertyName(simpleName); [EOL] assertNotNull(propertyName); [EOL] assertEquals(simpleName, propertyName.getSimpleName()); [EOL] assertNull(propertyName.getNamespace()); [EOL] }
public void testPropertyNameWithNullSimpleName() { [EOL] PropertyName propertyName = new PropertyName(null, "namespace"); [EOL] assertEquals("", propertyName.getSimpleName()); [EOL] assertEquals("namespace", propertyName.getNamespace()); [EOL] }
public void testPropertyNameWithNonNullSimpleName() { [EOL] PropertyName propertyName = new PropertyName("simpleName", "namespace"); [EOL] assertEquals("simpleName", propertyName.getSimpleName()); [EOL] assertEquals("namespace", propertyName.getNamespace()); [EOL] }
public void testPropertyNameWithNullNamespace() { [EOL] PropertyName propertyName = new PropertyName("simpleName", null); [EOL] assertEquals("simpleName", propertyName.getSimpleName()); [EOL] assertNull(propertyName.getNamespace()); [EOL] }
public void testPropertyNameWithNonNullValues() { [EOL] PropertyName propertyName = new PropertyName("simpleName", "namespace"); [EOL] assertEquals("simpleName", propertyName.getSimpleName()); [EOL] assertEquals("namespace", propertyName.getNamespace()); [EOL] }
public void testGetSimpleNameWhenSimpleNameIsNotNull() { [EOL] PropertyName propertyName = new PropertyName("testName"); [EOL] String simpleName = propertyName.getSimpleName(); [EOL] assertNotNull(simpleName); [EOL] assertEquals("testName", simpleName); [EOL] }
public void testGetSimpleNameWhenSimpleNameIsNull() { [EOL] PropertyName propertyName = new PropertyName(null); [EOL] String simpleName = propertyName.getSimpleName(); [EOL] assertNull(simpleName); [EOL] }
public void testHasSimpleNameWithNonEmptyName() { [EOL] PropertyName propertyName = new PropertyName("name"); [EOL] assertTrue(propertyName.hasSimpleName()); [EOL] }
public void testHasSimpleNameWithEmptyName() { [EOL] PropertyName propertyName = new PropertyName(""); [EOL] assertFalse(propertyName.hasSimpleName()); [EOL] }
public void testCollectionLikeTypeWithNonNullElements() { [EOL] JavaType elemType = TypeFactory.defaultInstance().constructType(String.class); [EOL] CollectionLikeType clt = new CollectionLikeType(List.class, elemType, null, null, false); [EOL] assertNotNull(clt); [EOL] assertEquals(elemType, clt.getContentType()); [EOL] }
public void testCollectionLikeTypeWithNullElements() { [EOL] JavaType elemType = null; [EOL] try { [EOL] new CollectionLikeType(List.class, elemType, null, null, false); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testCollectionLikeTypeWithStaticFlag() { [EOL] JavaType elemType = TypeFactory.defaultInstance().constructType(String.class); [EOL] CollectionLikeType clt = new CollectionLikeType(List.class, elemType, null, null, true); [EOL] assertNotNull(clt); [EOL] assertTrue(clt.isStatic()); [EOL] }
public void testCollectionLikeTypeWithValueAndTypeHandlers() { [EOL] JavaType elemType = TypeFactory.defaultInstance().constructType(String.class); [EOL] Object valueHandler = new Object(); [EOL] Object typeHandler = new Object(); [EOL] CollectionLikeType clt = new CollectionLikeType(List.class, elemType, valueHandler, typeHandler, false); [EOL] assertNotNull(clt); [EOL] assertEquals(valueHandler, clt.getValueHandler()); [EOL] assertEquals(typeHandler, clt.getTypeHandler()); [EOL] }
public void testIsCollectionLikeType() { [EOL] MyType type = new MyType(); [EOL] boolean result = type.isCollectionLikeType(); [EOL] assertTrue(result); [EOL] }
public void testGetContentTypeWhenElementTypeIsNull() { [EOL] MyJacksonClass instance = new MyJacksonClass(null); [EOL] JavaType result = instance.getContentType(); [EOL] assertNull(result); [EOL] }
public void testGetContentTypeWhenElementTypeIsNotNull() { [EOL] JavaType mockElementType = mock(JavaType.class); [EOL] MyJacksonClass instance = new MyJacksonClass(mockElementType); [EOL] JavaType result = instance.getContentType(); [EOL] assertSame(mockElementType, result); [EOL] }
public void testContainedTypeWithIndexZero() { [EOL] ContainingClass instance = new ContainingClass(); [EOL] JavaType result = instance.containedType(0); [EOL] assertNotNull(result); [EOL] }
public void testContainedTypeWithIndexNonZero() { [EOL] ContainingClass instance = new ContainingClass(); [EOL] JavaType result = instance.containedType(1); [EOL] assertNull(result); [EOL] }
public void testIsTrueCollectionType_withCollectionSubtype() { [EOL] JavaType javaType = TypeFactory.defaultInstance().constructType(ArrayList.class); [EOL] assertTrue(javaType.isTrueCollectionType()); [EOL] }
public void testIsTrueCollectionType_withNonCollectionType() { [EOL] JavaType javaType = TypeFactory.defaultInstance().constructType(String.class); [EOL] assertFalse(javaType.isTrueCollectionType()); [EOL] }
public void testTypeBaseConstructor() { [EOL] Class<?> raw = Object.class; [EOL] int hash = 1; [EOL] Object valueHandler = new Object(); [EOL] Object typeHandler = new Object(); [EOL] boolean asStatic = true; [EOL] TypeBase typeBase = new TypeBase(raw, hash, valueHandler, typeHandler, asStatic); [EOL] }
public void testWithRootName_NullRootName() { [EOL] ObjectWriter writer = new ObjectWriter(); [EOL] ObjectWriter result = writer.withRootName(null); [EOL] assertNotNull(result); [EOL] assertNotSame(writer, result); [EOL] }
public void testWithRootName_NonNullRootName() { [EOL] ObjectWriter writer = new ObjectWriter(); [EOL] ObjectWriter result = writer.withRootName("root"); [EOL] assertNotNull(result); [EOL] assertNotSame(writer, result); [EOL] }
public void testWithRootName_SameRootName() { [EOL] ObjectWriter writer = new ObjectWriter(); [EOL] ObjectWriter result = writer.withRootName(writer._config.getRootName()); [EOL] assertNotNull(result); [EOL] assertSame(writer, result); [EOL] }
public void testWriteValueWithValidWriterAndValue() throws IOException, JsonGenerationException, JsonMappingException { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] Writer writer = new StringWriter(); [EOL] Object value = new Object(); [EOL] mapper.writeValue(writer, value); [EOL] assertFalse(writer.toString().isEmpty()); [EOL] }
public void testWriteValueWithNullWriter() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] Object value = new Object(); [EOL] assertThrows(IOException.class, () -> mapper.writeValue(null, value)); [EOL] }
public void testWriteValueWithNullValue() throws IOException, JsonGenerationException, JsonMappingException { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] Writer writer = new StringWriter(); [EOL] mapper.writeValue(writer, null); [EOL] assertTrue(writer.toString().isEmpty() || writer.toString().equals("null")); [EOL] }
public void testPathWithValidIndex() { [EOL] ArrayNode arrayNode = JsonNodeFactory.instance.arrayNode(); [EOL] arrayNode.add(1); [EOL] arrayNode.add(2); [EOL] JsonNode result = arrayNode.path(1); [EOL] assertNotNull(result); [EOL] assertEquals(2, result.intValue()); [EOL] }
public void testPathWithNegativeIndex() { [EOL] ArrayNode arrayNode = JsonNodeFactory.instance.arrayNode(); [EOL] arrayNode.add(1); [EOL] JsonNode result = arrayNode.path(-1); [EOL] assertTrue(result instanceof MissingNode); [EOL] }
public void testPathWithIndexOutOfBounds() { [EOL] ArrayNode arrayNode = JsonNodeFactory.instance.arrayNode(); [EOL] arrayNode.add(1); [EOL] JsonNode result = arrayNode.path(2); [EOL] assertTrue(result instanceof MissingNode); [EOL] }
public void testAddNull() { [EOL] ArrayNode arrayNode = JsonNodeFactory.instance.arrayNode(); [EOL] ArrayNode result = arrayNode.addNull(); [EOL] assertNotNull(result); [EOL] assertTrue(result.isNull(0)); [EOL] }
public void testInsertNullAtStart() { [EOL] ArrayNode arrayNode = JsonNodeFactory.instance.arrayNode(); [EOL] arrayNode.add(1); [EOL] arrayNode.add(2); [EOL] ArrayNode result = arrayNode.insertNull(0); [EOL] assertNotNull(result); [EOL] assertTrue(result.get(0).isNull()); [EOL] assertEquals(3, result.size()); [EOL] }
public void testInsertNullInMiddle() { [EOL] ArrayNode arrayNode = JsonNodeFactory.instance.arrayNode(); [EOL] arrayNode.add(1); [EOL] arrayNode.add(2); [EOL] ArrayNode result = arrayNode.insertNull(1); [EOL] assertNotNull(result); [EOL] assertTrue(result.get(1).isNull()); [EOL] assertEquals(3, result.size()); [EOL] }
public void testInsertNullAtEnd() { [EOL] ArrayNode arrayNode = JsonNodeFactory.instance.arrayNode(); [EOL] arrayNode.add(1); [EOL] arrayNode.add(2); [EOL] ArrayNode result = arrayNode.insertNull(2); [EOL] assertNotNull(result); [EOL] assertTrue(result.get(2).isNull()); [EOL] assertEquals(3, result.size()); [EOL] }
public void testDeserializerCacheConstructor() { [EOL] DeserializerCache cache = new DeserializerCache(); [EOL] assertNotNull(cache); [EOL] }
public void testFindValueDeserializerWithCachedDeserializer() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] DeserializerFactory factory = mock(DeserializerFactory.class); [EOL] JavaType propertyType = mock(JavaType.class); [EOL] JsonDeserializer<Object> expectedDeserializer = mock(JsonDeserializer.class); [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] SimpleDeserializers deserializers = new SimpleDeserializers(); [EOL] deserializers.addDeserializer(propertyType.getRawClass(), expectedDeserializer); [EOL] mapper.setDeserializerProvider(new SimpleDeserializersProvider(deserializers)); [EOL] JsonDeserializer<Object> result = mapper.findValueDeserializer(ctxt, factory, propertyType); [EOL] assertSame(expectedDeserializer, result); [EOL] }
public void testFindValueDeserializerWithCreatedDeserializer() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] DeserializerFactory factory = mock(DeserializerFactory.class); [EOL] JavaType propertyType = mock(JavaType.class); [EOL] JsonDeserializer<Object> expectedDeserializer = mock(JsonDeserializer.class); [EOL] when(ctxt.findRootValueDeserializer(propertyType)).thenReturn(expectedDeserializer); [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] JsonDeserializer<Object> result = mapper.findValueDeserializer(ctxt, factory, propertyType); [EOL] assertSame(expectedDeserializer, result); [EOL] }
public void testFindValueDeserializerWithUnknownDeserializer() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] DeserializerFactory factory = mock(DeserializerFactory.class); [EOL] JavaType propertyType = mock(JavaType.class); [EOL] when(ctxt.findRootValueDeserializer(propertyType)).thenReturn(null); [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] JsonDeserializer<Object> result = mapper.findValueDeserializer(ctxt, factory, propertyType); [EOL] assertNull(result); [EOL] }
public void testFindKeyDeserializerWithNullKeyDeserializer() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] DeserializerFactory factory = mock(DeserializerFactory.class); [EOL] JavaType type = mock(JavaType.class); [EOL] when(factory.createKeyDeserializer(ctxt, type)).thenReturn(null); [EOL] KeyDeserializer result = findKeyDeserializer(ctxt, factory, type); [EOL] assertNotNull(result); [EOL] }
public void testFindKeyDeserializerWithNonResolvableDeserializer() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] DeserializerFactory factory = mock(DeserializerFactory.class); [EOL] JavaType type = mock(JavaType.class); [EOL] KeyDeserializer kd = mock(KeyDeserializer.class); [EOL] when(factory.createKeyDeserializer(ctxt, type)).thenReturn(kd); [EOL] KeyDeserializer result = findKeyDeserializer(ctxt, factory, type); [EOL] assertSame(kd, result); [EOL] }
public void testFindKeyDeserializerWithResolvableDeserializer() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] DeserializerFactory factory = mock(DeserializerFactory.class); [EOL] JavaType type = mock(JavaType.class); [EOL] KeyDeserializer kd = mock(KeyDeserializer.class, withSettings().extraInterfaces(ResolvableDeserializer.class)); [EOL] when(factory.createKeyDeserializer(ctxt, type)).thenReturn(kd); [EOL] findKeyDeserializer(ctxt, factory, type); [EOL] verify(((ResolvableDeserializer) kd)).resolve(ctxt); [EOL] }
public void testHasValueDeserializerForWithCachedDeserializer() { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] DeserializerFactory factory = mock(DeserializerFactory.class); [EOL] JavaType type = mock(JavaType.class); [EOL] JsonDeserializer<Object> deser = mock(JsonDeserializer.class); [EOL] MyObjectUnderTest objUnderTest = new MyObjectUnderTest(); [EOL] objUnderTest.cacheDeserializer(type, deser); // Assuming this method caches the deserializer [EOL] boolean result = objUnderTest.hasValueDeserializerFor(ctxt, factory, type); [EOL] assertTrue(result); [EOL] }
public void testHasValueDeserializerForWithoutCachedDeserializerAndCreationSucceeds() { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] DeserializerFactory factory = mock(DeserializerFactory.class); [EOL] JavaType type = mock(JavaType.class); [EOL] MyObjectUnderTest objUnderTest = new MyObjectUnderTest(); [EOL] when(objUnderTest._createAndCacheValueDeserializer(ctxt, factory, type)).thenReturn(mock(JsonDeserializer.class)); [EOL] boolean result = objUnderTest.hasValueDeserializerFor(ctxt, factory, type); [EOL] assertTrue(result); [EOL] }
public void testHasValueDeserializerForWithoutCachedDeserializerAndCreationFails() { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] DeserializerFactory factory = mock(DeserializerFactory.class); [EOL] JavaType type = mock(JavaType.class); [EOL] MyObjectUnderTest objUnderTest = new MyObjectUnderTest(); [EOL] when(objUnderTest._createAndCacheValueDeserializer(ctxt, factory, type)).thenThrow(new Exception()); [EOL] boolean result = objUnderTest.hasValueDeserializerFor(ctxt, factory, type); [EOL] assertFalse(result); [EOL] }
public void testCreateAndCacheValueDeserializerWithCachedDeserializer() { [EOL] DeserializationContext ctxt = ...; // provide actual initialization [EOL] DeserializerFactory factory = ...; // provide actual initialization [EOL] JavaType type = ...; // provide actual initialization [EOL] JsonDeserializer<Object> expectedDeserializer = ...; // provide actual initialization [EOL] when(_findCachedDeserializer(type)).thenReturn(expectedDeserializer); [EOL] JsonDeserializer<Object> actualDeserializer = _createAndCacheValueDeserializer(ctxt, factory, type); [EOL] assertSame(expectedDeserializer, actualDeserializer); [EOL] }
public void testCreateAndCacheValueDeserializerWithIncompleteDeserializers() { [EOL] DeserializationContext ctxt = ...; // provide actual initialization [EOL] DeserializerFactory factory = ...; // provide actual initialization [EOL] JavaType type = ...; // provide actual initialization [EOL] when(_findCachedDeserializer(type)).thenReturn(null); [EOL] when(_incompleteDeserializers.size()).thenReturn(1); [EOL] JsonDeserializer<Object> incompleteDeserializer = ...; // provide actual initialization [EOL] when(_incompleteDeserializers.get(type)).thenReturn(incompleteDeserializer); [EOL] JsonDeserializer<Object> actualDeserializer = _createAndCacheValueDeserializer(ctxt, factory, type); [EOL] assertSame(incompleteDeserializer, actualDeserializer); [EOL] }
public void testCreateAndCacheValueDeserializerWithCreation() { [EOL] DeserializationContext ctxt = ...; // provide actual initialization [EOL] DeserializerFactory factory = ...; // provide actual initialization [EOL] JavaType type = ...; // provide actual initialization [EOL] when(_findCachedDeserializer(type)).thenReturn(null); [EOL] when(_incompleteDeserializers.size()).thenReturn(0); [EOL] JsonDeserializer<Object> newDeserializer = ...; // provide actual initialization [EOL] when(_createAndCache2(ctxt, factory, type)).thenReturn(newDeserializer); [EOL] JsonDeserializer<Object> actualDeserializer = _createAndCacheValueDeserializer(ctxt, factory, type); [EOL] assertSame(newDeserializer, actualDeserializer); [EOL] assertTrue(_incompleteDeserializers.isEmpty()); [EOL] }
public void testCreateAndCache2WithNullDeserializer() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] DeserializerFactory factory = mock(DeserializerFactory.class); [EOL] JavaType type = mock(JavaType.class); [EOL] when(factory.createDeserializer(ctxt, type)).thenReturn(null); [EOL] JsonDeserializer<Object> result = _createAndCache2(ctxt, factory, type); [EOL] assertNull(result); [EOL] }
public void testCreateAndCache2WithIllegalArgumentException() { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] DeserializerFactory factory = mock(DeserializerFactory.class); [EOL] JavaType type = mock(JavaType.class); [EOL] when(factory.createDeserializer(ctxt, type)).thenThrow(new IllegalArgumentException("Illegal argument")); [EOL] try { [EOL] _createAndCache2(ctxt, factory, type); [EOL] fail("Expected JsonMappingException to be thrown"); [EOL] } catch (JsonMappingException e) { [EOL] assertEquals("Illegal argument", e.getMessage()); [EOL] } [EOL] }
public void testCreateAndCache2WithResolvableDeserializer() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] DeserializerFactory factory = mock(DeserializerFactory.class); [EOL] JavaType type = mock(JavaType.class); [EOL] ResolvableDeserializer resolvableDeserializer = mock(ResolvableDeserializer.class); [EOL] when(factory.createDeserializer(ctxt, type)).thenReturn(resolvableDeserializer); [EOL] when(resolvableDeserializer.isCachable()).thenReturn(false); [EOL] JsonDeserializer<Object> result = _createAndCache2(ctxt, factory, type); [EOL] verify(resolvableDeserializer).resolve(ctxt); [EOL] assertSame(resolvableDeserializer, result); [EOL] }
public void testCreateAndCache2WithCachableDeserializer() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] DeserializerFactory factory = mock(DeserializerFactory.class); [EOL] JavaType type = mock(JavaType.class); [EOL] JsonDeserializer<Object> cachableDeserializer = mock(JsonDeserializer.class); [EOL] when(factory.createDeserializer(ctxt, type)).thenReturn(cachableDeserializer); [EOL] when(cachableDeserializer.isCachable()).thenReturn(true); [EOL] JsonDeserializer<Object> result = _createAndCache2(ctxt, factory, type); [EOL] assertSame(cachableDeserializer, result); [EOL] }
public void testCreateDeserializerWithAbstractType() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] DeserializerFactory factory = mock(DeserializerFactory.class); [EOL] JavaType abstractType = mock(JavaType.class); [EOL] when(abstractType.isAbstract()).thenReturn(true); [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] when(ctxt.getConfig()).thenReturn(config); [EOL] when(factory.mapAbstractType(config, abstractType)).thenReturn(abstractType); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] when(config.introspect(abstractType)).thenReturn(beanDesc); [EOL] when(beanDesc.getClassInfo()).thenReturn(mock(AnnotatedClass.class)); [EOL] JsonDeserializer<Object> result = _createDeserializer(ctxt, factory, abstractType); [EOL] assertNotNull(result); [EOL] }
public void testCreateDeserializerWithDeserializerFromAnnotation() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] DeserializerFactory factory = mock(DeserializerFactory.class); [EOL] JavaType type = mock(JavaType.class); [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] when(ctxt.getConfig()).thenReturn(config); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] when(config.introspect(type)).thenReturn(beanDesc); [EOL] AnnotatedClass ac = mock(AnnotatedClass.class); [EOL] when(beanDesc.getClassInfo()).thenReturn(ac); [EOL] JsonDeserializer<Object> expectedDeserializer = mock(JsonDeserializer.class); [EOL] when(findDeserializerFromAnnotation(ctxt, ac)).thenReturn(expectedDeserializer); [EOL] JsonDeserializer<Object> result = _createDeserializer(ctxt, factory, type); [EOL] assertSame(expectedDeserializer, result); [EOL] }
public void testCreateDeserializerWithBuilderBasedDeserializer() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] DeserializerFactory factory = mock(DeserializerFactory.class); [EOL] JavaType type = mock(JavaType.class); [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] when(ctxt.getConfig()).thenReturn(config); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] when(config.introspect(type)).thenReturn(beanDesc); [EOL] when(beanDesc.findPOJOBuilder()).thenReturn(Object.class); [EOL] JsonDeserializer<Object> result = _createDeserializer(ctxt, factory, type); [EOL] assertNotNull(result); [EOL] }
public void testCreateDeserializerWithConversion() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] DeserializerFactory factory = mock(DeserializerFactory.class); [EOL] JavaType type = mock(JavaType.class); [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] when(ctxt.getConfig()).thenReturn(config); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] when(config.introspect(type)).thenReturn(beanDesc); [EOL] Converter<Object, Object> conv = mock(Converter.class); [EOL] when(beanDesc.findDeserializationConverter()).thenReturn(conv); [EOL] TypeFactory typeFactory = mock(TypeFactory.class); [EOL] when(ctxt.getTypeFactory()).thenReturn(typeFactory); [EOL] JavaType delegateType = mock(JavaType.class); [EOL] when(conv.getInputType(typeFactory)).thenReturn(delegateType); [EOL] JsonDeserializer<Object> result = _createDeserializer(ctxt, factory, type); [EOL] assertNotNull(result); [EOL] }
public void testCreateDeserializer2WithEnumType() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] DeserializerFactory factory = mock(DeserializerFactory.class); [EOL] JavaType type = mock(JavaType.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] when(type.isEnumType()).thenReturn(true); [EOL] new TestClass()._createDeserializer2(ctxt, factory, type, beanDesc); [EOL] verify(factory).createEnumDeserializer(ctxt, type, beanDesc); [EOL] }
public void testCreateDeserializer2WithArrayType() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] DeserializerFactory factory = mock(DeserializerFactory.class); [EOL] ArrayType type = mock(ArrayType.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] when(type.isContainerType()).thenReturn(true); [EOL] when(type.isArrayType()).thenReturn(true); [EOL] new TestClass()._createDeserializer2(ctxt, factory, type, beanDesc); [EOL] verify(factory).createArrayDeserializer(ctxt, type, beanDesc); [EOL] }
public void testCreateDeserializer2WithMapType() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] DeserializerFactory factory = mock(DeserializerFactory.class); [EOL] MapType type = mock(MapType.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] when(type.isContainerType()).thenReturn(true); [EOL] when(type.isMapLikeType()).thenReturn(true); [EOL] when(((MapLikeType) type).isTrueMapType()).thenReturn(true); [EOL] new TestClass()._createDeserializer2(ctxt, factory, type, beanDesc); [EOL] verify(factory).createMapDeserializer(ctxt, type, beanDesc); [EOL] }
public void testCreateDeserializer2WithMapLikeType() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] DeserializerFactory factory = mock(DeserializerFactory.class); [EOL] MapLikeType type = mock(MapLikeType.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] when(type.isContainerType()).thenReturn(true); [EOL] when(type.isMapLikeType()).thenReturn(true); [EOL] when(type.isTrueMapType()).thenReturn(false); [EOL] new TestClass()._createDeserializer2(ctxt, factory, type, beanDesc); [EOL] verify(factory).createMapLikeDeserializer(ctxt, type, beanDesc); [EOL] }
public void testCreateDeserializer2WithCollectionType() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] DeserializerFactory factory = mock(DeserializerFactory.class); [EOL] CollectionType type = mock(CollectionType.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] when(type.isContainerType()).thenReturn(true); [EOL] when(type.isCollectionLikeType()).thenReturn(true); [EOL] when(((CollectionLikeType) type).isTrueCollectionType()).thenReturn(true); [EOL] new TestClass()._createDeserializer2(ctxt, factory, type, beanDesc); [EOL] verify(factory).createCollectionDeserializer(ctxt, type, beanDesc); [EOL] }
public void testCreateDeserializer2WithCollectionLikeType() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] DeserializerFactory factory = mock(DeserializerFactory.class); [EOL] CollectionLikeType type = mock(CollectionLikeType.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] JsonFormat.Value format = mock(JsonFormat.Value.class); [EOL] when(type.isContainerType()).thenReturn(true); [EOL] when(type.isCollectionLikeType()).thenReturn(true); [EOL] when(beanDesc.findExpectedFormat(null)).thenReturn(format); [EOL] when(format.getShape()).thenReturn(JsonFormat.Shape.ARRAY); [EOL] when(type.isTrueCollectionType()).thenReturn(false); [EOL] new TestClass()._createDeserializer2(ctxt, factory, type, beanDesc); [EOL] verify(factory).createCollectionLikeDeserializer(ctxt, type, beanDesc); [EOL] }
public void testCreateDeserializer2WithJsonNode() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] DeserializerFactory factory = mock(DeserializerFactory.class); [EOL] JavaType type = mock(JavaType.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] when(ctxt.getConfig()).thenReturn(config); [EOL] when(JsonNode.class.isAssignableFrom(type.getRawClass())).thenReturn(true); [EOL] new TestClass()._createDeserializer2(ctxt, factory, type, beanDesc); [EOL] verify(factory).createTreeDeserializer(config, type, beanDesc); [EOL] }
public void testCreateDeserializer2WithBeanType() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] DeserializerFactory factory = mock(DeserializerFactory.class); [EOL] JavaType type = mock(JavaType.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] when(type.isEnumType()).thenReturn(false); [EOL] when(type.isContainerType()).thenReturn(false); [EOL] when(JsonNode.class.isAssignableFrom(type.getRawClass())).thenReturn(false); [EOL] new TestClass()._createDeserializer2(ctxt, factory, type, beanDesc); [EOL] verify(factory).createBeanDeserializer(ctxt, type, beanDesc); [EOL] }
private JavaType modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, JavaType type) throws JsonMappingException { [EOL] AnnotationIntrospector intr = ctxt.getAnnotationIntrospector(); [EOL] Class<?> subclass = intr.findDeserializationType(a, type); [EOL] if (subclass != null) { [EOL] try { [EOL] type = type.narrowBy(subclass); [EOL] } catch (IllegalArgumentException iae) { [EOL] throw new JsonMappingException("Failed to narrow type " + type + " with concrete-type annotation (value " + subclass.getName() + "), method '" + a.getName() + "': " + iae.getMessage(), null, iae); [EOL] } [EOL] } [EOL] if (type.isContainerType()) { [EOL] Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType()); [EOL] if (keyClass != null) { [EOL] if (!(type instanceof MapLikeType)) { [EOL] throw new JsonMappingException("Illegal key-type annotation: type " + type + " is not a Map(-like) type"); [EOL] } [EOL] try { [EOL] type = ((MapLikeType) type).narrowKey(keyClass); [EOL] } catch (IllegalArgumentException iae) { [EOL] throw new JsonMappingException("Failed to narrow key type " + type + " with key-type annotation (" + keyClass.getName() + "): " + iae.getMessage(), null, iae); [EOL] } [EOL] } [EOL] JavaType keyType = type.getKeyType(); [EOL] if (keyType != null && keyType.getValueHandler() == null) { [EOL] Object kdDef = intr.findKeyDeserializer(a); [EOL] if (kdDef != null) { [EOL] KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef); [EOL] if (kd != null) { [EOL] type = ((MapLikeType) type).withKeyValueHandler(kd); [EOL] keyType = type.getKeyType(); [EOL] } [EOL] } [EOL] } [EOL] Class<?> cc = intr.findDeserializationContentType(a, type.getContentType()); [EOL] if (cc != null) { [EOL] try { [EOL] type = type.narrowContentsBy(cc); [EOL] } catch (IllegalArgumentException iae) { [EOL] throw new JsonMappingException("Failed to narrow content type " + type + " with content-type annotation (" + cc.getName() + "): " + iae.getMessage(), null, iae); [EOL] } [EOL] } [EOL] JavaType contentType = type.getContentType(); [EOL] if (contentType.getValueHandler() == null) { [EOL] Object cdDef = intr.findContentDeserializer(a); [EOL] if (cdDef != null) { [EOL] JsonDeserializer<?> cd = null; [EOL] if (cdDef instanceof JsonDeserializer<?>) { [EOL] cdDef = (JsonDeserializer<?>) cdDef; [EOL] } else { [EOL] Class<?> cdClass = _verifyAsClass(cdDef, "findContentDeserializer", JsonDeserializer.None.class); [EOL] if (cdClass != null) { [EOL] cd = ctxt.deserializerInstance(a, cdClass); [EOL] } [EOL] } [EOL] if (cd != null) { [EOL] type = type.withContentValueHandler(cd); [EOL] } [EOL] } [EOL] } [EOL] } [EOL] return type; [EOL] }
public void testPropertyBasedObjectIdGeneratorWithNullOid() { [EOL] ObjectIdInfo oid = null; [EOL] BeanPropertyWriter prop = new BeanPropertyWriter(); [EOL] try { [EOL] new PropertyBasedObjectIdGenerator(oid, prop); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testPropertyBasedObjectIdGeneratorWithNonNullOid() { [EOL] ObjectIdInfo oid = new ObjectIdInfo("id", String.class, null); [EOL] BeanPropertyWriter prop = new BeanPropertyWriter(); [EOL] PropertyBasedObjectIdGenerator generator = new PropertyBasedObjectIdGenerator(oid, prop); [EOL] assertNotNull(generator); [EOL] }
public void testPropertyBasedObjectIdGeneratorWithNonNullScopeAndProperty() { [EOL] Class<?> scope = Object.class; [EOL] BeanPropertyWriter prop = new BeanPropertyWriter(); [EOL] PropertyBasedObjectIdGenerator generator = new PropertyBasedObjectIdGenerator(scope, prop); [EOL] assertNotNull(generator); [EOL] assertEquals(scope, generator.getScope()); [EOL] assertEquals(prop, generator.getProperty()); [EOL] }
public void testPropertyBasedObjectIdGeneratorWithNullScope() { [EOL] Class<?> scope = null; [EOL] BeanPropertyWriter prop = new BeanPropertyWriter(); [EOL] try { [EOL] PropertyBasedObjectIdGenerator generator = new PropertyBasedObjectIdGenerator(scope, prop); [EOL] fail("Expected IllegalArgumentException for null scope"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testPropertyBasedObjectIdGeneratorWithNullProperty() { [EOL] Class<?> scope = Object.class; [EOL] BeanPropertyWriter prop = null; [EOL] try { [EOL] PropertyBasedObjectIdGenerator generator = new PropertyBasedObjectIdGenerator(scope, prop); [EOL] fail("Expected IllegalArgumentException for null property"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testCanUseFor_SameClassSameScopeSameProperty() { [EOL] PropertyBasedObjectIdGenerator gen1 = new PropertyBasedObjectIdGenerator(SomeScope.class, someProperty); [EOL] PropertyBasedObjectIdGenerator gen2 = new PropertyBasedObjectIdGenerator(SomeScope.class, someProperty); [EOL] boolean result = gen1.canUseFor(gen2); [EOL] assertTrue(result); [EOL] }
public void testCanUseFor_SameClassSameScopeDifferentProperty() { [EOL] PropertyBasedObjectIdGenerator gen1 = new PropertyBasedObjectIdGenerator(SomeScope.class, someProperty); [EOL] PropertyBasedObjectIdGenerator gen2 = new PropertyBasedObjectIdGenerator(SomeScope.class, differentProperty); [EOL] boolean result = gen1.canUseFor(gen2); [EOL] assertFalse(result); [EOL] }
public void testCanUseFor_SameClassDifferentScope() { [EOL] PropertyBasedObjectIdGenerator gen1 = new PropertyBasedObjectIdGenerator(SomeScope.class, someProperty); [EOL] PropertyBasedObjectIdGenerator gen2 = new PropertyBasedObjectIdGenerator(DifferentScope.class, someProperty); [EOL] boolean result = gen1.canUseFor(gen2); [EOL] assertFalse(result); [EOL] }
public void testCanUseFor_DifferentClass() { [EOL] PropertyBasedObjectIdGenerator gen1 = new PropertyBasedObjectIdGenerator(SomeScope.class, someProperty); [EOL] ObjectIdGenerator<?> gen2 = new DifferentClassObjectIdGenerator(); [EOL] boolean result = gen1.canUseFor(gen2); [EOL] assertFalse(result); [EOL] }
public void testGenerateIdWithValidPojo() { [EOL] Pojo pojo = new Pojo(); [EOL] Object id = generateId(pojo); [EOL] assertNotNull(id); [EOL] assertEquals(pojo.getExpectedId(), id); [EOL] }
public void testGenerateIdWithRuntimeException() { [EOL] Pojo pojo = new Pojo(); [EOL] try { [EOL] generateId(pojo); [EOL] fail("Expected a RuntimeException to be thrown"); [EOL] } catch (RuntimeException e) { [EOL] } [EOL] }
public void testGenerateIdWithException() { [EOL] Pojo pojo = new Pojo(); [EOL] try { [EOL] generateId(pojo); [EOL] fail("Expected an IllegalStateException to be thrown"); [EOL] } catch (IllegalStateException e) { [EOL] assertTrue(e.getMessage().contains(_property.getName())); [EOL] } [EOL] }
public void testNewForSerialization() { [EOL] ObjectIdGenerator<Object> generator = new ObjectIdGeneratorImpl(); [EOL] ObjectIdGenerator<Object> newGenerator = generator.newForSerialization(null); [EOL] assertSame(generator, newGenerator); [EOL] }
public void testCompleteAndClearBufferWithEmptyBufferAndEmptyLastChunk() { [EOL] Object[] lastChunk = new Object[0]; [EOL] int lastChunkEntries = 0; [EOL] List<Object> resultList = new ArrayList<>(); [EOL] completeAndClearBuffer(lastChunk, lastChunkEntries, resultList); [EOL] assertTrue(resultList.isEmpty()); [EOL] }
public void testCompleteAndClearBufferWithNonEmptyBufferAndEmptyLastChunk() { [EOL] Object[] lastChunk = new Object[0]; [EOL] int lastChunkEntries = 0; [EOL] List<Object> resultList = new ArrayList<>(); [EOL] _bufferHead = new Node(new Object[] {"a", "b", "c"}, null); [EOL] completeAndClearBuffer(lastChunk, lastChunkEntries, resultList); [EOL] assertEquals(Arrays.asList("a", "b", "c"), resultList); [EOL] }
public void testCompleteAndClearBufferWithEmptyBufferAndNonEmptyLastChunk() { [EOL] Object[] lastChunk = new Object[] {"x", "y", "z"}; [EOL] int lastChunkEntries = 3; [EOL] List<Object> resultList = new ArrayList<>(); [EOL] completeAndClearBuffer(lastChunk, lastChunkEntries, resultList); [EOL] assertEquals(Arrays.asList("x", "y", "z"), resultList); [EOL] }
public void testCompleteAndClearBufferWithNonEmptyBufferAndNonEmptyLastChunk() { [EOL] Object[] lastChunk = new Object[] {"x", "y", "z"}; [EOL] int lastChunkEntries = 3; [EOL] List<Object> resultList = new ArrayList<>(); [EOL] _bufferHead = new Node(new Object[] {"a", "b", "c"}, null); [EOL] completeAndClearBuffer(lastChunk, lastChunkEntries, resultList); [EOL] assertEquals(Arrays.asList("a", "b", "c", "x", "y", "z"), resultList); [EOL] }
public void testUntypedObjectDeserializerConstructor() { [EOL] UntypedObjectDeserializer deserializer = new UntypedObjectDeserializer(); [EOL] assertNotNull(deserializer); [EOL] }
public void testDeserializeWithStartObjectToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); [EOL] Object result = deserialize(jp, ctxt); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeWithStartArrayToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_ARRAY); [EOL] Object result = deserialize(jp, ctxt); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeWithFieldNameToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.FIELD_NAME); [EOL] Object result = deserialize(jp, ctxt); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeWithValueEmbeddedObjectToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_EMBEDDED_OBJECT); [EOL] Object embeddedObject = new Object(); [EOL] when(jp.getEmbeddedObject()).thenReturn(embeddedObject); [EOL] Object result = deserialize(jp, null); [EOL] assertSame(embeddedObject, result); [EOL] }
public void testDeserializeWithValueStringToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] String text = "test"; [EOL] when(jp.getText()).thenReturn(text); [EOL] Object result = deserialize(jp, null); [EOL] assertEquals(text, result); [EOL] }
public void testDeserializeWithValueNumberIntTokenUseBigInteger() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); [EOL] when(ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)).thenReturn(true); [EOL] BigInteger bigInteger = new BigInteger("12345"); [EOL] when(jp.getBigIntegerValue()).thenReturn(bigInteger); [EOL] Object result = deserialize(jp, ctxt); [EOL] assertEquals(bigInteger, result); [EOL] }
public void testDeserializeWithValueNumberIntTokenDefault() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); [EOL] when(ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)).thenReturn(false); [EOL] Number number = 12345; [EOL] when(jp.getNumberValue()).thenReturn(number); [EOL] Object result = deserialize(jp, ctxt); [EOL] assertEquals(number, result); [EOL] }
public void testDeserializeWithValueNumberFloatTokenUseBigDecimal() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_FLOAT); [EOL] when(ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)).thenReturn(true); [EOL] BigDecimal bigDecimal = new BigDecimal("123.45"); [EOL] when(jp.getDecimalValue()).thenReturn(bigDecimal); [EOL] Object result = deserialize(jp, ctxt); [EOL] assertEquals(bigDecimal, result); [EOL] }
public void testDeserializeWithValueNumberFloatTokenDefault() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_FLOAT); [EOL] when(ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)).thenReturn(false); [EOL] double value = 123.45; [EOL] when(jp.getDoubleValue()).thenReturn(value); [EOL] Object result = deserialize(jp, ctxt); [EOL] assertEquals(Double.valueOf(value), result); [EOL] }
public void testDeserializeWithValueTrueToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_TRUE); [EOL] Object result = deserialize(jp, null); [EOL] assertEquals(Boolean.TRUE, result); [EOL] }
public void testDeserializeWithValueFalseToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_FALSE); [EOL] Object result = deserialize(jp, null); [EOL] assertEquals(Boolean.FALSE, result); [EOL] }
public void testDeserializeWithValueNullToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NULL); [EOL] Object result = deserialize(jp, null); [EOL] assertNull(result); [EOL] }
public void testDeserializeWithEndArrayToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.END_ARRAY); [EOL] try { [EOL] deserialize(jp, ctxt); [EOL] fail("Expected an exception to be thrown"); [EOL] } catch (JsonMappingException e) { [EOL] } [EOL] }
public void testDeserializeWithEndObjectToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.END_OBJECT); [EOL] try { [EOL] deserialize(jp, ctxt); [EOL] fail("Expected an exception to be thrown"); [EOL] } catch (JsonMappingException e) { [EOL] } [EOL] }
public void testDeserializeWithDefaultCaseToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(null); // A token that does not match any case [EOL] try { [EOL] deserialize(jp, ctxt); [EOL] fail("Expected an exception to be thrown"); [EOL] } catch (JsonMappingException e) { [EOL] } [EOL] }
public void testMapArrayWithJavaArrayFeatureEnabled() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)).thenReturn(true); [EOL] Object result = mapArray(jp, ctxt); [EOL] assertNotNull(result); [EOL] assertTrue(result.getClass().isArray()); [EOL] }
public void testMapArrayWithEmptyArray() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)).thenReturn(false); [EOL] when(jp.nextToken()).thenReturn(JsonToken.END_ARRAY); [EOL] Object result = mapArray(jp, ctxt); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof ArrayList); [EOL] assertTrue(((ArrayList) result).isEmpty()); [EOL] }
public void testMapArrayWithNonEmptyArray() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] ObjectBuffer buffer = new ObjectBuffer(); [EOL] when(ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)).thenReturn(false); [EOL] when(jp.nextToken()).thenReturn(JsonToken.VALUE_STRING).thenReturn(JsonToken.END_ARRAY); [EOL] when(ctxt.leaseObjectBuffer()).thenReturn(buffer); [EOL] when(deserialize(jp, ctxt)).thenReturn("testValue"); [EOL] Object result = mapArray(jp, ctxt); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof ArrayList); [EOL] assertFalse(((ArrayList) result).isEmpty()); [EOL] assertEquals("testValue", ((ArrayList) result).get(0)); [EOL] }
protected BeanDescription(JavaType type) { [EOL] _type = type; [EOL] }
public void testGetType() { [EOL] MyClass instance = new MyClass(); [EOL] JavaType expectedType = new JavaType(); // Replace with actual type initialization [EOL] instance.setType(expectedType); // Replace with actual method to set the type [EOL] JavaType result = instance.getType(); [EOL] assertEquals(expectedType, result); [EOL] }
public void testGetBeanClass() { [EOL] YourClass instance = setupYourClassWithValidType(); [EOL] Class<?> result = instance.getBeanClass(); [EOL] assertNotNull(result); [EOL] assertEquals(SomeBean.class, result); [EOL] }
public void testFindWithUnlistedClassName() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(Calendar.class, "UnlistedClassName"); [EOL] assertNull(deserializer); [EOL] }
public void testFindWithCalendarClass() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(Calendar.class, "java.util.Calendar"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof CalendarDeserializer); [EOL] }
public void testFindWithUtilDateClass() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(java.util.Date.class, "java.util.Date"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof DateDeserializer); [EOL] }
public void testFindWithSqlDateClass() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(java.sql.Date.class, "java.sql.Date"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof SqlDateDeserializer); [EOL] }
public void testFindWithTimestampClass() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(Timestamp.class, "java.sql.Timestamp"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof TimestampDeserializer); [EOL] }
public void testFindWithTimeZoneClass() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(TimeZone.class, "java.util.TimeZone"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof TimeZoneDeserializer); [EOL] }
public void testFindWithGregorianCalendarClass() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(GregorianCalendar.class, "java.util.GregorianCalendar"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof CalendarDeserializer); [EOL] }
public void testFindWithInvalidClass() { [EOL] try { [EOL] YourClass.find(String.class, "java.lang.String"); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testCreateContextualWithPropertyAndFormatWithPattern() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] AnnotatedMember member = mock(AnnotatedMember.class); [EOL] when(property.getMember()).thenReturn(member); [EOL] AnnotationIntrospector ai = mock(AnnotationIntrospector.class); [EOL] when(ctxt.getAnnotationIntrospector()).thenReturn(ai); [EOL] JsonFormat.Value format = mock(JsonFormat.Value.class); [EOL] when(ai.findFormat(member)).thenReturn(format); [EOL] when(format.getPattern()).thenReturn("yyyy-MM-dd"); [EOL] when(format.getTimeZone()).thenReturn(TimeZone.getTimeZone("GMT")); [EOL] when(format.getLocale()).thenReturn(Locale.ENGLISH); [EOL] JsonDeserializer<?> result = createContextual(ctxt, property); [EOL] assertNotNull(result); [EOL] assertNotSame(this, result); [EOL] }
public void testCreateContextualWithPropertyAndFormatWithoutPattern() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] AnnotatedMember member = mock(AnnotatedMember.class); [EOL] when(property.getMember()).thenReturn(member); [EOL] AnnotationIntrospector ai = mock(AnnotationIntrospector.class); [EOL] when(ctxt.getAnnotationIntrospector()).thenReturn(ai); [EOL] JsonFormat.Value format = mock(JsonFormat.Value.class); [EOL] when(ai.findFormat(member)).thenReturn(format); [EOL] when(format.getPattern()).thenReturn(""); [EOL] when(format.getTimeZone()).thenReturn(TimeZone.getTimeZone("GMT")); [EOL] JsonDeserializer<?> result = createContextual(ctxt, property); [EOL] assertSame(this, result); [EOL] }
public void testCreateContextualWithPropertyAndFormatWithTimeZone() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] AnnotatedMember member = mock(AnnotatedMember.class); [EOL] when(property.getMember()).thenReturn(member); [EOL] AnnotationIntrospector ai = mock(AnnotationIntrospector.class); [EOL] when(ctxt.getAnnotationIntrospector()).thenReturn(ai); [EOL] JsonFormat.Value format = mock(JsonFormat.Value.class); [EOL] when(ai.findFormat(member)).thenReturn(format); [EOL] when(format.getPattern()).thenReturn(""); [EOL] when(format.getTimeZone()).thenReturn(null); [EOL] DateFormat df = mock(DateFormat.class); [EOL] when(ctxt.getConfig().getDateFormat()).thenReturn(df); [EOL] when(df.getClass()).thenReturn(StdDateFormat.class); [EOL] StdDateFormat stdDf = mock(StdDateFormat.class); [EOL] when(((StdDateFormat) df).withTimeZone(any(TimeZone.class))).thenReturn(stdDf); [EOL] JsonDeserializer<?> result = createContextual(ctxt, property); [EOL] assertNotNull(result); [EOL] assertNotSame(this, result); [EOL] }
public void testCreateContextualWithoutProperty() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JsonDeserializer<?> result = createContextual(ctxt, null); [EOL] assertSame(this, result); [EOL] }
public void testCalendarDeserializerCopyConstructor() { [EOL] SimpleDateFormat df = new SimpleDateFormat("yyyy-MM-dd"); [EOL] String formatString = "yyyy-MM-dd"; [EOL] CalendarDeserializer original = new CalendarDeserializer(Calendar.class, df, formatString); [EOL] CalendarDeserializer copy = new CalendarDeserializer(original, df, formatString); [EOL] assertNotNull(copy); [EOL] assertEquals(Calendar.class, copy._calendarClass); [EOL] assertEquals(df, copy._dateFormat); [EOL] assertEquals(formatString, copy._formatString); [EOL] }
public void testWithDateFormat_Null() { [EOL] CalendarDeserializer original = new CalendarDeserializer(); [EOL] CalendarDeserializer result = original.withDateFormat(null, null); [EOL] assertNotNull(result); [EOL] assertNull(result.getDateFormat()); [EOL] assertNull(result.getFormatString()); [EOL] }
public void testWithDateFormat_NonNull() { [EOL] CalendarDeserializer original = new CalendarDeserializer(); [EOL] DateFormat df = new SimpleDateFormat(); [EOL] String formatString = "yyyy-MM-dd"; [EOL] CalendarDeserializer result = original.withDateFormat(df, formatString); [EOL] assertNotNull(result); [EOL] assertEquals(df, result.getDateFormat()); [EOL] assertEquals(formatString, result.getFormatString()); [EOL] }
public void testDateDeserializerConstructor() { [EOL] DateDeserializer deserializer = new DateDeserializer(); [EOL] assertNotNull(deserializer); [EOL] assertEquals(Date.class, deserializer.handledType()); [EOL] }
public void testDeserializeWithValidDate() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] DateDeserializer deserializer = new DateDeserializer(); [EOL] when(jp.getText()).thenReturn("2023-01-01T00:00:00Z"); [EOL] Date result = deserializer.deserialize(jp, ctxt); [EOL] assertNotNull(result); [EOL] assertEquals(result, new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss'Z'").parse("2023-01-01T00:00:00Z")); [EOL] }
public void testDeserializeWithInvalidDate() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] DateDeserializer deserializer = new DateDeserializer(); [EOL] when(jp.getText()).thenReturn("not a date"); [EOL] try { [EOL] deserializer.deserialize(jp, ctxt); [EOL] fail("Expected an exception to be thrown"); [EOL] } catch (JsonProcessingException e) { [EOL] } [EOL] }
public void testGetGenericType() throws Exception { [EOL] Method method = TestClass.class.getMethod("testMethod"); [EOL] MethodWrapper methodWrapper = new MethodWrapper(method); [EOL] Type genericType = methodWrapper.getGenericType(); [EOL] assertEquals(ExpectedType.class, genericType); [EOL] }
public void testGetTypeWithNullBindings() { [EOL] Method method = MyClass.class.getMethod("myMethod", null); // Replace "MyClass" and "myMethod" with actual class and method names [EOL] MyClass instance = new MyClass(method); [EOL] JavaType result = instance.getType(null); [EOL] assertNull(result); [EOL] } [EOL] public void testGetTypeWithEmptyBindings() { [EOL] TypeBindings bindings = new TypeBindings(); // Assuming TypeBindings has a constructor with no parameters [EOL] Method method = MyClass.class.getMethod("myMethod", null); // Replace "MyClass" and "myMethod" with actual class and method names [EOL] MyClass instance = new MyClass(method); [EOL] JavaType result = instance.getType(bindings); [EOL] assertNotNull(result); [EOL] } [EOL] public void testGetTypeWithNonEmptyBindings() { [EOL] TypeBindings bindings = new TypeBindings(); // Assuming TypeBindings can be populated with some data [EOL] Method method = MyClass.class.getMethod("myMethod", null); // Replace "MyClass" and "myMethod" with actual class and method names [EOL] MyClass instance = new MyClass(method); [EOL] JavaType result = instance.getType(bindings); [EOL] assertNotNull(result); [EOL] }
public final Object call() throws Exception { [EOL] return _method.invoke(null); [EOL] }
public void testGetValueWithValidPojo() { [EOL] Object pojo = createValidPojo(); [EOL] MyAccessor accessor = new MyAccessor(validMethod); // validMethod should be a Method object that can be invoked on pojo [EOL] Object result = accessor.getValue(pojo); [EOL] Object expected = getExpectedValue(); [EOL] assertEquals(expected, result); [EOL] }
public void testGetValueWithInaccessibleMethod() { [EOL] Object pojo = createValidPojo(); [EOL] MyAccessor accessor = new MyAccessor(inaccessibleMethod); // inaccessibleMethod should be a Method object that is not accessible [EOL] try { [EOL] accessor.getValue(pojo); [EOL] fail("Expected an IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertTrue(e.getMessage().contains("Failed to getValue() with method")); [EOL] } [EOL] }
public void testGetValueWithMethodThrowingInvocationTargetException() { [EOL] Object pojo = createValidPojo(); [EOL] MyAccessor accessor = new MyAccessor(methodThatThrows); // methodThatThrows should be a Method object that throws InvocationTargetException when invoked [EOL] try { [EOL] accessor.getValue(pojo); [EOL] fail("Expected an IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertTrue(e.getMessage().contains("Failed to getValue() with method")); [EOL] } [EOL] }
public void testGetFullName() { [EOL] Class<?> declaringClassMock = mock(Class.class); [EOL] when(declaringClassMock.getName()).thenReturn("com.example.MyClass"); [EOL] MyMethod myMethod = new MyMethod(declaringClassMock, "myMethod", 2); [EOL] String fullName = myMethod.getFullName(); [EOL] assertEquals("com.example.MyClass#myMethod(2 params)", fullName); [EOL] }
public void testToString() { [EOL] YourClass instance = new YourClass(); [EOL] instance.setFullName("SampleMethod"); [EOL] String expected = "[method SampleMethod]"; [EOL] String actual = instance.toString(); [EOL] assertEquals(expected, actual); [EOL] }
public void testTypeSerializerBaseConstructorWithNonNullArgs() { [EOL] TypeIdResolver idRes = mock(TypeIdResolver.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] TypeSerializerBase serializerBase = new TypeSerializerBase(idRes, property); [EOL] assertNotNull(serializerBase); [EOL] assertEquals(idRes, serializerBase.getIdResolver()); [EOL] assertEquals(property, serializerBase.getProperty()); [EOL] }
public void testIdFromValueWithNonNullValue() { [EOL] ObjectIdGenerator.IdKey idKey = new ObjectIdGenerator.IdKey(getClass(), getClass(), "testValue"); [EOL] ObjectIdResolver resolver = new SimpleObjectIdResolver(); [EOL] resolver.bindItem(idKey, "testId"); [EOL] CustomIdResolver customIdResolver = new CustomIdResolver(resolver); [EOL] String id = customIdResolver.idFromValue("testValue"); [EOL] assertEquals("testId", id); [EOL] }
public void testIdFromValueWithNullValue() { [EOL] CustomIdResolver customIdResolver = new CustomIdResolver(new SimpleObjectIdResolver()); [EOL] String id = customIdResolver.idFromValue(null); [EOL] assertNull(id); [EOL] }
public void testGetEmbeddedObjectWhenClosed() { [EOL] yourObjectUnderTest.setClosed(true); // Assuming there's a method to set the _closed field [EOL] Object result = yourObjectUnderTest.getEmbeddedObject(); [EOL] assertNull(result); [EOL] }
public void testGetEmbeddedObjectWithPojoNode() { [EOL] POJONode pojoNode = new POJONode(new Object()); [EOL] yourObjectUnderTest.setCurrentNode(pojoNode); // Assuming there's a method to set the current node [EOL] Object result = yourObjectUnderTest.getEmbeddedObject(); [EOL] assertSame(pojoNode.getPojo(), result); [EOL] }
public void testGetEmbeddedObjectWithBinaryNode() { [EOL] byte[] data = new byte[] {1, 2, 3}; [EOL] BinaryNode binaryNode = new BinaryNode(data); [EOL] yourObjectUnderTest.setCurrentNode(binaryNode); // Assuming there's a method to set the current node [EOL] Object result = yourObjectUnderTest.getEmbeddedObject(); [EOL] assertArrayEquals(data, (byte[]) result); [EOL] }
public void testGetEmbeddedObjectWithNonSpecialNode() { [EOL] JsonNode regularNode = JsonNodeFactory.instance.objectNode(); [EOL] yourObjectUnderTest.setCurrentNode(regularNode); // Assuming there's a method to set the current node [EOL] Object result = yourObjectUnderTest.getEmbeddedObject(); [EOL] assertNull(result); [EOL] }
public void testArraySerializerBaseWithNonNullProperty() { [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] ArraySerializerBase serializer = new ArraySerializerBase(String[].class, property); [EOL] assertNotNull(serializer); [EOL] }
public void testArraySerializerBaseWithNullProperty() { [EOL] ArraySerializerBase serializer = new ArraySerializerBase(String[].class, null); [EOL] assertNotNull(serializer); [EOL] }
protected void testArraySerializerBaseWithNullProperty() { [EOL] ArraySerializerBase<?> original = new MockArraySerializerBase<>(String.class); [EOL] ArraySerializerBase<?> cloned = new MockArraySerializerBase<>(original, null); [EOL] assertNull(cloned._property); [EOL] }
protected void testArraySerializerBaseWithNonNullProperty() { [EOL] BeanProperty property = new MockBeanProperty(); [EOL] ArraySerializerBase<?> original = new MockArraySerializerBase<>(String.class); [EOL] ArraySerializerBase<?> cloned = new MockArraySerializerBase<>(original, property); [EOL] assertNotNull(cloned._property); [EOL] assertEquals(property, cloned._property); [EOL] }
public void testSerializeWithSingleElementArrayUnwrapped() throws IOException { [EOL] T value = createSingleElementValue(); // Implement this method to create a single element value [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] when(provider.isEnabled(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED)).thenReturn(true); [EOL] serialize(value, jgen, provider); [EOL] verify(jgen, never()).writeStartArray(); [EOL] verify(jgen, never()).writeEndArray(); [EOL] verify(provider).isEnabled(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED); [EOL] verify(jgen).writeFieldName(anyString()); // Assuming serializeContents writes a field name [EOL] }
public void testSerializeWithNonSingleElementArray() throws IOException { [EOL] T value = createMultipleElementValue(); // Implement this method to create a multiple element value [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] when(provider.isEnabled(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED)).thenReturn(false); [EOL] serialize(value, jgen, provider); [EOL] verify(jgen).writeStartArray(); [EOL] verify(jgen).writeEndArray(); [EOL] verify(provider).isEnabled(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED); [EOL] verify(jgen, atLeastOnce()).writeFieldName(anyString()); // Assuming serializeContents writes field names [EOL] }
public void testSerializeWithSingleElementArrayWrapped() throws IOException { [EOL] T value = createSingleElementValue(); // Implement this method to create a single element value [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] when(provider.isEnabled(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED)).thenReturn(false); [EOL] serialize(value, jgen, provider); [EOL] verify(jgen).writeStartArray(); [EOL] verify(jgen).writeEndArray(); [EOL] verify(provider).isEnabled(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED); [EOL] verify(jgen).writeFieldName(anyString()); // Assuming serializeContents writes a field name [EOL] }
public void testAsToken() { [EOL] JsonNumber jsonNumber = new JsonNumber(); [EOL] JsonToken result = jsonNumber.asToken(); [EOL] assertEquals(JsonToken.VALUE_NUMBER_INT, result); [EOL] }
public void testNumberTypeReturnsLong() { [EOL] JsonParser.NumberType expectedType = JsonParser.NumberType.LONG; [EOL] JsonParser.NumberType actualType = new YourConcreteJsonParser().numberType(); [EOL] assertEquals(expectedType, actualType); [EOL] }
public void testCanConvertToIntWithMinValue() { [EOL] setValue(Integer.MIN_VALUE); [EOL] assertTrue(canConvertToInt()); [EOL] } [EOL] public void testCanConvertToIntWithMaxValue() { [EOL] setValue(Integer.MAX_VALUE); [EOL] assertTrue(canConvertToInt()); [EOL] } [EOL] public void testCanConvertToIntWithLessThanMinValue() { [EOL] setValue((long) Integer.MIN_VALUE - 1); [EOL] assertFalse(canConvertToInt()); [EOL] } [EOL] public void testCanConvertToIntWithMoreThanMaxValue() { [EOL] setValue((long) Integer.MAX_VALUE + 1); [EOL] assertFalse(canConvertToInt()); [EOL] } [EOL] public void testCanConvertToIntWithWithinRangeValue() { [EOL] setValue(0); // 0 is within the range of int values [EOL] assertTrue(canConvertToInt()); [EOL] }
public void testCanConvertToLong() { [EOL] YourClassUnderTest instance = new YourClassUnderTest(); [EOL] boolean result = instance.canConvertToLong(); [EOL] assertTrue(result); [EOL] }
public void testDecimalValue_Positive() { [EOL] JsonNode node = new LongNode(12345L); [EOL] BigDecimal result = node.decimalValue(); [EOL] assertEquals(new BigDecimal("12345"), result); [EOL] }
public void testDecimalValue_Negative() { [EOL] JsonNode node = new LongNode(-12345L); [EOL] BigDecimal result = node.decimalValue(); [EOL] assertEquals(new BigDecimal("-12345"), result); [EOL] }
public void testDecimalValue_Zero() { [EOL] JsonNode node = new LongNode(0L); [EOL] BigDecimal result = node.decimalValue(); [EOL] assertEquals(BigDecimal.ZERO, result); [EOL] }
public void testBigIntegerValue_Positive() { [EOL] long input = 123L; [EOL] LongNode node = new LongNode(input); [EOL] BigInteger result = node.bigIntegerValue(); [EOL] assertEquals(BigInteger.valueOf(input), result); [EOL] }
public void testBigIntegerValue_Negative() { [EOL] long input = -123L; [EOL] LongNode node = new LongNode(input); [EOL] BigInteger result = node.bigIntegerValue(); [EOL] assertEquals(BigInteger.valueOf(input), result); [EOL] }
public void testBigIntegerValue_Zero() { [EOL] long input = 0L; [EOL] LongNode node = new LongNode(input); [EOL] BigInteger result = node.bigIntegerValue(); [EOL] assertEquals(BigInteger.valueOf(input), result); [EOL] }
public void testAsBooleanTrue() { [EOL] IntNode node = new IntNode(1); [EOL] assertTrue(node.asBoolean(false)); [EOL] }
public void testAsBooleanFalse() { [EOL] IntNode node = new IntNode(0); [EOL] assertFalse(node.asBoolean(true)); [EOL] }
public void testEquals_sameObject() { [EOL] LongNode node = new LongNode(5); [EOL] assertTrue(node.equals(node)); [EOL] } [EOL] public void testEquals_nullObject() { [EOL] LongNode node = new LongNode(5); [EOL] assertFalse(node.equals(null)); [EOL] } [EOL] public void testEquals_differentClass() { [EOL] LongNode node = new LongNode(5); [EOL] Object other = new Object(); [EOL] assertFalse(node.equals(other)); [EOL] } [EOL] public void testEquals_differentValue() { [EOL] LongNode node1 = new LongNode(5); [EOL] LongNode node2 = new LongNode(10); [EOL] assertFalse(node1.equals(node2)); [EOL] } [EOL] public void testEquals_sameValue() { [EOL] LongNode node1 = new LongNode(5); [EOL] LongNode node2 = new LongNode(5); [EOL] assertTrue(node1.equals(node2)); [EOL] }
public void testHashCode_PositiveValue() { [EOL] long initialValue = 123456789L; [EOL] LongNode node = new LongNode(initialValue); [EOL] int expectedHashCode = ((int) initialValue) ^ (int) (initialValue >> 32); [EOL] assertEquals(expectedHashCode, node.hashCode()); [EOL] }
public void testHashCode_NegativeValue() { [EOL] long initialValue = -123456789L; [EOL] LongNode node = new LongNode(initialValue); [EOL] int expectedHashCode = ((int) initialValue) ^ (int) (initialValue >> 32); [EOL] assertEquals(expectedHashCode, node.hashCode()); [EOL] }
public void testHashCode_ZeroValue() { [EOL] long initialValue = 0L; [EOL] LongNode node = new LongNode(initialValue); [EOL] int expectedHashCode = ((int) initialValue) ^ (int) (initialValue >> 32); [EOL] assertEquals(expectedHashCode, node.hashCode()); [EOL] }
public void testBeanSerializerBuilderWithNonNullBeanDescription() { [EOL] BeanDescription beanDesc = mock(BeanDescription.class); // Assuming mockito is used [EOL] BeanSerializerBuilder builder = new BeanSerializerBuilder(beanDesc); [EOL] assertNotNull(builder); [EOL] }
public void testBeanSerializerBuilderWithNullBeanDescription() { [EOL] BeanSerializerBuilder builder = new BeanSerializerBuilder(null); [EOL] assertNotNull(builder); [EOL] }
protected void setConfig(SerializationConfig config) { [EOL] _config = config; [EOL] }
public void testSetPropertiesWithNonNullList() { [EOL] BeanSerializerBase beanSerializerBase = new BeanSerializerBase() {}; [EOL] List<BeanPropertyWriter> properties = new ArrayList<>(); [EOL] properties.add(mock(BeanPropertyWriter.class)); [EOL] beanSerializerBase.setProperties(properties); [EOL] assertEquals(properties, beanSerializerBase._properties); [EOL] }
public void testSetPropertiesWithNull() { [EOL] BeanSerializerBase beanSerializerBase = new BeanSerializerBase() {}; [EOL] beanSerializerBase.setProperties(null); [EOL] assertNull(beanSerializerBase._properties); [EOL] }
public void testSetFilteredPropertiesWithNonNull() { [EOL] BeanSerializerBase beanSerializerBase = new BeanSerializerBase() {}; [EOL] BeanPropertyWriter[] properties = new BeanPropertyWriter[2]; [EOL] properties[0] = mock(BeanPropertyWriter.class); [EOL] properties[1] = mock(BeanPropertyWriter.class); [EOL] beanSerializerBase.setFilteredProperties(properties); [EOL] assertArrayEquals(properties, beanSerializerBase._filteredProperties); [EOL] }
public void testSetFilteredPropertiesWithNull() { [EOL] BeanSerializerBase beanSerializerBase = new BeanSerializerBase() {}; [EOL] beanSerializerBase.setFilteredProperties(null); [EOL] assertNull(beanSerializerBase._filteredProperties); [EOL] }
public void testSetAnyGetterWithNonNull() { [EOL] SomeClass instance = new SomeClass(); [EOL] AnyGetterWriter expectedAnyGetter = new AnyGetterWriter(); [EOL] instance.setAnyGetter(expectedAnyGetter); [EOL] assertEquals(expectedAnyGetter, instance.getAnyGetter()); [EOL] }
public void testSetAnyGetterWithNull() { [EOL] SomeClass instance = new SomeClass(); [EOL] instance.setAnyGetter(null); [EOL] assertNull(instance.getAnyGetter()); [EOL] }
public void testSetFilterIdWithNull() { [EOL] YourClass instance = new YourClass(); [EOL] instance.setFilterId(null); [EOL] assertNull(instance.getFilterId()); [EOL] }
public void testSetFilterIdWithObject() { [EOL] YourClass instance = new YourClass(); [EOL] Object filterId = new Object(); [EOL] instance.setFilterId(filterId); [EOL] assertSame(filterId, instance.getFilterId()); [EOL] }
public void testSetObjectIdWriter_Null() { [EOL] JsonSerializer<Object> serializer = mock(JsonSerializer.class); [EOL] ObjectIdGenerator<?> idGenerator = mock(ObjectIdGenerator.class); [EOL] ObjectIdWriter objectIdWriter = new ObjectIdWriter(null, null, idGenerator, serializer, false); [EOL] BeanSerializerBase instance = new BeanSerializerBase() {}; [EOL] instance.setObjectIdWriter(null); [EOL] assertNull(instance._objectIdWriter); [EOL] }
public void testSetObjectIdWriter_NonNull() { [EOL] JsonSerializer<Object> serializer = mock(JsonSerializer.class); [EOL] ObjectIdGenerator<?> idGenerator = mock(ObjectIdGenerator.class); [EOL] ObjectIdWriter objectIdWriter = new ObjectIdWriter(null, null, idGenerator, serializer, false); [EOL] BeanSerializerBase instance = new BeanSerializerBase() {}; [EOL] instance.setObjectIdWriter(objectIdWriter); [EOL] assertEquals(objectIdWriter, instance._objectIdWriter); [EOL] }
public void testGetBeanDescription() { [EOL] BeanDescription expected = instance._beanDesc; [EOL] BeanDescription actual = instance.getBeanDescription(); [EOL] assertSame("BeanDescription should be the same as the one set in instance", expected, actual); [EOL] }
public void testGetProperties() { [EOL] BeanSerializerBase beanSerializerBase = new BeanSerializerBase() { [EOL] }; [EOL] List<BeanPropertyWriter> properties = beanSerializerBase.getProperties(); [EOL] assertNotNull(properties); [EOL] }
public void testGetAnyGetterWhenAnyGetterIsNull() { [EOL] BeanPropertyWriter bpw = new BeanPropertyWriter(); // Assuming a constructor or a setup method exists [EOL] AnyGetterWriter result = bpw.getAnyGetter(); [EOL] assertNull(result); [EOL] }
public void testGetAnyGetterWhenAnyGetterIsNotNull() { [EOL] AnyGetterWriter expectedAnyGetter = new AnyGetterWriter(); // Assuming a constructor or a setup method exists [EOL] BeanPropertyWriter bpw = new BeanPropertyWriter(); // Assuming a constructor or a setup method exists [EOL] bpw.setAnyGetter(expectedAnyGetter); // Assuming there is a method to set the _anyGetter field [EOL] AnyGetterWriter result = bpw.getAnyGetter(); [EOL] assertSame(expectedAnyGetter, result); [EOL] }
public void testGetFilterIdWhenFilterIdIsNull() { [EOL] FilterHolder filterHolder = new FilterHolder(); // You need to replace FilterHolder with the actual class name [EOL] Object filterId = filterHolder.getFilterId(); [EOL] assertNull(filterId); [EOL] }
public void testGetFilterIdWhenFilterIdIsNotNull() { [EOL] FilterHolder filterHolder = new FilterHolder(); // You need to replace FilterHolder with the actual class name [EOL] Object expectedFilterId = new Object(); [EOL] filterHolder.setFilterId(expectedFilterId); // Assuming there's a setter for _filterId [EOL] Object filterId = filterHolder.getFilterId(); [EOL] assertSame(expectedFilterId, filterId); [EOL] }
public AnnotatedMember getTypeId() { [EOL] return _typeId; [EOL] }
public void testGetObjectIdWriter_WhenObjectIdWriterIsSet_ShouldReturnSameInstance() { [EOL] ObjectIdWriter expectedObjectIdWriter = new ObjectIdWriter(null, null, null); [EOL] BeanPropertyWriter beanPropertyWriter = new BeanPropertyWriter(); [EOL] beanPropertyWriter._objectIdWriter = expectedObjectIdWriter; [EOL] ObjectIdWriter actualObjectIdWriter = beanPropertyWriter.getObjectIdWriter(); [EOL] assertSame(expectedObjectIdWriter, actualObjectIdWriter); [EOL] }
public void testBuildWithNullPropertiesAndNullAnyGetter() { [EOL] BeanSerializerBuilder builder = new BeanSerializerBuilder(null); [EOL] JsonSerializer<?> serializer = builder.build(); [EOL] assertNull(serializer); [EOL] }
public void testBuildWithEmptyPropertiesAndNullAnyGetter() { [EOL] BeanSerializerBuilder builder = new BeanSerializerBuilder(null); [EOL] builder.setProperties(Collections.emptyList()); [EOL] JsonSerializer<?> serializer = builder.build(); [EOL] assertNull(serializer); [EOL] }
public void testBuildWithNonEmptyProperties() { [EOL] BeanSerializerBuilder builder = new BeanSerializerBuilder(null); [EOL] List<BeanPropertyWriter> propertyList = new ArrayList<>(); [EOL] propertyList.add(mock(BeanPropertyWriter.class)); [EOL] builder.setProperties(propertyList); [EOL] JsonSerializer<?> serializer = builder.build(); [EOL] assertNotNull(serializer); [EOL] assertTrue(serializer instanceof BeanSerializer); [EOL] }
public void testLRUMapWithValidArguments() { [EOL] int initialEntries = 10; [EOL] int maxEntries = 20; [EOL] LRUMap lruMap = new LRUMap(initialEntries, maxEntries); [EOL] assertEquals("Max entries should be set to 20", 20, lruMap.getMaxEntries()); [EOL] }
public void testLRUMapWithInitialEntriesLessThanZero() { [EOL] int initialEntries = -1; [EOL] int maxEntries = 20; [EOL] try { [EOL] LRUMap lruMap = new LRUMap(initialEntries, maxEntries); [EOL] fail("Should have thrown IllegalArgumentException for initialEntries < 0"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testLRUMapWithMaxEntriesLessThanZero() { [EOL] int initialEntries = 10; [EOL] int maxEntries = -1; [EOL] try { [EOL] LRUMap lruMap = new LRUMap(initialEntries, maxEntries); [EOL] fail("Should have thrown IllegalArgumentException for maxEntries < 0"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testRemoveEldestEntry_MaxEntriesExceeded() { [EOL] LruMap<Integer, String> lruMap = new LruMap<>(3); [EOL] lruMap.put(1, "one"); [EOL] lruMap.put(2, "two"); [EOL] lruMap.put(3, "three"); [EOL] lruMap.put(4, "four"); // This should trigger the removal of the eldest entry [EOL] boolean result = lruMap.removeEldestEntry(new AbstractMap.SimpleEntry<>(1, "one")); [EOL] assertTrue(result); [EOL] }
public void testRemoveEldestEntry_MaxEntriesNotExceeded() { [EOL] LruMap<Integer, String> lruMap = new LruMap<>(3); [EOL] lruMap.put(1, "one"); [EOL] lruMap.put(2, "two"); [EOL] boolean result = lruMap.removeEldestEntry(new AbstractMap.SimpleEntry<>(1, "one")); [EOL] assertFalse(result); [EOL] }
public void testEnumValuesConstructorWithValidArguments() { [EOL] Class<Enum<?>> enumClass = MyEnum.class; [EOL] Map<Enum<?>, SerializedString> values = new HashMap<>(); [EOL] values.put(MyEnum.VALUE1, new SerializedString("Value1")); [EOL] values.put(MyEnum.VALUE2, new SerializedString("Value2")); [EOL] EnumValues enumValues = new EnumValues(enumClass, values); [EOL] assertNotNull(enumValues); [EOL] assertEquals(MyEnum.class, enumValues.getEnumClass()); [EOL] assertEquals(new SerializedString("Value1"), enumValues.serializedValueFor(MyEnum.VALUE1)); [EOL] assertEquals(new SerializedString("Value2"), enumValues.serializedValueFor(MyEnum.VALUE2)); [EOL] } [EOL] public void testEnumValuesConstructorWithEmptyMap() { [EOL] Class<Enum<?>> enumClass = MyEnum.class; [EOL] Map<Enum<?>, SerializedString> values = new HashMap<>(); [EOL] EnumValues enumValues = new EnumValues(enumClass, values); [EOL] assertNotNull(enumValues); [EOL] assertEquals(MyEnum.class, enumValues.getEnumClass()); [EOL] assertTrue(enumValues.internalMap().isEmpty()); [EOL] } [EOL] public void testEnumValuesConstructorWithNullEnumClass() { [EOL] Map<Enum<?>, SerializedString> values = new HashMap<>(); [EOL] values.put(MyEnum.VALUE1, new SerializedString("Value1")); [EOL] try { [EOL] EnumValues enumValues = new EnumValues(null, values); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] } [EOL] public void testEnumValuesConstructorWithNullValues() { [EOL] Class<Enum<?>> enumClass = MyEnum.class; [EOL] try { [EOL] EnumValues enumValues = new EnumValues(enumClass, null); [EOL] fail("Expected NullPointerException"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testConstructWithNullIntr() { [EOL] Class<Enum<?>> enumClass = MyEnum.class; [EOL] EnumValues result = EnumValues.construct(enumClass, null); [EOL] assertNotNull(result); [EOL] }
public void testConstructWithNonNullIntr() { [EOL] Class<Enum<?>> enumClass = MyEnum.class; [EOL] AnnotationIntrospector intr = new MyAnnotationIntrospector(); [EOL] EnumValues result = EnumValues.construct(enumClass, intr); [EOL] assertNotNull(result); [EOL] }
public void testConstructFromNameWithValidEnum() { [EOL] Class<Enum<?>> enumClass = MyEnum.class; [EOL] AnnotationIntrospector intr = mock(AnnotationIntrospector.class); [EOL] when(intr.findEnumValue(any(Enum.class))).thenReturn("VALUE"); [EOL] EnumValues result = EnumValues.constructFromName(enumClass, intr); [EOL] assertNotNull(result); [EOL] assertEquals(MyEnum.class, result.getEnumClass()); [EOL] for (MyEnum value : MyEnum.values()) { [EOL] SerializedString serializedString = result.serializedValueFor(value); [EOL] assertNotNull(serializedString); [EOL] assertEquals("VALUE", serializedString.getValue()); [EOL] } [EOL] }
public void testConstructFromNameWithNullEnumConstants() { [EOL] Class<Enum<?>> enumClass = EmptyEnum.class; [EOL] AnnotationIntrospector intr = mock(AnnotationIntrospector.class); [EOL] try { [EOL] EnumValues.constructFromName(enumClass, intr); [EOL] fail("IllegalArgumentException expected"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Can not determine enum constants for Class " + enumClass.getName(), e.getMessage()); [EOL] } [EOL] }
public void testSerializedValueForWithExistingKey() { [EOL] EnumMapKeySerializer keySerializer = new EnumMapKeySerializer(null, null); [EOL] Enum<?> key = TestEnum.VALUE1; [EOL] SerializedString expectedSerializedString = new SerializedString("VALUE1"); [EOL] keySerializer._values.put(key, expectedSerializedString); [EOL] SerializedString result = keySerializer.serializedValueFor(key); [EOL] assertEquals(expectedSerializedString, result); [EOL] }
public void testSerializedValueForWithNonExistingKey() { [EOL] EnumMapKeySerializer keySerializer = new EnumMapKeySerializer(null, null); [EOL] Enum<?> key = TestEnum.VALUE2; [EOL] SerializedString result = keySerializer.serializedValueFor(key); [EOL] assertNull(result); [EOL] }
public void testJsonNodeFactoryWithTrue() { [EOL] JsonNodeFactory factory = new JsonNodeFactory(true); [EOL] assertTrue(factory._cfgBigDecimalExact); [EOL] }
public void testJsonNodeFactoryWithFalse() { [EOL] JsonNodeFactory factory = new JsonNodeFactory(false); [EOL] assertFalse(factory._cfgBigDecimalExact); [EOL] }
public void testBinaryNodeWithNonNullData() { [EOL] byte[] data = new byte[]{1, 2, 3}; [EOL] BinaryNode result = binaryNode(data); [EOL] assertNotNull(result); [EOL] assertArrayEquals(data, result.binaryValue()); [EOL] }
public void testBinaryNodeWithEmptyData() { [EOL] byte[] data = new byte[]{}; [EOL] BinaryNode result = binaryNode(data); [EOL] assertNotNull(result); [EOL] assertArrayEquals(data, result.binaryValue()); [EOL] }
public void testBinaryNodeWithNullData() { [EOL] byte[] data = null; [EOL] try { [EOL] BinaryNode result = binaryNode(data); [EOL] fail("Expected an exception to be thrown"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public SerializedString findRootName(JavaType rootType, MapperConfig<?> config) { [EOL] return findRootName(rootType.getRawClass(), config); [EOL] }
public void testFindRootNameWithNullRootNames() { [EOL] Class<?> rootType = Object.class; [EOL] MapperConfig<?> config = mock(MapperConfig.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] AnnotationIntrospector intr = mock(AnnotationIntrospector.class); [EOL] AnnotatedClass ac = mock(AnnotatedClass.class); [EOL] PropertyName pname = mock(PropertyName.class); [EOL] when(config.introspectClassAnnotations(rootType)).thenReturn(beanDesc); [EOL] when(config.getAnnotationIntrospector()).thenReturn(intr); [EOL] when(beanDesc.getClassInfo()).thenReturn(ac); [EOL] when(intr.findRootName(ac)).thenReturn(pname); [EOL] when(pname.hasSimpleName()).thenReturn(false); [EOL] SerializedString result = findRootName(rootType, config); [EOL] assertEquals(rootType.getSimpleName(), result.getValue()); [EOL] }
public void testFindRootNameWithExistingRootName() { [EOL] Class<?> rootType = Object.class; [EOL] MapperConfig<?> config = mock(MapperConfig.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] AnnotationIntrospector intr = mock(AnnotationIntrospector.class); [EOL] AnnotatedClass ac = mock(AnnotatedClass.class); [EOL] PropertyName pname = mock(PropertyName.class); [EOL] SerializedString existingName = new SerializedString("existingName"); [EOL] when(config.introspectClassAnnotations(rootType)).thenReturn(beanDesc); [EOL] when(config.getAnnotationIntrospector()).thenReturn(intr); [EOL] when(beanDesc.getClassInfo()).thenReturn(ac); [EOL] when(intr.findRootName(ac)).thenReturn(pname); [EOL] when(pname.hasSimpleName()).thenReturn(true); [EOL] when(pname.getSimpleName()).thenReturn("existingName"); [EOL] LRUMap<ClassKey, SerializedString> _rootNames = new LRUMap<>(20, 200); [EOL] ClassKey key = new ClassKey(rootType); [EOL] _rootNames.put(key, existingName); [EOL] SerializedString result = findRootName(rootType, config); [EOL] assertSame(existingName, result); [EOL] }
public void testFindRootNameWithNewRootName() { [EOL] Class<?> rootType = Object.class; [EOL] MapperConfig<?> config = mock(MapperConfig.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] AnnotationIntrospector intr = mock(AnnotationIntrospector.class); [EOL] AnnotatedClass ac = mock(AnnotatedClass.class); [EOL] PropertyName pname = new PropertyName("newName"); [EOL] when(config.introspectClassAnnotations(rootType)).thenReturn(beanDesc); [EOL] when(config.getAnnotationIntrospector()).thenReturn(intr); [EOL] when(beanDesc.getClassInfo()).thenReturn(ac); [EOL] when(intr.findRootName(ac)).thenReturn(pname); [EOL] SerializedString result = findRootName(rootType, config); [EOL] assertEquals("newName", result.getValue()); [EOL] }
protected ContainerDeserializerBase(Class<?> selfType) { [EOL] super(selfType); [EOL] }
public void testTypeBindingsWithNonNullClass() { [EOL] TypeFactory typeFactory = TypeFactory.defaultInstance(); [EOL] Class<?> cc = Object.class; [EOL] TypeBindings typeBindings = new TypeBindings(typeFactory, cc); [EOL] assertNotNull(typeBindings); [EOL] }
public void testTypeBindingsWithNullClass() { [EOL] TypeFactory typeFactory = TypeFactory.defaultInstance(); [EOL] Class<?> cc = null; [EOL] try { [EOL] new TypeBindings(typeFactory, cc); [EOL] fail("Expected IllegalArgumentException for null class"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testChildInstanceNotNull() { [EOL] TypeFactory typeFactory = TypeFactory.defaultInstance(); [EOL] Class<?> contextClass = Object.class; [EOL] JavaType contextType = typeFactory.constructType(contextClass); [EOL] TypeBindings typeBindings = new TypeBindings(typeFactory, null, contextClass, contextType); [EOL] TypeBindings childBindings = typeBindings.childInstance(); [EOL] assertNotNull(childBindings); [EOL] }
public void testChildInstanceProperties() { [EOL] TypeFactory typeFactory = TypeFactory.defaultInstance(); [EOL] Class<?> contextClass = Object.class; [EOL] JavaType contextType = typeFactory.constructType(contextClass); [EOL] TypeBindings typeBindings = new TypeBindings(typeFactory, null, contextClass, contextType); [EOL] TypeBindings childBindings = typeBindings.childInstance(); [EOL] assertSame(typeFactory, childBindings.getTypeFactory()); [EOL] assertSame(typeBindings, childBindings.getParentBindings()); [EOL] assertEquals(contextClass, childBindings.getContextClass()); [EOL] assertEquals(contextType, childBindings.getContextType()); [EOL] }
public void testTypeBindingsConstructorWithNullValues() { [EOL] TypeFactory tf = null; [EOL] TypeBindings parent = null; [EOL] Class<?> cc = null; [EOL] JavaType type = null; [EOL] TypeBindings bindings = new TypeBindings(tf, parent, cc, type); [EOL] assertNull(bindings.getTypeFactory()); [EOL] assertNull(bindings.getParentBindings()); [EOL] assertNull(bindings.getContextClass()); [EOL] assertNull(bindings.getContextType()); [EOL] }
public void testTypeBindingsConstructorWithNonNullValues() { [EOL] TypeFactory tf = new TypeFactory(); [EOL] TypeBindings parent = new TypeBindings(tf, null, Object.class, null); [EOL] Class<?> cc = String.class; [EOL] JavaType type = tf.constructType(String.class); [EOL] TypeBindings bindings = new TypeBindings(tf, parent, cc, type); [EOL] assertEquals(tf, bindings.getTypeFactory()); [EOL] assertEquals(parent, bindings.getParentBindings()); [EOL] assertEquals(cc, bindings.getContextClass()); [EOL] assertEquals(type, bindings.getContextType()); [EOL] }
public void testGetBindingCountWithNullBindings() { [EOL] instance.setBindings(null); [EOL] int count = instance.getBindingCount(); [EOL] assertEquals(0, count); // Assuming _resolve() initializes _bindings to an empty collection [EOL] }
public void testGetBindingCountWithNonNullBindings() { [EOL] instance.setBindings(new ArrayList<>()); // Assuming _bindings is a List type [EOL] instance.getBindings().add("Binding1"); [EOL] int count = instance.getBindingCount(); [EOL] assertEquals(1, count); [EOL] }
public void testFindTypeWithNullBindingsAndNoPlaceholdersOrParentBindings() { [EOL] MyTypeResolver resolver = new MyTypeResolver(null, null, null, null, null); [EOL] String name = "T"; [EOL] try { [EOL] resolver.findType(name); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testFindTypeWithNonNullBindings() { [EOL] Map<String, JavaType> bindings = new HashMap<>(); [EOL] JavaType expectedType = new JavaType(); // Assuming JavaType is a valid type for this context [EOL] bindings.put("T", expectedType); [EOL] MyTypeResolver resolver = new MyTypeResolver(bindings, null, null, null, null); [EOL] String name = "T"; [EOL] JavaType actualType = resolver.findType(name); [EOL] assertSame("The type should be found in the bindings", expectedType, actualType); [EOL] }
public void testFindTypeWithPlaceholders() { [EOL] Set<String> placeholders = new HashSet<>(); [EOL] placeholders.add("T"); [EOL] MyTypeResolver resolver = new MyTypeResolver(null, placeholders, null, null, null); [EOL] String name = "T"; [EOL] JavaType actualType = resolver.findType(name); [EOL] assertSame("The type should be UNBOUND when found in placeholders", UNBOUND, actualType); [EOL] }
public void testFindTypeWithParentBindings() { [EOL] MyTypeResolver parentResolver = mock(MyTypeResolver.class); [EOL] JavaType expectedType = new JavaType(); // Assuming JavaType is a valid type for this context [EOL] when(parentResolver.findType("T")).thenReturn(expectedType); [EOL] MyTypeResolver resolver = new MyTypeResolver(null, null, parentResolver, null, null); [EOL] String name = "T"; [EOL] JavaType actualType = resolver.findType(name); [EOL] assertSame("The type should be found in the parent bindings", expectedType, actualType); [EOL] }
public void testFindTypeWithContextClassNotStatic() { [EOL] Class<?> contextClass = mock(Class.class); [EOL] when(contextClass.getEnclosingClass()).thenReturn(Object.class); [EOL] when(contextClass.getModifiers()).thenReturn(0); // 0 implies not static [EOL] MyTypeResolver resolver = new MyTypeResolver(null, null, null, contextClass, null); [EOL] String name = "T"; [EOL] JavaType actualType = resolver.findType(name); [EOL] assertSame("The type should be UNBOUND when context class is not static", UNBOUND, actualType); [EOL] }
public void testFindTypeWithExceptionThrown() { [EOL] MyTypeResolver resolver = new MyTypeResolver(null, null, null, null, null); [EOL] String name = "T"; [EOL] try { [EOL] resolver.findType(name); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertTrue(e.getMessage().contains("Type variable 'T' can not be resolved")); [EOL] } [EOL] }
public void shouldAddBindingToEmptyMap() { [EOL] SimpleTypeBindings bindings = new SimpleTypeBindings(); [EOL] JavaType type = SimpleType.constructUnsafe(String.class); [EOL] bindings.addBinding("testName", type); [EOL] assertEquals(1, bindings.size()); [EOL] assertTrue(bindings.containsKey("testName")); [EOL] assertEquals(type, bindings.get("testName")); [EOL] }
public void shouldAddBindingToExistingMap() { [EOL] SimpleTypeBindings bindings = new SimpleTypeBindings(); [EOL] JavaType firstType = SimpleType.constructUnsafe(String.class); [EOL] JavaType secondType = SimpleType.constructUnsafe(Integer.class); [EOL] bindings.addBinding("firstTestName", firstType); [EOL] bindings.addBinding("secondTestName", secondType); [EOL] assertEquals(2, bindings.size()); [EOL] assertTrue(bindings.containsKey("secondTestName")); [EOL] assertEquals(secondType, bindings.get("secondTestName")); [EOL] }
public void testTypesAsArrayWithUnresolvedBindings() { [EOL] YourClass instance = new YourClass(); // Replace with actual class name [EOL] JavaType[] result = instance.typesAsArray(); [EOL] assertNotNull(result); [EOL] assertEquals(0, result.length); // Assuming NO_TYPES is an empty array [EOL] }
public void testTypesAsArrayWithEmptyBindings() { [EOL] YourClass instance = new YourClass(); // Replace with actual class name [EOL] instance._resolve(); // This should initialize _bindings as an empty Map or similar collection [EOL] JavaType[] result = instance.typesAsArray(); [EOL] assertNotNull(result); [EOL] assertEquals(0, result.length); // Assuming NO_TYPES is an empty array [EOL] }
public void testTypesAsArrayWithNonEmptyBindings() { [EOL] YourClass instance = new YourClass(); // Replace with actual class name [EOL] instance._resolve(); // This should initialize _bindings with some values [EOL] instance.addBinding("key", new JavaType()); // Replace with actual method to add bindings if exists [EOL] JavaType[] result = instance.typesAsArray(); [EOL] assertNotNull(result); [EOL] assertTrue(result.length > 0); [EOL] }
public void testResolveWithNullContextType() { [EOL] setup(); [EOL] this._contextType = null; [EOL] this._resolve(); [EOL] assertNotNull("Bindings should not be null", this._bindings); [EOL] assertTrue("Bindings should be empty", this._bindings.isEmpty()); [EOL] }
public void testResolveWithNonNullContextTypeAndNoContainedTypes() { [EOL] setup(); [EOL] this._contextType = createContextTypeWithNoContainedTypes(); [EOL] this._resolve(); [EOL] assertNotNull("Bindings should not be null", this._bindings); [EOL] assertTrue("Bindings should be empty", this._bindings.isEmpty()); [EOL] }
public void testResolveWithNonNullContextTypeAndContainedTypes() { [EOL] setup(); [EOL] this._contextType = createContextTypeWithContainedTypes(); [EOL] this._resolve(); [EOL] assertNotNull("Bindings should not be null", this._bindings); [EOL] assertFalse("Bindings should not be empty", this._bindings.isEmpty()); [EOL] assertEquals("Bindings size should match contained types count", [EOL] this._contextType.containedTypeCount(), this._bindings.size()); [EOL] }
public void testAddPlaceholderWithNullSet() { [EOL] _addPlaceholder("testName"); [EOL] assertTrue(_placeholders.contains("testName")); [EOL] assertEquals(1, _placeholders.size()); [EOL] }
public void testAddPlaceholderWithExistingSet() { [EOL] _placeholders = new HashSet<String>(); [EOL] _placeholders.add("existingName"); [EOL] _addPlaceholder("testName"); [EOL] assertTrue(_placeholders.contains("testName")); [EOL] assertTrue(_placeholders.contains("existingName")); [EOL] assertEquals(2, _placeholders.size()); [EOL] }
protected void _resolveBindings(Type t) { [EOL] if (t == null) [EOL] return; [EOL] Class<?> raw; [EOL] if (t instanceof ParameterizedType) { [EOL] ParameterizedType pt = (ParameterizedType) t; [EOL] Type[] args = pt.getActualTypeArguments(); [EOL] if (args != null && args.length > 0) { [EOL] Class<?> rawType = (Class<?>) pt.getRawType(); [EOL] TypeVariable<?>[] vars = rawType.getTypeParameters(); [EOL] if (vars.length != args.length) { [EOL] throw new IllegalArgumentException("Strange parametrized type (in class " + rawType.getName() + "): number of type arguments != number of type parameters (" + args.length + " vs " + vars.length + ")"); [EOL] } [EOL] for (int i = 0, len = args.length; i < len; ++i) { [EOL] TypeVariable<?> var = vars[i]; [EOL] String name = var.getName(); [EOL] if (_bindings == null) { [EOL] _bindings = new LinkedHashMap<String, JavaType>(); [EOL] } else { [EOL] if (_bindings.containsKey(name)) [EOL] continue; [EOL] } [EOL] _addPlaceholder(name); [EOL] _bindings.put(name, _typeFactory._constructType(args[i], this)); [EOL] } [EOL] } [EOL] raw = (Class<?>) pt.getRawType(); [EOL] } else if (t instanceof Class<?>) { [EOL] raw = (Class<?>) t; [EOL] Class<?> decl = raw.getDeclaringClass(); [EOL] if (decl != null && !decl.isAssignableFrom(raw)) { [EOL] _resolveBindings(raw.getDeclaringClass()); [EOL] } [EOL] TypeVariable<?>[] vars = raw.getTypeParameters(); [EOL] if (vars != null && vars.length > 0) { [EOL] JavaType[] typeParams = null; [EOL] if (_contextType != null && raw.isAssignableFrom(_contextType.getRawClass())) { [EOL] typeParams = _typeFactory.findTypeParameters(_contextType, raw); [EOL] } [EOL] for (int i = 0; i < vars.length; i++) { [EOL] TypeVariable<?> var = vars[i]; [EOL] String name = var.getName(); [EOL] Type varType = var.getBounds()[0]; [EOL] if (varType != null) { [EOL] if (_bindings == null) { [EOL] _bindings = new LinkedHashMap<String, JavaType>(); [EOL] } else { [EOL] if (_bindings.containsKey(name)) [EOL] continue; [EOL] } [EOL] _addPlaceholder(name); [EOL] if (typeParams != null) { [EOL] _bindings.put(name, typeParams[i]); [EOL] } else { [EOL] _bindings.put(name, _typeFactory._constructType(varType, this)); [EOL] } [EOL] } [EOL] } [EOL] } [EOL] } else { [EOL] return; [EOL] } [EOL] _resolveBindings(raw.getGenericSuperclass()); [EOL] for (Type intType : raw.getGenericInterfaces()) { [EOL] _resolveBindings(intType); [EOL] } [EOL] }
protected StdSerializer(Class<T> t) { [EOL] _handledType = t; [EOL] }
public void testStdSerializerConstructorWithNonNullType() { [EOL] JavaType javaType = TypeFactory.defaultInstance().constructType(String.class); [EOL] StdSerializer<?> serializer = new StdSerializer<String>(javaType) {}; [EOL] assertEquals(String.class, serializer.handledType()); [EOL] }
public void testStdSerializerConstructorWithNullType() { [EOL] JavaType javaType = null; [EOL] try { [EOL] StdSerializer<?> serializer = new StdSerializer<Object>(javaType) {}; [EOL] fail("Constructor should throw an exception when type is null"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testStdSerializerWithNonNullClass() { [EOL] Class<?> clazz = String.class; [EOL] StdSerializer<?> serializer = new StdSerializer<Object>(clazz, false); [EOL] assertEquals("Handled type should be 'String.class'", clazz, serializer.handledType()); [EOL] }
public void testStdSerializerWithNullClass() { [EOL] Class<?> clazz = null; [EOL] try { [EOL] StdSerializer<?> serializer = new StdSerializer<Object>(clazz, false); [EOL] fail("Expected IllegalArgumentException not thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testWrapAndThrowWithInvocationTargetException() throws IOException { [EOL] SerializerProvider provider = null; [EOL] Throwable cause = new RuntimeException("Inner exception"); [EOL] Throwable t = new InvocationTargetException(cause); [EOL] Object bean = new Object(); [EOL] String fieldName = "field"; [EOL] try { [EOL] wrapAndThrow(provider, t, bean, fieldName); [EOL] } catch (JsonMappingException e) { [EOL] assertSame(cause, e.getCause()); [EOL] assertEquals("field", e.getPathReference()); [EOL] } [EOL] }
public void testWrapAndThrowWithError() { [EOL] SerializerProvider provider = null; [EOL] Throwable t = new Error("Error occurred"); [EOL] Object bean = new Object(); [EOL] String fieldName = "field"; [EOL] try { [EOL] wrapAndThrow(provider, t, bean, fieldName); [EOL] fail("Expected Error to be thrown"); [EOL] } catch (Error e) { [EOL] assertEquals("Error occurred", e.getMessage()); [EOL] } [EOL] }
public void testWrapAndThrowWithIOExceptionAndWrapDisabled() throws IOException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] when(provider.isEnabled(SerializationFeature.WRAP_EXCEPTIONS)).thenReturn(false); [EOL] Throwable t = new IOException("IO exception"); [EOL] Object bean = new Object(); [EOL] String fieldName = "field"; [EOL] try { [EOL] wrapAndThrow(provider, t, bean, fieldName); [EOL] fail("Expected IOException to be thrown"); [EOL] } catch (IOException e) { [EOL] assertEquals("IO exception", e.getMessage()); [EOL] } [EOL] }
public void testWrapAndThrowWithRuntimeExceptionAndWrapDisabled() { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] when(provider.isEnabled(SerializationFeature.WRAP_EXCEPTIONS)).thenReturn(false); [EOL] Throwable t = new RuntimeException("Runtime exception"); [EOL] Object bean = new Object(); [EOL] String fieldName = "field"; [EOL] try { [EOL] wrapAndThrow(provider, t, bean, fieldName); [EOL] fail("Expected RuntimeException to be thrown"); [EOL] } catch (RuntimeException e) { [EOL] assertEquals("Runtime exception", e.getMessage()); [EOL] } [EOL] }
public void testWrapAndThrowWithJsonMappingExceptionAndWrapEnabled() throws IOException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] when(provider.isEnabled(SerializationFeature.WRAP_EXCEPTIONS)).thenReturn(true); [EOL] Throwable t = new JsonMappingException(null, "JsonMapping exception"); [EOL] Object bean = new Object(); [EOL] String fieldName = "field"; [EOL] try { [EOL] wrapAndThrow(provider, t, bean, fieldName); [EOL] } catch (JsonMappingException e) { [EOL] assertEquals("JsonMapping exception", e.getOriginalMessage()); [EOL] assertEquals("field", e.getPathReference()); [EOL] } [EOL] }
public void testWrapAndThrowWithIOExceptionAndWrapEnabled() throws IOException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] when(provider.isEnabled(SerializationFeature.WRAP_EXCEPTIONS)).thenReturn(true); [EOL] Throwable t = new IOException("IO exception"); [EOL] Object bean = new Object(); [EOL] String fieldName = "field"; [EOL] try { [EOL] wrapAndThrow(provider, t, bean, fieldName); [EOL] } catch (JsonMappingException e) { [EOL] assertTrue(e.getCause() instanceof IOException); [EOL] assertEquals("field", e.getPathReference()); [EOL] } [EOL] }
public void testFindConvertingContentSerializerWithNonNullIntrAndPropAndConvDefAndNullExistingSerializer() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanProperty prop = mock(BeanProperty.class); [EOL] JsonSerializer<?> existingSerializer = null; [EOL] AnnotationIntrospector intr = mock(AnnotationIntrospector.class); [EOL] Object convDef = new Object(); [EOL] Converter<Object, Object> conv = mock(Converter.class); [EOL] JavaType delegateType = mock(JavaType.class); [EOL] JsonSerializer<?> valueSerializer = mock(JsonSerializer.class); [EOL] when(provider.getAnnotationIntrospector()).thenReturn(intr); [EOL] when(prop.getMember()).thenReturn(mock(AnnotatedMember.class)); [EOL] when(intr.findSerializationContentConverter(prop.getMember())).thenReturn(convDef); [EOL] when(provider.converterInstance(prop.getMember(), convDef)).thenReturn(conv); [EOL] when(conv.getOutputType(provider.getTypeFactory())).thenReturn(delegateType); [EOL] when(provider.findValueSerializer(delegateType, prop)).thenReturn(valueSerializer); [EOL] JsonSerializer<?> result = findConvertingContentSerializer(provider, prop, existingSerializer); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof StdDelegatingSerializer); [EOL] }
public void testFindConvertingContentSerializerWithNonNullIntrAndPropButNullConvDef() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanProperty prop = mock(BeanProperty.class); [EOL] JsonSerializer<?> existingSerializer = mock(JsonSerializer.class); [EOL] AnnotationIntrospector intr = mock(AnnotationIntrospector.class); [EOL] when(provider.getAnnotationIntrospector()).thenReturn(intr); [EOL] when(prop.getMember()).thenReturn(mock(AnnotatedMember.class)); [EOL] when(intr.findSerializationContentConverter(prop.getMember())).thenReturn(null); [EOL] JsonSerializer<?> result = findConvertingContentSerializer(provider, prop, existingSerializer); [EOL] assertSame(existingSerializer, result); [EOL] }
public void testFindConvertingContentSerializerWithNullIntrOrProp() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanProperty prop = null; [EOL] JsonSerializer<?> existingSerializer = mock(JsonSerializer.class); [EOL] when(provider.getAnnotationIntrospector()).thenReturn(null); [EOL] JsonSerializer<?> result = findConvertingContentSerializer(provider, prop, existingSerializer); [EOL] assertSame(existingSerializer, result); [EOL] }
protected BasicDeserializerFactory(DeserializerFactoryConfig config) { [EOL] _factoryConfig = config; [EOL] }
public void testWithAdditionalKeyDeserializers_Null() { [EOL] DeserializerFactory factory = new MyDeserializerFactory(); [EOL] DeserializerFactory result = factory.withAdditionalKeyDeserializers(null); [EOL] assertNotNull(result); [EOL] }
public void testWithAdditionalKeyDeserializers_NonNull() { [EOL] DeserializerFactory factory = new MyDeserializerFactory(); [EOL] KeyDeserializers additional = new MyKeyDeserializers(); [EOL] DeserializerFactory result = factory.withAdditionalKeyDeserializers(additional); [EOL] assertNotNull(result); [EOL] assertNotSame(factory, result); [EOL] }
public void testWithValueInstantiators_NewInstantiators() { [EOL] DeserializerFactory originalFactory = new MyDeserializerFactory(); // Assuming MyDeserializerFactory is a valid implementation of DeserializerFactory [EOL] ValueInstantiators newInstantiators = new MyValueInstantiators(); // Assuming MyValueInstantiators is a valid implementation of ValueInstantiators [EOL] DeserializerFactory updatedFactory = originalFactory.withValueInstantiators(newInstantiators); [EOL] assertNotNull(updatedFactory); [EOL] assertNotSame(originalFactory, updatedFactory); [EOL] assertTrue(((MyDeserializerFactory) updatedFactory).isInstantiatorsConfigured(newInstantiators)); [EOL] }
public void testWithValueInstantiators_NullInstantiators() { [EOL] DeserializerFactory originalFactory = new MyDeserializerFactory(); // Assuming MyDeserializerFactory is a valid implementation of DeserializerFactory [EOL] DeserializerFactory updatedFactory = originalFactory.withValueInstantiators(null); [EOL] assertNotNull(updatedFactory); [EOL] assertNotSame(originalFactory, updatedFactory); [EOL] assertFalse(((MyDeserializerFactory) updatedFactory).isInstantiatorsConfigured(null)); [EOL] }
public void testFindValueInstantiatorWithAnnotation() throws JsonMappingException { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] BeanDescription beanDesc = createBeanDescription(); [EOL] AnnotatedClass ac = beanDesc.getClassInfo(); [EOL] Object instDef = new Object(); // Mocked ValueInstantiator definition [EOL] when(ctxt.getAnnotationIntrospector().findValueInstantiator(ac)).thenReturn(instDef); [EOL] ValueInstantiator result = findValueInstantiator(ctxt, beanDesc); [EOL] assertNotNull(result); [EOL] }
public void testFindValueInstantiatorWithNullFromAnnotationAndStdInstantiator() throws JsonMappingException { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] BeanDescription beanDesc = createBeanDescription(); [EOL] AnnotatedClass ac = beanDesc.getClassInfo(); [EOL] when(ctxt.getAnnotationIntrospector().findValueInstantiator(ac)).thenReturn(null); [EOL] when(_findStdValueInstantiator(ctxt.getConfig(), beanDesc)).thenReturn(new StdValueInstantiator(ctxt.getConfig(), beanDesc.getType())); [EOL] ValueInstantiator result = findValueInstantiator(ctxt, beanDesc); [EOL] assertNotNull(result); [EOL] }
public void testFindValueInstantiatorWithNullFromAllSources() throws JsonMappingException { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] BeanDescription beanDesc = createBeanDescription(); [EOL] AnnotatedClass ac = beanDesc.getClassInfo(); [EOL] when(ctxt.getAnnotationIntrospector().findValueInstantiator(ac)).thenReturn(null); [EOL] when(_findStdValueInstantiator(ctxt.getConfig(), beanDesc)).thenReturn(null); [EOL] when(_constructDefaultValueInstantiator(ctxt, beanDesc)).thenReturn(new DefaultValueInstantiator()); [EOL] ValueInstantiator result = findValueInstantiator(ctxt, beanDesc); [EOL] assertNotNull(result); [EOL] }
public void testFindValueInstantiatorWithCustomValueInstantiators() throws JsonMappingException { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] BeanDescription beanDesc = createBeanDescription(); [EOL] ValueInstantiators customInstantiators = mock(ValueInstantiators.class); [EOL] when(_factoryConfig.hasValueInstantiators()).thenReturn(true); [EOL] when(_factoryConfig.valueInstantiators()).thenReturn(Collections.singletonList(customInstantiators)); [EOL] when(customInstantiators.findValueInstantiator(any(DeserializationConfig.class), any(BeanDescription.class), any(ValueInstantiator.class))).thenReturn(new CustomValueInstantiator()); [EOL] ValueInstantiator result = findValueInstantiator(ctxt, beanDesc); [EOL] assertNotNull(result); [EOL] }
public void testFindValueInstantiatorWithIncompleteParameter() { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] BeanDescription beanDesc = createBeanDescription(); [EOL] ValueInstantiator instantiator = mock(ValueInstantiator.class); [EOL] AnnotatedParameter nonAnnotatedParam = mock(AnnotatedParameter.class); [EOL] when(instantiator.getIncompleteParameter()).thenReturn(nonAnnotatedParam); [EOL] when(_constructDefaultValueInstantiator(ctxt, beanDesc)).thenReturn(instantiator); [EOL] Exception exception = assertThrows(IllegalArgumentException.class, () -> { [EOL] findValueInstantiator(ctxt, beanDesc); [EOL] }); [EOL] assertNotNull(exception.getMessage()); [EOL] }
public void testAddDeserializerConstructorsWithDefaultConstructor() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] VisibilityChecker<?> vchecker = mock(VisibilityChecker.class); [EOL] AnnotationIntrospector intr = mock(AnnotationIntrospector.class); [EOL] CreatorCollector creators = mock(CreatorCollector.class); [EOL] AnnotatedConstructor defaultCtor = mock(AnnotatedConstructor.class); [EOL] when(beanDesc.findDefaultConstructor()).thenReturn(defaultCtor); [EOL] when(creators.hasDefaultCreator()).thenReturn(false); [EOL] when(intr.hasCreatorAnnotation(defaultCtor)).thenReturn(false); [EOL] _addDeserializerConstructors(ctxt, beanDesc, vchecker, intr, creators); [EOL] verify(creators).setDefaultCreator(defaultCtor); [EOL] }
public void testAddDeserializerConstructorsWithPropertyConstructor() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] VisibilityChecker<?> vchecker = mock(VisibilityChecker.class); [EOL] AnnotationIntrospector intr = mock(AnnotationIntrospector.class); [EOL] CreatorCollector creators = mock(CreatorCollector.class); [EOL] AnnotatedConstructor propertyCtor = mock(AnnotatedConstructor.class); [EOL] BeanPropertyDefinition propDef = mock(BeanPropertyDefinition.class); [EOL] AnnotatedParameter param = mock(AnnotatedParameter.class); [EOL] when(beanDesc.findDefaultConstructor()).thenReturn(null); [EOL] when(beanDesc.findProperties()).thenReturn(Collections.singletonList(propDef)); [EOL] when(propDef.getConstructorParameter()).thenReturn(param); [EOL] when(param.getOwner()).thenReturn(propertyCtor); [EOL] when(propertyCtor.getParameterCount()).thenReturn(1); [EOL] when(param.getIndex()).thenReturn(0); [EOL] when(propDef.getName()).thenReturn("propertyName"); [EOL] _addDeserializerConstructors(ctxt, beanDesc, vchecker, intr, creators); [EOL] verify(creators, never()).setDefaultCreator(any(AnnotatedConstructor.class)); [EOL] }
public void testAddDeserializerConstructorsWithSingleArgumentConstructor() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] VisibilityChecker<?> vchecker = mock(VisibilityChecker.class); [EOL] AnnotationIntrospector intr = mock(AnnotationIntrospector.class); [EOL] CreatorCollector creators = mock(CreatorCollector.class); [EOL] AnnotatedConstructor singleArgCtor = mock(AnnotatedConstructor.class); [EOL] List<AnnotatedConstructor> ctors = Collections.singletonList(singleArgCtor); [EOL] when(beanDesc.findDefaultConstructor()).thenReturn(null); [EOL] when(beanDesc.findProperties()).thenReturn(Collections.emptyList()); [EOL] when(beanDesc.getConstructors()).thenReturn(ctors); [EOL] when(singleArgCtor.getParameterCount()).thenReturn(1); [EOL] when(intr.hasCreatorAnnotation(singleArgCtor)).thenReturn(true); [EOL] when(vchecker.isCreatorVisible(singleArgCtor)).thenReturn(true); [EOL] _addDeserializerConstructors(ctxt, beanDesc, vchecker, intr, creators); [EOL] verify(creators, never()).setDefaultCreator(any(AnnotatedConstructor.class)); [EOL] verify(creators).handleSingleArgumentConstructor(eq(ctxt), eq(beanDesc), eq(vchecker), eq(intr), eq(creators), eq(singleArgCtor), eq(true), eq(true), anyString()); [EOL] }
public void testAddDeserializerConstructorsWithMultiArgumentConstructor() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] VisibilityChecker<?> vchecker = mock(VisibilityChecker.class); [EOL] AnnotationIntrospector intr = mock(AnnotationIntrospector.class); [EOL] CreatorCollector creators = mock(CreatorCollector.class); [EOL] AnnotatedConstructor multiArgCtor = mock(AnnotatedConstructor.class); [EOL] List<AnnotatedConstructor> ctors = Collections.singletonList(multiArgCtor); [EOL] AnnotatedParameter param = mock(AnnotatedParameter.class); [EOL] PropertyName propertyName = mock(PropertyName.class); [EOL] when(beanDesc.findDefaultConstructor()).thenReturn(null); [EOL] when(beanDesc.findProperties()).thenReturn(Collections.emptyList()); [EOL] when(beanDesc.getConstructors()).thenReturn(ctors); [EOL] when(multiArgCtor.getParameterCount()).thenReturn(2); [EOL] when(intr.hasCreatorAnnotation(multiArgCtor)).thenReturn(false); [EOL] when(vchecker.isCreatorVisible(multiArgCtor)).thenReturn(true); [EOL] when(multiArgCtor.getParameter(0)).thenReturn(param); [EOL] when(multiArgCtor.getParameter(1)).thenReturn(param); [EOL] when(intr.findNameForDeserialization(param)).thenReturn(propertyName); [EOL] when(propertyName.getSimpleName()).thenReturn("paramName"); [EOL] when(intr.findInjectableValueId(param)).thenReturn(null); [EOL] _addDeserializerConstructors(ctxt, beanDesc, vchecker, intr, creators); [EOL] verify(creators, never()).setDefaultCreator(any(AnnotatedConstructor.class)); [EOL] verify(creators).addPropertyCreator(eq(multiArgCtor), any(CreatorProperty[].class)); [EOL] }
public void testHandleSingleArgumentConstructorWithNameAndInjectId() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] VisibilityChecker<?> vchecker = mock(VisibilityChecker.class); [EOL] AnnotationIntrospector intr = mock(AnnotationIntrospector.class); [EOL] CreatorCollector creators = mock(CreatorCollector.class); [EOL] AnnotatedConstructor ctor = mock(AnnotatedConstructor.class); [EOL] AnnotatedParameter param = mock(AnnotatedParameter.class); [EOL] when(ctor.getParameter(0)).thenReturn(param); [EOL] when(intr.findNameForDeserialization(param)).thenReturn(new PropertyName("testName")); [EOL] when(intr.findInjectableValueId(param)).thenReturn("injectId"); [EOL] boolean result = _handleSingleArgumentConstructor(ctxt, beanDesc, vchecker, intr, creators, ctor, false, false, null); [EOL] assertTrue(result); [EOL] verify(creators).addPropertyCreator(eq(ctor), any(CreatorProperty[].class)); [EOL] }
public void testHandleSingleArgumentConstructorWithNullNameAndParam() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] VisibilityChecker<?> vchecker = mock(VisibilityChecker.class); [EOL] AnnotationIntrospector intr = mock(AnnotationIntrospector.class); [EOL] CreatorCollector creators = mock(CreatorCollector.class); [EOL] AnnotatedConstructor ctor = mock(AnnotatedConstructor.class); [EOL] when(ctor.getParameter(0)).thenReturn(null); [EOL] when(intr.findNameForDeserialization(null)).thenReturn(null); [EOL] boolean result = _handleSingleArgumentConstructor(ctxt, beanDesc, vchecker, intr, creators, ctor, false, false, null); [EOL] assertFalse(result); [EOL] }
public void testHandleSingleArgumentConstructorWithTypeStringAndIsCreator() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] VisibilityChecker<?> vchecker = mock(VisibilityChecker.class); [EOL] AnnotationIntrospector intr = mock(AnnotationIntrospector.class); [EOL] CreatorCollector creators = mock(CreatorCollector.class); [EOL] AnnotatedConstructor ctor = mock(AnnotatedConstructor.class); [EOL] when(ctor.getRawParameterType(0)).thenReturn(String.class); [EOL] boolean result = _handleSingleArgumentConstructor(ctxt, beanDesc, vchecker, intr, creators, ctor, true, false, null); [EOL] assertTrue(result); [EOL] verify(creators).addStringCreator(ctor); [EOL] }
public void testHandleSingleArgumentConstructorWithTypeIntAndIsVisible() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] VisibilityChecker<?> vchecker = mock(VisibilityChecker.class); [EOL] AnnotationIntrospector intr = mock(AnnotationIntrospector.class); [EOL] CreatorCollector creators = mock(CreatorCollector.class); [EOL] AnnotatedConstructor ctor = mock(AnnotatedConstructor.class); [EOL] when(ctor.getRawParameterType(0)).thenReturn(int.class); [EOL] boolean result = _handleSingleArgumentConstructor(ctxt, beanDesc, vchecker, intr, creators, ctor, false, true, null); [EOL] assertTrue(result); [EOL] verify(creators).addIntCreator(ctor); [EOL] }
public void testHandleSingleArgumentConstructorWithTypeLongAndNotVisibleOrCreator() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] VisibilityChecker<?> vchecker = mock(VisibilityChecker.class); [EOL] AnnotationIntrospector intr = mock(AnnotationIntrospector.class); [EOL] CreatorCollector creators = mock(CreatorCollector.class); [EOL] AnnotatedConstructor ctor = mock(AnnotatedConstructor.class); [EOL] when(ctor.getRawParameterType(0)).thenReturn(long.class); [EOL] boolean result = _handleSingleArgumentConstructor(ctxt, beanDesc, vchecker, intr, creators, ctor, false, false, null); [EOL] assertFalse(result); [EOL] }
public void testHandleSingleArgumentConstructorWithTypeDoubleAndIsCreator() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] VisibilityChecker<?> vchecker = mock(VisibilityChecker.class); [EOL] AnnotationIntrospector intr = mock(AnnotationIntrospector.class); [EOL] CreatorCollector creators = mock(CreatorCollector.class); [EOL] AnnotatedConstructor ctor = mock(AnnotatedConstructor.class); [EOL] when(ctor.getRawParameterType(0)).thenReturn(double.class); [EOL] boolean result = _handleSingleArgumentConstructor(ctxt, beanDesc, vchecker, intr, creators, ctor, true, false, null); [EOL] assertTrue(result); [EOL] verify(creators).addDoubleCreator(ctor); [EOL] }
public void testHandleSingleArgumentConstructorWithIsCreatorAndUnsupportedType() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] VisibilityChecker<?> vchecker = mock(VisibilityChecker.class); [EOL] AnnotationIntrospector intr = mock(AnnotationIntrospector.class); [EOL] CreatorCollector creators = mock(CreatorCollector.class); [EOL] AnnotatedConstructor ctor = mock(AnnotatedConstructor.class); [EOL] when(ctor.getRawParameterType(0)).thenReturn(Object.class); [EOL] boolean result = _handleSingleArgumentConstructor(ctxt, beanDesc, vchecker, intr, creators, ctor, true, false, null); [EOL] assertTrue(result); [EOL] verify(creators).addDelegatingCreator(ctor, null); [EOL] }
protected void _addDeserializerFactoryMethods(DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators) throws JsonMappingException { [EOL] final DeserializationConfig config = ctxt.getConfig(); [EOL] for (AnnotatedMethod factory : beanDesc.getFactoryMethods()) { [EOL] boolean isCreator = intr.hasCreatorAnnotation(factory); [EOL] int argCount = factory.getParameterCount(); [EOL] if (argCount == 0) { [EOL] if (isCreator) { [EOL] creators.setDefaultCreator(factory); [EOL] } [EOL] continue; [EOL] } [EOL] if (argCount == 1) { [EOL] AnnotatedParameter param = factory.getParameter(0); [EOL] PropertyName pn = (param == null) ? null : intr.findNameForDeserialization(param); [EOL] String name = (pn == null) ? null : pn.getSimpleName(); [EOL] Object injectId = intr.findInjectableValueId(param); [EOL] if ((injectId == null) && (name == null || name.length() == 0)) { [EOL] _handleSingleArgumentFactory(config, beanDesc, vchecker, intr, creators, factory, isCreator); [EOL] continue; [EOL] } [EOL] } else { [EOL] if (!intr.hasCreatorAnnotation(factory)) { [EOL] continue; [EOL] } [EOL] } [EOL] AnnotatedParameter nonAnnotatedParam = null; [EOL] CreatorProperty[] properties = new CreatorProperty[argCount]; [EOL] int namedCount = 0; [EOL] int injectCount = 0; [EOL] for (int i = 0; i < argCount; ++i) { [EOL] AnnotatedParameter param = factory.getParameter(i); [EOL] PropertyName pn = (param == null) ? null : intr.findNameForDeserialization(param); [EOL] String name = (pn == null) ? null : pn.getSimpleName(); [EOL] Object injectId = intr.findInjectableValueId(param); [EOL] if (name != null && name.length() > 0) { [EOL] ++namedCount; [EOL] properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId); [EOL] } else if (injectId != null) { [EOL] ++injectCount; [EOL] properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId); [EOL] } else if (nonAnnotatedParam == null) { [EOL] nonAnnotatedParam = param; [EOL] } [EOL] } [EOL] if (isCreator || namedCount > 0 || injectCount > 0) { [EOL] if ((namedCount + injectCount) == argCount) { [EOL] creators.addPropertyCreator(factory, properties); [EOL] } else if ((namedCount == 0) && ((injectCount + 1) == argCount)) { [EOL] creators.addDelegatingCreator(factory, properties); [EOL] } else { [EOL] throw new IllegalArgumentException("Argument #" + nonAnnotatedParam.getIndex() + " of factory method " + factory + " has no property name annotation; must have name when multiple-paramater constructor annotated as Creator"); [EOL] } [EOL] } [EOL] } [EOL] }
public void testHandleSingleArgumentFactoryWithString() { [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] VisibilityChecker<?> vchecker = mock(VisibilityChecker.class); [EOL] AnnotationIntrospector intr = mock(AnnotationIntrospector.class); [EOL] CreatorCollector creators = new CreatorCollector(config, false); [EOL] AnnotatedMethod factory = mock(AnnotatedMethod.class); [EOL] boolean isCreator = false; [EOL] when(factory.getRawParameterType(0)).thenReturn(String.class); [EOL] when(vchecker.isCreatorVisible(factory)).thenReturn(true); [EOL] boolean result = _handleSingleArgumentFactory(config, beanDesc, vchecker, intr, creators, factory, isCreator); [EOL] assertTrue(result); [EOL] verify(creators).addStringCreator(factory); [EOL] }
public void testHandleSingleArgumentFactoryWithInt() { [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] VisibilityChecker<?> vchecker = mock(VisibilityChecker.class); [EOL] AnnotationIntrospector intr = mock(AnnotationIntrospector.class); [EOL] CreatorCollector creators = new CreatorCollector(config, false); [EOL] AnnotatedMethod factory = mock(AnnotatedMethod.class); [EOL] boolean isCreator = false; [EOL] when(factory.getRawParameterType(0)).thenReturn(int.class); [EOL] when(vchecker.isCreatorVisible(factory)).thenReturn(true); [EOL] boolean result = _handleSingleArgumentFactory(config, beanDesc, vchecker, intr, creators, factory, isCreator); [EOL] assertTrue(result); [EOL] verify(creators).addIntCreator(factory); [EOL] }
public void testHandleSingleArgumentFactoryWithLong() { [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] VisibilityChecker<?> vchecker = mock(VisibilityChecker.class); [EOL] AnnotationIntrospector intr = mock(AnnotationIntrospector.class); [EOL] CreatorCollector creators = new CreatorCollector(config, false); [EOL] AnnotatedMethod factory = mock(AnnotatedMethod.class); [EOL] boolean isCreator = false; [EOL] when(factory.getRawParameterType(0)).thenReturn(long.class); [EOL] when(vchecker.isCreatorVisible(factory)).thenReturn(true); [EOL] boolean result = _handleSingleArgumentFactory(config, beanDesc, vchecker, intr, creators, factory, isCreator); [EOL] assertTrue(result); [EOL] verify(creators).addLongCreator(factory); [EOL] }
public void testHandleSingleArgumentFactoryWithDouble() { [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] VisibilityChecker<?> vchecker = mock(VisibilityChecker.class); [EOL] AnnotationIntrospector intr = mock(AnnotationIntrospector.class); [EOL] CreatorCollector creators = new CreatorCollector(config, false); [EOL] AnnotatedMethod factory = mock(AnnotatedMethod.class); [EOL] boolean isCreator = false; [EOL] when(factory.getRawParameterType(0)).thenReturn(double.class); [EOL] when(vchecker.isCreatorVisible(factory)).thenReturn(true); [EOL] boolean result = _handleSingleArgumentFactory(config, beanDesc, vchecker, intr, creators, factory, isCreator); [EOL] assertTrue(result); [EOL] verify(creators).addDoubleCreator(factory); [EOL] }
public void testHandleSingleArgumentFactoryWithBoolean() { [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] VisibilityChecker<?> vchecker = mock(VisibilityChecker.class); [EOL] AnnotationIntrospector intr = mock(AnnotationIntrospector.class); [EOL] CreatorCollector creators = new CreatorCollector(config, false); [EOL] AnnotatedMethod factory = mock(AnnotatedMethod.class); [EOL] boolean isCreator = false; [EOL] when(factory.getRawParameterType(0)).thenReturn(boolean.class); [EOL] when(vchecker.isCreatorVisible(factory)).thenReturn(true); [EOL] boolean result = _handleSingleArgumentFactory(config, beanDesc, vchecker, intr, creators, factory, isCreator); [EOL] assertTrue(result); [EOL] verify(creators).addBooleanCreator(factory); [EOL] }
public void testHandleSingleArgumentFactoryWithCreatorAnnotation() { [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] VisibilityChecker<?> vchecker = mock(VisibilityChecker.class); [EOL] AnnotationIntrospector intr = mock(AnnotationIntrospector.class); [EOL] CreatorCollector creators = new CreatorCollector(config, false); [EOL] AnnotatedMethod factory = mock(AnnotatedMethod.class); [EOL] boolean isCreator = false; [EOL] when(factory.getRawParameterType(0)).thenReturn(Object.class); [EOL] when(intr.hasCreatorAnnotation(factory)).thenReturn(true); [EOL] boolean result = _handleSingleArgumentFactory(config, beanDesc, vchecker, intr, creators, factory, isCreator); [EOL] assertTrue(result); [EOL] verify(creators).addDelegatingCreator(factory, null); [EOL] }
public void testHandleSingleArgumentFactoryWithNoMatch() { [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] VisibilityChecker<?> vchecker = mock(VisibilityChecker.class); [EOL] AnnotationIntrospector intr = mock(AnnotationIntrospector.class); [EOL] CreatorCollector creators = new CreatorCollector(config, false); [EOL] AnnotatedMethod factory = mock(AnnotatedMethod.class); [EOL] boolean isCreator = false; [EOL] when(factory.getRawParameterType(0)).thenReturn(Object.class); [EOL] when(intr.hasCreatorAnnotation(factory)).thenReturn(false); [EOL] boolean result = _handleSingleArgumentFactory(config, beanDesc, vchecker, intr, creators, factory, isCreator); [EOL] assertFalse(result); [EOL] }
public void testConstructCreatorPropertyWithNonNullIntrospectorAndRequiredMarker() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] AnnotationIntrospector intr = mock(AnnotationIntrospector.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] AnnotatedParameter param = mock(AnnotatedParameter.class); [EOL] TypeFactory typeFactory = mock(TypeFactory.class); [EOL] JavaType t0 = mock(JavaType.class); [EOL] JavaType type = mock(JavaType.class); [EOL] String name = "testProperty"; [EOL] int index = 0; [EOL] Object injectableValueId = new Object(); [EOL] when(ctxt.getConfig()).thenReturn(config); [EOL] when(ctxt.getAnnotationIntrospector()).thenReturn(intr); [EOL] when(intr.hasRequiredMarker(param)).thenReturn(Boolean.TRUE); [EOL] when(config.getTypeFactory()).thenReturn(typeFactory); [EOL] when(typeFactory.constructType(param.getParameterType(), beanDesc.bindingsForBeanType())).thenReturn(t0); [EOL] when(beanDesc.getClassAnnotations()).thenReturn(null); [EOL] CreatorProperty result = constructCreatorProperty(ctxt, beanDesc, name, index, param, injectableValueId); [EOL] assertNotNull(result); [EOL] assertTrue(result.isRequired()); [EOL] }
public void testConstructCreatorPropertyWithNullIntrospector() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] AnnotatedParameter param = mock(AnnotatedParameter.class); [EOL] TypeFactory typeFactory = mock(TypeFactory.class); [EOL] JavaType t0 = mock(JavaType.class); [EOL] JavaType type = mock(JavaType.class); [EOL] String name = "testProperty"; [EOL] int index = 0; [EOL] Object injectableValueId = new Object(); [EOL] when(ctxt.getConfig()).thenReturn(config); [EOL] when(ctxt.getAnnotationIntrospector()).thenReturn(null); [EOL] when(config.getTypeFactory()).thenReturn(typeFactory); [EOL] when(typeFactory.constructType(param.getParameterType(), beanDesc.bindingsForBeanType())).thenReturn(t0); [EOL] when(beanDesc.getClassAnnotations()).thenReturn(null); [EOL] CreatorProperty result = constructCreatorProperty(ctxt, beanDesc, name, index, param, injectableValueId); [EOL] assertNotNull(result); [EOL] assertFalse(result.isRequired()); [EOL] }
public void testConstructCreatorPropertyWithTypeModification() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] AnnotationIntrospector intr = mock(AnnotationIntrospector.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] AnnotatedParameter param = mock(AnnotatedParameter.class); [EOL] TypeFactory typeFactory = mock(TypeFactory.class); [EOL] JavaType t0 = mock(JavaType.class); [EOL] JavaType modifiedType = mock(JavaType.class); [EOL] String name = "testProperty"; [EOL] int index = 0; [EOL] Object injectableValueId = new Object(); [EOL] when(ctxt.getConfig()).thenReturn(config); [EOL] when(ctxt.getAnnotationIntrospector()).thenReturn(intr); [EOL] when(config.getTypeFactory()).thenReturn(typeFactory); [EOL] when(typeFactory.constructType(param.getParameterType(), beanDesc.bindingsForBeanType())).thenReturn(t0); [EOL] when(beanDesc.getClassAnnotations()).thenReturn(null); [EOL] when(resolveType(ctxt, beanDesc, t0, param)).thenReturn(modifiedType); [EOL] CreatorProperty result = constructCreatorProperty(ctxt, beanDesc, name, index, param, injectableValueId); [EOL] assertNotNull(result); [EOL] assertSame(modifiedType, result.getType()); [EOL] }
public void testCreateArrayDeserializerWithCustomDeserializer() { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] ArrayType type = mock(ArrayType.class); [EOL] JavaType elemType = mock(JavaType.class); [EOL] JsonDeserializer<Object> contentDeser = mock(JsonDeserializer.class); [EOL] TypeDeserializer elemTypeDeser = mock(TypeDeserializer.class); [EOL] when(ctxt.getConfig()).thenReturn(config); [EOL] when(type.getContentType()).thenReturn(elemType); [EOL] when(elemType.getValueHandler()).thenReturn(contentDeser); [EOL] when(elemType.getTypeHandler()).thenReturn(null); [EOL] when(elemType.getRawClass()).thenReturn(Object.class); [EOL] JsonDeserializer<?> result = createArrayDeserializer(ctxt, type, beanDesc); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof ObjectArrayDeserializer); [EOL] }
public void testCreateArrayDeserializerWithPrimitiveType() { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] ArrayType type = mock(ArrayType.class); [EOL] JavaType elemType = mock(JavaType.class); [EOL] when(ctxt.getConfig()).thenReturn(config); [EOL] when(type.getContentType()).thenReturn(elemType); [EOL] when(elemType.getValueHandler()).thenReturn(null); [EOL] when(elemType.getTypeHandler()).thenReturn(null); [EOL] when(elemType.isPrimitive()).thenReturn(true); [EOL] when(elemType.getRawClass()).thenReturn(int.class); [EOL] JsonDeserializer<?> result = createArrayDeserializer(ctxt, type, beanDesc); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof PrimitiveArrayDeserializers); [EOL] }
public void testCreateArrayDeserializerWithStringType() { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] ArrayType type = mock(ArrayType.class); [EOL] JavaType elemType = mock(JavaType.class); [EOL] when(ctxt.getConfig()).thenReturn(config); [EOL] when(type.getContentType()).thenReturn(elemType); [EOL] when(elemType.getValueHandler()).thenReturn(null); [EOL] when(elemType.getTypeHandler()).thenReturn(null); [EOL] when(elemType.getRawClass()).thenReturn(String.class); [EOL] JsonDeserializer<?> result = createArrayDeserializer(ctxt, type, beanDesc); [EOL] assertNotNull(result); [EOL] assertSame(StringArrayDeserializer.instance, result); [EOL] }
public void testCreateArrayDeserializerWithModifiers() { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] ArrayType type = mock(ArrayType.class); [EOL] JavaType elemType = mock(JavaType.class); [EOL] JsonDeserializer<Object> contentDeser = mock(JsonDeserializer.class); [EOL] TypeDeserializer elemTypeDeser = mock(TypeDeserializer.class); [EOL] BeanDeserializerModifier modifier = mock(BeanDeserializerModifier.class); [EOL] when(ctxt.getConfig()).thenReturn(config); [EOL] when(type.getContentType()).thenReturn(elemType); [EOL] when(elemType.getValueHandler()).thenReturn(contentDeser); [EOL] when(elemType.getTypeHandler()).thenReturn(elemTypeDeser); [EOL] when(_factoryConfig.hasDeserializerModifiers()).thenReturn(true); [EOL] when(_factoryConfig.deserializerModifiers()).thenReturn(Collections.singletonList(modifier)); [EOL] when(modifier.modifyArrayDeserializer(any(DeserializationConfig.class), any(ArrayType.class), any(BeanDescription.class), any(JsonDeserializer.class))) [EOL] .thenAnswer(invocation -> invocation.getArgument(3)); [EOL] JsonDeserializer<?> result = createArrayDeserializer(ctxt, type, beanDesc); [EOL] assertNotNull(result); [EOL] verify(modifier).modifyArrayDeserializer(config, type, beanDesc, result); [EOL] }
public void testCreateCollectionDeserializerWithEnumSet() { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] CollectionType type = mock(CollectionType.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] JavaType contentType = mock(JavaType.class); [EOL] when(type.getContentType()).thenReturn(contentType); [EOL] when(contentType.getRawClass()).thenReturn(Enum.class); [EOL] when(type.getRawClass()).thenReturn(EnumSet.class); [EOL] JsonDeserializer<?> result = createCollectionDeserializer(ctxt, type, beanDesc); [EOL] assertTrue(result instanceof EnumSetDeserializer); [EOL] }
public void testCreateCollectionDeserializerWithAbstractType() { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] CollectionType type = mock(CollectionType.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] when(ctxt.getConfig()).thenReturn(config); [EOL] when(type.isInterface()).thenReturn(true); [EOL] when(config.introspectForCreation(any(JavaType.class))).thenReturn(beanDesc); [EOL] try { [EOL] createCollectionDeserializer(ctxt, type, beanDesc); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testCreateCollectionDeserializerWithArrayBlockingQueue() { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] CollectionType type = mock(CollectionType.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] JavaType contentType = mock(JavaType.class); [EOL] ValueInstantiator inst = mock(ValueInstantiator.class); [EOL] when(type.getContentType()).thenReturn(contentType); [EOL] when(type.getRawClass()).thenReturn(ArrayBlockingQueue.class); [EOL] when(inst.canCreateUsingDefault()).thenReturn(false); [EOL] JsonDeserializer<?> result = createCollectionDeserializer(ctxt, type, beanDesc); [EOL] assertTrue(result instanceof ArrayBlockingQueueDeserializer); [EOL] }
public void testCreateCollectionDeserializerWithStringCollection() { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] CollectionType type = mock(CollectionType.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] JavaType contentType = mock(JavaType.class); [EOL] ValueInstantiator inst = mock(ValueInstantiator.class); [EOL] when(type.getContentType()).thenReturn(contentType); [EOL] when(contentType.getRawClass()).thenReturn(String.class); [EOL] JsonDeserializer<?> result = createCollectionDeserializer(ctxt, type, beanDesc); [EOL] assertTrue(result instanceof StringCollectionDeserializer); [EOL] }
public void testCreateCollectionDeserializerWithModifiers() { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] CollectionType type = mock(CollectionType.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] when(ctxt.getConfig()).thenReturn(config); [EOL] DeserializerFactoryConfig factoryConfig = mock(DeserializerFactoryConfig.class); [EOL] when(factoryConfig.hasDeserializerModifiers()).thenReturn(true); [EOL] BeanDeserializerModifier modifier = mock(BeanDeserializerModifier.class); [EOL] when(factoryConfig.deserializerModifiers()).thenReturn(Collections.singletonList(modifier)); [EOL] JsonDeserializer<?> originalDeserializer = mock(JsonDeserializer.class); [EOL] when(modifier.modifyCollectionDeserializer(any(), any(), any(), any())).thenReturn(originalDeserializer); [EOL] JsonDeserializer<?> result = createCollectionDeserializer(ctxt, type, beanDesc); [EOL] assertSame(originalDeserializer, result); [EOL] }
public void testCreateMapDeserializerWithEnumMap() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] when(ctxt.getConfig()).thenReturn(config); [EOL] MapType type = mock(MapType.class); [EOL] when(type.getRawClass()).thenReturn(EnumMap.class); [EOL] JavaType keyType = mock(JavaType.class); [EOL] when(keyType.getRawClass()).thenReturn(Enum.class); [EOL] when(type.getKeyType()).thenReturn(keyType); [EOL] JavaType contentType = mock(JavaType.class); [EOL] when(type.getContentType()).thenReturn(contentType); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] JsonDeserializer<?> result = createMapDeserializer(ctxt, type, beanDesc); [EOL] assertTrue(result instanceof EnumMapDeserializer); [EOL] }
public void testCreateMapDeserializerWithNonConcreteMapType() { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] when(ctxt.getConfig()).thenReturn(config); [EOL] MapType type = mock(MapType.class); [EOL] when(type.getRawClass()).thenReturn(Map.class); [EOL] when(type.isInterface()).thenReturn(true); [EOL] JavaType keyType = mock(JavaType.class); [EOL] when(type.getKeyType()).thenReturn(keyType); [EOL] JavaType contentType = mock(JavaType.class); [EOL] when(type.getContentType()).thenReturn(contentType); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] Exception exception = assertThrows(IllegalArgumentException.class, () -> { [EOL] createMapDeserializer(ctxt, type, beanDesc); [EOL] }); [EOL] String expectedMessage = "Can not find a deserializer for non-concrete Map type"; [EOL] String actualMessage = exception.getMessage(); [EOL] assertTrue(actualMessage.contains(expectedMessage)); [EOL] }
public void testCreateMapDeserializerWithCustomDeserializer() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] when(ctxt.getConfig()).thenReturn(config); [EOL] MapType type = mock(MapType.class); [EOL] JavaType keyType = mock(JavaType.class); [EOL] when(type.getKeyType()).thenReturn(keyType); [EOL] JavaType contentType = mock(JavaType.class); [EOL] when(type.getContentType()).thenReturn(contentType); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] JsonDeserializer<Object> contentDeser = mock(JsonDeserializer.class); [EOL] when(contentType.getValueHandler()).thenReturn(contentDeser); [EOL] KeyDeserializer keyDes = mock(KeyDeserializer.class); [EOL] when(keyType.getValueHandler()).thenReturn(keyDes); [EOL] TypeDeserializer contentTypeDeser = mock(TypeDeserializer.class); [EOL] when(contentType.getTypeHandler()).thenReturn(contentTypeDeser); [EOL] JsonDeserializer<?> customDeser = mock(JsonDeserializer.class); [EOL] when(_findCustomMapDeserializer(type, config, beanDesc, keyDes, contentTypeDeser, contentDeser)).thenReturn(customDeser); [EOL] JsonDeserializer<?> result = createMapDeserializer(ctxt, type, beanDesc); [EOL] assertSame(customDeser, result); [EOL] }
public void testCreateMapDeserializerWithModifiers() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] when(ctxt.getConfig()).thenReturn(config); [EOL] MapType type = mock(MapType.class); [EOL] JavaType keyType = mock(JavaType.class); [EOL] when(type.getKeyType()).thenReturn(keyType); [EOL] JavaType contentType = mock(JavaType.class); [EOL] when(type.getContentType()).thenReturn(contentType); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] JsonDeserializer<Object> contentDeser = mock(JsonDeserializer.class); [EOL] when(contentType.getValueHandler()).thenReturn(contentDeser); [EOL] KeyDeserializer keyDes = mock(KeyDeserializer.class); [EOL] when(keyType.getValueHandler()).thenReturn(keyDes); [EOL] TypeDeserializer contentTypeDeser = mock(TypeDeserializer.class); [EOL] when(contentType.getTypeHandler()).thenReturn(contentTypeDeser); [EOL] JsonDeserializer<?> baseDeser = mock(JsonDeserializer.class); [EOL] when(_findCustomMapDeserializer(type, config, beanDesc, keyDes, contentTypeDeser, contentDeser)).thenReturn(null); [EOL] when(_factoryConfig.hasDeserializerModifiers()).thenReturn(true); [EOL] BeanDeserializerModifier modifier = mock(BeanDeserializerModifier.class); [EOL] when(_factoryConfig.deserializerModifiers()).thenReturn(Collections.singletonList(modifier)); [EOL] JsonDeserializer<?> modifiedDeser = mock(JsonDeserializer.class); [EOL] when(modifier.modifyMapDeserializer(config, type, beanDesc, baseDeser)).thenReturn(modifiedDeser); [EOL] JsonDeserializer<?> result = createMapDeserializer(ctxt, type, beanDesc); [EOL] assertSame(modifiedDeser, result); [EOL] }
public void testCreateMapLikeDeserializerWithNonNullDeserializer() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] MapLikeType type = mock(MapLikeType.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] JavaType keyType = mock(JavaType.class); [EOL] JavaType contentType = mock(JavaType.class); [EOL] JsonDeserializer<Object> contentDeser = mock(JsonDeserializer.class); [EOL] KeyDeserializer keyDes = mock(KeyDeserializer.class); [EOL] TypeDeserializer contentTypeDeser = mock(TypeDeserializer.class); [EOL] JsonDeserializer<?> customDeser = mock(JsonDeserializer.class); [EOL] when(ctxt.getConfig()).thenReturn(config); [EOL] when(type.getKeyType()).thenReturn(keyType); [EOL] when(type.getContentType()).thenReturn(contentType); [EOL] when(contentType.getValueHandler()).thenReturn(contentDeser); [EOL] when(keyType.getValueHandler()).thenReturn(keyDes); [EOL] when(contentType.getTypeHandler()).thenReturn(null); [EOL] when(contentTypeDeser).thenReturn(contentTypeDeser); [EOL] BasicDeserializerFactory factory = new BasicDeserializerFactory(null, null, null); [EOL] factory._factoryConfig = new DeserializerFactoryConfig(); [EOL] JsonDeserializer<?> deser = factory.createMapLikeDeserializer(ctxt, type, beanDesc); [EOL] assertNotNull(deser); [EOL] }
public void testCreateMapLikeDeserializerWithNullDeserializer() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] MapLikeType type = mock(MapLikeType.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] JavaType keyType = mock(JavaType.class); [EOL] JavaType contentType = mock(JavaType.class); [EOL] when(ctxt.getConfig()).thenReturn(config); [EOL] when(type.getKeyType()).thenReturn(keyType); [EOL] when(type.getContentType()).thenReturn(contentType); [EOL] when(contentType.getValueHandler()).thenReturn(null); [EOL] when(keyType.getValueHandler()).thenReturn(null); [EOL] when(contentType.getTypeHandler()).thenReturn(null); [EOL] BasicDeserializerFactory factory = new BasicDeserializerFactory(null, null, null); [EOL] factory._factoryConfig = new DeserializerFactoryConfig(); [EOL] JsonDeserializer<?> deser = factory.createMapLikeDeserializer(ctxt, type, beanDesc); [EOL] assertNull(deser); [EOL] }
public void testCreateMapLikeDeserializerWithModifiers() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] MapLikeType type = mock(MapLikeType.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] JavaType keyType = mock(JavaType.class); [EOL] JavaType contentType = mock(JavaType.class); [EOL] JsonDeserializer<Object> contentDeser = mock(JsonDeserializer.class); [EOL] KeyDeserializer keyDes = mock(KeyDeserializer.class); [EOL] TypeDeserializer contentTypeDeser = mock(TypeDeserializer.class); [EOL] JsonDeserializer<?> customDeser = mock(JsonDeserializer.class); [EOL] BeanDeserializerModifier modifier = mock(BeanDeserializerModifier.class); [EOL] when(ctxt.getConfig()).thenReturn(config); [EOL] when(type.getKeyType()).thenReturn(keyType); [EOL] when(type.getContentType()).thenReturn(contentType); [EOL] when(contentType.getValueHandler()).thenReturn(contentDeser); [EOL] when(keyType.getValueHandler()).thenReturn(keyDes); [EOL] when(contentType.getTypeHandler()).thenReturn(null); [EOL] when(contentTypeDeser).thenReturn(contentTypeDeser); [EOL] when(modifier.modifyMapLikeDeserializer(any(DeserializationConfig.class), any(MapLikeType.class), any(BeanDescription.class), any(JsonDeserializer.class))).thenReturn(customDeser); [EOL] BasicDeserializerFactory factory = new BasicDeserializerFactory(null, null, null); [EOL] factory._factoryConfig = new DeserializerFactoryConfig(); [EOL] factory._factoryConfig = factory._factoryConfig.withDeserializerModifier(modifier); [EOL] JsonDeserializer<?> deser = factory.createMapLikeDeserializer(ctxt, type, beanDesc); [EOL] assertSame(customDeser, deser); [EOL] }
public void testFindCustomMapDeserializerWithNonNullDeserializer() throws JsonMappingException { [EOL] MapType type = mock(MapType.class); [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] KeyDeserializer keyDeserializer = mock(KeyDeserializer.class); [EOL] TypeDeserializer elementTypeDeserializer = mock(TypeDeserializer.class); [EOL] JsonDeserializer<?> elementDeserializer = mock(JsonDeserializer.class); [EOL] JsonDeserializer<?> expectedDeserializer = mock(JsonDeserializer.class); [EOL] Deserializers mockDeserializers = mock(Deserializers.class); [EOL] when(mockDeserializers.findMapDeserializer(eq(type), eq(config), eq(beanDesc), eq(keyDeserializer), eq(elementTypeDeserializer), eq(elementDeserializer))).thenReturn(expectedDeserializer); [EOL] DeserializerFactoryConfig factoryConfig = mock(DeserializerFactoryConfig.class); [EOL] when(factoryConfig.deserializers()).thenReturn(Collections.singletonList(mockDeserializers)); [EOL] BasicDeserializerFactory factory = new BasicDeserializerFactory(factoryConfig); [EOL] JsonDeserializer<?> result = factory._findCustomMapDeserializer(type, config, beanDesc, keyDeserializer, elementTypeDeserializer, elementDeserializer); [EOL] assertSame(expectedDeserializer, result); [EOL] }
public void testFindCustomMapDeserializerWithNullDeserializer() throws JsonMappingException { [EOL] MapType type = mock(MapType.class); [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] KeyDeserializer keyDeserializer = mock(KeyDeserializer.class); [EOL] TypeDeserializer elementTypeDeserializer = mock(TypeDeserializer.class); [EOL] JsonDeserializer<?> elementDeserializer = mock(JsonDeserializer.class); [EOL] Deserializers mockDeserializers = mock(Deserializers.class); [EOL] when(mockDeserializers.findMapDeserializer(eq(type), eq(config), eq(beanDesc), eq(keyDeserializer), eq(elementTypeDeserializer), eq(elementDeserializer))).thenReturn(null); [EOL] DeserializerFactoryConfig factoryConfig = mock(DeserializerFactoryConfig.class); [EOL] when(factoryConfig.deserializers()).thenReturn(Collections.singletonList(mockDeserializers)); [EOL] BasicDeserializerFactory factory = new BasicDeserializerFactory(factoryConfig); [EOL] JsonDeserializer<?> result = factory._findCustomMapDeserializer(type, config, beanDesc, keyDeserializer, elementTypeDeserializer, elementDeserializer); [EOL] assertNull(result); [EOL] }
public void testFindCustomMapLikeDeserializerWithNonNullDeserializer() throws JsonMappingException { [EOL] MapLikeType type = mock(MapLikeType.class); [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] KeyDeserializer keyDeserializer = mock(KeyDeserializer.class); [EOL] TypeDeserializer elementTypeDeserializer = mock(TypeDeserializer.class); [EOL] JsonDeserializer<?> elementDeserializer = mock(JsonDeserializer.class); [EOL] JsonDeserializer<?> expectedDeserializer = mock(JsonDeserializer.class); [EOL] Deserializers mockDeserializers = mock(Deserializers.class); [EOL] when(mockDeserializers.findMapLikeDeserializer(eq(type), eq(config), eq(beanDesc), eq(keyDeserializer), eq(elementTypeDeserializer), eq(elementDeserializer))).thenReturn(expectedDeserializer); [EOL] DeserializerFactoryConfig factoryConfig = new DeserializerFactoryConfig(); [EOL] factoryConfig = spy(factoryConfig); [EOL] doReturn(Collections.singletonList(mockDeserializers)).when(factoryConfig).deserializers(); [EOL] BasicDeserializerFactory factory = new BasicDeserializerFactory(factoryConfig); [EOL] JsonDeserializer<?> result = factory._findCustomMapLikeDeserializer(type, config, beanDesc, keyDeserializer, elementTypeDeserializer, elementDeserializer); [EOL] assertSame(expectedDeserializer, result); [EOL] }
public void testFindCustomMapLikeDeserializerWithNullDeserializer() throws JsonMappingException { [EOL] MapLikeType type = mock(MapLikeType.class); [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] KeyDeserializer keyDeserializer = mock(KeyDeserializer.class); [EOL] TypeDeserializer elementTypeDeserializer = mock(TypeDeserializer.class); [EOL] JsonDeserializer<?> elementDeserializer = mock(JsonDeserializer.class); [EOL] Deserializers mockDeserializers = mock(Deserializers.class); [EOL] when(mockDeserializers.findMapLikeDeserializer(eq(type), eq(config), eq(beanDesc), eq(keyDeserializer), eq(elementTypeDeserializer), eq(elementDeserializer))).thenReturn(null); [EOL] DeserializerFactoryConfig factoryConfig = new DeserializerFactoryConfig(); [EOL] factoryConfig = spy(factoryConfig); [EOL] doReturn(Collections.singletonList(mockDeserializers)).when(factoryConfig).deserializers(); [EOL] BasicDeserializerFactory factory = new BasicDeserializerFactory(factoryConfig); [EOL] JsonDeserializer<?> result = factory._findCustomMapLikeDeserializer(type, config, beanDesc, keyDeserializer, elementTypeDeserializer, elementDeserializer); [EOL] assertNull(result); [EOL] }
public void testFindCustomTreeNodeDeserializerWithNonNullDeserializer() throws JsonMappingException { [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] Deserializers deserializers = mock(Deserializers.class); [EOL] JsonDeserializer<?> expectedDeserializer = mock(JsonDeserializer.class); [EOL] when(deserializers.findTreeNodeDeserializer(any(Class.class), any(DeserializationConfig.class), any(BeanDescription.class))).thenReturn(expectedDeserializer); [EOL] DeserializerFactoryConfig factoryConfig = new DeserializerFactoryConfig(); [EOL] factoryConfig = factoryConfig.withAdditionalDeserializers(deserializers); [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] mapper.setConfig(config.with(factoryConfig)); [EOL] BasicDeserializerFactory factory = (BasicDeserializerFactory) mapper.getDeserializationContext().getFactory(); [EOL] JsonDeserializer<?> result = factory._findCustomTreeNodeDeserializer(JsonNode.class, config, beanDesc); [EOL] assertNotNull(result); [EOL] assertSame(expectedDeserializer, result); [EOL] }
public void testFindCustomTreeNodeDeserializerWithNullDeserializer() throws JsonMappingException { [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] Deserializers deserializers = mock(Deserializers.class); [EOL] when(deserializers.findTreeNodeDeserializer(any(Class.class), any(DeserializationConfig.class), any(BeanDescription.class))).thenReturn(null); [EOL] DeserializerFactoryConfig factoryConfig = new DeserializerFactoryConfig(); [EOL] factoryConfig = factoryConfig.withAdditionalDeserializers(deserializers); [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] mapper.setConfig(config.with(factoryConfig)); [EOL] BasicDeserializerFactory factory = (BasicDeserializerFactory) mapper.getDeserializationContext().getFactory(); [EOL] JsonDeserializer<?> result = factory._findCustomTreeNodeDeserializer(JsonNode.class, config, beanDesc); [EOL] assertNull(result); [EOL] }
public void testCreateKeyDeserializerWithKeyDeserializers() throws JsonMappingException { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] JavaType type = createJavaType(); [EOL] DeserializationConfig config = ctxt.getConfig(); [EOL] BeanDescription beanDesc = config.introspectClassAnnotations(type.getRawClass()); [EOL] KeyDeserializers mockKeyDeserializers = createMockKeyDeserializers(); [EOL] KeyDeserializer expectedDeserializer = createMockKeyDeserializer(); [EOL] when(mockKeyDeserializers.findKeyDeserializer(eq(type), eq(config), eq(beanDesc))).thenReturn(expectedDeserializer); [EOL] addKeyDeserializersToFactoryConfig(mockKeyDeserializers); [EOL] KeyDeserializer result = createKeyDeserializer(ctxt, type); [EOL] assertNotNull(result); [EOL] assertSame(expectedDeserializer, result); [EOL] }
public void testCreateKeyDeserializerWithEnumType() throws JsonMappingException { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] JavaType type = createEnumJavaType(); [EOL] KeyDeserializer expectedDeserializer = createMockKeyDeserializer(); [EOL] when(_createEnumKeyDeserializer(ctxt, type)).thenReturn(expectedDeserializer); [EOL] KeyDeserializer result = createKeyDeserializer(ctxt, type); [EOL] assertNotNull(result); [EOL] assertSame(expectedDeserializer, result); [EOL] }
public void testCreateKeyDeserializerWithModifier() throws JsonMappingException { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] JavaType type = createJavaType(); [EOL] DeserializationConfig config = ctxt.getConfig(); [EOL] KeyDeserializer baseDeserializer = createMockKeyDeserializer(); [EOL] KeyDeserializer modifiedDeserializer = createMockKeyDeserializer(); [EOL] BeanDeserializerModifier modifier = createMockBeanDeserializerModifier(); [EOL] when(StdKeyDeserializers.findStringBasedKeyDeserializer(config, type)).thenReturn(baseDeserializer); [EOL] when(modifier.modifyKeyDeserializer(eq(config), eq(type), eq(baseDeserializer))).thenReturn(modifiedDeserializer); [EOL] addDeserializerModifiersToFactoryConfig(modifier); [EOL] KeyDeserializer result = createKeyDeserializer(ctxt, type); [EOL] assertNotNull(result); [EOL] assertSame(modifiedDeserializer, result); [EOL] }
public void testCreateKeyDeserializerWithoutModifiersOrKeyDeserializers() throws JsonMappingException { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] JavaType type = createJavaType(); [EOL] DeserializationConfig config = ctxt.getConfig(); [EOL] KeyDeserializer expectedDeserializer = createMockKeyDeserializer(); [EOL] when(StdKeyDeserializers.findStringBasedKeyDeserializer(config, type)).thenReturn(expectedDeserializer); [EOL] KeyDeserializer result = createKeyDeserializer(ctxt, type); [EOL] assertNotNull(result); [EOL] assertSame(expectedDeserializer, result); [EOL] }
public void testFindPropertyContentTypeDeserializerWithNullBuilder() throws JsonMappingException { [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] JavaType containerType = mock(JavaType.class); [EOL] AnnotatedMember propertyEntity = mock(AnnotatedMember.class); [EOL] AnnotationIntrospector ai = mock(AnnotationIntrospector.class); [EOL] JavaType contentType = mock(JavaType.class); [EOL] when(config.getAnnotationIntrospector()).thenReturn(ai); [EOL] when(ai.findPropertyContentTypeResolver(config, propertyEntity, containerType)).thenReturn(null); [EOL] when(containerType.getContentType()).thenReturn(contentType); [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] TypeDeserializer typeDeserializer = mapper.findPropertyContentTypeDeserializer(config, containerType, propertyEntity); [EOL] assertNotNull(typeDeserializer); [EOL] }
public void testFindPropertyContentTypeDeserializerWithNonNullBuilder() throws JsonMappingException { [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] JavaType containerType = mock(JavaType.class); [EOL] AnnotatedMember propertyEntity = mock(AnnotatedMember.class); [EOL] AnnotationIntrospector ai = mock(AnnotationIntrospector.class); [EOL] TypeResolverBuilder<?> builder = mock(TypeResolverBuilder.class); [EOL] JavaType contentType = mock(JavaType.class); [EOL] TypeDeserializer expectedDeserializer = mock(TypeDeserializer.class); [EOL] Collection<NamedType> subtypes = new ArrayList<>(); [EOL] when(config.getAnnotationIntrospector()).thenReturn(ai); [EOL] when(ai.findPropertyContentTypeResolver(config, propertyEntity, containerType)).thenReturn(builder); [EOL] when(containerType.getContentType()).thenReturn(contentType); [EOL] when(config.getSubtypeResolver().collectAndResolveSubtypes(propertyEntity, config, ai, contentType)).thenReturn(subtypes); [EOL] when(builder.buildTypeDeserializer(config, contentType, subtypes)).thenReturn(expectedDeserializer); [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] TypeDeserializer typeDeserializer = mapper.findPropertyContentTypeDeserializer(config, containerType, propertyEntity); [EOL] assertSame(expectedDeserializer, typeDeserializer); [EOL] }
public void testFindDefaultDeserializerWithPrimitiveType() { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JavaType type = mock(JavaType.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] when(type.getRawClass()).thenReturn(int.class); [EOL] JsonDeserializer<?> result = findDefaultDeserializer(ctxt, type, beanDesc); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof NumberDeserializers.IntDeserializer); [EOL] }
public void testFindDefaultDeserializerWithStringType() { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JavaType type = mock(JavaType.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] when(type.getRawClass()).thenReturn(String.class); [EOL] JsonDeserializer<?> result = findDefaultDeserializer(ctxt, type, beanDesc); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof StringDeserializer); [EOL] }
public void testFindDefaultDeserializerWithIterableType() { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JavaType type = mock(JavaType.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] when(type.getRawClass()).thenReturn(Iterable.class); [EOL] when(type.containedTypeCount()).thenReturn(1); [EOL] when(type.containedType(0)).thenReturn(TypeFactory.defaultInstance().constructSimpleType(Object.class, null)); [EOL] when(ctxt.getTypeFactory()).thenReturn(TypeFactory.defaultInstance()); [EOL] JsonDeserializer<?> result = findDefaultDeserializer(ctxt, type, beanDesc); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof CollectionDeserializer); [EOL] }
public void testFindDefaultDeserializerWithUnknownType() { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JavaType type = mock(JavaType.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] when(type.getRawClass()).thenReturn(Object.class); [EOL] when(type.getRawClass().getName()).thenReturn("com.unknown.Type"); [EOL] JsonDeserializer<?> result = findDefaultDeserializer(ctxt, type, beanDesc); [EOL] assertNull(result); [EOL] }
public void testFindDefaultDeserializerWithJacksonType() { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JavaType type = mock(JavaType.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] when(type.getRawClass()).thenReturn(Object.class); [EOL] when(type.getRawClass().getName()).thenReturn("com.fasterxml.jackson.databind.JsonNode"); [EOL] JsonDeserializer<?> result = findDefaultDeserializer(ctxt, type, beanDesc); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof JacksonDeserializers.JsonNodeDeserializer); [EOL] }
public void testModifyTypeByAnnotationWithSubclass() throws JsonMappingException { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] Annotated a = createAnnotated(); [EOL] JavaType type = createJavaType(); [EOL] AnnotationIntrospector intr = createAnnotationIntrospectorWithDeserializationType(type.getRawClass()); [EOL] when(ctxt.getAnnotationIntrospector()).thenReturn(intr); [EOL] JavaType result = modifyTypeByAnnotation(ctxt, a, type); [EOL] assertNotNull(result); [EOL] assertNotSame(type, result); [EOL] }
public void testModifyTypeByAnnotationWithInvalidSubclass() { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] Annotated a = createAnnotated(); [EOL] JavaType type = createJavaType(); [EOL] AnnotationIntrospector intr = createAnnotationIntrospectorWithInvalidDeserializationType(); [EOL] when(ctxt.getAnnotationIntrospector()).thenReturn(intr); [EOL] try { [EOL] modifyTypeByAnnotation(ctxt, a, type); [EOL] fail("Expected JsonMappingException"); [EOL] } catch (JsonMappingException e) { [EOL] } [EOL] }
public void testModifyTypeByAnnotationWithKeyClass() throws JsonMappingException { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] Annotated a = createAnnotated(); [EOL] MapLikeType type = createMapLikeType(); [EOL] AnnotationIntrospector intr = createAnnotationIntrospectorWithKeyDeserializationType(type.getKeyType().getRawClass()); [EOL] when(ctxt.getAnnotationIntrospector()).thenReturn(intr); [EOL] JavaType result = modifyTypeByAnnotation(ctxt, a, type); [EOL] assertNotNull(result); [EOL] assertTrue(result.isContainerType()); [EOL] assertNotSame(type, result); [EOL] }
public void testModifyTypeByAnnotationWithInvalidKeyClass() { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] Annotated a = createAnnotated(); [EOL] JavaType type = createJavaType(); // Not a MapLikeType [EOL] AnnotationIntrospector intr = createAnnotationIntrospectorWithKeyDeserializationType(Object.class); [EOL] when(ctxt.getAnnotationIntrospector()).thenReturn(intr); [EOL] try { [EOL] modifyTypeByAnnotation(ctxt, a, type); [EOL] fail("Expected JsonMappingException"); [EOL] } catch (JsonMappingException e) { [EOL] } [EOL] }
public void testModifyTypeByAnnotationWithContentType() throws JsonMappingException { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] Annotated a = createAnnotated(); [EOL] MapLikeType type = createMapLikeType(); [EOL] AnnotationIntrospector intr = createAnnotationIntrospectorWithContentDeserializationType(type.getContentType().getRawClass()); [EOL] when(ctxt.getAnnotationIntrospector()).thenReturn(intr); [EOL] JavaType result = modifyTypeByAnnotation(ctxt, a, type); [EOL] assertNotNull(result); [EOL] assertTrue(result.isContainerType()); [EOL] assertNotSame(type, result); [EOL] }
public void testModifyTypeByAnnotationWithInvalidContentType() { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] Annotated a = createAnnotated(); [EOL] MapLikeType type = createMapLikeType(); [EOL] AnnotationIntrospector intr = createAnnotationIntrospectorWithInvalidContentDeserializationType(); [EOL] when(ctxt.getAnnotationIntrospector()).thenReturn(intr); [EOL] try { [EOL] modifyTypeByAnnotation(ctxt, a, type); [EOL] fail("Expected JsonMappingException"); [EOL] } catch (JsonMappingException e) { [EOL] } [EOL] }
public void testResolveTypeWithContainerTypeAndKeyDeserializer() throws JsonMappingException { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] BeanDescription beanDesc = createBeanDescription(); [EOL] JavaType containerType = createContainerType(); [EOL] AnnotatedMember member = createAnnotatedMemberWithKeyDeserializer(); [EOL] JavaType resultType = resolveType(ctxt, beanDesc, containerType, member); [EOL] assertNotNull(resultType.getKeyType()); [EOL] assertNotNull(resultType.getKeyValueHandler()); [EOL] }
public void testResolveTypeWithContainerTypeAndContentDeserializer() throws JsonMappingException { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] BeanDescription beanDesc = createBeanDescription(); [EOL] JavaType containerType = createContainerType(); [EOL] AnnotatedMember member = createAnnotatedMemberWithContentDeserializer(); [EOL] JavaType resultType = resolveType(ctxt, beanDesc, containerType, member); [EOL] assertNotNull(resultType.getContentType()); [EOL] assertNotNull(resultType.getContentValueHandler()); [EOL] }
public void testResolveTypeWithContainerTypeAndContentTypeDeserializer() throws JsonMappingException { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] BeanDescription beanDesc = createBeanDescription(); [EOL] JavaType containerType = createContainerType(); [EOL] AnnotatedMember member = createAnnotatedMemberWithContentTypeDeserializer(); [EOL] JavaType resultType = resolveType(ctxt, beanDesc, containerType, member); [EOL] assertNotNull(resultType.getContentType()); [EOL] assertNotNull(resultType.getContentTypeHandler()); [EOL] }
public void testResolveTypeWithValueTypeDeserializer() throws JsonMappingException { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] BeanDescription beanDesc = createBeanDescription(); [EOL] JavaType nonContainerType = createNonContainerType(); [EOL] AnnotatedMember member = createAnnotatedMemberWithValueTypeDeserializer(); [EOL] JavaType resultType = resolveType(ctxt, beanDesc, nonContainerType, member); [EOL] assertNotNull(resultType.getTypeHandler()); [EOL] }
public void testResolveTypeWithoutTypeDeserializer() throws JsonMappingException { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] BeanDescription beanDesc = createBeanDescription(); [EOL] JavaType nonContainerType = createNonContainerType(); [EOL] AnnotatedMember member = createAnnotatedMemberWithoutTypeDeserializer(); [EOL] JavaType resultType = resolveType(ctxt, beanDesc, nonContainerType, member); [EOL] assertNull(resultType.getTypeHandler()); [EOL] }
protected DefaultSerializerProvider(SerializerProvider src, SerializationConfig config, SerializerFactory f) { [EOL] super(src, config, f); [EOL] }
public void testSerializeValueWithNullValue() throws IOException { [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] Object value = null; [EOL] serializeValue(jgen, value); [EOL] verify(getDefaultNullValueSerializer()).serialize(null, jgen, this); [EOL] verify(jgen, never()).writeStartObject(); [EOL] verify(jgen, never()).writeFieldName(anyString()); [EOL] verify(jgen, never()).writeEndObject(); [EOL] }
public void testSerializeValueWithNonNullValueWithoutWrap() throws IOException { [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] Object value = new Object(); [EOL] when(_config.getRootName()).thenReturn(""); [EOL] when(_config.isEnabled(SerializationFeature.WRAP_ROOT_VALUE)).thenReturn(false); [EOL] serializeValue(jgen, value); [EOL] verify(findTypedValueSerializer(Object.class, true, null)).serialize(value, jgen, this); [EOL] verify(jgen, never()).writeStartObject(); [EOL] verify(jgen, never()).writeFieldName(anyString()); [EOL] verify(jgen, never()).writeEndObject(); [EOL] }
public void testSerializeValueWithNonNullValueWithWrap() throws IOException { [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] Object value = new Object(); [EOL] when(_config.getRootName()).thenReturn(null); [EOL] when(_config.isEnabled(SerializationFeature.WRAP_ROOT_VALUE)).thenReturn(true); [EOL] when(_rootNames.findRootName(Object.class, _config)).thenReturn("root"); [EOL] serializeValue(jgen, value); [EOL] verify(findTypedValueSerializer(Object.class, true, null)).serialize(value, jgen, this); [EOL] verify(jgen).writeStartObject(); [EOL] verify(jgen).writeFieldName("root"); [EOL] verify(jgen).writeEndObject(); [EOL] }
public void testSerializeValueWithNonNullValueWithExplicitRootName() throws IOException { [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] Object value = new Object(); [EOL] String rootName = "explicitRoot"; [EOL] when(_config.getRootName()).thenReturn(rootName); [EOL] serializeValue(jgen, value); [EOL] verify(findTypedValueSerializer(Object.class, true, null)).serialize(value, jgen, this); [EOL] verify(jgen).writeStartObject(); [EOL] verify(jgen).writeFieldName(rootName); [EOL] verify(jgen).writeEndObject(); [EOL] }
public void testSerializeValueWithIOException() { [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] Object value = new Object(); [EOL] IOException ioe = new IOException(); [EOL] JsonSerializer<Object> ser = findTypedValueSerializer(Object.class, true, null); [EOL] doThrow(ioe).when(ser).serialize(any(), any(JsonGenerator.class), any(SerializerProvider.class)); [EOL] assertThrows(IOException.class, () -> serializeValue(jgen, value)); [EOL] }
public void testSerializeValueWithGenericException() { [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] Object value = new Object(); [EOL] Exception e = new Exception("error"); [EOL] JsonSerializer<Object> ser = findTypedValueSerializer(Object.class, true, null); [EOL] doThrow(e).when(ser).serialize(any(), any(JsonGenerator.class), any(SerializerProvider.class)); [EOL] Exception exception = assertThrows(JsonMappingException.class, () -> serializeValue(jgen, value)); [EOL] assertEquals("error", exception.getMessage()); [EOL] }
public void testGenerateJsonSchemaWithNullClass() { [EOL] try { [EOL] objectMapper.generateJsonSchema(null); [EOL] fail("Expected IllegalArgumentException for null class"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("A class must be provided", e.getMessage()); [EOL] } catch (JsonMappingException e) { [EOL] fail("Expected IllegalArgumentException, not JsonMappingException"); [EOL] } [EOL] }
public void testGenerateJsonSchemaWithNonJsonClass() { [EOL] try { [EOL] objectMapper.generateJsonSchema(NonJsonClass.class); [EOL] fail("Expected IllegalArgumentException for class not serializable as JSON object"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertTrue(e.getMessage().contains("would not be serialized as a JSON object and therefore has no schema")); [EOL] } catch (JsonMappingException e) { [EOL] fail("Expected IllegalArgumentException, not JsonMappingException"); [EOL] } [EOL] }
public void testGenerateJsonSchemaWithValidClass() throws JsonMappingException { [EOL] com.fasterxml.jackson.databind.jsonschema.JsonSchema jsonSchema = objectMapper.generateJsonSchema(ValidJsonClass.class); [EOL] assertNotNull(jsonSchema); [EOL] assertTrue(jsonSchema.isObjectSchema()); [EOL] }
public void testSerializerInstanceWithNull() { [EOL] JsonSerializer<Object> result = serializerInstance(null, null); [EOL] assertNull(result); [EOL] }
public void testSerializerInstanceWithJsonSerializer() { [EOL] JsonSerializer<Object> expectedSerializer = new MyJsonSerializer<>(); [EOL] JsonSerializer<Object> result = serializerInstance(null, expectedSerializer); [EOL] assertSame(expectedSerializer, result); [EOL] }
public void testSerializerInstanceWithInvalidType() { [EOL] Object invalidSerDef = new Object(); [EOL] try { [EOL] serializerInstance(null, invalidSerDef); [EOL] fail("Expected IllegalStateException to be thrown"); [EOL] } catch (IllegalStateException e) { [EOL] assertEquals("AnnotationIntrospector returned serializer definition of type java.lang.Object; expected type JsonSerializer or Class<JsonSerializer> instead", e.getMessage()); [EOL] } [EOL] }
public void testSerializerInstanceWithNoneClass() { [EOL] JsonSerializer<Object> result = serializerInstance(null, JsonSerializer.None.class); [EOL] assertNull(result); [EOL] }
public void testSerializerInstanceWithNoClass() { [EOL] JsonSerializer<Object> result = serializerInstance(null, NoClass.class); [EOL] assertNull(result); [EOL] }
public void testSerializerInstanceWithNonAssignableClass() { [EOL] try { [EOL] serializerInstance(null, String.class); [EOL] fail("Expected IllegalStateException to be thrown"); [EOL] } catch (IllegalStateException e) { [EOL] assertEquals("AnnotationIntrospector returned Class java.lang.String; expected Class<JsonSerializer>", e.getMessage()); [EOL] } [EOL] }
public void testSerializerInstanceWithAssignableClassAndNoHandlerInstantiator() { [EOL] JsonSerializer<Object> result = serializerInstance(null, MyJsonSerializer.class); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof MyJsonSerializer); [EOL] }
public void testSerializerInstanceWithAssignableClassAndHandlerInstantiator() { [EOL] HandlerInstantiator hi = new MyHandlerInstantiator(); [EOL] _config.setHandlerInstantiator(hi); [EOL] JsonSerializer<Object> result = serializerInstance(null, MyJsonSerializer.class); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof MyJsonSerializer); [EOL] }
public void testImplConstructor() { [EOL] SerializerProvider src = mock(SerializerProvider.class); [EOL] SerializationConfig config = mock(SerializationConfig.class); [EOL] SerializerFactory f = mock(SerializerFactory.class); [EOL] Impl impl = new Impl(src, config, f); [EOL] }
public void testCreateInstanceWithNonNullValues() { [EOL] SerializationConfig config = new SerializationConfig(...); // Provide actual initialization [EOL] SerializerFactory jsf = new SerializerFactoryImpl(); // Provide actual initialization [EOL] Impl result = createInstance(config, jsf); [EOL] assertNotNull(result); [EOL] assertSame(config, result.getConfig()); [EOL] assertSame(jsf, result.getSerializerFactory()); [EOL] }
public void testBeanDeserializerConstructorWithBase() { [EOL] BeanDeserializerBase src = new BeanDeserializerBase(); // Assuming a constructor or a way to create a BeanDeserializerBase instance [EOL] BeanDeserializer deserializer = new BeanDeserializer(src); [EOL] assertNotNull(deserializer); [EOL] assertEquals(src._ignoreAllUnknown, deserializer._ignoreAllUnknown); [EOL] }
public void testDeserializeOtherWithNullToken() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(null); [EOL] try { [EOL] _deserializeOther(jp, ctxt, null); [EOL] fail("Expected an exception for null JsonToken"); [EOL] } catch (Exception e) { [EOL] } [EOL] }
public void testDeserializeOtherWithValueString() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] Object result = _deserializeOther(jp, ctxt, JsonToken.VALUE_STRING); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeOtherWithValueNumberInt() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); [EOL] Object result = _deserializeOther(jp, ctxt, JsonToken.VALUE_NUMBER_INT); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeOtherWithValueNumberFloat() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_FLOAT); [EOL] Object result = _deserializeOther(jp, ctxt, JsonToken.VALUE_NUMBER_FLOAT); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeOtherWithValueEmbeddedObject() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object embeddedObject = new Object(); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_EMBEDDED_OBJECT); [EOL] when(jp.getEmbeddedObject()).thenReturn(embeddedObject); [EOL] Object result = _deserializeOther(jp, ctxt, JsonToken.VALUE_EMBEDDED_OBJECT); [EOL] assertSame(embeddedObject, result); [EOL] }
public void testDeserializeOtherWithValueTrue() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_TRUE); [EOL] Object result = _deserializeOther(jp, ctxt, JsonToken.VALUE_TRUE); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeOtherWithValueFalse() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_FALSE); [EOL] Object result = _deserializeOther(jp, ctxt, JsonToken.VALUE_FALSE); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeOtherWithStartArray() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_ARRAY); [EOL] Object result = _deserializeOther(jp, ctxt, JsonToken.START_ARRAY); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeOtherWithFieldName() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.FIELD_NAME); [EOL] _vanillaProcessing = true; // Assuming this is a field that can be set in the test [EOL] Object result = _deserializeOther(jp, ctxt, JsonToken.FIELD_NAME); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeOtherWithEndObject() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.END_OBJECT); [EOL] _vanillaProcessing = false; // Assuming this is a field that can be set in the test [EOL] _objectIdReader = null; // Assuming this is a field that can be set in the test [EOL] Object result = _deserializeOther(jp, ctxt, JsonToken.END_OBJECT); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeOtherWithInvalidToken() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.NOT_AVAILABLE); [EOL] try { [EOL] _deserializeOther(jp, ctxt, JsonToken.NOT_AVAILABLE); [EOL] fail("Expected an exception for invalid JsonToken"); [EOL] } catch (JsonMappingException e) { [EOL] } [EOL] }
public void testDeserializeWithInjectables() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object bean = new Object(); [EOL] BeanDeserializerBase instance = createInstanceWithInjectables(); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); [EOL] when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME).thenReturn(JsonToken.END_OBJECT); [EOL] when(jp.getCurrentName()).thenReturn("propName"); [EOL] Object result = instance.deserialize(jp, ctxt, bean); [EOL] assertNotNull(result); [EOL] verify(instance, times(1)).injectValues(ctxt, bean); [EOL] }
public void testDeserializeWithUnwrapped() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object bean = new Object(); [EOL] BeanDeserializerBase instance = createInstanceWithUnwrappedPropertyHandler(); [EOL] Object result = instance.deserialize(jp, ctxt, bean); [EOL] assertNotNull(result); [EOL] verify(instance, times(1)).deserializeWithUnwrapped(jp, ctxt, bean); [EOL] }
public void testDeserializeWithExternalTypeId() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object bean = new Object(); [EOL] BeanDeserializerBase instance = createInstanceWithExternalTypeIdHandler(); [EOL] Object result = instance.deserialize(jp, ctxt, bean); [EOL] assertNotNull(result); [EOL] verify(instance, times(1)).deserializeWithExternalTypeId(jp, ctxt, bean); [EOL] }
public void testDeserializeWithView() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object bean = new Object(); [EOL] Class<?> view = Object.class; [EOL] BeanDeserializerBase instance = createInstanceWithViewProcessing(); [EOL] when(ctxt.getActiveView()).thenReturn(view); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); [EOL] when(jp.nextToken()).thenReturn(JsonToken.END_OBJECT); [EOL] Object result = instance.deserialize(jp, ctxt, bean); [EOL] assertNotNull(result); [EOL] verify(instance, times(1)).deserializeWithView(jp, ctxt, bean, view); [EOL] }
public void testDeserializeWithKnownProperties() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object bean = new Object(); [EOL] String propName = "knownProperty"; [EOL] SettableBeanProperty prop = mock(SettableBeanProperty.class); [EOL] BeanPropertyMap beanProperties = mock(BeanPropertyMap.class); [EOL] BeanDeserializerBase instance = createInstanceWithBeanProperties(beanProperties); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT).thenReturn(JsonToken.FIELD_NAME).thenReturn(JsonToken.END_OBJECT); [EOL] when(jp.getCurrentName()).thenReturn(propName); [EOL] when(jp.nextToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(beanProperties.find(propName)).thenReturn(prop); [EOL] Object result = instance.deserialize(jp, ctxt, bean); [EOL] assertNotNull(result); [EOL] verify(prop, times(1)).deserializeAndSet(jp, ctxt, bean); [EOL] }
public void testDeserializeWithIgnorableProperties() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object bean = new Object(); [EOL] String propName = "ignorableProperty"; [EOL] HashSet<String> ignorableProps = new HashSet<>(); [EOL] ignorableProps.add(propName); [EOL] BeanDeserializerBase instance = createInstanceWithIgnorableProperties(ignorableProps); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT).thenReturn(JsonToken.FIELD_NAME).thenReturn(JsonToken.END_OBJECT); [EOL] when(jp.getCurrentName()).thenReturn(propName); [EOL] when(jp.nextToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] Object result = instance.deserialize(jp, ctxt, bean); [EOL] assertNotNull(result); [EOL] verify(jp, times(1)).skipChildren(); [EOL] }
public void testDeserializeWithAnySetter() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object bean = new Object(); [EOL] String propName = "anyProperty"; [EOL] AnySetter anySetter = mock(AnySetter.class); [EOL] BeanDeserializerBase instance = createInstanceWithAnySetter(anySetter); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT).thenReturn(JsonToken.FIELD_NAME).thenReturn(JsonToken.END_OBJECT); [EOL] when(jp.getCurrentName()).thenReturn(propName); [EOL] when(jp.nextToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] Object result = instance.deserialize(jp, ctxt, bean); [EOL] assertNotNull(result); [EOL] verify(anySetter, times(1)).deserializeAndSet(jp, ctxt, bean, propName); [EOL] }
public void testDeserializeWithUnknownProperties() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object bean = new Object(); [EOL] String propName = "unknownProperty"; [EOL] BeanDeserializerBase instance = createInstanceWithoutAnySetterOrIgnorableProperties(); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT).thenReturn(JsonToken.FIELD_NAME).thenReturn(JsonToken.END_OBJECT); [EOL] when(jp.getCurrentName()).thenReturn(propName); [EOL] when(jp.nextToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] Object result = instance.deserialize(jp, ctxt, bean); [EOL] assertNotNull(result); [EOL] verify(instance, times(1)).handleUnknownProperty(jp, ctxt, bean, propName); [EOL] }
public void testDeserializeFromObjectWithNonStandardCreationAndUnwrapped() throws IOException, JsonProcessingException { [EOL] setupNonStandardCreationWithUnwrapped(); [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object result = deserializeFromObject(jp, ctxt); [EOL] assertNotNull(result); [EOL] verifyDeserializeWithUnwrapped(result); [EOL] }
public void testDeserializeFromObjectWithNonStandardCreationAndExternalTypeId() throws IOException, JsonProcessingException { [EOL] setupNonStandardCreationWithExternalTypeId(); [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object result = deserializeFromObject(jp, ctxt); [EOL] assertNotNull(result); [EOL] verifyDeserializeWithExternalTypeId(result); [EOL] }
public void testDeserializeFromObjectUsingNonDefault() throws IOException, JsonProcessingException { [EOL] setupNonStandardCreation(); [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object result = deserializeFromObject(jp, ctxt); [EOL] assertNotNull(result); [EOL] verifyDeserializeFromObjectUsingNonDefault(result); [EOL] }
public void testDeserializeFromObjectWithInjectables() throws IOException, JsonProcessingException { [EOL] setupWithInjectables(); [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object bean = _valueInstantiator.createUsingDefault(ctxt); [EOL] injectValues(ctxt, bean); [EOL] Object result = deserializeFromObject(jp, ctxt); [EOL] assertNotNull(result); [EOL] verifyInjectValues(bean, result); [EOL] }
public void testDeserializeFromObjectWithViewProcessing() throws IOException, JsonProcessingException { [EOL] setupWithViewProcessing(); [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(ctxt.getActiveView()).thenReturn(SomeViewClass.class); [EOL] Object bean = _valueInstantiator.createUsingDefault(ctxt); [EOL] Object result = deserializeWithView(jp, ctxt, bean, SomeViewClass.class); [EOL] assertNotNull(result); [EOL] verifyDeserializeWithView(result); [EOL] }
public void testDeserializeFromObjectWithKnownProperties() throws IOException, JsonProcessingException { [EOL] setupWithKnownProperties(); [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT, JsonToken.FIELD_NAME, JsonToken.END_OBJECT); [EOL] when(jp.getCurrentName()).thenReturn("knownProperty"); [EOL] Object bean = _valueInstantiator.createUsingDefault(ctxt); [EOL] deserializeFromObject(jp, ctxt); [EOL] verifyPropertySet(bean, "knownProperty"); [EOL] }
public void testDeserializeFromObjectWithIgnorableProperties() throws IOException, JsonProcessingException { [EOL] setupWithIgnorableProperties(); [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT, JsonToken.FIELD_NAME, JsonToken.END_OBJECT); [EOL] when(jp.getCurrentName()).thenReturn("ignorableProperty"); [EOL] Object bean = _valueInstantiator.createUsingDefault(ctxt); [EOL] deserializeFromObject(jp, ctxt); [EOL] verifyPropertyIgnored(bean, "ignorableProperty"); [EOL] }
public void testDeserializeFromObjectWithAnySetter() throws IOException, JsonProcessingException { [EOL] setupWithAnySetter(); [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT, JsonToken.FIELD_NAME, JsonToken.END_OBJECT); [EOL] when(jp.getCurrentName()).thenReturn("dynamicProperty"); [EOL] Object bean = _valueInstantiator.createUsingDefault(ctxt); [EOL] deserializeFromObject(jp, ctxt); [EOL] verifyAnySetterCalled(bean, "dynamicProperty"); [EOL] }
public void testDeserializeFromObjectWithUnknownProperties() throws IOException, JsonProcessingException { [EOL] setupWithUnknownProperties(); [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT, JsonToken.FIELD_NAME, JsonToken.END_OBJECT); [EOL] when(jp.getCurrentName()).thenReturn("unknownProperty"); [EOL] Object bean = _valueInstantiator.createUsingDefault(ctxt); [EOL] deserializeFromObject(jp, ctxt); [EOL] verifyHandleUnknownProperty(bean, "unknownProperty"); [EOL] }
protected Object _deserializeUsingPropertyBased(final JsonParser jp, final DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL] final PropertyBasedCreator creator = _propertyBasedCreator; [EOL] PropertyValueBuffer buffer = creator.startBuilding(jp, ctxt, _objectIdReader); [EOL] TokenBuffer unknown = null; [EOL] JsonToken t = jp.getCurrentToken(); [EOL] for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) { [EOL] String propName = jp.getCurrentName(); [EOL] jp.nextToken(); [EOL] SettableBeanProperty creatorProp = creator.findCreatorProperty(propName); [EOL] if (creatorProp != null) { [EOL] Object value = creatorProp.deserialize(jp, ctxt); [EOL] if (buffer.assignParameter(creatorProp.getCreatorIndex(), value)) { [EOL] jp.nextToken(); [EOL] Object bean; [EOL] try { [EOL] bean = creator.build(ctxt, buffer); [EOL] } catch (Exception e) { [EOL] wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt); [EOL] bean = null; [EOL] } [EOL] if (bean.getClass() != _beanType.getRawClass()) { [EOL] return handlePolymorphic(jp, ctxt, bean, unknown); [EOL] } [EOL] if (unknown != null) { [EOL] bean = handleUnknownProperties(ctxt, bean, unknown); [EOL] } [EOL] return deserialize(jp, ctxt, bean); [EOL] } [EOL] continue; [EOL] } [EOL] if (buffer.readIdProperty(propName)) { [EOL] continue; [EOL] } [EOL] SettableBeanProperty prop = _beanProperties.find(propName); [EOL] if (prop != null) { [EOL] buffer.bufferProperty(prop, prop.deserialize(jp, ctxt)); [EOL] continue; [EOL] } [EOL] if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL] jp.skipChildren(); [EOL] continue; [EOL] } [EOL] if (_anySetter != null) { [EOL] buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(jp, ctxt)); [EOL] continue; [EOL] } [EOL] if (unknown == null) { [EOL] unknown = new TokenBuffer(jp.getCodec()); [EOL] } [EOL] unknown.writeFieldName(propName); [EOL] unknown.copyCurrentStructure(jp); [EOL] } [EOL] Object bean; [EOL] try { [EOL] bean = creator.build(ctxt, buffer); [EOL] } catch (Exception e) { [EOL] wrapInstantiationProblem(e, ctxt); [EOL] bean = null; [EOL] } [EOL] if (unknown != null) { [EOL] if (bean.getClass() != _beanType.getRawClass()) { [EOL] return handlePolymorphic(null, ctxt, bean, unknown); [EOL] } [EOL] return handleUnknownProperties(ctxt, bean, unknown); [EOL] } [EOL] return bean; [EOL] }
protected Object deserializeWithExternalTypeId(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL] if (_propertyBasedCreator != null) { [EOL] return deserializeUsingPropertyBasedWithExternalTypeId(jp, ctxt); [EOL] } [EOL] return deserializeWithExternalTypeId(jp, ctxt, _valueInstantiator.createUsingDefault(ctxt)); [EOL] }
protected Object deserializeUsingPropertyBasedWithExternalTypeId(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL] final ExternalTypeHandler ext = _externalTypeIdHandler.start(); [EOL] final PropertyBasedCreator creator = _propertyBasedCreator; [EOL] PropertyValueBuffer buffer = creator.startBuilding(jp, ctxt, _objectIdReader); [EOL] TokenBuffer tokens = new TokenBuffer(jp.getCodec()); [EOL] tokens.writeStartObject(); [EOL] JsonToken t = jp.getCurrentToken(); [EOL] for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) { [EOL] String propName = jp.getCurrentName(); [EOL] jp.nextToken(); [EOL] SettableBeanProperty creatorProp = creator.findCreatorProperty(propName); [EOL] if (creatorProp != null) { [EOL] if (ext.handlePropertyValue(jp, ctxt, propName, buffer)) { [EOL] ; [EOL] } else { [EOL] Object value = creatorProp.deserialize(jp, ctxt); [EOL] if (buffer.assignParameter(creatorProp.getCreatorIndex(), value)) { [EOL] t = jp.nextToken(); [EOL] Object bean; [EOL] try { [EOL] bean = creator.build(ctxt, buffer); [EOL] } catch (Exception e) { [EOL] wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt); [EOL] continue; [EOL] } [EOL] while (t == JsonToken.FIELD_NAME) { [EOL] jp.nextToken(); [EOL] tokens.copyCurrentStructure(jp); [EOL] t = jp.nextToken(); [EOL] } [EOL] if (bean.getClass() != _beanType.getRawClass()) { [EOL] throw ctxt.mappingException("Can not create polymorphic instances with unwrapped values"); [EOL] } [EOL] return ext.complete(jp, ctxt, bean); [EOL] } [EOL] } [EOL] continue; [EOL] } [EOL] if (buffer.readIdProperty(propName)) { [EOL] continue; [EOL] } [EOL] SettableBeanProperty prop = _beanProperties.find(propName); [EOL] if (prop != null) { [EOL] buffer.bufferProperty(prop, prop.deserialize(jp, ctxt)); [EOL] continue; [EOL] } [EOL] if (ext.handlePropertyValue(jp, ctxt, propName, null)) { [EOL] continue; [EOL] } [EOL] if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL] jp.skipChildren(); [EOL] continue; [EOL] } [EOL] if (_anySetter != null) { [EOL] buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(jp, ctxt)); [EOL] } [EOL] } [EOL] try { [EOL] return ext.complete(jp, ctxt, buffer, creator); [EOL] } catch (Exception e) { [EOL] wrapInstantiationProblem(e, ctxt); [EOL] return null; [EOL] } [EOL] }
public void testCreateContextualWithNonNullPropertyAndNonNullFormatAndDifferentSerializeAsIndex() throws JsonMappingException { [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] AnnotatedMember member = mock(AnnotatedMember.class); [EOL] JavaType javaType = mock(JavaType.class); [EOL] Class<?> rawClass = Enum.class; // Assuming Enum is the raw class for this test case [EOL] JsonFormat.Value format = mock(JsonFormat.Value.class); [EOL] AnnotationIntrospector introspector = mock(AnnotationIntrospector.class); [EOL] when(prov.getAnnotationIntrospector()).thenReturn(introspector); [EOL] when(property.getMember()).thenReturn(member); [EOL] when(introspector.findFormat(member)).thenReturn(format); [EOL] when(property.getType()).thenReturn(javaType); [EOL] when(javaType.getRawClass()).thenReturn(rawClass); [EOL] EnumSerializer originalSerializer = new EnumSerializer(null, true); [EOL] Boolean serializeAsIndex = false; // Assuming the original _serializeAsIndex is true [EOL] when(originalSerializer._isShapeWrittenUsingIndex(rawClass, format, false)).thenReturn(serializeAsIndex); [EOL] JsonSerializer<?> result = originalSerializer.createContextual(prov, property); [EOL] assertTrue(result instanceof EnumSerializer); [EOL] assertNotSame(originalSerializer, result); [EOL] }
public void testCreateContextualWithNonNullPropertyAndNonNullFormatAndSameSerializeAsIndex() throws JsonMappingException { [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] AnnotatedMember member = mock(AnnotatedMember.class); [EOL] JavaType javaType = mock(JavaType.class); [EOL] Class<?> rawClass = Enum.class; // Assuming Enum is the raw class for this test case [EOL] JsonFormat.Value format = mock(JsonFormat.Value.class); [EOL] AnnotationIntrospector introspector = mock(AnnotationIntrospector.class); [EOL] when(prov.getAnnotationIntrospector()).thenReturn(introspector); [EOL] when(property.getMember()).thenReturn(member); [EOL] when(introspector.findFormat(member)).thenReturn(format); [EOL] when(property.getType()).thenReturn(javaType); [EOL] when(javaType.getRawClass()).thenReturn(rawClass); [EOL] EnumSerializer originalSerializer = new EnumSerializer(null, true); [EOL] Boolean serializeAsIndex = true; // Assuming the original _serializeAsIndex is true [EOL] when(originalSerializer._isShapeWrittenUsingIndex(rawClass, format, false)).thenReturn(serializeAsIndex); [EOL] JsonSerializer<?> result = originalSerializer.createContextual(prov, property); [EOL] assertSame(originalSerializer, result); [EOL] }
public void testCreateContextualWithNonNullPropertyAndNullFormat() throws JsonMappingException { [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] AnnotatedMember member = mock(AnnotatedMember.class); [EOL] AnnotationIntrospector introspector = mock(AnnotationIntrospector.class); [EOL] when(prov.getAnnotationIntrospector()).thenReturn(introspector); [EOL] when(property.getMember()).thenReturn(member); [EOL] when(introspector.findFormat(member)).thenReturn(null); [EOL] EnumSerializer originalSerializer = new EnumSerializer(null, true); [EOL] JsonSerializer<?> result = originalSerializer.createContextual(prov, property); [EOL] assertSame(originalSerializer, result); [EOL] }
public void testCreateContextualWithNullProperty() throws JsonMappingException { [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] EnumSerializer originalSerializer = new EnumSerializer(null, true); [EOL] JsonSerializer<?> result = originalSerializer.createContextual(prov, null); [EOL] assertSame(originalSerializer, result); [EOL] }
public void testSerializeAsIndexTrue() throws IOException { [EOL] Enum<?> en = MyEnum.VALUE1; // Assuming MyEnum is an enum in the test context [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] when(provider.isEnabled(SerializationFeature.WRITE_ENUMS_USING_INDEX)).thenReturn(true); [EOL] new EnumSerializer(null, true).serialize(en, jgen, provider); [EOL] verify(jgen).writeNumber(en.ordinal()); [EOL] }
public void testSerializeAsIndexFalse() throws IOException { [EOL] Enum<?> en = MyEnum.VALUE2; // Assuming MyEnum is an enum in the test context [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] when(provider.isEnabled(SerializationFeature.WRITE_ENUMS_USING_INDEX)).thenReturn(false); [EOL] EnumValues values = mock(EnumValues.class); [EOL] when(values.serializedValueFor(en)).thenReturn("VALUE2"); [EOL] new EnumSerializer(values, false).serialize(en, jgen, provider); [EOL] verify(jgen).writeString("VALUE2"); [EOL] }
public void testSerializeAsIndexWhenConfigured() { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] when(provider.isEnabled(SerializationFeature.WRITE_ENUMS_USING_INDEX)).thenReturn(true); [EOL] MyEnumSerializer serializer = new MyEnumSerializer(null, true); [EOL] assertTrue(serializer._serializeAsIndex(provider)); [EOL] }
public void testSerializeAsIndexWhenNotConfigured() { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] when(provider.isEnabled(SerializationFeature.WRITE_ENUMS_USING_INDEX)).thenReturn(false); [EOL] MyEnumSerializer serializer = new MyEnumSerializer(null, null); [EOL] assertFalse(serializer._serializeAsIndex(provider)); [EOL] }
public void testIsShapeWrittenUsingIndex_NullFormat() { [EOL] Class<?> enumClass = MyEnum.class; [EOL] JsonFormat.Value format = null; [EOL] Boolean result = _isShapeWrittenUsingIndex(enumClass, format, true); [EOL] assertNull(result); [EOL] }
public void testIsShapeWrittenUsingIndex_ShapeAny() { [EOL] Class<?> enumClass = MyEnum.class; [EOL] JsonFormat.Value format = new JsonFormat.Value().withShape(JsonFormat.Shape.ANY); [EOL] Boolean result = _isShapeWrittenUsingIndex(enumClass, format, true); [EOL] assertNull(result); [EOL] }
public void testIsShapeWrittenUsingIndex_ShapeScalar() { [EOL] Class<?> enumClass = MyEnum.class; [EOL] JsonFormat.Value format = new JsonFormat.Value().withShape(JsonFormat.Shape.SCALAR); [EOL] Boolean result = _isShapeWrittenUsingIndex(enumClass, format, true); [EOL] assertNull(result); [EOL] }
public void testIsShapeWrittenUsingIndex_ShapeString() { [EOL] Class<?> enumClass = MyEnum.class; [EOL] JsonFormat.Value format = new JsonFormat.Value().withShape(JsonFormat.Shape.STRING); [EOL] Boolean result = _isShapeWrittenUsingIndex(enumClass, format, true); [EOL] assertEquals(Boolean.FALSE, result); [EOL] }
public void testIsShapeWrittenUsingIndex_ShapeNumeric() { [EOL] Class<?> enumClass = MyEnum.class; [EOL] JsonFormat.Value format = new JsonFormat.Value().withShape(JsonFormat.Shape.NUMBER); [EOL] Boolean result = _isShapeWrittenUsingIndex(enumClass, format, true); [EOL] assertEquals(Boolean.TRUE, result); [EOL] }
public void testIsShapeWrittenUsingIndex_UnsupportedShape() { [EOL] Class<?> enumClass = MyEnum.class; [EOL] JsonFormat.Value format = new JsonFormat.Value().withShape(JsonFormat.Shape.ARRAY); [EOL] try { [EOL] _isShapeWrittenUsingIndex(enumClass, format, true); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testGetReadOnlyLookupMapWhenMapIsNull() { [EOL] SerializerCache cache = new SerializerCache(); [EOL] ReadOnlyClassToSerializerMap result = cache.getReadOnlyLookupMap(); [EOL] assertNotNull(result); [EOL] }
public void testGetReadOnlyLookupMapWhenMapIsNotNull() { [EOL] SerializerCache cache = new SerializerCache(); [EOL] cache.getReadOnlyLookupMap(); [EOL] ReadOnlyClassToSerializerMap result = cache.getReadOnlyLookupMap(); [EOL] assertNotNull(result); [EOL] }
public void testUntypedValueSerializerWithExistingType() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] JsonSerializer<Object> serializer = mapper.getSerializerProviderInstance().untypedValueSerializer(String.class); [EOL] assertNotNull(serializer); [EOL] }
public void testUntypedValueSerializerWithNullType() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] try { [EOL] mapper.getSerializerProviderInstance().untypedValueSerializer(null); [EOL] fail("Should not pass with null type"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testUntypedValueSerializerWithExistingType() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] JavaType type = mapper.constructType(String.class); [EOL] JsonSerializer<Object> serializer = mapper.getSerializerProviderInstance().untypedValueSerializer(type); [EOL] assertNotNull(serializer); [EOL] }
public void testUntypedValueSerializerWithNewType() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] JavaType type = mapper.constructType(CustomClass.class); [EOL] JsonSerializer<Object> serializer = mapper.getSerializerProviderInstance().untypedValueSerializer(type); [EOL] assertNull(serializer); [EOL] }
public void testTypedValueSerializerWithExistingClass() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] JsonSerializer<Object> serializer = mapper.getSerializerProvider().typedValueSerializer(String.class); [EOL] assertNotNull(serializer); [EOL] }
public void testTypedValueSerializerWithNullClass() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] JsonSerializer<Object> serializer = mapper.getSerializerProvider().typedValueSerializer(null); [EOL] assertNull(serializer); [EOL] }
public void testAddTypedSerializer_NewTypeKey() { [EOL] SerializerProviderImpl provider = new SerializerProviderImpl(); [EOL] JsonSerializer<Object> serializer = new CustomJsonSerializer(); [EOL] Class<?> cls = String.class; [EOL] provider.addTypedSerializer(cls, serializer); [EOL] JsonSerializer<Object> retrievedSerializer = provider.findTypedValueSerializer(cls, true, null); [EOL] assertSame("Expected custom serializer to be returned", serializer, retrievedSerializer); [EOL] }
public void testAddTypedSerializer_ExistingTypeKey() { [EOL] SerializerProviderImpl provider = new SerializerProviderImpl(); [EOL] JsonSerializer<Object> firstSerializer = new CustomJsonSerializer(); [EOL] JsonSerializer<Object> secondSerializer = new CustomJsonSerializer(); [EOL] Class<?> cls = String.class; [EOL] provider.addTypedSerializer(cls, firstSerializer); [EOL] provider.addTypedSerializer(cls, secondSerializer); [EOL] JsonSerializer<Object> retrievedSerializer = provider.findTypedValueSerializer(cls, true, null); [EOL] assertNotSame("Expected second serializer to replace the first one", firstSerializer, retrievedSerializer); [EOL] assertSame("Expected second serializer to be returned", secondSerializer, retrievedSerializer); [EOL] }
public void testAddAndResolveNonTypedSerializerWithNonResolvableSerializer() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] JsonSerializer<Object> ser = mock(JsonSerializer.class); [EOL] Class<?> type = Object.class; [EOL] addAndResolveNonTypedSerializer(type, ser, provider); [EOL] }
public void testAddAndResolveNonTypedSerializerWithResolvableSerializer() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] ResolvableSerializer resolvableSer = mock(ResolvableSerializer.class); [EOL] Class<?> type = Object.class; [EOL] addAndResolveNonTypedSerializer(type, resolvableSer, provider); [EOL] verify(resolvableSer).resolve(provider); [EOL] }
public void testAddAndResolveNonTypedSerializerWithNonResolvableSerializer() throws JsonMappingException { [EOL] TypeKey typeKey = new TypeKey(type, false); [EOL] JsonSerializer<Object> ser = mock(JsonSerializer.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] CustomSerializerProvider customSerializerProvider = new CustomSerializerProvider(); [EOL] customSerializerProvider.addAndResolveNonTypedSerializer(type, ser, provider); [EOL] assertNull(customSerializerProvider._readOnlyMap); [EOL] verify(_sharedMap, times(1)).put(typeKey, ser); [EOL] verify(ser, never()).resolve(any(SerializerProvider.class)); [EOL] }
public void testAddAndResolveNonTypedSerializerWithResolvableSerializer() throws JsonMappingException { [EOL] TypeKey typeKey = new TypeKey(type, false); [EOL] ResolvableSerializer resolvableSerializer = mock(ResolvableSerializer.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] CustomSerializerProvider customSerializerProvider = new CustomSerializerProvider(); [EOL] customSerializerProvider.addAndResolveNonTypedSerializer(type, resolvableSerializer, provider); [EOL] assertNull(customSerializerProvider._readOnlyMap); [EOL] verify(_sharedMap, times(1)).put(typeKey, resolvableSerializer); [EOL] verify(resolvableSerializer, times(1)).resolve(provider); [EOL] }
public void testTypeKeyWithTypedTrue() { [EOL] Class<?> key = String.class; [EOL] boolean typed = true; [EOL] TypeKey typeKey = new TypeKey(key, typed); [EOL] assertEquals(key, typeKey._class); [EOL] assertNull(typeKey._type); [EOL] assertTrue(typeKey._isTyped); [EOL] assertEquals(typeKey._hashCode, typeKey.hash(key, typed)); [EOL] } [EOL] public void testTypeKeyWithTypedFalse() { [EOL] Class<?> key = Integer.class; [EOL] boolean typed = false; [EOL] TypeKey typeKey = new TypeKey(key, typed); [EOL] assertEquals(key, typeKey._class); [EOL] assertNull(typeKey._type); [EOL] assertFalse(typeKey._isTyped); [EOL] assertEquals(typeKey._hashCode, typeKey.hash(key, typed)); [EOL] }
public void testTypeKeyWithTypedTrue() { [EOL] JavaType key = new SimpleType(String.class); [EOL] boolean typed = true; [EOL] TypeKey typeKey = new TypeKey(key, typed); [EOL] assertEquals(key, typeKey._type); [EOL] assertNull(typeKey._class); [EOL] assertTrue(typeKey._isTyped); [EOL] assertEquals(typeKey._hashCode, typeKey.hash(key, typed)); [EOL] }
public void testTypeKeyWithTypedFalse() { [EOL] JavaType key = new SimpleType(Integer.class); [EOL] boolean typed = false; [EOL] TypeKey typeKey = new TypeKey(key, typed); [EOL] assertEquals(key, typeKey._type); [EOL] assertNull(typeKey._class); [EOL] assertFalse(typeKey._isTyped); [EOL] assertEquals(typeKey._hashCode, typeKey.hash(key, typed)); [EOL] }
public void testHashWithTypedTrue() { [EOL] Class<?> cls = String.class; [EOL] boolean typed = true; [EOL] int expectedHash = cls.getName().hashCode() + 1; [EOL] int actualHash = hash(cls, typed); [EOL] assertEquals(expectedHash, actualHash); [EOL] } [EOL] public void testHashWithTypedFalse() { [EOL] Class<?> cls = String.class; [EOL] boolean typed = false; [EOL] int expectedHash = cls.getName().hashCode(); [EOL] int actualHash = hash(cls, typed); [EOL] assertEquals(expectedHash, actualHash); [EOL] }
public void testHashWithTypedTrue() { [EOL] JavaType mockType = Mockito.mock(JavaType.class); [EOL] Mockito.when(mockType.hashCode()).thenReturn(123); [EOL] int result = hash(mockType, true); [EOL] assertEquals(121, result); [EOL] }
public void testHashWithTypedFalse() { [EOL] JavaType mockType = Mockito.mock(JavaType.class); [EOL] Mockito.when(mockType.hashCode()).thenReturn(123); [EOL] int result = hash(mockType, false); [EOL] assertEquals(122, result); [EOL] }
public void testResetUntypedWithNonNullClass() { [EOL] Class<?> cls = Object.class; // Use any class for testing [EOL] instance.resetUntyped(cls); [EOL] assertNull(instance._type); [EOL] assertEquals(cls, instance._class); [EOL] assertFalse(instance._isTyped); [EOL] assertEquals(instance.hash(cls, false), instance._hashCode); [EOL] }
public void testResetUntypedWithNonNullType() { [EOL] JavaType mockType = Mockito.mock(JavaType.class); [EOL] TypeReference<?> typeRef = new TypeReference<Object>() {}; [EOL] JavaType type = objectMapper.getTypeFactory().constructType(typeRef); [EOL] TypeWrappedSerializer instance = new TypeWrappedSerializer(mockType, null); [EOL] instance.resetUntyped(type); [EOL] assertEquals(type, instance._type); [EOL] assertNull(instance._class); [EOL] assertFalse(instance._isTyped); [EOL] assertEquals(instance._hashCode, instance.hash(type, false)); [EOL] }
public void testResetUntypedWithNullType() { [EOL] JavaType mockType = Mockito.mock(JavaType.class); [EOL] TypeWrappedSerializer instance = new TypeWrappedSerializer(mockType, null); [EOL] instance.resetUntyped(null); [EOL] assertNull(instance._type); [EOL] assertNull(instance._class); [EOL] assertFalse(instance._isTyped); [EOL] assertEquals(instance._hashCode, instance.hash(null, false)); [EOL] }
public void testHashCode() { [EOL] MyClass instance = new MyClass(123); [EOL] int expectedHashCode = 123; // Assuming the _hashCode field is set to 123 in the constructor [EOL] assertEquals(expectedHashCode, instance.hashCode()); [EOL] }
public void testEqualsWithNull() { [EOL] TypeKey key = new TypeKey(SomeClass.class, false); [EOL] assertFalse(key.equals(null)); [EOL] }
public void testEqualsWithSelf() { [EOL] TypeKey key = new TypeKey(SomeClass.class, false); [EOL] assertTrue(key.equals(key)); [EOL] }
public void testEqualsWithDifferentClass() { [EOL] TypeKey key = new TypeKey(SomeClass.class, false); [EOL] Object other = new Object(); [EOL] assertFalse(key.equals(other)); [EOL] }
public void testEqualsWithSameClassDifferentTypeFlag() { [EOL] TypeKey key = new TypeKey(SomeClass.class, false); [EOL] TypeKey other = new TypeKey(SomeClass.class, true); [EOL] assertFalse(key.equals(other)); [EOL] }
public void testEqualsWithSameClassSameTypeFlagDifferentClassField() { [EOL] TypeKey key = new TypeKey(SomeClass.class, false); [EOL] TypeKey other = new TypeKey(OtherClass.class, false); [EOL] assertFalse(key.equals(other)); [EOL] }
public void testEqualsWithSameClassSameTypeFlagSameClassField() { [EOL] TypeKey key = new TypeKey(SomeClass.class, false); [EOL] TypeKey other = new TypeKey(SomeClass.class, false); [EOL] assertTrue(key.equals(other)); [EOL] }
public void testEqualsWithSameClassSameTypeFlagNullClassField() { [EOL] TypeKey key = new TypeKey(null, false); [EOL] TypeKey other = new TypeKey(null, false); [EOL] assertTrue(key.equals(other)); [EOL] }
public void testEqualsWithSameClassSameTypeFlagNonNullAndNullClassField() { [EOL] TypeKey key = new TypeKey(SomeClass.class, false); [EOL] TypeKey other = new TypeKey(null, false); [EOL] assertFalse(key.equals(other)); [EOL] }
public void testEqualsWithSameClassSameTypeFlagDifferentGenericType() { [EOL] TypeKey key = new TypeKey(null, false, new TypeReference<List<String>>() {}); [EOL] TypeKey other = new TypeKey(null, false, new TypeReference<List<Integer>>() {}); [EOL] assertFalse(key.equals(other)); [EOL] }
public void testEqualsWithSameClassSameTypeFlagSameGenericType() { [EOL] TypeReference<List<String>> typeRef = new TypeReference<List<String>>() {}; [EOL] TypeKey key = new TypeKey(null, false, typeRef); [EOL] TypeKey other = new TypeKey(null, false, typeRef); [EOL] assertTrue(key.equals(other)); [EOL] }
public void testBeanPropertyMapWithEmptyCollection() { [EOL] Collection<SettableBeanProperty> properties = Collections.emptyList(); [EOL] BeanPropertyMap beanPropertyMap = new BeanPropertyMap(properties); [EOL] assertEquals(0, beanPropertyMap.size()); [EOL] }
public void testBeanPropertyMapWithSingleElement() { [EOL] SettableBeanProperty property = mock(SettableBeanProperty.class); [EOL] when(property.getName()).thenReturn("propertyOne"); [EOL] Collection<SettableBeanProperty> properties = Collections.singleton(property); [EOL] BeanPropertyMap beanPropertyMap = new BeanPropertyMap(properties); [EOL] assertEquals(1, beanPropertyMap.size()); [EOL] }
public void testBeanPropertyMapWithMultipleElements() { [EOL] SettableBeanProperty propertyOne = mock(SettableBeanProperty.class); [EOL] when(propertyOne.getName()).thenReturn("propertyOne"); [EOL] SettableBeanProperty propertyTwo = mock(SettableBeanProperty.class); [EOL] when(propertyTwo.getName()).thenReturn("propertyTwo"); [EOL] Collection<SettableBeanProperty> properties = Arrays.asList(propertyOne, propertyTwo); [EOL] BeanPropertyMap beanPropertyMap = new BeanPropertyMap(properties); [EOL] assertEquals(2, beanPropertyMap.size()); [EOL] }
public void testBeanPropertyMapWithCollisions() { [EOL] SettableBeanProperty propertyOne = mock(SettableBeanProperty.class); [EOL] when(propertyOne.getName()).thenReturn("property"); [EOL] SettableBeanProperty propertyTwo = mock(SettableBeanProperty.class); [EOL] when(propertyTwo.getName()).thenReturn("property"); [EOL] Collection<SettableBeanProperty> properties = Arrays.asList(propertyOne, propertyTwo); [EOL] BeanPropertyMap beanPropertyMap = new BeanPropertyMap(properties); [EOL] assertEquals(2, beanPropertyMap.size()); [EOL] }
public void testWithPropertyNewProperty() { [EOL] BeanPropertyMap originalMap = new BeanPropertyMap(new Bucket[4], 0, 0); [EOL] SettableBeanProperty newProperty = new MockSettableBeanProperty("newProp"); [EOL] BeanPropertyMap newMap = originalMap.withProperty(newProperty); [EOL] assertNotNull(newMap); [EOL] assertNotSame(originalMap, newMap); [EOL] assertEquals(1, newMap.size()); [EOL] assertNotNull(newMap.find("newProp")); [EOL] }
public void testWithPropertyExistingProperty() { [EOL] BeanPropertyMap originalMap = new BeanPropertyMap(new Bucket[4], 0, 0); [EOL] SettableBeanProperty existingProperty = new MockSettableBeanProperty("existingProp"); [EOL] originalMap = originalMap.withProperty(existingProperty); [EOL] SettableBeanProperty newProperty = new MockSettableBeanProperty("existingProp"); [EOL] BeanPropertyMap newMap = originalMap.withProperty(newProperty); [EOL] assertNotNull(newMap); [EOL] assertSame(originalMap, newMap); [EOL] assertEquals(1, newMap.size()); [EOL] assertSame(newProperty, newMap.find("existingProp")); [EOL] }
public void testAssignIndexesWithEmptyMap() { [EOL] BeanPropertyMap map = new BeanPropertyMap(false); [EOL] BeanPropertyMap result = map.assignIndexes(); [EOL] assertNotNull(result); [EOL] assertTrue(result.size() == 0); [EOL] }
public void testAssignIndexesWithNonEmptyMap() { [EOL] BeanPropertyMap map = new BeanPropertyMap(false); [EOL] BeanProperty prop1 = new BeanProperty.Std(new PropertyName("prop1"), null, null, null); [EOL] BeanProperty prop2 = new BeanProperty.Std(new PropertyName("prop2"), null, null, null); [EOL] map.put(prop1.getName(), prop1); [EOL] map.put(prop2.getName(), prop2); [EOL] BeanPropertyMap result = map.assignIndexes(); [EOL] assertNotNull(result); [EOL] assertEquals(2, result.size()); [EOL] assertEquals(0, prop1.getIndex()); [EOL] assertEquals(1, prop2.getIndex()); [EOL] }
public void testFindSizeForSizeLessThanOrEqualTo32() { [EOL] int size = 16; [EOL] int expected = 32; [EOL] int actual = findSize(size); [EOL] assertEquals(expected, actual); [EOL] }
public void testFindSizeForSizeGreaterThan32() { [EOL] int size = 40; [EOL] int expected = 64; [EOL] int actual = findSize(size); [EOL] assertEquals(expected, actual); [EOL] }
public void testFindSizeForSizeExactly32() { [EOL] int size = 32; [EOL] int expected = 64; [EOL] int actual = findSize(size); [EOL] assertEquals(expected, actual); [EOL] }
public void testIteratorEmpty() { [EOL] PropertyName[][] noProperties = new PropertyName[0][]; [EOL] BeanPropertyMap map = new BeanPropertyMap(false, noProperties); [EOL] Iterator<SettableBeanProperty> iterator = map.iterator(); [EOL] assertFalse(iterator.hasNext()); [EOL] }
public void testIteratorSingleElement() { [EOL] PropertyName propName = new PropertyName("testProperty"); [EOL] SettableBeanProperty property = new MockSettableBeanProperty(propName); [EOL] PropertyName[][] properties = new PropertyName[][]{{propName}}; [EOL] BeanPropertyMap map = new BeanPropertyMap(false, properties); [EOL] map.assignIndexes(); [EOL] Iterator<SettableBeanProperty> iterator = map.iterator(); [EOL] assertTrue(iterator.hasNext()); [EOL] assertSame(property, iterator.next()); [EOL] assertFalse(iterator.hasNext()); [EOL] }
public void testIteratorMultipleElements() { [EOL] PropertyName propName1 = new PropertyName("testProperty1"); [EOL] PropertyName propName2 = new PropertyName("testProperty2"); [EOL] SettableBeanProperty property1 = new MockSettableBeanProperty(propName1); [EOL] SettableBeanProperty property2 = new MockSettableBeanProperty(propName2); [EOL] PropertyName[][] properties = new PropertyName[][]{{propName1}, {propName2}}; [EOL] BeanPropertyMap map = new BeanPropertyMap(false, properties); [EOL] map.assignIndexes(); [EOL] Iterator<SettableBeanProperty> iterator = map.iterator(); [EOL] assertTrue(iterator.hasNext()); [EOL] assertSame(property1, iterator.next()); [EOL] assertTrue(iterator.hasNext()); [EOL] assertSame(property2, iterator.next()); [EOL] assertFalse(iterator.hasNext()); [EOL] }
public void testFindWithNullBucket() { [EOL] PropertyBasedCreator creator = new PropertyBasedCreator(null, null, false); [EOL] String key = "testKey"; [EOL] SettableBeanProperty result = creator.find(key); [EOL] assertNull(result); [EOL] }
public void testFindWithMatchingKey() { [EOL] PropertyBasedCreator creator = new PropertyBasedCreator(null, null, false); [EOL] String key = "testKey"; [EOL] SettableBeanProperty property = new SettableBeanProperty.DummyProperty(); [EOL] creator.assign(key, property); [EOL] SettableBeanProperty result = creator.find(key); [EOL] assertSame(property, result); [EOL] }
public void testFindWithNonMatchingKey() { [EOL] PropertyBasedCreator creator = new PropertyBasedCreator(null, null, false); [EOL] String key = "testKey"; [EOL] String nonMatchingKey = "nonMatchingKey"; [EOL] SettableBeanProperty property = new SettableBeanProperty.DummyProperty(); [EOL] creator.assign(key, property); [EOL] SettableBeanProperty result = creator.find(nonMatchingKey); [EOL] assertNull(result); [EOL] }
public void testFindWithEquals() { [EOL] PropertyBasedCreator creator = new PropertyBasedCreator(null, null, false); [EOL] String key = "testKey"; [EOL] String anotherKeyWithSameHashCode = "anotherKey"; [EOL] SettableBeanProperty property = new SettableBeanProperty.DummyProperty(); [EOL] SettableBeanProperty anotherProperty = new SettableBeanProperty.DummyProperty(); [EOL] creator.assign(key, property); [EOL] creator.assign(anotherKeyWithSameHashCode, anotherProperty); [EOL] assertEquals(key.hashCode(), anotherKeyWithSameHashCode.hashCode()); [EOL] SettableBeanProperty result = creator.find(anotherKeyWithSameHashCode); [EOL] assertSame(anotherProperty, result); [EOL] }
public void testReplaceWithExistingProperty() { [EOL] SettableBeanProperty property = createMockProperty("existingProperty"); [EOL] PropertyBucketMap map = new PropertyBucketMap(); [EOL] map.add(property); [EOL] map.replace(property); // Assuming 'add' method exists and adds the property to the map [EOL] SettableBeanProperty replacedProperty = map.get("existingProperty"); [EOL] assertNotNull(replacedProperty); [EOL] assertSame(property, replacedProperty); [EOL] } [EOL] public void testReplaceWithNonExistingProperty() { [EOL] SettableBeanProperty property = createMockProperty("nonExistingProperty"); [EOL] PropertyBucketMap map = new PropertyBucketMap(); [EOL] try { [EOL] map.replace(property); [EOL] fail("Expected NoSuchElementException to be thrown"); [EOL] } catch (NoSuchElementException e) { [EOL] assertEquals("No entry 'nonExistingProperty' found, can't replace", e.getMessage()); [EOL] } [EOL] }
private SettableBeanProperty createMockProperty(String name) { [EOL] SettableBeanProperty property = mock(SettableBeanProperty.class); [EOL] when(property.getName()).thenReturn(name); [EOL] return property; [EOL] }
public void testRemovePropertyNotFound() { [EOL] SettableBeanProperty property = new SettableBeanPropertyStub("nonExistentProperty"); [EOL] BeanPropertyMap map = new BeanPropertyMap(false, new HashSet<>()); [EOL] try { [EOL] map.remove(property); [EOL] fail("Expected NoSuchElementException to be thrown"); [EOL] } catch (NoSuchElementException e) { [EOL] assertEquals("No entry 'nonExistentProperty' found, can't remove", e.getMessage()); [EOL] } [EOL] }
public void testRemovePropertyFound() { [EOL] SettableBeanProperty property1 = new SettableBeanPropertyStub("property1"); [EOL] SettableBeanProperty property2 = new SettableBeanPropertyStub("property2"); [EOL] Set<SettableBeanProperty> properties = new HashSet<>(); [EOL] properties.add(property1); [EOL] properties.add(property2); [EOL] BeanPropertyMap map = new BeanPropertyMap(false, properties); [EOL] assertTrue(map.find("property1") != null); [EOL] map.remove(property1); [EOL] assertNull(map.find("property1")); [EOL] assertNotNull(map.find("property2")); [EOL] }
public void testBucketConstructorWithNullNext() { [EOL] String key = "testKey"; [EOL] SettableBeanProperty value = mock(SettableBeanProperty.class); [EOL] int index = 1; [EOL] Bucket bucket = new Bucket(null, key, value, index); [EOL] assertNull(bucket.next); [EOL] assertEquals(key, bucket.key); [EOL] assertEquals(value, bucket.value); [EOL] assertEquals(index, bucket.index); [EOL] }
public void testBucketConstructorWithNonNullNext() { [EOL] Bucket next = mock(Bucket.class); [EOL] String key = "testKey"; [EOL] SettableBeanProperty value = mock(SettableBeanProperty.class); [EOL] int index = 1; [EOL] Bucket bucket = new Bucket(next, key, value, index); [EOL] assertNotNull(bucket.next); [EOL] assertEquals(key, bucket.key); [EOL] assertEquals(value, bucket.value); [EOL] assertEquals(index, bucket.index); [EOL] }
public void testIteratorImplWithEmptyBuckets() { [EOL] Bucket[] buckets = new Bucket[0]; [EOL] IteratorImpl iterator = new IteratorImpl(buckets); [EOL] assertFalse(iterator.hasNext()); [EOL] }
public void testIteratorImplWithAllNullBuckets() { [EOL] Bucket[] buckets = new Bucket[3]; [EOL] IteratorImpl iterator = new IteratorImpl(buckets); [EOL] assertFalse(iterator.hasNext()); [EOL] }
public void testIteratorImplWithOneNonNullBucket() { [EOL] Bucket[] buckets = new Bucket[3]; [EOL] buckets[1] = new Bucket(); // Assuming Bucket is a valid class and has a constructor [EOL] IteratorImpl iterator = new IteratorImpl(buckets); [EOL] assertTrue(iterator.hasNext()); [EOL] }
public void testHasNextWhenCurrentBucketIsNull() { [EOL] IteratorUnderTest iterator = new IteratorUnderTest(); [EOL] iterator._currentBucket = null; [EOL] boolean result = iterator.hasNext(); [EOL] assertFalse(result); [EOL] }
public void testHasNextWhenCurrentBucketIsNotNull() { [EOL] IteratorUnderTest iterator = new IteratorUnderTest(); [EOL] iterator._currentBucket = new Object(); // Replace Object with the actual type of _currentBucket [EOL] boolean result = iterator.hasNext(); [EOL] assertTrue(result); [EOL] }
public void testNextWhenCurrentBucketIsNull() { [EOL] Bucket[] buckets = new Bucket[0]; // Empty array to ensure _currentBucket is null [EOL] BucketIterator iterator = new BucketIterator(buckets); [EOL] try { [EOL] iterator.next(); [EOL] fail("Expected NoSuchElementException to be thrown"); [EOL] } catch (NoSuchElementException e) { [EOL] } [EOL] }
public void testNextWhenCurrentBucketIsNotNullAndHasNext() { [EOL] Bucket bucketWithNext = new Bucket(); // Assuming Bucket class has a default constructor [EOL] bucketWithNext.next = new Bucket(); // Set next bucket to simulate a non-null next bucket [EOL] Bucket[] buckets = {bucketWithNext}; [EOL] BucketIterator iterator = new BucketIterator(buckets); [EOL] iterator.next(); // Set the _currentBucket to the first bucket [EOL] SettableBeanProperty result = iterator.next(); // Call next to get the next bucket's value [EOL] assertNotNull("Expected non-null result", result); [EOL] assertEquals("Expected result to be the value of the next bucket", bucketWithNext.next.value, result); [EOL] }
public void testNextWhenCurrentBucketIsNotNullAndNoNextButFurtherBucketsExist() { [EOL] Bucket firstBucket = new Bucket(); // No next bucket [EOL] Bucket secondBucket = new Bucket(); // This will be in the _buckets array [EOL] Bucket[] buckets = new Bucket[] {null, secondBucket}; // Simulate _buckets with a null first entry [EOL] BucketIterator iterator = new BucketIterator(buckets); [EOL] iterator.next(); // Set the _currentBucket to the first bucket [EOL] SettableBeanProperty result = iterator.next(); // Call next to move to the second bucket [EOL] assertNotNull("Expected non-null result", result); [EOL] assertEquals("Expected result to be the value of the second bucket", secondBucket.value, result); [EOL] }
public void testForTypeWithIntegerType() { [EOL] JsonDeserializer<?> deserializer = YourClass.forType(Integer.TYPE); [EOL] assertTrue(deserializer instanceof IntDeser); [EOL] }
public void testForTypeWithLongType() { [EOL] JsonDeserializer<?> deserializer = YourClass.forType(Long.TYPE); [EOL] assertTrue(deserializer instanceof LongDeser); [EOL] }
public void testForTypeWithByteType() { [EOL] JsonDeserializer<?> deserializer = YourClass.forType(Byte.TYPE); [EOL] assertTrue(deserializer instanceof ByteDeser); [EOL] }
public void testForTypeWithShortType() { [EOL] JsonDeserializer<?> deserializer = YourClass.forType(Short.TYPE); [EOL] assertTrue(deserializer instanceof ShortDeser); [EOL] }
public void testForTypeWithFloatType() { [EOL] JsonDeserializer<?> deserializer = YourClass.forType(Float.TYPE); [EOL] assertTrue(deserializer instanceof FloatDeser); [EOL] }
public void testForTypeWithDoubleType() { [EOL] JsonDeserializer<?> deserializer = YourClass.forType(Double.TYPE); [EOL] assertTrue(deserializer instanceof DoubleDeser); [EOL] }
public void testForTypeWithBooleanType() { [EOL] JsonDeserializer<?> deserializer = YourClass.forType(Boolean.TYPE); [EOL] assertTrue(deserializer instanceof BooleanDeser); [EOL] }
public void testForTypeWithCharacterType() { [EOL] JsonDeserializer<?> deserializer = YourClass.forType(Character.TYPE); [EOL] assertTrue(deserializer instanceof CharDeser); [EOL] }
public void testForTypeWithInvalidType() { [EOL] try { [EOL] YourClass.forType(String.class); [EOL] fail("Expected an IllegalStateException to be thrown"); [EOL] } catch (IllegalStateException e) { [EOL] } [EOL] }
public void testBooleanDeserConstructor() { [EOL] BooleanDeser deser = new BooleanDeser(); [EOL] assertNotNull(deser); [EOL] }
public void testDeserializeWithNonArrayToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.isExpectedStartArrayToken()).thenReturn(false); [EOL] boolean[] result = deserialize(jp, ctxt); [EOL] }
public void testDeserializeWithEmptyArray() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.isExpectedStartArrayToken()).thenReturn(true); [EOL] when(jp.nextToken()).thenReturn(JsonToken.END_ARRAY); [EOL] boolean[] result = deserialize(jp, ctxt); [EOL] assertTrue(result.length == 0); [EOL] }
public void testDeserializeWithNonEmptyArray() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.isExpectedStartArrayToken()).thenReturn(true); [EOL] when(jp.nextToken()).thenReturn(JsonToken.VALUE_TRUE, JsonToken.VALUE_FALSE, JsonToken.END_ARRAY); [EOL] boolean[] result = deserialize(jp, ctxt); [EOL] assertTrue(result.length == 2); [EOL] assertTrue(result[0]); [EOL] assertFalse(result[1]); [EOL] }
public void testDeserializeWithArrayNeedingExpansion() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.isExpectedStartArrayToken()).thenReturn(true); [EOL] when(jp.nextToken()).thenReturn(JsonToken.VALUE_TRUE, JsonToken.VALUE_TRUE, JsonToken.END_ARRAY); [EOL] ArrayBuilders.BooleanBuilder builder = ctxt.getArrayBuilders().getBooleanBuilder(); [EOL] boolean[] chunk = builder.resetAndStart(); [EOL] int initialLength = chunk.length; [EOL] when(jp.nextToken()).thenAnswer(new Answer<JsonToken>() { [EOL] private int count = 0; [EOL] @Override [EOL] public JsonToken answer(InvocationOnMock invocation) { [EOL] count++; [EOL] return count <= initialLength ? JsonToken.VALUE_TRUE : JsonToken.END_ARRAY; [EOL] } [EOL] }); [EOL] boolean[] result = deserialize(jp, ctxt); [EOL] assertTrue(result.length > initialLength); [EOL] for (boolean value : result) { [EOL] assertTrue(value); [EOL] } [EOL] }
public void testDeserializeWithJsonValueString() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Base64Variant b64variant = mock(Base64Variant.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(ctxt.getBase64Variant()).thenReturn(b64variant); [EOL] when(jp.getBinaryValue(b64variant)).thenReturn(new byte[]{(byte) 1, (byte) 2, (byte) 3}); [EOL] byte[] result = deserialize(jp, ctxt); [EOL] assertArrayEquals(new byte[]{(byte) 1, (byte) 2, (byte) 3}, result); [EOL] }
public void testDeserializeWithJsonEmbeddedObject() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_EMBEDDED_OBJECT); [EOL] when(jp.getEmbeddedObject()).thenReturn(new byte[]{(byte) 4, (byte) 5, (byte) 6}); [EOL] byte[] result = deserialize(jp, null); [EOL] assertArrayEquals(new byte[]{(byte) 4, (byte) 5, (byte) 6}, result); [EOL] }
public void testDeserializeWithJsonEmbeddedObjectNull() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_EMBEDDED_OBJECT); [EOL] when(jp.getEmbeddedObject()).thenReturn(null); [EOL] byte[] result = deserialize(jp, null); [EOL] assertNull(result); [EOL] }
public void testDeserializeWithNonArrayToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_FALSE); [EOL] when(jp.isExpectedStartArrayToken()).thenReturn(false); [EOL] when(ctxt.handleUnexpectedToken(byte[].class, jp)).thenReturn(new byte[]{(byte) 7, (byte) 8, (byte) 9}); [EOL] byte[] result = deserialize(jp, ctxt); [EOL] assertArrayEquals(new byte[]{(byte) 7, (byte) 8, (byte) 9}, result); [EOL] }
public void testDeserializeWithArrayTokenAndNumbers() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] ArrayBuilders.ByteBuilder builder = mock(ArrayBuilders.ByteBuilder.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_ARRAY); [EOL] when(jp.nextToken()).thenReturn(JsonToken.VALUE_NUMBER_INT).thenReturn(JsonToken.END_ARRAY); [EOL] when(jp.getByteValue()).thenReturn((byte) 10); [EOL] when(ctxt.getArrayBuilders()).thenReturn(mock(ArrayBuilders.class)); [EOL] when(ctxt.getArrayBuilders().getByteBuilder()).thenReturn(builder); [EOL] when(builder.resetAndStart()).thenReturn(new byte[10]); [EOL] when(builder.completeAndClearBuffer(any(byte[].class), anyInt())).thenReturn(new byte[]{(byte) 10}); [EOL] byte[] result = deserialize(jp, ctxt); [EOL] assertArrayEquals(new byte[]{(byte) 10}, result); [EOL] }
public void testDeserializeWithArrayTokenAndNulls() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] ArrayBuilders.ByteBuilder builder = mock(ArrayBuilders.ByteBuilder.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_ARRAY); [EOL] when(jp.nextToken()).thenReturn(JsonToken.VALUE_NULL).thenReturn(JsonToken.END_ARRAY); [EOL] when(ctxt.getArrayBuilders()).thenReturn(mock(ArrayBuilders.class)); [EOL] when(ctxt.getArrayBuilders().getByteBuilder()).thenReturn(builder); [EOL] when(builder.resetAndStart()).thenReturn(new byte[10]); [EOL] when(builder.completeAndClearBuffer(any(byte[].class), anyInt())).thenReturn(new byte[]{(byte) 0}); [EOL] byte[] result = deserialize(jp, ctxt); [EOL] assertArrayEquals(new byte[]{(byte) 0}, result); [EOL] }
public void testDeserializeWithArrayTokenAndInvalidType() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_ARRAY); [EOL] when(jp.nextToken()).thenReturn(JsonToken.VALUE_TRUE); [EOL] when(ctxt.mappingException(any(Class.class))).thenThrow(new JsonMappingException("Invalid type")); [EOL] assertThrows(JsonMappingException.class, () -> { [EOL] deserialize(jp, ctxt); [EOL] }); [EOL] }
public void testDeserializeWithNonArrayToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.isExpectedStartArrayToken()).thenReturn(false); [EOL] short[] result = deserialize(jp, ctxt); [EOL] }
public void testDeserializeWithEmptyArray() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.isExpectedStartArrayToken()).thenReturn(true); [EOL] when(jp.nextToken()).thenReturn(JsonToken.END_ARRAY); [EOL] short[] result = deserialize(jp, ctxt); [EOL] assertNotNull(result); [EOL] assertEquals(0, result.length); [EOL] }
public void testDeserializeWithNonEmptyArray() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] ArrayBuilders.ShortBuilder builder = ctxt.getArrayBuilders().getShortBuilder(); [EOL] when(jp.isExpectedStartArrayToken()).thenReturn(true); [EOL] when(jp.nextToken()).thenReturn(JsonToken.VALUE_NUMBER_INT, JsonToken.END_ARRAY); [EOL] when(jp.getShortValue()).thenReturn((short) 1); [EOL] short[] result = deserialize(jp, ctxt); [EOL] assertNotNull(result); [EOL] assertEquals(1, result.length); [EOL] assertEquals((short) 1, result[0]); [EOL] }
public void testDeserializeWithLargeArray() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] ArrayBuilders.ShortBuilder builder = ctxt.getArrayBuilders().getShortBuilder(); [EOL] when(jp.isExpectedStartArrayToken()).thenReturn(true); [EOL] when(jp.nextToken()).thenReturn(JsonToken.VALUE_NUMBER_INT).thenReturn(JsonToken.VALUE_NUMBER_INT).thenReturn(JsonToken.END_ARRAY); [EOL] when(jp.getShortValue()).thenReturn((short) 1, (short) 2); [EOL] short[] result = deserialize(jp, ctxt); [EOL] assertNotNull(result); [EOL] assertEquals(2, result.length); [EOL] assertEquals((short) 1, result[0]); [EOL] assertEquals((short) 2, result[1]); [EOL] }
public void testDeserializeWithNonArrayToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.isExpectedStartArrayToken()).thenReturn(false); [EOL] int[] result = deserialize(jp, ctxt); [EOL] }
public void testDeserializeWithEmptyArray() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.isExpectedStartArrayToken()).thenReturn(true); [EOL] when(jp.nextToken()).thenReturn(JsonToken.END_ARRAY); [EOL] int[] result = deserialize(jp, ctxt); [EOL] assertNotNull(result); [EOL] assertEquals(0, result.length); [EOL] }
public void testDeserializeWithNonEmptyArray() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.isExpectedStartArrayToken()).thenReturn(true); [EOL] when(jp.nextToken()).thenReturn(JsonToken.VALUE_NUMBER_INT).thenReturn(JsonToken.END_ARRAY); [EOL] when(jp.getIntValue()).thenReturn(42); [EOL] int[] result = deserialize(jp, ctxt); [EOL] assertNotNull(result); [EOL] assertEquals(1, result.length); [EOL] assertEquals(42, result[0]); [EOL] }
public void testDeserializeWithLargeArray() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] ArrayBuilders.IntBuilder builder = ctxt.getArrayBuilders().getIntBuilder(); [EOL] int[] initialChunk = builder.resetAndStart(); [EOL] when(jp.isExpectedStartArrayToken()).thenReturn(true); [EOL] when(jp.nextToken()).thenReturn(JsonToken.VALUE_NUMBER_INT).thenReturn(JsonToken.VALUE_NUMBER_INT).thenReturn(JsonToken.END_ARRAY); [EOL] when(jp.getIntValue()).thenReturn(42); [EOL] int[] result = deserialize(jp, ctxt); [EOL] assertNotNull(result); [EOL] assertTrue(result.length >= 2); [EOL] assertEquals(42, result[0]); [EOL] assertEquals(42, result[1]); [EOL] }
public void testHandleNonArrayWithEmptyStringAndFeatureEnabled() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)).thenReturn(true); [EOL] when(jp.getText()).thenReturn(""); [EOL] int[] result = handleNonArray(jp, ctxt); [EOL] assertNull(result); [EOL] }
public void testHandleNonArrayWithNonEmptyStringAndFeatureEnabled() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)).thenReturn(true); [EOL] when(jp.getText()).thenReturn("non-empty"); [EOL] int[] result = handleNonArray(jp, ctxt); [EOL] assertNotNull(result); [EOL] assertEquals(1, result.length); [EOL] }
public void testHandleNonArrayWithFeatureDisabled() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY)).thenReturn(false); [EOL] try { [EOL] handleNonArray(jp, ctxt); [EOL] fail("Expected JsonMappingException"); [EOL] } catch (JsonMappingException e) { [EOL] } [EOL] }
public void testHandleNonArrayWithSingleValueAsArrayFeatureEnabled() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY)).thenReturn(true); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); [EOL] when(jp.getIntValue()).thenReturn(42); [EOL] int[] result = handleNonArray(jp, ctxt); [EOL] assertNotNull(result); [EOL] assertEquals(1, result.length); [EOL] assertEquals(42, result[0]); [EOL] }
public void testIndexedListSerializerWithNullParameters() { [EOL] IndexedListSerializer src = null; [EOL] BeanProperty property = null; [EOL] TypeSerializer vts = null; [EOL] JsonSerializer<?> valueSerializer = null; [EOL] IndexedListSerializer serializer = new IndexedListSerializer(src, property, vts, valueSerializer); [EOL] assertNull(serializer.property); [EOL] assertNull(serializer.vts); [EOL] assertNull(serializer.valueSerializer); [EOL] }
public void testIndexedListSerializerWithNonNullParameters() { [EOL] IndexedListSerializer src = new IndexedListSerializer(null, null, null, null); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] TypeSerializer vts = mock(TypeSerializer.class); [EOL] JsonSerializer<?> valueSerializer = mock(JsonSerializer.class); [EOL] IndexedListSerializer serializer = new IndexedListSerializer(src, property, vts, valueSerializer); [EOL] assertNotNull(serializer.property); [EOL] assertNotNull(serializer.vts); [EOL] assertNotNull(serializer.valueSerializer); [EOL] }
public void testWithResolved() { [EOL] IndexedListSerializer originalSerializer = new IndexedListSerializer(null, null, null, null); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] TypeSerializer vts = mock(TypeSerializer.class); [EOL] JsonSerializer<?> elementSerializer = mock(JsonSerializer.class); [EOL] IndexedListSerializer resultSerializer = originalSerializer.withResolved(property, vts, elementSerializer); [EOL] assertNotNull(resultSerializer); [EOL] assertNotSame(originalSerializer, resultSerializer); [EOL] assertSame(property, resultSerializer.getProperty()); [EOL] assertSame(vts, resultSerializer.getTypeSerializer()); [EOL] assertSame(elementSerializer, resultSerializer.getElementSerializer()); [EOL] }
public void testSerializeContentsWithElementSerializer() throws IOException { [EOL] List<?> value = ...; // Initialize with a list that will trigger the _elementSerializer branch [EOL] JsonGenerator jgen = ...; // Mock JsonGenerator [EOL] SerializerProvider provider = ...; // Mock SerializerProvider [EOL] serializeContents(value, jgen, provider); [EOL] }
public void testSerializeContentsWithTypeSerializer() throws IOException { [EOL] List<?> value = ...; // Initialize with a list that will trigger the _valueTypeSerializer branch [EOL] JsonGenerator jgen = ...; // Mock JsonGenerator [EOL] SerializerProvider provider = ...; // Mock SerializerProvider [EOL] serializeContents(value, jgen, provider); [EOL] }
public void testSerializeContentsEmptyList() throws IOException { [EOL] List<?> value = Collections.emptyList(); // Empty list to trigger the len == 0 branch [EOL] JsonGenerator jgen = ...; // Mock JsonGenerator [EOL] SerializerProvider provider = ...; // Mock SerializerProvider [EOL] serializeContents(value, jgen, provider); [EOL] }
public void testSerializeContentsDynamicSerializer() throws IOException { [EOL] List<?> value = ...; // Initialize with a list that will trigger the dynamic serializer branch [EOL] JsonGenerator jgen = ...; // Mock JsonGenerator [EOL] SerializerProvider provider = ...; // Mock SerializerProvider [EOL] serializeContents(value, jgen, provider); [EOL] }
public void testSerializeContentsWithNullElement() throws IOException { [EOL] List<?> value = Arrays.asList(null, ...); // List with a null element to trigger provider.defaultSerializeNull [EOL] JsonGenerator jgen = ...; // Mock JsonGenerator [EOL] SerializerProvider provider = ...; // Mock SerializerProvider [EOL] serializeContents(value, jgen, provider); [EOL] }
public void testSerializeContentsWithException() throws IOException { [EOL] List<?> value = ...; // Initialize with a list that will cause an exception during serialization [EOL] JsonGenerator jgen = ...; // Mock JsonGenerator [EOL] SerializerProvider provider = ...; // Mock SerializerProvider [EOL] try { [EOL] serializeContents(value, jgen, provider); [EOL] fail("Expected an exception to be thrown"); [EOL] } catch (Exception e) { [EOL] } [EOL] }
public void testAsArrayTypeSerializerWithNonNullIdResAndProperty() { [EOL] TypeIdResolver idRes = mock(TypeIdResolver.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] AsArrayTypeSerializer serializer = new AsArrayTypeSerializer(idRes, property); [EOL] assertNotNull(serializer); [EOL] }
public void testAsArrayTypeSerializerWithNullIdRes() { [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] try { [EOL] AsArrayTypeSerializer serializer = new AsArrayTypeSerializer(null, property); [EOL] fail("Expected IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("idRes cannot be null", e.getMessage()); [EOL] } [EOL] }
public void testAsArrayTypeSerializerWithNullProperty() { [EOL] TypeIdResolver idRes = mock(TypeIdResolver.class); [EOL] AsArrayTypeSerializer serializer = new AsArrayTypeSerializer(idRes, null); [EOL] assertNotNull(serializer); [EOL] }
public void testForPropertySameProperty() { [EOL] BeanProperty prop = mock(BeanProperty.class); [EOL] AsArrayTypeSerializer serializer = new AsArrayTypeSerializer(mock(TypeIdResolver.class), prop); [EOL] AsArrayTypeSerializer result = serializer.forProperty(prop); [EOL] assertSame(serializer, result); [EOL] }
public void testForPropertyDifferentProperty() { [EOL] BeanProperty prop1 = mock(BeanProperty.class); [EOL] BeanProperty prop2 = mock(BeanProperty.class); [EOL] AsArrayTypeSerializer serializer = new AsArrayTypeSerializer(mock(TypeIdResolver.class), prop1); [EOL] AsArrayTypeSerializer result = serializer.forProperty(prop2); [EOL] assertNotSame(serializer, result); [EOL] assertNotNull(result); [EOL] }
public void testWriteTypePrefixForObject() throws IOException { [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] TypeNameIdResolver resolver = new TypeNameIdResolver(null, null, false); [EOL] Object value = new Object(); [EOL] resolver.writeTypePrefixForObject(value, mockJsonGenerator); [EOL] verify(mockJsonGenerator).writeStartArray(); [EOL] verify(mockJsonGenerator).writeString(anyString()); [EOL] verify(mockJsonGenerator).writeStartObject(); [EOL] }
public void testWriteTypePrefixForScalarWithNonNullValue() throws IOException { [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] Object value = new Object(); [EOL] String typeId = "typeId"; [EOL] TypeNameIdResolver resolver = new TypeNameIdResolver(null, null, false, null); [EOL] resolver.init(new ObjectMapper(), new SimpleType(Object.class)); [EOL] when(resolver.idFromValue(value)).thenReturn(typeId); [EOL] resolver.writeTypePrefixForScalar(value, mockJsonGenerator); [EOL] verify(mockJsonGenerator).writeStartArray(); [EOL] verify(mockJsonGenerator).writeString(typeId); [EOL] }
public void testWriteTypePrefixForScalarWithNullValue() throws IOException { [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] Object value = null; [EOL] TypeNameIdResolver resolver = new TypeNameIdResolver(null, null, false, null); [EOL] resolver.init(new ObjectMapper(), new SimpleType(Object.class)); [EOL] when(resolver.idFromValue(null)).thenReturn(null); [EOL] resolver.writeTypePrefixForScalar(value, mockJsonGenerator); [EOL] verify(mockJsonGenerator).writeStartArray(); [EOL] verify(mockJsonGenerator, never()).writeString(anyString()); [EOL] }
public void testWriteTypeSuffixForObject() throws IOException, JsonProcessingException { [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] JsonSerializer<Object> serializer = new JsonSerializer<Object>() { [EOL] @Override [EOL] public void writeTypeSuffixForObject(Object value, JsonGenerator jgen) throws IOException { [EOL] super.writeTypeSuffixForObject(value, jgen); [EOL] } [EOL] }; [EOL] Object value = new Object(); [EOL] serializer.writeTypeSuffixForObject(value, mockJsonGenerator); [EOL] verify(mockJsonGenerator).writeEndObject(); [EOL] verify(mockJsonGenerator).writeEndArray(); [EOL] }
public void testWriteTypeSuffixForScalar() throws IOException, JsonProcessingException { [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] JsonSerializer<Object> serializer = new JsonSerializer<Object>() { [EOL] @Override [EOL] public void writeTypeSuffixForScalar(Object value, JsonGenerator jgen) throws IOException { [EOL] jgen.writeEndArray(); [EOL] } [EOL] }; [EOL] serializer.writeTypeSuffixForScalar(new Object(), mockJsonGenerator); [EOL] verify(mockJsonGenerator).writeEndArray(); [EOL] }
public void testNullNode() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] NullNode result = mapper.nullNode(); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof NullNode); [EOL] }
public void testNumberNodeWithPositiveValue() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] int value = 5; [EOL] NumericNode result = mapper.numberNode(value); [EOL] assertNotNull(result); [EOL] assertEquals(value, result.intValue()); [EOL] }
public void testNumberNodeWithNegativeValue() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] int value = -5; [EOL] NumericNode result = mapper.numberNode(value); [EOL] assertNotNull(result); [EOL] assertEquals(value, result.intValue()); [EOL] }
public void testNumberNodeWithZero() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] int value = 0; [EOL] NumericNode result = mapper.numberNode(value); [EOL] assertNotNull(result); [EOL] assertEquals(value, result.intValue()); [EOL] }
public void testNumberNodeWithPositiveValue() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] double value = 123.456; [EOL] NumericNode result = mapper.numberNode(value); [EOL] assertNotNull(result); [EOL] assertEquals(value, result.doubleValue(), 0.0); [EOL] }
public void testNumberNodeWithNegativeValue() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] double value = -123.456; [EOL] NumericNode result = mapper.numberNode(value); [EOL] assertNotNull(result); [EOL] assertEquals(value, result.doubleValue(), 0.0); [EOL] }
public void testNumberNodeWithZero() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] double value = 0.0; [EOL] NumericNode result = mapper.numberNode(value); [EOL] assertNotNull(result); [EOL] assertEquals(value, result.doubleValue(), 0.0); [EOL] }
public void testBinaryNodeWithNonNullData() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] byte[] data = new byte[]{1, 2, 3}; [EOL] BinaryNode result = mapper.binaryNode(data); [EOL] assertNotNull(result); [EOL] assertArrayEquals(data, result.binaryValue()); [EOL] }
public void testBinaryNodeWithNullData() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] byte[] data = null; [EOL] BinaryNode result = mapper.binaryNode(data); [EOL] assertNotNull(result); [EOL] assertNull(result.binaryValue()); [EOL] }
public void testStringSerializerConstructor() { [EOL] StringSerializer serializer = new StringSerializer(); [EOL] assertNotNull(serializer); [EOL] }
public void testSerializeWithNonNullValue() throws IOException { [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] SerializerProvider mockProvider = mock(SerializerProvider.class); [EOL] String testValue = "testString"; [EOL] new TestClass().serialize(testValue, mockJsonGenerator, mockProvider); [EOL] verify(mockJsonGenerator).writeString(testValue); [EOL] }
public void testSerializeWithNullValue() throws IOException { [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] SerializerProvider mockProvider = mock(SerializerProvider.class); [EOL] String testValue = null; [EOL] new TestClass().serialize(testValue, mockJsonGenerator, mockProvider); [EOL] verify(mockJsonGenerator).writeString(testValue); [EOL] }
public void testDeserializeAndSet() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object instance = new Object(); [EOL] YourDeserializer deserializer = new YourDeserializer(); [EOL] deserializer.deserializeAndSet(jp, ctxt, instance); [EOL] verify(deserializer).deserializeSetAndReturn(jp, ctxt, instance); [EOL] }
public void testDeserializeSetAndReturnWithIdProperty() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object instance = new Object(); [EOL] Object id = new Object(); [EOL] ObjectIdGenerator<?> generator = mock(ObjectIdGenerator.class); [EOL] ReadableObjectId roid = mock(ReadableObjectId.class); [EOL] SettableBeanProperty idProp = mock(SettableBeanProperty.class); [EOL] when(_valueDeserializer.deserialize(jp, ctxt)).thenReturn(id); [EOL] when(ctxt.findObjectId(id, generator)).thenReturn(roid); [EOL] when(_objectIdReader.generator).thenReturn(generator); [EOL] when(_objectIdReader.idProperty).thenReturn(idProp); [EOL] when(idProp.setAndReturn(instance, id)).thenReturn(instance); [EOL] Object result = deserializeSetAndReturn(jp, ctxt, instance); [EOL] verify(roid).bindItem(instance); [EOL] verify(idProp).setAndReturn(instance, id); [EOL] assertEquals(instance, result); [EOL] }
public void testDeserializeSetAndReturnWithoutIdProperty() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object instance = new Object(); [EOL] Object id = new Object(); [EOL] ObjectIdGenerator<?> generator = mock(ObjectIdGenerator.class); [EOL] ReadableObjectId roid = mock(ReadableObjectId.class); [EOL] when(_valueDeserializer.deserialize(jp, ctxt)).thenReturn(id); [EOL] when(ctxt.findObjectId(id, generator)).thenReturn(roid); [EOL] when(_objectIdReader.generator).thenReturn(generator); [EOL] when(_objectIdReader.idProperty).thenReturn(null); [EOL] Object result = deserializeSetAndReturn(jp, ctxt, instance); [EOL] verify(roid).bindItem(instance); [EOL] assertNull(_objectIdReader.idProperty); [EOL] assertEquals(instance, result); [EOL] }
public void testCollectionDeserializerWithNonNullParameters() { [EOL] JavaType collectionType = mock(JavaType.class); [EOL] JsonDeserializer<Object> valueDeser = mock(JsonDeserializer.class); [EOL] TypeDeserializer valueTypeDeser = mock(TypeDeserializer.class); [EOL] ValueInstantiator valueInstantiator = mock(ValueInstantiator.class); [EOL] CollectionDeserializer result = new CollectionDeserializer(collectionType, valueDeser, valueTypeDeser, valueInstantiator); [EOL] assertNotNull(result); [EOL] }
public void testCollectionDeserializerWithNullParameters() { [EOL] JavaType collectionType = null; [EOL] JsonDeserializer<Object> valueDeser = null; [EOL] TypeDeserializer valueTypeDeser = null; [EOL] ValueInstantiator valueInstantiator = null; [EOL] try { [EOL] CollectionDeserializer result = new CollectionDeserializer(collectionType, valueDeser, valueTypeDeser, valueInstantiator); [EOL] fail("Expected an exception to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertNotNull(e.getMessage()); [EOL] } [EOL] }
public void testCollectionDeserializerConstructor() { [EOL] JavaType collectionType = mock(JavaType.class); [EOL] when(collectionType.getRawClass()).thenReturn(List.class); [EOL] JsonDeserializer<Object> valueDeser = mock(JsonDeserializer.class); [EOL] TypeDeserializer valueTypeDeser = mock(TypeDeserializer.class); [EOL] ValueInstantiator valueInstantiator = mock(ValueInstantiator.class); [EOL] JsonDeserializer<Object> delegateDeser = mock(JsonDeserializer.class); [EOL] CollectionDeserializer collectionDeserializer = new CollectionDeserializer( [EOL] collectionType, valueDeser, valueTypeDeser, valueInstantiator, delegateDeser [EOL] ); [EOL] assertNotNull(collectionDeserializer); [EOL] assertEquals(List.class, collectionDeserializer._collectionType.getRawClass()); [EOL] assertEquals(valueDeser, collectionDeserializer._valueDeserializer); [EOL] assertEquals(valueTypeDeser, collectionDeserializer._valueTypeDeserializer); [EOL] assertEquals(valueInstantiator, collectionDeserializer._valueInstantiator); [EOL] assertEquals(delegateDeser, collectionDeserializer._delegateDeserializer); [EOL] }
public void testWithResolvedSameDeserializers() { [EOL] JsonDeserializer<?> dd = mock(JsonDeserializer.class); [EOL] JsonDeserializer<?> vd = mock(JsonDeserializer.class); [EOL] TypeDeserializer vtd = mock(TypeDeserializer.class); [EOL] CollectionDeserializer instance = new CollectionDeserializer(null, vd, vtd, null, dd); [EOL] CollectionDeserializer result = instance.withResolved(dd, vd, vtd); [EOL] assertSame(instance, result); [EOL] }
public void testWithResolvedDifferentDelegateDeserializer() { [EOL] JsonDeserializer<?> dd = mock(JsonDeserializer.class); [EOL] JsonDeserializer<?> vd = mock(JsonDeserializer.class); [EOL] TypeDeserializer vtd = mock(TypeDeserializer.class); [EOL] JsonDeserializer<?> newDd = mock(JsonDeserializer.class); [EOL] CollectionDeserializer instance = new CollectionDeserializer(null, vd, vtd, null, dd); [EOL] CollectionDeserializer result = instance.withResolved(newDd, vd, vtd); [EOL] assertNotSame(instance, result); [EOL] assertNotNull(result); [EOL] }
public void testWithResolvedDifferentValueDeserializer() { [EOL] JsonDeserializer<?> dd = mock(JsonDeserializer.class); [EOL] JsonDeserializer<?> vd = mock(JsonDeserializer.class); [EOL] TypeDeserializer vtd = mock(TypeDeserializer.class); [EOL] JsonDeserializer<?> newVd = mock(JsonDeserializer.class); [EOL] CollectionDeserializer instance = new CollectionDeserializer(null, vd, vtd, null, dd); [EOL] CollectionDeserializer result = instance.withResolved(dd, newVd, vtd); [EOL] assertNotSame(instance, result); [EOL] assertNotNull(result); [EOL] }
public void testWithResolvedDifferentValueTypeDeserializer() { [EOL] JsonDeserializer<?> dd = mock(JsonDeserializer.class); [EOL] JsonDeserializer<?> vd = mock(JsonDeserializer.class); [EOL] TypeDeserializer vtd = mock(TypeDeserializer.class); [EOL] TypeDeserializer newVtd = mock(TypeDeserializer.class); [EOL] CollectionDeserializer instance = new CollectionDeserializer(null, vd, vtd, null, dd); [EOL] CollectionDeserializer result = instance.withResolved(dd, vd, newVtd); [EOL] assertNotSame(instance, result); [EOL] assertNotNull(result); [EOL] }
public void testCreateContextualWithDelegate() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] ValueInstantiator valueInstantiator = mock(ValueInstantiator.class); [EOL] JavaType delegateType = mock(JavaType.class); [EOL] JsonDeserializer<Object> delegateDeser = mock(JsonDeserializer.class); [EOL] JavaType collectionType = mock(JavaType.class); [EOL] when(_valueInstantiator.canCreateUsingDelegate()).thenReturn(true); [EOL] when(_valueInstantiator.getDelegateType(any(DeserializationConfig.class))).thenReturn(delegateType); [EOL] when(ctxt.getConfig()).thenReturn(mock(DeserializationConfig.class)); [EOL] when(findDeserializer(ctxt, delegateType, property)).thenReturn(delegateDeser); [EOL] when(_collectionType.getContentType()).thenReturn(mock(JavaType.class)); [EOL] when(ctxt.findContextualValueDeserializer(any(JavaType.class), any(BeanProperty.class))).thenReturn(mock(JsonDeserializer.class)); [EOL] when(_valueInstantiator.getClass().getName()).thenReturn("ValueInstantiator"); [EOL] when(_collectionType.toString()).thenReturn("CollectionType"); [EOL] CollectionDeserializer deserializer = createContextual(ctxt, property); [EOL] assertNotNull(deserializer); [EOL] assertEquals(delegateDeser, deserializer._delegateDeserializer); [EOL] }
public void testCreateContextualWithoutDelegate() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] ValueInstantiator valueInstantiator = mock(ValueInstantiator.class); [EOL] when(_valueInstantiator.canCreateUsingDelegate()).thenReturn(false); [EOL] when(_collectionType.getContentType()).thenReturn(mock(JavaType.class)); [EOL] when(ctxt.findContextualValueDeserializer(any(JavaType.class), any(BeanProperty.class))).thenReturn(mock(JsonDeserializer.class)); [EOL] CollectionDeserializer deserializer = createContextual(ctxt, property); [EOL] assertNotNull(deserializer); [EOL] assertNull(deserializer._delegateDeserializer); [EOL] }
public void testCreateContextualWithNullDelegateType() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] ValueInstantiator valueInstantiator = mock(ValueInstantiator.class); [EOL] when(_valueInstantiator.canCreateUsingDelegate()).thenReturn(true); [EOL] when(_valueInstantiator.getDelegateType(any(DeserializationConfig.class))).thenReturn(null); [EOL] when(_valueInstantiator.getClass().getName()).thenReturn("ValueInstantiator"); [EOL] when(_collectionType.toString()).thenReturn("CollectionType"); [EOL] Exception exception = assertThrows(IllegalArgumentException.class, () -> { [EOL] createContextual(ctxt, property); [EOL] }); [EOL] String expectedMessage = "Invalid delegate-creator definition for CollectionType: value instantiator (ValueInstantiator) returned true for 'canCreateUsingDelegate()', but null for 'getDelegateType()'"; [EOL] String actualMessage = exception.getMessage(); [EOL] assertTrue(actualMessage.contains(expectedMessage)); [EOL] }
public void testCreateContextualWithValueDeserializer() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] JsonDeserializer<Object> valueDeser = mock(JsonDeserializer.class); [EOL] when(_valueDeserializer).thenReturn(valueDeser); [EOL] when(findConvertingContentDeserializer(ctxt, property, valueDeser)).thenReturn(valueDeser); [EOL] when(_collectionType.getContentType()).thenReturn(mock(JavaType.class)); [EOL] when(ctxt.findContextualValueDeserializer(any(JavaType.class), any(BeanProperty.class))).thenReturn(valueDeser); [EOL] when(valueDeser instanceof ContextualDeserializer).thenReturn(true); [EOL] when(((ContextualDeserializer) valueDeser).createContextual(ctxt, property)).thenReturn(valueDeser); [EOL] CollectionDeserializer deserializer = createContextual(ctxt, property); [EOL] assertNotNull(deserializer); [EOL] assertEquals(valueDeser, deserializer._valueDeserializer); [EOL] }
public void testCreateContextualWithValueTypeDeserializer() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] TypeDeserializer valueTypeDeser = mock(TypeDeserializer.class); [EOL] when(_valueTypeDeserializer).thenReturn(valueTypeDeser); [EOL] when(valueTypeDeser.forProperty(property)).thenReturn(valueTypeDeser); [EOL] CollectionDeserializer deserializer = createContextual(ctxt, property); [EOL] assertNotNull(deserializer); [EOL] assertEquals(valueTypeDeser, deserializer._valueTypeDeserializer); [EOL] }
public void testDeserializeWithDelegateDeserializer() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JsonDeserializer<Object> delegateDeserializer = mock(JsonDeserializer.class); [EOL] ValueInstantiator valueInstantiator = mock(ValueInstantiator.class); [EOL] Collection<Object> expectedCollection = mock(Collection.class); [EOL] when(_delegateDeserializer.deserialize(jp, ctxt)).thenReturn(new Object()); [EOL] when(valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt))).thenReturn(expectedCollection); [EOL] Collection<Object> result = deserialize(jp, ctxt); [EOL] assertSame(expectedCollection, result); [EOL] }
public void testDeserializeWithEmptyString() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] ValueInstantiator valueInstantiator = mock(ValueInstantiator.class); [EOL] Collection<Object> expectedCollection = mock(Collection.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn(""); [EOL] when(valueInstantiator.createFromString(ctxt, "")).thenReturn(expectedCollection); [EOL] Collection<Object> result = deserialize(jp, ctxt); [EOL] assertSame(expectedCollection, result); [EOL] }
public void testDeserializeUsingDefault() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] ValueInstantiator valueInstantiator = mock(ValueInstantiator.class); [EOL] Collection<Object> expectedCollection = mock(Collection.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.NOT_AVAILABLE); [EOL] when(valueInstantiator.createUsingDefault(ctxt)).thenReturn(expectedCollection); [EOL] Collection<Object> result = deserialize(jp, ctxt); [EOL] assertSame(expectedCollection, result); [EOL] }
public void testDeserializeWithNonArrayToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Collection<Object> result = new ArrayList<>(); [EOL] when(jp.isExpectedStartArrayToken()).thenReturn(false); [EOL] Collection<Object> actual = deserialize(jp, ctxt, result); [EOL] assertNotNull(actual); [EOL] verify(jp, times(1)).isExpectedStartArrayToken(); [EOL] }
public void testDeserializeWithEmptyArray() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Collection<Object> result = new ArrayList<>(); [EOL] when(jp.isExpectedStartArrayToken()).thenReturn(true); [EOL] when(jp.nextToken()).thenReturn(JsonToken.END_ARRAY); [EOL] Collection<Object> actual = deserialize(jp, ctxt, result); [EOL] assertEquals(result, actual); [EOL] verify(jp, times(1)).nextToken(); [EOL] }
public void testDeserializeWithNonNullValues() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Collection<Object> result = new ArrayList<>(); [EOL] JsonDeserializer<Object> valueDes = mock(JsonDeserializer.class); [EOL] when(jp.isExpectedStartArrayToken()).thenReturn(true); [EOL] when(jp.nextToken()).thenReturn(JsonToken.VALUE_STRING).thenReturn(JsonToken.END_ARRAY); [EOL] when(valueDes.deserialize(jp, ctxt)).thenReturn("test"); [EOL] Collection<Object> actual = deserialize(jp, ctxt, result); [EOL] assertTrue(actual.contains("test")); [EOL] verify(jp, times(2)).nextToken(); [EOL] verify(valueDes, times(1)).deserialize(jp, ctxt); [EOL] }
public void testDeserializeWithTypeDeserializer() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Collection<Object> result = new ArrayList<>(); [EOL] JsonDeserializer<Object> valueDes = mock(JsonDeserializer.class); [EOL] TypeDeserializer typeDeser = mock(TypeDeserializer.class); [EOL] when(jp.isExpectedStartArrayToken()).thenReturn(true); [EOL] when(jp.nextToken()).thenReturn(JsonToken.VALUE_STRING).thenReturn(JsonToken.END_ARRAY); [EOL] when(valueDes.deserializeWithType(jp, ctxt, typeDeser)).thenReturn("testWithType"); [EOL] Collection<Object> actual = deserialize(jp, ctxt, result); [EOL] assertTrue(actual.contains("testWithType")); [EOL] verify(jp, times(2)).nextToken(); [EOL] verify(valueDes, times(1)).deserializeWithType(jp, ctxt, typeDeser); [EOL] }
public void testDeserializeWithNullValues() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Collection<Object> result = new ArrayList<>(); [EOL] when(jp.isExpectedStartArrayToken()).thenReturn(true); [EOL] when(jp.nextToken()).thenReturn(JsonToken.VALUE_NULL).thenReturn(JsonToken.END_ARRAY); [EOL] Collection<Object> actual = deserialize(jp, ctxt, result); [EOL] assertTrue(actual.contains(null)); [EOL] verify(jp, times(2)).nextToken(); [EOL] }
public void testSerializationFeatureWithTrue() { [EOL] SerializationFeature feature = new SerializationFeature(true); [EOL] assertTrue(feature.enabledByDefault()); [EOL] }
public void testSerializationFeatureWithFalse() { [EOL] SerializationFeature feature = new SerializationFeature(false); [EOL] assertFalse(feature.enabledByDefault()); [EOL] }
public void testNamedTypeWithNullName() { [EOL] Class<?> clazz = Object.class; [EOL] NamedType namedType = new NamedType(clazz, null); [EOL] assertNull(namedType.getName()); [EOL] assertEquals(clazz, namedType.getType()); [EOL] assertEquals(clazz.getName().hashCode(), namedType.hashCode()); [EOL] }
public void testNamedTypeWithNonNullName() { [EOL] Class<?> clazz = Object.class; [EOL] String name = "CustomName"; [EOL] NamedType namedType = new NamedType(clazz, name); [EOL] assertEquals(name, namedType.getName()); [EOL] assertEquals(clazz, namedType.getType()); [EOL] assertEquals(clazz.getName().hashCode(), namedType.hashCode()); [EOL] }
public void setName_withNullName_setsNameToNull() { [EOL] YourClass instance = new YourClass(); [EOL] String name = null; [EOL] instance.setName(name); [EOL] assertNull(instance.getName()); [EOL] }
public void setName_withEmptyName_setsNameToNull() { [EOL] YourClass instance = new YourClass(); [EOL] String name = ""; [EOL] instance.setName(name); [EOL] assertNull(instance.getName()); [EOL] }
public void setName_withNonEmptyName_setsNameAccordingly() { [EOL] YourClass instance = new YourClass(); [EOL] String name = "Jackson"; [EOL] instance.setName(name); [EOL] assertEquals("Jackson", instance.getName()); [EOL] }
public void testHasNameWhenNameIsNull() { [EOL] JsonProperty prop = new JsonProperty(null); [EOL] assertFalse(prop.hasName()); [EOL] }
public void testHasNameWhenNameIsNotNull() { [EOL] JsonProperty prop = new JsonProperty("propertyName"); [EOL] assertTrue(prop.hasName()); [EOL] }
public void testHashCode_WhenCalled_ReturnsHashCode() { [EOL] MyClass instance = new MyClass(); [EOL] int expectedHashCode = 12345; // Replace with the actual expected hash code [EOL] instance._hashCode = expectedHashCode; // Assuming _hashCode is accessible, otherwise use a setter or constructor [EOL] int actualHashCode = instance.hashCode(); [EOL] assertEquals(expectedHashCode, actualHashCode); [EOL] }
public void testObjectArraySerializerWithStaticTyping() { [EOL] JavaType elemType = TypeFactory.defaultInstance().constructType(String.class); [EOL] TypeSerializer vts = null; [EOL] JsonSerializer<Object> elementSerializer = new StdSerializer<Object>(Object.class) { [EOL] @Override [EOL] public void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException { [EOL] } [EOL] }; [EOL] ObjectArraySerializer serializer = new ObjectArraySerializer(elemType, true, vts, elementSerializer); [EOL] assertNotNull(serializer); [EOL] }
public void testObjectArraySerializerWithoutStaticTyping() { [EOL] JavaType elemType = TypeFactory.defaultInstance().constructType(Integer.class); [EOL] TypeSerializer vts = null; [EOL] JsonSerializer<Object> elementSerializer = null; [EOL] ObjectArraySerializer serializer = new ObjectArraySerializer(elemType, false, vts, elementSerializer); [EOL] assertNotNull(serializer); [EOL] }
public void testObjectArraySerializerWithTypeSerializer() { [EOL] JavaType elemType = TypeFactory.defaultInstance().constructType(Double.class); [EOL] TypeSerializer vts = new TypeSerializer() { [EOL] @Override [EOL] public void writeTypePrefixForScalar(Object value, JsonGenerator gen) throws IOException { [EOL] } [EOL] @Override [EOL] public void writeTypeSuffixForScalar(Object value, JsonGenerator gen) throws IOException { [EOL] } [EOL] @Override [EOL] public void writeTypePrefixForObject(Object value, JsonGenerator gen) throws IOException { [EOL] } [EOL] @Override [EOL] public void writeTypeSuffixForObject(Object value, JsonGenerator gen) throws IOException { [EOL] } [EOL] @Override [EOL] public void writeTypePrefixForArray(Object value, JsonGenerator gen) throws IOException { [EOL] } [EOL] @Override [EOL] public void writeTypeSuffixForArray(Object value, JsonGenerator gen) throws IOException { [EOL] } [EOL] }; [EOL] JsonSerializer<Object> elementSerializer = null; [EOL] ObjectArraySerializer serializer = new ObjectArraySerializer(elemType, false, vts, elementSerializer); [EOL] assertNotNull(serializer); [EOL] }
public void testObjectArraySerializerConstructorWithNonNullValues() { [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] TypeSerializer vts = mock(TypeSerializer.class); [EOL] JsonSerializer<?> elementSerializer = mock(JsonSerializer.class); [EOL] ObjectArraySerializer src = new ObjectArraySerializer(null, null, null, null); [EOL] ObjectArraySerializer serializer = new ObjectArraySerializer(src, property, vts, elementSerializer); [EOL] assertNotNull(serializer); [EOL] assertEquals(property, serializer.getProperty()); [EOL] assertEquals(vts, serializer.getValueTypeSerializer()); [EOL] assertNotNull(serializer.getDynamicSerializers()); [EOL] assertEquals(elementSerializer, serializer.getElementSerializer()); [EOL] }
public void testObjectArraySerializerConstructorWithNullValues() { [EOL] ObjectArraySerializer src = new ObjectArraySerializer(null, null, null, null); [EOL] ObjectArraySerializer serializer = new ObjectArraySerializer(src, null, null, null); [EOL] assertNotNull(serializer); [EOL] assertNull(serializer.getProperty()); [EOL] assertNull(serializer.getValueTypeSerializer()); [EOL] assertNotNull(serializer.getDynamicSerializers()); [EOL] assertNull(serializer.getElementSerializer()); [EOL] }
public void testWithValueTypeSerializerNonNull() { [EOL] TypeSerializer typeSerializer = new TypeSerializerBase() { [EOL] }; [EOL] ObjectArraySerializer originalSerializer = new ObjectArraySerializer( [EOL] SomeElementType.class, true, null, null); [EOL] ContainerSerializer<?> resultSerializer = originalSerializer._withValueTypeSerializer(typeSerializer); [EOL] assertNotNull(resultSerializer); [EOL] assertTrue(resultSerializer instanceof ObjectArraySerializer); [EOL] ObjectArraySerializer resultObjectArraySerializer = (ObjectArraySerializer) resultSerializer; [EOL] assertEquals(typeSerializer, resultObjectArraySerializer._valueTypeSerializer); [EOL] }
public void testWithValueTypeSerializerNull() { [EOL] ObjectArraySerializer originalSerializer = new ObjectArraySerializer( [EOL] SomeElementType.class, true, null, null); [EOL] ContainerSerializer<?> resultSerializer = originalSerializer._withValueTypeSerializer(null); [EOL] assertNotNull(resultSerializer); [EOL] assertTrue(resultSerializer instanceof ObjectArraySerializer); [EOL] ObjectArraySerializer resultObjectArraySerializer = (ObjectArraySerializer) resultSerializer; [EOL] assertNull(resultObjectArraySerializer._valueTypeSerializer); [EOL] }
public void testWithResolvedSameValues() { [EOL] BeanProperty prop = null; [EOL] TypeSerializer vts = null; [EOL] JsonSerializer<?> ser = null; [EOL] ObjectArraySerializer original = new ObjectArraySerializer(null, prop, vts, ser); [EOL] ObjectArraySerializer result = original.withResolved(prop, vts, ser); [EOL] assertSame(original, result); [EOL] }
public void testWithResolvedDifferentValues() { [EOL] BeanProperty prop = null; [EOL] TypeSerializer vts = null; [EOL] JsonSerializer<?> ser = null; [EOL] ObjectArraySerializer original = new ObjectArraySerializer(null, prop, vts, ser); [EOL] BeanProperty newProp = mock(BeanProperty.class); [EOL] TypeSerializer newVts = mock(TypeSerializer.class); [EOL] JsonSerializer<?> newSer = mock(JsonSerializer.class); [EOL] ObjectArraySerializer result = original.withResolved(newProp, newVts, newSer); [EOL] assertNotSame(original, result); [EOL] assertNotNull(result); [EOL] }
public void testCreateContextualWithNonNullTypeSerializerAndProperty() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] TypeSerializer typeSerializer = mock(TypeSerializer.class); [EOL] JsonSerializer<Object> elementSerializer = mock(JsonSerializer.class); [EOL] JsonSerializer<Object> contextualSerializer = mock(JsonSerializer.class); [EOL] AnnotatedMember member = mock(AnnotatedMember.class); [EOL] Object serDef = new Object(); [EOL] when(_valueTypeSerializer).thenReturn(typeSerializer); [EOL] when(typeSerializer.forProperty(property)).thenReturn(typeSerializer); [EOL] when(property.getMember()).thenReturn(member); [EOL] when(provider.getAnnotationIntrospector().findContentSerializer(member)).thenReturn(serDef); [EOL] when(provider.serializerInstance(member, serDef)).thenReturn(elementSerializer); [EOL] when(elementSerializer instanceof ContextualSerializer).thenReturn(true); [EOL] when(((ContextualSerializer) elementSerializer).createContextual(provider, property)).thenReturn(contextualSerializer); [EOL] JsonSerializer<?> result = createContextual(provider, property); [EOL] assertSame(contextualSerializer, result); [EOL] }
public void testCreateContextualWithNullProperty() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] JsonSerializer<Object> elementSerializer = mock(JsonSerializer.class); [EOL] when(_valueTypeSerializer).thenReturn(null); [EOL] when(_elementSerializer).thenReturn(elementSerializer); [EOL] JsonSerializer<?> result = createContextual(provider, null); [EOL] assertSame(elementSerializer, result); [EOL] }
public void testCreateContextualWithNonNullPropertyButNullMember() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] TypeSerializer typeSerializer = mock(TypeSerializer.class); [EOL] JsonSerializer<Object> elementSerializer = mock(JsonSerializer.class); [EOL] when(_valueTypeSerializer).thenReturn(typeSerializer); [EOL] when(typeSerializer.forProperty(property)).thenReturn(typeSerializer); [EOL] when(property.getMember()).thenReturn(null); [EOL] when(_elementSerializer).thenReturn(elementSerializer); [EOL] JsonSerializer<?> result = createContextual(provider, property); [EOL] assertSame(elementSerializer, result); [EOL] }
public void testCreateContextualWithStaticTyping() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] JavaType elementType = mock(JavaType.class); [EOL] JsonSerializer<Object> valueSerializer = mock(JsonSerializer.class); [EOL] when(_valueTypeSerializer).thenReturn(null); [EOL] when(_elementType).thenReturn(elementType); [EOL] when(_staticTyping).thenReturn(true); [EOL] when(provider.findValueSerializer(elementType, property)).thenReturn(valueSerializer); [EOL] JsonSerializer<?> result = createContextual(provider, property); [EOL] assertSame(valueSerializer, result); [EOL] }
public void testCreateContextualWithContentTypeAnnotation() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] JavaType elementType = mock(JavaType.class); [EOL] JsonSerializer<Object> valueSerializer = mock(JsonSerializer.class); [EOL] when(_valueTypeSerializer).thenReturn(null); [EOL] when(_elementType).thenReturn(elementType); [EOL] when(_staticTyping).thenReturn(false); [EOL] when(hasContentTypeAnnotation(provider, property)).thenReturn(true); [EOL] when(provider.findValueSerializer(elementType, property)).thenReturn(valueSerializer); [EOL] JsonSerializer<?> result = createContextual(provider, property); [EOL] assertSame(valueSerializer, result); [EOL] }
public void testSerializeContentsEmptyArray() throws IOException { [EOL] Object[] value = new Object[0]; [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] StdSerializer<Object[]> serializer = new ArraySerializer(); [EOL] serializer.serializeContents(value, jgen, provider); [EOL] verifyNoMoreInteractions(jgen); [EOL] }
public void testSerializeContentsWithElementSerializer() throws IOException { [EOL] Object[] value = new Object[] {"test"}; [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] JsonSerializer<Object> elementSerializer = mock(JsonSerializer.class); [EOL] StdSerializer<Object[]> serializer = new ArraySerializer(elementSerializer, null); [EOL] serializer.serializeContents(value, jgen, provider); [EOL] verify(elementSerializer).serialize(any(), eq(jgen), eq(provider)); [EOL] }
public void testSerializeContentsWithTypeSerializer() throws IOException { [EOL] Object[] value = new Object[] {"test"}; [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] TypeSerializer typeSerializer = mock(TypeSerializer.class); [EOL] StdSerializer<Object[]> serializer = new ArraySerializer(null, typeSerializer); [EOL] serializer.serializeContents(value, jgen, provider); [EOL] verify(jgen, never()).writeString(any(String.class)); [EOL] }
public void testSerializeContentsWithDynamicSerializer() throws IOException { [EOL] Object[] value = new Object[] {"test"}; [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] StdSerializer<Object[]> serializer = new ArraySerializer(); [EOL] serializer.serializeContents(value, jgen, provider); [EOL] verify(jgen).writeString("test"); [EOL] }
public void testSerializeContentsWithIOException() { [EOL] Object[] value = new Object[] {"test"}; [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] StdSerializer<Object[]> serializer = new ArraySerializer(); [EOL] doThrow(IOException.class).when(jgen).writeString(any(String.class)); [EOL] assertThrows(IOException.class, () -> serializer.serializeContents(value, jgen, provider)); [EOL] }
public void testSerializeContentsWithRuntimeException() { [EOL] Object[] value = new Object[] {"test"}; [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] StdSerializer<Object[]> serializer = new ArraySerializer(); [EOL] doThrow(RuntimeException.class).when(jgen).writeString(any(String.class)); [EOL] assertThrows(JsonMappingException.class, () -> serializer.serializeContents(value, jgen, provider)); [EOL] }
public void testSerializeTypedContentsWithEmptyArray() throws IOException { [EOL] Object[] value = new Object[0]; [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] serializeTypedContents(value, jgen, provider); [EOL] verifyNoInteractions(jgen); [EOL] verifyNoInteractions(provider); [EOL] }
public void testSerializeTypedContentsWithNullElement() throws IOException { [EOL] Object[] value = new Object[1]; [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] serializeTypedContents(value, jgen, provider); [EOL] verify(provider).defaultSerializeNull(jgen); [EOL] }
public void testSerializeTypedContentsWithNonNullElement() throws IOException { [EOL] Object[] value = new Object[] { "testString" }; [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] TypeSerializer typeSer = mock(TypeSerializer.class); [EOL] JsonSerializer<Object> serializer = mock(JsonSerializer.class); [EOL] when(_valueTypeSerializer).thenReturn(typeSer); [EOL] when(_dynamicSerializers.serializerFor(any(Class.class))).thenReturn(serializer); [EOL] serializeTypedContents(value, jgen, provider); [EOL] verify(serializer).serializeWithType("testString", jgen, provider, typeSer); [EOL] }
public void testSerializeTypedContentsWithException() throws IOException { [EOL] Object[] value = new Object[] { "testString" }; [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] TypeSerializer typeSer = mock(TypeSerializer.class); [EOL] JsonSerializer<Object> serializer = mock(JsonSerializer.class); [EOL] when(_valueTypeSerializer).thenReturn(typeSer); [EOL] when(_dynamicSerializers.serializerFor(any(Class.class))).thenReturn(null); [EOL] when(_findAndAddDynamic(any(PropertySerializerMap.class), any(Class.class), any(SerializerProvider.class))).thenReturn(serializer); [EOL] doThrow(new IOException()).when(serializer).serializeWithType(any(), any(JsonGenerator.class), any(SerializerProvider.class), any(TypeSerializer.class)); [EOL] try { [EOL] serializeTypedContents(value, jgen, provider); [EOL] fail("IOException expected"); [EOL] } catch (IOException expected) { [EOL] } [EOL] }
protected StdScalarDeserializer(Class<?> vc) { [EOL] super(vc); [EOL] }
private ReadOnlyClassToSerializerMap(JsonSerializerMap map) { [EOL] _map = map; [EOL] }
public void testInstanceNotNull() { [EOL] ReadOnlyClassToSerializerMap readOnlyClassToSerializerMap = new ReadOnlyClassToSerializerMap(null); [EOL] ReadOnlyClassToSerializerMap instance = readOnlyClassToSerializerMap.instance(); [EOL] assertNotNull(instance); [EOL] }
public void testInstanceWithNonNullMap() { [EOL] HashMap<ClassKey, JsonSerializer<Object>> map = new HashMap<>(); [EOL] ReadOnlyClassToSerializerMap readOnlyClassToSerializerMap = new ReadOnlyClassToSerializerMap(map); [EOL] ReadOnlyClassToSerializerMap instance = readOnlyClassToSerializerMap.instance(); [EOL] assertNotNull(instance); [EOL] assertSame(map, instance.getMap()); [EOL] }
public void testFromWithEmptyMap() { [EOL] HashMap<TypeKey, JsonSerializer<Object>> src = new HashMap<>(); [EOL] ReadOnlyClassToSerializerMap result = ReadOnlyClassToSerializerMap.from(src); [EOL] assertNotNull(result); [EOL] assertTrue(result.size() == 0); [EOL] }
public void testFromWithNonEmptyMap() { [EOL] HashMap<TypeKey, JsonSerializer<Object>> src = new HashMap<>(); [EOL] src.put(new TypeKey(SomeClass.class, false), new SomeJsonSerializer()); [EOL] ReadOnlyClassToSerializerMap result = ReadOnlyClassToSerializerMap.from(src); [EOL] assertNotNull(result); [EOL] assertTrue(result.size() == 1); [EOL] }
public void testTypedValueSerializerWithNewTypeKey() { [EOL] TypeKey _cacheKey = null; [EOL] TypeKeyMap<JsonSerializer<Object>> _map = new TypeKeyMap<>(); [EOL] JsonSerializer<Object> expectedSerializer = new SomeJsonSerializer(); [EOL] Class<?> cls = String.class; [EOL] _map.add(new TypeKey(cls, true), expectedSerializer); [EOL] JsonSerializer<Object> result = typedValueSerializer(cls); [EOL] assertNotNull(result); [EOL] assertSame(expectedSerializer, result); [EOL] }
public void testTypedValueSerializerWithExistingTypeKey() { [EOL] TypeKey _cacheKey = new TypeKey(SomeClass.class, true); [EOL] TypeKeyMap<JsonSerializer<Object>> _map = new TypeKeyMap<>(); [EOL] JsonSerializer<Object> expectedSerializer = new SomeJsonSerializer(); [EOL] Class<?> cls = String.class; [EOL] _map.add(new TypeKey(cls, true), expectedSerializer); [EOL] _map.add(_cacheKey, new SomeOtherJsonSerializer()); [EOL] JsonSerializer<Object> result = typedValueSerializer(cls); [EOL] assertNotNull(result); [EOL] assertSame(expectedSerializer, result); [EOL] }
public void testUntypedValueSerializerWithNullCacheKey() { [EOL] StdSerializerProvider provider = new StdSerializerProvider(); [EOL] JavaType type = SimpleType.constructUnsafe(String.class); [EOL] JsonSerializer<Object> serializer = provider.untypedValueSerializer(type); [EOL] assertNotNull(serializer); [EOL] }
public void testUntypedValueSerializerWithNonNullCacheKey() { [EOL] StdSerializerProvider provider = new StdSerializerProvider(); [EOL] JavaType type = SimpleType.constructUnsafe(String.class); [EOL] provider.untypedValueSerializer(type); // This will initialize the _cacheKey [EOL] JsonSerializer<Object> serializer = provider.untypedValueSerializer(type); [EOL] assertNotNull(serializer); [EOL] }
public void testUntypedValueSerializerWithNullCacheKey() { [EOL] JsonSerializerMap map = new JsonSerializerMap(null); [EOL] JsonSerializerProvider provider = new JsonSerializerProvider(map); [EOL] JsonSerializer<Object> serializer = provider.untypedValueSerializer(String.class); [EOL] assertNotNull(serializer); [EOL] }
public void testUntypedValueSerializerWithNonNullCacheKey() { [EOL] JsonSerializerMap map = new JsonSerializerMap(null); [EOL] JsonSerializerProvider provider = new JsonSerializerProvider(map); [EOL] provider._cacheKey = new TypeKey(Integer.class, false); [EOL] JsonSerializer<Object> serializer = provider.untypedValueSerializer(String.class); [EOL] assertNotNull(serializer); [EOL] assertEquals(String.class, provider._cacheKey.getType()); [EOL] }
public void testJSONPObjectWithNonNullValues() { [EOL] String function = "callbackFunction"; [EOL] Object value = new Object(); [EOL] JavaType asType = TypeFactory.defaultInstance().constructType(Object.class); [EOL] JSONPObject jsonpObject = new JSONPObject(function, value, asType); [EOL] assertEquals("callbackFunction", jsonpObject.getFunction()); [EOL] assertEquals(value, jsonpObject.getValue()); [EOL] assertEquals(asType, jsonpObject.getSerializationType()); [EOL] }
public void testJSONPObjectWithNullValues() { [EOL] JSONPObject jsonpObject = new JSONPObject(null, null, null); [EOL] assertNull(jsonpObject.getFunction()); [EOL] assertNull(jsonpObject.getValue()); [EOL] assertNull(jsonpObject.getSerializationType()); [EOL] }
public void testSerializeWithNullValue() throws IOException { [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] CustomSerializer instance = new CustomSerializer(null, null); [EOL] instance.serialize(jgen, provider); [EOL] verify(jgen).writeRaw(instance._function); [EOL] verify(jgen).writeRaw('('); [EOL] verify(provider).defaultSerializeNull(jgen); [EOL] verify(jgen).writeRaw(')'); [EOL] }
public void testSerializeWithType() throws IOException { [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] CustomSerializer instance = new CustomSerializer("value", String.class); [EOL] instance.serialize(jgen, provider); [EOL] verify(jgen).writeRaw(instance._function); [EOL] verify(jgen).writeRaw('('); [EOL] verify(provider).findTypedValueSerializer(String.class, true, null) [EOL] .serialize("value", jgen, provider); [EOL] verify(jgen).writeRaw(')'); [EOL] }
public void testSerializeWithoutType() throws IOException { [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] CustomSerializer instance = new CustomSerializer("value", null); [EOL] instance.serialize(jgen, provider); [EOL] verify(jgen).writeRaw(instance._function); [EOL] verify(jgen).writeRaw('('); [EOL] verify(provider).findTypedValueSerializer(String.class, true, null) [EOL] .serialize("value", jgen, provider); [EOL] verify(jgen).writeRaw(')'); [EOL] }
public void testCustomSerializers() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] SimpleModule module = new SimpleModule(); [EOL] module.addSerializer(new MyCustomSerializer()); [EOL] mapper.registerModule(module); [EOL] Iterable<Serializers> serializers = mapper.getSerializationConfig().customSerializers(); [EOL] assertNotNull(serializers); [EOL] assertTrue(serializers.iterator().hasNext()); [EOL] assertEquals(MyCustomSerializer.class, serializers.iterator().next().getClass()); [EOL] }
public void testCreateSerializerWithAnnotationSerializer() throws JsonMappingException { [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] JavaType origType = mock(JavaType.class); [EOL] SerializationConfig config = mock(SerializationConfig.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] JsonSerializer<Object> expectedSer = mock(JsonSerializer.class); [EOL] AnnotatedClass ac = mock(AnnotatedClass.class); [EOL] when(prov.getConfig()).thenReturn(config); [EOL] when(config.introspect(origType)).thenReturn(beanDesc); [EOL] when(beanDesc.getClassInfo()).thenReturn(ac); [EOL] when(findSerializerFromAnnotation(prov, ac)).thenReturn(expectedSer); [EOL] JsonSerializer<Object> result = createSerializer(prov, origType); [EOL] assertSame(expectedSer, result); [EOL] }
public void testCreateSerializerWithoutAnnotationAndSameType() throws JsonMappingException { [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] JavaType origType = mock(JavaType.class); [EOL] SerializationConfig config = mock(SerializationConfig.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] JsonSerializer<Object> expectedSer = mock(JsonSerializer.class); [EOL] AnnotatedClass ac = mock(AnnotatedClass.class); [EOL] when(prov.getConfig()).thenReturn(config); [EOL] when(config.introspect(origType)).thenReturn(beanDesc); [EOL] when(beanDesc.getClassInfo()).thenReturn(ac); [EOL] when(findSerializerFromAnnotation(prov, ac)).thenReturn(null); [EOL] when(modifyTypeByAnnotation(config, ac, origType)).thenReturn(origType); [EOL] when(_createSerializer2(prov, origType, beanDesc, false)).thenReturn(expectedSer); [EOL] JsonSerializer<Object> result = createSerializer(prov, origType); [EOL] assertSame(expectedSer, result); [EOL] }
public void testCreateSerializerWithoutAnnotationAndDifferentType() throws JsonMappingException { [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] JavaType origType = mock(JavaType.class); [EOL] JavaType modifiedType = mock(JavaType.class); [EOL] SerializationConfig config = mock(SerializationConfig.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] JsonSerializer<Object> expectedSer = mock(JsonSerializer.class); [EOL] AnnotatedClass ac = mock(AnnotatedClass.class); [EOL] Class<?> rawClass = Object.class; [EOL] when(prov.getConfig()).thenReturn(config); [EOL] when(config.introspect(origType)).thenReturn(beanDesc); [EOL] when(config.introspect(modifiedType)).thenReturn(beanDesc); [EOL] when(beanDesc.getClassInfo()).thenReturn(ac); [EOL] when(findSerializerFromAnnotation(prov, ac)).thenReturn(null); [EOL] when(modifyTypeByAnnotation(config, ac, origType)).thenReturn(modifiedType); [EOL] when(origType.getRawClass()).thenReturn(rawClass); [EOL] when(modifiedType.getRawClass()).thenReturn(rawClass); [EOL] when(_createSerializer2(prov, modifiedType, beanDesc, true)).thenReturn(expectedSer); [EOL] JsonSerializer<Object> result = createSerializer(prov, origType); [EOL] assertSame(expectedSer, result); [EOL] }
public void testCreateSerializerWithConverter() throws JsonMappingException { [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] JavaType origType = mock(JavaType.class); [EOL] JavaType modifiedType = mock(JavaType.class); [EOL] JavaType delegateType = mock(JavaType.class); [EOL] SerializationConfig config = mock(SerializationConfig.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] JsonSerializer<Object> delegateSer = mock(JsonSerializer.class); [EOL] Converter<Object, Object> conv = mock(Converter.class); [EOL] AnnotatedClass ac = mock(AnnotatedClass.class); [EOL] TypeFactory typeFactory = mock(TypeFactory.class); [EOL] when(prov.getConfig()).thenReturn(config); [EOL] when(config.introspect(any(JavaType.class))).thenReturn(beanDesc); [EOL] when(beanDesc.getClassInfo()).thenReturn(ac); [EOL] when(findSerializerFromAnnotation(prov, ac)).thenReturn(null); [EOL] when(modifyTypeByAnnotation(config, ac, origType)).thenReturn(modifiedType); [EOL] when(beanDesc.findSerializationConverter()).thenReturn(conv); [EOL] when(conv.getOutputType(typeFactory)).thenReturn(delegateType); [EOL] when(prov.getTypeFactory()).thenReturn(typeFactory); [EOL] when(_createSerializer2(prov, delegateType, beanDesc, true)).thenReturn(delegateSer); [EOL] JsonSerializer<Object> result = createSerializer(prov, origType); [EOL] assertTrue(result instanceof StdDelegatingSerializer); [EOL] }
public void testCreateSerializer2WithSerializerByAnnotations() throws JsonMappingException { [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] JavaType type = mock(JavaType.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] JsonSerializer<?> expectedSerializer = mock(JsonSerializer.class); [EOL] when(findSerializerByAnnotations(prov, type, beanDesc)).thenReturn(expectedSerializer); [EOL] JsonSerializer<?> result = _createSerializer2(prov, type, beanDesc, false); [EOL] assertSame(expectedSerializer, result); [EOL] }
public void testCreateSerializer2WithContainerTypeAndStaticTyping() throws JsonMappingException { [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] JavaType type = mock(JavaType.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] SerializationConfig config = mock(SerializationConfig.class); [EOL] when(prov.getConfig()).thenReturn(config); [EOL] when(type.isContainerType()).thenReturn(true); [EOL] JsonSerializer<?> expectedSerializer = mock(JsonSerializer.class); [EOL] when(buildContainerSerializer(prov, type, beanDesc, true)).thenReturn(expectedSerializer); [EOL] JsonSerializer<?> result = _createSerializer2(prov, type, beanDesc, true); [EOL] assertSame(expectedSerializer, result); [EOL] }
public void testCreateSerializer2WithCustomSerializers() throws JsonMappingException { [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] JavaType type = mock(JavaType.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] SerializationConfig config = mock(SerializationConfig.class); [EOL] when(prov.getConfig()).thenReturn(config); [EOL] when(type.isContainerType()).thenReturn(false); [EOL] JsonSerializer<?> expectedSerializer = mock(JsonSerializer.class); [EOL] Serializers serializers = mock(Serializers.class); [EOL] when(serializers.findSerializer(config, type, beanDesc)).thenReturn(expectedSerializer); [EOL] when(customSerializers()).thenReturn(Collections.singletonList(serializers)); [EOL] JsonSerializer<?> result = _createSerializer2(prov, type, beanDesc, false); [EOL] assertSame(expectedSerializer, result); [EOL] }
public void testCreateSerializer2WithSerializerByLookup() throws JsonMappingException { [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] JavaType type = mock(JavaType.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] SerializationConfig config = mock(SerializationConfig.class); [EOL] when(prov.getConfig()).thenReturn(config); [EOL] when(type.isContainerType()).thenReturn(false); [EOL] when(customSerializers()).thenReturn(Collections.emptyList()); [EOL] JsonSerializer<?> expectedSerializer = mock(JsonSerializer.class); [EOL] when(findSerializerByLookup(type, config, beanDesc, false)).thenReturn(expectedSerializer); [EOL] JsonSerializer<?> result = _createSerializer2(prov, type, beanDesc, false); [EOL] assertSame(expectedSerializer, result); [EOL] }
public void testCreateSerializer2WithSerializerModifiers() throws JsonMappingException { [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] JavaType type = mock(JavaType.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] SerializationConfig config = mock(SerializationConfig.class); [EOL] when(prov.getConfig()).thenReturn(config); [EOL] when(type.isContainerType()).thenReturn(false); [EOL] when(customSerializers()).thenReturn(Collections.emptyList()); [EOL] when(findSerializerByLookup(type, config, beanDesc, false)).thenReturn(null); [EOL] when(findSerializerByPrimaryType(prov, type, beanDesc, false)).thenReturn(null); [EOL] when(findBeanSerializer(prov, type, beanDesc)).thenReturn(null); [EOL] when(findSerializerByAddonType(config, type, beanDesc, false)).thenReturn(null); [EOL] JsonSerializer<?> initialSerializer = mock(JsonSerializer.class); [EOL] JsonSerializer<?> modifiedSerializer = mock(JsonSerializer.class); [EOL] BeanSerializerModifier modifier = mock(BeanSerializerModifier.class); [EOL] when(modifier.modifySerializer(config, beanDesc, initialSerializer)).thenReturn(modifiedSerializer); [EOL] when(_factoryConfig.hasSerializerModifiers()).thenReturn(true); [EOL] when(_factoryConfig.serializerModifiers()).thenReturn(Collections.singletonList(modifier)); [EOL] JsonSerializer<?> result = _createSerializer2(prov, type, beanDesc, false); [EOL] assertSame(modifiedSerializer, result); [EOL] }
public void testFindBeanSerializerWithNonBeanType() { [EOL] SerializerProvider prov = null; // Mock or create instance as needed [EOL] JavaType nonBeanType = null; // Create a JavaType instance that is not a potential bean type [EOL] BeanDescription beanDesc = null; // Mock or create instance as needed [EOL] JsonSerializer<Object> result = findBeanSerializer(prov, nonBeanType, beanDesc); [EOL] assertNull(result); [EOL] }
public void testFindBeanSerializerWithEnumType() { [EOL] SerializerProvider prov = null; // Mock or create instance as needed [EOL] JavaType enumType = null; // Create a JavaType instance that represents an enum type [EOL] BeanDescription beanDesc = null; // Mock or create instance as needed [EOL] JsonSerializer<Object> result = findBeanSerializer(prov, enumType, beanDesc); [EOL] assertNotNull(result); [EOL] }
public void testFindBeanSerializerWithBeanType() { [EOL] SerializerProvider prov = null; // Mock or create instance as needed [EOL] JavaType beanType = null; // Create a JavaType instance that is a potential bean type [EOL] BeanDescription beanDesc = null; // Mock or create instance as needed [EOL] JsonSerializer<Object> result = findBeanSerializer(prov, beanType, beanDesc); [EOL] assertNotNull(result); [EOL] }
public void testFindPropertyTypeSerializerWithNullBuilder() throws JsonMappingException { [EOL] SerializationConfig config = new SerializationConfig(...); // Provide actual initialization [EOL] AnnotatedMember accessor = ...; // Provide actual initialization [EOL] JavaType baseType = ...; // Provide actual initialization [EOL] TypeSerializer result = findPropertyTypeSerializer(baseType, config, accessor); [EOL] assertNotNull(result); [EOL] }
public void testFindPropertyTypeSerializerWithNonNullBuilder() throws JsonMappingException { [EOL] SerializationConfig config = new SerializationConfig(...); // Provide actual initialization [EOL] AnnotatedMember accessor = ...; // Provide actual initialization [EOL] JavaType baseType = ...; // Provide actual initialization [EOL] AnnotationIntrospector ai = config.getAnnotationIntrospector(); [EOL] TypeResolverBuilder<?> b = Mockito.mock(TypeResolverBuilder.class); [EOL] Mockito.when(ai.findPropertyTypeResolver(config, accessor, baseType)).thenReturn(b); [EOL] Mockito.when(b.buildTypeSerializer(Mockito.any(), Mockito.any(), Mockito.any())).thenReturn(Mockito.mock(TypeSerializer.class)); [EOL] TypeSerializer result = findPropertyTypeSerializer(baseType, config, accessor); [EOL] assertNotNull(result); [EOL] }
public void testFindPropertyContentTypeSerializerWithNullBuilder() throws JsonMappingException { [EOL] SerializationConfig config = new SerializationConfig(...); // Provide actual initialization [EOL] JavaType containerType = ...; // Provide actual initialization [EOL] AnnotatedMember accessor = ...; // Provide actual initialization [EOL] TypeSerializer result = findPropertyContentTypeSerializer(containerType, config, accessor); [EOL] assertNotNull(result); [EOL] }
public void testFindPropertyContentTypeSerializerWithNonNullBuilder() throws JsonMappingException { [EOL] SerializationConfig config = new SerializationConfig(...); // Provide actual initialization [EOL] JavaType containerType = ...; // Provide actual initialization [EOL] AnnotatedMember accessor = ...; // Provide actual initialization [EOL] AnnotationIntrospector ai = config.getAnnotationIntrospector(); [EOL] when(ai.findPropertyContentTypeResolver(config, accessor, containerType)).thenReturn(...); // Provide actual TypeResolverBuilder [EOL] TypeSerializer result = findPropertyContentTypeSerializer(containerType, config, accessor); [EOL] assertNotNull(result); [EOL] }
public void testConstructBeanSerializerWithObjectClass() { [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] when(beanDesc.getBeanClass()).thenReturn(Object.class); [EOL] when(prov.getUnknownTypeSerializer(Object.class)).thenReturn(mock(JsonSerializer.class)); [EOL] JsonSerializer<Object> result = constructBeanSerializer(prov, beanDesc); [EOL] assertNotNull(result); [EOL] }
public void testConstructBeanSerializerWithModifiers() { [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] SerializationConfig config = mock(SerializationConfig.class); [EOL] when(beanDesc.getBeanClass()).thenReturn(SomeBean.class); [EOL] when(prov.getConfig()).thenReturn(config); [EOL] when(beanDesc.findAnyGetter()).thenReturn(null); [EOL] SerializerFactoryConfig factoryConfig = mock(SerializerFactoryConfig.class); [EOL] when(factoryConfig.hasSerializerModifiers()).thenReturn(true); [EOL] when(factoryConfig.serializerModifiers()).thenReturn(Collections.singletonList(mock(BeanSerializerModifier.class))); [EOL] setFactoryConfig(factoryConfig); // Assuming there's a method to set _factoryConfig [EOL] JsonSerializer<Object> result = constructBeanSerializer(prov, beanDesc); [EOL] assertNotNull(result); [EOL] }
public void testConstructBeanSerializerWithoutModifiers() { [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] SerializationConfig config = mock(SerializationConfig.class); [EOL] when(beanDesc.getBeanClass()).thenReturn(SomeBean.class); [EOL] when(prov.getConfig()).thenReturn(config); [EOL] when(beanDesc.findAnyGetter()).thenReturn(null); [EOL] SerializerFactoryConfig factoryConfig = mock(SerializerFactoryConfig.class); [EOL] when(factoryConfig.hasSerializerModifiers()).thenReturn(false); [EOL] setFactoryConfig(factoryConfig); // Assuming there's a method to set _factoryConfig [EOL] JsonSerializer<Object> result = constructBeanSerializer(prov, beanDesc); [EOL] assertNotNull(result); [EOL] }
public void testConstructBeanSerializerWithAnyGetter() { [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] SerializationConfig config = mock(SerializationConfig.class); [EOL] when(beanDesc.getBeanClass()).thenReturn(SomeBean.class); [EOL] when(prov.getConfig()).thenReturn(config); [EOL] AnnotatedMember anyGetter = mock(AnnotatedMember.class); [EOL] when(beanDesc.findAnyGetter()).thenReturn(anyGetter); [EOL] when(config.canOverrideAccessModifiers()).thenReturn(true); [EOL] JsonSerializer<Object> result = constructBeanSerializer(prov, beanDesc); [EOL] assertNotNull(result); [EOL] }
public void testConstructBeanSerializerWithNullSerializer() { [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] SerializationConfig config = mock(SerializationConfig.class); [EOL] when(beanDesc.getBeanClass()).thenReturn(SomeBean.class); [EOL] when(prov.getConfig()).thenReturn(config); [EOL] when(beanDesc.findAnyGetter()).thenReturn(null); [EOL] BeanSerializerBuilder builder = mock(BeanSerializerBuilder.class); [EOL] when(builder.build()).thenReturn(null); [EOL] when(beanDesc.hasKnownClassAnnotations()).thenReturn(true); [EOL] when(builder.createDummy()).thenReturn(mock(JsonSerializer.class)); [EOL] setBuilder(builder); // Assuming there's a method to set a custom builder [EOL] JsonSerializer<Object> result = constructBeanSerializer(prov, beanDesc); [EOL] assertNotNull(result); [EOL] }
public void testConstructObjectIdHandlerWithNullObjectIdInfo() throws JsonMappingException { [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] when(beanDesc.getObjectIdInfo()).thenReturn(null); [EOL] ObjectIdWriter result = constructObjectIdHandler(prov, beanDesc, new ArrayList<>()); [EOL] assertNull(result); [EOL] }
public void testConstructObjectIdHandlerWithPropertyGenerator() throws JsonMappingException { [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] ObjectIdInfo objectIdInfo = mock(ObjectIdInfo.class); [EOL] when(beanDesc.getObjectIdInfo()).thenReturn(objectIdInfo); [EOL] when(objectIdInfo.getGeneratorType()).thenReturn(ObjectIdGenerators.PropertyGenerator.class); [EOL] when(objectIdInfo.getPropertyName()).thenReturn("id"); [EOL] List<BeanPropertyWriter> props = new ArrayList<>(); [EOL] BeanPropertyWriter idProp = mock(BeanPropertyWriter.class); [EOL] when(idProp.getName()).thenReturn("id"); [EOL] props.add(idProp); [EOL] ObjectIdWriter result = constructObjectIdHandler(prov, beanDesc, props); [EOL] assertNotNull(result); [EOL] assertEquals(idProp, props.get(0)); // The id property should be moved to the first position [EOL] }
public void testConstructObjectIdHandlerWithPropertyGeneratorAndMissingProperty() { [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] ObjectIdInfo objectIdInfo = mock(ObjectIdInfo.class); [EOL] when(beanDesc.getObjectIdInfo()).thenReturn(objectIdInfo); [EOL] when(objectIdInfo.getGeneratorType()).thenReturn(ObjectIdGenerators.PropertyGenerator.class); [EOL] when(objectIdInfo.getPropertyName()).thenReturn("id"); [EOL] List<BeanPropertyWriter> props = new ArrayList<>(); [EOL] BeanPropertyWriter otherProp = mock(BeanPropertyWriter.class); [EOL] when(otherProp.getName()).thenReturn("other"); [EOL] props.add(otherProp); [EOL] Exception exception = assertThrows(IllegalArgumentException.class, () -> { [EOL] constructObjectIdHandler(prov, beanDesc, props); [EOL] }); [EOL] String expectedMessage = "Invalid Object Id definition for "; [EOL] String actualMessage = exception.getMessage(); [EOL] assertTrue(actualMessage.contains(expectedMessage)); [EOL] }
public void testConstructObjectIdHandlerWithNonPropertyGenerator() throws JsonMappingException { [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] ObjectIdInfo objectIdInfo = mock(ObjectIdInfo.class); [EOL] when(beanDesc.getObjectIdInfo()).thenReturn(objectIdInfo); [EOL] when(objectIdInfo.getGeneratorType()).thenReturn(ObjectIdGenerators.IntSequenceGenerator.class); [EOL] when(objectIdInfo.getPropertyName()).thenReturn("id"); [EOL] when(prov.constructType(ObjectIdGenerators.IntSequenceGenerator.class)).thenReturn(mock(JavaType.class)); [EOL] when(prov.getTypeFactory()).thenReturn(mock(TypeFactory.class)); [EOL] when(prov.objectIdGeneratorInstance(any(), any())).thenReturn(mock(ObjectIdGenerator.class)); [EOL] JavaType type = mock(JavaType.class); [EOL] when(prov.constructType(ObjectIdGenerators.IntSequenceGenerator.class)).thenReturn(type); [EOL] JavaType idType = mock(JavaType.class); [EOL] when(prov.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)).thenReturn(new JavaType[]{idType}); [EOL] ObjectIdWriter result = constructObjectIdHandler(prov, beanDesc, new ArrayList<>()); [EOL] assertNotNull(result); [EOL] }
public void testConstructFilteredBeanWriterWithNullViews() { [EOL] BeanPropertyWriter writer = mock(BeanPropertyWriter.class); [EOL] BeanPropertyWriter result = constructFilteredBeanWriter(writer, null); [EOL] assertSame(writer, result); [EOL] }
public void testConstructFilteredBeanWriterWithEmptyViews() { [EOL] BeanPropertyWriter writer = mock(BeanPropertyWriter.class); [EOL] Class<?>[] inViews = new Class<?>[0]; [EOL] BeanPropertyWriter result = constructFilteredBeanWriter(writer, inViews); [EOL] assertSame(writer, result); [EOL] }
public void testConstructFilteredBeanWriterWithNonNullViews() { [EOL] BeanPropertyWriter writer = mock(BeanPropertyWriter.class); [EOL] Class<?>[] inViews = new Class<?>[] {View.class}; [EOL] BeanPropertyWriter result = constructFilteredBeanWriter(writer, inViews); [EOL] assertNotNull(result); [EOL] assertNotSame(writer, result); [EOL] }
protected PropertyBuilder constructPropertyBuilder(SerializationConfig config, BeanDescription beanDesc) { [EOL] return new PropertyBuilder(config, beanDesc); [EOL] }
protected BeanSerializerBuilder constructBeanSerializerBuilder(BeanDescription beanDesc) { [EOL] return new BeanSerializerBuilder(beanDesc); [EOL] }
public void testFindFilterIdWithNonNullConfigAndBeanDesc() { [EOL] SerializationConfig config = mock(SerializationConfig.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] AnnotationIntrospector introspector = mock(AnnotationIntrospector.class); [EOL] ClassInfo classInfo = mock(ClassInfo.class); [EOL] Object expectedFilterId = new Object(); [EOL] when(beanDesc.getClassInfo()).thenReturn(classInfo); [EOL] when(config.getAnnotationIntrospector()).thenReturn(introspector); [EOL] when(introspector.findFilterId(classInfo)).thenReturn(expectedFilterId); [EOL] Object actualFilterId = findFilterId(config, beanDesc); [EOL] assertSame(expectedFilterId, actualFilterId); [EOL] }
public void testFindFilterIdWithNullConfig() { [EOL] SerializationConfig config = null; [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] try { [EOL] findFilterId(config, beanDesc); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testFindFilterIdWithNullBeanDesc() { [EOL] SerializationConfig config = mock(SerializationConfig.class); [EOL] BeanDescription beanDesc = null; [EOL] try { [EOL] findFilterId(config, beanDesc); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
protected boolean isPotentialBeanType(Class<?> type) { [EOL] return (ClassUtil.canBeABeanType(type) == null) && !ClassUtil.isProxyType(type); [EOL] }
public void testFindBeanPropertiesWithEmptyProperties() throws JsonMappingException { [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] BeanSerializerBuilder builder = mock(BeanSerializerBuilder.class); [EOL] when(beanDesc.findProperties()).thenReturn(Collections.emptyList()); [EOL] SerializationConfig config = mock(SerializationConfig.class); [EOL] when(prov.getConfig()).thenReturn(config); [EOL] List<BeanPropertyWriter> result = findBeanProperties(prov, beanDesc, builder); [EOL] assertNull(result); [EOL] }
public void testFindBeanPropertiesWithIgnorableTypes() throws JsonMappingException { [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] BeanSerializerBuilder builder = mock(BeanSerializerBuilder.class); [EOL] List<BeanPropertyDefinition> properties = new ArrayList<>(); [EOL] properties.add(mock(BeanPropertyDefinition.class)); [EOL] when(beanDesc.findProperties()).thenReturn(properties); [EOL] SerializationConfig config = mock(SerializationConfig.class); [EOL] when(prov.getConfig()).thenReturn(config); [EOL] doNothing().when(this).removeIgnorableTypes(any(SerializationConfig.class), any(BeanDescription.class), anyList()); [EOL] List<BeanPropertyWriter> result = findBeanProperties(prov, beanDesc, builder); [EOL] assertNotNull(result); [EOL] assertFalse(result.isEmpty()); [EOL] }
public void testFindBeanPropertiesWithSetterlessGetters() throws JsonMappingException { [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] BeanSerializerBuilder builder = mock(BeanSerializerBuilder.class); [EOL] List<BeanPropertyDefinition> properties = new ArrayList<>(); [EOL] BeanPropertyDefinition property = mock(BeanPropertyDefinition.class); [EOL] properties.add(property); [EOL] when(beanDesc.findProperties()).thenReturn(properties); [EOL] SerializationConfig config = mock(SerializationConfig.class); [EOL] when(prov.getConfig()).thenReturn(config); [EOL] when(config.isEnabled(MapperFeature.REQUIRE_SETTERS_FOR_GETTERS)).thenReturn(true); [EOL] doNothing().when(this).removeSetterlessGetters(any(SerializationConfig.class), any(BeanDescription.class), anyList()); [EOL] List<BeanPropertyWriter> result = findBeanProperties(prov, beanDesc, builder); [EOL] assertNotNull(result); [EOL] assertFalse(result.isEmpty()); [EOL] }
public void testFindBeanPropertiesWithTypeIds() throws JsonMappingException { [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] BeanSerializerBuilder builder = mock(BeanSerializerBuilder.class); [EOL] List<BeanPropertyDefinition> properties = new ArrayList<>(); [EOL] BeanPropertyDefinition property = mock(BeanPropertyDefinition.class); [EOL] when(property.isTypeId()).thenReturn(true); [EOL] properties.add(property); [EOL] when(beanDesc.findProperties()).thenReturn(properties); [EOL] SerializationConfig config = mock(SerializationConfig.class); [EOL] when(prov.getConfig()).thenReturn(config); [EOL] AnnotatedMember accessor = mock(AnnotatedMember.class); [EOL] when(property.getAccessor()).thenReturn(accessor); [EOL] when(config.canOverrideAccessModifiers()).thenReturn(true); [EOL] List<BeanPropertyWriter> result = findBeanProperties(prov, beanDesc, builder); [EOL] assertNotNull(result); [EOL] assertTrue(result.isEmpty()); [EOL] }
public void testFindBeanPropertiesWithBackReference() throws JsonMappingException { [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] BeanSerializerBuilder builder = mock(BeanSerializerBuilder.class); [EOL] List<BeanPropertyDefinition> properties = new ArrayList<>(); [EOL] BeanPropertyDefinition property = mock(BeanPropertyDefinition.class); [EOL] AnnotationIntrospector.ReferenceProperty refType = mock(AnnotationIntrospector.ReferenceProperty.class); [EOL] when(property.findReferenceType()).thenReturn(refType); [EOL] when(refType.isBackReference()).thenReturn(true); [EOL] properties.add(property); [EOL] when(beanDesc.findProperties()).thenReturn(properties); [EOL] SerializationConfig config = mock(SerializationConfig.class); [EOL] when(prov.getConfig()).thenReturn(config); [EOL] List<BeanPropertyWriter> result = findBeanProperties(prov, beanDesc, builder); [EOL] assertNotNull(result); [EOL] assertTrue(result.isEmpty()); [EOL] }
public void testFindBeanPropertiesWithAccessorMethod() throws JsonMappingException { [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] BeanSerializerBuilder builder = mock(BeanSerializerBuilder.class); [EOL] List<BeanPropertyDefinition> properties = new ArrayList<>(); [EOL] BeanPropertyDefinition property = mock(BeanPropertyDefinition.class); [EOL] properties.add(property); [EOL] when(beanDesc.findProperties()).thenReturn(properties); [EOL] SerializationConfig config = mock(SerializationConfig.class); [EOL] when(prov.getConfig()).thenReturn(config); [EOL] AnnotatedMethod accessor = mock(AnnotatedMethod.class); [EOL] when(property.getAccessor()).thenReturn(accessor); [EOL] when(accessor instanceof AnnotatedMethod).thenReturn(true); [EOL] List<BeanPropertyWriter> result = findBeanProperties(prov, beanDesc, builder); [EOL] assertNotNull(result); [EOL] assertFalse(result.isEmpty()); [EOL] assertEquals(1, result.size()); [EOL] }
public void testFindBeanPropertiesWithAccessorField() throws JsonMappingException { [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] BeanSerializerBuilder builder = mock(BeanSerializerBuilder.class); [EOL] List<BeanPropertyDefinition> properties = new ArrayList<>(); [EOL] BeanPropertyDefinition property = mock(BeanPropertyDefinition.class); [EOL] properties.add(property); [EOL] when(beanDesc.findProperties()).thenReturn(properties); [EOL] SerializationConfig config = mock(SerializationConfig.class); [EOL] when(prov.getConfig()).thenReturn(config); [EOL] AnnotatedField accessor = mock(AnnotatedField.class); [EOL] when(property.getAccessor()).thenReturn(accessor); [EOL] when(accessor instanceof AnnotatedMethod).thenReturn(false); [EOL] List<BeanPropertyWriter> result = findBeanProperties(prov, beanDesc, builder); [EOL] assertNotNull(result); [EOL] assertFalse(result.isEmpty()); [EOL] assertEquals(1, result.size()); [EOL] }
public void testFilterBeanPropertiesWithNoPropertiesToIgnore() { [EOL] SerializationConfig config = createMockConfig(); [EOL] BeanDescription beanDesc = createMockBeanDescription(); [EOL] List<BeanPropertyWriter> props = createMockPropertyWriters(); [EOL] AnnotationIntrospector intr = mock(AnnotationIntrospector.class); [EOL] when(config.getAnnotationIntrospector()).thenReturn(intr); [EOL] when(intr.findPropertiesToIgnore(any(AnnotatedClass.class))).thenReturn(null); [EOL] List<BeanPropertyWriter> filteredProps = filterBeanProperties(config, beanDesc, props); [EOL] assertEquals(props.size(), filteredProps.size()); [EOL] }
public void testFilterBeanPropertiesWithPropertiesToIgnore() { [EOL] SerializationConfig config = createMockConfig(); [EOL] BeanDescription beanDesc = createMockBeanDescription(); [EOL] List<BeanPropertyWriter> props = createMockPropertyWriters(); [EOL] String[] ignored = new String[]{"propToIgnore"}; [EOL] AnnotationIntrospector intr = mock(AnnotationIntrospector.class); [EOL] when(config.getAnnotationIntrospector()).thenReturn(intr); [EOL] when(intr.findPropertiesToIgnore(any(AnnotatedClass.class))).thenReturn(ignored); [EOL] List<BeanPropertyWriter> filteredProps = filterBeanProperties(config, beanDesc, props); [EOL] assertEquals(props.size() - ignored.length, filteredProps.size()); [EOL] for (BeanPropertyWriter writer : filteredProps) { [EOL] assertFalse(ArrayUtils.contains(ignored, writer.getName())); [EOL] } [EOL] }
protected void processViews(SerializationConfig config, BeanSerializerBuilder builder) { [EOL] List<BeanPropertyWriter> props = builder.getProperties(); [EOL] boolean includeByDefault = config.isEnabled(MapperFeature.DEFAULT_VIEW_INCLUSION); [EOL] final int propCount = props.size(); [EOL] int viewsFound = 0; [EOL] BeanPropertyWriter[] filtered = new BeanPropertyWriter[propCount]; [EOL] for (int i = 0; i < propCount; ++i) { [EOL] BeanPropertyWriter bpw = props.get(i); [EOL] Class<?>[] views = bpw.getViews(); [EOL] if (views == null) { [EOL] if (includeByDefault) { [EOL] filtered[i] = bpw; [EOL] } [EOL] } else { [EOL] ++viewsFound; [EOL] filtered[i] = constructFilteredBeanWriter(bpw, views); [EOL] } [EOL] } [EOL] if (includeByDefault && viewsFound == 0) { [EOL] return; [EOL] } [EOL] builder.setFilteredProperties(filtered); [EOL] }
public void testRemoveIgnorableTypesWithNoIgnorables() { [EOL] SerializationConfig config = createSerializationConfig(); [EOL] BeanDescription beanDesc = createBeanDescription(); [EOL] List<BeanPropertyDefinition> properties = createPropertiesWithNoIgnorables(); [EOL] removeIgnorableTypes(config, beanDesc, properties); [EOL] assertEquals("Expected no properties to be removed", properties.size(), expectedPropertiesSizeWithNoIgnorables()); [EOL] }
public void testRemoveIgnorableTypesWithSomeIgnorables() { [EOL] SerializationConfig config = createSerializationConfig(); [EOL] BeanDescription beanDesc = createBeanDescription(); [EOL] List<BeanPropertyDefinition> properties = createPropertiesWithSomeIgnorables(); [EOL] removeIgnorableTypes(config, beanDesc, properties); [EOL] assertEquals("Expected some properties to be removed", properties.size(), expectedPropertiesSizeWithSomeIgnorables()); [EOL] }
public void testRemoveIgnorableTypesWithAllIgnorables() { [EOL] SerializationConfig config = createSerializationConfig(); [EOL] BeanDescription beanDesc = createBeanDescription(); [EOL] List<BeanPropertyDefinition> properties = createPropertiesWithAllIgnorables(); [EOL] removeIgnorableTypes(config, beanDesc, properties); [EOL] assertTrue("Expected all properties to be removed", properties.isEmpty()); [EOL] }
public void testRemoveIgnorableTypesWithNullAccessor() { [EOL] SerializationConfig config = createSerializationConfig(); [EOL] BeanDescription beanDesc = createBeanDescription(); [EOL] List<BeanPropertyDefinition> properties = createPropertiesWithNullAccessor(); [EOL] removeIgnorableTypes(config, beanDesc, properties); [EOL] assertEquals("Expected properties with null accessor to be removed", properties.size(), expectedPropertiesSizeWithNullAccessor()); [EOL] }
public void test_constructWriter_canOverrideAccessModifiers() throws JsonMappingException { [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] BeanPropertyDefinition propDef = mock(BeanPropertyDefinition.class); [EOL] TypeBindings typeContext = mock(TypeBindings.class); [EOL] PropertyBuilder pb = mock(PropertyBuilder.class); [EOL] AnnotatedMember accessor = mock(AnnotatedMember.class); [EOL] when(prov.canOverrideAccessModifiers()).thenReturn(true); [EOL] when(propDef.getName()).thenReturn("propertyName"); [EOL] when(accessor.getType(typeContext)).thenReturn(mock(JavaType.class)); [EOL] when(propDef.getWrapperName()).thenReturn(null); [EOL] when(pb.getClassAnnotations()).thenReturn(mock(Annotations.class)); [EOL] when(propDef.isRequired()).thenReturn(false); [EOL] when(accessor.fixAccess()).thenReturn(null); [EOL] BeanPropertyWriter result = _constructWriter(prov, propDef, typeContext, pb, false, accessor); [EOL] assertNotNull(result); [EOL] }
public void test_constructWriter_noOverrideAccessModifiers() throws JsonMappingException { [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] BeanPropertyDefinition propDef = mock(BeanPropertyDefinition.class); [EOL] TypeBindings typeContext = mock(TypeBindings.class); [EOL] PropertyBuilder pb = mock(PropertyBuilder.class); [EOL] AnnotatedMember accessor = mock(AnnotatedMember.class); [EOL] when(prov.canOverrideAccessModifiers()).thenReturn(false); [EOL] when(propDef.getName()).thenReturn("propertyName"); [EOL] when(accessor.getType(typeContext)).thenReturn(mock(JavaType.class)); [EOL] when(propDef.getWrapperName()).thenReturn(null); [EOL] when(pb.getClassAnnotations()).thenReturn(mock(Annotations.class)); [EOL] when(propDef.isRequired()).thenReturn(false); [EOL] BeanPropertyWriter result = _constructWriter(prov, propDef, typeContext, pb, false, accessor); [EOL] assertNotNull(result); [EOL] }
public void test_constructWriter_withAnnotatedSerializer() throws JsonMappingException { [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] BeanPropertyDefinition propDef = mock(BeanPropertyDefinition.class); [EOL] TypeBindings typeContext = mock(TypeBindings.class); [EOL] PropertyBuilder pb = mock(PropertyBuilder.class); [EOL] AnnotatedMember accessor = mock(AnnotatedMember.class); [EOL] JsonSerializer<?> annotatedSerializer = mock(JsonSerializer.class); [EOL] when(prov.canOverrideAccessModifiers()).thenReturn(true); [EOL] when(propDef.getName()).thenReturn("propertyName"); [EOL] when(accessor.getType(typeContext)).thenReturn(mock(JavaType.class)); [EOL] when(propDef.getWrapperName()).thenReturn(null); [EOL] when(pb.getClassAnnotations()).thenReturn(mock(Annotations.class)); [EOL] when(propDef.isRequired()).thenReturn(false); [EOL] when(findSerializerFromAnnotation(prov, accessor)).thenReturn(annotatedSerializer); [EOL] when(annotatedSerializer instanceof ResolvableSerializer).thenReturn(true); [EOL] when(annotatedSerializer instanceof ContextualSerializer).thenReturn(true); [EOL] BeanPropertyWriter result = _constructWriter(prov, propDef, typeContext, pb, false, accessor); [EOL] assertNotNull(result); [EOL] }
public void test_constructWriter_withCollectionMapOrArray() throws JsonMappingException { [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] BeanPropertyDefinition propDef = mock(BeanPropertyDefinition.class); [EOL] TypeBindings typeContext = mock(TypeBindings.class); [EOL] PropertyBuilder pb = mock(PropertyBuilder.class); [EOL] AnnotatedMember accessor = mock(AnnotatedMember.class); [EOL] JavaType javaType = mock(JavaType.class); [EOL] when(prov.canOverrideAccessModifiers()).thenReturn(true); [EOL] when(propDef.getName()).thenReturn("propertyName"); [EOL] when(accessor.getType(typeContext)).thenReturn(javaType); [EOL] when(javaType.getRawClass()).thenReturn(ArrayList.class); [EOL] when(propDef.getWrapperName()).thenReturn(null); [EOL] when(pb.getClassAnnotations()).thenReturn(mock(Annotations.class)); [EOL] when(propDef.isRequired()).thenReturn(false); [EOL] when(ClassUtil.isCollectionMapOrArray(javaType.getRawClass())).thenReturn(true); [EOL] BeanPropertyWriter result = _constructWriter(prov, propDef, typeContext, pb, false, accessor); [EOL] assertNotNull(result); [EOL] }
public void testConstructTypeWithClassType() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] JavaType javaType = mapper.constructType(String.class); [EOL] assertNotNull(javaType); [EOL] assertTrue(javaType.isTypeOrSubTypeOf(String.class)); [EOL] }
public void testConstructTypeWithParameterizedType() throws NoSuchFieldException { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] Type type = getClass().getDeclaredField("listOfString").getGenericType(); [EOL] JavaType javaType = mapper.constructType(type); [EOL] assertNotNull(javaType); [EOL] assertTrue(javaType.isTypeOrSubTypeOf(List.class)); [EOL] assertTrue(javaType.containedType(0).isTypeOrSubTypeOf(String.class)); [EOL] }
public void testConstructTypeWithGenericArrayType() throws NoSuchFieldException { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] Type type = getClass().getDeclaredField("arrayOfListOfString").getGenericType(); [EOL] JavaType javaType = mapper.constructType(type); [EOL] assertNotNull(javaType); [EOL] assertTrue(javaType.isArrayType()); [EOL] assertTrue(javaType.getContentType().isTypeOrSubTypeOf(List.class)); [EOL] }
public void testAnnotatedConstructorWithNonNullConstructor() { [EOL] Constructor<?> constructor = String.class.getConstructors()[0]; [EOL] AnnotationMap classAnn = new AnnotationMap(); [EOL] AnnotationMap[] paramAnn = new AnnotationMap[constructor.getParameterTypes().length]; [EOL] AnnotatedConstructor ac = new AnnotatedConstructor(constructor, classAnn, paramAnn); [EOL] assertNotNull(ac); [EOL] }
public void testAnnotatedConstructorWithNullConstructor() { [EOL] try { [EOL] new AnnotatedConstructor(null, new AnnotationMap(), new AnnotationMap[0]); [EOL] fail("Expected IllegalArgumentException not thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Null constructor not allowed", e.getMessage()); [EOL] } [EOL] }
public void testGetAnnotated() { [EOL] Constructor<?> expectedConstructor = String.class.getConstructor(); [EOL] AnnotatedConstructor ac = new AnnotatedConstructor(null, expectedConstructor, null, null); [EOL] Constructor<?> actualConstructor = ac.getAnnotated(); [EOL] assertSame(expectedConstructor, actualConstructor); [EOL] }
public void testGetName() { [EOL] Constructor<?> constructor = String.class.getConstructors()[0]; [EOL] AnnotatedConstructor ac = new AnnotatedConstructor(null, constructor, null, null); [EOL] assertEquals(constructor.getName(), ac.getName()); [EOL] }
public void testGetParameterCountZeroParameters() { [EOL] Constructor<?> constructor = Object.class.getConstructors()[0]; // Assuming Object has a no-arg constructor [EOL] JacksonConstructor jacksonConstructor = new JacksonConstructor(constructor); [EOL] int parameterCount = jacksonConstructor.getParameterCount(); [EOL] assertEquals(0, parameterCount); [EOL] }
public void testGetParameterCountMultipleParameters() { [EOL] Constructor<?> constructor = String.class.getConstructor(char[].class, boolean.class); // Assuming this constructor exists [EOL] JacksonConstructor jacksonConstructor = new JacksonConstructor(constructor); [EOL] int parameterCount = jacksonConstructor.getParameterCount(); [EOL] assertEquals(2, parameterCount); [EOL] }
public void testGetRawParameterTypeWithValidIndex() { [EOL] Constructor<?> constructor = SomeClass.class.getConstructors()[0]; [EOL] JacksonConstructor jacksonConstructor = new JacksonConstructor(constructor); [EOL] Class<?> expectedType = constructor.getParameterTypes()[0]; [EOL] Class<?> resultType = jacksonConstructor.getRawParameterType(0); [EOL] assertEquals(expectedType, resultType); [EOL] }
public void testGetRawParameterTypeWithInvalidIndex() { [EOL] Constructor<?> constructor = SomeClass.class.getConstructors()[0]; [EOL] JacksonConstructor jacksonConstructor = new JacksonConstructor(constructor); [EOL] int invalidIndex = constructor.getParameterTypes().length; [EOL] Class<?> resultType = jacksonConstructor.getRawParameterType(invalidIndex); [EOL] assertNull(resultType); [EOL] }
public void testGetGenericParameterTypeWithValidIndex() { [EOL] Constructor<?> constructor = SampleClass.class.getConstructors()[0]; [EOL] JacksonConstructor jacksonConstructor = new JacksonConstructor(constructor); [EOL] int validIndex = 0; // assuming the constructor has at least one parameter [EOL] Type expectedType = constructor.getGenericParameterTypes()[validIndex]; [EOL] Type result = jacksonConstructor.getGenericParameterType(validIndex); [EOL] assertEquals(expectedType, result); [EOL] }
public void testGetGenericParameterTypeWithInvalidIndex() { [EOL] Constructor<?> constructor = SampleClass.class.getConstructors()[0]; [EOL] JacksonConstructor jacksonConstructor = new JacksonConstructor(constructor); [EOL] int invalidIndex = constructor.getGenericParameterTypes().length; // one past the last valid index [EOL] Type result = jacksonConstructor.getGenericParameterType(invalidIndex); [EOL] assertNull(result); [EOL] }
public void testCallWithValidArgs() throws Exception { [EOL] Constructor<?> constructor = String.class.getConstructor(String.class); [EOL] Object[] args = new Object[]{"test"}; [EOL] ConstructorBasedCreator creator = new ConstructorBasedCreator(constructor); [EOL] Object result = creator.call(args); [EOL] assertNotNull(result); [EOL] assertEquals("test", result.toString()); [EOL] }
public void testCallWithInvalidArgs() { [EOL] Constructor<?> constructor = String.class.getConstructor(String.class); [EOL] Object[] args = new Object[]{new Object()}; [EOL] ConstructorBasedCreator creator = new ConstructorBasedCreator(constructor); [EOL] try { [EOL] creator.call(args); [EOL] fail("Expected an exception to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testCallWithNullArgs() throws Exception { [EOL] Constructor<?> constructor = String.class.getConstructor(String.class); [EOL] Object[] args = null; [EOL] ConstructorBasedCreator creator = new ConstructorBasedCreator(constructor); [EOL] try { [EOL] creator.call(args); [EOL] fail("Expected an exception to be thrown"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testGetMember() { [EOL] Constructor<?> constructor = String.class.getConstructors()[0]; [EOL] MyObject obj = new MyObject(constructor); [EOL] Member result = obj.getMember(); [EOL] assertNotNull(result); [EOL] assertEquals(constructor, result); [EOL] }
public void testToString() { [EOL] ConstructorClass constructor = new ConstructorClass("SampleConstructor", new AnnotationMap()); [EOL] String result = constructor.toString(); [EOL] assertEquals("[constructor for SampleConstructor, annotations: " + constructor.getAnnotations() + "]", result); [EOL] }
public void testCreateContextualWithNullKeyAndValueDeserializer() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] JavaType mapKeyType = mock(JavaType.class); [EOL] JavaType mapContentType = mock(JavaType.class); [EOL] JavaType mapType = mock(JavaType.class); [EOL] when(mapType.getKeyType()).thenReturn(mapKeyType); [EOL] when(mapType.getContentType()).thenReturn(mapContentType); [EOL] JsonDeserializer<?> keyDeserializer = null; [EOL] JsonDeserializer<?> valueDeserializer = null; [EOL] TypeDeserializer valueTypeDeserializer = null; [EOL] CustomDeserializer instance = new CustomDeserializer(mapType, keyDeserializer, valueDeserializer, valueTypeDeserializer); [EOL] JsonDeserializer<?> expectedKeyDeserializer = mock(JsonDeserializer.class); [EOL] JsonDeserializer<?> expectedValueDeserializer = mock(JsonDeserializer.class); [EOL] when(ctxt.findContextualValueDeserializer(mapKeyType, property)).thenReturn(expectedKeyDeserializer); [EOL] when(ctxt.findContextualValueDeserializer(mapContentType, property)).thenReturn(expectedValueDeserializer); [EOL] JsonDeserializer<?> result = instance.createContextual(ctxt, property); [EOL] assertSame(expectedKeyDeserializer, result.getKeyDeserializer()); [EOL] assertSame(expectedValueDeserializer, result.getValueDeserializer()); [EOL] assertNull(result.getValueTypeDeserializer()); [EOL] }
public void testCreateContextualWithValueDeserializerNeedingContextualization() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] JavaType mapKeyType = mock(JavaType.class); [EOL] JavaType mapContentType = mock(JavaType.class); [EOL] JavaType mapType = mock(JavaType.class); [EOL] when(mapType.getKeyType()).thenReturn(mapKeyType); [EOL] when(mapType.getContentType()).thenReturn(mapContentType); [EOL] JsonDeserializer<?> keyDeserializer = mock(JsonDeserializer.class); [EOL] ContextualDeserializer valueDeserializer = mock(ContextualDeserializer.class); [EOL] TypeDeserializer valueTypeDeserializer = mock(TypeDeserializer.class); [EOL] CustomDeserializer instance = new CustomDeserializer(mapType, keyDeserializer, valueDeserializer, valueTypeDeserializer); [EOL] JsonDeserializer<?> expectedValueDeserializer = mock(JsonDeserializer.class); [EOL] when(valueDeserializer.createContextual(ctxt, property)).thenReturn(expectedValueDeserializer); [EOL] when(valueTypeDeserializer.forProperty(property)).thenReturn(valueTypeDeserializer); [EOL] JsonDeserializer<?> result = instance.createContextual(ctxt, property); [EOL] assertSame(keyDeserializer, result.getKeyDeserializer()); [EOL] assertSame(expectedValueDeserializer, result.getValueDeserializer()); [EOL] assertSame(valueTypeDeserializer, result.getValueTypeDeserializer()); [EOL] }
public void testCreateContextualWithValueTypeDeserializer() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] JavaType mapKeyType = mock(JavaType.class); [EOL] JavaType mapContentType = mock(JavaType.class); [EOL] JavaType mapType = mock(JavaType.class); [EOL] when(mapType.getKeyType()).thenReturn(mapKeyType); [EOL] when(mapType.getContentType()).thenReturn(mapContentType); [EOL] JsonDeserializer<?> keyDeserializer = mock(JsonDeserializer.class); [EOL] JsonDeserializer<?> valueDeserializer = mock(JsonDeserializer.class); [EOL] TypeDeserializer valueTypeDeserializer = mock(TypeDeserializer.class); [EOL] CustomDeserializer instance = new CustomDeserializer(mapType, keyDeserializer, valueDeserializer, valueTypeDeserializer); [EOL] when(valueTypeDeserializer.forProperty(property)).thenReturn(valueTypeDeserializer); [EOL] JsonDeserializer<?> result = instance.createContextual(ctxt, property); [EOL] assertSame(keyDeserializer, result.getKeyDeserializer()); [EOL] assertSame(valueDeserializer, result.getValueDeserializer()); [EOL] assertSame(valueTypeDeserializer, result.getValueTypeDeserializer()); [EOL] }
public void testDeserializeWithInvalidToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] try { [EOL] new TestDeserializer().deserialize(jp, ctxt); [EOL] fail("Expected mappingException for invalid token"); [EOL] } catch (JsonMappingException e) { [EOL] } [EOL] }
public void testDeserializeWithValidStartObjectToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); [EOL] when(jp.nextToken()).thenReturn(JsonToken.END_OBJECT); [EOL] EnumMap<?, ?> result = new TestDeserializer().deserialize(jp, ctxt); [EOL] assertNotNull(result); [EOL] assertTrue(result.isEmpty()); [EOL] }
public void testDeserializeWithUnknownEnumKey() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); [EOL] when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME).thenReturn(JsonToken.END_OBJECT); [EOL] when(ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)).thenReturn(false); [EOL] when(jp.getText()).thenReturn("UNKNOWN_ENUM"); [EOL] try { [EOL] new TestDeserializer().deserialize(jp, ctxt); [EOL] fail("Expected weirdStringException for unknown enum key"); [EOL] } catch (JsonMappingException e) { [EOL] } [EOL] }
public void testDeserializeWithNullEnumKeyAndFeatureEnabled() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); [EOL] when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME).thenReturn(JsonToken.END_OBJECT); [EOL] when(ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)).thenReturn(true); [EOL] EnumMap<?, ?> result = new TestDeserializer().deserialize(jp, ctxt); [EOL] assertNotNull(result); [EOL] assertTrue(result.isEmpty()); [EOL] }
public void testDeserializeWithValueNull() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JsonDeserializer<Object> valueDes = mock(JsonDeserializer.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); [EOL] when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME).thenReturn(JsonToken.VALUE_NULL).thenReturn(JsonToken.END_OBJECT); [EOL] when(valueDes.deserialize(jp, ctxt)).thenReturn(null); [EOL] TestDeserializer deserializer = new TestDeserializer(valueDes, null, null); [EOL] EnumMap<?, ?> result = deserializer.deserialize(jp, ctxt); [EOL] assertNotNull(result); [EOL] assertTrue(result.containsValue(null)); [EOL] }
public void testDeserializeWithValueDeserializer() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JsonDeserializer<Object> valueDes = mock(JsonDeserializer.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); [EOL] when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME).thenReturn(JsonToken.VALUE_STRING).thenReturn(JsonToken.END_OBJECT); [EOL] when(valueDes.deserialize(jp, ctxt)).thenReturn("value"); [EOL] TestDeserializer deserializer = new TestDeserializer(valueDes, null, null); [EOL] EnumMap<?, ?> result = deserializer.deserialize(jp, ctxt); [EOL] assertNotNull(result); [EOL] assertTrue(result.containsValue("value")); [EOL] }
public void testDeserializeWithValueDeserializerWithTypeDeserializer() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JsonDeserializer<Object> valueDes = mock(JsonDeserializer.class); [EOL] TypeDeserializer typeDeser = mock(TypeDeserializer.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); [EOL] when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME).thenReturn(JsonToken.VALUE_STRING).thenReturn(JsonToken.END_OBJECT); [EOL] when(valueDes.deserializeWithType(jp, ctxt, typeDeser)).thenReturn("value"); [EOL] TestDeserializer deserializer = new TestDeserializer(valueDes, null, typeDeser); [EOL] EnumMap<?, ?> result = deserializer.deserialize(jp, ctxt); [EOL] assertNotNull(result); [EOL] assertTrue(result.containsValue("value")); [EOL] }
public void testSerializeWithNonNullValue() throws IOException { [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] SerializerProvider mockProvider = mock(SerializerProvider.class); [EOL] Object value = new Object(); [EOL] new TestSerializer().serialize(value, mockJsonGenerator, mockProvider); [EOL] verify(mockJsonGenerator).writeRawValue(value.toString()); [EOL] }
public void testSerializeWithNullValue() throws IOException { [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] SerializerProvider mockProvider = mock(SerializerProvider.class); [EOL] Object value = null; [EOL] try { [EOL] new TestSerializer().serialize(value, mockJsonGenerator, mockProvider); [EOL] fail("Expected NullPointerException to be thrown"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testFindWithPrimitiveIntegerType() { [EOL] JsonDeserializer<?> deserializer = DeserializerFactory.find(Integer.TYPE, "java.lang.Integer"); [EOL] assertTrue(deserializer instanceof IntegerDeserializer); [EOL] assertSame(IntegerDeserializer.primitiveInstance, deserializer); [EOL] }
public void testFindWithPrimitiveBooleanType() { [EOL] JsonDeserializer<?> deserializer = DeserializerFactory.find(Boolean.TYPE, "java.lang.Boolean"); [EOL] assertTrue(deserializer instanceof BooleanDeserializer); [EOL] assertSame(BooleanDeserializer.primitiveInstance, deserializer); [EOL] }
public void testFindWithPrimitiveLongType() { [EOL] JsonDeserializer<?> deserializer = DeserializerFactory.find(Long.TYPE, "java.lang.Long"); [EOL] assertTrue(deserializer instanceof LongDeserializer); [EOL] assertSame(LongDeserializer.primitiveInstance, deserializer); [EOL] }
public void testFindWithPrimitiveDoubleType() { [EOL] JsonDeserializer<?> deserializer = DeserializerFactory.find(Double.TYPE, "java.lang.Double"); [EOL] assertTrue(deserializer instanceof DoubleDeserializer); [EOL] assertSame(DoubleDeserializer.primitiveInstance, deserializer); [EOL] }
public void testFindWithPrimitiveCharacterType() { [EOL] JsonDeserializer<?> deserializer = DeserializerFactory.find(Character.TYPE, "java.lang.Character"); [EOL] assertTrue(deserializer instanceof CharacterDeserializer); [EOL] assertSame(CharacterDeserializer.primitiveInstance, deserializer); [EOL] }
public void testFindWithPrimitiveByteType() { [EOL] JsonDeserializer<?> deserializer = DeserializerFactory.find(Byte.TYPE, "java.lang.Byte"); [EOL] assertTrue(deserializer instanceof ByteDeserializer); [EOL] assertSame(ByteDeserializer.primitiveInstance, deserializer); [EOL] }
public void testFindWithPrimitiveShortType() { [EOL] JsonDeserializer<?> deserializer = DeserializerFactory.find(Short.TYPE, "java.lang.Short"); [EOL] assertTrue(deserializer instanceof ShortDeserializer); [EOL] assertSame(ShortDeserializer.primitiveInstance, deserializer); [EOL] }
public void testFindWithPrimitiveFloatType() { [EOL] JsonDeserializer<?> deserializer = DeserializerFactory.find(Float.TYPE, "java.lang.Float"); [EOL] assertTrue(deserializer instanceof FloatDeserializer); [EOL] assertSame(FloatDeserializer.primitiveInstance, deserializer); [EOL] }
public void testFindWithWrapperIntegerType() { [EOL] JsonDeserializer<?> deserializer = DeserializerFactory.find(Integer.class, "java.lang.Integer"); [EOL] assertTrue(deserializer instanceof IntegerDeserializer); [EOL] assertSame(IntegerDeserializer.wrapperInstance, deserializer); [EOL] }
public void testFindWithWrapperBooleanType() { [EOL] JsonDeserializer<?> deserializer = DeserializerFactory.find(Boolean.class, "java.lang.Boolean"); [EOL] assertTrue(deserializer instanceof BooleanDeserializer); [EOL] assertSame(BooleanDeserializer.wrapperInstance, deserializer); [EOL] }
public void testFindWithWrapperLongType() { [EOL] JsonDeserializer<?> deserializer = DeserializerFactory.find(Long.class, "java.lang.Long"); [EOL] assertTrue(deserializer instanceof LongDeserializer); [EOL] assertSame(LongDeserializer.wrapperInstance, deserializer); [EOL] }
public void testFindWithWrapperDoubleType() { [EOL] JsonDeserializer<?> deserializer = DeserializerFactory.find(Double.class, "java.lang.Double"); [EOL] assertTrue(deserializer instanceof DoubleDeserializer); [EOL] assertSame(DoubleDeserializer.wrapperInstance, deserializer); [EOL] }
public void testFindWithWrapperCharacterType() { [EOL] JsonDeserializer<?> deserializer = DeserializerFactory.find(Character.class, "java.lang.Character"); [EOL] assertTrue(deserializer instanceof CharacterDeserializer); [EOL] assertSame(CharacterDeserializer.wrapperInstance, deserializer); [EOL] }
public void testFindWithWrapperByteType() { [EOL] JsonDeserializer<?> deserializer = DeserializerFactory.find(Byte.class, "java.lang.Byte"); [EOL] assertTrue(deserializer instanceof ByteDeserializer); [EOL] assertSame(ByteDeserializer.wrapperInstance, deserializer); [EOL] }
public void testFindWithWrapperShortType() { [EOL] JsonDeserializer<?> deserializer = DeserializerFactory.find(Short.class, "java.lang.Short"); [EOL] assertTrue(deserializer instanceof ShortDeserializer); [EOL] assertSame(ShortDeserializer.wrapperInstance, deserializer); [EOL] }
public void testFindWithWrapperFloatType() { [EOL] JsonDeserializer<?> deserializer = DeserializerFactory.find(Float.class, "java.lang.Float"); [EOL] assertTrue(deserializer instanceof FloatDeserializer); [EOL] assertSame(FloatDeserializer.wrapperInstance, deserializer); [EOL] }
public void testFindWithNumberType() { [EOL] JsonDeserializer<?> deserializer = DeserializerFactory.find(Number.class, "java.lang.Number"); [EOL] assertTrue(deserializer instanceof NumberDeserializer); [EOL] assertSame(NumberDeserializer.instance, deserializer); [EOL] }
public void testFindWithBigDecimalType() { [EOL] JsonDeserializer<?> deserializer = DeserializerFactory.find(BigDecimal.class, "java.math.BigDecimal"); [EOL] assertTrue(deserializer instanceof BigDecimalDeserializer); [EOL] assertSame(BigDecimalDeserializer.instance, deserializer); [EOL] }
public void testFindWithBigIntegerType() { [EOL] JsonDeserializer<?> deserializer = DeserializerFactory.find(BigInteger.class, "java.math.BigInteger"); [EOL] assertTrue(deserializer instanceof BigIntegerDeserializer); [EOL] assertSame(BigIntegerDeserializer.instance, deserializer); [EOL] }
public void testFindWithUnrecognizedType() { [EOL] JsonDeserializer<?> deserializer = DeserializerFactory.find(Object.class, "java.lang.Object"); [EOL] assertNull(deserializer); [EOL] }
public void testPrimitiveOrWrapperDeserializerWithNonNullValue() { [EOL] Integer defaultValue = 10; [EOL] PrimitiveOrWrapperDeserializer<Integer> deserializer = new PrimitiveOrWrapperDeserializer<>(Integer.class, defaultValue); [EOL] assertEquals(Integer.class, deserializer.getValueClass()); [EOL] assertEquals(defaultValue, deserializer.getNullValue()); [EOL] }
public void testPrimitiveOrWrapperDeserializerWithNullValue() { [EOL] PrimitiveOrWrapperDeserializer<Integer> deserializer = new PrimitiveOrWrapperDeserializer<>(Integer.class, null); [EOL] assertEquals(Integer.class, deserializer.getValueClass()); [EOL] assertNull(deserializer.getNullValue()); [EOL] }
public void testBooleanDeserializerWithTrueClassAndNullValue() { [EOL] BooleanDeserializer deserializer = new BooleanDeserializer(Boolean.class, null); [EOL] assertNull(deserializer.getValueType()); [EOL] }
public void testBooleanDeserializerWithTrueClassAndTrueValue() { [EOL] BooleanDeserializer deserializer = new BooleanDeserializer(Boolean.class, Boolean.TRUE); [EOL] assertEquals(Boolean.TRUE, deserializer.getValueType()); [EOL] }
public void testBooleanDeserializerWithTrueClassAndFalseValue() { [EOL] BooleanDeserializer deserializer = new BooleanDeserializer(Boolean.class, Boolean.FALSE); [EOL] assertEquals(Boolean.FALSE, deserializer.getValueType()); [EOL] }
public void testDeserializeWithTrueValue() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getText()).thenReturn("true"); [EOL] Boolean result = deserialize(jp, ctxt); [EOL] assertTrue(result); [EOL] }
public void testDeserializeWithFalseValue() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getText()).thenReturn("false"); [EOL] Boolean result = deserialize(jp, ctxt); [EOL] assertFalse(result); [EOL] }
public void testDeserializeWithNullValue() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NULL); [EOL] Boolean result = deserialize(jp, ctxt); [EOL] assertNull(result); [EOL] }
public void testDeserializeWithNonBooleanValue() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getText()).thenReturn("not a boolean"); [EOL] try { [EOL] deserialize(jp, ctxt); [EOL] fail("Expected JsonProcessingException to be thrown"); [EOL] } catch (JsonProcessingException e) { [EOL] } [EOL] }
public void testByteDeserializerWithNonNullClassAndValue() { [EOL] Byte expectedValue = 10; [EOL] ByteDeserializer deserializer = new ByteDeserializer(Byte.class, expectedValue); [EOL] assertEquals(Byte.class, deserializer.handledType()); [EOL] assertEquals(expectedValue, deserializer.getNullValue()); [EOL] }
public void testByteDeserializerWithNonNullClassAndNullValue() { [EOL] ByteDeserializer deserializer = new ByteDeserializer(Byte.class, null); [EOL] assertEquals(Byte.class, deserializer.handledType()); [EOL] assertNull(deserializer.getNullValue()); [EOL] }
public void testDeserializeWithValidByteValue() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getValueAsString()).thenReturn("10"); [EOL] Byte result = deserialize(jp, ctxt); [EOL] assertEquals(Byte.valueOf((byte) 10), result); [EOL] }
public void testDeserializeWithInvalidByteValue() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getValueAsString()).thenReturn("not a byte"); [EOL] try { [EOL] deserialize(jp, ctxt); [EOL] fail("Expected an exception to be thrown"); [EOL] } catch (JsonProcessingException e) { [EOL] } [EOL] }
public void testDeserializeWithNullValue() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getValueAsString()).thenReturn(null); [EOL] Byte result = deserialize(jp, ctxt); [EOL] assertNull(result); [EOL] }
public void testShortDeserializerWithNonNullClassAndValue() { [EOL] Short expectedValue = 10; [EOL] ShortDeserializer deserializer = new ShortDeserializer(Short.class, expectedValue); [EOL] assertEquals(Short.class, deserializer.handledType()); [EOL] assertEquals(expectedValue, deserializer.getNullValue()); [EOL] }
public void testShortDeserializerWithNonNullClassAndNullValue() { [EOL] ShortDeserializer deserializer = new ShortDeserializer(Short.class, null); [EOL] assertEquals(Short.class, deserializer.handledType()); [EOL] assertNull(deserializer.getNullValue()); [EOL] }
public void testDeserializeWithValidShortValue() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getValueAsString()).thenReturn("123"); [EOL] Short result = deserialize(jp, ctxt); [EOL] assertEquals(Short.valueOf((short) 123), result); [EOL] }
public void testDeserializeWithInvalidShortValue() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getValueAsString()).thenReturn("not a number"); [EOL] try { [EOL] deserialize(jp, ctxt); [EOL] fail("Expected JsonProcessingException to be thrown"); [EOL] } catch (JsonProcessingException e) { [EOL] } [EOL] }
public void testDeserializeWithNullValue() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getValueAsString()).thenReturn(null); [EOL] Short result = deserialize(jp, ctxt); [EOL] assertNull(result); [EOL] }
public void testCharacterDeserializerWithNonNullClassAndValue() { [EOL] Character expectedValue = 'a'; [EOL] CharacterDeserializer deserializer = new CharacterDeserializer(Character.class, expectedValue); [EOL] assertEquals(Character.class, deserializer.handledType()); [EOL] assertEquals(expectedValue, deserializer.getNullValue()); [EOL] }
public void testCharacterDeserializerWithNonNullClassAndNullValue() { [EOL] CharacterDeserializer deserializer = new CharacterDeserializer(Character.class, null); [EOL] assertEquals(Character.class, deserializer.handledType()); [EOL] assertNull(deserializer.getNullValue()); [EOL] }
public void testDeserializeWithValidNumberIntToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); [EOL] when(jp.getIntValue()).thenReturn(65); // ASCII value for 'A' [EOL] CharacterDeserializer deserializer = new CharacterDeserializer(); [EOL] Character result = deserializer.deserialize(jp, ctxt); [EOL] assertEquals(Character.valueOf('A'), result); [EOL] }
public void testDeserializeWithInvalidNumberIntToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); [EOL] when(jp.getIntValue()).thenReturn(70000); // Out of char range [EOL] CharacterDeserializer deserializer = new CharacterDeserializer(); [EOL] try { [EOL] deserializer.deserialize(jp, ctxt); [EOL] fail("Expected an exception to be thrown"); [EOL] } catch (JsonMappingException e) { [EOL] } [EOL] }
public void testDeserializeWithValidStringToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("A"); [EOL] CharacterDeserializer deserializer = new CharacterDeserializer(); [EOL] Character result = deserializer.deserialize(jp, ctxt); [EOL] assertEquals(Character.valueOf('A'), result); [EOL] }
public void testDeserializeWithEmptyStringToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn(""); [EOL] when(ctxt.getEmptyValue()).thenReturn(Character.valueOf('\0')); [EOL] CharacterDeserializer deserializer = new CharacterDeserializer(); [EOL] Character result = deserializer.deserialize(jp, ctxt); [EOL] assertEquals(Character.valueOf('\0'), result); [EOL] }
public void testDeserializeWithInvalidStringToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("AB"); // More than one character [EOL] CharacterDeserializer deserializer = new CharacterDeserializer(); [EOL] try { [EOL] deserializer.deserialize(jp, ctxt); [EOL] fail("Expected an exception to be thrown"); [EOL] } catch (JsonMappingException e) { [EOL] } [EOL] }
public void testDeserializeWithInvalidToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.NOT_AVAILABLE); // Invalid token for deserialization [EOL] CharacterDeserializer deserializer = new CharacterDeserializer(); [EOL] try { [EOL] deserializer.deserialize(jp, ctxt); [EOL] fail("Expected an exception to be thrown"); [EOL] } catch (JsonMappingException e) { [EOL] } [EOL] }
public void testIntegerDeserializerWithNonNullClassAndValue() { [EOL] Integer expectedValue = 10; [EOL] IntegerDeserializer deserializer = new IntegerDeserializer(Integer.class, expectedValue); [EOL] assertEquals(Integer.class, deserializer.handledType()); [EOL] assertEquals(expectedValue, deserializer.getNullValue()); [EOL] }
public void testIntegerDeserializerWithNonNullClassAndNullValue() { [EOL] IntegerDeserializer deserializer = new IntegerDeserializer(Integer.class, null); [EOL] assertEquals(Integer.class, deserializer.handledType()); [EOL] assertNull(deserializer.getNullValue()); [EOL] }
public void testDeserializeWithValidInteger() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getValueAsInt()).thenReturn(123); [EOL] IntegerDeserializer deserializer = new IntegerDeserializer(); [EOL] Integer result = deserializer.deserialize(jp, ctxt); [EOL] assertEquals(Integer.valueOf(123), result); [EOL] }
public void testDeserializeWithNonInteger() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getValueAsInt()).thenThrow(new JsonParseException(jp, "Not an integer")); [EOL] IntegerDeserializer deserializer = new IntegerDeserializer(); [EOL] try { [EOL] deserializer.deserialize(jp, ctxt); [EOL] fail("Expected JsonParseException"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testLongDeserializerWithNonNullClassAndValue() { [EOL] Long expectedValue = 10L; [EOL] LongDeserializer deserializer = new LongDeserializer(Long.class, expectedValue); [EOL] assertEquals(Long.class, deserializer.handledType()); [EOL] assertEquals(expectedValue, deserializer.getNullValue()); [EOL] }
public void testLongDeserializerWithNonNullClassAndNullValue() { [EOL] LongDeserializer deserializer = new LongDeserializer(Long.class, null); [EOL] assertEquals(Long.class, deserializer.handledType()); [EOL] assertNull(deserializer.getNullValue()); [EOL] }
public void testDeserializeWithValidLong() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getLongValue()).thenReturn(123L); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); [EOL] LongDeserializer deserializer = new LongDeserializer(); [EOL] Long result = deserializer.deserialize(jp, ctxt); [EOL] assertEquals(Long.valueOf(123L), result); [EOL] }
public void testDeserializeWithNonIntegerToken() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("123"); [EOL] LongDeserializer deserializer = new LongDeserializer(); [EOL] Long result = deserializer.deserialize(jp, ctxt); [EOL] assertEquals(Long.valueOf(123L), result); [EOL] }
public void testFloatDeserializerWithNonNullClassAndValue() { [EOL] Float expectedValue = 10.0f; [EOL] FloatDeserializer deserializer = new FloatDeserializer(Float.class, expectedValue); [EOL] assertEquals(Float.class, deserializer.getValueClass()); [EOL] assertEquals(expectedValue, deserializer.getNullValue()); [EOL] }
public void testFloatDeserializerWithNonNullClassAndNullValue() { [EOL] FloatDeserializer deserializer = new FloatDeserializer(Float.class, null); [EOL] assertEquals(Float.class, deserializer.getValueClass()); [EOL] assertNull(deserializer.getNullValue()); [EOL] }
public void testDeserializeWithValidFloat() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getFloatValue()).thenReturn(10.0f); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_FLOAT); [EOL] Float result = deserialize(jp, ctxt); [EOL] assertEquals(Float.valueOf(10.0f), result); [EOL] }
public void testDeserializeWithInvalidToken() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("not a float"); [EOL] try { [EOL] deserialize(jp, ctxt); [EOL] fail("Expected JsonParseException"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testNumberDeserializerConstructor() { [EOL] NumberDeserializer deserializer = new NumberDeserializer(); [EOL] assertNotNull(deserializer); [EOL] }
public void testDeserializeWithIntTokenAndUseBigIntegerForIntsEnabled() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); [EOL] when(ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)).thenReturn(true); [EOL] when(jp.getBigIntegerValue()).thenReturn(new BigInteger("12345")); [EOL] Number result = deserialize(jp, ctxt); [EOL] assertTrue(result instanceof BigInteger); [EOL] assertEquals(new BigInteger("12345"), result); [EOL] }
public void testDeserializeWithIntTokenAndUseBigIntegerForIntsDisabled() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); [EOL] when(ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)).thenReturn(false); [EOL] when(jp.getNumberValue()).thenReturn(12345); [EOL] Number result = deserialize(jp, ctxt); [EOL] assertEquals(12345, result); [EOL] }
public void testDeserializeWithFloatTokenAndUseBigDecimalForFloatsEnabled() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_FLOAT); [EOL] when(ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)).thenReturn(true); [EOL] when(jp.getDecimalValue()).thenReturn(new BigDecimal("123.45")); [EOL] Number result = deserialize(jp, ctxt); [EOL] assertTrue(result instanceof BigDecimal); [EOL] assertEquals(new BigDecimal("123.45"), result); [EOL] }
public void testDeserializeWithFloatTokenAndUseBigDecimalForFloatsDisabled() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_FLOAT); [EOL] when(ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)).thenReturn(false); [EOL] when(jp.getDoubleValue()).thenReturn(123.45); [EOL] Number result = deserialize(jp, ctxt); [EOL] assertEquals(Double.valueOf(123.45), result); [EOL] }
public void testDeserializeWithStringTokenWithDotAndUseBigDecimalForFloatsEnabled() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("123.45"); [EOL] when(ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)).thenReturn(true); [EOL] Number result = deserialize(jp, ctxt); [EOL] assertTrue(result instanceof BigDecimal); [EOL] assertEquals(new BigDecimal("123.45"), result); [EOL] }
public void testDeserializeWithStringTokenWithDotAndUseBigDecimalForFloatsDisabled() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("123.45"); [EOL] when(ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)).thenReturn(false); [EOL] Number result = deserialize(jp, ctxt); [EOL] assertTrue(result instanceof Double); [EOL] assertEquals(Double.valueOf("123.45"), result); [EOL] }
public void testDeserializeWithStringTokenWithoutDotAndUseBigIntegerForIntsEnabled() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("12345"); [EOL] when(ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)).thenReturn(true); [EOL] Number result = deserialize(jp, ctxt); [EOL] assertTrue(result instanceof BigInteger); [EOL] assertEquals(new BigInteger("12345"), result); [EOL] }
public void testDeserializeWithStringTokenWithoutDotAndFitsInInteger() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("12345"); [EOL] when(ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)).thenReturn(false); [EOL] Number result = deserialize(jp, ctxt); [EOL] assertTrue(result instanceof Integer); [EOL] assertEquals(Integer.valueOf(12345), result); [EOL] }
public void testDeserializeWithStringTokenWithoutDotAndDoesNotFitInInteger() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn(String.valueOf(Long.MAX_VALUE)); [EOL] when(ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)).thenReturn(false); [EOL] Number result = deserialize(jp, ctxt); [EOL] assertTrue(result instanceof Long); [EOL] assertEquals(Long.valueOf(Long.MAX_VALUE), result); [EOL] }
public void testDeserializeWithInvalidStringToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("not a number"); [EOL] try { [EOL] deserialize(jp, ctxt); [EOL] fail("Expected an IOException to be thrown"); [EOL] } catch (IOException e) { [EOL] } [EOL] }
public void testDeserializeWithInvalidToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.NOT_AVAILABLE); [EOL] try { [EOL] deserialize(jp, ctxt); [EOL] fail("Expected an IOException to be thrown"); [EOL] } catch (IOException e) { [EOL] } [EOL] }
public void testDeserializeWithNumberIntTokenAndIntType() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); [EOL] when(jp.getNumberType()).thenReturn(JsonParser.NumberType.INT); [EOL] when(jp.getLongValue()).thenReturn(123L); [EOL] BigInteger result = deserialize(jp, ctxt); [EOL] assertEquals(BigInteger.valueOf(123L), result); [EOL] }
public void testDeserializeWithNumberIntTokenAndLongType() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); [EOL] when(jp.getNumberType()).thenReturn(JsonParser.NumberType.LONG); [EOL] when(jp.getLongValue()).thenReturn(1234567890123456789L); [EOL] BigInteger result = deserialize(jp, ctxt); [EOL] assertEquals(BigInteger.valueOf(1234567890123456789L), result); [EOL] }
public void testDeserializeWithNumberFloatToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BigDecimal decimalValue = new BigDecimal("123.456"); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_FLOAT); [EOL] when(jp.getDecimalValue()).thenReturn(decimalValue); [EOL] BigInteger result = deserialize(jp, ctxt); [EOL] assertEquals(decimalValue.toBigInteger(), result); [EOL] }
public void testDeserializeWithNonStringValue() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); [EOL] try { [EOL] deserialize(jp, ctxt); [EOL] fail("Expected JsonMappingException"); [EOL] } catch (JsonMappingException e) { [EOL] } [EOL] }
public void testDeserializeWithEmptyString() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("   "); [EOL] BigInteger result = deserialize(jp, ctxt); [EOL] assertNull(result); [EOL] }
public void testDeserializeWithValidString() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("123456789"); [EOL] BigInteger result = deserialize(jp, ctxt); [EOL] assertEquals(new BigInteger("123456789"), result); [EOL] }
public void testDeserializeWithInvalidString() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("not a number"); [EOL] try { [EOL] deserialize(jp, ctxt); [EOL] fail("Expected JsonMappingException"); [EOL] } catch (JsonMappingException e) { [EOL] } [EOL] }
public void testBigDecimalDeserializerConstruction() { [EOL] BigDecimalDeserializer deserializer = new BigDecimalDeserializer(); [EOL] assertNotNull(deserializer); [EOL] assertEquals(BigDecimal.class, deserializer.handledType()); [EOL] }
public void testDeserializeWithNumberIntToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); [EOL] when(jp.getDecimalValue()).thenReturn(new BigDecimal("123")); [EOL] BigDecimal result = deserialize(jp, ctxt); [EOL] assertNotNull(result); [EOL] assertEquals(new BigDecimal("123"), result); [EOL] }
public void testDeserializeWithNumberFloatToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_FLOAT); [EOL] when(jp.getDecimalValue()).thenReturn(new BigDecimal("123.45")); [EOL] BigDecimal result = deserialize(jp, ctxt); [EOL] assertNotNull(result); [EOL] assertEquals(new BigDecimal("123.45"), result); [EOL] }
public void testDeserializeWithEmptyString() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn(""); [EOL] BigDecimal result = deserialize(jp, ctxt); [EOL] assertNull(result); [EOL] }
public void testDeserializeWithValidString() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("123.45"); [EOL] BigDecimal result = deserialize(jp, ctxt); [EOL] assertNotNull(result); [EOL] assertEquals(new BigDecimal("123.45"), result); [EOL] }
public void testDeserializeWithInvalidString() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("not a number"); [EOL] try { [EOL] deserialize(jp, ctxt); [EOL] fail("Expected an exception to be thrown"); [EOL] } catch (JsonProcessingException e) { [EOL] } [EOL] }
public void testDeserializeWithUnexpectedToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_ARRAY); [EOL] try { [EOL] deserialize(jp, ctxt); [EOL] fail("Expected an exception to be thrown"); [EOL] } catch (JsonProcessingException e) { [EOL] } [EOL] }
public void testForTypeWithStringClass() { [EOL] StringKD result = StringKD.forType(String.class); [EOL] assertSame(StringKD.sString, result); [EOL] }
public void testForTypeWithObjectClass() { [EOL] StringKD result = StringKD.forType(Object.class); [EOL] assertSame(StringKD.sObject, result); [EOL] }
public void testForTypeWithCustomClass() { [EOL] class CustomClass {} [EOL] StringKD result = StringKD.forType(CustomClass.class); [EOL] assertNotNull(result); [EOL] assertNotSame(StringKD.sString, result); [EOL] assertNotSame(StringKD.sObject, result); [EOL] assertEquals(CustomClass.class, result.getNominalType()); [EOL] }
public void testStringCtorKeyDeserializerWithValidConstructor() { [EOL] Constructor<String> ctor = String.class.getConstructor(String.class); [EOL] StringCtorKeyDeserializer deserializer = new StringCtorKeyDeserializer(ctor); [EOL] assertNotNull(deserializer); [EOL] assertEquals(String.class, deserializer.handledType()); [EOL] }
public void testParseWithValidKey() throws Exception { [EOL] Constructor<?> constructor = MyObject.class.getConstructor(String.class); [EOL] MyDeserializer deserializer = new MyDeserializer(constructor); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] String validKey = "validKey"; [EOL] Object result = deserializer._parse(validKey, ctxt); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof MyObject); [EOL] assertEquals(validKey, ((MyObject) result).getKey()); [EOL] }
public void testParseWithInvalidKeyThrowsException() { [EOL] Constructor<?> constructor = MyObject.class.getConstructor(String.class); [EOL] MyDeserializer deserializer = new MyDeserializer(constructor); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] String invalidKey = "invalidKey"; [EOL] assertThrows(Exception.class, () -> { [EOL] deserializer._parse(invalidKey, ctxt); [EOL] }); [EOL] }
public void testFindAndAddSerializerWithValidType() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] JsonSerializer<Object> expectedSerializer = mock(JsonSerializer.class); [EOL] when(provider.findValueSerializer(any(Class.class), any(BeanProperty.class))).thenReturn(expectedSerializer); [EOL] SerializerAndMapResult result = findAndAddSerializer(Object.class, provider, property); [EOL] assertNotNull(result); [EOL] assertEquals(expectedSerializer, result.getSerializer()); [EOL] assertNotNull(result.getTypeMapping()); [EOL] }
public void testFindAndAddSerializerWithNullType() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] when(provider.findValueSerializer(null, property)).thenThrow(new JsonMappingException("Type is null")); [EOL] try { [EOL] findAndAddSerializer(null, provider, property); [EOL] fail("Expected JsonMappingException"); [EOL] } catch (JsonMappingException e) { [EOL] } [EOL] }
public void testEmptyMap() { [EOL] PropertySerializerMap map = PropertySerializerMap.emptyMap(); [EOL] assertNotNull(map); [EOL] assertTrue(map instanceof PropertySerializerMap.Empty); [EOL] }
public void testSerializerAndMapResultWithNonNullValues() { [EOL] JsonSerializer<Object> serializer = mock(JsonSerializer.class); [EOL] PropertySerializerMap map = mock(PropertySerializerMap.class); [EOL] SerializerAndMapResult result = new SerializerAndMapResult(serializer, map); [EOL] assertNotNull(result.serializer); [EOL] assertNotNull(result.map); [EOL] } [EOL] public void testSerializerAndMapResultWithNullValues() { [EOL] SerializerAndMapResult result = new SerializerAndMapResult(null, null); [EOL] assertNull(result.serializer); [EOL] assertNull(result.map); [EOL] }
public void testSerializerForReturnsNull() { [EOL] JsonSerializerProvider provider = new JsonSerializerProvider(); [EOL] JsonSerializer<Object> serializer = provider.serializerFor(String.class); [EOL] assertNull(serializer); [EOL] }
public void testNewWithNonNullTypeAndSerializer() { [EOL] Class<?> type = String.class; [EOL] JsonSerializer<Object> serializer = new StdSerializer<Object>(Object.class) { [EOL] @Override [EOL] public void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException { [EOL] } [EOL] }; [EOL] PropertySerializerMap map = new PropertySerializerMap.Empty(); [EOL] PropertySerializerMap newMap = map.newWith(type, serializer); [EOL] assertTrue(newMap instanceof PropertySerializerMap.Single); [EOL] }
public void testNewWithNullType() { [EOL] JsonSerializer<Object> serializer = new StdSerializer<Object>(Object.class) { [EOL] @Override [EOL] public void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException { [EOL] } [EOL] }; [EOL] PropertySerializerMap map = new PropertySerializerMap.Empty(); [EOL] try { [EOL] map.newWith(null, serializer); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testNewWithNullSerializer() { [EOL] Class<?> type = String.class; [EOL] PropertySerializerMap map = new PropertySerializerMap.Empty(); [EOL] try { [EOL] map.newWith(type, null); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testSingleConstructorWithNonNullValues() { [EOL] Class<?> type = String.class; [EOL] JsonSerializer<Object> serializer = new StdSerializer<Object>(Object.class) { [EOL] @Override [EOL] public void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException { [EOL] } [EOL] }; [EOL] Single single = new Single(type, serializer); [EOL] assertNotNull(single); [EOL] assertEquals(type, single.getType()); [EOL] assertEquals(serializer, single.getSerializer()); [EOL] }
public void testSingleConstructorWithNullType() { [EOL] JsonSerializer<Object> serializer = new StdSerializer<Object>(Object.class) { [EOL] @Override [EOL] public void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException { [EOL] } [EOL] }; [EOL] Single single = new Single(null, serializer); [EOL] assertNull(single.getType()); [EOL] assertEquals(serializer, single.getSerializer()); [EOL] }
public void testSingleConstructorWithNullSerializer() { [EOL] Class<?> type = String.class; [EOL] Single single = new Single(type, null); [EOL] assertEquals(type, single.getType()); [EOL] assertNull(single.getSerializer()); [EOL] }
public void testSingleConstructorWithNullValues() { [EOL] Single single = new Single(null, null); [EOL] assertNull(single.getType()); [EOL] assertNull(single.getSerializer()); [EOL] }
public void testSerializerForWithMatchingType() { [EOL] TypeAndSerializer matchingEntry = new TypeAndSerializer(String.class, mock(JsonSerializer.class)); [EOL] _entries = new TypeAndSerializer[]{matchingEntry}; [EOL] JsonSerializer<Object> result = serializerFor(String.class); [EOL] assertNotNull(result); [EOL] assertSame(matchingEntry.serializer, result); [EOL] } [EOL] public void testSerializerForWithNoMatchingType() { [EOL] TypeAndSerializer nonMatchingEntry = new TypeAndSerializer(Integer.class, mock(JsonSerializer.class)); [EOL] _entries = new TypeAndSerializer[]{nonMatchingEntry}; [EOL] JsonSerializer<Object> result = serializerFor(String.class); [EOL] assertNull(result); [EOL] }
public void testFindStringBasedKeyDeserializerWithConstructor() { [EOL] DeserializationConfig config = createConfigWithAccessModifiers(true); [EOL] JavaType type = createTypeWithSingleArgConstructor(String.class); [EOL] KeyDeserializer deserializer = findStringBasedKeyDeserializer(config, type); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof StdKeyDeserializer.StringCtorKeyDeserializer); [EOL] } [EOL] public void testFindStringBasedKeyDeserializerWithFactoryMethod() { [EOL] DeserializationConfig config = createConfigWithAccessModifiers(true); [EOL] JavaType type = createTypeWithFactoryMethod(String.class); [EOL] KeyDeserializer deserializer = findStringBasedKeyDeserializer(config, type); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof StdKeyDeserializer.StringFactoryKeyDeserializer); [EOL] } [EOL] public void testFindStringBasedKeyDeserializerWithNoStringCreator() { [EOL] DeserializationConfig config = createConfigWithAccessModifiers(false); [EOL] JavaType type = createTypeWithoutStringCreator(); [EOL] KeyDeserializer deserializer = findStringBasedKeyDeserializer(config, type); [EOL] assertNull(deserializer); [EOL] }
private DeserializationConfig createConfigWithAccessModifiers(boolean canOverride) { [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] when(config.canOverrideAccessModifiers()).thenReturn(canOverride); [EOL] return config; [EOL] } [EOL] private JavaType createTypeWithSingleArgConstructor(Class<?> argClass) { [EOL] JavaType type = mock(JavaType.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] Constructor<?> ctor = mock(Constructor.class); [EOL] when(type.getRawClass()).thenReturn(SomeClassWithConstructor.class); [EOL] when(beanDesc.findSingleArgConstructor(argClass)).thenReturn(ctor); [EOL] when(config.introspect(type)).thenReturn(beanDesc); [EOL] return type; [EOL] } [EOL] private JavaType createTypeWithFactoryMethod(Class<?> argClass) { [EOL] JavaType type = mock(JavaType.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] Method m = mock(Method.class); [EOL] when(type.getRawClass()).thenReturn(SomeClassWithFactoryMethod.class); [EOL] when(beanDesc.findFactoryMethod(argClass)).thenReturn(m); [EOL] when(config.introspect(type)).thenReturn(beanDesc); [EOL] return type; [EOL] } [EOL] private JavaType createTypeWithoutStringCreator() { [EOL] JavaType type = mock(JavaType.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] when(type.getRawClass()).thenReturn(SomeClassWithoutStringCreator.class); [EOL] when(beanDesc.findSingleArgConstructor(String.class)).thenReturn(null); [EOL] when(beanDesc.findFactoryMethod(String.class)).thenReturn(null); [EOL] when(config.introspect(type)).thenReturn(beanDesc); [EOL] return type; [EOL] }
public void testCollectionSerializerWithNonNullValues() { [EOL] JavaType elemType = TypeFactory.defaultInstance().constructType(String.class); [EOL] TypeSerializer vts = new MockTypeSerializer(); [EOL] BeanProperty property = new MockBeanProperty(); [EOL] JsonSerializer<Object> valueSerializer = new MockJsonSerializer(); [EOL] CollectionSerializer serializer = new CollectionSerializer(elemType, true, vts, property, valueSerializer); [EOL] assertNotNull(serializer); [EOL] }
public void testCollectionSerializerWithNullValues() { [EOL] JavaType elemType = TypeFactory.defaultInstance().constructType(String.class); [EOL] CollectionSerializer serializer = new CollectionSerializer(elemType, false, null, null, null); [EOL] assertNotNull(serializer); [EOL] }
public void testCollectionSerializerConstructorWithNonNullParameters() { [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] TypeSerializer typeSerializer = mock(TypeSerializer.class); [EOL] JsonSerializer<Object> jsonSerializer = mock(JsonSerializer.class); [EOL] CollectionSerializer src = new CollectionSerializer(null, null, null, null); [EOL] CollectionSerializer result = new CollectionSerializer(src, property, typeSerializer, jsonSerializer); [EOL] assertNotNull(result); [EOL] }
public void testCollectionSerializerConstructorWithNullParameters() { [EOL] CollectionSerializer src = new CollectionSerializer(null, null, null, null); [EOL] CollectionSerializer result = new CollectionSerializer(src, null, null, null); [EOL] assertNotNull(result); [EOL] }
public void testWithValueTypeSerializerNonNull() { [EOL] TypeSerializer typeSerializer = new MockTypeSerializer(); [EOL] CollectionSerializer originalSerializer = new CollectionSerializer( [EOL] SimpleType.constructUnsafe(List.class), [EOL] false, [EOL] null, [EOL] null, [EOL] null [EOL] ); [EOL] ContainerSerializer<?> newSerializer = originalSerializer._withValueTypeSerializer(typeSerializer); [EOL] assertNotNull(newSerializer); [EOL] assertTrue(newSerializer instanceof CollectionSerializer); [EOL] CollectionSerializer collectionSerializer = (CollectionSerializer) newSerializer; [EOL] assertEquals(typeSerializer, collectionSerializer._valueTypeSerializer); [EOL] }
public void testWithValueTypeSerializerNull() { [EOL] CollectionSerializer originalSerializer = new CollectionSerializer( [EOL] SimpleType.constructUnsafe(List.class), [EOL] false, [EOL] null, [EOL] null, [EOL] null [EOL] ); [EOL] ContainerSerializer<?> newSerializer = originalSerializer._withValueTypeSerializer(null); [EOL] assertNotNull(newSerializer); [EOL] assertTrue(newSerializer instanceof CollectionSerializer); [EOL] CollectionSerializer collectionSerializer = (CollectionSerializer) newSerializer; [EOL] assertNull(collectionSerializer._valueTypeSerializer); [EOL] }
public void testWithResolved() { [EOL] CollectionSerializer original = new CollectionSerializer(null, null, null, null, false); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] TypeSerializer vts = mock(TypeSerializer.class); [EOL] JsonSerializer<?> elementSerializer = mock(JsonSerializer.class); [EOL] CollectionSerializer result = original.withResolved(property, vts, elementSerializer); [EOL] assertNotNull(result); [EOL] assertNotSame(original, result); [EOL] assertSame(property, result.getProperty()); [EOL] assertSame(vts, result.getTypeSerializer()); [EOL] assertSame(elementSerializer, result.getContentSerializer()); [EOL] }
public void testSerializeContentsWithElementSerializer() throws IOException { [EOL] Collection<?> value = ...; // Initialize with a collection [EOL] JsonGenerator jgen = ...; // Initialize JsonGenerator [EOL] SerializerProvider provider = ...; // Initialize SerializerProvider [EOL] JsonSerializer<Object> elementSerializer = ...; // Initialize element serializer [EOL] serializeContents(value, jgen, provider); [EOL] }
public void testSerializeContentsEmptyCollection() throws IOException { [EOL] Collection<?> value = Collections.emptyList(); [EOL] JsonGenerator jgen = ...; // Initialize JsonGenerator [EOL] SerializerProvider provider = ...; // Initialize SerializerProvider [EOL] serializeContents(value, jgen, provider); [EOL] }
public void testSerializeContentsWithNonNullElements() throws IOException { [EOL] Collection<?> value = ...; // Initialize with a collection containing non-null elements [EOL] JsonGenerator jgen = ...; // Initialize JsonGenerator [EOL] SerializerProvider provider = ...; // Initialize SerializerProvider [EOL] serializeContents(value, jgen, provider); [EOL] }
public void testSerializeContentsWithNullElements() throws IOException { [EOL] Collection<?> value = ...; // Initialize with a collection containing null elements [EOL] JsonGenerator jgen = ...; // Initialize JsonGenerator [EOL] SerializerProvider provider = ...; // Initialize SerializerProvider [EOL] serializeContents(value, jgen, provider); [EOL] }
public void testSerializeContentsWithException() throws IOException { [EOL] Collection<?> value = ...; // Initialize with a collection that will cause an exception during serialization [EOL] JsonGenerator jgen = ...; // Initialize JsonGenerator [EOL] SerializerProvider provider = ...; // Initialize SerializerProvider [EOL] try { [EOL] serializeContents(value, jgen, provider); [EOL] fail("Expected an exception to be thrown"); [EOL] } catch (Exception e) { [EOL] } [EOL] }
public void testDeserializationFeatureWithTrue() { [EOL] DeserializationFeature feature = new DeserializationFeature(true); [EOL] assertTrue(feature.enabledByDefault()); [EOL] }
public void testDeserializationFeatureWithFalse() { [EOL] DeserializationFeature feature = new DeserializationFeature(false); [EOL] assertFalse(feature.enabledByDefault()); [EOL] }
public void testSimpleKeyDeserializersInstantiation() { [EOL] SimpleKeyDeserializers deserializers = new SimpleKeyDeserializers(); [EOL] assertNotNull(deserializers); [EOL] }
public void testAddDeserializerWithNewMap() { [EOL] SimpleKeyDeserializers deserializers = new SimpleKeyDeserializers(); [EOL] KeyDeserializer keyDeserializer = mock(KeyDeserializer.class); [EOL] Class<?> forClass = String.class; [EOL] SimpleKeyDeserializers result = deserializers.addDeserializer(forClass, keyDeserializer); [EOL] assertNotNull(result); [EOL] assertSame(deserializers, result); [EOL] assertNotNull(result.findDeserializer(forClass)); [EOL] assertSame(keyDeserializer, result.findDeserializer(forClass)); [EOL] }
public void testAddDeserializerWithExistingMap() { [EOL] SimpleKeyDeserializers deserializers = new SimpleKeyDeserializers(); [EOL] KeyDeserializer keyDeserializer1 = mock(KeyDeserializer.class); [EOL] KeyDeserializer keyDeserializer2 = mock(KeyDeserializer.class); [EOL] Class<?> forClass1 = String.class; [EOL] Class<?> forClass2 = Integer.class; [EOL] deserializers.addDeserializer(forClass1, keyDeserializer1); [EOL] SimpleKeyDeserializers result = deserializers.addDeserializer(forClass2, keyDeserializer2); [EOL] assertNotNull(result); [EOL] assertSame(deserializers, result); [EOL] assertNotNull(result.findDeserializer(forClass1)); [EOL] assertNotNull(result.findDeserializer(forClass2)); [EOL] assertSame(keyDeserializer1, result.findDeserializer(forClass1)); [EOL] assertSame(keyDeserializer2, result.findDeserializer(forClass2)); [EOL] }
public void testFindKeyDeserializerWithNullClassMappings() { [EOL] KeyDeserializers deserializers = new KeyDeserializers() { [EOL] private Map<ClassKey, KeyDeserializer> _classMappings = null; [EOL] @Override [EOL] public KeyDeserializer findKeyDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) { [EOL] if (_classMappings == null) { [EOL] return null; [EOL] } [EOL] return _classMappings.get(new ClassKey(type.getRawClass())); [EOL] } [EOL] }; [EOL] JavaType type = mock(JavaType.class); [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] KeyDeserializer result = deserializers.findKeyDeserializer(type, config, beanDesc); [EOL] assertNull(result); [EOL] }
public void testFindKeyDeserializerWithNonNullClassMappings() { [EOL] KeyDeserializers deserializers = new KeyDeserializers() { [EOL] private Map<ClassKey, KeyDeserializer> _classMappings = new HashMap<>(); [EOL] @Override [EOL] public KeyDeserializer findKeyDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) { [EOL] if (_classMappings == null) { [EOL] return null; [EOL] } [EOL] return _classMappings.get(new ClassKey(type.getRawClass())); [EOL] } [EOL] }; [EOL] JavaType type = mock(JavaType.class); [EOL] when(type.getRawClass()).thenReturn(String.class); [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] ClassKey classKey = new ClassKey(String.class); [EOL] KeyDeserializer expectedDeserializer = mock(KeyDeserializer.class); [EOL] deserializers._classMappings.put(classKey, expectedDeserializer); [EOL] KeyDeserializer result = deserializers.findKeyDeserializer(type, config, beanDesc); [EOL] assertSame(expectedDeserializer, result); [EOL] }
public void testAtomicReferenceSerializerConstructor() { [EOL] AtomicReferenceSerializer serializer = new AtomicReferenceSerializer(); [EOL] assertNotNull(serializer); [EOL] assertEquals(AtomicReference.class, serializer.handledType()); [EOL] assertFalse(serializer.usesObjectId()); [EOL] }
public void testSerializeWithNonNullValue() throws IOException { [EOL] AtomicReference<Object> value = new AtomicReference<>("testValue"); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] new AtomicReferenceSerializer().serialize(value, jgen, provider); [EOL] verify(provider).defaultSerializeValue("testValue", jgen); [EOL] }
public void testSerializeWithNullValue() throws IOException { [EOL] AtomicReference<Object> value = new AtomicReference<>(null); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] new AtomicReferenceSerializer().serialize(value, jgen, provider); [EOL] verify(provider).defaultSerializeValue(null, jgen); [EOL] }
public void testDeepCopyWithEmptyObjectNode() { [EOL] ObjectNode original = new ObjectNode(JsonNodeFactory.instance); [EOL] ObjectNode copy = original.deepCopy(); [EOL] assertNotSame(original, copy); [EOL] assertTrue(copy.isEmpty()); [EOL] }
public void testDeepCopyWithNonEmptyObjectNode() { [EOL] ObjectNode original = new ObjectNode(JsonNodeFactory.instance); [EOL] original.set("key1", TextNode.valueOf("value1")); [EOL] original.set("key2", TextNode.valueOf("value2")); [EOL] ObjectNode copy = original.deepCopy(); [EOL] assertNotSame(original, copy); [EOL] assertEquals(original, copy); [EOL] assertNotSame(original.get("key1"), copy.get("key1")); [EOL] assertNotSame(original.get("key2"), copy.get("key2")); [EOL] }
public void testPutWithValidFieldNameAndDoubleValue() { [EOL] ObjectNode objectNode = new ObjectNode(JsonNodeFactory.instance); [EOL] double value = 10.5; [EOL] String fieldName = "testField"; [EOL] ObjectNode result = objectNode.put(fieldName, value); [EOL] assertSame("The method should return the same ObjectNode instance", objectNode, result); [EOL] assertTrue("The ObjectNode should contain the key", objectNode.has(fieldName)); [EOL] assertEquals("The value for the key should be the double value", value, objectNode.get(fieldName).asDouble(), 0.0); [EOL] }
public void testPutWithNullByteArray() { [EOL] ObjectNode objectNode = JsonNodeFactory.instance.objectNode(); [EOL] String fieldName = "field"; [EOL] byte[] value = null; [EOL] ObjectNode result = objectNode.put(fieldName, value); [EOL] assertTrue(result.get(fieldName).isNull()); [EOL] }
public void testPutWithNonNullByteArray() { [EOL] ObjectNode objectNode = JsonNodeFactory.instance.objectNode(); [EOL] String fieldName = "field"; [EOL] byte[] value = new byte[]{1, 2, 3}; [EOL] ObjectNode result = objectNode.put(fieldName, value); [EOL] assertTrue(result.get(fieldName).isBinary()); [EOL] assertArrayEquals(value, ((BinaryNode) result.get(fieldName)).binaryValue()); [EOL] }
public void testGetTypeWithNonNullContext() { [EOL] TypeBindings context = new TypeBindings(null, null, null); [EOL] MyType myTypeInstance = new MyType(); [EOL] JavaType result = myTypeInstance.getType(context); [EOL] assertNotNull(result); [EOL] }
public void testGetTypeWithGenericType() { [EOL] TypeBindings context = new TypeBindings(null, null, null); [EOL] MyGenericType myGenericTypeInstance = new MyGenericType(); [EOL] JavaType result = myGenericTypeInstance.getType(context); [EOL] assertEquals(expectedGenericType, result.getRawClass()); [EOL] }
public void testOkNameForGetterWithIsGetter() { [EOL] AnnotatedMethod am = createAnnotatedMethod("isValue"); [EOL] String result = JacksonDatabindUtils.okNameForGetter(am); [EOL] assertNotNull(result); [EOL] assertEquals("value", result); [EOL] } [EOL] public void testOkNameForGetterWithRegularGetter() { [EOL] AnnotatedMethod am = createAnnotatedMethod("getValue"); [EOL] String result = JacksonDatabindUtils.okNameForGetter(am); [EOL] assertNotNull(result); [EOL] assertEquals("value", result); [EOL] } [EOL] public void testOkNameForGetterWithNonGetter() { [EOL] AnnotatedMethod am = createAnnotatedMethod("notAGetter"); [EOL] String result = JacksonDatabindUtils.okNameForGetter(am); [EOL] assertNull(result); [EOL] }

public void testCopyWithValidInstance() { [EOL] MappingJsonFactory factory = new MappingJsonFactory(); [EOL] JsonFactory copy = factory.copy(); [EOL] assertNotNull(copy); [EOL] assertNotSame(factory, copy); [EOL] assertTrue(copy instanceof MappingJsonFactory); [EOL] }
public void testValueOfWithNonCanonicalValue() { [EOL] int nonCanonicalValue = IntNode.MAX_CANONICAL + 1; // Assuming MAX_CANONICAL is a static field [EOL] IntNode result = IntNode.valueOf(nonCanonicalValue); [EOL] assertNotNull(result); [EOL] assertEquals(nonCanonicalValue, result.intValue()); [EOL] }
public void testValueOfWithMinimumCanonicalValue() { [EOL] int minCanonicalValue = IntNode.MIN_CANONICAL; // Assuming MIN_CANONICAL is a static field [EOL] IntNode result = IntNode.valueOf(minCanonicalValue); [EOL] assertNotNull(result); [EOL] assertSame(IntNode.CANONICALS[0], result); // Assuming CANONICALS is a static field [EOL] }
public void testValueOfWithMaximumCanonicalValue() { [EOL] int maxCanonicalValue = IntNode.MAX_CANONICAL; // Assuming MAX_CANONICAL is a static field [EOL] IntNode result = IntNode.valueOf(maxCanonicalValue); [EOL] assertNotNull(result); [EOL] assertSame(IntNode.CANONICALS[maxCanonicalValue - IntNode.MIN_CANONICAL], result); // Assuming CANONICALS is a static field [EOL] }
public void testNumberType() { [EOL] JsonParser.NumberType expected = JsonParser.NumberType.INT; [EOL] JsonParser.NumberType actual = new YourConcreteJsonParserSubclass().numberType(); [EOL] assertEquals(expected, actual); [EOL] }
public void testCanConvertToInt() { [EOL] JsonNode node = new NumericNode(); [EOL] assertTrue(node.canConvertToInt()); [EOL] }
public void testEquals_sameObject() { [EOL] IntNode node = new IntNode(5); [EOL] boolean result = node.equals(node); [EOL] assert result; [EOL] } [EOL] public void testEquals_nullObject() { [EOL] IntNode node = new IntNode(5); [EOL] boolean result = node.equals(null); [EOL] assert !result; [EOL] } [EOL] public void testEquals_differentClass() { [EOL] IntNode node = new IntNode(5); [EOL] Object other = new Object(); [EOL] boolean result = node.equals(other); [EOL] assert !result; [EOL] } [EOL] public void testEquals_differentValue() { [EOL] IntNode node1 = new IntNode(5); [EOL] IntNode node2 = new IntNode(10); [EOL] boolean result = node1.equals(node2); [EOL] assert !result; [EOL] } [EOL] public void testEquals_sameValue() { [EOL] IntNode node1 = new IntNode(5); [EOL] IntNode node2 = new IntNode(5); [EOL] boolean result = node1.equals(node2); [EOL] assert result; [EOL] }
public void testHashCodeWithPositiveValue() { [EOL] SomeClass instance = new SomeClass(123); [EOL] int expectedHashCode = 123; [EOL] int actualHashCode = instance.hashCode(); [EOL] assertEquals(expectedHashCode, actualHashCode); [EOL] }
public void testHashCodeWithNegativeValue() { [EOL] SomeClass instance = new SomeClass(-456); [EOL] int expectedHashCode = -456; [EOL] int actualHashCode = instance.hashCode(); [EOL] assertEquals(expectedHashCode, actualHashCode); [EOL] }
public void testHashCodeWithZero() { [EOL] SomeClass instance = new SomeClass(0); [EOL] int expectedHashCode = 0; [EOL] int actualHashCode = instance.hashCode(); [EOL] assertEquals(expectedHashCode, actualHashCode); [EOL] }
public void testConstructValueInstantiatorWithNullDelegateCreator() { [EOL] DeserializationConfig config = new DeserializationConfig(...); // Provide actual initialization [EOL] BeanDescription beanDesc = new BeanDescription(...); // Provide actual initialization [EOL] MyClass instance = new MyClass(config, beanDesc); [EOL] instance.setDelegateCreator(null); // Assuming there's a setter for _delegateCreator [EOL] ValueInstantiator result = instance.constructValueInstantiator(config); [EOL] assertNull(result.getDelegateType()); // Assuming there's a getter for delegateType [EOL] }
public void testConstructValueInstantiatorWithNonNullDelegateCreatorAndNullArgs() { [EOL] DeserializationConfig config = new DeserializationConfig(...); // Provide actual initialization [EOL] BeanDescription beanDesc = new BeanDescription(...); // Provide actual initialization [EOL] MyClass instance = new MyClass(config, beanDesc); [EOL] instance.setDelegateCreator(...); // Provide actual initialization [EOL] instance.setDelegateArgs(null); // Assuming there's a setter for _delegateArgs [EOL] ValueInstantiator result = instance.constructValueInstantiator(config); [EOL] assertNotNull(result.getDelegateType()); // Assuming there's a getter for delegateType [EOL] }
public void testConstructValueInstantiatorWithNonNullDelegateCreatorAndNonNullArgs() { [EOL] DeserializationConfig config = new DeserializationConfig(...); // Provide actual initialization [EOL] BeanDescription beanDesc = new BeanDescription(...); // Provide actual initialization [EOL] MyClass instance = new MyClass(config, beanDesc); [EOL] instance.setDelegateCreator(...); // Provide actual initialization [EOL] Object[] delegateArgs = new Object[] { null, new Object(), new Object() }; // Example args [EOL] instance.setDelegateArgs(delegateArgs); // Assuming there's a setter for _delegateArgs [EOL] ValueInstantiator result = instance.constructValueInstantiator(config); [EOL] assertNotNull(result.getDelegateType()); // Assuming there's a getter for delegateType [EOL] }
public void testSetDefaultCreatorWithAnnotatedConstructor() { [EOL] AnnotatedWithParams mockAnnotatedConstructor = Mockito.mock(AnnotatedConstructor.class); [EOL] YourClass instance = new YourClass(); // Replace with actual class name that contains setDefaultCreator [EOL] instance.setDefaultCreator(mockAnnotatedConstructor); [EOL] Mockito.verify(instance).setDefaultConstructor((AnnotatedConstructor) mockAnnotatedConstructor); [EOL] }
public void testSetDefaultCreatorWithNonAnnotatedConstructor() { [EOL] AnnotatedWithParams mockAnnotatedWithParams = Mockito.mock(AnnotatedWithParams.class); [EOL] YourClass instance = new YourClass(); // Replace with actual class name that contains setDefaultCreator [EOL] instance.setDefaultCreator(mockAnnotatedWithParams); [EOL] assertEquals(mockAnnotatedWithParams, instance.get_defaultConstructor()); [EOL] assertTrue(instance.was_fixAccessCalled()); [EOL] }
public void testAddStringCreatorWithNull() { [EOL] CreatorCollector collector = new CreatorCollector(null, false); [EOL] collector.addStringCreator(null); [EOL] assertNull(collector.getStringCreator()); [EOL] }
public void testAddStringCreatorWithNonNull() { [EOL] CreatorCollector collector = new CreatorCollector(null, false); [EOL] AnnotatedWithParams mockCreator = Mockito.mock(AnnotatedWithParams.class); [EOL] collector.addStringCreator(mockCreator); [EOL] assertEquals(mockCreator, collector.getStringCreator()); [EOL] }
public void testAddStringCreatorWithDuplicate() { [EOL] CreatorCollector collector = new CreatorCollector(null, false); [EOL] AnnotatedWithParams mockCreator1 = Mockito.mock(AnnotatedWithParams.class); [EOL] AnnotatedWithParams mockCreator2 = Mockito.mock(AnnotatedWithParams.class); [EOL] collector.addStringCreator(mockCreator1); [EOL] try { [EOL] collector.addStringCreator(mockCreator2); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Duplicate String creator", e.getMessage()); [EOL] } [EOL] }
public void testAddLongCreatorWithNull() { [EOL] CreatorCollector collector = new CreatorCollector(null, false); [EOL] AnnotatedWithParams creator = null; [EOL] collector.addLongCreator(creator); [EOL] assertNull(collector.getLongCreator()); [EOL] }
public void testAddLongCreatorWithNonNull() { [EOL] CreatorCollector collector = new CreatorCollector(null, false); [EOL] AnnotatedWithParams creator = mock(AnnotatedWithParams.class); [EOL] collector.addLongCreator(creator); [EOL] assertEquals(creator, collector.getLongCreator()); [EOL] }
public void testAddLongCreatorWithDuplicate() { [EOL] CreatorCollector collector = new CreatorCollector(null, false); [EOL] AnnotatedWithParams firstCreator = mock(AnnotatedWithParams.class); [EOL] AnnotatedWithParams secondCreator = mock(AnnotatedWithParams.class); [EOL] collector.addLongCreator(firstCreator); [EOL] try { [EOL] collector.addLongCreator(secondCreator); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Conflicting long creators", e.getMessage()); [EOL] } [EOL] }
public void testAddDelegatingCreatorWithNonNullCreatorAndInjectables() { [EOL] CreatorCollector collector = new CreatorCollector(null, false); [EOL] AnnotatedWithParams creator = mock(AnnotatedWithParams.class); [EOL] CreatorProperty[] injectables = new CreatorProperty[] { mock(CreatorProperty.class) }; [EOL] collector.addDelegatingCreator(creator, injectables); [EOL] assertNotNull(collector.getDelegateCreator()); [EOL] assertArrayEquals(injectables, collector.getDelegateArgs()); [EOL] }
public void testAddDelegatingCreatorWithNonNullCreatorAndNullInjectables() { [EOL] CreatorCollector collector = new CreatorCollector(null, false); [EOL] AnnotatedWithParams creator = mock(AnnotatedWithParams.class); [EOL] collector.addDelegatingCreator(creator, null); [EOL] assertNotNull(collector.getDelegateCreator()); [EOL] assertNull(collector.getDelegateArgs()); [EOL] }
public void testAddDelegatingCreatorWithDuplicateCreator() { [EOL] CreatorCollector collector = new CreatorCollector(null, false); [EOL] AnnotatedWithParams creator1 = mock(AnnotatedWithParams.class); [EOL] AnnotatedWithParams creator2 = mock(AnnotatedWithParams.class); [EOL] collector.addDelegatingCreator(creator1, null); [EOL] try { [EOL] collector.addDelegatingCreator(creator2, null); [EOL] fail("Expected IllegalArgumentException not thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertTrue(e.getMessage().contains("duplicate")); [EOL] } [EOL] }
public void testAddPropertyCreatorWithEmptyProperties() { [EOL] AnnotatedWithParams creator = mock(AnnotatedWithParams.class); [EOL] CreatorProperty[] properties = new CreatorProperty[0]; [EOL] target.addPropertyCreator(creator, properties); [EOL] assertEquals(creator, target.getPropertyBasedCreator()); [EOL] assertArrayEquals(properties, target.getPropertyBasedArgs()); [EOL] }
public void testAddPropertyCreatorWithSingleProperty() { [EOL] AnnotatedWithParams creator = mock(AnnotatedWithParams.class); [EOL] CreatorProperty[] properties = new CreatorProperty[1]; [EOL] properties[0] = mock(CreatorProperty.class); [EOL] when(properties[0].getName()).thenReturn("property1"); [EOL] target.addPropertyCreator(creator, properties); [EOL] assertEquals(creator, target.getPropertyBasedCreator()); [EOL] assertArrayEquals(properties, target.getPropertyBasedArgs()); [EOL] }
public void testAddPropertyCreatorWithMultiplePropertiesNoDuplicates() { [EOL] AnnotatedWithParams creator = mock(AnnotatedWithParams.class); [EOL] CreatorProperty[] properties = new CreatorProperty[2]; [EOL] properties[0] = mock(CreatorProperty.class); [EOL] properties[1] = mock(CreatorProperty.class); [EOL] when(properties[0].getName()).thenReturn("property1"); [EOL] when(properties[1].getName()).thenReturn("property2"); [EOL] target.addPropertyCreator(creator, properties); [EOL] assertEquals(creator, target.getPropertyBasedCreator()); [EOL] assertArrayEquals(properties, target.getPropertyBasedArgs()); [EOL] }
public void testAddPropertyCreatorWithMultiplePropertiesWithDuplicates() { [EOL] AnnotatedWithParams creator = mock(AnnotatedWithParams.class); [EOL] CreatorProperty[] properties = new CreatorProperty[2]; [EOL] properties[0] = mock(CreatorProperty.class); [EOL] properties[1] = mock(CreatorProperty.class); [EOL] when(properties[0].getName()).thenReturn("property"); [EOL] when(properties[1].getName()).thenReturn("property"); [EOL] Exception exception = assertThrows(IllegalArgumentException.class, () -> { [EOL] target.addPropertyCreator(creator, properties); [EOL] }); [EOL] String expectedMessage = "Duplicate creator property \"property\" (index 0 vs 1)"; [EOL] String actualMessage = exception.getMessage(); [EOL] assertTrue(actualMessage.contains(expectedMessage)); [EOL] }
public void testAddPropertyCreatorWithMultiplePropertiesWithInjectable() { [EOL] AnnotatedWithParams creator = mock(AnnotatedWithParams.class); [EOL] CreatorProperty[] properties = new CreatorProperty[2]; [EOL] properties[0] = mock(CreatorProperty.class); [EOL] properties[1] = mock(CreatorProperty.class); [EOL] when(properties[0].getName()).thenReturn(""); [EOL] when(properties[0].getInjectableValueId()).thenReturn("injectable"); [EOL] when(properties[1].getName()).thenReturn("property2"); [EOL] target.addPropertyCreator(creator, properties); [EOL] assertEquals(creator, target.getPropertyBasedCreator()); [EOL] assertArrayEquals(properties, target.getPropertyBasedArgs()); [EOL] }
public void testAddIncompleteParameterWhenNoneExists() { [EOL] CreatorCollector underTest = new CreatorCollector(null, false); [EOL] AnnotatedParameter parameter = new AnnotatedParameter(null, null, null, null, null, 0); [EOL] underTest.addIncompeteParameter(parameter); [EOL] assertEquals(parameter, underTest.getIncompleteParameter()); [EOL] }
public void testAddIncompleteParameterWhenAlreadyExists() { [EOL] CreatorCollector underTest = new CreatorCollector(null, false); [EOL] AnnotatedParameter firstParameter = new AnnotatedParameter(null, null, null, null, null, 0); [EOL] AnnotatedParameter secondParameter = new AnnotatedParameter(null, null, null, null, null, 1); [EOL] underTest.addIncompeteParameter(firstParameter); [EOL] underTest.addIncompeteParameter(secondParameter); [EOL] assertEquals(firstParameter, underTest.getIncompleteParameter()); [EOL] assertNotEquals(secondParameter, underTest.getIncompleteParameter()); [EOL] }
public void testVerifyNonDupWithNullOldOne() { [EOL] AnnotatedWithParams newOne = createNewAnnotatedWithParams(); [EOL] AnnotatedWithParams oldOne = null; [EOL] String type = "testType"; [EOL] AnnotatedWithParams result = verifyNonDup(newOne, oldOne, type); [EOL] assertNotNull(result); [EOL] }
public void testVerifyNonDupWithDifferentClassOldOne() { [EOL] AnnotatedWithParams newOne = createNewAnnotatedWithParams(); [EOL] AnnotatedWithParams oldOne = createDifferentClassAnnotatedWithParams(); [EOL] String type = "testType"; [EOL] AnnotatedWithParams result = verifyNonDup(newOne, oldOne, type); [EOL] assertNotNull(result); [EOL] }
public void testVerifyNonDupWithSameClassOldOne() { [EOL] AnnotatedWithParams newOne = createNewAnnotatedWithParams(); [EOL] AnnotatedWithParams oldOne = createSameClassAnnotatedWithParams(); [EOL] String type = "testType"; [EOL] try { [EOL] verifyNonDup(newOne, oldOne, type); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Conflicting " + type + " creators: already had " + oldOne + ", encountered " + newOne, e.getMessage()); [EOL] } [EOL] }
public void testFindTreeNodeDeserializerWithNullClassMappings() { [EOL] SimpleDeserializers deserializers = new SimpleDeserializers(); [EOL] Class<? extends JsonNode> nodeType = JsonNode.class; [EOL] DeserializationConfig config = null; // Assuming we can pass null for this test [EOL] BeanDescription beanDesc = null; // Assuming we can pass null for this test [EOL] JsonDeserializer<?> result = deserializers.findTreeNodeDeserializer(nodeType, config, beanDesc); [EOL] assertNull(result); [EOL] }
public void testFindTreeNodeDeserializerWithNonNullClassMappingsAndKeyNotPresent() { [EOL] SimpleDeserializers deserializers = new SimpleDeserializers(); [EOL] deserializers.addDeserializer(JsonNode.class, new JsonNodeDeserializer()); [EOL] Class<? extends JsonNode> nodeType = TextNode.class; // Different type from what was added [EOL] DeserializationConfig config = null; // Assuming we can pass null for this test [EOL] BeanDescription beanDesc = null; // Assuming we can pass null for this test [EOL] JsonDeserializer<?> result = deserializers.findTreeNodeDeserializer(nodeType, config, beanDesc); [EOL] assertNull(result); [EOL] }
public void testFindTreeNodeDeserializerWithNonNullClassMappingsAndKeyPresent() { [EOL] SimpleDeserializers deserializers = new SimpleDeserializers(); [EOL] JsonDeserializer<?> expectedDeserializer = new JsonNodeDeserializer(); [EOL] deserializers.addDeserializer(JsonNode.class, expectedDeserializer); [EOL] Class<? extends JsonNode> nodeType = JsonNode.class; // Same type as what was added [EOL] DeserializationConfig config = null; // Assuming we can pass null for this test [EOL] BeanDescription beanDesc = null; // Assuming we can pass null for this test [EOL] JsonDeserializer<?> result = deserializers.findTreeNodeDeserializer(nodeType, config, beanDesc); [EOL] assertSame(expectedDeserializer, result); [EOL] }
public void testAsToken() { [EOL] MyJsonNode node = new MyJsonNode(); [EOL] JsonToken token = node.asToken(); [EOL] assertEquals(JsonToken.VALUE_NUMBER_FLOAT, token); [EOL] }
public void testNumberType() { [EOL] JsonNodeFactory factory = JsonNodeFactory.instance; [EOL] NumericNode numericNode = factory.numberNode(new BigDecimal("123.456")); [EOL] assertEquals(JsonParser.NumberType.BIG_DECIMAL, numericNode.numberType()); [EOL] }
public void testCanConvertToInt_MinValue() { [EOL] BigDecimalValue value = new BigDecimalValue(BigDecimalValue.MIN_INTEGER); [EOL] assertTrue(value.canConvertToInt()); [EOL] }
public void testCanConvertToInt_MaxValue() { [EOL] BigDecimalValue value = new BigDecimalValue(BigDecimalValue.MAX_INTEGER); [EOL] assertTrue(value.canConvertToInt()); [EOL] }
public void testCanConvertToInt_TooSmall() { [EOL] BigDecimalValue value = new BigDecimalValue(BigDecimalValue.MIN_INTEGER.subtract(BigDecimal.ONE)); [EOL] assertFalse(value.canConvertToInt()); [EOL] }
public void testCanConvertToInt_TooLarge() { [EOL] BigDecimalValue value = new BigDecimalValue(BigDecimalValue.MAX_INTEGER.add(BigDecimal.ONE)); [EOL] assertFalse(value.canConvertToInt()); [EOL] }
public void testCanConvertToInt_InRange() { [EOL] BigDecimalValue value = new BigDecimalValue(BigDecimalValue.MIN_INTEGER.add(BigDecimal.ONE)); [EOL] assertTrue(value.canConvertToInt()); [EOL] }
public void testCanConvertToLong_MinValue() { [EOL] BigDecimalValue value = new BigDecimalValue(new BigDecimal(Long.MIN_VALUE)); [EOL] assertTrue(value.canConvertToLong()); [EOL] }
public void testCanConvertToLong_MaxValue() { [EOL] BigDecimalValue value = new BigDecimalValue(new BigDecimal(Long.MAX_VALUE)); [EOL] assertTrue(value.canConvertToLong()); [EOL] }
public void testCanConvertToLong_TooSmall() { [EOL] BigDecimalValue value = new BigDecimalValue(BigDecimalValue.MIN_LONG.subtract(BigDecimal.ONE)); [EOL] assertFalse(value.canConvertToLong()); [EOL] }
public void testCanConvertToLong_TooLarge() { [EOL] BigDecimalValue value = new BigDecimalValue(BigDecimalValue.MAX_LONG.add(BigDecimal.ONE)); [EOL] assertFalse(value.canConvertToLong()); [EOL] }
public void testIntValue_Positive() { [EOL] JsonIntValue jsonIntValue = new JsonIntValue(10); [EOL] int result = jsonIntValue.intValue(); [EOL] assertEquals(10, result); [EOL] }
public void testIntValue_Negative() { [EOL] JsonIntValue jsonIntValue = new JsonIntValue(-10); [EOL] int result = jsonIntValue.intValue(); [EOL] assertEquals(-10, result); [EOL] }
public void testIntValue_Zero() { [EOL] JsonIntValue jsonIntValue = new JsonIntValue(0); [EOL] int result = jsonIntValue.intValue(); [EOL] assertEquals(0, result); [EOL] }
public void testLongValue_Positive() { [EOL] LongTestWrapper wrapper = new LongTestWrapper(123L); [EOL] long expected = 123L; [EOL] long actual = wrapper.longValue(); [EOL] assertEquals(expected, actual); [EOL] }
public void testLongValue_Negative() { [EOL] LongTestWrapper wrapper = new LongTestWrapper(-123L); [EOL] long expected = -123L; [EOL] long actual = wrapper.longValue(); [EOL] assertEquals(expected, actual); [EOL] }
public void testLongValue_Zero() { [EOL] LongTestWrapper wrapper = new LongTestWrapper(0L); [EOL] long expected = 0L; [EOL] long actual = wrapper.longValue(); [EOL] assertEquals(expected, actual); [EOL] }
public void testLongValue_MaxValue() { [EOL] LongTestWrapper wrapper = new LongTestWrapper(Long.MAX_VALUE); [EOL] long expected = Long.MAX_VALUE; [EOL] long actual = wrapper.longValue(); [EOL] assertEquals(expected, actual); [EOL] }
public void testLongValue_MinValue() { [EOL] LongTestWrapper wrapper = new LongTestWrapper(Long.MIN_VALUE); [EOL] long expected = Long.MIN_VALUE; [EOL] long actual = wrapper.longValue(); [EOL] assertEquals(expected, actual); [EOL] }
public void testDoubleValue_Positive() { [EOL] BigDecimalHolder holder = new BigDecimalHolder(new BigDecimal("123.456")); [EOL] double result = holder.doubleValue(); [EOL] assertEquals(123.456, result, 0.0); [EOL] }
public void testDoubleValue_Negative() { [EOL] BigDecimalHolder holder = new BigDecimalHolder(new BigDecimal("-123.456")); [EOL] double result = holder.doubleValue(); [EOL] assertEquals(-123.456, result, 0.0); [EOL] }
public void testDoubleValue_Zero() { [EOL] BigDecimalHolder holder = new BigDecimalHolder(BigDecimal.ZERO); [EOL] double result = holder.doubleValue(); [EOL] assertEquals(0.0, result, 0.0); [EOL] }
public void testDecimalValue() { [EOL] BigDecimal expected = new BigDecimal("123.456"); [EOL] DecimalNode node = new DecimalNode(expected); [EOL] BigDecimal result = node.decimalValue(); [EOL] assertEquals(expected, result); [EOL] }
public void testEqualsWithSameObject() { [EOL] DecimalNode node = new DecimalNode(BigDecimal.ONE); [EOL] assertTrue(node.equals(node)); [EOL] }
public void testEqualsWithNull() { [EOL] DecimalNode node = new DecimalNode(BigDecimal.ONE); [EOL] assertFalse(node.equals(null)); [EOL] }
public void testEqualsWithDifferentClass() { [EOL] DecimalNode node = new DecimalNode(BigDecimal.ONE); [EOL] Object other = new Object(); [EOL] assertFalse(node.equals(other)); [EOL] }
public void testEqualsWithEqualValues() { [EOL] DecimalNode node1 = new DecimalNode(BigDecimal.ONE); [EOL] DecimalNode node2 = new DecimalNode(BigDecimal.ONE); [EOL] assertTrue(node1.equals(node2)); [EOL] }
public void testEqualsWithDifferentValues() { [EOL] DecimalNode node1 = new DecimalNode(BigDecimal.ONE); [EOL] DecimalNode node2 = new DecimalNode(BigDecimal.TEN); [EOL] assertFalse(node1.equals(node2)); [EOL] }
public void testHashCodeWithNonNullValue() { [EOL] SomeClass instance = new SomeClass("testValue"); [EOL] int expectedHashCode = "testValue".hashCode(); [EOL] int actualHashCode = instance.hashCode(); [EOL] assertEquals(expectedHashCode, actualHashCode); [EOL] }
public void testHashCodeWithNullValue() { [EOL] SomeClass instance = new SomeClass(null); [EOL] int expectedHashCode = 0; // Assuming the hashCode for null _value is 0 [EOL] int actualHashCode = instance.hashCode(); [EOL] assertEquals(expectedHashCode, actualHashCode); [EOL] }
public void testAnnotatedWithParamsWithNullAnnotations() { [EOL] AnnotationMap[] paramAnnotations = new AnnotationMap[0]; [EOL] AnnotatedWithParams awp = new AnnotatedWithParams(null, paramAnnotations); [EOL] assertNull(awp.getAnnotations()); [EOL] assertArrayEquals(paramAnnotations, awp.getParamAnnotations()); [EOL] }
public void testAnnotatedWithParamsWithNonNullAnnotations() { [EOL] AnnotationMap annotations = new AnnotationMap(); [EOL] AnnotationMap[] paramAnnotations = new AnnotationMap[0]; [EOL] AnnotatedWithParams awp = new AnnotatedWithParams(annotations, paramAnnotations); [EOL] assertEquals(annotations, awp.getAnnotations()); [EOL] assertArrayEquals(paramAnnotations, awp.getParamAnnotations()); [EOL] }
public void testAnnotatedWithParamsWithNullParamAnnotations() { [EOL] AnnotationMap annotations = new AnnotationMap(); [EOL] AnnotatedWithParams awp = new AnnotatedWithParams(annotations, null); [EOL] assertEquals(annotations, awp.getAnnotations()); [EOL] assertNull(awp.getParamAnnotations()); [EOL] }
public void testGetTypeWithNullTypeParams() { [EOL] TypeBindings bindings = new TypeBindings(null, null, null); [EOL] JavaType result = getType(bindings, null); [EOL] assertNotNull(result); [EOL] }
public void testGetTypeWithEmptyTypeParams() { [EOL] TypeBindings bindings = new TypeBindings(null, null, null); [EOL] TypeVariable<?>[] typeParams = new TypeVariable<?>[0]; [EOL] JavaType result = getType(bindings, typeParams); [EOL] assertNotNull(result); [EOL] }
public void testGetTypeWithTypeParams() { [EOL] TypeBindings bindings = new TypeBindings(null, null, null); [EOL] TypeVariable<?>[] typeParams = new TypeVariable<?>[1]; [EOL] TypeVariable<?> typeVar = mock(TypeVariable.class); [EOL] when(typeVar.getName()).thenReturn("T"); [EOL] when(typeVar.getBounds()).thenReturn(new Type[]{null}); [EOL] typeParams[0] = typeVar; [EOL] JavaType result = getType(bindings, typeParams); [EOL] assertNotNull(result); [EOL] }
public void testGetTypeWithTypeParamsAndNonNullBounds() { [EOL] TypeBindings bindings = new TypeBindings(null, null, null); [EOL] TypeVariable<?>[] typeParams = new TypeVariable<?>[1]; [EOL] TypeVariable<?> typeVar = mock(TypeVariable.class); [EOL] when(typeVar.getName()).thenReturn("T"); [EOL] Type lowerBound = String.class; [EOL] when(typeVar.getBounds()).thenReturn(new Type[]{lowerBound}); [EOL] typeParams[0] = typeVar; [EOL] JavaType result = getType(bindings, typeParams); [EOL] assertNotNull(result); [EOL] }
public void testGetAnnotationWithExistingClass() { [EOL] AnnotationCollector ac = new AnnotationCollector(); [EOL] Class<MyAnnotation> acls = MyAnnotation.class; [EOL] MyAnnotation expectedAnnotation = new MyAnnotation(); [EOL] ac.add(acls, expectedAnnotation); [EOL] MyAnnotation actualAnnotation = ac.getAnnotation(acls); [EOL] assertEquals(expectedAnnotation, actualAnnotation); [EOL] }
public void testGetAnnotationWithNonExistingClass() { [EOL] AnnotationCollector ac = new AnnotationCollector(); [EOL] Class<OtherAnnotation> acls = OtherAnnotation.class; [EOL] OtherAnnotation actualAnnotation = ac.getAnnotation(acls); [EOL] assertNull(actualAnnotation); [EOL] }
public void testGetParameterAnnotationsValidIndex() { [EOL] int validIndex = 0; // assuming 0 is a valid index [EOL] AnnotationMap result = obj.getParameterAnnotations(validIndex); [EOL] assertNotNull(result); [EOL] }
public void testGetParameterAnnotationsInvalidIndex() { [EOL] int invalidIndex = -1; // assuming -1 is an invalid index [EOL] AnnotationMap result = obj.getParameterAnnotations(invalidIndex); [EOL] assertNull(result); [EOL] }
public void testGetParameterAnnotationsIndexOutOfBounds() { [EOL] int outOfBoundsIndex = n; // assuming n is out of bounds [EOL] AnnotationMap result = obj.getParameterAnnotations(outOfBoundsIndex); [EOL] assertNull(result); [EOL] }
public void testGetParameterAnnotationsWithNullAnnotations() { [EOL] int anyIndex = 0; [EOL] AnnotationMap result = obj.getParameterAnnotations(anyIndex); [EOL] assertNull(result); [EOL] }
public AnnotatedParameter getParameter(int index) { [EOL] return new AnnotatedParameter(this, getGenericParameterType(index), getParameterAnnotations(index), index); [EOL] }
public void testBasicBeanDescriptionWithNonNullConfig() { [EOL] MapperConfig<?> config = mock(MapperConfig.class); [EOL] JavaType type = mock(JavaType.class); [EOL] AnnotatedClass classDef = mock(AnnotatedClass.class); [EOL] List<BeanPropertyDefinition> props = new ArrayList<>(); [EOL] when(config.getAnnotationIntrospector()).thenReturn(mock(AnnotationIntrospector.class)); [EOL] BasicBeanDescription beanDescription = new BasicBeanDescription(config, type, classDef, props); [EOL] assertNotNull(beanDescription); [EOL] assertEquals(config, beanDescription.getConfig()); [EOL] assertNotNull(beanDescription.getAnnotationIntrospector()); [EOL] assertEquals(classDef, beanDescription.getClassInfo()); [EOL] assertEquals(props, beanDescription.findProperties()); [EOL] }
public void testBasicBeanDescriptionWithNullConfig() { [EOL] JavaType type = mock(JavaType.class); [EOL] AnnotatedClass classDef = mock(AnnotatedClass.class); [EOL] List<BeanPropertyDefinition> props = new ArrayList<>(); [EOL] BasicBeanDescription beanDescription = new BasicBeanDescription(null, type, classDef, props); [EOL] assertNotNull(beanDescription); [EOL] assertNull(beanDescription.getConfig()); [EOL] assertNull(beanDescription.getAnnotationIntrospector()); [EOL] assertEquals(classDef, beanDescription.getClassInfo()); [EOL] assertEquals(props, beanDescription.findProperties()); [EOL] }
public void testBasicBeanDescriptionWithNullCollector() { [EOL] POJOPropertiesCollector coll = null; [EOL] try { [EOL] new BasicBeanDescription(coll); [EOL] fail("Expected NullPointerException to be thrown"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testBasicBeanDescriptionWithNonNullCollector() { [EOL] POJOPropertiesCollector coll = mock(POJOPropertiesCollector.class); [EOL] when(coll.getConfig()).thenReturn(mock(MapperConfig.class)); [EOL] when(coll.getType()).thenReturn(mock(JavaType.class)); [EOL] when(coll.getClassDef()).thenReturn(mock(AnnotatedClass.class)); [EOL] when(coll.getProperties()).thenReturn(Collections.emptyList()); [EOL] when(coll.getObjectIdInfo()).thenReturn(mock(ObjectIdInfo.class)); [EOL] BasicBeanDescription description = new BasicBeanDescription(coll); [EOL] assertNotNull(description); [EOL] assertEquals(coll.getObjectIdInfo(), description.getObjectIdInfo()); [EOL] }
public void testForSerializationWithJsonValueMethodAndAnyGetter() { [EOL] POJOPropertiesCollector coll = mock(POJOPropertiesCollector.class); [EOL] when(coll.getJsonValueMethod()).thenReturn(mock(AnnotatedMethod.class)); [EOL] when(coll.getAnyGetter()).thenReturn(mock(AnnotatedMethod.class)); [EOL] BasicBeanDescription desc = BasicBeanDescription.forSerialization(coll); [EOL] assertNotNull(desc); [EOL] assertNotNull(desc._jsonValueMethod); [EOL] assertNotNull(desc._anyGetter); [EOL] }
public void testForSerializationWithNullJsonValueMethodAndAnyGetter() { [EOL] POJOPropertiesCollector coll = mock(POJOPropertiesCollector.class); [EOL] when(coll.getJsonValueMethod()).thenReturn(null); [EOL] when(coll.getAnyGetter()).thenReturn(mock(AnnotatedMethod.class)); [EOL] BasicBeanDescription desc = BasicBeanDescription.forSerialization(coll); [EOL] assertNotNull(desc); [EOL] assertNull(desc._jsonValueMethod); [EOL] assertNotNull(desc._anyGetter); [EOL] }
public void testForSerializationWithJsonValueMethodAndNullAnyGetter() { [EOL] POJOPropertiesCollector coll = mock(POJOPropertiesCollector.class); [EOL] when(coll.getJsonValueMethod()).thenReturn(mock(AnnotatedMethod.class)); [EOL] when(coll.getAnyGetter()).thenReturn(null); [EOL] BasicBeanDescription desc = BasicBeanDescription.forSerialization(coll); [EOL] assertNotNull(desc); [EOL] assertNotNull(desc._jsonValueMethod); [EOL] assertNull(desc._anyGetter); [EOL] }
public void testForSerializationWithNullJsonValueMethodAndNullAnyGetter() { [EOL] POJOPropertiesCollector coll = mock(POJOPropertiesCollector.class); [EOL] when(coll.getJsonValueMethod()).thenReturn(null); [EOL] when(coll.getAnyGetter()).thenReturn(null); [EOL] BasicBeanDescription desc = BasicBeanDescription.forSerialization(coll); [EOL] assertNotNull(desc); [EOL] assertNull(desc._jsonValueMethod); [EOL] assertNull(desc._anyGetter); [EOL] }
public void testForOtherUseWithValidInputs() { [EOL] MapperConfig<?> config = mock(MapperConfig.class); [EOL] JavaType type = mock(JavaType.class); [EOL] AnnotatedClass ac = mock(AnnotatedClass.class); [EOL] BasicBeanDescription result = BasicBeanDescription.forOtherUse(config, type, ac); [EOL] assertNotNull(result); [EOL] assertSame(config, result.getConfig()); [EOL] assertSame(type, result.getType()); [EOL] assertSame(ac, result.getClassInfo()); [EOL] assertTrue(result.findProperties().isEmpty()); [EOL] }
public void testGetClassInfo() { [EOL] AnnotatedClass annotatedClass = new AnnotatedClass(SomeClass.class); [EOL] JacksonAnnotationIntrospector introspector = new JacksonAnnotationIntrospector(); [EOL] AnnotatedClass actualClassInfo = introspector.getClassInfo(); [EOL] assertNotNull(actualClassInfo); [EOL] assertEquals(annotatedClass, actualClassInfo); [EOL] }
public void testGetObjectIdInfo_WhenObjectIdInfoIsSet_ShouldReturnSameInstance() { [EOL] ObjectIdInfo expectedObjectIdInfo = new ObjectIdInfo(...); // Provide necessary arguments [EOL] SomeClass instance = new SomeClass(); [EOL] instance._objectIdInfo = expectedObjectIdInfo; // Assuming direct access or through a setter method [EOL] ObjectIdInfo actualObjectIdInfo = instance.getObjectIdInfo(); [EOL] assertEquals(expectedObjectIdInfo, actualObjectIdInfo); [EOL] }
public void testFindPropertiesReturnsCorrectList() { [EOL] BeanPropertyDefinition prop1 = mock(BeanPropertyDefinition.class); [EOL] BeanPropertyDefinition prop2 = mock(BeanPropertyDefinition.class); [EOL] List<BeanPropertyDefinition> properties = new ArrayList<>(); [EOL] properties.add(prop1); [EOL] properties.add(prop2); [EOL] YourClass yourClass = new YourClass(properties); [EOL] List<BeanPropertyDefinition> result = yourClass.findProperties(); [EOL] assertNotNull(result); [EOL] assertEquals(2, result.size()); [EOL] assertTrue(result.contains(prop1)); [EOL] assertTrue(result.contains(prop2)); [EOL] }
public void testFindJsonValueMethodWhenNull() { [EOL] assertNull(instance.findJsonValueMethod()); [EOL] }
public void testFindJsonValueMethodWhenNotNull() { [EOL] AnnotatedMethod expectedMethod = new AnnotatedMethod(); // Replace with actual constructor [EOL] instance.setJsonValueMethod(expectedMethod); // Replace with actual setter method [EOL] assertEquals(expectedMethod, instance.findJsonValueMethod()); [EOL] }
public void testGetIgnoredPropertyNamesWhenNull() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] SerializationConfig config = mapper.getSerializationConfig(); [EOL] Set<String> ignoredPropertyNames = config.getIgnoredPropertyNames(); [EOL] assertTrue(ignoredPropertyNames.isEmpty()); [EOL] }
public void testGetIgnoredPropertyNamesWhenNotEmpty() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] SerializationConfig config = mapper.getSerializationConfig(); [EOL] config._ignoredPropertyNames = new HashSet<>(Arrays.asList("prop1", "prop2")); [EOL] Set<String> ignoredPropertyNames = config.getIgnoredPropertyNames(); [EOL] assertEquals(2, ignoredPropertyNames.size()); [EOL] assertTrue(ignoredPropertyNames.contains("prop1")); [EOL] assertTrue(ignoredPropertyNames.contains("prop2")); [EOL] }
public void testGetClassAnnotations() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] AnnotatedClass annotatedClass = AnnotatedClass.construct(mapper.constructType(MyClass.class), mapper.getSerializationConfig()); [EOL] Annotations annotations = annotatedClass.getClassAnnotations(); [EOL] assertNotNull(annotations); [EOL] assertTrue(annotations.size() > 0); [EOL] }
public void testBindingsForBeanType_WhenBindingsAreNull_ShouldInitializeBindings() { [EOL] BeanDescription beanDescription = createBeanDescriptionWithNullBindings(); [EOL] TypeBindings result = beanDescription.bindingsForBeanType(); [EOL] assertNotNull(result); [EOL] assertEquals(beanDescription.getExpectedTypeBindings(), result); [EOL] } [EOL] public void testBindingsForBeanType_WhenBindingsAreNotNull_ShouldReturnExistingBindings() { [EOL] BeanDescription beanDescription = createBeanDescriptionWithNonNullBindings(); [EOL] TypeBindings expectedBindings = beanDescription.getExpectedTypeBindings(); [EOL] TypeBindings result = beanDescription.bindingsForBeanType(); [EOL] assertSame(expectedBindings, result); [EOL] }
public void testResolveTypeWithNull() { [EOL] JavaType result = resolveType(null); [EOL] assertNull(result); [EOL] }
public void testResolveTypeWithNonNullType() { [EOL] JavaType mockJavaType = mock(JavaType.class); [EOL] Type mockType = mock(Type.class); [EOL] TypeBindings mockBindings = mock(TypeBindings.class); [EOL] when(bindingsForBeanType()).thenReturn(mockBindings); [EOL] when(mockBindings.resolveType(mockType)).thenReturn(mockJavaType); [EOL] JavaType result = resolveType(mockType); [EOL] assertNotNull(result); [EOL] assertEquals(mockJavaType, result); [EOL] }
public void testFindDefaultConstructorWhenDefaultConstructorExists() { [EOL] ClassInfo classInfoMock = mock(ClassInfo.class); [EOL] AnnotatedConstructor expectedConstructor = new AnnotatedConstructor(); [EOL] when(classInfoMock.getDefaultConstructor()).thenReturn(expectedConstructor); [EOL] MyClass myObject = new MyClass(classInfoMock); [EOL] AnnotatedConstructor actualConstructor = myObject.findDefaultConstructor(); [EOL] assertNotNull(actualConstructor); [EOL] assertEquals(expectedConstructor, actualConstructor); [EOL] }
public void testFindDefaultConstructorWhenDefaultConstructorDoesNotExist() { [EOL] ClassInfo classInfoMock = mock(ClassInfo.class); [EOL] when(classInfoMock.getDefaultConstructor()).thenReturn(null); [EOL] MyClass myObject = new MyClass(classInfoMock); [EOL] AnnotatedConstructor actualConstructor = myObject.findDefaultConstructor(); [EOL] assertNull(actualConstructor); [EOL] }
public void testFindAnySetterWithValidStringType() { [EOL] AnnotatedMethod annotatedMethod = createAnnotatedMethodWithFirstParamType(String.class); [EOL] BeanPropertyCollector collector = new BeanPropertyCollector(annotatedMethod); [EOL] AnnotatedMethod result = collector.findAnySetter(); [EOL] assertEquals(annotatedMethod, result); [EOL] } [EOL] public void testFindAnySetterWithValidObjectType() { [EOL] AnnotatedMethod annotatedMethod = createAnnotatedMethodWithFirstParamType(Object.class); [EOL] BeanPropertyCollector collector = new BeanPropertyCollector(annotatedMethod); [EOL] AnnotatedMethod result = collector.findAnySetter(); [EOL] assertEquals(annotatedMethod, result); [EOL] } [EOL] public void testFindAnySetterWithInvalidType() { [EOL] AnnotatedMethod annotatedMethod = createAnnotatedMethodWithFirstParamType(Integer.class); [EOL] BeanPropertyCollector collector = new BeanPropertyCollector(annotatedMethod); [EOL] try { [EOL] collector.findAnySetter(); [EOL] fail("IllegalArgumentException was expected for an invalid parameter type"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] } [EOL] public void testFindAnySetterWithNull() { [EOL] BeanPropertyCollector collector = new BeanPropertyCollector(null); [EOL] AnnotatedMethod result = collector.findAnySetter(); [EOL] assertNull(result); [EOL] }
public void testGetConstructors() { [EOL] MyClassInfo mockClassInfo = Mockito.mock(MyClassInfo.class); [EOL] List<AnnotatedConstructor> expectedConstructors = new ArrayList<>(); [EOL] Mockito.when(mockClassInfo.getConstructors()).thenReturn(expectedConstructors); [EOL] MyClassUnderTest myClassUnderTest = new MyClassUnderTest(mockClassInfo); [EOL] List<AnnotatedConstructor> actualConstructors = myClassUnderTest.getConstructors(); [EOL] assertSame("The list of constructors should be the same as the one returned by _classInfo", expectedConstructors, actualConstructors); [EOL] }
public void testInstantiateBeanWithNullConstructor() { [EOL] BeanInstantiator instantiator = new BeanInstantiator(null); // Assuming a constructor that takes AnnotatedConstructor [EOL] Object bean = instantiator.instantiateBean(false); [EOL] assertNull(bean); [EOL] }
public void testInstantiateBeanWithFixAccess() throws Exception { [EOL] AnnotatedConstructor ac = mock(AnnotatedConstructor.class); [EOL] when(ac.getAnnotated()).thenReturn(SomeClass.class.getConstructor()); [EOL] BeanInstantiator instantiator = new BeanInstantiator(ac); // Assuming a constructor that takes AnnotatedConstructor [EOL] instantiator.instantiateBean(true); [EOL] verify(ac).fixAccess(); [EOL] }
public void testInstantiateBeanWithoutFixAccess() throws Exception { [EOL] AnnotatedConstructor ac = mock(AnnotatedConstructor.class); [EOL] when(ac.getAnnotated()).thenReturn(SomeClass.class.getConstructor()); [EOL] BeanInstantiator instantiator = new BeanInstantiator(ac); // Assuming a constructor that takes AnnotatedConstructor [EOL] instantiator.instantiateBean(false); [EOL] verify(ac, never()).fixAccess(); [EOL] }
public void testInstantiateBeanThrowsError() { [EOL] AnnotatedConstructor ac = mock(AnnotatedConstructor.class); [EOL] when(ac.getAnnotated()).thenThrow(new Error("Test error")); [EOL] BeanInstantiator instantiator = new BeanInstantiator(ac); // Assuming a constructor that takes AnnotatedConstructor [EOL] try { [EOL] instantiator.instantiateBean(false); [EOL] fail("Expected Error to be thrown"); [EOL] } catch (Error e) { [EOL] assertEquals("Test error", e.getMessage()); [EOL] } [EOL] }
public void testInstantiateBeanThrowsRuntimeException() { [EOL] AnnotatedConstructor ac = mock(AnnotatedConstructor.class); [EOL] when(ac.getAnnotated()).thenThrow(new RuntimeException("Test runtime exception")); [EOL] BeanInstantiator instantiator = new BeanInstantiator(ac); // Assuming a constructor that takes AnnotatedConstructor [EOL] try { [EOL] instantiator.instantiateBean(false); [EOL] fail("Expected RuntimeException to be thrown"); [EOL] } catch (RuntimeException e) { [EOL] assertEquals("Test runtime exception", e.getMessage()); [EOL] } [EOL] }
public void testInstantiateBeanThrowsWrappedException() { [EOL] AnnotatedConstructor ac = mock(AnnotatedConstructor.class); [EOL] when(ac.getAnnotated()).thenThrow(new InvocationTargetException(new Exception("Test exception"))); [EOL] BeanInstantiator instantiator = new BeanInstantiator(ac); // Assuming a constructor that takes AnnotatedConstructor [EOL] try { [EOL] instantiator.instantiateBean(false); [EOL] fail("Expected IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertTrue(e.getMessage().contains("Failed to instantiate bean of type")); [EOL] assertTrue(e.getMessage().contains("Test exception")); [EOL] } [EOL] }
public void testFindMethodWithValidNameAndParams() { [EOL] String methodName = "someMethod"; [EOL] Class<?>[] paramTypes = new Class<?>[] {String.class, int.class}; [EOL] AnnotatedMethod result = _classInfo.findMethod(methodName, paramTypes); [EOL] assertNotNull(result); [EOL] assertEquals(methodName, result.getName()); [EOL] assertArrayEquals(paramTypes, result.getParameterTypes()); [EOL] }
public void testFindMethodWithInvalidName() { [EOL] String methodName = "nonExistentMethod"; [EOL] Class<?>[] paramTypes = new Class<?>[] {String.class, int.class}; [EOL] AnnotatedMethod result = _classInfo.findMethod(methodName, paramTypes); [EOL] assertNull(result); [EOL] }
public void testFindMethodWithNullName() { [EOL] String methodName = null; [EOL] Class<?>[] paramTypes = new Class<?>[] {String.class, int.class}; [EOL] try { [EOL] _classInfo.findMethod(methodName, paramTypes); [EOL] fail("Should have thrown IllegalArgumentException for null method name"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testFindMethodWithNullParams() { [EOL] String methodName = "someMethod"; [EOL] Class<?>[] paramTypes = null; [EOL] try { [EOL] _classInfo.findMethod(methodName, paramTypes); [EOL] fail("Should have thrown IllegalArgumentException for null paramTypes"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testFindMethodWithEmptyParams() { [EOL] String methodName = "someMethod"; [EOL] Class<?>[] paramTypes = new Class<?>[] {}; [EOL] AnnotatedMethod result = _classInfo.findMethod(methodName, paramTypes); [EOL] assertNotNull(result); [EOL] assertEquals(0, result.getParameterCount()); [EOL] }
public void testFindExpectedFormatWithNonNullIntrospectorAndNonNullFormat() { [EOL] AnnotationIntrospector introspector = Mockito.mock(AnnotationIntrospector.class); [EOL] ClassInfo classInfo = Mockito.mock(ClassInfo.class); [EOL] JsonFormat.Value expectedFormat = new JsonFormat.Value(); [EOL] Mockito.when(introspector.findFormat(classInfo)).thenReturn(expectedFormat); [EOL] BeanPropertyDefinition instance = new BeanPropertyDefinition(); [EOL] instance._annotationIntrospector = introspector; [EOL] instance._classInfo = classInfo; [EOL] JsonFormat.Value result = instance.findExpectedFormat(null); [EOL] assertSame(expectedFormat, result); [EOL] }
public void testFindExpectedFormatWithNonNullIntrospectorAndNullFormat() { [EOL] AnnotationIntrospector introspector = Mockito.mock(AnnotationIntrospector.class); [EOL] ClassInfo classInfo = Mockito.mock(ClassInfo.class); [EOL] JsonFormat.Value defaultValue = new JsonFormat.Value(); [EOL] Mockito.when(introspector.findFormat(classInfo)).thenReturn(null); [EOL] BeanPropertyDefinition instance = new BeanPropertyDefinition(); [EOL] instance._annotationIntrospector = introspector; [EOL] instance._classInfo = classInfo; [EOL] JsonFormat.Value result = instance.findExpectedFormat(defaultValue); [EOL] assertSame(defaultValue, result); [EOL] }
public void testFindExpectedFormatWithNullIntrospector() { [EOL] JsonFormat.Value defaultValue = new JsonFormat.Value(); [EOL] BeanPropertyDefinition instance = new BeanPropertyDefinition(); [EOL] instance._annotationIntrospector = null; [EOL] instance._classInfo = null; [EOL] JsonFormat.Value result = instance.findExpectedFormat(defaultValue); [EOL] assertSame(defaultValue, result); [EOL] }
public void testFindSerializationConverterWithNullIntrospector() { [EOL] MyClass instance = new MyClass(null); [EOL] Converter<Object, Object> result = instance.findSerializationConverter(); [EOL] assertNull(result); [EOL] }
public void testFindSerializationConverterWithNonNullIntrospector() { [EOL] AnnotationIntrospector introspector = mock(AnnotationIntrospector.class); [EOL] MyClass instance = new MyClass(introspector); [EOL] ClassInfo classInfo = new ClassInfo(); // Assuming ClassInfo is a valid class and has a constructor [EOL] when(introspector.findSerializationConverter(classInfo)).thenReturn(SomeConverter.class); [EOL] Converter<Object, Object> result = instance.findSerializationConverter(); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof SomeConverter); [EOL] }
public void testFindSerializationInclusionWithNullIntrospector() { [EOL] SerializationConfig config = new SerializationConfig(...); // Provide necessary arguments [EOL] AnnotatedClass ac = AnnotatedClass.construct(...); // Provide necessary arguments [EOL] BeanPropertyWriter bpw = new BeanPropertyWriter(...); // Provide necessary arguments [EOL] bpw.assignNullSerializer(...); // Provide necessary arguments if needed [EOL] JsonInclude.Include result = bpw.findSerializationInclusion(JsonInclude.Include.ALWAYS); [EOL] assertEquals(JsonInclude.Include.ALWAYS, result); [EOL] }
public void testFindSerializationInclusionWithNonNullIntrospector() { [EOL] SerializationConfig config = new SerializationConfig(...); // Provide necessary arguments [EOL] AnnotationIntrospector introspector = new AnnotationIntrospector() { [EOL] @Override [EOL] public JsonInclude.Include findSerializationInclusion(Annotated a, JsonInclude.Include defValue) { [EOL] return JsonInclude.Include.NON_NULL; [EOL] } [EOL] }; [EOL] AnnotatedClass ac = AnnotatedClass.construct(...); // Provide necessary arguments [EOL] BeanPropertyWriter bpw = new BeanPropertyWriter(...); // Provide necessary arguments [EOL] bpw.assignNullSerializer(...); // Provide necessary arguments if needed [EOL] bpw.assignAnnotationIntrospector(introspector); [EOL] JsonInclude.Include result = bpw.findSerializationInclusion(JsonInclude.Include.ALWAYS); [EOL] assertEquals(JsonInclude.Include.NON_NULL, result); [EOL] }
public void testFindAnyGetterWithNonNullAnyGetterAndValidType() { [EOL] BeanPropertyMap beanPropertyMap = new BeanPropertyMap(false, Collections.emptyList()); [EOL] AnnotatedMethod anyGetter = new AnnotatedMethod(null, Map.class.getMethod("size"), null, null); [EOL] beanPropertyMap._anyGetter = anyGetter; [EOL] AnnotatedMember result = beanPropertyMap.findAnyGetter(); [EOL] assertEquals(anyGetter, result); [EOL] }
public void testFindAnyGetterWithNonNullAnyGetterAndInvalidType() { [EOL] BeanPropertyMap beanPropertyMap = new BeanPropertyMap(false, Collections.emptyList()); [EOL] AnnotatedMethod anyGetter = new AnnotatedMethod(null, String.class.getMethod("length"), null, null); [EOL] beanPropertyMap._anyGetter = anyGetter; [EOL] try { [EOL] beanPropertyMap.findAnyGetter(); [EOL] fail("Expected IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertTrue(e.getMessage().contains("Invalid 'any-getter' annotation on method")); [EOL] } [EOL] }
public void testFindAnyGetterWithNullAnyGetter() { [EOL] BeanPropertyMap beanPropertyMap = new BeanPropertyMap(false, Collections.emptyList()); [EOL] AnnotatedMember result = beanPropertyMap.findAnyGetter(); [EOL] assertNull(result); [EOL] }
public void testFindBackReferenceProperties_NoBackReferences() { [EOL] BeanPropertyDefinition property = mock(BeanPropertyDefinition.class); [EOL] when(property.getMutator()).thenReturn(null); [EOL] List<BeanPropertyDefinition> properties = Collections.singletonList(property); [EOL] AnnotationIntrospector annotationIntrospector = mock(AnnotationIntrospector.class); [EOL] when(annotationIntrospector.findReferenceType(any(AnnotatedMember.class))).thenReturn(null); [EOL] Map<String, AnnotatedMember> result = new YourClassUnderTest(properties, annotationIntrospector).findBackReferenceProperties(); [EOL] assertNull(result); [EOL] }
public void testFindBackReferenceProperties_WithBackReferences() { [EOL] BeanPropertyDefinition property = mock(BeanPropertyDefinition.class); [EOL] AnnotatedMember annotatedMember = mock(AnnotatedMember.class); [EOL] when(property.getMutator()).thenReturn(annotatedMember); [EOL] AnnotationIntrospector.ReferenceProperty refProperty = mock(AnnotationIntrospector.ReferenceProperty.class); [EOL] when(refProperty.isBackReference()).thenReturn(true); [EOL] when(refProperty.getName()).thenReturn("backRef"); [EOL] AnnotationIntrospector annotationIntrospector = mock(AnnotationIntrospector.class); [EOL] when(annotationIntrospector.findReferenceType(annotatedMember)).thenReturn(refProperty); [EOL] List<BeanPropertyDefinition> properties = Collections.singletonList(property); [EOL] Map<String, AnnotatedMember> result = new YourClassUnderTest(properties, annotationIntrospector).findBackReferenceProperties(); [EOL] assertNotNull(result); [EOL] assertTrue(result.containsKey("backRef")); [EOL] assertEquals(annotatedMember, result.get("backRef")); [EOL] }
public void testFindBackReferenceProperties_MultipleBackReferencesSameName() { [EOL] BeanPropertyDefinition property1 = mock(BeanPropertyDefinition.class); [EOL] AnnotatedMember annotatedMember1 = mock(AnnotatedMember.class); [EOL] when(property1.getMutator()).thenReturn(annotatedMember1); [EOL] BeanPropertyDefinition property2 = mock(BeanPropertyDefinition.class); [EOL] AnnotatedMember annotatedMember2 = mock(AnnotatedMember.class); [EOL] when(property2.getMutator()).thenReturn(annotatedMember2); [EOL] AnnotationIntrospector.ReferenceProperty refProperty = mock(AnnotationIntrospector.ReferenceProperty.class); [EOL] when(refProperty.isBackReference()).thenReturn(true); [EOL] when(refProperty.getName()).thenReturn("backRef"); [EOL] AnnotationIntrospector annotationIntrospector = mock(AnnotationIntrospector.class); [EOL] when(annotationIntrospector.findReferenceType(annotatedMember1)).thenReturn(refProperty); [EOL] when(annotationIntrospector.findReferenceType(annotatedMember2)).thenReturn(refProperty); [EOL] List<BeanPropertyDefinition> properties = Arrays.asList(property1, property2); [EOL] try { [EOL] new YourClassUnderTest(properties, annotationIntrospector).findBackReferenceProperties(); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testGetFactoryMethodsWithEmptyCandidates() { [EOL] MyClassInfo mockClassInfo = Mockito.mock(MyClassInfo.class); [EOL] Mockito.when(mockClassInfo.getStaticMethods()).thenReturn(Collections.emptyList()); [EOL] MyClassUnderTest myClassUnderTest = new MyClassUnderTest(mockClassInfo); [EOL] List<AnnotatedMethod> factoryMethods = myClassUnderTest.getFactoryMethods(); [EOL] assertTrue(factoryMethods.isEmpty()); [EOL] }
public void testGetFactoryMethodsWithNonEmptyCandidatesNoFactoryMethods() { [EOL] MyClassInfo mockClassInfo = Mockito.mock(MyClassInfo.class); [EOL] List<AnnotatedMethod> staticMethods = Arrays.asList( [EOL] Mockito.mock(AnnotatedMethod.class), [EOL] Mockito.mock(AnnotatedMethod.class) [EOL] ); [EOL] Mockito.when(mockClassInfo.getStaticMethods()).thenReturn(staticMethods); [EOL] Mockito.when(myClassUnderTest.isFactoryMethod(any(AnnotatedMethod.class))).thenReturn(false); [EOL] MyClassUnderTest myClassUnderTest = new MyClassUnderTest(mockClassInfo); [EOL] List<AnnotatedMethod> factoryMethods = myClassUnderTest.getFactoryMethods(); [EOL] assertTrue(factoryMethods.isEmpty()); [EOL] }
public void testGetFactoryMethodsWithNonEmptyCandidatesWithFactoryMethods() { [EOL] MyClassInfo mockClassInfo = Mockito.mock(MyClassInfo.class); [EOL] AnnotatedMethod nonFactoryMethod = Mockito.mock(AnnotatedMethod.class); [EOL] AnnotatedMethod factoryMethod = Mockito.mock(AnnotatedMethod.class); [EOL] List<AnnotatedMethod> staticMethods = Arrays.asList(nonFactoryMethod, factoryMethod); [EOL] Mockito.when(mockClassInfo.getStaticMethods()).thenReturn(staticMethods); [EOL] Mockito.when(myClassUnderTest.isFactoryMethod(nonFactoryMethod)).thenReturn(false); [EOL] Mockito.when(myClassUnderTest.isFactoryMethod(factoryMethod)).thenReturn(true); [EOL] MyClassUnderTest myClassUnderTest = new MyClassUnderTest(mockClassInfo); [EOL] List<AnnotatedMethod> factoryMethods = myClassUnderTest.getFactoryMethods(); [EOL] assertFalse(factoryMethods.isEmpty()); [EOL] assertEquals(1, factoryMethods.size()); [EOL] assertSame(factoryMethod, factoryMethods.get(0)); [EOL] }
public void testFindSingleArgConstructor_MatchFound() { [EOL] Class<?>[] argTypes = new Class<?>[]{String.class}; [EOL] AnnotatedConstructor ac = Mockito.mock(AnnotatedConstructor.class); [EOL] Mockito.when(ac.getParameterCount()).thenReturn(1); [EOL] Mockito.when(ac.getRawParameterType(0)).thenReturn(String.class); [EOL] Mockito.when(ac.getAnnotated()).thenReturn(String.class.getConstructor(String.class)); [EOL] ClassInfo classInfo = Mockito.mock(ClassInfo.class); [EOL] Mockito.when(classInfo.getConstructors()).thenReturn(Collections.singletonList(ac)); [EOL] Constructor<?> result = findSingleArgConstructor(argTypes); [EOL] assertNotNull(result); [EOL] assertEquals(String.class.getConstructor(String.class), result); [EOL] }
public void testFindSingleArgConstructor_NoMatchFound() { [EOL] Class<?>[] argTypes = new Class<?>[]{Integer.class}; [EOL] AnnotatedConstructor ac = Mockito.mock(AnnotatedConstructor.class); [EOL] Mockito.when(ac.getParameterCount()).thenReturn(1); [EOL] Mockito.when(ac.getRawParameterType(0)).thenReturn(String.class); [EOL] ClassInfo classInfo = Mockito.mock(ClassInfo.class); [EOL] Mockito.when(classInfo.getConstructors()).thenReturn(Collections.singletonList(ac)); [EOL] Constructor<?> result = findSingleArgConstructor(argTypes); [EOL] assertNull(result); [EOL] }
public void testFindSingleArgConstructor_NoSingleArgConstructors() { [EOL] Class<?>[] argTypes = new Class<?>[]{String.class}; [EOL] AnnotatedConstructor ac = Mockito.mock(AnnotatedConstructor.class); [EOL] Mockito.when(ac.getParameterCount()).thenReturn(2); [EOL] ClassInfo classInfo = Mockito.mock(ClassInfo.class); [EOL] Mockito.when(classInfo.getConstructors()).thenReturn(Collections.singletonList(ac)); [EOL] Constructor<?> result = findSingleArgConstructor(argTypes); [EOL] assertNull(result); [EOL] }
public void testFindSingleArgConstructor_EmptyArgTypes() { [EOL] Class<?>[] argTypes = new Class<?>[]{}; [EOL] AnnotatedConstructor ac = Mockito.mock(AnnotatedConstructor.class); [EOL] Mockito.when(ac.getParameterCount()).thenReturn(1); [EOL] Mockito.when(ac.getRawParameterType(0)).thenReturn(String.class); [EOL] ClassInfo classInfo = Mockito.mock(ClassInfo.class); [EOL] Mockito.when(classInfo.getConstructors()).thenReturn(Collections.singletonList(ac)); [EOL] Constructor<?> result = findSingleArgConstructor(argTypes); [EOL] assertNull(result); [EOL] }
public void testIsFactoryMethod_NotAssignableReturnType() { [EOL] AnnotatedMethod am = mock(AnnotatedMethod.class); [EOL] when(am.getRawReturnType()).thenReturn(Object.class); [EOL] when(getBeanClass()).thenReturn(String.class); [EOL] boolean result = isFactoryMethod(am); [EOL] assertFalse(result); [EOL] }
public void testIsFactoryMethod_HasCreatorAnnotation() { [EOL] AnnotatedMethod am = mock(AnnotatedMethod.class); [EOL] when(am.getRawReturnType()).thenReturn(String.class); [EOL] when(getBeanClass()).thenReturn(String.class); [EOL] when(_annotationIntrospector.hasCreatorAnnotation(am)).thenReturn(true); [EOL] boolean result = isFactoryMethod(am); [EOL] assertTrue(result); [EOL] }
public void testIsFactoryMethod_ValueOfMethodName() { [EOL] AnnotatedMethod am = mock(AnnotatedMethod.class); [EOL] when(am.getRawReturnType()).thenReturn(String.class); [EOL] when(getBeanClass()).thenReturn(String.class); [EOL] when(am.getName()).thenReturn("valueOf"); [EOL] when(_annotationIntrospector.hasCreatorAnnotation(am)).thenReturn(false); [EOL] boolean result = isFactoryMethod(am); [EOL] assertTrue(result); [EOL] }
public void testIsFactoryMethod_NonValueOfMethodName() { [EOL] AnnotatedMethod am = mock(AnnotatedMethod.class); [EOL] when(am.getRawReturnType()).thenReturn(String.class); [EOL] when(getBeanClass()).thenReturn(String.class); [EOL] when(am.getName()).thenReturn("nonValueOfMethod"); [EOL] when(_annotationIntrospector.hasCreatorAnnotation(am)).thenReturn(false); [EOL] boolean result = isFactoryMethod(am); [EOL] assertFalse(result); [EOL] }
public void testFindDeserializationConverterWithNullIntrospector() { [EOL] _annotationIntrospector = null; [EOL] Converter<Object, Object> result = findDeserializationConverter(); [EOL] assertNull(result); [EOL] }
public void testFindDeserializationConverterWithNonNullIntrospector() { [EOL] _annotationIntrospector = mock(AnnotationIntrospector.class); [EOL] ClassInfo classInfo = mock(ClassInfo.class); [EOL] _classInfo = classInfo; [EOL] when(_annotationIntrospector.findDeserializationConverter(classInfo)).thenReturn(SomeConverter.class); [EOL] Converter<Object, Object> result = findDeserializationConverter(); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof SomeConverter); [EOL] }
public void testCreateConverterWithNull() { [EOL] Converter<Object, Object> result = _createConverter(null); [EOL] assertNull(result); [EOL] }
public void testCreateConverterWithConverterInstance() { [EOL] Converter<Object, Object> converter = new Converter<Object, Object>() { [EOL] @Override [EOL] public Object convert(Object value) { [EOL] return value; [EOL] } [EOL] }; [EOL] Converter<Object, Object> result = _createConverter(converter); [EOL] assertSame(converter, result); [EOL] }
public void testCreateConverterWithInvalidType() { [EOL] Object invalidConverterDef = new Object(); [EOL] try { [EOL] _createConverter(invalidConverterDef); [EOL] fail("Expected IllegalStateException"); [EOL] } catch (IllegalStateException e) { [EOL] assertEquals("AnnotationIntrospector returned Converter definition of type " + invalidConverterDef.getClass().getName() + "; expected type Converter or Class<Converter> instead", e.getMessage()); [EOL] } [EOL] }
public void testCreateConverterWithNoneClass() { [EOL] Converter<Object, Object> result = _createConverter(Converter.None.class); [EOL] assertNull(result); [EOL] }
public void testCreateConverterWithNoClass() { [EOL] Converter<Object, Object> result = _createConverter(NoClass.class); [EOL] assertNull(result); [EOL] }
public void testCreateConverterWithNonConverterClass() { [EOL] class NonConverter {} [EOL] try { [EOL] _createConverter(NonConverter.class); [EOL] fail("Expected IllegalStateException"); [EOL] } catch (IllegalStateException e) { [EOL] assertEquals("AnnotationIntrospector returned Class " + NonConverter.class.getName() + "; expected Class<Converter>", e.getMessage()); [EOL] } [EOL] }
public void testCreateConverterWithValidConverterClass() { [EOL] class ValidConverter implements Converter<Object, Object> { [EOL] @Override [EOL] public Object convert(Object value) { [EOL] return value; [EOL] } [EOL] } [EOL] Converter<Object, Object> result = _createConverter(ValidConverter.class); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof ValidConverter); [EOL] }
public void testGetDelegateType() { [EOL] YourClass instance = new YourClass(); [EOL] JavaType expectedDelegateType = ...; // Initialize with the expected JavaType [EOL] instance._delegateType = expectedDelegateType; // Set the _delegateType field [EOL] JavaType result = instance.getDelegateType(null); // DeserializationConfig is not used in the method [EOL] assertEquals(expectedDelegateType, result); [EOL] }
public void testCreateFromObjectWithNullWithArgsCreator() { [EOL] MyValueInstantiator instantiator = new MyValueInstantiator(null); [EOL] try { [EOL] instantiator.createFromObjectWith(null, new Object[]{}); [EOL] fail("Expected an IllegalStateException to be thrown"); [EOL] } catch (IllegalStateException e) { [EOL] assertEquals("No with-args constructor for " + instantiator.getValueTypeDesc(), e.getMessage()); [EOL] } catch (Exception e) { [EOL] fail("Expected an IllegalStateException, but got a different exception"); [EOL] } [EOL] }
public void testCreateFromObjectWithValidArgs() throws Exception { [EOL] Object[] args = new Object[]{/* appropriate arguments */}; [EOL] MyValueInstantiator instantiator = new MyValueInstantiator(/* valid with-args constructor */); [EOL] Object result = instantiator.createFromObjectWith(null, args); [EOL] assertNotNull(result); [EOL] }
public void testCreateFromObjectWithExceptionInInitializerError() { [EOL] MyValueInstantiator instantiator = new MyValueInstantiator(/* constructor that throws ExceptionInInitializerError */); [EOL] try { [EOL] instantiator.createFromObjectWith(null, new Object[]{}); [EOL] fail("Expected a JsonProcessingException to be thrown"); [EOL] } catch (JsonProcessingException e) { [EOL] assertTrue(e.getCause() instanceof ExceptionInInitializerError); [EOL] } catch (Exception e) { [EOL] fail("Expected a JsonProcessingException, but got a different exception"); [EOL] } [EOL] }
public void testCreateFromObjectWithOtherException() { [EOL] MyValueInstantiator instantiator = new MyValueInstantiator(/* constructor that throws a generic exception */); [EOL] try { [EOL] instantiator.createFromObjectWith(null, new Object[]{}); [EOL] fail("Expected a JsonProcessingException to be thrown"); [EOL] } catch (JsonProcessingException e) { [EOL] assertFalse(e.getCause() instanceof ExceptionInInitializerError); [EOL] } catch (Exception e) { [EOL] fail("Expected a JsonProcessingException, but got a different exception"); [EOL] } [EOL] }
public void testCreateUsingDelegateWithNullCreator() throws IOException { [EOL] MyValueInstantiator instantiator = new MyValueInstantiator(); [EOL] instantiator._delegateCreator = null; [EOL] DeserializationContext ctxt = null; // Mock or create a real context as needed [EOL] Object delegate = new Object(); [EOL] try { [EOL] instantiator.createUsingDelegate(ctxt, delegate); [EOL] fail("Expected IllegalStateException"); [EOL] } catch (IllegalStateException e) { [EOL] assertEquals("No delegate constructor for " + instantiator.getValueTypeDesc(), e.getMessage()); [EOL] } [EOL] }
public void testCreateUsingDelegateWithoutArguments() throws IOException { [EOL] MyValueInstantiator instantiator = new MyValueInstantiator(); [EOL] instantiator._delegateCreator = mock(AnnotatedWithParams.class); [EOL] instantiator._delegateArguments = null; [EOL] DeserializationContext ctxt = null; // Mock or create a real context as needed [EOL] Object delegate = new Object(); [EOL] when(instantiator._delegateCreator.call1(delegate)).thenReturn(new Object()); [EOL] Object result = instantiator.createUsingDelegate(ctxt, delegate); [EOL] assertNotNull(result); [EOL] verify(instantiator._delegateCreator).call1(delegate); [EOL] }
public void testCreateUsingDelegateWithArguments() throws IOException { [EOL] MyValueInstantiator instantiator = new MyValueInstantiator(); [EOL] instantiator._delegateCreator = mock(AnnotatedWithParams.class); [EOL] CreatorProperty prop = mock(CreatorProperty.class); [EOL] instantiator._delegateArguments = new CreatorProperty[]{null, prop}; [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object delegate = new Object(); [EOL] Object injectableValue = new Object(); [EOL] when(ctxt.findInjectableValue(prop.getInjectableValueId(), prop, null)).thenReturn(injectableValue); [EOL] when(instantiator._delegateCreator.call(any(Object[].class))).thenReturn(new Object()); [EOL] Object result = instantiator.createUsingDelegate(ctxt, delegate); [EOL] assertNotNull(result); [EOL] verify(ctxt).findInjectableValue(prop.getInjectableValueId(), prop, null); [EOL] verify(instantiator._delegateCreator).call(any(Object[].class)); [EOL] }
public void testCreateUsingDelegateWithExceptionInInitializerError() throws IOException { [EOL] MyValueInstantiator instantiator = new MyValueInstantiator(); [EOL] instantiator._delegateCreator = mock(AnnotatedWithParams.class); [EOL] instantiator._delegateArguments = new CreatorProperty[]{}; [EOL] DeserializationContext ctxt = null; // Mock or create a real context as needed [EOL] Object delegate = new Object(); [EOL] when(instantiator._delegateCreator.call(any(Object[].class))).thenThrow(new ExceptionInInitializerError()); [EOL] try { [EOL] instantiator.createUsingDelegate(ctxt, delegate); [EOL] fail("Expected JsonMappingException"); [EOL] } catch (JsonMappingException e) { [EOL] assertTrue(e.getCause() instanceof ExceptionInInitializerError); [EOL] } [EOL] }
public void testCreateUsingDelegateWithGenericException() throws IOException { [EOL] MyValueInstantiator instantiator = new MyValueInstantiator(); [EOL] instantiator._delegateCreator = mock(AnnotatedWithParams.class); [EOL] instantiator._delegateArguments = new CreatorProperty[]{}; [EOL] DeserializationContext ctxt = null; // Mock or create a real context as needed [EOL] Object delegate = new Object(); [EOL] when(instantiator._delegateCreator.call(any(Object[].class))).thenThrow(new Exception()); [EOL] try { [EOL] instantiator.createUsingDelegate(ctxt, delegate); [EOL] fail("Expected JsonMappingException"); [EOL] } catch (JsonMappingException e) { [EOL] assertTrue(e.getCause() instanceof Exception); [EOL] } [EOL] }
public void testCreateFromIntWithIntCreator() throws IOException { [EOL] int testValue = 42; [EOL] Object expectedResult = Integer.valueOf(testValue); [EOL] when(_fromIntCreator.call1(any())).thenReturn(expectedResult); [EOL] Object result = createFromInt(mock(DeserializationContext.class), testValue); [EOL] assertEquals(expectedResult, result); [EOL] }
public void testCreateFromIntWithLongCreator() throws IOException { [EOL] int testValue = 42; [EOL] Object expectedResult = Long.valueOf(testValue); [EOL] when(_fromLongCreator.call1(any())).thenReturn(expectedResult); [EOL] Object result = createFromInt(mock(DeserializationContext.class), testValue); [EOL] assertEquals(expectedResult, result); [EOL] }
public void testCreateFromIntThrowsJsonMappingException() { [EOL] int testValue = 42; [EOL] Exception exception = assertThrows(JsonMappingException.class, () -> { [EOL] createFromInt(mock(DeserializationContext.class), testValue); [EOL] }); [EOL] assertTrue(exception.getMessage().contains("Can not instantiate value of type")); [EOL] }
public void testCreateFromIntThrowsWrappedException() throws Exception { [EOL] int testValue = 42; [EOL] when(_fromIntCreator.call1(any())).thenThrow(new Exception("test exception")); [EOL] Exception exception = assertThrows(JsonMappingException.class, () -> { [EOL] createFromInt(mock(DeserializationContext.class), testValue); [EOL] }); [EOL] assertNotNull(exception.getCause()); [EOL] assertEquals("test exception", exception.getCause().getMessage()); [EOL] }
public void testCreateFromIntThrowsWrappedExceptionInInitializerError() throws Exception { [EOL] int testValue = 42; [EOL] when(_fromIntCreator.call1(any())).thenThrow(new ExceptionInInitializerError("test initializer error")); [EOL] Exception exception = assertThrows(JsonMappingException.class, () -> { [EOL] createFromInt(mock(DeserializationContext.class), testValue); [EOL] }); [EOL] assertNotNull(exception.getCause()); [EOL] assertTrue(exception.getCause() instanceof ExceptionInInitializerError); [EOL] }
public void testGetDelegateCreator_WhenDelegateCreatorIsSet_ShouldReturnDelegateCreator() { [EOL] AnnotatedWithParams expectedDelegateCreator = mock(AnnotatedWithParams.class); [EOL] MyClass myClass = new MyClass(); [EOL] myClass._delegateCreator = expectedDelegateCreator; // Assuming there's a way to set this, either through a constructor or a setter [EOL] AnnotatedWithParams actualDelegateCreator = myClass.getDelegateCreator(); [EOL] assertEquals(expectedDelegateCreator, actualDelegateCreator); [EOL] }
public void testGetDelegateCreator_WhenDelegateCreatorIsNull_ShouldReturnNull() { [EOL] MyClass myClass = new MyClass(); [EOL] myClass._delegateCreator = null; // Assuming there's a way to set this, either through a constructor or a setter [EOL] AnnotatedWithParams actualDelegateCreator = myClass.getDelegateCreator(); [EOL] assertNull(actualDelegateCreator); [EOL] }
public void testCreateFromStringFallbacksWithTrue() throws IOException { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] String value = " true "; [EOL] Object result = _createFromStringFallbacks(ctxt, value); [EOL] assertNotNull(result); [EOL] assertTrue((Boolean) result); [EOL] }
public void testCreateFromStringFallbacksWithFalse() throws IOException { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] String value = " false "; [EOL] Object result = _createFromStringFallbacks(ctxt, value); [EOL] assertNotNull(result); [EOL] assertFalse((Boolean) result); [EOL] }
public void testCreateFromStringFallbacksWithEmptyString() throws IOException { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] String value = ""; [EOL] _cfgEmptyStringsAsObjects = true; [EOL] Object result = _createFromStringFallbacks(ctxt, value); [EOL] assertNull(result); [EOL] }
public void testCreateFromStringFallbacksWithNonEmptyString() { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] String value = "nonEmptyString"; [EOL] try { [EOL] _createFromStringFallbacks(ctxt, value); [EOL] fail("Expected JsonMappingException"); [EOL] } catch (JsonMappingException e) { [EOL] } [EOL] }
public void testSerializeWithJsonArrayFeatureEnabled() throws IOException { [EOL] char[] value = new char[]{'a', 'b', 'c'}; [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] when(provider.isEnabled(SerializationFeature.WRITE_CHAR_ARRAYS_AS_JSON_ARRAYS)).thenReturn(true); [EOL] new CharArraySerializer().serialize(value, jgen, provider); [EOL] verify(jgen).writeStartArray(); [EOL] verify(jgen).writeString(any(char[].class), anyInt(), anyInt()); [EOL] verify(jgen).writeEndArray(); [EOL] }
public void testSerializeWithoutJsonArrayFeatureEnabled() throws IOException { [EOL] char[] value = new char[]{'x', 'y', 'z'}; [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] when(provider.isEnabled(SerializationFeature.WRITE_CHAR_ARRAYS_AS_JSON_ARRAYS)).thenReturn(false); [EOL] new CharArraySerializer().serialize(value, jgen, provider); [EOL] verify(jgen).writeString(value, 0, value.length); [EOL] }
public void testWriteArrayContentsEmptyArray() throws IOException { [EOL] JsonGenerator mockGenerator = mock(JsonGenerator.class); [EOL] char[] emptyArray = new char[0]; [EOL] _writeArrayContents(mockGenerator, emptyArray); [EOL] verify(mockGenerator, never()).writeString(any(char[].class), anyInt(), anyInt()); [EOL] }
public void testWriteArrayContentsSingleElement() throws IOException { [EOL] JsonGenerator mockGenerator = mock(JsonGenerator.class); [EOL] char[] singleElementArray = new char[]{'a'}; [EOL] _writeArrayContents(mockGenerator, singleElementArray); [EOL] verify(mockGenerator, times(1)).writeString(singleElementArray, 0, 1); [EOL] }
public void testWriteArrayContentsMultipleElements() throws IOException { [EOL] JsonGenerator mockGenerator = mock(JsonGenerator.class); [EOL] char[] multipleElementsArray = new char[]{'a', 'b', 'c'}; [EOL] _writeArrayContents(mockGenerator, multipleElementsArray); [EOL] verify(mockGenerator, times(3)).writeString(any(char[].class), anyInt(), anyInt()); [EOL] }
public void testNarrowWithNonNullClass() { [EOL] MapType original = MapType.construct(HashMap.class, SimpleType.constructUnsafe(String.class), SimpleType.constructUnsafe(Integer.class)); [EOL] Class<?> subclass = LinkedHashMap.class; [EOL] JavaType narrowed = original._narrow(subclass); [EOL] assertTrue(narrowed instanceof MapType); [EOL] assertEquals(subclass, narrowed.getRawClass()); [EOL] }
public void testNarrowWithNullClass() { [EOL] MapType original = MapType.construct(HashMap.class, SimpleType.constructUnsafe(String.class), SimpleType.constructUnsafe(Integer.class)); [EOL] try { [EOL] JavaType narrowed = original._narrow(null); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testWithContentTypeHandler_NewHandler() { [EOL] Class<?> mapClass = Map.class; [EOL] JavaType keyType = SimpleType.constructUnsafe(String.class); [EOL] JavaType valueType = SimpleType.constructUnsafe(Object.class); [EOL] MapType mapType = MapType.construct(mapClass, keyType, valueType); [EOL] Object newContentTypeHandler = new Object(); [EOL] MapType newMapType = mapType.withContentTypeHandler(newContentTypeHandler); [EOL] assertNotNull(newMapType); [EOL] assertEquals(newContentTypeHandler, newMapType.getContentTypeHandler()); [EOL] }
public void testWithContentTypeHandler_NullHandler() { [EOL] Class<?> mapClass = Map.class; [EOL] JavaType keyType = SimpleType.constructUnsafe(String.class); [EOL] JavaType valueType = SimpleType.constructUnsafe(Object.class); [EOL] MapType mapType = MapType.construct(mapClass, keyType, valueType); [EOL] MapType newMapType = mapType.withContentTypeHandler(null); [EOL] assertNotNull(newMapType); [EOL] assertNull(newMapType.getContentTypeHandler()); [EOL] }
public void testToString() { [EOL] MapType mapType = new MapType( [EOL] HashMap.class, [EOL] SimpleType.constructUnsafe(String.class), [EOL] SimpleType.constructUnsafe(Integer.class) [EOL] ); [EOL] String expectedToString = "[map type; class java.util.HashMap, class java.lang.String -> class java.lang.Integer]"; [EOL] assertEquals(expectedToString, mapType.toString()); [EOL] }
public void testBeanPropertyWriterWithField() { [EOL] BeanPropertyDefinition propDef = mock(BeanPropertyDefinition.class); [EOL] AnnotatedMember member = mock(AnnotatedField.class); [EOL] Annotations contextAnnotations = mock(Annotations.class); [EOL] JavaType declaredType = mock(JavaType.class); [EOL] JsonSerializer<?> ser = null; [EOL] TypeSerializer typeSer = mock(TypeSerializer.class); [EOL] JavaType serType = mock(JavaType.class); [EOL] boolean suppressNulls = true; [EOL] Object suppressableValue = new Object(); [EOL] when(propDef.getName()).thenReturn("testName"); [EOL] when(propDef.getWrapperName()).thenReturn(null); [EOL] when(propDef.isRequired()).thenReturn(false); [EOL] when(propDef.findViews()).thenReturn(null); [EOL] when(member.getMember()).thenReturn(Field.class); [EOL] BeanPropertyWriter writer = new BeanPropertyWriter(propDef, member, contextAnnotations, declaredType, ser, typeSer, serType, suppressNulls, suppressableValue); [EOL] assertNotNull(writer); [EOL] assertEquals("testName", writer.getName()); [EOL] assertNull(writer.getWrapperName()); [EOL] assertFalse(writer.isRequired()); [EOL] assertNull(writer.getViews()); [EOL] assertNull(writer.getSerializer()); [EOL] assertNotNull(writer.getTypeSerializer()); [EOL] assertTrue(writer.willSuppressNulls()); [EOL] assertEquals(suppressableValue, writer.getSuppressableValue()); [EOL] assertNull(writer.getAccessorMethod()); [EOL] assertNotNull(writer.getField()); [EOL] }
public void testBeanPropertyWriterWithMethod() { [EOL] BeanPropertyDefinition propDef = mock(BeanPropertyDefinition.class); [EOL] AnnotatedMember member = mock(AnnotatedMethod.class); [EOL] Annotations contextAnnotations = mock(Annotations.class); [EOL] JavaType declaredType = mock(JavaType.class); [EOL] JsonSerializer<?> ser = mock(JsonSerializer.class); [EOL] TypeSerializer typeSer = mock(TypeSerializer.class); [EOL] JavaType serType = mock(JavaType.class); [EOL] boolean suppressNulls = false; [EOL] Object suppressableValue = null; [EOL] when(propDef.getName()).thenReturn("testName"); [EOL] when(propDef.getWrapperName()).thenReturn(new SerializedString("wrapperName")); [EOL] when(propDef.isRequired()).thenReturn(true); [EOL] when(propDef.findViews()).thenReturn(new Class<?>[]{View.class}); [EOL] when(member.getMember()).thenReturn(Method.class); [EOL] BeanPropertyWriter writer = new BeanPropertyWriter(propDef, member, contextAnnotations, declaredType, ser, typeSer, serType, suppressNulls, suppressableValue); [EOL] assertNotNull(writer); [EOL] assertEquals("testName", writer.getName()); [EOL] assertEquals("wrapperName", writer.getWrapperName().getValue()); [EOL] assertTrue(writer.isRequired()); [EOL] assertNotNull(writer.getViews()); [EOL] assertNotNull(writer.getSerializer()); [EOL] assertNotNull(writer.getTypeSerializer()); [EOL] assertFalse(writer.willSuppressNulls()); [EOL] assertNull(writer.getSuppressableValue()); [EOL] assertNotNull(writer.getAccessorMethod()); [EOL] assertNull(writer.getField()); [EOL] }
public void testBeanPropertyWriterWithInvalidMember() { [EOL] BeanPropertyDefinition propDef = mock(BeanPropertyDefinition.class); [EOL] AnnotatedMember member = mock(AnnotatedMember.class); [EOL] Annotations contextAnnotations = mock(Annotations.class); [EOL] JavaType declaredType = mock(JavaType.class); [EOL] JsonSerializer<?> ser = mock(JsonSerializer.class); [EOL] TypeSerializer typeSer = mock(TypeSerializer.class); [EOL] JavaType serType = mock(JavaType.class); [EOL] boolean suppressNulls = true; [EOL] Object suppressableValue = new Object(); [EOL] when(propDef.getName()).thenReturn("testName"); [EOL] when(member.getMember()).thenReturn(Object.class); [EOL] Exception exception = assertThrows(IllegalArgumentException.class, () -> { [EOL] new BeanPropertyWriter(propDef, member, contextAnnotations, declaredType, ser, typeSer, serType, suppressNulls, suppressableValue); [EOL] }); [EOL] String expectedMessage = "Can not pass member of type " + member.getClass().getName(); [EOL] String actualMessage = exception.getMessage(); [EOL] assertTrue(actualMessage.contains(expectedMessage)); [EOL] }
protected BeanPropertyWriter(BeanPropertyWriter base) { [EOL] this(base, base._name); [EOL] }
public void testBeanPropertyWriterCopyConstructor() { [EOL] SerializedString name = new SerializedString("testName"); [EOL] BeanPropertyWriter base = new BeanPropertyWriter(); [EOL] base.setWrapperName(new SerializedString("wrapperName")); [EOL] base.setMember(new Member() { /* Member implementation */ }); [EOL] base.setContextAnnotations(new AnnotationMap()); [EOL] base.setDeclaredType(new JavaType() { /* JavaType implementation */ }); [EOL] base.setAccessorMethod(new AnnotatedMethod() { /* AnnotatedMethod implementation */ }); [EOL] base.setField(new Field() { /* Field implementation */ }); [EOL] base.setSerializer(new JsonSerializer<Object>() { /* JsonSerializer implementation */ }); [EOL] base.setNullSerializer(new JsonSerializer<Object>() { /* JsonSerializer implementation */ }); [EOL] base.setInternalSettings(new HashMap<Object, Object>()); [EOL] base.setCfgSerializationType(new JavaType() { /* JavaType implementation */ }); [EOL] base.setDynamicSerializers(new PropertySerializerMap() { /* PropertySerializerMap implementation */ }); [EOL] base.setSuppressNulls(true); [EOL] base.setSuppressableValue(new Object()); [EOL] base.setIncludeInViews(new Class<?>[] { Object.class }); [EOL] base.setTypeSerializer(new TypeSerializer() { /* TypeSerializer implementation */ }); [EOL] base.setNonTrivialBaseType(new JavaType() { /* JavaType implementation */ }); [EOL] base.setRequired(true); [EOL] BeanPropertyWriter copy = new BeanPropertyWriter(base, name); [EOL] assertEquals(name, copy.getName()); [EOL] assertEquals(base.getWrapperName(), copy.getWrapperName()); [EOL] assertEquals(base.getMember(), copy.getMember()); [EOL] assertEquals(base.getContextAnnotations(), copy.getContextAnnotations()); [EOL] assertEquals(base.getDeclaredType(), copy.getDeclaredType()); [EOL] assertEquals(base.getAccessorMethod(), copy.getAccessorMethod()); [EOL] assertEquals(base.getField(), copy.getField()); [EOL] assertEquals(base.getSerializer(), copy.getSerializer()); [EOL] assertEquals(base.getNullSerializer(), copy.getNullSerializer()); [EOL] assertNotNull(copy.getInternalSettings()); [EOL] assertEquals(base.getCfgSerializationType(), copy.getCfgSerializationType()); [EOL] assertEquals(base.getDynamicSerializers(), copy.getDynamicSerializers()); [EOL] assertEquals(base.isSuppressNulls(), copy.isSuppressNulls()); [EOL] assertEquals(base.getSuppressableValue(), copy.getSuppressableValue()); [EOL] assertEquals(base.getIncludeInViews(), copy.getIncludeInViews()); [EOL] assertEquals(base.getTypeSerializer(), copy.getTypeSerializer()); [EOL] assertEquals(base.getNonTrivialBaseType(), copy.getNonTrivialBaseType()); [EOL] assertEquals(base.isRequired(), copy.isRequired()); [EOL] }
public void testAssignSerializerWithNull() { [EOL] YourClass instance = new YourClass(); [EOL] JsonSerializer<Object> serializer = null; [EOL] instance.assignSerializer(serializer); [EOL] }
public void testAssignSerializerWithNonNull() { [EOL] YourClass instance = new YourClass(); [EOL] JsonSerializer<Object> serializer = new YourCustomJsonSerializer(); [EOL] instance.assignSerializer(serializer); [EOL] }
public void testAssignSerializerWhenAlreadySet() { [EOL] YourClass instance = new YourClass(); [EOL] JsonSerializer<Object> firstSerializer = new YourCustomJsonSerializer(); [EOL] JsonSerializer<Object> secondSerializer = new YourCustomJsonSerializer(); [EOL] instance.assignSerializer(firstSerializer); [EOL] try { [EOL] instance.assignSerializer(secondSerializer); [EOL] fail("Expected an IllegalStateException to be thrown"); [EOL] } catch (IllegalStateException e) { [EOL] assertEquals("Can not override serializer", e.getMessage()); [EOL] } [EOL] }
public void testAssignNullSerializerWithNull() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] JsonSerializer<Object> nullSer = null; [EOL] mapper.getSerializerProvider().assignNullSerializer(nullSer); [EOL] assertNull(mapper.getSerializerProvider().getDefaultNullKeySerializer()); [EOL] }
public void testAssignNullSerializerWithNonNull() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] JsonSerializer<Object> nullSer = new JsonSerializer<Object>() { [EOL] @Override [EOL] public void serialize(Object value, JsonGenerator gen, SerializerProvider serializers) throws IOException { [EOL] } [EOL] }; [EOL] mapper.getSerializerProvider().assignNullSerializer(nullSer); [EOL] assertEquals(nullSer, mapper.getSerializerProvider().getDefaultNullKeySerializer()); [EOL] }
public void testAssignNullSerializerWithNonNullThenNull() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] JsonSerializer<Object> nullSer1 = new JsonSerializer<Object>() { [EOL] @Override [EOL] public void serialize(Object value, JsonGenerator gen, SerializerProvider serializers) throws IOException { [EOL] } [EOL] }; [EOL] JsonSerializer<Object> nullSer2 = null; [EOL] mapper.getSerializerProvider().assignNullSerializer(nullSer1); [EOL] try { [EOL] mapper.getSerializerProvider().assignNullSerializer(nullSer2); [EOL] fail("Expected IllegalStateException"); [EOL] } catch (IllegalStateException e) { [EOL] } [EOL] }
public void testAssignNullSerializerWithNonNullTwice() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] JsonSerializer<Object> nullSer1 = new JsonSerializer<Object>() { [EOL] @Override [EOL] public void serialize(Object value, JsonGenerator gen, SerializerProvider serializers) throws IOException { [EOL] } [EOL] }; [EOL] JsonSerializer<Object> nullSer2 = new JsonSerializer<Object>() { [EOL] @Override [EOL] public void serialize(Object value, JsonGenerator gen, SerializerProvider serializers) throws IOException { [EOL] } [EOL] }; [EOL] mapper.getSerializerProvider().assignNullSerializer(nullSer1); [EOL] try { [EOL] mapper.getSerializerProvider().assignNullSerializer(nullSer2); [EOL] fail("Expected IllegalStateException"); [EOL] } catch (IllegalStateException e) { [EOL] } [EOL] }
public void testGetType() { [EOL] MyClass instance = new MyClass(); [EOL] JavaType expected = instance._declaredType; [EOL] JavaType actual = instance.getType(); [EOL] assertEquals(expected, actual); [EOL] }
public void testHasSerializerWhenSerializerIsNull() { [EOL] ObjectMapper objectMapper = new ObjectMapper(); [EOL] JsonSerializer<Object> serializer = objectMapper.getSerializerProvider().findNullValueSerializer(null, null); [EOL] boolean hasSerializer = serializer.hasSerializer(); [EOL] assertFalse(hasSerializer); [EOL] }
public void testHasSerializerWhenSerializerIsNotNull() { [EOL] ObjectMapper objectMapper = new ObjectMapper(); [EOL] SimpleModule module = new SimpleModule(); [EOL] module.addSerializer(new StdSerializer<Object>(Object.class) { [EOL] @Override [EOL] public void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException { [EOL] } [EOL] }); [EOL] objectMapper.registerModule(module); [EOL] JsonSerializer<Object> serializer = objectMapper.getSerializerProvider().findValueSerializer(Object.class, null); [EOL] boolean hasSerializer = serializer.hasSerializer(); [EOL] assertTrue(hasSerializer); [EOL] }
public void testHasNullSerializerWhenNull() { [EOL] JsonSerializer<Object> nullSerializer = null; [EOL] BeanPropertyWriter beanPropertyWriter = new BeanPropertyWriter(); [EOL] beanPropertyWriter.assignNullSerializer(nullSerializer); [EOL] assertFalse(beanPropertyWriter.hasNullSerializer()); [EOL] }
public void testHasNullSerializerWhenNotNull() { [EOL] JsonSerializer<Object> nullSerializer = new JsonSerializer<Object>() {}; [EOL] BeanPropertyWriter beanPropertyWriter = new BeanPropertyWriter(); [EOL] beanPropertyWriter.assignNullSerializer(nullSerializer); [EOL] assertTrue(beanPropertyWriter.hasNullSerializer()); [EOL] }
public void testWillSuppressNullsTrue() { [EOL] JsonInclude.Value includeValue = JsonInclude.Value.construct(JsonInclude.Include.ALWAYS, JsonInclude.Include.ALWAYS); [EOL] includeValue = includeValue.withSuppressNulls(true); [EOL] assertTrue(includeValue.willSuppressNulls()); [EOL] }
public void testWillSuppressNullsFalse() { [EOL] JsonInclude.Value includeValue = JsonInclude.Value.construct(JsonInclude.Include.ALWAYS, JsonInclude.Include.ALWAYS); [EOL] includeValue = includeValue.withSuppressNulls(false); [EOL] assertFalse(includeValue.willSuppressNulls()); [EOL] }
public void testGetSerializationType() { [EOL] SerializationConfig config = new SerializationConfig(); [EOL] JavaType expectedType = TypeFactory.defaultInstance().constructType(String.class); [EOL] config.setSerializationType(expectedType); [EOL] JavaType resultType = config.getSerializationType(); [EOL] assertSame("The serialization type should be the same as set", expectedType, resultType); [EOL] }
public void testGetGenericPropertyTypeWithAccessorMethod() { [EOL] MyBean bean = new MyBean(); [EOL] Method accessorMethod = bean.getClass().getMethod("getSomeProperty"); [EOL] Field field = null; // Assuming field is not relevant in this case [EOL] BeanProperty prop = new BeanProperty(accessorMethod, field); [EOL] Type result = prop.getGenericPropertyType(); [EOL] assertEquals(accessorMethod.getGenericReturnType(), result); [EOL] }
public void testGetGenericPropertyTypeWithField() { [EOL] MyBean bean = new MyBean(); [EOL] Method accessorMethod = null; // Assuming accessor method is not relevant in this case [EOL] Field field = bean.getClass().getDeclaredField("someField"); [EOL] BeanProperty prop = new BeanProperty(accessorMethod, field); [EOL] Type result = prop.getGenericPropertyType(); [EOL] assertEquals(field.getGenericType(), result); [EOL] }
public void testGetViewsWhenIncludeInViewsIsNull() { [EOL] TestClass instance = new TestClass(); // Replace 'TestClass' with the actual class name that contains 'getViews' [EOL] instance._includeInViews = null; // Assuming '_includeInViews' is accessible, otherwise use a setter or constructor [EOL] Class<?>[] result = instance.getViews(); [EOL] assertNull(result); [EOL] }
public void testGetViewsWhenIncludeInViewsIsNotNull() { [EOL] TestClass instance = new TestClass(); // Replace 'TestClass' with the actual class name that contains 'getViews' [EOL] instance._includeInViews = new Class<?>[] {String.class, Integer.class}; // Assuming '_includeInViews' is accessible [EOL] Class<?>[] result = instance.getViews(); [EOL] assertNotNull(result); [EOL] assertEquals(2, result.length); [EOL] assertEquals(String.class, result[0]); [EOL] assertEquals(Integer.class, result[1]); [EOL] }
public void testSerializeAsFieldWithNullValueAndNullSerializer() throws Exception { [EOL] Object bean = new Object(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] JsonSerializer<Object> nullSerializer = mock(JsonSerializer.class); [EOL] PropertyWriter propertyWriter = new PropertyWriter() { [EOL] @Override [EOL] public void serializeAsField(Object bean, JsonGenerator jgen, SerializerProvider prov) throws Exception { [EOL] this._nullSerializer = nullSerializer; [EOL] super.serializeAsField(bean, jgen, prov); [EOL] } [EOL] @Override [EOL] public Object get(Object bean) { [EOL] return null; [EOL] } [EOL] }; [EOL] propertyWriter.serializeAsField(bean, jgen, prov); [EOL] verify(jgen).writeFieldName(anyString()); [EOL] verify(nullSerializer).serialize(eq(null), eq(jgen), eq(prov)); [EOL] }
public void testSerializeAsFieldWithValueAndNoSerializer() throws Exception { [EOL] Object bean = new Object(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] JsonSerializer<Object> serializer = mock(JsonSerializer.class); [EOL] PropertySerializerMap map = mock(PropertySerializerMap.class); [EOL] PropertyWriter propertyWriter = new PropertyWriter() { [EOL] @Override [EOL] public void serializeAsField(Object bean, JsonGenerator jgen, SerializerProvider prov) throws Exception { [EOL] this._serializer = null; [EOL] this._dynamicSerializers = map; [EOL] super.serializeAsField(bean, jgen, prov); [EOL] } [EOL] @Override [EOL] public Object get(Object bean) { [EOL] return new Object(); [EOL] } [EOL] @Override [EOL] protected JsonSerializer<Object> _findAndAddDynamic(PropertySerializerMap map, Class<?> cls, SerializerProvider prov) { [EOL] return serializer; [EOL] } [EOL] }; [EOL] when(map.serializerFor(any(Class.class))).thenReturn(null); [EOL] propertyWriter.serializeAsField(bean, jgen, prov); [EOL] verify(jgen).writeFieldName(anyString()); [EOL] verify(serializer).serialize(any(), eq(jgen), eq(prov)); [EOL] }
public void testSerializeAsFieldWithSuppressableValue() throws Exception { [EOL] Object bean = new Object(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] JsonSerializer<Object> serializer = mock(JsonSerializer.class); [EOL] PropertyWriter propertyWriter = new PropertyWriter() { [EOL] @Override [EOL] public void serializeAsField(Object bean, JsonGenerator jgen, SerializerProvider prov) throws Exception { [EOL] this._suppressableValue = "suppress"; [EOL] this._serializer = serializer; [EOL] super.serializeAsField(bean, jgen, prov); [EOL] } [EOL] @Override [EOL] public Object get(Object bean) { [EOL] return "suppress"; [EOL] } [EOL] }; [EOL] propertyWriter.serializeAsField(bean, jgen, prov); [EOL] verify(jgen, never()).writeFieldName(anyString()); [EOL] verify(serializer, never()).serialize(any(), eq(jgen), eq(prov)); [EOL] }
public void testSerializeAsFieldWithSelfReference() throws Exception { [EOL] Object bean = new Object(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] JsonSerializer<Object> serializer = mock(JsonSerializer.class); [EOL] PropertyWriter propertyWriter = new PropertyWriter() { [EOL] @Override [EOL] public void serializeAsField(Object bean, JsonGenerator jgen, SerializerProvider prov) throws Exception { [EOL] this._serializer = serializer; [EOL] super.serializeAsField(bean, jgen, prov); [EOL] } [EOL] @Override [EOL] public Object get(Object bean) { [EOL] return bean; // self reference [EOL] } [EOL] @Override [EOL] protected void _handleSelfReference(Object bean, JsonSerializer<?> ser) { [EOL] } [EOL] }; [EOL] propertyWriter.serializeAsField(bean, jgen, prov); [EOL] verify(propertyWriter)._handleSelfReference(eq(bean), eq(serializer)); [EOL] verify(jgen).writeFieldName(anyString()); [EOL] verify(serializer).serialize(eq(bean), eq(jgen), eq(prov)); [EOL] }
public void testSerializeAsColumnWithNullValueAndNullSerializer() throws Exception { [EOL] Object bean = new Object(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] JsonSerializer<Object> nullSerializer = mock(JsonSerializer.class); [EOL] ColumnSerializer instance = new ColumnSerializer(); [EOL] instance.setNullSerializer(nullSerializer); [EOL] instance.serializeAsColumn(bean, jgen, prov); [EOL] verify(nullSerializer).serialize(null, jgen, prov); [EOL] verify(jgen, never()).writeNull(); [EOL] }
public void testSerializeAsColumnWithNullValueNoNullSerializer() throws Exception { [EOL] Object bean = new Object(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] ColumnSerializer instance = new ColumnSerializer(); [EOL] instance.serializeAsColumn(bean, jgen, prov); [EOL] verify(jgen).writeNull(); [EOL] }
public void testSerializeAsColumnWithValueAndSerializer() throws Exception { [EOL] Object bean = new Object(); [EOL] Object value = new Object(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] JsonSerializer<Object> serializer = mock(JsonSerializer.class); [EOL] ColumnSerializer instance = new ColumnSerializer(); [EOL] instance.setValue(value); [EOL] instance.setSerializer(serializer); [EOL] instance.serializeAsColumn(bean, jgen, prov); [EOL] verify(serializer).serialize(value, jgen, prov); [EOL] }
public void testSerializeAsColumnWithDynamicSerializer() throws Exception { [EOL] Object bean = new Object(); [EOL] Object value = new Object(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] PropertySerializerMap map = mock(PropertySerializerMap.class); [EOL] JsonSerializer<Object> dynamicSerializer = mock(JsonSerializer.class); [EOL] ColumnSerializer instance = new ColumnSerializer(); [EOL] instance.setValue(value); [EOL] instance.setDynamicSerializers(map); [EOL] when(map.serializerFor(any(Class.class))).thenReturn(dynamicSerializer); [EOL] instance.serializeAsColumn(bean, jgen, prov); [EOL] verify(map).serializerFor(value.getClass()); [EOL] verify(dynamicSerializer).serialize(value, jgen, prov); [EOL] }
public void testSerializeAsColumnWithSuppressableValue() throws Exception { [EOL] Object bean = new Object(); [EOL] Object value = new Object(); [EOL] Object suppressableValue = new Object(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] JsonSerializer<Object> serializer = mock(JsonSerializer.class); [EOL] ColumnSerializer instance = new ColumnSerializer(); [EOL] instance.setValue(value); [EOL] instance.setSerializer(serializer); [EOL] instance.setSuppressableValue(suppressableValue); [EOL] instance.serializeAsColumn(bean, jgen, prov); [EOL] verify(serializer, never()).serialize(any(), any(), any()); [EOL] }
public void testSerializeAsColumnWithTypeSerializer() throws Exception { [EOL] Object bean = new Object(); [EOL] Object value = new Object(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] JsonSerializer<Object> serializer = mock(JsonSerializer.class); [EOL] TypeSerializer typeSerializer = mock(TypeSerializer.class); [EOL] ColumnSerializer instance = new ColumnSerializer(); [EOL] instance.setValue(value); [EOL] instance.setSerializer(serializer); [EOL] instance.setTypeSerializer(typeSerializer); [EOL] instance.serializeAsColumn(bean, jgen, prov); [EOL] verify(serializer).serializeWithType(value, jgen, prov, typeSerializer); [EOL] }
public void testFindAndAddDynamicWithNonTrivialBaseType() throws JsonMappingException { [EOL] PropertySerializerMap map = new PropertySerializerMap.Empty(); [EOL] Class<?> type = String.class; [EOL] SerializerProvider provider = new DefaultSerializerProvider.Impl(); [EOL] provider.setConfig(new SerializationConfig(new ObjectMapper()._deserializationConfig.getBaseSettings())); [EOL] JavaType nonTrivialBaseType = provider.constructType(Object.class); [EOL] BeanPropertyWriter writer = new BeanPropertyWriter(); [EOL] writer.assignType(nonTrivialBaseType); [EOL] JsonSerializer<Object> serializer = writer._findAndAddDynamic(map, type, provider); [EOL] assertNotNull(serializer); [EOL] assertNotSame(map, writer._dynamicSerializers); [EOL] }
public void testFindAndAddDynamicWithTrivialBaseType() throws JsonMappingException { [EOL] PropertySerializerMap map = new PropertySerializerMap.Empty(); [EOL] Class<?> type = String.class; [EOL] SerializerProvider provider = new DefaultSerializerProvider.Impl(); [EOL] provider.setConfig(new SerializationConfig(new ObjectMapper()._deserializationConfig.getBaseSettings())); [EOL] BeanPropertyWriter writer = new BeanPropertyWriter(); [EOL] JsonSerializer<Object> serializer = writer._findAndAddDynamic(map, type, provider); [EOL] assertNotNull(serializer); [EOL] assertSame(map, writer._dynamicSerializers); [EOL] }
public void testGetWithAccessorMethod() throws Exception { [EOL] Object bean = new Object(); [EOL] Method accessorMethod = bean.getClass().getMethod("toString"); [EOL] Field field = null; // Assuming field is not used in this test case [EOL] YourClass instance = new YourClass(accessorMethod, field); [EOL] Object result = instance.get(bean); [EOL] assertNotNull(result); [EOL] assertEquals(bean.toString(), result); [EOL] }
public void testGetWithField() throws Exception { [EOL] Object bean = new Object(); [EOL] Method accessorMethod = null; // Assuming accessorMethod is not used in this test case [EOL] Field field = bean.getClass().getDeclaredField("someField"); [EOL] field.setAccessible(true); [EOL] field.set(bean, "expectedValue"); [EOL] YourClass instance = new YourClass(accessorMethod, field); [EOL] Object result = instance.get(bean); [EOL] assertNotNull(result); [EOL] assertEquals("expectedValue", result); [EOL] }
public void testHandleSelfReferenceWithObjectId() throws JsonMappingException { [EOL] Object bean = new Object(); [EOL] JsonSerializer<?> ser = mock(JsonSerializer.class); [EOL] when(ser.usesObjectId()).thenReturn(true); [EOL] _handleSelfReference(bean, ser); [EOL] }
public void testHandleSelfReferenceWithoutObjectId() { [EOL] Object bean = new Object(); [EOL] JsonSerializer<?> ser = mock(JsonSerializer.class); [EOL] when(ser.usesObjectId()).thenReturn(false); [EOL] try { [EOL] _handleSelfReference(bean, ser); [EOL] fail("Expected JsonMappingException"); [EOL] } catch (JsonMappingException e) { [EOL] assertEquals("Direct self-reference leading to cycle", e.getMessage()); [EOL] } [EOL] }
public void testCreateContextualWithNullDeserializer() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] JavaType contentType = mock(JavaType.class); [EOL] when(_arrayType.getContentType()).thenReturn(contentType); [EOL] JsonDeserializer<?> expectedDeserializer = mock(JsonDeserializer.class); [EOL] when(ctxt.findContextualValueDeserializer(contentType, property)).thenReturn(expectedDeserializer); [EOL] JsonDeserializer<?> result = createContextual(ctxt, property); [EOL] assertNotNull(result); [EOL] assertSame(expectedDeserializer, result); [EOL] }
public void testCreateContextualWithNonNullDeserializer() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] JsonDeserializer<?> initialDeserializer = mock(JsonDeserializer.class); [EOL] _elementDeserializer = initialDeserializer; [EOL] JsonDeserializer<?> contextualDeserializer = mock(JsonDeserializer.class); [EOL] when(initialDeserializer.createContextual(ctxt, property)).thenReturn(contextualDeserializer); [EOL] JsonDeserializer<?> result = createContextual(ctxt, property); [EOL] assertNotNull(result); [EOL] assertSame(contextualDeserializer, result); [EOL] }
public void testCreateContextualWithTypeDeserializer() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] TypeDeserializer typeDeserializer = mock(TypeDeserializer.class); [EOL] _elementTypeDeserializer = typeDeserializer; [EOL] TypeDeserializer propertyTypeDeserializer = mock(TypeDeserializer.class); [EOL] when(typeDeserializer.forProperty(property)).thenReturn(propertyTypeDeserializer); [EOL] JsonDeserializer<?> expectedDeserializer = mock(JsonDeserializer.class); [EOL] when(ctxt.findContextualValueDeserializer(any(JavaType.class), eq(property))).thenReturn(expectedDeserializer); [EOL] JsonDeserializer<?> result = createContextual(ctxt, property); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeWithNonArrayToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.isExpectedStartArrayToken()).thenReturn(false); [EOL] Object[] result = deserialize(jp, ctxt); [EOL] }
public void testDeserializeWithEmptyArray() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.isExpectedStartArrayToken()).thenReturn(true); [EOL] when(jp.nextToken()).thenReturn(JsonToken.END_ARRAY); [EOL] Object[] result = deserialize(jp, ctxt); [EOL] assertNotNull(result); [EOL] assertEquals(0, result.length); [EOL] }
public void testDeserializeWithNullValue() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.isExpectedStartArrayToken()).thenReturn(true); [EOL] when(jp.nextToken()).thenReturn(JsonToken.VALUE_NULL).thenReturn(JsonToken.END_ARRAY); [EOL] Object[] result = deserialize(jp, ctxt); [EOL] assertNotNull(result); [EOL] assertEquals(1, result.length); [EOL] assertNull(result[0]); [EOL] }
public void testDeserializeWithTypeDeserializer() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] TypeDeserializer typeDeser = mock(TypeDeserializer.class); [EOL] JsonDeserializer<Object> elementDeserializer = mock(JsonDeserializer.class); [EOL] when(jp.isExpectedStartArrayToken()).thenReturn(true); [EOL] when(jp.nextToken()).thenReturn(JsonToken.VALUE_STRING).thenReturn(JsonToken.END_ARRAY); [EOL] when(ctxt.leaseObjectBuffer()).thenReturn(new ObjectBuffer()); [EOL] when(elementDeserializer.deserializeWithType(jp, ctxt, typeDeser)).thenReturn("deserializedValue"); [EOL] Object[] result = deserialize(jp, ctxt); [EOL] assertNotNull(result); [EOL] assertEquals(1, result.length); [EOL] assertEquals("deserializedValue", result[0]); [EOL] }
public void testDeserializeWithoutTypeDeserializer() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JsonDeserializer<Object> elementDeserializer = mock(JsonDeserializer.class); [EOL] when(jp.isExpectedStartArrayToken()).thenReturn(true); [EOL] when(jp.nextToken()).thenReturn(JsonToken.VALUE_STRING).thenReturn(JsonToken.END_ARRAY); [EOL] when(ctxt.leaseObjectBuffer()).thenReturn(new ObjectBuffer()); [EOL] when(elementDeserializer.deserialize(jp, ctxt)).thenReturn("deserializedValue"); [EOL] Object[] result = deserialize(jp, ctxt); [EOL] assertNotNull(result); [EOL] assertEquals(1, result.length); [EOL] assertEquals("deserializedValue", result[0]); [EOL] }
public void testDeserializeWithExpansion() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JsonDeserializer<Object> elementDeserializer = mock(JsonDeserializer.class); [EOL] when(jp.isExpectedStartArrayToken()).thenReturn(true); [EOL] when(jp.nextToken()).thenReturn(JsonToken.VALUE_STRING).thenReturn(JsonToken.VALUE_STRING).thenReturn(JsonToken.END_ARRAY); [EOL] when(ctxt.leaseObjectBuffer()).thenReturn(new ObjectBuffer()); [EOL] when(elementDeserializer.deserialize(jp, ctxt)).thenReturn("deserializedValue1", "deserializedValue2"); [EOL] Object[] result = deserialize(jp, ctxt); [EOL] assertNotNull(result); [EOL] assertEquals(2, result.length); [EOL] assertEquals("deserializedValue1", result[0]); [EOL] assertEquals("deserializedValue2", result[1]); [EOL] }
public void testDeserializeTyped() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.isExpectedStartArrayToken()).thenReturn(true); [EOL] when(jp.nextToken()).thenReturn(JsonToken.END_ARRAY); [EOL] Object[] result = deserialize(jp, ctxt); [EOL] assertNotNull(result); [EOL] }
public void testHandleNonArrayWithEmptyStringAndAcceptEmptyStringAsNullObject() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn(""); [EOL] when(ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)).thenReturn(true); [EOL] Object[] result = handleNonArray(jp, ctxt); [EOL] assertNull(result); [EOL] }
public void testHandleNonArrayWithAcceptSingleValueAsArrayDisabled() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY)).thenReturn(false); [EOL] try { [EOL] handleNonArray(jp, ctxt); [EOL] fail("Expected JsonMappingException"); [EOL] } catch (JsonMappingException e) { [EOL] } [EOL] }
public void testHandleNonArrayWithSingleValueAndAcceptSingleValueAsArrayEnabled() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NULL); [EOL] when(ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY)).thenReturn(true); [EOL] Object[] result = handleNonArray(jp, ctxt); [EOL] assertNotNull(result); [EOL] assertEquals(1, result.length); [EOL] assertNull(result[0]); [EOL] }
public void testHandleNonArrayWithCustomDeserializer() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JsonDeserializer<Object> elementDeserializer = mock(JsonDeserializer.class); [EOL] TypeDeserializer elementTypeDeserializer = mock(TypeDeserializer.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY)).thenReturn(true); [EOL] when(_elementDeserializer).thenReturn(elementDeserializer); [EOL] when(_elementTypeDeserializer).thenReturn(elementTypeDeserializer); [EOL] when(elementDeserializer.deserializeWithType(jp, ctxt, elementTypeDeserializer)).thenReturn("deserializedValue"); [EOL] Object[] result = handleNonArray(jp, ctxt); [EOL] assertNotNull(result); [EOL] assertEquals(1, result.length); [EOL] assertEquals("deserializedValue", result[0]); [EOL] }
public void testNopInstance() { [EOL] AnnotationIntrospector result = JacksonAnnotationIntrospector.nopInstance(); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof NopAnnotationIntrospector); [EOL] }
public String[] findPropertiesToIgnore(Annotated ac) { [EOL] return null; [EOL] }
public void testIsIgnorableTypeWithNullAnnotatedClass() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] Boolean result = mapper.getSerializationConfig().isIgnorableType(null); [EOL] assertNull(result); [EOL] }
public Object findFilterId(AnnotatedClass ac) { [EOL] return null; [EOL] }
public void testFindAutoDetectVisibilityWithNonNullChecker() { [EOL] AnnotatedClass ac = mock(AnnotatedClass.class); [EOL] VisibilityChecker<?> checker = mock(VisibilityChecker.class); [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] VisibilityChecker<?> result = mapper.getSerializationConfig().findAutoDetectVisibility(ac, checker); [EOL] assertSame(checker, result); [EOL] }
public void testFindAutoDetectVisibilityWithNullChecker() { [EOL] AnnotatedClass ac = mock(AnnotatedClass.class); [EOL] VisibilityChecker<?> result = new ObjectMapper().getSerializationConfig().findAutoDetectVisibility(ac, null); [EOL] assertNull(result); [EOL] }
public void testFindTypeResolverWithNullConfig() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] AnnotatedClass ac = AnnotatedClass.constructWithoutSuperTypes(Object.class, mapper.getDeserializationConfig().getAnnotationIntrospector()); [EOL] JavaType baseType = mapper.constructType(Object.class); [EOL] TypeResolverBuilder<?> result = mapper.getDeserializationConfig().findTypeResolver(null, ac, baseType); [EOL] assertNull(result); [EOL] }
public void testFindTypeResolverWithNonNullConfig() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] AnnotatedClass ac = AnnotatedClass.constructWithoutSuperTypes(Object.class, mapper.getDeserializationConfig().getAnnotationIntrospector()); [EOL] JavaType baseType = mapper.constructType(Object.class); [EOL] MapperConfig<?> config = mapper.getDeserializationConfig(); [EOL] TypeResolverBuilder<?> result = config.findTypeResolver(config, ac, baseType); [EOL] assertNull(result); [EOL] }
public void testFindPropertyTypeResolver_ReturnsNull() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] AnnotatedMember annotatedMember = _mockAnnotatedMember(); [EOL] JavaType baseType = _mockJavaType(); [EOL] TypeResolverBuilder<?> result = mapper.getSerializationConfig().findPropertyTypeResolver(null, annotatedMember, baseType); [EOL] assertNull(result); [EOL] }
public NameTransformer findUnwrappingNameTransformer(AnnotatedMember member) { [EOL] return null; [EOL] }
public Object findInjectableValueId(AnnotatedMember m) { [EOL] return null; [EOL] }
public void testFindFormatWithAnnotatedMember() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] AnnotatedMember annotatedMember = mock(AnnotatedMember.class); [EOL] Object result = mapper.getSerializationConfig().findFormat(annotatedMember); [EOL] assertNotNull(result); [EOL] }
public void testFindFormatWithNonAnnotatedMember() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] Annotated memberOrClass = mock(Annotated.class); [EOL] Object result = mapper.getSerializationConfig().findFormat(memberOrClass); [EOL] assertNull(result); [EOL] }
public Object findSerializer(Annotated am) { [EOL] return null; [EOL] }
public void testFindSerializationInclusionWithNullDefValue() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] AnnotatedClass ac = new AnnotatedClass(Object.class); [EOL] JsonInclude.Include result = mapper.getSerializationConfig().findSerializationInclusion(ac, null); [EOL] assertNull(result); [EOL] }
public void testFindSerializationInclusionWithNonNullDefValue() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] AnnotatedClass ac = new AnnotatedClass(Object.class); [EOL] JsonInclude.Include nonNullDefValue = JsonInclude.Include.NON_NULL; [EOL] JsonInclude.Include result = mapper.getSerializationConfig().findSerializationInclusion(ac, nonNullDefValue); [EOL] assertEquals(JsonInclude.Include.NON_NULL, result); [EOL] }
public Class<?> findSerializationType(Annotated a) { [EOL] return null; [EOL] }
public void testFindSerializationTypingReturnsNull() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] AnnotatedClass ac = AnnotatedClass.constructWithoutSuperTypes(Object.class, mapper.getSerializationConfig()); [EOL] JsonSerialize.Typing result = mapper.getSerializationConfig().introspect(ac).findSerializationTyping(); [EOL] assertNull(result); [EOL] }
public Object findSerializationConverterTest() { [EOL] Annotated annotated = mock(Annotated.class); [EOL] Object result = findSerializationConverter(annotated); [EOL] assertNull(result); [EOL] }
public void testFindDeserializerWithNullAnnotated() { [EOL] MyClass myClass = new MyClass(); [EOL] Object result = myClass.findDeserializer(null); [EOL] assertNull(result); [EOL] }
public Object findKeyDeserializer(Annotated am) { [EOL] return null; [EOL] }
public Object findContentDeserializer(Annotated am) { [EOL] return null; [EOL] }
public Class<?> findDeserializationType(Annotated am, JavaType baseType) { [EOL] return null; [EOL] }
public Class<?> findDeserializationKeyType(Annotated am, JavaType baseKeyType) { [EOL] return null; [EOL] }
public Class<?> findDeserializationContentType(Annotated am, JavaType baseContentType) { [EOL] return null; [EOL] }
public Object findDeserializationConverterTest() { [EOL] Annotated annotated = mock(Annotated.class); [EOL] Object result = findDeserializationConverter(annotated); [EOL] assertNull(result); [EOL] }
public Object findValueInstantiator(AnnotatedClass ac) { [EOL] return null; [EOL] }
public Class<?> findPOJOBuilder(AnnotatedClass ac) { [EOL] return null; [EOL] }
public void testFindNameForDeserializationWithAnnotatedField() { [EOL] AnnotatedField annotatedField = createMockAnnotatedFieldWithName("fieldName"); [EOL] PropertyName result = findNameForDeserialization(annotatedField); [EOL] assertNotNull(result); [EOL] assertEquals("fieldName", result.getSimpleName()); [EOL] }
public void testFindNameForDeserializationWithAnnotatedMethod() { [EOL] AnnotatedMethod annotatedMethod = createMockAnnotatedMethodWithName("methodName"); [EOL] PropertyName result = findNameForDeserialization(annotatedMethod); [EOL] assertNotNull(result); [EOL] assertEquals("methodName", result.getSimpleName()); [EOL] }
public void testFindNameForDeserializationWithAnnotatedParameter() { [EOL] AnnotatedParameter annotatedParameter = createMockAnnotatedParameterWithName("paramName"); [EOL] PropertyName result = findNameForDeserialization(annotatedParameter); [EOL] assertNotNull(result); [EOL] assertEquals("paramName", result.getSimpleName()); [EOL] }
public void testFindNameForDeserializationWithEmptyName() { [EOL] AnnotatedField annotatedField = createMockAnnotatedFieldWithName(""); [EOL] PropertyName result = findNameForDeserialization(annotatedField); [EOL] assertEquals(PropertyName.USE_DEFAULT, result); [EOL] }
public void testFindNameForDeserializationWithNull() { [EOL] Annotated notAnnotated = createMockNotAnnotated(); [EOL] PropertyName result = findNameForDeserialization(notAnnotated); [EOL] assertNull(result); [EOL] }
public void testFindDeserializationNameWithNullParameter() { [EOL] AnnotatedParameter param = null; [EOL] String result = findDeserializationName(param); [EOL] assertNull(result); [EOL] }
public boolean hasCreatorAnnotation(Annotated a) { [EOL] return false; [EOL] }
public void testDeserializeIfNaturalWithNullParser() throws IOException, JsonProcessingException { [EOL] JsonParser jp = null; [EOL] DeserializationContext ctxt = null; [EOL] JavaType baseType = null; [EOL] Object result = JacksonDatabindUtils.deserializeIfNatural(jp, ctxt, baseType); [EOL] assertNull(result); [EOL] }
public void testDeserializeIfNaturalWithNonNullParserAndBaseType() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JavaType baseType = mock(JavaType.class); [EOL] Class<?> rawClass = String.class; [EOL] when(baseType.getRawClass()).thenReturn(rawClass); [EOL] Object result = JacksonDatabindUtils.deserializeIfNatural(jp, ctxt, baseType); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeIfNaturalWithNullToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(null); [EOL] Object result = YourClass.deserializeIfNatural(jp, ctxt, String.class); [EOL] assertNull(result); [EOL] }
public void testDeserializeIfNaturalWithString() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("test"); [EOL] Object result = YourClass.deserializeIfNatural(jp, ctxt, String.class); [EOL] assertEquals("test", result); [EOL] }
public void testDeserializeIfNaturalWithInteger() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); [EOL] when(jp.getIntValue()).thenReturn(123); [EOL] Object result = YourClass.deserializeIfNatural(jp, ctxt, Integer.class); [EOL] assertEquals(123, result); [EOL] }
public void testDeserializeIfNaturalWithDouble() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_FLOAT); [EOL] when(jp.getDoubleValue()).thenReturn(45.67); [EOL] Object result = YourClass.deserializeIfNatural(jp, ctxt, Double.class); [EOL] assertEquals(45.67, result); [EOL] }
public void testDeserializeIfNaturalWithBooleanTrue() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_TRUE); [EOL] Object result = YourClass.deserializeIfNatural(jp, ctxt, Boolean.class); [EOL] assertEquals(Boolean.TRUE, result); [EOL] }
public void testDeserializeIfNaturalWithBooleanFalse() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_FALSE); [EOL] Object result = YourClass.deserializeIfNatural(jp, ctxt, Boolean.class); [EOL] assertEquals(Boolean.FALSE, result); [EOL] }
public void testDeserializeIfNaturalWithUnsupportedType() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] Object result = YourClass.deserializeIfNatural(jp, ctxt, Object.class); [EOL] assertNull(result); [EOL] }
public void testAnnotatedMethodMapConstructor() { [EOL] AnnotatedMethodMap annotatedMethodMap = new AnnotatedMethodMap(); [EOL] assertNotNull(annotatedMethodMap); [EOL] }
public void testAddWithNullMethods() { [EOL] AnnotatedMethodCollector collector = new AnnotatedMethodCollector(null, null); [EOL] AnnotatedMethod am = new AnnotatedMethod(null, null, null, null); [EOL] collector.add(am); [EOL] assertNotNull(collector._methods); [EOL] assertTrue(collector._methods.containsKey(new MemberKey(am.getAnnotated()))); [EOL] assertEquals(am, collector._methods.get(new MemberKey(am.getAnnotated()))); [EOL] }
public void testAddWithNonNullMethods() { [EOL] AnnotatedMethodCollector collector = new AnnotatedMethodCollector(null, null); [EOL] collector._methods = new LinkedHashMap<MemberKey, AnnotatedMethod>(); [EOL] AnnotatedMethod am = new AnnotatedMethod(null, null, null, null); [EOL] collector.add(am); [EOL] assertTrue(collector._methods.containsKey(new MemberKey(am.getAnnotated()))); [EOL] assertEquals(am, collector._methods.get(new MemberKey(am.getAnnotated()))); [EOL] }
public void testRemoveWithNonNullMethods() { [EOL] AnnotatedMethodMap methodMap = new AnnotatedMethodMap(); [EOL] Method method = Object.class.getMethod("toString"); [EOL] methodMap.add(new AnnotatedMethod(null, method, null, null)); [EOL] AnnotatedMethod removed = methodMap.remove(method); [EOL] assertNotNull(removed); [EOL] assertEquals(method, removed.getAnnotated()); [EOL] }
public void testRemoveWithNullMethods() { [EOL] AnnotatedMethodMap methodMap = new AnnotatedMethodMap(); [EOL] Method method = Object.class.getMethod("toString"); [EOL] AnnotatedMethod removed = methodMap.remove(method); [EOL] assertNull(removed); [EOL] }
public void testIsEmptyWhenMethodsIsNull() { [EOL] ExampleClass example = new ExampleClass(); [EOL] example._methods = null; [EOL] boolean result = example.isEmpty(); [EOL] assert result == true; [EOL] }
public void testIsEmptyWhenMethodsIsEmpty() { [EOL] ExampleClass example = new ExampleClass(); [EOL] example._methods = new ArrayList<>(); [EOL] boolean result = example.isEmpty(); [EOL] assert result == true; [EOL] }
public void testIsEmptyWhenMethodsIsNotEmpty() { [EOL] ExampleClass example = new ExampleClass(); [EOL] example._methods = new ArrayList<>(); [EOL] example._methods.add("dummyMethod"); [EOL] boolean result = example.isEmpty(); [EOL] assert result == false; [EOL] }
public void testFindWithNullMethods() { [EOL] _methods = null; [EOL] AnnotatedMethod result = instance.find("someMethod", new Class<?>[]{String.class, Integer.class}); [EOL] assertNull(result); [EOL] }
public void testFindWithEmptyMethods() { [EOL] _methods = new HashMap<MemberKey, AnnotatedMethod>(); [EOL] AnnotatedMethod result = instance.find("someMethod", new Class<?>[]{String.class, Integer.class}); [EOL] assertNull(result); [EOL] }
public void testFindWithNonEmptyMethods() { [EOL] _methods = new HashMap<MemberKey, AnnotatedMethod>(); [EOL] MemberKey key = new MemberKey("someMethod", new Class<?>[]{String.class, Integer.class}); [EOL] AnnotatedMethod expectedMethod = new AnnotatedMethod(); // Assuming a constructor or a method to create an instance [EOL] _methods.put(key, expectedMethod); [EOL] AnnotatedMethod result = instance.find("someMethod", new Class<?>[]{String.class, Integer.class}); [EOL] assertEquals(expectedMethod, result); [EOL] }
public void testFindWithNullMethods() { [EOL] instanceUnderTest._methods = null; // Simulate _methods being null [EOL] AnnotatedMethod result = instanceUnderTest.find(method); [EOL] assertNull(result); // Assert that the result should be null when _methods is null [EOL] }
public void testFindWithNonNullMethodsAndMethodNotPresent() { [EOL] instanceUnderTest._methods = new HashMap<MemberKey, AnnotatedMethod>(); // Simulate _methods being not null but empty [EOL] AnnotatedMethod result = instanceUnderTest.find(method); [EOL] assertNull(result); // Assert that the result should be null when the method is not present in the map [EOL] }
public void testFindWithNonNullMethodsAndMethodPresent() { [EOL] MemberKey key = new MemberKey(method); [EOL] instanceUnderTest._methods = new HashMap<MemberKey, AnnotatedMethod>(); // Simulate _methods being not null [EOL] instanceUnderTest._methods.put(key, annotatedMethod); // Add a method to the map [EOL] AnnotatedMethod result = instanceUnderTest.find(method); [EOL] assertSame(annotatedMethod, result); // Assert that the result should be the same object that was put in the map [EOL] }
public void testIteratorWithNonNullMethods() { [EOL] instance.setMethods(someNonNullMethodsMap); [EOL] Iterator<AnnotatedMethod> iterator = instance.iterator(); [EOL] assertNotNull(iterator); [EOL] assertTrue(iterator.hasNext()); [EOL] assertEquals(someNonNullMethodsMap.values().iterator().next(), iterator.next()); [EOL] }
public void testIteratorWithNullMethods() { [EOL] instance.setMethods(null); [EOL] Iterator<AnnotatedMethod> iterator = instance.iterator(); [EOL] assertNotNull(iterator); [EOL] assertFalse(iterator.hasNext()); [EOL] }
protected DOMDeserializer(Class<T> cls) { [EOL] super(cls); [EOL] }
public void testParseValidXML() { [EOL] String validXML = "<root><child>value</child></root>"; [EOL] Document result = null; [EOL] try { [EOL] result = parse(validXML); [EOL] } catch (IllegalArgumentException e) { [EOL] fail("Parsing failed for valid XML input: " + e.getMessage()); [EOL] } [EOL] assertNotNull("Resulting Document should not be null for valid XML input", result); [EOL] assertEquals("Root element should be 'root'", "root", result.getDocumentElement().getNodeName()); [EOL] }
public void testParseInvalidXML() { [EOL] String invalidXML = "<root><child>value</child>"; // missing closing tag [EOL] try { [EOL] parse(invalidXML); [EOL] fail("IllegalArgumentException expected for invalid XML input"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertTrue("Exception message should contain 'Failed to parse JSON String as XML'", e.getMessage().contains("Failed to parse JSON String as XML")); [EOL] } [EOL] }
public void testDocumentDeserializerConstructor() { [EOL] DocumentDeserializer deserializer = new DocumentDeserializer(); [EOL] assertNotNull(deserializer); [EOL] }
public void testDeserializeWithValidDocument() throws IllegalArgumentException { [EOL] String validDocumentString = "<root><element>value</element></root>"; [EOL] Document result = _deserialize(validDocumentString, new DeserializationContext()); [EOL] assertNotNull(result); [EOL] assertEquals("root", result.getDocumentElement().getNodeName()); [EOL] }
public void testDeserializeWithInvalidDocument() { [EOL] String invalidDocumentString = "<root><element>value</element>"; [EOL] try { [EOL] Document result = _deserialize(invalidDocumentString, new DeserializationContext()); [EOL] fail("Expected IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testCreateContextualWithNullProperty() { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] JsonSerializer<?> result = createContextual(provider, null); [EOL] assertNotNull(result); [EOL] }
public void testCreateContextualWithNonNullPropertyAndMember() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] AnnotatedMember member = mock(AnnotatedMember.class); [EOL] AnnotationIntrospector introspector = mock(AnnotationIntrospector.class); [EOL] when(property.getMember()).thenReturn(member); [EOL] when(provider.getAnnotationIntrospector()).thenReturn(introspector); [EOL] when(introspector.findKeySerializer(member)).thenReturn(null); [EOL] when(introspector.findContentSerializer(member)).thenReturn(null); [EOL] JsonSerializer<?> result = createContextual(provider, property); [EOL] assertNotNull(result); [EOL] }
public void testCreateContextualWithNonNullPropertyAndMemberWithKeySerializer() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] AnnotatedMember member = mock(AnnotatedMember.class); [EOL] AnnotationIntrospector introspector = mock(AnnotationIntrospector.class); [EOL] JsonSerializer<?> keySerializer = mock(JsonSerializer.class); [EOL] when(property.getMember()).thenReturn(member); [EOL] when(provider.getAnnotationIntrospector()).thenReturn(introspector); [EOL] when(introspector.findKeySerializer(member)).thenReturn(keySerializer); [EOL] when(provider.serializerInstance(member, keySerializer)).thenReturn(keySerializer); [EOL] when(introspector.findContentSerializer(member)).thenReturn(null); [EOL] JsonSerializer<?> result = createContextual(provider, property); [EOL] assertNotNull(result); [EOL] }
public void testCreateContextualWithNonNullPropertyAndMemberWithContentSerializer() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] AnnotatedMember member = mock(AnnotatedMember.class); [EOL] AnnotationIntrospector introspector = mock(AnnotationIntrospector.class); [EOL] JsonSerializer<?> contentSerializer = mock(JsonSerializer.class); [EOL] when(property.getMember()).thenReturn(member); [EOL] when(provider.getAnnotationIntrospector()).thenReturn(introspector); [EOL] when(introspector.findKeySerializer(member)).thenReturn(null); [EOL] when(introspector.findContentSerializer(member)).thenReturn(contentSerializer); [EOL] when(provider.serializerInstance(member, contentSerializer)).thenReturn(contentSerializer); [EOL] JsonSerializer<?> result = createContextual(provider, property); [EOL] assertNotNull(result); [EOL] }
public void testCreateContextualWithNonNullPropertyAndMemberWithIgnoredEntries() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] AnnotatedMember member = mock(AnnotatedMember.class); [EOL] AnnotationIntrospector introspector = mock(AnnotationIntrospector.class); [EOL] String[] toIgnore = new String[]{"propToIgnore"}; [EOL] when(property.getMember()).thenReturn(member); [EOL] when(provider.getAnnotationIntrospector()).thenReturn(introspector); [EOL] when(introspector.findKeySerializer(member)).thenReturn(null); [EOL] when(introspector.findContentSerializer(member)).thenReturn(null); [EOL] when(introspector.findPropertiesToIgnore(member)).thenReturn(toIgnore); [EOL] JsonSerializer<?> result = createContextual(provider, property); [EOL] assertNotNull(result); [EOL] }
public void testMapDeserializerWithStandardKey() { [EOL] JavaType mapType = TypeFactory.defaultInstance().constructMapType(Map.class, String.class, Object.class); [EOL] ValueInstantiator valueInstantiator = new StdValueInstantiator(null, mapType); [EOL] KeyDeserializer keyDeser = new StdKeyDeserializer.StringKD(); [EOL] JsonDeserializer<Object> valueDeser = new StdDeserializer.StringDeserializer(); [EOL] TypeDeserializer valueTypeDeser = null; // Assuming TypeDeserializer is not needed for this test [EOL] MapDeserializer mapDeserializer = new MapDeserializer(mapType, valueInstantiator, keyDeser, valueDeser, valueTypeDeser); [EOL] assertNotNull(mapDeserializer); [EOL] assertEquals(mapType, mapDeserializer._mapType); [EOL] assertEquals(keyDeser, mapDeserializer._keyDeserializer); [EOL] assertEquals(valueDeser, mapDeserializer._valueDeserializer); [EOL] assertNull(mapDeserializer._valueTypeDeserializer); [EOL] assertEquals(valueInstantiator, mapDeserializer._valueInstantiator); [EOL] assertTrue(mapDeserializer._hasDefaultCreator); [EOL] assertNull(mapDeserializer._delegateDeserializer); [EOL] assertNull(mapDeserializer._propertyBasedCreator); [EOL] assertTrue(mapDeserializer._standardStringKey); [EOL] }
public void testMapDeserializerWithNonStandardKey() { [EOL] JavaType mapType = TypeFactory.defaultInstance().constructMapType(Map.class, Integer.class, Object.class); [EOL] ValueInstantiator valueInstantiator = new StdValueInstantiator(null, mapType); [EOL] KeyDeserializer keyDeser = new StdKeyDeserializer.IntKD(); [EOL] JsonDeserializer<Object> valueDeser = new StdDeserializer.StringDeserializer(); [EOL] TypeDeserializer valueTypeDeser = null; // Assuming TypeDeserializer is not needed for this test [EOL] MapDeserializer mapDeserializer = new MapDeserializer(mapType, valueInstantiator, keyDeser, valueDeser, valueTypeDeser); [EOL] assertNotNull(mapDeserializer); [EOL] assertEquals(mapType, mapDeserializer._mapType); [EOL] assertEquals(keyDeser, mapDeserializer._keyDeserializer); [EOL] assertEquals(valueDeser, mapDeserializer._valueDeserializer); [EOL] assertNull(mapDeserializer._valueTypeDeserializer); [EOL] assertEquals(valueInstantiator, mapDeserializer._valueInstantiator); [EOL] assertTrue(mapDeserializer._hasDefaultCreator); [EOL] assertNull(mapDeserializer._delegateDeserializer); [EOL] assertNull(mapDeserializer._propertyBasedCreator); [EOL] assertFalse(mapDeserializer._standardStringKey); [EOL] }
public void testIsStdKeyDeserWithNullKeyDeserializer() { [EOL] JavaType mapType = mock(JavaType.class); [EOL] boolean result = _isStdKeyDeser(mapType, null); [EOL] assertTrue(result); [EOL] }
public void testIsStdKeyDeserWithNullKeyType() { [EOL] JavaType mapType = mock(JavaType.class); [EOL] when(mapType.getKeyType()).thenReturn(null); [EOL] KeyDeserializer keyDeser = mock(KeyDeserializer.class); [EOL] boolean result = _isStdKeyDeser(mapType, keyDeser); [EOL] assertTrue(result); [EOL] }
public void testIsStdKeyDeserWithStringClass() { [EOL] JavaType mapType = mock(JavaType.class); [EOL] JavaType keyType = mock(JavaType.class); [EOL] when(mapType.getKeyType()).thenReturn(keyType); [EOL] when(keyType.getRawClass()).thenReturn(String.class); [EOL] KeyDeserializer keyDeser = mock(KeyDeserializer.class); [EOL] when(isDefaultKeyDeserializer(keyDeser)).thenReturn(true); [EOL] boolean result = _isStdKeyDeser(mapType, keyDeser); [EOL] assertTrue(result); [EOL] }
public void testIsStdKeyDeserWithObjectClass() { [EOL] JavaType mapType = mock(JavaType.class); [EOL] JavaType keyType = mock(JavaType.class); [EOL] when(mapType.getKeyType()).thenReturn(keyType); [EOL] when(keyType.getRawClass()).thenReturn(Object.class); [EOL] KeyDeserializer keyDeser = mock(KeyDeserializer.class); [EOL] when(isDefaultKeyDeserializer(keyDeser)).thenReturn(true); [EOL] boolean result = _isStdKeyDeser(mapType, keyDeser); [EOL] assertTrue(result); [EOL] }
public void testIsStdKeyDeserWithNonStdKeyClass() { [EOL] JavaType mapType = mock(JavaType.class); [EOL] JavaType keyType = mock(JavaType.class); [EOL] when(mapType.getKeyType()).thenReturn(keyType); [EOL] when(keyType.getRawClass()).thenReturn(Integer.class); [EOL] KeyDeserializer keyDeser = mock(KeyDeserializer.class); [EOL] when(isDefaultKeyDeserializer(keyDeser)).thenReturn(false); [EOL] boolean result = _isStdKeyDeser(mapType, keyDeser); [EOL] assertFalse(result); [EOL] }
public void testSetIgnorablePropertiesWithNull() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] mapper.setIgnorableProperties(null); [EOL] assertNull(mapper.getIgnorableProperties()); [EOL] }
public void testSetIgnorablePropertiesWithEmptyArray() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] mapper.setIgnorableProperties(new String[0]); [EOL] assertNull(mapper.getIgnorableProperties()); [EOL] }
public void testSetIgnorablePropertiesWithNonEmptyArray() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] String[] ignorable = new String[]{"prop1", "prop2"}; [EOL] mapper.setIgnorableProperties(ignorable); [EOL] assertNotNull(mapper.getIgnorableProperties()); [EOL] assertTrue(mapper.getIgnorableProperties().contains("prop1")); [EOL] assertTrue(mapper.getIgnorableProperties().contains("prop2")); [EOL] }
public void testCreateContextualWithNullKeyDeserializerAndValueDeserializer() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] JavaType keyType = mock(JavaType.class); [EOL] JavaType contentType = mock(JavaType.class); [EOL] KeyDeserializer keyDeserializer = null; [EOL] JsonDeserializer<?> valueDeserializer = null; [EOL] TypeDeserializer valueTypeDeserializer = null; [EOL] HashSet<String> ignorableProperties = null; [EOL] when(_mapType.getKeyType()).thenReturn(keyType); [EOL] when(_mapType.getContentType()).thenReturn(contentType); [EOL] when(ctxt.findKeyDeserializer(keyType, property)).thenReturn(keyDeserializer); [EOL] when(ctxt.findContextualValueDeserializer(contentType, property)).thenReturn(valueDeserializer); [EOL] JsonDeserializer<?> result = createContextual(ctxt, property); [EOL] verify(ctxt).findKeyDeserializer(keyType, property); [EOL] verify(ctxt).findContextualValueDeserializer(contentType, property); [EOL] assertNotNull(result); [EOL] }
public void testCreateContextualWithNonNullKeyDeserializerAndValueDeserializer() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] KeyDeserializer keyDeserializer = mock(KeyDeserializer.class); [EOL] JsonDeserializer<?> valueDeserializer = mock(JsonDeserializer.class); [EOL] TypeDeserializer valueTypeDeserializer = mock(TypeDeserializer.class); [EOL] HashSet<String> ignorableProperties = new HashSet<>(); [EOL] ignorableProperties.add("ignoreMe"); [EOL] when(_mapType.getKeyType()).thenReturn(mock(JavaType.class)); [EOL] when(_mapType.getContentType()).thenReturn(mock(JavaType.class)); [EOL] when(ctxt.findKeyDeserializer(any(), any())).thenReturn(keyDeserializer); [EOL] when(ctxt.findContextualValueDeserializer(any(), any())).thenReturn(valueDeserializer); [EOL] when(valueTypeDeserializer.forProperty(property)).thenReturn(valueTypeDeserializer); [EOL] when(ctxt.getAnnotationIntrospector()).thenReturn(mock(AnnotationIntrospector.class)); [EOL] when(ctxt.getAnnotationIntrospector().findPropertiesToIgnore(any())).thenReturn(new String[]{"ignoreMe"}); [EOL] JsonDeserializer<?> result = createContextual(ctxt, property); [EOL] verify(ctxt, never()).findKeyDeserializer(any(), any()); [EOL] verify(ctxt, never()).findContextualValueDeserializer(any(), any()); [EOL] verify(valueTypeDeserializer).forProperty(property); [EOL] assertNotNull(result); [EOL] }
public void testCreateContextualWithKeyDeserializerNeedingContextualization() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] ContextualKeyDeserializer keyDeserializer = mock(ContextualKeyDeserializer.class); [EOL] JsonDeserializer<?> valueDeserializer = mock(JsonDeserializer.class); [EOL] TypeDeserializer valueTypeDeserializer = null; [EOL] HashSet<String> ignorableProperties = null; [EOL] when(_mapType.getKeyType()).thenReturn(mock(JavaType.class)); [EOL] when(_mapType.getContentType()).thenReturn(mock(JavaType.class)); [EOL] when(keyDeserializer.createContextual(ctxt, property)).thenReturn(keyDeserializer); [EOL] when(ctxt.findContextualValueDeserializer(any(), any())).thenReturn(valueDeserializer); [EOL] _keyDeserializer = keyDeserializer; [EOL] JsonDeserializer<?> result = createContextual(ctxt, property); [EOL] verify(keyDeserializer).createContextual(ctxt, property); [EOL] verify(ctxt, never()).findKeyDeserializer(any(), any()); [EOL] assertNotNull(result); [EOL] }
public void testCreateContextualWithValueDeserializerNeedingContextualization() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] KeyDeserializer keyDeserializer = mock(KeyDeserializer.class); [EOL] ContextualDeserializer valueDeserializer = mock(ContextualDeserializer.class); [EOL] TypeDeserializer valueTypeDeserializer = null; [EOL] HashSet<String> ignorableProperties = null; [EOL] when(_mapType.getKeyType()).thenReturn(mock(JavaType.class)); [EOL] when(_mapType.getContentType()).thenReturn(mock(JavaType.class)); [EOL] when(valueDeserializer.createContextual(ctxt, property)).thenReturn(valueDeserializer); [EOL] _valueDeserializer = valueDeserializer; [EOL] JsonDeserializer<?> result = createContextual(ctxt, property); [EOL] verify(valueDeserializer).createContextual(ctxt, property); [EOL] verify(ctxt, never()).findContextualValueDeserializer(any(), any()); [EOL] assertNotNull(result); [EOL] }
public void testCreateContextualWithPropertyIgnorals() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] KeyDeserializer keyDeserializer = mock(KeyDeserializer.class); [EOL] JsonDeserializer<?> valueDeserializer = mock(JsonDeserializer.class); [EOL] TypeDeserializer valueTypeDeserializer = null; [EOL] HashSet<String> ignorableProperties = null; [EOL] when(_mapType.getKeyType()).thenReturn(mock(JavaType.class)); [EOL] when(_mapType.getContentType()).thenReturn(mock(JavaType.class)); [EOL] when(ctxt.getAnnotationIntrospector()).thenReturn(mock(AnnotationIntrospector.class)); [EOL] when(ctxt.getAnnotationIntrospector().findPropertiesToIgnore(any())).thenReturn(new String[]{"ignoreMe"}); [EOL] JsonDeserializer<?> result = createContextual(ctxt, property); [EOL] verify(ctxt.getAnnotationIntrospector()).findPropertiesToIgnore(any()); [EOL] assertNotNull(result); [EOL] }
public void testGetContentDeserializer() { [EOL] MyCustomDeserializer deserializer = new MyCustomDeserializer(); [EOL] assertNull(deserializer.getContentDeserializer()); [EOL] }
public void testGetContentDeserializerWithValueDeserializerSet() { [EOL] JsonDeserializer<Object> valueDeserializer = mock(JsonDeserializer.class); [EOL] MyCustomDeserializer deserializer = new MyCustomDeserializer(); [EOL] deserializer._valueDeserializer = valueDeserializer; [EOL] assertSame(valueDeserializer, deserializer.getContentDeserializer()); [EOL] }
public void testDeserializeWithPropertyBasedCreator() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(_propertyBasedCreator).thenReturn(true); [EOL] Map<Object, Object> result = deserialize(jp, ctxt); [EOL] }
public void testDeserializeWithDelegateDeserializer() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(_propertyBasedCreator).thenReturn(null); [EOL] when(_delegateDeserializer).thenReturn(mock(JsonDeserializer.class)); [EOL] when(_valueInstantiator.createUsingDelegate(eq(ctxt), any())).thenReturn(new HashMap<>()); [EOL] Map<Object, Object> result = deserialize(jp, ctxt); [EOL] }
public void testDeserializeWithoutDefaultCreator() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(_propertyBasedCreator).thenReturn(null); [EOL] when(_delegateDeserializer).thenReturn(null); [EOL] when(_hasDefaultCreator).thenReturn(false); [EOL] assertThrows(JsonMappingException.class, () -> deserialize(jp, ctxt)); [EOL] }
public void testDeserializeFromStringValue() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(_propertyBasedCreator).thenReturn(null); [EOL] when(_delegateDeserializer).thenReturn(null); [EOL] when(_hasDefaultCreator).thenReturn(true); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("string value"); [EOL] when(_valueInstantiator.createFromString(eq(ctxt), anyString())).thenReturn(new HashMap<>()); [EOL] Map<Object, Object> result = deserialize(jp, ctxt); [EOL] }
public void testDeserializeWithStartObjectToken() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(_propertyBasedCreator).thenReturn(null); [EOL] when(_delegateDeserializer).thenReturn(null); [EOL] when(_hasDefaultCreator).thenReturn(true); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); [EOL] when(_standardStringKey).thenReturn(true); [EOL] when(_valueInstantiator.createUsingDefault(ctxt)).thenReturn(new HashMap<>()); [EOL] Map<Object, Object> result = deserialize(jp, ctxt); [EOL] }
public void testDeserializeWithFieldNameToken() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(_propertyBasedCreator).thenReturn(null); [EOL] when(_delegateDeserializer).thenReturn(null); [EOL] when(_hasDefaultCreator).thenReturn(true); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.FIELD_NAME); [EOL] when(_standardStringKey).thenReturn(false); [EOL] when(_valueInstantiator.createUsingDefault(ctxt)).thenReturn(new HashMap<>()); [EOL] Map<Object, Object> result = deserialize(jp, ctxt); [EOL] }
public void testGetMapClass() { [EOL] Class<?> mapClass = instance.getMapClass(); [EOL] assertTrue(mapClass.equals(Map.class)); [EOL] }
public void testReadAndBindStringMapWithStartObjectToken() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Map<Object, Object> result = new HashMap<>(); [EOL] JsonDeserializer<Object> valueDes = mock(JsonDeserializer.class); [EOL] TypeDeserializer typeDeser = null; [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); [EOL] when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME).thenReturn(JsonToken.VALUE_STRING).thenReturn(null); [EOL] when(jp.getCurrentName()).thenReturn("key"); [EOL] when(valueDes.deserialize(jp, ctxt)).thenReturn("value"); [EOL] _readAndBindStringMap(jp, ctxt, result); [EOL] assertEquals("value", result.get("key")); [EOL] }
public void testReadAndBindStringMapWithIgnorableProperty() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Map<Object, Object> result = new HashMap<>(); [EOL] JsonDeserializer<Object> valueDes = mock(JsonDeserializer.class); [EOL] Set<String> ignorableProperties = new HashSet<>(); [EOL] ignorableProperties.add("key"); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.FIELD_NAME); [EOL] when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME).thenReturn(null); [EOL] when(jp.getCurrentName()).thenReturn("key"); [EOL] _ignorableProperties = ignorableProperties; [EOL] _readAndBindStringMap(jp, ctxt, result); [EOL] assertTrue(result.isEmpty()); [EOL] }
public void testReadAndBindStringMapWithValueNullToken() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Map<Object, Object> result = new HashMap<>(); [EOL] JsonDeserializer<Object> valueDes = mock(JsonDeserializer.class); [EOL] TypeDeserializer typeDeser = null; [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.FIELD_NAME); [EOL] when(jp.nextToken()).thenReturn(JsonToken.VALUE_NULL).thenReturn(null); [EOL] when(jp.getCurrentName()).thenReturn("key"); [EOL] _readAndBindStringMap(jp, ctxt, result); [EOL] assertNull(result.get("key")); [EOL] }
public void testReadAndBindStringMapWithCustomDeserializer() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Map<Object, Object> result = new HashMap<>(); [EOL] JsonDeserializer<Object> valueDes = mock(JsonDeserializer.class); [EOL] TypeDeserializer typeDeser = mock(TypeDeserializer.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.FIELD_NAME); [EOL] when(jp.nextToken()).thenReturn(JsonToken.VALUE_STRING).thenReturn(null); [EOL] when(jp.getCurrentName()).thenReturn("key"); [EOL] when(valueDes.deserializeWithType(jp, ctxt, typeDeser)).thenReturn("customValue"); [EOL] _valueDeserializer = valueDes; [EOL] _valueTypeDeserializer = typeDeser; [EOL] _readAndBindStringMap(jp, ctxt, result); [EOL] assertEquals("customValue", result.get("key")); [EOL] }
public T getNullValueTest() { [EOL] assertNull(getNullValue()); [EOL] }
public T getEmptyValueTest() { [EOL] TestClass testInstance = new TestClass(); [EOL] T expectedValue = testInstance.getNullValue(); [EOL] T actualValue = testInstance.getEmptyValue(); [EOL] assertEquals(expectedValue, actualValue); [EOL] }
public void testFindSerializerWithJavaxXml() { [EOL] SerializationConfig config = new SerializationConfig(); [EOL] JavaType type = new JavaType(PACKAGE_PREFIX_JAVAX_XML + ".DummyClass"); [EOL] BeanDescription beanDesc = new BeanDescription(type); [EOL] JsonSerializer<?> serializer = findSerializer(config, type, beanDesc); [EOL] assertNotNull(serializer); [EOL] assertTrue(serializer instanceof MyJavaxXmlSerializer); [EOL] }
public void testFindSerializerWithDomNode() { [EOL] SerializationConfig config = new SerializationConfig(); [EOL] JavaType type = new JavaType(CLASS_NAME_DOM_NODE); [EOL] BeanDescription beanDesc = new BeanDescription(type); [EOL] JsonSerializer<?> serializer = findSerializer(config, type, beanDesc); [EOL] assertNotNull(serializer); [EOL] assertTrue(serializer instanceof MyDomNodeSerializer); [EOL] }
public void testFindSerializerWithUnknownType() { [EOL] SerializationConfig config = new SerializationConfig(); [EOL] JavaType type = new JavaType("com.unknown.Type"); [EOL] BeanDescription beanDesc = new BeanDescription(type); [EOL] JsonSerializer<?> serializer = findSerializer(config, type, beanDesc); [EOL] assertNull(serializer); [EOL] }
public void testFindDeserializerWithJavaxXml() throws JsonMappingException { [EOL] JavaType type = mock(JavaType.class); [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] when(type.getRawClass()).thenReturn((Class) SomeJavaxXmlClass.class); [EOL] JsonDeserializer<?> deserializer = findDeserializer(type, config, beanDesc); [EOL] assertNotNull(deserializer); [EOL] } [EOL] public void testFindDeserializerWithDomDocument() throws JsonMappingException { [EOL] JavaType type = mock(JavaType.class); [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] when(type.getRawClass()).thenReturn((Class) DomDocumentClass.class); [EOL] JsonDeserializer<?> deserializer = findDeserializer(type, config, beanDesc); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof DomDocumentDeserializer); [EOL] } [EOL] public void testFindDeserializerWithDomNode() throws JsonMappingException { [EOL] JavaType type = mock(JavaType.class); [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] when(type.getRawClass()).thenReturn((Class) DomNodeClass.class); [EOL] JsonDeserializer<?> deserializer = findDeserializer(type, config, beanDesc); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof DomNodeDeserializer); [EOL] } [EOL] public void testFindDeserializerWithUnknownType() throws JsonMappingException { [EOL] JavaType type = mock(JavaType.class); [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] when(type.getRawClass()).thenReturn((Class) UnknownClass.class); [EOL] JsonDeserializer<?> deserializer = findDeserializer(type, config, beanDesc); [EOL] assertNull(deserializer); [EOL] }
public void testFindDeserializerWithNullFactory() throws JsonMappingException { [EOL] JavaType type = mock(JavaType.class); [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] when(type.getRawClass()).thenReturn((Class) SomeJavaxXmlClass.class); [EOL] when(instantiate(DESERIALIZERS_FOR_JAVAX_XML)).thenReturn(null); [EOL] JsonDeserializer<?> deserializer = findDeserializer(type, config, beanDesc); [EOL] assertNull(deserializer); [EOL] }
public void testDoesImplementWithExactClassMatch() { [EOL] boolean result = doesImplement(String.class, "java.lang.String"); [EOL] assertTrue(result); [EOL] }
public void testDoesImplementWithSuperclassMatch() { [EOL] boolean result = doesImplement(Integer.class, "java.lang.Number"); [EOL] assertTrue(result); [EOL] }
public void testDoesImplementWithInterfaceMatch() { [EOL] boolean result = doesImplement(ArrayList.class, "java.util.List"); [EOL] assertTrue(result); [EOL] }
public void testDoesImplementWithNoMatch() { [EOL] boolean result = doesImplement(Object.class, "java.util.List"); [EOL] assertFalse(result); [EOL] }
public void testDoesImplementWithNullClass() { [EOL] boolean result = doesImplement(null, "java.util.List"); [EOL] assertFalse(result); [EOL] }
public void testHasInterfaceDirectMatch() { [EOL] boolean result = hasInterface(SomeClassWithDesiredInterface.class, "com.example.DesiredInterface"); [EOL] assertTrue(result); [EOL] }
public void testHasInterfaceNoMatch() { [EOL] boolean result = hasInterface(SomeClassWithoutDesiredInterface.class, "com.example.DesiredInterface"); [EOL] assertFalse(result); [EOL] }
public void testHasInterfaceIndirectMatch() { [EOL] boolean result = hasInterface(SomeClassWithInheritedInterface.class, "com.example.DesiredInterface"); [EOL] assertTrue(result); [EOL] }
public void testHasInterfaceWithNullType() { [EOL] boolean result = hasInterface(null, "com.example.DesiredInterface"); [EOL] assertFalse(result); [EOL] }
public void testHasInterfaceWithEmptyInterfaceName() { [EOL] boolean result = hasInterface(SomeClassWithDesiredInterface.class, ""); [EOL] assertFalse(result); [EOL] }
public void testHasInterfaceStartingWith_DirectMatch() { [EOL] boolean result = hasInterfaceStartingWith(SampleInterface.class, "Sample"); [EOL] assertTrue(result); [EOL] } [EOL] public void testHasInterfaceStartingWith_NoMatch() { [EOL] boolean result = hasInterfaceStartingWith(SampleClass.class, "NonExistentPrefix"); [EOL] assertFalse(result); [EOL] } [EOL] public void testHasInterfaceStartingWith_IndirectMatch() { [EOL] boolean result = hasInterfaceStartingWith(SampleClassImplementingInterface.class, "Sample"); [EOL] assertTrue(result); [EOL] } [EOL] public void testHasInterfaceStartingWith_NullType() { [EOL] boolean result = hasInterfaceStartingWith(null, "Sample"); [EOL] assertFalse(result); [EOL] } [EOL] public void testHasInterfaceStartingWith_EmptyPrefix() { [EOL] boolean result = hasInterfaceStartingWith(SampleInterface.class, ""); [EOL] assertTrue(result); [EOL] }
public static Std defaultInstance() { [EOL] return DEFAULT; [EOL] }
public void testStdWithAllVisibilityLevels() { [EOL] JsonAutoDetect ann = mock(JsonAutoDetect.class); [EOL] when(ann.getterVisibility()).thenReturn(JsonAutoDetect.Visibility.ANY); [EOL] when(ann.isGetterVisibility()).thenReturn(JsonAutoDetect.Visibility.NONE); [EOL] when(ann.setterVisibility()).thenReturn(JsonAutoDetect.Visibility.DEFAULT); [EOL] when(ann.creatorVisibility()).thenReturn(JsonAutoDetect.Visibility.PUBLIC_ONLY); [EOL] when(ann.fieldVisibility()).thenReturn(JsonAutoDetect.Visibility.PROTECTED_AND_PUBLIC); [EOL] Std std = new Std(ann); [EOL] assertEquals(JsonAutoDetect.Visibility.ANY, std._getterMinLevel); [EOL] assertEquals(JsonAutoDetect.Visibility.NONE, std._isGetterMinLevel); [EOL] assertEquals(JsonAutoDetect.Visibility.DEFAULT, std._setterMinLevel); [EOL] assertEquals(JsonAutoDetect.Visibility.PUBLIC_ONLY, std._creatorMinLevel); [EOL] assertEquals(JsonAutoDetect.Visibility.PROTECTED_AND_PUBLIC, std._fieldMinLevel); [EOL] }
public void testWithIsGetterVisibility_Default() { [EOL] Std std = new Std(Visibility.ANY, Visibility.ANY, Visibility.ANY, Visibility.ANY, Visibility.ANY); [EOL] Std result = std.withIsGetterVisibility(Visibility.DEFAULT); [EOL] assertSame("Expected same instance when passing DEFAULT visibility", std, result); [EOL] }
public void testWithIsGetterVisibility_NonDefault() { [EOL] Std std = new Std(Visibility.ANY, Visibility.ANY, Visibility.ANY, Visibility.ANY, Visibility.ANY); [EOL] Std result = std.withIsGetterVisibility(Visibility.NONE); [EOL] assertNotSame("Expected different instance when passing non-default visibility", std, result); [EOL] assertEquals("Expected NONE visibility for isGetter", Visibility.NONE, result.getIsGetterVisibility()); [EOL] }
public void testWithCreatorVisibility_DefaultVisibility() { [EOL] Std std = new Std(Visibility.ANY, Visibility.ANY, Visibility.ANY, Visibility.ANY, Visibility.ANY); [EOL] Std result = std.withCreatorVisibility(Visibility.DEFAULT); [EOL] assertNotSame(std, result); [EOL] assertEquals(Visibility.ANY, result.getCreatorVisibility()); [EOL] } [EOL] public void testWithCreatorVisibility_SameVisibility() { [EOL] Std std = new Std(Visibility.ANY, Visibility.ANY, Visibility.ANY, Visibility.PUBLIC, Visibility.ANY); [EOL] Std result = std.withCreatorVisibility(Visibility.PUBLIC); [EOL] assertSame(std, result); [EOL] } [EOL] public void testWithCreatorVisibility_DifferentVisibility() { [EOL] Std std = new Std(Visibility.ANY, Visibility.ANY, Visibility.ANY, Visibility.PUBLIC, Visibility.ANY); [EOL] Std result = std.withCreatorVisibility(Visibility.PROTECTED); [EOL] assertNotSame(std, result); [EOL] assertEquals(Visibility.PROTECTED, result.getCreatorVisibility()); [EOL] }

public void testIsCreatorVisibleWithPublicMember() { [EOL] VisibilityChecker.Std checker = new VisibilityChecker.Std(JsonAutoDetect.Visibility.PUBLIC_ONLY); [EOL] Member publicMember = PublicCreator.class.getMethods()[0]; [EOL] assertTrue(checker.isCreatorVisible(publicMember)); [EOL] }
public void testIsCreatorVisibleWithPrivateMember() { [EOL] VisibilityChecker.Std checker = new VisibilityChecker.Std(JsonAutoDetect.Visibility.PUBLIC_ONLY); [EOL] Member privateMember = PrivateCreator.class.getDeclaredMethods()[0]; [EOL] assertFalse(checker.isCreatorVisible(privateMember)); [EOL] }
public void testIsCreatorVisibleWithDifferentVisibilityLevels() { [EOL] VisibilityChecker.Std checkerNone = new VisibilityChecker.Std(JsonAutoDetect.Visibility.NONE); [EOL] VisibilityChecker.Std checkerAny = new VisibilityChecker.Std(JsonAutoDetect.Visibility.ANY); [EOL] Member member = AnyVisibilityCreator.class.getMethods()[0]; [EOL] assertFalse(checkerNone.isCreatorVisible(member)); [EOL] assertTrue(checkerAny.isCreatorVisible(member)); [EOL] }
public void testIsCreatorVisibleWithVisibleMember() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] AnnotatedMember member = new AnnotatedMethod(null, Object.class.getDeclaredMethods()[0], null, null); [EOL] VisibilityChecker<?> visibilityChecker = mapper.getSerializationConfig().getDefaultVisibilityChecker(); [EOL] assertTrue(visibilityChecker.isCreatorVisible(member)); [EOL] }
public void testIsCreatorVisibleWithInvisibleMember() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] AnnotatedMember member = new AnnotatedMethod(null, Object.class.getDeclaredMethods()[0], null, null); [EOL] VisibilityChecker<?> visibilityChecker = mapper.getSerializationConfig().withVisibility(PropertyAccessor.CREATOR, JsonAutoDetect.Visibility.NONE); [EOL] assertFalse(visibilityChecker.isCreatorVisible(member)); [EOL] }
public void testIsFieldVisibleWhenVisible() { [EOL] VisibilityChecker checker = mock(VisibilityChecker.class); [EOL] Field field = mock(Field.class); [EOL] when(checker.isVisible(field)).thenReturn(true); [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] mapper.setVisibility(checker); [EOL] assertTrue(mapper.isFieldVisible(field)); [EOL] }
public void testIsFieldVisibleWhenNotVisible() { [EOL] VisibilityChecker checker = mock(VisibilityChecker.class); [EOL] Field field = mock(Field.class); [EOL] when(checker.isVisible(field)).thenReturn(false); [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] mapper.setVisibility(checker); [EOL] assertFalse(mapper.isFieldVisible(field)); [EOL] }
public void testIsFieldVisibleWithVisibleField() { [EOL] AnnotatedField mockField = Mockito.mock(AnnotatedField.class); [EOL] Field javaField = String.class.getDeclaredFields()[0]; [EOL] Mockito.when(mockField.getAnnotated()).thenReturn(javaField); [EOL] boolean result = isFieldVisible(mockField); [EOL] assertTrue(result); [EOL] }
public void testIsFieldVisibleWithInvisibleField() { [EOL] AnnotatedField mockField = Mockito.mock(AnnotatedField.class); [EOL] Field javaField = String.class.getDeclaredFields()[0]; [EOL] Mockito.when(mockField.getAnnotated()).thenReturn(javaField); [EOL] Mockito.when(mockField.getModifiers()).thenReturn(Modifier.PRIVATE); // Assuming there's a visibility check [EOL] boolean result = isFieldVisible(mockField); [EOL] assertFalse(result); [EOL] }
public void testIsGetterVisible_WithVisibleGetter_ShouldReturnTrue() { [EOL] VisibilityChecker.Std visibilityChecker = new VisibilityChecker.Std(JsonAutoDetect.Visibility.ANY); [EOL] Method visibleGetter = MyClass.class.getMethod("getVisibleProperty"); [EOL] boolean result = visibilityChecker.isGetterVisible(visibleGetter); [EOL] assertTrue(result); [EOL] }
public void testIsGetterVisible_WithInvisibleGetter_ShouldReturnFalse() { [EOL] VisibilityChecker.Std visibilityChecker = new VisibilityChecker.Std(JsonAutoDetect.Visibility.NONE); [EOL] Method invisibleGetter = MyClass.class.getMethod("getInvisibleProperty"); [EOL] boolean result = visibilityChecker.isGetterVisible(invisibleGetter); [EOL] assertFalse(result); [EOL] }
public void testIsGetterVisibleWithVisibleGetter() { [EOL] VisibilityChecker<?> checker = VisibilityChecker.Std.defaultInstance(); [EOL] AnnotatedMethod mockAnnotatedMethod = Mockito.mock(AnnotatedMethod.class); [EOL] Method mockMethod = String.class.getMethod("toString"); [EOL] Mockito.when(mockAnnotatedMethod.getAnnotated()).thenReturn(mockMethod); [EOL] boolean result = checker.isGetterVisible(mockAnnotatedMethod); [EOL] assertTrue(result); [EOL] }
public void testIsGetterVisibleWithInvisibleGetter() { [EOL] VisibilityChecker<?> checker = VisibilityChecker.Std.defaultInstance().withGetterVisibility(JsonAutoDetect.Visibility.NONE); [EOL] AnnotatedMethod mockAnnotatedMethod = Mockito.mock(AnnotatedMethod.class); [EOL] Method mockMethod = String.class.getMethod("getBytes"); [EOL] Mockito.when(mockAnnotatedMethod.getAnnotated()).thenReturn(mockMethod); [EOL] boolean result = checker.isGetterVisible(mockAnnotatedMethod); [EOL] assertFalse(result); [EOL] }
public void testIsIsGetterVisible_VisibleMethod() { [EOL] VisibilityChecker.Std checker = new VisibilityChecker.Std(JsonAutoDetect.Visibility.PUBLIC_ONLY); [EOL] Method visibleMethod = MyClass.class.getMethod("publicMethod"); [EOL] boolean result = checker.isIsGetterVisible(visibleMethod); [EOL] assertTrue(result); [EOL] } [EOL] public void testIsIsGetterVisible_NonVisibleMethod() { [EOL] VisibilityChecker.Std checker = new VisibilityChecker.Std(JsonAutoDetect.Visibility.NONE); [EOL] Method nonVisibleMethod = MyClass.class.getMethod("privateMethod"); [EOL] boolean result = checker.isIsGetterVisible(nonVisibleMethod); [EOL] assertFalse(result); [EOL] }
public void testIsIsGetterVisible_ProtectedMethod() { [EOL] VisibilityChecker.Std checker = new VisibilityChecker.Std(JsonAutoDetect.Visibility.PROTECTED_AND_PUBLIC); [EOL] Method protectedMethod = MyClass.class.getMethod("protectedMethod"); [EOL] boolean result = checker.isIsGetterVisible(protectedMethod); [EOL] assertTrue(result); [EOL] }
public void testIsIsGetterVisible_WithVisibleIsGetter() { [EOL] VisibilityChecker<?> checker = VisibilityChecker.Std.defaultInstance(); [EOL] AnnotatedMethod mockAnnotatedMethod = Mockito.mock(AnnotatedMethod.class); [EOL] Method mockMethod = Mockito.mock(Method.class); [EOL] Mockito.when(mockAnnotatedMethod.getAnnotated()).thenReturn(mockMethod); [EOL] Mockito.when(mockMethod.getName()).thenReturn("isVisible"); [EOL] Mockito.when(mockMethod.getParameterTypes()).thenReturn(new Class<?>[0]); [EOL] Mockito.when(mockMethod.getModifiers()).thenReturn(Modifier.PUBLIC); [EOL] boolean result = checker.isIsGetterVisible(mockAnnotatedMethod); [EOL] assertTrue(result); [EOL] }
public void testIsIsGetterVisible_WithInvisibleIsGetter() { [EOL] VisibilityChecker<?> checker = VisibilityChecker.Std.defaultInstance(); [EOL] AnnotatedMethod mockAnnotatedMethod = Mockito.mock(AnnotatedMethod.class); [EOL] Method mockMethod = Mockito.mock(Method.class); [EOL] Mockito.when(mockAnnotatedMethod.getAnnotated()).thenReturn(mockMethod); [EOL] Mockito.when(mockMethod.getName()).thenReturn("isNotVisible"); [EOL] Mockito.when(mockMethod.getParameterTypes()).thenReturn(new Class<?>[0]); [EOL] Mockito.when(mockMethod.getModifiers()).thenReturn(Modifier.PRIVATE); [EOL] boolean result = checker.isIsGetterVisible(mockAnnotatedMethod); [EOL] assertFalse(result); [EOL] }
public void testIsSetterVisibleWithPublicMethod() { [EOL] VisibilityChecker<?> checker = VisibilityChecker.Std.defaultInstance(); [EOL] Method publicMethod = MyClass.class.getMethod("publicSetterMethod", String.class); [EOL] boolean result = checker.isSetterVisible(publicMethod); [EOL] assertTrue(result); [EOL] } [EOL] public void testIsSetterVisibleWithProtectedMethod() { [EOL] VisibilityChecker<?> checker = VisibilityChecker.Std.defaultInstance(); [EOL] Method protectedMethod = MyClass.class.getMethod("protectedSetterMethod", String.class); [EOL] boolean result = checker.isSetterVisible(protectedMethod); [EOL] assertFalse(result); [EOL] } [EOL] public void testIsSetterVisibleWithPrivateMethod() { [EOL] VisibilityChecker<?> checker = VisibilityChecker.Std.defaultInstance(); [EOL] Method privateMethod = MyClass.class.getMethod("privateSetterMethod", String.class); [EOL] boolean result = checker.isSetterVisible(privateMethod); [EOL] assertFalse(result); [EOL] } [EOL] public void testIsSetterVisibleWithDefaultMethod() { [EOL] VisibilityChecker<?> checker = VisibilityChecker.Std.defaultInstance(); [EOL] Method defaultMethod = MyClass.class.getMethod("defaultSetterMethod", String.class); [EOL] boolean result = checker.isSetterVisible(defaultMethod); [EOL] assertFalse(result); [EOL] }

public void testIsSetterVisibleWithVisibleSetter() { [EOL] VisibilityChecker<?> checker = VisibilityChecker.Std.defaultInstance(); [EOL] AnnotatedMethod mockAnnotatedMethod = Mockito.mock(AnnotatedMethod.class); [EOL] Method mockMethod = Mockito.mock(Method.class); [EOL] Mockito.when(mockAnnotatedMethod.getAnnotated()).thenReturn(mockMethod); [EOL] Mockito.when(mockMethod.isSynthetic()).thenReturn(false); [EOL] Mockito.when(mockMethod.getModifiers()).thenReturn(Modifier.PUBLIC); [EOL] boolean result = checker.isSetterVisible(mockAnnotatedMethod); [EOL] assertTrue(result); [EOL] }
public void testIsSetterVisibleWithInvisibleSetter() { [EOL] VisibilityChecker<?> checker = VisibilityChecker.Std.defaultInstance(); [EOL] AnnotatedMethod mockAnnotatedMethod = Mockito.mock(AnnotatedMethod.class); [EOL] Method mockMethod = Mockito.mock(Method.class); [EOL] Mockito.when(mockAnnotatedMethod.getAnnotated()).thenReturn(mockMethod); [EOL] Mockito.when(mockMethod.isSynthetic()).thenReturn(false); [EOL] Mockito.when(mockMethod.getModifiers()).thenReturn(Modifier.PRIVATE); [EOL] boolean result = checker.isSetterVisible(mockAnnotatedMethod); [EOL] assertFalse(result); [EOL] }
public void testFindValueInstantiatorWithJsonLocationClass() { [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] when(beanDesc.getBeanClass()).thenReturn(JsonLocation.class); [EOL] ValueInstantiator result = JacksonDatabindUtils.findValueInstantiator(config, beanDesc); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof JsonLocationInstantiator); [EOL] }
public void testFindValueInstantiatorWithNonJsonLocationClass() { [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] when(beanDesc.getBeanClass()).thenReturn(Object.class); [EOL] ValueInstantiator result = JacksonDatabindUtils.findValueInstantiator(config, beanDesc); [EOL] assertNull(result); [EOL] }
public void testCanCreateFromObjectWith() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] assertTrue(mapper.getDeserializationConfig().canCreateFromObjectWith()); [EOL] }
public void testGetFromObjectArguments() { [EOL] DeserializationConfig config = new DeserializationConfig(...); // Provide actual implementation [EOL] JavaType intType = config.constructType(Integer.TYPE); [EOL] JavaType longType = config.constructType(Long.TYPE); [EOL] CreatorProperty[] result = instance.getFromObjectArguments(config); [EOL] assertEquals("sourceRef", result[0].getName()); [EOL] assertEquals(Object.class, result[0].getType().getRawClass()); [EOL] assertEquals(0, result[0].getCreatorIndex()); [EOL] assertEquals("byteOffset", result[1].getName()); [EOL] assertEquals(Long.TYPE, result[1].getType().getRawClass()); [EOL] assertEquals(1, result[1].getCreatorIndex()); [EOL] assertEquals("charOffset", result[2].getName()); [EOL] assertEquals(Long.TYPE, result[2].getType().getRawClass()); [EOL] assertEquals(2, result[2].getCreatorIndex()); [EOL] assertEquals("lineNr", result[3].getName()); [EOL] assertEquals(Integer.TYPE, result[3].getType().getRawClass()); [EOL] assertEquals(3, result[3].getCreatorIndex()); [EOL] assertEquals("columnNr", result[4].getName()); [EOL] assertEquals(Integer.TYPE, result[4].getType().getRawClass()); [EOL] assertEquals(4, result[4].getCreatorIndex()); [EOL] }
public void testCreatorPropWithNonNullNameAndType() { [EOL] String name = "testName"; [EOL] JavaType type = new SimpleType(String.class); [EOL] int index = 1; [EOL] CreatorProperty result = creatorProp(name, type, index); [EOL] assertNotNull(result); [EOL] assertEquals(name, result.getName()); [EOL] assertEquals(type, result.getType()); [EOL] assertEquals(index, result.getCreatorIndex()); [EOL] assertTrue(result.isExplicitlyIncluded()); [EOL] }
public void testCreatorPropWithNullName() { [EOL] String name = null; [EOL] JavaType type = new SimpleType(String.class); [EOL] int index = 1; [EOL] CreatorProperty result = creatorProp(name, type, index); [EOL] assertNotNull(result); [EOL] assertNull(result.getName()); [EOL] assertEquals(type, result.getType()); [EOL] assertEquals(index, result.getCreatorIndex()); [EOL] assertTrue(result.isExplicitlyIncluded()); [EOL] }
public void testCreatorPropWithNullType() { [EOL] String name = "testName"; [EOL] JavaType type = null; [EOL] int index = 1; [EOL] try { [EOL] CreatorProperty result = creatorProp(name, type, index); [EOL] fail("Expected an exception to be thrown"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testCreateFromObjectWithValidArgs() { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object[] args = new Object[]{URI.create("http://example.com"), 1L, 2L, 3, 4}; [EOL] Object result = createFromObjectWith(ctxt, args); [EOL] assertTrue(result instanceof JsonLocation); [EOL] JsonLocation location = (JsonLocation) result; [EOL] assertEquals(URI.create("http://example.com"), location.getSourceRef()); [EOL] assertEquals(1L, location.getByteOffset()); [EOL] assertEquals(2L, location.getCharOffset()); [EOL] assertEquals(3, location.getLineNr()); [EOL] assertEquals(4, location.getColumnNr()); [EOL] }
public void testCreateFromObjectWithInvalidArgs() { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object[] args = new Object[]{null, "not a long", "not a long", "not an int", "not an int"}; [EOL] try { [EOL] Object result = createFromObjectWith(ctxt, args); [EOL] fail("Expected an exception to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void test_longWithNullInput() { [EOL] long result = _long(null); [EOL] assertEquals(0L, result); [EOL] }
public void test_longWithNumberInput() { [EOL] long expectedValue = 123L; [EOL] Number number = expectedValue; [EOL] long result = _long(number); [EOL] assertEquals(expectedValue, result); [EOL] }
public void testIntWithNullObject() { [EOL] int result = _int(null); [EOL] assertEquals(0, result); [EOL] }
public void testIntWithNumberObject() { [EOL] int expectedValue = 5; [EOL] int result = _int(expectedValue); [EOL] assertEquals(expectedValue, result); [EOL] }
public void testJsonMappingExceptionWithMessage() { [EOL] String message = "Test message"; [EOL] JsonMappingException exception = new JsonMappingException(message); [EOL] assertEquals(message, exception.getMessage()); [EOL] }
public void testGetActiveView() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] assertNull(mapper.getSerializationConfig().getActiveView()); [EOL] Class<?> viewClass = SomeViewClass.class; [EOL] mapper.setConfig(mapper.getSerializationConfig().withView(viewClass)); [EOL] assertEquals(viewClass, mapper.getSerializationConfig().getActiveView()); [EOL] }
public void testIsEnabledWithFeatureEnabled() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] mapper.enable(SerializationFeature.INDENT_OUTPUT); [EOL] assertTrue(mapper.isEnabled(SerializationFeature.INDENT_OUTPUT)); [EOL] }
public void testIsEnabledWithFeatureDisabled() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] mapper.disable(SerializationFeature.INDENT_OUTPUT); [EOL] assertFalse(mapper.isEnabled(SerializationFeature.INDENT_OUTPUT)); [EOL] }
public void testGetFilterProvider() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] assertNull(mapper.getSerializationConfig().getFilterProvider()); [EOL] FilterProvider filterProvider = new SimpleFilterProvider(); [EOL] mapper.setFilterProvider(filterProvider); [EOL] assertSame(filterProvider, mapper.getSerializationConfig().getFilterProvider()); [EOL] }
public void testFindValueSerializerWithKnownSerializer() { [EOL] JsonSerializer<Object> expectedSerializer = mock(JsonSerializer.class); [EOL] Class<?> valueType = Object.class; [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] SerializerProvider provider = new DefaultSerializerProvider.Impl(); [EOL] provider._knownSerializers = new SerializerCache(); [EOL] provider._serializerCache = new SerializerCache(); [EOL] provider._config = new SerializationConfig(null, null, null); [EOL] when(provider._knownSerializers.untypedValueSerializer(valueType)).thenReturn(expectedSerializer); [EOL] JsonSerializer<Object> result = provider.findValueSerializer(valueType, property); [EOL] assertEquals(expectedSerializer, result); [EOL] }
public void testFindValueSerializerWithCacheSerializer() { [EOL] JsonSerializer<Object> expectedSerializer = mock(JsonSerializer.class); [EOL] Class<?> valueType = Object.class; [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] SerializerProvider provider = new DefaultSerializerProvider.Impl(); [EOL] provider._knownSerializers = new SerializerCache(); [EOL] provider._serializerCache = new SerializerCache(); [EOL] provider._config = new SerializationConfig(null, null, null); [EOL] when(provider._knownSerializers.untypedValueSerializer(valueType)).thenReturn(null); [EOL] when(provider._serializerCache.untypedValueSerializer(valueType)).thenReturn(expectedSerializer); [EOL] JsonSerializer<Object> result = provider.findValueSerializer(valueType, property); [EOL] assertEquals(expectedSerializer, result); [EOL] }
public void testFindValueSerializerWithConstructedTypeSerializer() { [EOL] JsonSerializer<Object> expectedSerializer = mock(JsonSerializer.class); [EOL] Class<?> valueType = Object.class; [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] SerializerProvider provider = new DefaultSerializerProvider.Impl(); [EOL] provider._knownSerializers = new SerializerCache(); [EOL] provider._serializerCache = new SerializerCache(); [EOL] provider._config = new SerializationConfig(null, null, null); [EOL] when(provider._knownSerializers.untypedValueSerializer(valueType)).thenReturn(null); [EOL] when(provider._serializerCache.untypedValueSerializer(valueType)).thenReturn(null); [EOL] when(provider._serializerCache.untypedValueSerializer(provider._config.constructType(valueType))).thenReturn(expectedSerializer); [EOL] JsonSerializer<Object> result = provider.findValueSerializer(valueType, property); [EOL] assertEquals(expectedSerializer, result); [EOL] }
public void testFindValueSerializerWithCreateAndCacheSerializer() { [EOL] JsonSerializer<Object> expectedSerializer = mock(JsonSerializer.class); [EOL] Class<?> valueType = Object.class; [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] SerializerProvider provider = new DefaultSerializerProvider.Impl(); [EOL] provider._knownSerializers = new SerializerCache(); [EOL] provider._serializerCache = new SerializerCache(); [EOL] provider._config = new SerializationConfig(null, null, null); [EOL] when(provider._knownSerializers.untypedValueSerializer(valueType)).thenReturn(null); [EOL] when(provider._serializerCache.untypedValueSerializer(valueType)).thenReturn(null); [EOL] when(provider._serializerCache.untypedValueSerializer(provider._config.constructType(valueType))).thenReturn(null); [EOL] when(provider._createAndCacheUntypedSerializer(valueType)).thenReturn(expectedSerializer); [EOL] JsonSerializer<Object> result = provider.findValueSerializer(valueType, property); [EOL] assertEquals(expectedSerializer, result); [EOL] }
public void testFindValueSerializerWithUnknownTypeSerializer() { [EOL] JsonSerializer<Object> expectedSerializer = mock(JsonSerializer.class); [EOL] Class<?> valueType = Object.class; [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] SerializerProvider provider = new DefaultSerializerProvider.Impl(); [EOL] provider._knownSerializers = new SerializerCache(); [EOL] provider._serializerCache = new SerializerCache(); [EOL] provider._config = new SerializationConfig(null, null, null); [EOL] provider.CACHE_UNKNOWN_MAPPINGS = true; [EOL] when(provider._knownSerializers.untypedValueSerializer(valueType)).thenReturn(null); [EOL] when(provider._serializerCache.untypedValueSerializer(valueType)).thenReturn(null); [EOL] when(provider._serializerCache.untypedValueSerializer(provider._config.constructType(valueType))).thenReturn(null); [EOL] when(provider._createAndCacheUntypedSerializer(valueType)).thenReturn(null); [EOL] when(provider.getUnknownTypeSerializer(valueType)).thenReturn(expectedSerializer); [EOL] JsonSerializer<Object> result = provider.findValueSerializer(valueType, property); [EOL] assertEquals(expectedSerializer, result); [EOL] verify(provider._serializerCache).addAndResolveNonTypedSerializer(eq(valueType), eq(expectedSerializer), eq(provider)); [EOL] }
public void testFindTypedValueSerializerWithKnownSerializer() { [EOL] Class<?> valueType = Object.class; [EOL] boolean cache = false; [EOL] BeanProperty property = null; [EOL] JsonSerializer<Object> expectedSerializer = mock(JsonSerializer.class); [EOL] SerializerProvider provider = new DefaultSerializerProvider.Impl(); [EOL] provider._knownSerializers = mock(SerializerCache.class); [EOL] when(provider._knownSerializers.typedValueSerializer(valueType)).thenReturn(expectedSerializer); [EOL] JsonSerializer<Object> result = provider.findTypedValueSerializer(valueType, cache, property); [EOL] assertEquals(expectedSerializer, result); [EOL] }
public void testFindTypedValueSerializerWithCachedSerializer() { [EOL] Class<?> valueType = Object.class; [EOL] boolean cache = false; [EOL] BeanProperty property = null; [EOL] JsonSerializer<Object> expectedSerializer = mock(JsonSerializer.class); [EOL] SerializerProvider provider = new DefaultSerializerProvider.Impl(); [EOL] provider._knownSerializers = mock(SerializerCache.class); [EOL] provider._serializerCache = mock(SerializerCache.class); [EOL] when(provider._knownSerializers.typedValueSerializer(valueType)).thenReturn(null); [EOL] when(provider._serializerCache.typedValueSerializer(valueType)).thenReturn(expectedSerializer); [EOL] JsonSerializer<Object> result = provider.findTypedValueSerializer(valueType, cache, property); [EOL] assertEquals(expectedSerializer, result); [EOL] }
public void testFindTypedValueSerializerWithTypeSerializer() { [EOL] Class<?> valueType = Object.class; [EOL] boolean cache = false; [EOL] BeanProperty property = null; [EOL] JsonSerializer<Object> valueSerializer = mock(JsonSerializer.class); [EOL] TypeSerializer typeSerializer = mock(TypeSerializer.class); [EOL] TypeWrappedSerializer expectedSerializer = new TypeWrappedSerializer(typeSerializer, valueSerializer); [EOL] SerializerProvider provider = new DefaultSerializerProvider.Impl(); [EOL] provider._knownSerializers = mock(SerializerCache.class); [EOL] provider._serializerCache = mock(SerializerCache.class); [EOL] provider._serializerFactory = mock(SerializerFactory.class); [EOL] provider._config = new SerializationConfig(null, null, null, null, null, null, null); [EOL] when(provider._knownSerializers.typedValueSerializer(valueType)).thenReturn(null); [EOL] when(provider._serializerCache.typedValueSerializer(valueType)).thenReturn(null); [EOL] when(provider.findValueSerializer(valueType, property)).thenReturn(valueSerializer); [EOL] when(provider._serializerFactory.createTypeSerializer(any(SerializationConfig.class), any(JavaType.class))).thenReturn(typeSerializer); [EOL] JsonSerializer<Object> result = provider.findTypedValueSerializer(valueType, cache, property); [EOL] assertEquals(expectedSerializer, result); [EOL] }
public void testFindTypedValueSerializerWithCaching() { [EOL] Class<?> valueType = Object.class; [EOL] boolean cache = true; [EOL] BeanProperty property = null; [EOL] JsonSerializer<Object> valueSerializer = mock(JsonSerializer.class); [EOL] TypeSerializer typeSerializer = mock(TypeSerializer.class); [EOL] TypeWrappedSerializer expectedSerializer = new TypeWrappedSerializer(typeSerializer, valueSerializer); [EOL] SerializerProvider provider = new DefaultSerializerProvider.Impl(); [EOL] provider._knownSerializers = mock(SerializerCache.class); [EOL] provider._serializerCache = mock(SerializerCache.class); [EOL] provider._serializerFactory = mock(SerializerFactory.class); [EOL] provider._config = new SerializationConfig(null, null, null, null, null, null, null); [EOL] when(provider._knownSerializers.typedValueSerializer(valueType)).thenReturn(null); [EOL] when(provider._serializerCache.typedValueSerializer(valueType)).thenReturn(null); [EOL] when(provider.findValueSerializer(valueType, property)).thenReturn(valueSerializer); [EOL] when(provider._serializerFactory.createTypeSerializer(any(SerializationConfig.class), any(JavaType.class))).thenReturn(typeSerializer); [EOL] JsonSerializer<Object> result = provider.findTypedValueSerializer(valueType, cache, property); [EOL] assertEquals(expectedSerializer, result); [EOL] verify(provider._serializerCache).addTypedSerializer(valueType, result); [EOL] }
public void testDefaultSerializeValueWithNull() throws IOException, JsonProcessingException { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] JsonGenerator jgen = new JsonFactory().createGenerator(new StringWriter()); [EOL] mapper.defaultSerializeValue(null, jgen); [EOL] }
public void testDefaultSerializeValueWithNonNull() throws IOException, JsonProcessingException { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] JsonGenerator jgen = new JsonFactory().createGenerator(new StringWriter()); [EOL] Object value = new Object(); [EOL] mapper.defaultSerializeValue(value, jgen); [EOL] }
public void testHandleResolvableWithResolvableSerializer() throws JsonMappingException { [EOL] JsonSerializer<?> ser = mock(ResolvableSerializer.class); [EOL] JsonSerializer<Object> result = _handleResolvable(ser); [EOL] verify((ResolvableSerializer) ser).resolve(this); [EOL] assertNotNull(result); [EOL] }
public void testHandleResolvableWithNonResolvableSerializer() throws JsonMappingException { [EOL] JsonSerializer<?> ser = mock(JsonSerializer.class); [EOL] JsonSerializer<Object> result = _handleResolvable(ser); [EOL] assertEquals(ser, result); [EOL] }
public void testHandleContextualWithNonContextualSerializer() { [EOL] JsonSerializer<?> nonContextualSerializer = new JsonSerializer<Object>() { [EOL] }; [EOL] JsonSerializer<Object> result = _handleContextual(nonContextualSerializer, null); [EOL] assertSame(nonContextualSerializer, result); [EOL] }
public void testHandleContextualWithContextualSerializer() { [EOL] JsonSerializer<?> contextualSerializer = new ContextualSerializer() { [EOL] @Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider prov, BeanProperty property) throws JsonMappingException { [EOL] return this; // Return the same serializer for simplicity [EOL] } [EOL] }; [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] JsonSerializer<Object> result = _handleContextual(contextualSerializer, property); [EOL] assertSame(contextualSerializer, result); [EOL] }
