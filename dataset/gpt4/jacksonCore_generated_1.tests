public void testCreateRoot() { [EOL] CharsToNameCanonicalizer ctn = CharsToNameCanonicalizer.createRoot(); [EOL] assertNotNull(ctn); [EOL] }
protected static CharsToNameCanonicalizer createRoot(int hashSeed) { [EOL] return sBootstrapSymbolTable.makeOrphan(hashSeed); [EOL] }
public void testThresholdSize_PositiveHashAreaSize() { [EOL] int hashAreaSize = 100; [EOL] int expectedThreshold = 75; // 100 - (100 >> 2) = 75 [EOL] int actualThreshold = _thresholdSize(hashAreaSize); [EOL] assertEquals(expectedThreshold, actualThreshold); [EOL] }
public void testThresholdSize_ZeroHashAreaSize() { [EOL] int hashAreaSize = 0; [EOL] int expectedThreshold = 0; // 0 - (0 >> 2) = 0 [EOL] int actualThreshold = _thresholdSize(hashAreaSize); [EOL] assertEquals(expectedThreshold, actualThreshold); [EOL] }
public void testThresholdSize_MaxIntegerHashAreaSize() { [EOL] int hashAreaSize = Integer.MAX_VALUE; [EOL] int expectedThreshold = Integer.MAX_VALUE - (Integer.MAX_VALUE >> 2); // Edge case [EOL] int actualThreshold = _thresholdSize(hashAreaSize); [EOL] assertEquals(expectedThreshold, actualThreshold); [EOL] }
public void testCharsToNameCanonicalizerConstruction() { [EOL] String[] symbols = new String[]{"a", "b", "c"}; [EOL] CharsToNameCanonicalizer.Bucket[] buckets = new CharsToNameCanonicalizer.Bucket[3]; [EOL] CharsToNameCanonicalizer parent = null; [EOL] boolean canonicalize = true; [EOL] boolean intern = true; [EOL] int size = 3; [EOL] int hashSeed = 0; [EOL] int longestColl = 1; [EOL] CharsToNameCanonicalizer ctn = new CharsToNameCanonicalizer(parent, canonicalize, intern, symbols, buckets, size, hashSeed, longestColl); [EOL] assertNotNull(ctn); [EOL] assertEquals(parent, ctn._parent); [EOL] assertEquals(canonicalize, ctn._canonicalize); [EOL] assertEquals(intern, ctn._intern); [EOL] assertArrayEquals(symbols, ctn._symbols); [EOL] assertArrayEquals(buckets, ctn._buckets); [EOL] assertEquals(size, ctn._size); [EOL] assertEquals(hashSeed, ctn._hashSeed); [EOL] assertEquals(symbols.length - 1, ctn._indexMask); [EOL] assertEquals(longestColl, ctn._longestCollisionList); [EOL] assertFalse(ctn._dirty); [EOL] }
public void testCharsToNameCanonicalizerConstructionWithDifferentParameters() { [EOL] String[] symbols = new String[]{"x", "y"}; [EOL] CharsToNameCanonicalizer.Bucket[] buckets = new CharsToNameCanonicalizer.Bucket[2]; [EOL] CharsToNameCanonicalizer parent = new CharsToNameCanonicalizer(null, false, false, new String[0], new CharsToNameCanonicalizer.Bucket[0], 0, 0, 0); [EOL] boolean canonicalize = false; [EOL] boolean intern = false; [EOL] int size = 2; [EOL] int hashSeed = 1; [EOL] int longestColl = 0; [EOL] CharsToNameCanonicalizer ctn = new CharsToNameCanonicalizer(parent, canonicalize, intern, symbols, buckets, size, hashSeed, longestColl); [EOL] assertNotNull(ctn); [EOL] assertEquals(parent, ctn._parent); [EOL] assertEquals(canonicalize, ctn._canonicalize); [EOL] assertEquals(intern, ctn._intern); [EOL] assertArrayEquals(symbols, ctn._symbols); [EOL] assertArrayEquals(buckets, ctn._buckets); [EOL] assertEquals(size, ctn._size); [EOL] assertEquals(hashSeed, ctn._hashSeed); [EOL] assertEquals(symbols.length - 1, ctn._indexMask); [EOL] assertEquals(longestColl, ctn._longestCollisionList); [EOL] assertFalse(ctn._dirty); [EOL] }
public void testMakeChildWithCanonicalizeAndIntern() { [EOL] CharsToNameCanonicalizer parent = new CharsToNameCanonicalizer(0); [EOL] CharsToNameCanonicalizer child = parent.makeChild(true, true); [EOL] assertNotNull(child); [EOL] assertTrue(child.isCanonicalizing()); [EOL] assertTrue(child.isInterning()); [EOL] }
public void testMakeChildWithoutCanonicalizeAndIntern() { [EOL] CharsToNameCanonicalizer parent = new CharsToNameCanonicalizer(0); [EOL] CharsToNameCanonicalizer child = parent.makeChild(false, false); [EOL] assertNotNull(child); [EOL] assertFalse(child.isCanonicalizing()); [EOL] assertFalse(child.isInterning()); [EOL] }
public void testMakeOrphanWithPositiveSeed() { [EOL] int seed = 1; [EOL] CharsToNameCanonicalizer result = makeOrphan(seed); [EOL] assertNotNull(result); [EOL] assertTrue(result.isIntern()); [EOL] assertTrue(result.isCanonical()); [EOL] assertNull(result.getParent()); [EOL] assertEquals(seed, result.getSeed()); [EOL] assertEquals(_size, result.size()); [EOL] assertEquals(_longestCollisionList, result.getLongestCollisionList()); [EOL] }
public void testMakeOrphanWithZeroSeed() { [EOL] int seed = 0; [EOL] CharsToNameCanonicalizer result = makeOrphan(seed); [EOL] assertNotNull(result); [EOL] assertTrue(result.isIntern()); [EOL] assertTrue(result.isCanonical()); [EOL] assertNull(result.getParent()); [EOL] assertEquals(seed, result.getSeed()); [EOL] assertEquals(_size, result.size()); [EOL] assertEquals(_longestCollisionList, result.getLongestCollisionList()); [EOL] }
public void testMakeOrphanWithNegativeSeed() { [EOL] int seed = -1; [EOL] CharsToNameCanonicalizer result = makeOrphan(seed); [EOL] assertNotNull(result); [EOL] assertTrue(result.isIntern()); [EOL] assertTrue(result.isCanonical()); [EOL] assertNull(result.getParent()); [EOL] assertEquals(seed, result.getSeed()); [EOL] assertEquals(_size, result.size()); [EOL] assertEquals(_longestCollisionList, result.getLongestCollisionList()); [EOL] }
public void testMergeChildWithLargerSize() { [EOL] CharsToNameCanonicalizer parent = new CharsToNameCanonicalizer(16); [EOL] CharsToNameCanonicalizer child = new CharsToNameCanonicalizer(32); [EOL] child._size = 17; // Assuming size() method returns _size and it's public for the sake of the test [EOL] child._longestCollisionList = 0; // Assuming _longestCollisionList is public for the sake of the test [EOL] parent.mergeChild(child); [EOL] assertEquals(17, parent.size()); [EOL] assertEquals(child._symbols, parent._symbols); [EOL] assertEquals(child._buckets, parent._buckets); [EOL] assertEquals(child._size, parent._size); [EOL] assertEquals(child._sizeThreshold, parent._sizeThreshold); [EOL] assertEquals(child._indexMask, parent._indexMask); [EOL] assertEquals(child._longestCollisionList, parent._longestCollisionList); [EOL] assertFalse(parent._dirty); [EOL] }
public void testMergeChildWithLongerCollisionList() { [EOL] CharsToNameCanonicalizer parent = new CharsToNameCanonicalizer(16); [EOL] CharsToNameCanonicalizer child = new CharsToNameCanonicalizer(16); [EOL] child._size = 10; [EOL] child._longestCollisionList = 65; // MAX_COLL_CHAIN_FOR_REUSE is assumed to be less than 65 [EOL] parent.mergeChild(child); [EOL] assertEquals(DEFAULT_TABLE_SIZE, parent.size()); // Assuming DEFAULT_TABLE_SIZE is a known constant [EOL] assertTrue(parent._dirty); [EOL] }
public void testMergeChildWithSmallerSize() { [EOL] CharsToNameCanonicalizer parent = new CharsToNameCanonicalizer(32); [EOL] CharsToNameCanonicalizer child = new CharsToNameCanonicalizer(16); [EOL] child._size = 15; [EOL] child._longestCollisionList = 0; [EOL] parent.mergeChild(child); [EOL] assertEquals(32, parent.size()); // No change expected [EOL] assertFalse(parent._dirty); [EOL] }
public void testRelease_NotDirty() { [EOL] JacksonCore target = new JacksonCore() { [EOL] @Override [EOL] public boolean maybeDirty() { [EOL] return false; [EOL] } [EOL] }; [EOL] target.release(); [EOL] }
public void testRelease_DirtyWithParent() { [EOL] JacksonCore target = new JacksonCore() { [EOL] @Override [EOL] public boolean maybeDirty() { [EOL] return true; [EOL] } [EOL] }; [EOL] JacksonCore parent = new JacksonCore(); [EOL] target._parent = parent; [EOL] target.release(); [EOL] }
public void testSizeWhenSizeIsZero() { [EOL] JsonArray jsonArray = new JsonArray(); [EOL] int size = jsonArray.size(); [EOL] assertEquals(0, size); [EOL] }
public void testSizeWhenSizeIsNonZero() { [EOL] JsonArray jsonArray = new JsonArray(); [EOL] jsonArray.add("element"); // Assuming there's a method to add elements [EOL] int size = jsonArray.size(); [EOL] assertEquals(1, size); [EOL] }
public void testMaybeDirtyWhenDirty() { [EOL] JsonGenerator generator = new JsonGenerator(); [EOL] generator.setDirty(true); [EOL] assertTrue(generator.maybeDirty()); [EOL] }
public void testMaybeDirtyWhenNotDirty() { [EOL] JsonGenerator generator = new JsonGenerator(); [EOL] generator.setDirty(false); [EOL] assertFalse(generator.maybeDirty()); [EOL] }
public int testHashSeed() { [EOL] JsonFactory factory = new JsonFactory(); [EOL] int seed = factory.hashSeed(); [EOL] assertEquals(factory._hashSeed, seed); [EOL] }
public void testFindSymbolWithEmptyBuffer() { [EOL] YourSymbolClass instance = new YourSymbolClass(true); // true for _canonicalize [EOL] char[] buffer = new char[0]; [EOL] String result = instance.findSymbol(buffer, 0, 0, 0); [EOL] assertEquals("", result); [EOL] }
public void testFindSymbolWithoutCanonicalization() { [EOL] YourSymbolClass instance = new YourSymbolClass(false); // false for _canonicalize [EOL] char[] buffer = new char[]{'a', 'b', 'c'}; [EOL] String result = instance.findSymbol(buffer, 0, 3, 0); [EOL] assertEquals("abc", result); [EOL] }
public void testFindSymbolWithExistingSymbol() { [EOL] YourSymbolClass instance = new YourSymbolClass(true); // true for _canonicalize [EOL] char[] buffer = new char[]{'a', 'b', 'c'}; [EOL] int h = instance.calcHash(buffer, 0, 3); [EOL] int index = instance._hashToIndex(h); [EOL] instance._symbols[index] = "abc"; [EOL] String result = instance.findSymbol(buffer, 0, 3, h); [EOL] assertEquals("abc", result); [EOL] }
public void testFindSymbolWithCollisionAndBucketNotNull() { [EOL] YourSymbolClass instance = new YourSymbolClass(true); // true for _canonicalize [EOL] char[] buffer = new char[]{'a', 'b', 'c'}; [EOL] int h = instance.calcHash(buffer, 0, 3); [EOL] int index = instance._hashToIndex(h); [EOL] instance._symbols[index] = "xyz"; // Different symbol to create collision [EOL] instance._buckets[index >> 1] = instance.new Bucket("abc", null); [EOL] String result = instance.findSymbol(buffer, 0, 3, h); [EOL] assertEquals("abc", result); [EOL] }
public void testFindSymbolWithDirtyAndSizeThresholdExceeded() { [EOL] YourSymbolClass instance = new YourSymbolClass(true); // true for _canonicalize [EOL] instance._dirty = true; [EOL] instance._size = instance._sizeThreshold; // To trigger rehash [EOL] char[] buffer = new char[]{'a', 'b', 'c'}; [EOL] int h = instance.calcHash(buffer, 0, 3); [EOL] String result = instance.findSymbol(buffer, 0, 3, h); [EOL] assertNotNull(result); [EOL] assertEquals("abc", result); [EOL] }
public void testFindSymbolWithIntern() { [EOL] YourSymbolClass instance = new YourSymbolClass(true, true); // true for _canonicalize and _intern [EOL] char[] buffer = new char[]{'a', 'b', 'c'}; [EOL] int h = instance.calcHash(buffer, 0, 3); [EOL] String result = instance.findSymbol(buffer, 0, 3, h); [EOL] assertNotNull(result); [EOL] assertEquals("abc", result); [EOL] }
public void testFindSymbolWithLongestCollisionChainExceeded() { [EOL] YourSymbolClass instance = new YourSymbolClass(true); // true for _canonicalize [EOL] char[] buffer = new char[]{'a', 'b', 'c'}; [EOL] int h = instance.calcHash(buffer, 0, 3); [EOL] int index = instance._hashToIndex(h); [EOL] for (int i = 0; i <= instance.MAX_COLL_CHAIN_LENGTH; i++) { [EOL] instance._buckets[index >> 1] = instance.new Bucket("diff" + i, instance._buckets[index >> 1]); [EOL] } [EOL] instance._longestCollisionList = instance.MAX_COLL_CHAIN_LENGTH; [EOL] try { [EOL] instance.findSymbol(buffer, 0, 3, h); [EOL] fail("Should have reported too many collisions"); [EOL] } catch (Exception e) { [EOL] } [EOL] }
public void testHashToIndex_PositiveRawHash() { [EOL] int rawHash = 123456; // Some positive raw hash value [EOL] int indexMask = 0x3FF; // Assuming _indexMask is set to 0x3FF [EOL] JacksonCore instance = new JacksonCore(indexMask); // Assuming JacksonCore is the class name and it has a constructor that sets _indexMask [EOL] int expected = (rawHash + (rawHash >>> 15)) & indexMask; [EOL] int actual = instance._hashToIndex(rawHash); [EOL] assertEquals(expected, actual); [EOL] }
public void testHashToIndex_NegativeRawHash() { [EOL] int rawHash = -123456; // Some negative raw hash value [EOL] int indexMask = 0x3FF; // Assuming _indexMask is set to 0x3FF [EOL] JacksonCore instance = new JacksonCore(indexMask); // Assuming JacksonCore is the class name and it has a constructor that sets _indexMask [EOL] int expected = (rawHash + (rawHash >>> 15)) & indexMask; [EOL] int actual = instance._hashToIndex(rawHash); [EOL] assertEquals(expected, actual); [EOL] }
public void testHashToIndex_ZeroRawHash() { [EOL] int rawHash = 0; // Zero raw hash value [EOL] int indexMask = 0x3FF; // Assuming _indexMask is set to 0x3FF [EOL] JacksonCore instance = new JacksonCore(indexMask); // Assuming JacksonCore is the class name and it has a constructor that sets _indexMask [EOL] int expected = (rawHash + (rawHash >>> 15)) & indexMask; [EOL] int actual = instance._hashToIndex(rawHash); [EOL] assertEquals(expected, actual); [EOL] }
public void testHashToIndex_MaxIntRawHash() { [EOL] int rawHash = Integer.MAX_VALUE; // Max int raw hash value [EOL] int indexMask = 0x3FF; // Assuming _indexMask is set to 0x3FF [EOL] JacksonCore instance = new JacksonCore(indexMask); // Assuming JacksonCore is the class name and it has a constructor that sets _indexMask [EOL] int expected = (rawHash + (rawHash >>> 15)) & indexMask; [EOL] int actual = instance._hashToIndex(rawHash); [EOL] assertEquals(expected, actual); [EOL] }
public void testHashToIndex_MinIntRawHash() { [EOL] int rawHash = Integer.MIN_VALUE; // Min int raw hash value [EOL] int indexMask = 0x3FF; // Assuming _indexMask is set to 0x3FF [EOL] JacksonCore instance = new JacksonCore(indexMask); // Assuming JacksonCore is the class name and it has a constructor that sets _indexMask [EOL] int expected = (rawHash + (rawHash >>> 15)) & indexMask; [EOL] int actual = instance._hashToIndex(rawHash); [EOL] assertEquals(expected, actual); [EOL] }
public void testCopyArrays() { [EOL] _symbols = new String[] {"a", "b", "c"}; [EOL] _buckets = new Bucket[] {new Bucket(), new Bucket()}; [EOL] String[] oldSymbols = _symbols; [EOL] Bucket[] oldBuckets = _buckets; [EOL] copyArrays(); [EOL] assertNotSame("The symbols array should not be the same reference after copying", oldSymbols, _symbols); [EOL] assertNotSame("The buckets array should not be the same reference after copying", oldBuckets, _buckets); [EOL] assertArrayEquals("The symbols array should have the same content after copying", oldSymbols, _symbols); [EOL] assertArrayEquals("The buckets array should have the same content after copying", oldBuckets, _buckets); [EOL] }
public void testBucketConstructorWithNullNext() { [EOL] String symbol = "testSymbol"; [EOL] Bucket next = null; [EOL] Bucket bucket = new Bucket(symbol, next); [EOL] assertEquals("testSymbol", bucket._symbol); [EOL] assertNull(bucket._next); [EOL] assertEquals(1, bucket._length); [EOL] }
public void testBucketConstructorWithNonNullNext() { [EOL] String symbol = "testSymbol"; [EOL] Bucket next = new Bucket("nextSymbol", null); [EOL] Bucket bucket = new Bucket(symbol, next); [EOL] assertEquals("testSymbol", bucket._symbol); [EOL] assertNotNull(bucket._next); [EOL] assertEquals(2, bucket._length); [EOL] }
public void testLength_PositiveLength() { [EOL] YourClass instance = new YourClass(10); // Replace 'YourClass' with the actual class name [EOL] int result = instance.length(); [EOL] assertEquals(10, result); [EOL] }
public void testLength_ZeroLength() { [EOL] YourClass instance = new YourClass(0); // Replace 'YourClass' with the actual class name [EOL] int result = instance.length(); [EOL] assertEquals(0, result); [EOL] }
public void testParserBaseInitialization() { [EOL] IOContext ctxt = new IOContext(new BufferRecycler(), new Object(), false); [EOL] int features = 123; [EOL] ParserBase parserBase = new ParserBase(ctxt, features); [EOL] assertNotNull(parserBase); [EOL] assertEquals(features, parserBase._features); [EOL] assertEquals(ctxt, parserBase._ioContext); [EOL] assertNotNull(parserBase._textBuffer); [EOL] assertNotNull(parserBase._parsingContext); [EOL] }
public void testGetCurrentNameWithStartObjectToken() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserWithToken(JsonToken.START_OBJECT); [EOL] assertEquals("ExpectedName", parser.getCurrentName()); [EOL] } [EOL] public void testGetCurrentNameWithStartArrayToken() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserWithToken(JsonToken.START_ARRAY); [EOL] assertEquals("ExpectedName", parser.getCurrentName()); [EOL] } [EOL] public void testGetCurrentNameWithDifferentToken() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserWithToken(JsonToken.FIELD_NAME); [EOL] assertEquals("ExpectedName", parser.getCurrentName()); [EOL] }
private JsonParser createParserWithToken(JsonToken token) { [EOL] JsonParser parser = mock(JsonParser.class); [EOL] when(parser.getCurrentToken()).thenReturn(token); [EOL] JsonReadContext parsingContext = mock(JsonReadContext.class); [EOL] when(parsingContext.getCurrentName()).thenReturn("ExpectedName"); [EOL] when(parsingContext.getParent()).thenReturn(parsingContext); [EOL] when(parser.getParsingContext()).thenReturn(parsingContext); [EOL] return parser; [EOL] }
public void testCloseWhenAlreadyClosed() throws IOException { [EOL] YourClass instance = new YourClass(); [EOL] Field closedField = YourClass.class.getDeclaredField("_closed"); [EOL] closedField.setAccessible(true); [EOL] closedField.set(instance, true); [EOL] instance.close(); // This should not throw an exception [EOL] assertTrue((Boolean)closedField.get(instance)); [EOL] }
public void testCloseWhenNotClosed() throws IOException { [EOL] YourClass instance = new YourClass(); [EOL] Field closedField = YourClass.class.getDeclaredField("_closed"); [EOL] closedField.setAccessible(true); [EOL] instance.close(); // This should set _closed to true and call _closeInput and _releaseBuffers [EOL] assertTrue((Boolean)closedField.get(instance)); [EOL] }
public void testIsClosedWhenClosed() { [EOL] JsonParser jp = createParserWithClosedState(true); [EOL] assertTrue(jp.isClosed()); [EOL] }
public void testIsClosedWhenNotClosed() { [EOL] JsonParser jp = createParserWithClosedState(false); [EOL] assertFalse(jp.isClosed()); [EOL] }
public void testReleaseBuffersWithNonNullNameCopyBuffer() throws IOException { [EOL] _textBuffer = new TextBuffer(mock(IOContext.class)); [EOL] _nameCopyBuffer = new char[10]; // assuming this is a non-null value [EOL] _ioContext = mock(IOContext.class); [EOL] _releaseBuffers(); [EOL] assertNull(_nameCopyBuffer); [EOL] verify(_ioContext).releaseNameCopyBuffer(any(char[].class)); [EOL] }
public void testReleaseBuffersWithNullNameCopyBuffer() throws IOException { [EOL] _textBuffer = new TextBuffer(mock(IOContext.class)); [EOL] _nameCopyBuffer = null; // explicitly setting to null [EOL] _ioContext = mock(IOContext.class); [EOL] _releaseBuffers(); [EOL] assertNull(_nameCopyBuffer); [EOL] verify(_ioContext, never()).releaseNameCopyBuffer(any(char[].class)); [EOL] }
public void testResetWithIntOnly() { [EOL] JsonToken result = reset(false, 5, 0, 0); [EOL] assertEquals(JsonToken.VALUE_NUMBER_INT, result); [EOL] }
public void testResetWithFraction() { [EOL] JsonToken result = reset(false, 5, 1, 0); [EOL] assertEquals(JsonToken.VALUE_NUMBER_FLOAT, result); [EOL] }
public void testResetWithExponent() { [EOL] JsonToken result = reset(false, 5, 0, 1); [EOL] assertEquals(JsonToken.VALUE_NUMBER_FLOAT, result); [EOL] }
public void testResetWithFractionAndExponent() { [EOL] JsonToken result = reset(false, 5, 1, 1); [EOL] assertEquals(JsonToken.VALUE_NUMBER_FLOAT, result); [EOL] }
public void testResetNegativeIntOnly() { [EOL] JsonToken result = reset(true, 5, 0, 0); [EOL] assertEquals(JsonToken.VALUE_NUMBER_INT, result); [EOL] }
public void testResetNegativeWithFraction() { [EOL] JsonToken result = reset(true, 5, 1, 0); [EOL] assertEquals(JsonToken.VALUE_NUMBER_FLOAT, result); [EOL] }
public void testResetNegativeWithExponent() { [EOL] JsonToken result = reset(true, 5, 0, 1); [EOL] assertEquals(JsonToken.VALUE_NUMBER_FLOAT, result); [EOL] }
public void testResetNegativeWithFractionAndExponent() { [EOL] JsonToken result = reset(true, 5, 1, 1); [EOL] assertEquals(JsonToken.VALUE_NUMBER_FLOAT, result); [EOL] }
public void testResetIntPositive() { [EOL] JsonParser parser = new JsonParser(); // Replace with actual constructor [EOL] JsonToken result = parser.resetInt(false, 10); [EOL] assertEquals(JsonToken.VALUE_NUMBER_INT, result); [EOL] assertFalse(parser._numberNegative); [EOL] assertEquals(10, parser._intLength); [EOL] assertEquals(0, parser._fractLength); [EOL] assertEquals(0, parser._expLength); [EOL] assertEquals(JsonParser.NR_UNKNOWN, parser._numTypesValid); [EOL] }
public void testResetIntNegative() { [EOL] JsonParser parser = new JsonParser(); // Replace with actual constructor [EOL] JsonToken result = parser.resetInt(true, 5); [EOL] assertEquals(JsonToken.VALUE_NUMBER_INT, result); [EOL] assertTrue(parser._numberNegative); [EOL] assertEquals(5, parser._intLength); [EOL] assertEquals(0, parser._fractLength); [EOL] assertEquals(0, parser._expLength); [EOL] assertEquals(JsonParser.NR_UNKNOWN, parser._numTypesValid); [EOL] }
public void testResetFloat_PositiveValues() { [EOL] boolean negative = false; [EOL] int intLen = 5; [EOL] int fractLen = 3; [EOL] int expLen = 2; [EOL] JsonToken result = resetFloat(negative, intLen, fractLen, expLen); [EOL] assertEquals("Expected number negative to be false", false, _numberNegative); [EOL] assertEquals("Expected int length to be 5", 5, _intLength); [EOL] assertEquals("Expected fraction length to be 3", 3, _fractLength); [EOL] assertEquals("Expected exponent length to be 2", 2, _expLength); [EOL] assertEquals("Expected num types valid to be NR_UNKNOWN", NR_UNKNOWN, _numTypesValid); [EOL] assertEquals("Expected JsonToken to be VALUE_NUMBER_FLOAT", JsonToken.VALUE_NUMBER_FLOAT, result); [EOL] }
public void testResetFloat_NegativeValues() { [EOL] boolean negative = true; [EOL] int intLen = 7; [EOL] int fractLen = 4; [EOL] int expLen = 1; [EOL] JsonToken result = resetFloat(negative, intLen, fractLen, expLen); [EOL] assertEquals("Expected number negative to be true", true, _numberNegative); [EOL] assertEquals("Expected int length to be 7", 7, _intLength); [EOL] assertEquals("Expected fraction length to be 4", 4, _fractLength); [EOL] assertEquals("Expected exponent length to be 1", 1, _expLength); [EOL] assertEquals("Expected num types valid to be NR_UNKNOWN", NR_UNKNOWN, _numTypesValid); [EOL] assertEquals("Expected JsonToken to be VALUE_NUMBER_FLOAT", JsonToken.VALUE_NUMBER_FLOAT, result); [EOL] }
public void testGetNumberTypeWhenNumTypesValidIsUnknown() throws IOException, JsonParseException { [EOL] JsonParserImpl parser = new JsonParserImpl(); [EOL] parser._numTypesValid = NR_UNKNOWN; // Set to unknown to trigger parsing [EOL] NumberType result = parser.getNumberType(); [EOL] parser._currToken = JsonToken.VALUE_NUMBER_INT; [EOL] parser._numTypesValid = NR_INT; [EOL] assertEquals(NumberType.INT, result); [EOL] }
public void testGetNumberTypeWhenValueNumberIntAndNumTypesValidIsInt() throws IOException, JsonParseException { [EOL] JsonParserImpl parser = new JsonParserImpl(); [EOL] parser._numTypesValid = NR_INT; [EOL] parser._currToken = JsonToken.VALUE_NUMBER_INT; [EOL] NumberType result = parser.getNumberType(); [EOL] assertEquals(NumberType.INT, result); [EOL] }
public void testGetNumberTypeWhenValueNumberIntAndNumTypesValidIsLong() throws IOException, JsonParseException { [EOL] JsonParserImpl parser = new JsonParserImpl(); [EOL] parser._numTypesValid = NR_LONG; [EOL] parser._currToken = JsonToken.VALUE_NUMBER_INT; [EOL] NumberType result = parser.getNumberType(); [EOL] assertEquals(NumberType.LONG, result); [EOL] }
public void testGetNumberTypeWhenValueNumberIntAndNumTypesValidIsBigInteger() throws IOException, JsonParseException { [EOL] JsonParserImpl parser = new JsonParserImpl(); [EOL] parser._numTypesValid = NR_UNKNOWN; // BigInteger is the default when INT and LONG are not set [EOL] parser._currToken = JsonToken.VALUE_NUMBER_INT; [EOL] NumberType result = parser.getNumberType(); [EOL] assertEquals(NumberType.BIG_INTEGER, result); [EOL] }
public void testGetNumberTypeWhenNumTypesValidIsBigDecimal() throws IOException, JsonParseException { [EOL] JsonParserImpl parser = new JsonParserImpl(); [EOL] parser._numTypesValid = NR_BIGDECIMAL; [EOL] NumberType result = parser.getNumberType(); [EOL] assertEquals(NumberType.BIG_DECIMAL, result); [EOL] }
public void testGetNumberTypeWhenNumTypesValidIsDouble() throws IOException, JsonParseException { [EOL] JsonParserImpl parser = new JsonParserImpl(); [EOL] parser._numTypesValid = NR_UNKNOWN; // Double is the default when others are not set [EOL] NumberType result = parser.getNumberType(); [EOL] assertEquals(NumberType.DOUBLE, result); [EOL] }
public void testGetIntValueWithNrIntValid() throws IOException, JsonParseException { [EOL] setupNumberIntValidState(NR_INT); [EOL] int result = getIntValue(); [EOL] assertEquals(_numberInt, result); [EOL] }
public void testGetIntValueWithNrUnknown() throws IOException, JsonParseException { [EOL] setupNumberIntValidState(NR_UNKNOWN); [EOL] _parseNumericValue(NR_INT); // Assuming this method sets the _numTypesValid to include NR_INT [EOL] int result = getIntValue(); [EOL] assertEquals(_numberInt, result); [EOL] }
public void testGetIntValueWithNrIntInvalid() throws IOException, JsonParseException { [EOL] setupNumberIntInvalidState(); [EOL] convertNumberToInt(); // Assuming this method sets the _numTypesValid to include NR_INT [EOL] int result = getIntValue(); [EOL] assertEquals(_numberInt, result); [EOL] }
public void testGetLongValueWithNrLongSet() throws IOException, JsonParseException { [EOL] _numTypesValid = NR_LONG; // NR_LONG is some constant flag [EOL] _numberLong = 10L; // Example value [EOL] long result = getLongValue(); [EOL] assertEquals(10L, result); [EOL] }
public void testGetLongValueWithNrUnknown() throws IOException, JsonParseException { [EOL] _numTypesValid = NR_UNKNOWN; // NR_UNKNOWN is some constant flag [EOL] long result = getLongValue(); [EOL] assertEquals(20L, result); [EOL] }
public void testGetLongValueRequiresConversion() throws IOException, JsonParseException { [EOL] _numTypesValid = 0; // Neither NR_LONG nor NR_UNKNOWN is set [EOL] long result = getLongValue(); [EOL] assertEquals(30L, result); [EOL] }
public void testGetBigIntegerValueWithUnknownNumType() throws IOException, JsonParseException { [EOL] setNumTypesValid(NR_UNKNOWN); [EOL] setNumberBigInt(null); [EOL] BigInteger result = getBigIntegerValue(); [EOL] assertNotNull(result); [EOL] assertTrue(isNumTypeValid(NR_BIGINT)); [EOL] }
public void testGetBigIntegerValueWithBigIntNumType() throws IOException, JsonParseException { [EOL] setNumTypesValid(NR_BIGINT); [EOL] BigInteger expectedValue = new BigInteger("1234567890"); [EOL] setNumberBigInt(expectedValue); [EOL] BigInteger result = getBigIntegerValue(); [EOL] assertSame(expectedValue, result); [EOL] }
public void testGetBigIntegerValueWithNonBigIntNumType() throws IOException, JsonParseException { [EOL] setNumTypesValid(NR_INT); // NR_INT is just an example of another num type [EOL] setNumberBigInt(null); [EOL] BigInteger result = getBigIntegerValue(); [EOL] assertNotNull(result); [EOL] assertTrue(isNumTypeValid(NR_BIGINT)); [EOL] }
public void testGetDoubleValueWithUnknownType() throws IOException, JsonParseException { [EOL] setupWithUnknownType(); [EOL] double result = getDoubleValue(); [EOL] double expected = 0.0; [EOL] assertEquals(expected, result, 0.0); [EOL] } [EOL] public void testGetDoubleValueWithDoubleType() throws IOException, JsonParseException { [EOL] setupWithDoubleType(); [EOL] double result = getDoubleValue(); [EOL] double expected = 0.0; [EOL] assertEquals(expected, result, 0.0); [EOL] } [EOL] public void testGetDoubleValueWithNonDoubleType() throws IOException, JsonParseException { [EOL] setupWithNonDoubleType(); [EOL] double result = getDoubleValue(); [EOL] double expected = 0.0; [EOL] assertEquals(expected, result, 0.0); [EOL] }
public void testGetDecimalValueWithUnknownNumType() throws IOException, JsonParseException { [EOL] setNumTypesValid(NR_UNKNOWN); [EOL] setNumberBigDecimal(null); [EOL] BigDecimal result = getDecimalValue(); [EOL] assertNotNull(result); [EOL] }
public void testGetDecimalValueWithBigDecimalNumType() throws IOException, JsonParseException { [EOL] setNumTypesValid(NR_BIGDECIMAL); [EOL] BigDecimal expected = new BigDecimal("123.456"); [EOL] setNumberBigDecimal(expected); [EOL] BigDecimal result = getDecimalValue(); [EOL] assertSame(expected, result); [EOL] }
public void testGetDecimalValueWithNonBigDecimalNumType() throws IOException, JsonParseException { [EOL] setNumTypesValid(NR_INT); // Assuming NR_INT is a valid number type other than NR_BIGDECIMAL [EOL] setNumberBigDecimal(null); [EOL] BigDecimal result = getDecimalValue(); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof BigDecimal); [EOL] }
public void testParseNumericValueInt() throws IOException, JsonParseException { [EOL] _currToken = JsonToken.VALUE_NUMBER_INT; [EOL] _textBuffer.resetWithShared(new char[]{'1', '2', '3', '4', '5', '6', '7', '8', '9'}, 0, 9); [EOL] _intLength = 9; [EOL] _numberNegative = false; [EOL] _parseNumericValue(0); [EOL] assertEquals(NR_INT, _numTypesValid); [EOL] assertEquals(123456789, _numberInt); [EOL] }
public void testParseNumericValueIntNegative() throws IOException, JsonParseException { [EOL] _currToken = JsonToken.VALUE_NUMBER_INT; [EOL] _textBuffer.resetWithShared(new char[]{'-', '1', '2', '3', '4', '5', '6', '7', '8', '9'}, 0, 10); [EOL] _intLength = 9; [EOL] _numberNegative = true; [EOL] _parseNumericValue(0); [EOL] assertEquals(NR_INT, _numTypesValid); [EOL] assertEquals(-123456789, _numberInt); [EOL] }
public void testParseNumericValueLong() throws IOException, JsonParseException { [EOL] _currToken = JsonToken.VALUE_NUMBER_INT; [EOL] _textBuffer.resetWithShared(new char[]{'1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '1', '2', '3', '4', '5', '6', '7', '8'}, 0, 18); [EOL] _intLength = 18; [EOL] _numberNegative = false; [EOL] _parseNumericValue(0); [EOL] assertEquals(NR_LONG, _numTypesValid); [EOL] assertEquals(123456789012345678L, _numberLong); [EOL] }
public void testParseNumericValueLongEdgeCase() throws IOException, JsonParseException { [EOL] _currToken = JsonToken.VALUE_NUMBER_INT; [EOL] _textBuffer.resetWithShared(new char[]{'-', '2', '1', '4', '7', '4', '8', '3', '6', '4', '8'}, 0, 11); [EOL] _intLength = 10; [EOL] _numberNegative = true; [EOL] _parseNumericValue(0); [EOL] assertEquals(NR_INT, _numTypesValid); [EOL] assertEquals(Integer.MIN_VALUE, _numberInt); [EOL] }
public void testParseNumericValueFloat() throws IOException, JsonParseException { [EOL] _currToken = JsonToken.VALUE_NUMBER_FLOAT; [EOL] _parseNumericValue(0); [EOL] }
public void testParseNumericValueError() throws IOException, JsonParseException { [EOL] _currToken = JsonToken.NOT_AVAILABLE; [EOL] Exception exception = assertThrows(JsonParseException.class, () -> { [EOL] _parseNumericValue(0); [EOL] }); [EOL] assertTrue(exception.getMessage().contains("Current token (NOT_AVAILABLE) not numeric, can not use numeric value accessors")); [EOL] }
public void testParseSlowFloatValueWithBigDecimal() throws IOException, JsonParseException { [EOL] _initForTest(NR_BIGDECIMAL); // Assuming _initForTest is a method that initializes the object state for testing [EOL] _parseSlowFloatValue(NR_BIGDECIMAL); [EOL] assertNotNull(_numberBigDecimal); [EOL] assertEquals(NR_BIGDECIMAL, _numTypesValid); [EOL] }
public void testParseSlowFloatValueWithDouble() throws IOException, JsonParseException { [EOL] _initForTest(NR_DOUBLE); // Assuming _initForTest is a method that initializes the object state for testing [EOL] _parseSlowFloatValue(NR_DOUBLE); [EOL] assertNotNull(_numberDouble); [EOL] assertEquals(NR_DOUBLE, _numTypesValid); [EOL] }
public void testParseSlowFloatValueWithNumberFormatException() throws IOException, JsonParseException { [EOL] _initForTestWithMalformedInput(); // Assuming _initForTestWithMalformedInput is a method that sets up a malformed input [EOL] try { [EOL] _parseSlowFloatValue(NR_DOUBLE); [EOL] fail("Expected JsonParseException due to malformed numeric value"); [EOL] } catch (JsonParseException e) { [EOL] assertNotNull(e.getMessage()); [EOL] assertTrue(e.getMessage().contains("Malformed numeric value")); [EOL] } [EOL] }
public void testParseSlowIntValueWithLongRange() throws IOException, JsonParseException { [EOL] char[] buf = new char[]{'1', '2', '3', '4', '5', '6', '7', '8', '9', '0'}; [EOL] int offset = 0; [EOL] int len = 10; [EOL] int expType = 0; // Assuming expType is not used in the method body [EOL] boolean _numberNegative = false; // Assuming this is a class member variable [EOL] _parseSlowIntValue(expType, buf, offset, len); [EOL] assertEquals(NR_LONG, _numTypesValid); [EOL] assertEquals(1234567890L, _numberLong); [EOL] }
public void testParseSlowIntValueWithBigInt() throws IOException, JsonParseException { [EOL] char[] buf = new char[]{'9', '2', '3', '4', '5', '6', '7', '8', '9', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '0'}; [EOL] int offset = 0; [EOL] int len = 20; [EOL] int expType = 0; // Assuming expType is not used in the method body [EOL] boolean _numberNegative = false; // Assuming this is a class member variable [EOL] _parseSlowIntValue(expType, buf, offset, len); [EOL] assertEquals(NR_BIGINT, _numTypesValid); [EOL] assertEquals(new BigInteger("92345678901234567890"), _numberBigInt); [EOL] }
public void testParseSlowIntValueWithNumberFormatException() { [EOL] char[] buf = new char[]{'a'}; // Invalid number [EOL] int offset = 0; [EOL] int len = 1; [EOL] int expType = 0; // Assuming expType is not used in the method body [EOL] boolean _numberNegative = false; // Assuming this is a class member variable [EOL] try { [EOL] _parseSlowIntValue(expType, buf, offset, len); [EOL] fail("Expected JsonParseException due to NumberFormatException"); [EOL] } catch (JsonParseException e) { [EOL] } catch (IOException e) { [EOL] fail("Expected JsonParseException, not IOException"); [EOL] } [EOL] }
protected void convertNumberToLong() throws IOException, JsonParseException { [EOL] if ((_numTypesValid & NR_INT) != 0) { [EOL] _numberLong = (long) _numberInt; [EOL] } else if ((_numTypesValid & NR_BIGINT) != 0) { [EOL] if (BI_MIN_LONG.compareTo(_numberBigInt) > 0 || BI_MAX_LONG.compareTo(_numberBigInt) < 0) { [EOL] reportOverflowLong(); [EOL] } [EOL] _numberLong = _numberBigInt.longValue(); [EOL] } else if ((_numTypesValid & NR_DOUBLE) != 0) { [EOL] if (_numberDouble < MIN_LONG_D || _numberDouble > MAX_LONG_D) { [EOL] reportOverflowLong(); [EOL] } [EOL] _numberLong = (long) _numberDouble; [EOL] } else if ((_numTypesValid & NR_BIGDECIMAL) != 0) { [EOL] if (BD_MIN_LONG.compareTo(_numberBigDecimal) > 0 || BD_MAX_LONG.compareTo(_numberBigDecimal) < 0) { [EOL] reportOverflowLong(); [EOL] } [EOL] _numberLong = _numberBigDecimal.longValue(); [EOL] } else { [EOL] _throwInternal(); [EOL] } [EOL] _numTypesValid |= NR_LONG; [EOL] }
public void testConvertNumberToDoubleWithBigDecimal() throws IOException, JsonParseException { [EOL] _numTypesValid = NR_BIGDECIMAL; [EOL] _numberBigDecimal = new BigDecimal("123.456"); [EOL] convertNumberToDouble(); [EOL] assertEquals(123.456, _numberDouble, 0.0); [EOL] }
public void testConvertNumberToDoubleWithBigInt() throws IOException, JsonParseException { [EOL] _numTypesValid = NR_BIGINT; [EOL] _numberBigInt = new BigInteger("123456"); [EOL] convertNumberToDouble(); [EOL] assertEquals(123456.0, _numberDouble, 0.0); [EOL] }
public void testConvertNumberToDoubleWithLong() throws IOException, JsonParseException { [EOL] _numTypesValid = NR_LONG; [EOL] _numberLong = 123456789L; [EOL] convertNumberToDouble(); [EOL] assertEquals(123456789.0, _numberDouble, 0.0); [EOL] }
public void testConvertNumberToDoubleWithInt() throws IOException, JsonParseException { [EOL] _numTypesValid = NR_INT; [EOL] _numberInt = 123456; [EOL] convertNumberToDouble(); [EOL] assertEquals(123456.0, _numberDouble, 0.0); [EOL] }
public void testConvertNumberToDoubleWithInvalidType() throws IOException, JsonParseException { [EOL] _numTypesValid = 0; // No valid number types set [EOL] try { [EOL] convertNumberToDouble(); [EOL] fail("Expected JsonParseException"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testConvertNumberToBigDecimalWithDouble() throws IOException, JsonParseException { [EOL] _numTypesValid = NR_DOUBLE; [EOL] when(getText()).thenReturn("123.456"); [EOL] convertNumberToBigDecimal(); [EOL] assertEquals(new BigDecimal("123.456"), _numberBigDecimal); [EOL] assertTrue((_numTypesValid & NR_BIGDECIMAL) != 0); [EOL] }
public void testConvertNumberToBigDecimalWithBigInt() throws IOException, JsonParseException { [EOL] _numTypesValid = NR_BIGINT; [EOL] _numberBigInt = new BigInteger("12345678901234567890"); [EOL] convertNumberToBigDecimal(); [EOL] assertEquals(new BigDecimal(_numberBigInt), _numberBigDecimal); [EOL] assertTrue((_numTypesValid & NR_BIGDECIMAL) != 0); [EOL] }
public void testConvertNumberToBigDecimalWithLong() throws IOException, JsonParseException { [EOL] _numTypesValid = NR_LONG; [EOL] _numberLong = 1234567890123456789L; [EOL] convertNumberToBigDecimal(); [EOL] assertEquals(BigDecimal.valueOf(_numberLong), _numberBigDecimal); [EOL] assertTrue((_numTypesValid & NR_BIGDECIMAL) != 0); [EOL] }
public void testConvertNumberToBigDecimalWithInt() throws IOException, JsonParseException { [EOL] _numTypesValid = NR_INT; [EOL] _numberInt = 1234567890; [EOL] convertNumberToBigDecimal(); [EOL] assertEquals(BigDecimal.valueOf(_numberInt), _numberBigDecimal); [EOL] assertTrue((_numTypesValid & NR_BIGDECIMAL) != 0); [EOL] }
public void testConvertNumberToBigDecimalThrowsException() throws IOException, JsonParseException { [EOL] _numTypesValid = 0; [EOL] try { [EOL] convertNumberToBigDecimal(); [EOL] fail("Expected JsonParseException"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
protected final int _decodeBase64Escape(Base64Variant b64variant, int ch, int index) throws IOException, JsonParseException { [EOL] if (ch != '\\') { [EOL] throw reportInvalidBase64Char(b64variant, ch, index); [EOL] } [EOL] int unescaped = _decodeEscaped(); [EOL] if (unescaped <= INT_SPACE) { [EOL] if (index == 0) { [EOL] return -1; [EOL] } [EOL] } [EOL] int bits = b64variant.decodeBase64Char(unescaped); [EOL] if (bits < 0) { [EOL] throw reportInvalidBase64Char(b64variant, unescaped, index); [EOL] } [EOL] return bits; [EOL] }
public void testDecodeBase64EscapeWithNonBackslashChar() throws IOException, JsonParseException { [EOL] Base64Variant b64variant = Base64Variants.getDefaultVariant(); [EOL] char ch = 'a'; [EOL] int index = 0; [EOL] try { [EOL] _decodeBase64Escape(b64variant, ch, index); [EOL] fail("Should not pass, expected an exception to be thrown."); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testDecodeBase64EscapeWithBackslashAndSpaceChar() throws IOException, JsonParseException { [EOL] Base64Variant b64variant = Base64Variants.getDefaultVariant(); [EOL] char ch = '\\'; [EOL] int index = 0; [EOL] when(_decodeEscaped()).thenReturn(' '); [EOL] int result = _decodeBase64Escape(b64variant, ch, index); [EOL] assertEquals(-1, result); [EOL] }
public void testDecodeBase64EscapeWithBackslashAndInvalidBase64Char() throws IOException, JsonParseException { [EOL] Base64Variant b64variant = Base64Variants.getDefaultVariant(); [EOL] char ch = '\\'; [EOL] int index = 1; [EOL] char unescaped = '!'; [EOL] when(_decodeEscaped()).thenReturn(unescaped); [EOL] try { [EOL] _decodeBase64Escape(b64variant, ch, index); [EOL] fail("Should not pass, expected an exception to be thrown."); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testDecodeBase64EscapeWithBackslashAndValidBase64Char() throws IOException, JsonParseException { [EOL] Base64Variant b64variant = Base64Variants.getDefaultVariant(); [EOL] char ch = '\\'; [EOL] int index = 1; [EOL] char unescaped = 'A'; // Assuming 'A' is a valid base64 character [EOL] int expectedBits = 0; // Assuming 'A' decodes to 0 [EOL] when(_decodeEscaped()).thenReturn(unescaped); [EOL] when(b64variant.decodeBase64Char(unescaped)).thenReturn(expectedBits); [EOL] int result = _decodeBase64Escape(b64variant, ch, index); [EOL] assertEquals(expectedBits, result); [EOL] }
public void testBytesToNameCanonicalizerWithMinHashSize() { [EOL] int hashSize = BytesToNameCanonicalizer.MIN_HASH_SIZE; [EOL] boolean intern = false; [EOL] int seed = 0; [EOL] BytesToNameCanonicalizer bnc = new BytesToNameCanonicalizer(hashSize, intern, seed); [EOL] assertNotNull(bnc); [EOL] } [EOL] public void testBytesToNameCanonicalizerWithLessThanMinHashSize() { [EOL] int hashSize = BytesToNameCanonicalizer.MIN_HASH_SIZE - 1; [EOL] boolean intern = false; [EOL] int seed = 0; [EOL] BytesToNameCanonicalizer bnc = new BytesToNameCanonicalizer(hashSize, intern, seed); [EOL] assertNotNull(bnc); [EOL] } [EOL] public void testBytesToNameCanonicalizerWithNonPowerOfTwoHashSize() { [EOL] int hashSize = 3; // Any non-power of two greater than MIN_HASH_SIZE [EOL] boolean intern = false; [EOL] int seed = 0; [EOL] BytesToNameCanonicalizer bnc = new BytesToNameCanonicalizer(hashSize, intern, seed); [EOL] assertNotNull(bnc); [EOL] } [EOL] public void testBytesToNameCanonicalizerWithPowerOfTwoHashSize() { [EOL] int hashSize = 4; // Any power of two greater than MIN_HASH_SIZE [EOL] boolean intern = false; [EOL] int seed = 0; [EOL] BytesToNameCanonicalizer bnc = new BytesToNameCanonicalizer(hashSize, intern, seed); [EOL] assertNotNull(bnc); [EOL] } [EOL] public void testBytesToNameCanonicalizerWithInternTrue() { [EOL] int hashSize = BytesToNameCanonicalizer.MIN_HASH_SIZE; [EOL] boolean intern = true; [EOL] int seed = 0; [EOL] BytesToNameCanonicalizer bnc = new BytesToNameCanonicalizer(hashSize, intern, seed); [EOL] assertNotNull(bnc); [EOL] } [EOL] public void testBytesToNameCanonicalizerWithDifferentSeeds() { [EOL] int hashSize = BytesToNameCanonicalizer.MIN_HASH_SIZE; [EOL] boolean intern = false; [EOL] int seed = 1; [EOL] BytesToNameCanonicalizer bnc1 = new BytesToNameCanonicalizer(hashSize, intern, seed); [EOL] seed = 2; [EOL] BytesToNameCanonicalizer bnc2 = new BytesToNameCanonicalizer(hashSize, intern, seed); [EOL] assertNotNull(bnc1); [EOL] assertNotNull(bnc2); [EOL] assertNotEquals(bnc1._hashSeed, bnc2._hashSeed); [EOL] }
public void testBytesToNameCanonicalizerConstructor() { [EOL] BytesToNameCanonicalizer parent = null; // Assuming a constructor or a method to obtain a parent instance [EOL] boolean intern = true; [EOL] int seed = 1; [EOL] BytesToNameCanonicalizer.TableInfo state = new BytesToNameCanonicalizer.TableInfo(); // Assuming a constructor or a method to obtain a TableInfo instance [EOL] state.count = 10; [EOL] state.mainHashMask = 0xFF; [EOL] state.mainHash = new int[256]; [EOL] state.mainNames = new Name[256]; [EOL] state.collList = new LinkedList<>(); [EOL] state.collCount = 5; [EOL] state.collEnd = 3; [EOL] state.longestCollisionList = 2; [EOL] BytesToNameCanonicalizer canonicalizer = new BytesToNameCanonicalizer(parent, intern, seed, state); [EOL] assertNotNull(canonicalizer); [EOL] assertEquals(parent, canonicalizer._parent); [EOL] assertEquals(seed, canonicalizer._hashSeed); [EOL] assertEquals(intern, canonicalizer._intern); [EOL] assertNull(canonicalizer._tableInfo); [EOL] assertEquals(10, canonicalizer._count); [EOL] assertEquals(0xFF, canonicalizer._mainHashMask); [EOL] assertArrayEquals(state.mainHash, canonicalizer._mainHash); [EOL] assertArrayEquals(state.mainNames, canonicalizer._mainNames); [EOL] assertEquals(state.collList, canonicalizer._collList); [EOL] assertEquals(5, canonicalizer._collCount); [EOL] assertEquals(3, canonicalizer._collEnd); [EOL] assertEquals(2, canonicalizer._longestCollisionList); [EOL] assertFalse(canonicalizer._needRehash); [EOL] assertTrue(canonicalizer._mainHashShared); [EOL] assertTrue(canonicalizer._mainNamesShared); [EOL] assertTrue(canonicalizer._collListShared); [EOL] }
public void testInitTableInfoWithPositiveHashSize() { [EOL] int hashSize = 10; [EOL] TableInfo result = initTableInfo(hashSize); [EOL] assertNotNull(result); [EOL] assertEquals(hashSize - 1, result.getMaxBucketIndex()); [EOL] assertNotNull(result.getBucketSizes()); [EOL] assertEquals(hashSize, result.getBucketSizes().length); [EOL] assertNotNull(result.getNames()); [EOL] assertEquals(hashSize, result.getNames().length); [EOL] assertNull(result.getSpilloverEnd()); [EOL] assertEquals(0, result.getSpilloverStart()); [EOL] assertEquals(0, result.getLongestCollisionList()); [EOL] assertEquals(0, result.getModCount()); [EOL] }
public void testInitTableInfoWithMinimumHashSize() { [EOL] int hashSize = 1; [EOL] TableInfo result = initTableInfo(hashSize); [EOL] assertNotNull(result); [EOL] assertEquals(0, result.getMaxBucketIndex()); // hashSize - 1 = 0 [EOL] assertNotNull(result.getBucketSizes()); [EOL] assertEquals(1, result.getBucketSizes().length); [EOL] assertNotNull(result.getNames()); [EOL] assertEquals(1, result.getNames().length); [EOL] assertNull(result.getSpilloverEnd()); [EOL] assertEquals(0, result.getSpilloverStart()); [EOL] assertEquals(0, result.getLongestCollisionList()); [EOL] assertEquals(0, result.getModCount()); [EOL] }
public void testCreateRoot() { [EOL] BytesToNameCanonicalizer btc1 = BytesToNameCanonicalizer.createRoot(); [EOL] assertNotNull(btc1); [EOL] BytesToNameCanonicalizer btc2 = BytesToNameCanonicalizer.createRoot(); [EOL] assertNotNull(btc2); [EOL] assertNotSame(btc1, btc2); [EOL] }
protected static BytesToNameCanonicalizer createRoot(int hashSeed) { [EOL] return new BytesToNameCanonicalizer(DEFAULT_TABLE_SIZE, true, hashSeed); [EOL] }
public void testMakeChildWithCanonicalizeAndIntern() { [EOL] BytesToNameCanonicalizer parent = new BytesToNameCanonicalizer(16); [EOL] BytesToNameCanonicalizer child = parent.makeChild(true, true); [EOL] assertNotNull(child); [EOL] assertTrue(child.isCanonicalizing()); [EOL] assertTrue(child.isInterning()); [EOL] }
public void testMakeChildWithoutCanonicalizeAndIntern() { [EOL] BytesToNameCanonicalizer parent = new BytesToNameCanonicalizer(16); [EOL] BytesToNameCanonicalizer child = parent.makeChild(false, false); [EOL] assertNotNull(child); [EOL] assertFalse(child.isCanonicalizing()); [EOL] assertFalse(child.isInterning()); [EOL] }
public void testReleaseWithNonNullParentAndDirty() { [EOL] MyClass instance = new MyClass(parentMock); [EOL] instance.makeDirty(); // This method should make maybeDirty() return true [EOL] instance.release(); [EOL] verify(parentMock).mergeChild(any(TableInfo.class)); // Assuming we can verify interactions with a mock [EOL] assertTrue(instance.isMainHashShared()); [EOL] assertTrue(instance.isMainNamesShared()); [EOL] assertTrue(instance.isCollListShared()); [EOL] }
public void testReleaseWithNonNullParentAndNotDirty() { [EOL] MyClass instance = new MyClass(parentMock); [EOL] instance.release(); [EOL] verify(parentMock, never()).mergeChild(any(TableInfo.class)); // Assuming we can verify interactions with a mock [EOL] assertFalse(instance.isMainHashShared()); [EOL] assertFalse(instance.isMainNamesShared()); [EOL] assertFalse(instance.isCollListShared()); [EOL] }
public void testReleaseWithNullParent() { [EOL] MyClass instance = new MyClass(null); [EOL] instance.release(); [EOL] assertFalse(instance.isMainHashShared()); [EOL] assertFalse(instance.isMainNamesShared()); [EOL] assertFalse(instance.isCollListShared()); [EOL] }
public void testMergeChildWithChildCountLessThanOrEqualToCurrentCount() { [EOL] TableInfo childState = new TableInfo(); [EOL] childState.count = 5; [EOL] AtomicReference<TableInfo> tableInfo = new AtomicReference<>(new TableInfo()); [EOL] tableInfo.get().count = 10; [EOL] JacksonCore instance = new JacksonCore(tableInfo); [EOL] instance.mergeChild(childState); [EOL] assertEquals("Expected count should not change when child count is less than or equal to current count", 10, tableInfo.get().count); [EOL] }
public void testMergeChildWithChildCountGreaterThanCurrentCountAndNotExceedingMaxEntries() { [EOL] TableInfo childState = new TableInfo(); [EOL] childState.count = 15; [EOL] childState.longestCollisionList = 5; [EOL] AtomicReference<TableInfo> tableInfo = new AtomicReference<>(new TableInfo()); [EOL] tableInfo.get().count = 10; [EOL] JacksonCore instance = new JacksonCore(tableInfo); [EOL] instance.mergeChild(childState); [EOL] assertEquals("Expected count should be updated to child count", 15, tableInfo.get().count); [EOL] }
public void testMergeChildWithChildCountGreaterThanMaxEntries() { [EOL] TableInfo childState = new TableInfo(); [EOL] childState.count = JacksonCore.MAX_ENTRIES_FOR_REUSE + 1; [EOL] childState.longestCollisionList = 5; [EOL] AtomicReference<TableInfo> tableInfo = new AtomicReference<>(new TableInfo()); [EOL] tableInfo.get().count = 10; [EOL] JacksonCore instance = new JacksonCore(tableInfo); [EOL] instance.mergeChild(childState); [EOL] assertNotEquals("Expected count should not be the same as child count when exceeding max entries", childState.count, tableInfo.get().count); [EOL] assertEquals("Expected count should be reset to default table size", JacksonCore.DEFAULT_TABLE_SIZE, tableInfo.get().count); [EOL] }
public void testMergeChildWithChildLongestCollisionListGreaterThanMaxChainForReuse() { [EOL] TableInfo childState = new TableInfo(); [EOL] childState.count = 15; [EOL] childState.longestCollisionList = JacksonCore.MAX_COLL_CHAIN_FOR_REUSE + 1; [EOL] AtomicReference<TableInfo> tableInfo = new AtomicReference<>(new TableInfo()); [EOL] tableInfo.get().count = 10; [EOL] JacksonCore instance = new JacksonCore(tableInfo); [EOL] instance.mergeChild(childState); [EOL] assertNotEquals("Expected longest collision list should not be the same as child's when exceeding max chain for reuse", childState.longestCollisionList, tableInfo.get().longestCollisionList); [EOL] assertEquals("Expected count should be reset to default table size", JacksonCore.DEFAULT_TABLE_SIZE, tableInfo.get().count); [EOL] }
public void testMaybeDirtyWhenMainHashSharedIsTrue() { [EOL] JsonFactory factory = new JsonFactory(); [EOL] factory._mainHashShared = true; [EOL] assertFalse(factory.maybeDirty()); [EOL] }
public void testMaybeDirtyWhenMainHashSharedIsFalse() { [EOL] JsonFactory factory = new JsonFactory(); [EOL] factory._mainHashShared = false; [EOL] assertTrue(factory.maybeDirty()); [EOL] }
public void testGetEmptyName() { [EOL] Name result = JacksonCore.getEmptyName(); [EOL] assertNotNull(result); [EOL] assertTrue(result.isEmpty()); [EOL] }
public void testFindNameWithNullName() { [EOL] _mainNames[someIndex] = null; [EOL] _mainHash[someIndex] = (calcHash(firstQuadValue) & _mainHashMask) << 8; // Ensure the hash matches the condition [EOL] Name result = findName(firstQuadValue); [EOL] assertNull(result); [EOL] }
public void testFindNameWithEqualName() { [EOL] Name expectedName = new Name(firstQuadValue); [EOL] _mainNames[someIndex] = expectedName; [EOL] _mainHash[someIndex] = (calcHash(firstQuadValue) & _mainHashMask) << 8; // Ensure the hash matches the condition [EOL] Name result = findName(firstQuadValue); [EOL] assertEquals(expectedName, result); [EOL] }
public void testFindNameWithNonEmptyBucket() { [EOL] Bucket bucket = new Bucket(); [EOL] bucket.add(new Name(firstQuadValue)); [EOL] _collList[someIndex] = bucket; [EOL] _mainHash[someIndex] = ((calcHash(firstQuadValue) & _mainHashMask) << 8) | 1; // Set the last byte to non-zero to indicate a non-empty bucket [EOL] Name result = findName(firstQuadValue); [EOL] assertEquals(new Name(firstQuadValue), result); [EOL] }
public void testFindNameWithEmptyMainHash() { [EOL] _mainHash[someIndex] = 0; [EOL] Name result = findName(firstQuadValue); [EOL] assertNull(result); [EOL] }
public void testFindNameWithSecondQuadZeroAndNameNotFound() { [EOL] int firstQuad = 1; [EOL] int secondQuad = 0; [EOL] Name result = findName(firstQuad, secondQuad); [EOL] assertNull(result); [EOL] }
public void testFindNameWithSecondQuadNonZeroAndNameFound() { [EOL] int firstQuad = 1; [EOL] int secondQuad = 2; [EOL] Name result = findName(firstQuad, secondQuad); [EOL] assertNotNull(result); [EOL] assertTrue(result.equals(firstQuad, secondQuad)); [EOL] }
public void testFindNameWithSecondQuadNonZeroAndNameNotFoundInMain() { [EOL] int firstQuad = 1; [EOL] int secondQuad = 2; [EOL] Name result = findName(firstQuad, secondQuad); [EOL] assertNull(result); [EOL] }
public void testFindNameWithSecondQuadNonZeroAndBucketNotNull() { [EOL] int firstQuad = 1; [EOL] int secondQuad = 2; [EOL] Name result = findName(firstQuad, secondQuad); [EOL] assertNotNull(result); [EOL] assertTrue(result.equals(firstQuad, secondQuad)); [EOL] }
public void testFindNameWithLessThanThreeQuads() { [EOL] int[] quads = {1}; [EOL] int qlen = 1; [EOL] Name result = findName(quads, qlen); [EOL] }
public void testFindNameWithHashCollisionAndNameMatch() { [EOL] int[] quads = {1, 2, 3}; [EOL] int qlen = 3; [EOL] Name result = findName(quads, qlen); [EOL] }
public void testFindNameWithHashCollisionAndNameNotMatch() { [EOL] int[] quads = {1, 2, 3}; [EOL] int qlen = 3; [EOL] Name result = findName(quads, qlen); [EOL] }
public void testFindNameWithEmptyMainHashSlot() { [EOL] int[] quads = {1, 2, 3}; [EOL] int qlen = 3; [EOL] Name result = findName(quads, qlen); [EOL] }
public void testFindNameWithNonEmptyBucket() { [EOL] int[] quads = {1, 2, 3}; [EOL] int qlen = 3; [EOL] Name result = findName(quads, qlen); [EOL] }
public void testFindNameWithEmptyBucket() { [EOL] int[] quads = {1, 2, 3}; [EOL] int qlen = 3; [EOL] Name result = findName(quads, qlen); [EOL] }
public void testAddNameWithIntern() { [EOL] String symbolStr = "testSymbol"; [EOL] int[] quads = {0}; [EOL] int qlen = 1; [EOL] boolean intern = true; [EOL] NameTable nameTable = new NameTable(intern); [EOL] Name result = nameTable.addName(symbolStr, quads, qlen); [EOL] assertNotNull(result); [EOL] assertEquals(symbolStr, result.getName()); [EOL] assertTrue(result.toString().contains("testSymbol")); [EOL] }
public void testAddNameWithoutIntern() { [EOL] String symbolStr = "testSymbol"; [EOL] int[] quads = {0, 1}; [EOL] int qlen = 2; [EOL] boolean intern = false; [EOL] NameTable nameTable = new NameTable(intern); [EOL] Name result = nameTable.addName(symbolStr, quads, qlen); [EOL] assertNotNull(result); [EOL] assertEquals(symbolStr, result.getName()); [EOL] assertTrue(result.toString().contains("testSymbol")); [EOL] }
public void testAddNameWithMultipleQuads() { [EOL] String symbolStr = "testSymbol"; [EOL] int[] quads = {0, 1, 2}; [EOL] int qlen = 3; [EOL] boolean intern = false; [EOL] NameTable nameTable = new NameTable(intern); [EOL] Name result = nameTable.addName(symbolStr, quads, qlen); [EOL] assertNotNull(result); [EOL] assertEquals(symbolStr, result.getName()); [EOL] assertTrue(result.toString().contains("testSymbol")); [EOL] }
public void testCalcHashWithZero() { [EOL] int firstQuad = 0; [EOL] int result = calcHash(firstQuad); [EOL] assertEquals(result, _hashSeed); [EOL] }
public void testCalcHashWithMaxInt() { [EOL] int firstQuad = Integer.MAX_VALUE; [EOL] int result = calcHash(firstQuad); [EOL] int expected = Integer.MAX_VALUE ^ _hashSeed; [EOL] expected += (expected >>> 15); [EOL] expected ^= (expected >>> 9); [EOL] assertEquals(result, expected); [EOL] }
public void testCalcHashWithMinInt() { [EOL] int firstQuad = Integer.MIN_VALUE; [EOL] int result = calcHash(firstQuad); [EOL] int expected = Integer.MIN_VALUE ^ _hashSeed; [EOL] expected += (expected >>> 15); [EOL] expected ^= (expected >>> 9); [EOL] assertEquals(result, expected); [EOL] }
private void _addSymbol(int hash, Name symbol) { [EOL] if (_mainHashShared) { [EOL] unshareMain(); [EOL] } [EOL] if (_needRehash) { [EOL] rehash(); [EOL] } [EOL] ++_count; [EOL] int ix = (hash & _mainHashMask); [EOL] if (_mainNames[ix] == null) { [EOL] _mainHash[ix] = (hash << 8); [EOL] if (_mainNamesShared) { [EOL] unshareNames(); [EOL] } [EOL] _mainNames[ix] = symbol; [EOL] } else { [EOL] if (_collListShared) { [EOL] unshareCollision(); [EOL] } [EOL] ++_collCount; [EOL] int entryValue = _mainHash[ix]; [EOL] int bucket = entryValue & 0xFF; [EOL] if (bucket == 0) { [EOL] if (_collEnd <= LAST_VALID_BUCKET) { [EOL] bucket = _collEnd; [EOL] ++_collEnd; [EOL] if (bucket >= _collList.length) { [EOL] expandCollision(); [EOL] } [EOL] } else { [EOL] bucket = findBestBucket(); [EOL] } [EOL] _mainHash[ix] = (entryValue & ~0xFF) | (bucket + 1); [EOL] } else { [EOL] --bucket; [EOL] } [EOL] Bucket newB = new Bucket(symbol, _collList[bucket]); [EOL] _collList[bucket] = newB; [EOL] _longestCollisionList = Math.max(newB.length(), _longestCollisionList); [EOL] if (_longestCollisionList > MAX_COLL_CHAIN_LENGTH) { [EOL] reportTooManyCollisions(MAX_COLL_CHAIN_LENGTH); [EOL] } [EOL] } [EOL] { [EOL] int hashSize = _mainHash.length; [EOL] if (_count > (hashSize >> 1)) { [EOL] int hashQuarter = (hashSize >> 2); [EOL] if (_count > (hashSize - hashQuarter)) { [EOL] _needRehash = true; [EOL] } else if (_collCount >= hashQuarter) { [EOL] _needRehash = true; [EOL] } [EOL] } [EOL] } [EOL] }
private void rehash() { [EOL] _needRehash = false; [EOL] _mainNamesShared = false; [EOL] int[] oldMainHash = _mainHash; [EOL] int len = oldMainHash.length; [EOL] int newLen = len + len; [EOL] if (newLen > MAX_TABLE_SIZE) { [EOL] nukeSymbols(); [EOL] return; [EOL] } [EOL] _mainHash = new int[newLen]; [EOL] _mainHashMask = (newLen - 1); [EOL] Name[] oldNames = _mainNames; [EOL] _mainNames = new Name[newLen]; [EOL] int symbolsSeen = 0; [EOL] for (int i = 0; i < len; ++i) { [EOL] Name symbol = oldNames[i]; [EOL] if (symbol != null) { [EOL] ++symbolsSeen; [EOL] int hash = symbol.hashCode(); [EOL] int ix = (hash & _mainHashMask); [EOL] _mainNames[ix] = symbol; [EOL] _mainHash[ix] = hash << 8; [EOL] } [EOL] } [EOL] int oldEnd = _collEnd; [EOL] if (oldEnd == 0) { [EOL] _longestCollisionList = 0; [EOL] return; [EOL] } [EOL] _collCount = 0; [EOL] _collEnd = 0; [EOL] _collListShared = false; [EOL] int maxColl = 0; [EOL] Bucket[] oldBuckets = _collList; [EOL] _collList = new Bucket[oldBuckets.length]; [EOL] for (int i = 0; i < oldEnd; ++i) { [EOL] for (Bucket curr = oldBuckets[i]; curr != null; curr = curr._next) { [EOL] ++symbolsSeen; [EOL] Name symbol = curr._name; [EOL] int hash = symbol.hashCode(); [EOL] int ix = (hash & _mainHashMask); [EOL] int val = _mainHash[ix]; [EOL] if (_mainNames[ix] == null) { [EOL] _mainHash[ix] = (hash << 8); [EOL] _mainNames[ix] = symbol; [EOL] } else { [EOL] ++_collCount; [EOL] int bucket = val & 0xFF; [EOL] if (bucket == 0) { [EOL] if (_collEnd <= LAST_VALID_BUCKET) { [EOL] bucket = _collEnd; [EOL] ++_collEnd; [EOL] if (bucket >= _collList.length) { [EOL] expandCollision(); [EOL] } [EOL] } else { [EOL] bucket = findBestBucket(); [EOL] } [EOL] _mainHash[ix] = (val & ~0xFF) | (bucket + 1); [EOL] } else { [EOL] --bucket; [EOL] } [EOL] Bucket newB = new Bucket(symbol, _collList[bucket]); [EOL] _collList[bucket] = newB; [EOL] maxColl = Math.max(maxColl, newB.length()); [EOL] } [EOL] } [EOL] } [EOL] _longestCollisionList = maxColl; [EOL] if (symbolsSeen != _count) { [EOL] throw new RuntimeException("Internal error: count after rehash " + symbolsSeen + "; should be " + _count); [EOL] } [EOL] }
public void testUnshareMain() { [EOL] MyClassUnderTest testInstance = new MyClassUnderTest(); [EOL] testInstance._mainHash = new int[]{1, 2, 3}; [EOL] testInstance._mainHashShared = true; [EOL] testInstance.unshareMain(); [EOL] assertFalse(testInstance._mainHashShared); [EOL] assertNotSame(testInstance._mainHash, new int[]{1, 2, 3}); [EOL] assertEquals(testInstance._mainHash.length, 3); [EOL] assertEquals(testInstance._mainHash[0], 1); [EOL] assertEquals(testInstance._mainHash[1], 2); [EOL] assertEquals(testInstance._mainHash[2], 3); [EOL] }
private void unshareNames() { [EOL] final Name[] old = _mainNames; [EOL] _mainNames = Arrays.copyOf(old, old.length); [EOL] _mainNamesShared = false; [EOL] }
public void testConstructNameWithOneQuad() { [EOL] int hash = 1; [EOL] String name = "test"; [EOL] int[] quads = {0}; [EOL] int qlen = 1; [EOL] Name result = constructName(hash, name, quads, qlen); [EOL] assertTrue(result instanceof Name1); [EOL] assertEquals(name, result.getName()); [EOL] assertEquals(hash, result.hashCode()); [EOL] assertEquals(quads[0], result.getQuad(0)); [EOL] }
public void testConstructNameWithTwoQuads() { [EOL] int hash = 2; [EOL] String name = "test"; [EOL] int[] quads = {0, 1}; [EOL] int qlen = 2; [EOL] Name result = constructName(hash, name, quads, qlen); [EOL] assertTrue(result instanceof Name2); [EOL] assertEquals(name, result.getName()); [EOL] assertEquals(hash, result.hashCode()); [EOL] assertEquals(quads[0], result.getQuad(0)); [EOL] assertEquals(quads[1], result.getQuad(1)); [EOL] }
public void testConstructNameWithThreeQuads() { [EOL] int hash = 3; [EOL] String name = "test"; [EOL] int[] quads = {0, 1, 2}; [EOL] int qlen = 3; [EOL] Name result = constructName(hash, name, quads, qlen); [EOL] assertTrue(result instanceof Name3); [EOL] assertEquals(name, result.getName()); [EOL] assertEquals(hash, result.hashCode()); [EOL] assertEquals(quads[0], result.getQuad(0)); [EOL] assertEquals(quads[1], result.getQuad(1)); [EOL] assertEquals(quads[2], result.getQuad(2)); [EOL] }
public void testConstructNameWithMoreThanThreeQuads() { [EOL] int hash = 4; [EOL] String name = "test"; [EOL] int[] quads = {0, 1, 2, 3}; [EOL] int qlen = 4; [EOL] Name result = constructName(hash, name, quads, qlen); [EOL] assertTrue(result instanceof NameN); [EOL] assertEquals(name, result.getName()); [EOL] assertEquals(hash, result.hashCode()); [EOL] for (int i = 0; i < qlen; i++) { [EOL] assertEquals(quads[i], result.getQuad(i)); [EOL] } [EOL] }
public void testTableInfoConstructor() { [EOL] int count = 10; [EOL] int mainHashMask = 20; [EOL] int[] mainHash = new int[] {1, 2, 3}; [EOL] Name[] mainNames = new Name[] {null, null, null}; [EOL] Bucket[] collList = new Bucket[] {null, null, null}; [EOL] int collCount = 5; [EOL] int collEnd = 7; [EOL] int longestCollisionList = 3; [EOL] TableInfo tableInfo = new TableInfo(count, mainHashMask, mainHash, mainNames, collList, collCount, collEnd, longestCollisionList); [EOL] assertEquals(count, tableInfo.count); [EOL] assertEquals(mainHashMask, tableInfo.mainHashMask); [EOL] assertArrayEquals(mainHash, tableInfo.mainHash); [EOL] assertArrayEquals(mainNames, tableInfo.mainNames); [EOL] assertArrayEquals(collList, tableInfo.collList); [EOL] assertEquals(collCount, tableInfo.collCount); [EOL] assertEquals(collEnd, tableInfo.collEnd); [EOL] assertEquals(longestCollisionList, tableInfo.longestCollisionList); [EOL] }
public void testTableInfoConstructor() { [EOL] BytesToNameCanonicalizer src = new BytesToNameCanonicalizer(16); [EOL] TableInfo info = new TableInfo(src); [EOL] assertEquals(src._count, info.count); [EOL] assertEquals(src._mainHashMask, info.mainHashMask); [EOL] assertArrayEquals(src._mainHash, info.mainHash); [EOL] assertArrayEquals(src._mainNames, info.mainNames); [EOL] assertEquals(src._collList, info.collList); [EOL] assertEquals(src._collCount, info.collCount); [EOL] assertEquals(src._collEnd, info.collEnd); [EOL] assertEquals(src._longestCollisionList, info.longestCollisionList); [EOL] }
public void testStdConstructorWithNonNullInputStreamAndBuffer() { [EOL] InputStream in = new ByteArrayInputStream(new byte[]{}); [EOL] byte[] buffer = new byte[10]; [EOL] Std std = new Std(in, buffer); [EOL] assertNotNull(std._in); [EOL] assertSame(in, std._in); [EOL] assertNotNull(std._buffer); [EOL] assertSame(buffer, std._buffer); [EOL] assertEquals(0, std._bufferedStart); [EOL] assertEquals(0, std._ptr); [EOL] assertEquals(0, std._bufferedEnd); [EOL] }
public void testHasMoreBytes_PtrLessThanBufferedEnd() throws IOException { [EOL] _ptr = 0; [EOL] _bufferedEnd = 10; [EOL] boolean result = hasMoreBytes(); [EOL] assertTrue(result); [EOL] }
public void testHasMoreBytes_InIsNull() throws IOException { [EOL] _ptr = 10; [EOL] _bufferedEnd = 10; [EOL] _in = null; [EOL] boolean result = hasMoreBytes(); [EOL] assertFalse(result); [EOL] }
public void testHasMoreBytes_AmountLessThanOne() throws IOException { [EOL] _ptr = _buffer.length; [EOL] _bufferedEnd = _buffer.length; [EOL] _in = mock(InputStream.class); [EOL] boolean result = hasMoreBytes(); [EOL] assertFalse(result); [EOL] }
public void testHasMoreBytes_CountLessThanOrEqualToZero() throws IOException { [EOL] _ptr = 5; [EOL] _bufferedEnd = 10; [EOL] _buffer = new byte[10]; [EOL] _in = mock(InputStream.class); [EOL] when(_in.read(_buffer, _ptr, _buffer.length - _ptr)).thenReturn(0); [EOL] boolean result = hasMoreBytes(); [EOL] assertFalse(result); [EOL] }
public void testHasMoreBytes_CountGreaterThanZero() throws IOException { [EOL] _ptr = 5; [EOL] _bufferedEnd = 5; [EOL] _buffer = new byte[10]; [EOL] _in = mock(InputStream.class); [EOL] when(_in.read(_buffer, _ptr, _buffer.length - _ptr)).thenReturn(5); [EOL] boolean result = hasMoreBytes(); [EOL] assertTrue(result); [EOL] }
public void testNextByteWithBufferNotEmpty() throws IOException { [EOL] _ptr = 0; [EOL] _bufferedEnd = 10; [EOL] _buffer = new byte[_bufferedEnd]; [EOL] Arrays.fill(_buffer, (byte) 1); [EOL] byte result = nextByte(); [EOL] assertEquals("The byte read should be 1", 1, result); [EOL] assertEquals("The pointer should be incremented", 1, _ptr); [EOL] }
public void testNextByteWithBufferEmptyAndHasMoreBytes() throws IOException { [EOL] _ptr = 0; [EOL] _bufferedEnd = 0; [EOL] _buffer = new byte[10]; [EOL] Arrays.fill(_buffer, (byte) 1); [EOL] when(hasMoreBytes()).thenReturn(true); [EOL] _bufferedEnd = 10; [EOL] byte result = nextByte(); [EOL] assertEquals("The byte read should be 1", 1, result); [EOL] assertEquals("The pointer should be incremented", 1, _ptr); [EOL] }
public void testNextByteWithBufferEmptyAndNoMoreBytes() { [EOL] _ptr = 0; [EOL] _bufferedEnd = 0; [EOL] _buffer = new byte[10]; [EOL] when(hasMoreBytes()).thenReturn(false); [EOL] assertThrows(EOFException.class, this::nextByte); [EOL] }
public void testReset() { [EOL] JsonParser jp = createParser(); [EOL] jp.nextToken(); [EOL] int bufferedStartBefore = jp._bufferedStart; [EOL] jp.reset(); [EOL] assertEquals(bufferedStartBefore, jp._ptr); [EOL] }
public void testCreateMatcherWithNonNullValues() { [EOL] InputStream in = new ByteArrayInputStream(new byte[0]); [EOL] byte[] buffer = new byte[10]; [EOL] JsonFactory jsonFactory = new JsonFactory(); [EOL] MatchStrength matchStrength = MatchStrength.SOLID_MATCH; [EOL] DataFormatMatcher matcher = createMatcher(jsonFactory, matchStrength); [EOL] assertNotNull(matcher); [EOL] assertEquals(jsonFactory, matcher.getFactory()); [EOL] assertEquals(matchStrength, matcher.getMatchStrength()); [EOL] }
public void testCreateMatcherWithNullValues() { [EOL] InputStream in = null; [EOL] byte[] buffer = null; [EOL] JsonFactory jsonFactory = null; [EOL] MatchStrength matchStrength = null; [EOL] DataFormatMatcher matcher = createMatcher(jsonFactory, matchStrength); [EOL] assertNotNull(matcher); [EOL] assertNull(matcher.getFactory()); [EOL] assertNull(matcher.getMatchStrength()); [EOL] }
public void testAllocByteBufferWithNullBuffer() { [EOL] ByteBufferType type = ByteBufferType.SOME_TYPE; // Replace SOME_TYPE with an actual type from the enum [EOL] byte[] result = allocByteBuffer(type); [EOL] assertNotNull(result); [EOL] assertEquals(type.size, result.length); [EOL] }
public void testAllocByteBufferWithExistingBuffer() { [EOL] ByteBufferType type = ByteBufferType.SOME_TYPE; // Replace SOME_TYPE with an actual type from the enum [EOL] _byteBuffers[type.ordinal()] = new byte[type.size]; // Pre-populate the buffer [EOL] byte[] result = allocByteBuffer(type); [EOL] assertNotNull(result); [EOL] assertNull(_byteBuffers[type.ordinal()]); // The buffer should be set to null after allocation [EOL] assertEquals(type.size, result.length); [EOL] }
public void testReleaseByteBufferWithNullType() { [EOL] JsonFactory factory = new JsonFactory(); [EOL] try { [EOL] factory.releaseByteBuffer(null, new byte[10]); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testReleaseByteBufferWithNonNullTypeAndBuffer() { [EOL] JsonFactory factory = new JsonFactory(); [EOL] byte[] buffer = new byte[10]; [EOL] factory.releaseByteBuffer(ByteBufferType.READ_IO_BUFFER, buffer); [EOL] }
public void testAllocCharBufferWithSmallType() { [EOL] BufferRecycler recycler = new BufferRecycler(); [EOL] char[] buffer = recycler.allocCharBuffer(CharBufferType.TEXT_CONTENT, 10); [EOL] assertNotNull(buffer); [EOL] assertTrue(buffer.length >= 10); [EOL] }
public void testAllocCharBufferWithLargeType() { [EOL] BufferRecycler recycler = new BufferRecycler(); [EOL] char[] buffer = recycler.allocCharBuffer(CharBufferType.TEXT_CONTENT, 500); [EOL] assertNotNull(buffer); [EOL] assertTrue(buffer.length >= 500); [EOL] }
public void testAllocCharBufferWithSizeGreaterThanMinSize() { [EOL] CharBufferType type = CharBufferType.LARGE; // Assuming LARGE has a size greater than the minSize we will use [EOL] int minSize = 10; // Use a minSize smaller than CharBufferType.LARGE.size [EOL] char[] result = allocCharBuffer(type, minSize); [EOL] assertNotNull(result); [EOL] assertTrue(result.length >= type.size); [EOL] }
public void testAllocCharBufferWithSizeLessThanMinSize() { [EOL] CharBufferType type = CharBufferType.SMALL; // Assuming SMALL has a size smaller than the minSize we will use [EOL] int minSize = 50; // Use a minSize larger than CharBufferType.SMALL.size [EOL] char[] result = allocCharBuffer(type, minSize); [EOL] assertNotNull(result); [EOL] assertTrue(result.length >= minSize); [EOL] }
public void testAllocCharBufferWithExistingLargeEnoughBuffer() { [EOL] CharBufferType type = CharBufferType.MEDIUM; // Assuming MEDIUM is an enum value [EOL] int minSize = 20; // Use a minSize that is smaller than or equal to the buffer size already allocated [EOL] _charBuffers[type.ordinal()] = new char[minSize]; [EOL] char[] result = allocCharBuffer(type, minSize); [EOL] assertNotNull(result); [EOL] assertTrue(result.length >= minSize); [EOL] assertNull(_charBuffers[type.ordinal()]); // Check that the buffer was taken [EOL] }
public void testAllocCharBufferWithExistingSmallerBuffer() { [EOL] CharBufferType type = CharBufferType.SMALL; // Assuming SMALL is an enum value [EOL] int minSize = 30; // Use a minSize that is larger than the buffer size already allocated [EOL] _charBuffers[type.ordinal()] = new char[minSize - 10]; [EOL] char[] result = allocCharBuffer(type, minSize); [EOL] assertNotNull(result); [EOL] assertTrue(result.length >= minSize); [EOL] }
public void testReleaseCharBufferWithNullType() { [EOL] JsonFactory jf = new JsonFactory(); [EOL] try { [EOL] jf.releaseCharBuffer(null, new char[0]); [EOL] fail("Expected NullPointerException to be thrown"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testReleaseCharBufferWithNonNullTypeAndNullBuffer() { [EOL] JsonFactory jf = new JsonFactory(); [EOL] jf.releaseCharBuffer(CharBufferType.TEXT_BUFFER, null); [EOL] assertNull(jf.getCharBuffer(CharBufferType.TEXT_BUFFER)); [EOL] }
public void testReleaseCharBufferWithNonNullTypeAndNonNullBuffer() { [EOL] JsonFactory jf = new JsonFactory(); [EOL] char[] buffer = new char[10]; [EOL] jf.releaseCharBuffer(CharBufferType.TEXT_BUFFER, buffer); [EOL] assertSame(buffer, jf.getCharBuffer(CharBufferType.TEXT_BUFFER)); [EOL] }
public void testCallocWithZeroSize() { [EOL] char[] result = calloc(0); [EOL] assertNotNull(result); [EOL] assertEquals(0, result.length); [EOL] }
public void testCallocWithPositiveSize() { [EOL] int size = 10; [EOL] char[] result = calloc(size); [EOL] assertNotNull(result); [EOL] assertEquals(size, result.length); [EOL] }
public void testGetDefaultVariant() { [EOL] Base64Variant result = Base64Variants.getDefaultVariant(); [EOL] assertNotNull(result); [EOL] assertEquals(Base64Variants.MIME_NO_LINEFEEDS, result); [EOL] }
public void testByteArrayBuilderDefaultConstructor() { [EOL] ByteArrayBuilder builder = new ByteArrayBuilder(); [EOL] assertNotNull(builder); [EOL] assertNull(builder.getCurrentSegment()); [EOL] assertEquals(0, builder.getCurrentSegmentLength()); [EOL] }
public void testAppendTwoBytesWithEnoughSpace() { [EOL] TextBuffer instance = new TextBuffer(); [EOL] instance.resetWithEmpty(); [EOL] int initialLength = instance.size(); [EOL] int b16 = 0xABCD; // Some arbitrary 16-bit value [EOL] instance.appendTwoBytes(b16); [EOL] assertEquals(initialLength + 2, instance.size()); [EOL] byte[] result = instance.contentsAsArray(); [EOL] assertEquals((byte) (b16 >> 8), result[initialLength]); [EOL] assertEquals((byte) b16, result[initialLength + 1]); [EOL] }
public void testAppendTwoBytesWithInsufficientSpace() { [EOL] TextBuffer instance = new TextBuffer(); [EOL] instance.resetWithEmpty(); [EOL] for (int i = 0; i < instance.getCurrentBlock().length - 1; i++) { [EOL] instance.append('a'); [EOL] } [EOL] int initialLength = instance.size(); [EOL] int b16 = 0xABCD; // Some arbitrary 16-bit value [EOL] instance.appendTwoBytes(b16); [EOL] assertEquals(initialLength + 2, instance.size()); [EOL] byte[] result = instance.contentsAsArray(); [EOL] assertEquals((byte) (b16 >> 8), result[initialLength]); [EOL] assertEquals((byte) b16, result[initialLength + 1]); [EOL] }
public void testAppendThreeBytesWithEnoughSpace() { [EOL] int initialPtr = 0; // Example initial pointer [EOL] int b24 = 0x123456; // Example 3 bytes value [EOL] byte[] expectedBlock = new byte[]{(byte) 0x12, (byte) 0x34, (byte) 0x56}; [EOL] YourClass instance = new YourClass(); // Replace with actual class name [EOL] instance._currBlock = new byte[3]; // Assuming _currBlock is accessible [EOL] instance._currBlockPtr = initialPtr; [EOL] instance.appendThreeBytes(b24); [EOL] for (int i = 0; i < 3; i++) { [EOL] assertEquals(expectedBlock[i], instance._currBlock[i]); [EOL] } [EOL] assertEquals(initialPtr + 3, instance._currBlockPtr); [EOL] }
public void testAppendThreeBytesWithoutEnoughSpace() { [EOL] int initialPtr = 0; // Example initial pointer [EOL] int b24 = 0x123456; // Example 3 bytes value [EOL] YourClass instance = new YourClass(); // Replace with actual class name [EOL] instance._currBlock = new byte[2]; // Not enough space [EOL] instance._currBlockPtr = initialPtr; [EOL] instance.appendThreeBytes(b24); [EOL] }
public void testDataFormatMatcherWithNonNullValues() { [EOL] InputStream in = new ByteArrayInputStream(new byte[]{}); [EOL] byte[] buffered = new byte[]{1, 2, 3}; [EOL] int bufferedStart = 0; [EOL] int bufferedLength = buffered.length; [EOL] JsonFactory match = new JsonFactory(); [EOL] MatchStrength strength = MatchStrength.SOLID_MATCH; [EOL] DataFormatMatcher matcher = new DataFormatMatcher(in, buffered, bufferedStart, bufferedLength, match, strength); [EOL] assertNotNull(matcher.getOriginalStream()); [EOL] assertArrayEquals(buffered, matcher.getBufferedData()); [EOL] assertEquals(bufferedStart, matcher.getBufferedStart()); [EOL] assertEquals(bufferedLength, matcher.getBufferedLength()); [EOL] assertEquals(match, matcher.getMatch()); [EOL] assertEquals(strength, matcher.getMatchStrength()); [EOL] }
public void testDataFormatMatcherWithNullValues() { [EOL] InputStream in = null; [EOL] byte[] buffered = null; [EOL] int bufferedStart = 0; [EOL] int bufferedLength = 0; [EOL] JsonFactory match = null; [EOL] MatchStrength strength = null; [EOL] DataFormatMatcher matcher = new DataFormatMatcher(in, buffered, bufferedStart, bufferedLength, match, strength); [EOL] assertNull(matcher.getOriginalStream()); [EOL] assertNull(matcher.getBufferedData()); [EOL] assertEquals(bufferedStart, matcher.getBufferedStart()); [EOL] assertEquals(bufferedLength, matcher.getBufferedLength()); [EOL] assertNull(matcher.getMatch()); [EOL] assertNull(matcher.getMatchStrength()); [EOL] }
public void testHasMatchWhenMatchIsNull() { [EOL] JsonPointer pointer = new JsonPointer(""); [EOL] assertFalse(pointer.hasMatch()); [EOL] }
public void testHasMatchWhenMatchIsNotNull() { [EOL] JsonPointer pointer = new JsonPointer("/valid/path"); [EOL] assertTrue(pointer.hasMatch()); [EOL] }
public void testGetMatchStrengthWhenMatchStrengthIsNull() { [EOL] TestClass testInstance = new TestClass(); // Replace 'TestClass' with the actual class name that contains the method [EOL] MatchStrength result = testInstance.getMatchStrength(); [EOL] assertEquals(MatchStrength.INCONCLUSIVE, result); [EOL] }
public void testGetMatchStrengthWhenMatchStrengthIsNotNull() { [EOL] TestClass testInstance = new TestClass(); // Replace 'TestClass' with the actual class name that contains the method [EOL] testInstance.setMatchStrength(MatchStrength.STRONG_MATCH); // Replace 'setMatchStrength' with the actual method to set '_matchStrength' [EOL] MatchStrength result = testInstance.getMatchStrength(); [EOL] assertEquals(MatchStrength.STRONG_MATCH, result); [EOL] }
public JsonFactory getMatch() { [EOL] return _match; [EOL] }
public void testGetMatchedFormatName() { [EOL] MatchType _match = mock(MatchType.class); [EOL] when(_match.getFormatName()).thenReturn("expectedFormatName"); [EOL] ClassName instance = new ClassName(_match); [EOL] String result = instance.getMatchedFormatName(); [EOL] assertEquals("expectedFormatName", result); [EOL] }
public void testCreateParserWithMatch_MatchIsNull() throws IOException { [EOL] this._match = null; [EOL] JsonParser result = createParserWithMatch(); [EOL] assertNull(result); [EOL] }
public void testCreateParserWithMatch_OriginalStreamIsNull() throws IOException { [EOL] this._match = mock(Match.class); [EOL] this._originalStream = null; [EOL] this._bufferedData = new byte[0]; [EOL] this._bufferedStart = 0; [EOL] this._bufferedLength = 0; [EOL] when(_match.createParser(any(byte[].class), anyInt(), anyInt())).thenReturn(mock(JsonParser.class)); [EOL] JsonParser result = createParserWithMatch(); [EOL] assertNotNull(result); [EOL] verify(_match).createParser(_bufferedData, _bufferedStart, _bufferedLength); [EOL] }
public void testCreateParserWithMatch_OriginalStreamIsNotNull() throws IOException { [EOL] this._match = mock(Match.class); [EOL] this._originalStream = mock(InputStream.class); [EOL] when(_match.createParser(any(InputStream.class))).thenReturn(mock(JsonParser.class)); [EOL] JsonParser result = createParserWithMatch(); [EOL] assertNotNull(result); [EOL] verify(_match).createParser(getDataStream()); [EOL] }
public void testGetDataStreamWithNullOriginalStream() { [EOL] YourClass objectUnderTest = new YourClass(null, bufferedData, bufferedStart, bufferedLength); [EOL] InputStream result = objectUnderTest.getDataStream(); [EOL] assertTrue(result instanceof ByteArrayInputStream); [EOL] ByteArrayInputStream byteArrayInputStream = (ByteArrayInputStream) result; [EOL] byte[] actualData = new byte[bufferedLength]; [EOL] byteArrayInputStream.read(actualData, 0, bufferedLength); [EOL] assertArrayEquals(bufferedData, actualData); [EOL] assertEquals(bufferedStart, byteArrayInputStream.available()); [EOL] }
public void testGetDataStreamWithNonNullOriginalStream() { [EOL] InputStream originalStream = new ByteArrayInputStream(new byte[0]); [EOL] YourClass objectUnderTest = new YourClass(originalStream, bufferedData, bufferedStart, bufferedLength); [EOL] InputStream result = objectUnderTest.getDataStream(); [EOL] assertTrue(result instanceof MergedStream); [EOL] MergedStream mergedStream = (MergedStream) result; [EOL] }
public void testParseIntSingleDigit() { [EOL] char[] digitChars = {'3'}; [EOL] int result = parseInt(digitChars, 0, 1); [EOL] assertEquals(3, result); [EOL] }
public void testParseIntMultipleDigits() { [EOL] char[] digitChars = {'1', '2', '3', '4', '5', '6', '7', '8', '9'}; [EOL] int result = parseInt(digitChars, 0, 9); [EOL] assertEquals(123456789, result); [EOL] }
public void testParseIntWithOffset() { [EOL] char[] digitChars = {'0', '0', '1', '2', '3'}; [EOL] int result = parseInt(digitChars, 2, 3); [EOL] assertEquals(123, result); [EOL] }
public void testParseIntWithLeadingZeros() { [EOL] char[] digitChars = {'0', '0', '1', '2', '3'}; [EOL] int result = parseInt(digitChars, 0, 5); [EOL] assertEquals(123, result); [EOL] }
public void testParseIntWithOffsetAndLength() { [EOL] char[] digitChars = {'0', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'}; [EOL] int result = parseInt(digitChars, 2, 7); [EOL] assertEquals(1234567, result); [EOL] }
public void testInLongRangeLessThanCmpLen() { [EOL] char[] digitChars = {'1', '2', '3'}; [EOL] int offset = 0; [EOL] int len = 2; [EOL] boolean negative = false; [EOL] assertTrue(inLongRange(digitChars, offset, len, negative)); [EOL] }
public void testInLongRangeGreaterThanCmpLen() { [EOL] char[] digitChars = {'1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '1'}; [EOL] int offset = 0; [EOL] int len = 11; [EOL] boolean negative = false; [EOL] assertFalse(inLongRange(digitChars, offset, len, negative)); [EOL] }
public void testInLongRangeEqualCmpLenNegativeDiff() { [EOL] char[] digitChars = {'9', '2', '2', '3', '3', '7', '2', '0', '3', '6', '8', '5', '4', '7', '7', '5', '8', '0', '8'}; [EOL] int offset = 0; [EOL] int len = 19; [EOL] boolean negative = true; [EOL] assertTrue(inLongRange(digitChars, offset, len, negative)); [EOL] }
public void testInLongRangeEqualCmpLenPositiveDiff() { [EOL] char[] digitChars = {'9', '2', '2', '3', '3', '7', '2', '0', '3', '6', '8', '5', '4', '7', '7', '5', '8', '0', '9'}; [EOL] int offset = 0; [EOL] int len = 19; [EOL] boolean negative = true; [EOL] assertFalse(inLongRange(digitChars, offset, len, negative)); [EOL] }
public void testInLongRangeEqualCmpLenNoDiff() { [EOL] char[] digitChars = {'9', '2', '2', '3', '3', '7', '2', '0', '3', '6', '8', '5', '4', '7', '7', '5', '8', '0', '8'}; [EOL] int offset = 0; [EOL] int len = 19; [EOL] boolean negative = false; [EOL] assertTrue(inLongRange(digitChars, offset, len, negative)); [EOL] }
public void testParseAsLongWithNullInput() { [EOL] long defaultValue = 123L; [EOL] long result = YourClass.parseAsLong(null, defaultValue); [EOL] assertEquals(defaultValue, result); [EOL] }
public void testParseAsLongWithEmptyString() { [EOL] long defaultValue = 123L; [EOL] long result = YourClass.parseAsLong("", defaultValue); [EOL] assertEquals(defaultValue, result); [EOL] }
public void testParseAsLongWithPlusSign() { [EOL] long defaultValue = 123L; [EOL] long result = YourClass.parseAsLong("+456", defaultValue); [EOL] assertEquals(456L, result); [EOL] }
public void testParseAsLongWithMinusSign() { [EOL] long defaultValue = 123L; [EOL] long result = YourClass.parseAsLong("-456", defaultValue); [EOL] assertEquals(-456L, result); [EOL] }
public void testParseAsLongWithInvalidNumber() { [EOL] long defaultValue = 123L; [EOL] long result = YourClass.parseAsLong("invalid", defaultValue); [EOL] assertEquals(defaultValue, result); [EOL] }
public void testParseAsLongWithValidNumber() { [EOL] long defaultValue = 123L; [EOL] long result = YourClass.parseAsLong("456", defaultValue); [EOL] assertEquals(456L, result); [EOL] }
public void testParseAsLongWithDoubleValue() { [EOL] long defaultValue = 123L; [EOL] long result = YourClass.parseAsLong("456.78", defaultValue); [EOL] assertEquals(456L, result); [EOL] }
public void testParseAsLongWithLeadingAndTrailingSpaces() { [EOL] long defaultValue = 123L; [EOL] long result = YourClass.parseAsLong("  456  ", defaultValue); [EOL] assertEquals(456L, result); [EOL] }
public void testParseAsDoubleWithNullInput() { [EOL] double defaultValue = 1.0; [EOL] double result = parseAsDouble(null, defaultValue); [EOL] assertEquals(defaultValue, result, 0.0); [EOL] }
public void testParseAsDoubleWithEmptyString() { [EOL] double defaultValue = 1.0; [EOL] double result = parseAsDouble("", defaultValue); [EOL] assertEquals(defaultValue, result, 0.0); [EOL] }
public void testParseAsDoubleWithValidNumber() { [EOL] double defaultValue = 1.0; [EOL] double expected = 2.0; [EOL] double result = parseAsDouble("2.0", defaultValue); [EOL] assertEquals(expected, result, 0.0); [EOL] }
public void testParseAsDoubleWithInvalidNumber() { [EOL] double defaultValue = 1.0; [EOL] double result = parseAsDouble("invalid", defaultValue); [EOL] assertEquals(defaultValue, result, 0.0); [EOL] }
public void testGetTextWithValueStringTokenAndIncompleteTrue() throws IOException, JsonParseException { [EOL] _currToken = JsonToken.VALUE_STRING; [EOL] _tokenIncomplete = true; [EOL] String result = getText(); [EOL] assertFalse(_tokenIncomplete); [EOL] assertEquals(_textBuffer.contentsAsString(), result); [EOL] }
public void testGetTextWithValueStringTokenAndIncompleteFalse() throws IOException, JsonParseException { [EOL] _currToken = JsonToken.VALUE_STRING; [EOL] _tokenIncomplete = false; [EOL] String result = getText(); [EOL] assertFalse(_tokenIncomplete); [EOL] assertEquals(_textBuffer.contentsAsString(), result); [EOL] }
public void testGetTextWithNonValueStringToken() throws IOException, JsonParseException { [EOL] _currToken = JsonToken.NOT_AVAILABLE; // Use an appropriate non VALUE_STRING token [EOL] String result = getText(); [EOL] assertEquals(_getText2(_currToken), result); [EOL] }
public void testGetText2WithNullToken() { [EOL] String result = _getText2(null); [EOL] assertNull(result); [EOL] }
public void testGetText2WithFieldNameToken() { [EOL] JsonToken token = JsonToken.FIELD_NAME; [EOL] when(_parsingContext.getCurrentName()).thenReturn("fieldName"); [EOL] String result = _getText2(token); [EOL] assertEquals("fieldName", result); [EOL] }
public void testGetText2WithValueStringToken() { [EOL] JsonToken token = JsonToken.VALUE_STRING; [EOL] when(_textBuffer.contentsAsString()).thenReturn("stringValue"); [EOL] String result = _getText2(token); [EOL] assertEquals("stringValue", result); [EOL] }
public void testGetText2WithValueNumberIntToken() { [EOL] JsonToken token = JsonToken.VALUE_NUMBER_INT; [EOL] when(_textBuffer.contentsAsString()).thenReturn("intValue"); [EOL] String result = _getText2(token); [EOL] assertEquals("intValue", result); [EOL] }
public void testGetText2WithValueNumberFloatToken() { [EOL] JsonToken token = JsonToken.VALUE_NUMBER_FLOAT; [EOL] when(_textBuffer.contentsAsString()).thenReturn("floatValue"); [EOL] String result = _getText2(token); [EOL] assertEquals("floatValue", result); [EOL] }
public void testGetText2WithDefaultToken() { [EOL] JsonToken token = JsonToken.VALUE_TRUE; // Assuming VALUE_TRUE is a valid default case [EOL] String result = _getText2(token); [EOL] assertEquals("true", result); [EOL] }
@Override [EOL] public JsonToken nextToken() throws IOException, JsonParseException { [EOL] _numTypesValid = NR_UNKNOWN; [EOL] if (_currToken == JsonToken.FIELD_NAME) { [EOL] return _nextAfterName(); [EOL] } [EOL] if (_tokenIncomplete) { [EOL] _skipString(); [EOL] } [EOL] int i = _skipWSOrEnd(); [EOL] if (i < 0) { [EOL] close(); [EOL] return (_currToken = null); [EOL] } [EOL] _tokenInputTotal = _currInputProcessed + _inputPtr - 1; [EOL] _tokenInputRow = _currInputRow; [EOL] _tokenInputCol = _inputPtr - _currInputRowStart - 1; [EOL] _binaryValue = null; [EOL] if (i == INT_RBRACKET) { [EOL] if (!_parsingContext.inArray()) { [EOL] _reportMismatchedEndMarker(i, '}'); [EOL] } [EOL] _parsingContext = _parsingContext.getParent(); [EOL] return (_currToken = JsonToken.END_ARRAY); [EOL] } [EOL] if (i == INT_RCURLY) { [EOL] if (!_parsingContext.inObject()) { [EOL] _reportMismatchedEndMarker(i, ']'); [EOL] } [EOL] _parsingContext = _parsingContext.getParent(); [EOL] return (_currToken = JsonToken.END_OBJECT); [EOL] } [EOL] if (_parsingContext.expectComma()) { [EOL] if (i != INT_COMMA) { [EOL] _reportUnexpectedChar(i, "was expecting comma to separate " + _parsingContext.getTypeDesc() + " entries"); [EOL] } [EOL] i = _skipWS(); [EOL] } [EOL] if (!_parsingContext.inObject()) { [EOL] return _nextTokenNotInObject(i); [EOL] } [EOL] Name n = _parseFieldName(i); [EOL] _parsingContext.setCurrentName(n.getName()); [EOL] _currToken = JsonToken.FIELD_NAME; [EOL] i = _skipWS(); [EOL] if (i != INT_COLON) { [EOL] _reportUnexpectedChar(i, "was expecting a colon to separate field name and value"); [EOL] } [EOL] i = _skipWS(); [EOL] if (i == INT_QUOTE) { [EOL] _tokenIncomplete = true; [EOL] _nextToken = JsonToken.VALUE_STRING; [EOL] return _currToken; [EOL] } [EOL] JsonToken t; [EOL] switch(i) { [EOL] case INT_LBRACKET: [EOL] t = JsonToken.START_ARRAY; [EOL] break; [EOL] case INT_LCURLY: [EOL] t = JsonToken.START_OBJECT; [EOL] break; [EOL] case INT_RBRACKET: [EOL] case INT_RCURLY: [EOL] _reportUnexpectedChar(i, "expected a value"); [EOL] case INT_t: [EOL] _matchToken("true", 1); [EOL] t = JsonToken.VALUE_TRUE; [EOL] break; [EOL] case INT_f: [EOL] _matchToken("false", 1); [EOL] t = JsonToken.VALUE_FALSE; [EOL] break; [EOL] case INT_n: [EOL] _matchToken("null", 1); [EOL] t = JsonToken.VALUE_NULL; [EOL] break; [EOL] case INT_MINUS: [EOL] case INT_0: [EOL] case INT_1: [EOL] case INT_2: [EOL] case INT_3: [EOL] case INT_4: [EOL] case INT_5: [EOL] case INT_6: [EOL] case INT_7: [EOL] case INT_8: [EOL] case INT_9: [EOL] t = parseNumberText(i); [EOL] break; [EOL] default: [EOL] t = _handleUnexpectedValue(i); [EOL] } [EOL] _nextToken = t; [EOL] return _currToken; [EOL] }
public void testNextTokenNotInObjectWithQuote() throws IOException, JsonParseException { [EOL] int i = INT_QUOTE; [EOL] JsonToken result = _nextTokenNotInObject(i); [EOL] assertTrue(_tokenIncomplete); [EOL] assertEquals(JsonToken.VALUE_STRING, result); [EOL] }
public void testNextTokenNotInObjectWithLBracket() throws IOException, JsonParseException { [EOL] int i = INT_LBRACKET; [EOL] JsonToken result = _nextTokenNotInObject(i); [EOL] assertNotNull(_parsingContext); [EOL] assertEquals(JsonToken.START_ARRAY, result); [EOL] }
public void testNextTokenNotInObjectWithLCurly() throws IOException, JsonParseException { [EOL] int i = INT_LCURLY; [EOL] JsonToken result = _nextTokenNotInObject(i); [EOL] assertNotNull(_parsingContext); [EOL] assertEquals(JsonToken.START_OBJECT, result); [EOL] }
public void testNextTokenNotInObjectWithRBracket() { [EOL] int i = INT_RBRACKET; [EOL] try { [EOL] _nextTokenNotInObject(i); [EOL] fail("Expected JsonParseException"); [EOL] } catch (JsonParseException e) { [EOL] } catch (IOException e) { [EOL] fail("Expected JsonParseException, got IOException"); [EOL] } [EOL] }
public void testNextTokenNotInObjectWithRCurly() { [EOL] int i = INT_RCURLY; [EOL] try { [EOL] _nextTokenNotInObject(i); [EOL] fail("Expected JsonParseException"); [EOL] } catch (JsonParseException e) { [EOL] } catch (IOException e) { [EOL] fail("Expected JsonParseException, got IOException"); [EOL] } [EOL] }
public void testNextTokenNotInObjectWithT() throws IOException, JsonParseException { [EOL] int i = INT_t; [EOL] JsonToken result = _nextTokenNotInObject(i); [EOL] assertEquals(JsonToken.VALUE_TRUE, result); [EOL] }
public void testNextTokenNotInObjectWithF() throws IOException, JsonParseException { [EOL] int i = INT_f; [EOL] JsonToken result = _nextTokenNotInObject(i); [EOL] assertEquals(JsonToken.VALUE_FALSE, result); [EOL] }
public void testNextTokenNotInObjectWithN() throws IOException, JsonParseException { [EOL] int i = INT_n; [EOL] JsonToken result = _nextTokenNotInObject(i); [EOL] assertEquals(JsonToken.VALUE_NULL, result); [EOL] }
public void testNextTokenNotInObjectWithMinus() throws IOException, JsonParseException { [EOL] int i = INT_MINUS; [EOL] JsonToken result = _nextTokenNotInObject(i); [EOL] assertEquals(parseNumberText(i), result); [EOL] }
public void testNextTokenNotInObjectWithDigit() throws IOException, JsonParseException { [EOL] for (int i = INT_0; i <= INT_9; i++) { [EOL] JsonToken result = _nextTokenNotInObject(i); [EOL] assertEquals(parseNumberText(i), result); [EOL] } [EOL] }
public void testNextTokenNotInObjectWithUnexpectedValue() throws IOException, JsonParseException { [EOL] int i = INT_UNEXPECTED; [EOL] JsonToken result = _nextTokenNotInObject(i); [EOL] assertEquals(_handleUnexpectedValue(i), result); [EOL] }
public void testParseNumberTextNegative() throws IOException, JsonParseException { [EOL] int c = INT_MINUS; [EOL] JsonToken result = parseNumberText(c); [EOL] }
public void testParseNumberTextNonDigit() throws IOException, JsonParseException { [EOL] int c = INT_MINUS + 1; // Any non-digit character [EOL] JsonToken result = parseNumberText(c); [EOL] }
public void testParseNumberTextZero() throws IOException, JsonParseException { [EOL] int c = INT_0; [EOL] JsonToken result = parseNumberText(c); [EOL] }
public void testParseNumberTextDigit() throws IOException, JsonParseException { [EOL] for (int c = INT_0 + 1; c <= INT_9; c++) { [EOL] JsonToken result = parseNumberText(c); [EOL] } [EOL] }
public void testParseNumberTextEndOfInput() throws IOException, JsonParseException { [EOL] int c = INT_0; [EOL] JsonToken result = parseNumberText(c); [EOL] }
public void testParseNumberTextBufferEnd() throws IOException, JsonParseException { [EOL] int c = INT_0; [EOL] JsonToken result = parseNumberText(c); [EOL] }
public void testParseNumberTextFloat() throws IOException, JsonParseException { [EOL] int c = '.'; [EOL] JsonToken result = parseNumberText(c); [EOL] }
public void testParseNumberTextExponent() throws IOException, JsonParseException { [EOL] int c = 'e'; [EOL] JsonToken result = parseNumberText(c); [EOL] }
public void testParserNumber2EndOfInput() throws IOException, JsonParseException { [EOL] char[] outBuf = new char[10]; [EOL] int outPtr = 0; [EOL] boolean negative = false; [EOL] int intPartLength = 0; [EOL] when(_inputPtr).thenReturn(_inputEnd); [EOL] when(loadMore()).thenReturn(false); [EOL] JsonToken result = _parserNumber2(outBuf, outPtr, negative, intPartLength); [EOL] assertEquals(JsonToken.VALUE_NUMBER_INT, result); [EOL] verify(_textBuffer).setCurrentLength(outPtr); [EOL] verify(resetInt(negative, intPartLength)); [EOL] }
public void testParserNumber2NonDigit() throws IOException, JsonParseException { [EOL] char[] outBuf = new char[10]; [EOL] int outPtr = 0; [EOL] boolean negative = false; [EOL] int intPartLength = 0; [EOL] when(_inputPtr).thenReturn(_inputEnd - 1); [EOL] when(_inputBuffer[_inputPtr++]).thenReturn((int) 'a'); [EOL] JsonToken result = _parserNumber2(outBuf, outPtr, negative, intPartLength); [EOL] assertEquals(JsonToken.VALUE_NUMBER_INT, result); [EOL] verify(_textBuffer, never()).finishCurrentSegment(); [EOL] verify(_textBuffer).setCurrentLength(outPtr); [EOL] verify(resetInt(negative, intPartLength)); [EOL] }
public void testParserNumber2DecimalPoint() throws IOException, JsonParseException { [EOL] char[] outBuf = new char[10]; [EOL] int outPtr = 0; [EOL] boolean negative = false; [EOL] int intPartLength = 0; [EOL] when(_inputPtr).thenReturn(_inputEnd - 1); [EOL] when(_inputBuffer[_inputPtr++]).thenReturn((int) '.'); [EOL] JsonToken result = _parserNumber2(outBuf, outPtr, negative, intPartLength); [EOL] assertEquals(JsonToken.VALUE_NUMBER_FLOAT, result); [EOL] verify(_parseFloatText(outBuf, outPtr, '.', negative, intPartLength)); [EOL] }
public void testParserNumber2Exponent() throws IOException, JsonParseException { [EOL] char[] outBuf = new char[10]; [EOL] int outPtr = 0; [EOL] boolean negative = false; [EOL] int intPartLength = 0; [EOL] when(_inputPtr).thenReturn(_inputEnd - 1); [EOL] when(_inputBuffer[_inputPtr++]).thenReturn((int) 'e'); [EOL] JsonToken result = _parserNumber2(outBuf, outPtr, negative, intPartLength); [EOL] assertEquals(JsonToken.VALUE_NUMBER_FLOAT, result); [EOL] verify(_parseFloatText(outBuf, outPtr, 'e', negative, intPartLength)); [EOL] }
public void testParserNumber2BufferExpansion() throws IOException, JsonParseException { [EOL] char[] outBuf = new char[1]; [EOL] int outPtr = 1; // Set to the end of the buffer to force expansion [EOL] boolean negative = false; [EOL] int intPartLength = 0; [EOL] when(_inputPtr).thenReturn(_inputEnd - 1); [EOL] when(_inputBuffer[_inputPtr++]).thenReturn((int) '5'); [EOL] when(_textBuffer.finishCurrentSegment()).thenReturn(new char[10]); [EOL] JsonToken result = _parserNumber2(outBuf, outPtr, negative, intPartLength); [EOL] assertEquals(JsonToken.VALUE_NUMBER_INT, result); [EOL] verify(_textBuffer).finishCurrentSegment(); [EOL] verify(_textBuffer).setCurrentLength(1); [EOL] verify(resetInt(negative, intPartLength + 1)); [EOL] }
protected Name _parseFieldName(int i) throws IOException, JsonParseException { [EOL] if (i != INT_QUOTE) { [EOL] return _handleUnusualFieldName(i); [EOL] } [EOL] if ((_inputPtr + 9) > _inputEnd) { [EOL] return slowParseFieldName(); [EOL] } [EOL] final byte[] input = _inputBuffer; [EOL] final int[] codes = sInputCodesLatin1; [EOL] int q = input[_inputPtr++] & 0xFF; [EOL] if (codes[q] == 0) { [EOL] i = input[_inputPtr++] & 0xFF; [EOL] if (codes[i] == 0) { [EOL] q = (q << 8) | i; [EOL] i = input[_inputPtr++] & 0xFF; [EOL] if (codes[i] == 0) { [EOL] q = (q << 8) | i; [EOL] i = input[_inputPtr++] & 0xFF; [EOL] if (codes[i] == 0) { [EOL] q = (q << 8) | i; [EOL] i = input[_inputPtr++] & 0xFF; [EOL] if (codes[i] == 0) { [EOL] _quad1 = q; [EOL] return parseMediumFieldName(i, codes); [EOL] } [EOL] if (i == INT_QUOTE) { [EOL] return findName(q, 4); [EOL] } [EOL] return parseFieldName(q, i, 4); [EOL] } [EOL] if (i == INT_QUOTE) { [EOL] return findName(q, 3); [EOL] } [EOL] return parseFieldName(q, i, 3); [EOL] } [EOL] if (i == INT_QUOTE) { [EOL] return findName(q, 2); [EOL] } [EOL] return parseFieldName(q, i, 2); [EOL] } [EOL] if (i == INT_QUOTE) { [EOL] return findName(q, 1); [EOL] } [EOL] return parseFieldName(q, i, 1); [EOL] } [EOL] if (q == INT_QUOTE) { [EOL] return BytesToNameCanonicalizer.getEmptyName(); [EOL] } [EOL] return parseFieldName(0, q, 0); [EOL] }
public void testSlowParseFieldNameAtEndOfInputWithoutMoreData() throws IOException { [EOL] when(this._inputPtr).thenReturn(this._inputEnd); [EOL] when(this.loadMore()).thenReturn(false); [EOL] try { [EOL] this.slowParseFieldName(); [EOL] fail("Should have thrown JsonParseException due to end of input"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testSlowParseFieldNameWithInitialQuote() throws IOException { [EOL] when(this._inputPtr).thenReturn(this._inputEnd - 1); [EOL] when(this.loadMore()).thenReturn(true); [EOL] when(this._inputBuffer[this._inputPtr++]).thenReturn((byte) INT_QUOTE); [EOL] Name result = this.slowParseFieldName(); [EOL] assertEquals(BytesToNameCanonicalizer.getEmptyName(), result); [EOL] }
public void testSlowParseFieldNameWithNonQuoteCharacter() throws IOException { [EOL] when(this._inputPtr).thenReturn(this._inputEnd - 1); [EOL] when(this.loadMore()).thenReturn(true); [EOL] byte nonQuoteChar = 'a'; // Use a non-quote character [EOL] when(this._inputBuffer[this._inputPtr++]).thenReturn((byte) nonQuoteChar); [EOL] Name result = this.slowParseFieldName(); [EOL] verify(this).parseEscapedFieldName(any(int[].class), eq(0), eq(0), eq(nonQuoteChar), eq(0)); [EOL] }
protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException { [EOL] if (ch == INT_APOSTROPHE && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) { [EOL] return _parseApostropheFieldName(); [EOL] } [EOL] if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) { [EOL] _reportUnexpectedChar(ch, "was expecting double-quote to start field name"); [EOL] } [EOL] final int[] codes = CharTypes.getInputCodeUtf8JsNames(); [EOL] if (codes[ch] != 0) { [EOL] _reportUnexpectedChar(ch, "was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name"); [EOL] } [EOL] int[] quads = _quadBuffer; [EOL] int qlen = 0; [EOL] int currQuad = 0; [EOL] int currQuadBytes = 0; [EOL] while (true) { [EOL] if (currQuadBytes < 4) { [EOL] ++currQuadBytes; [EOL] currQuad = (currQuad << 8) | ch; [EOL] } else { [EOL] if (qlen >= quads.length) { [EOL] _quadBuffer = quads = growArrayBy(quads, quads.length); [EOL] } [EOL] quads[qlen++] = currQuad; [EOL] currQuad = ch; [EOL] currQuadBytes = 1; [EOL] } [EOL] if (_inputPtr >= _inputEnd) { [EOL] if (!loadMore()) { [EOL] _reportInvalidEOF(" in field name"); [EOL] } [EOL] } [EOL] ch = _inputBuffer[_inputPtr] & 0xFF; [EOL] if (codes[ch] != 0) { [EOL] break; [EOL] } [EOL] ++_inputPtr; [EOL] } [EOL] if (currQuadBytes > 0) { [EOL] if (qlen >= quads.length) { [EOL] _quadBuffer = quads = growArrayBy(quads, quads.length); [EOL] } [EOL] quads[qlen++] = currQuad; [EOL] } [EOL] Name name = _symbols.findName(quads, qlen); [EOL] if (name == null) { [EOL] name = addName(quads, qlen, currQuadBytes); [EOL] } [EOL] return name; [EOL] }
protected Name _parseApostropheFieldName() throws IOException, JsonParseException { [EOL] if (_inputPtr >= _inputEnd) { [EOL] if (!loadMore()) { [EOL] _reportInvalidEOF(": was expecting closing '\'' for name"); [EOL] } [EOL] } [EOL] int ch = _inputBuffer[_inputPtr++] & 0xFF; [EOL] if (ch == INT_APOSTROPHE) { [EOL] return BytesToNameCanonicalizer.getEmptyName(); [EOL] } [EOL] int[] quads = _quadBuffer; [EOL] int qlen = 0; [EOL] int currQuad = 0; [EOL] int currQuadBytes = 0; [EOL] final int[] codes = sInputCodesLatin1; [EOL] while (true) { [EOL] if (ch == INT_APOSTROPHE) { [EOL] break; [EOL] } [EOL] if (ch != INT_QUOTE && codes[ch] != 0) { [EOL] if (ch != INT_BACKSLASH) { [EOL] _throwUnquotedSpace(ch, "name"); [EOL] } else { [EOL] ch = _decodeEscaped(); [EOL] } [EOL] if (ch > 127) { [EOL] if (currQuadBytes >= 4) { [EOL] if (qlen >= quads.length) { [EOL] _quadBuffer = quads = growArrayBy(quads, quads.length); [EOL] } [EOL] quads[qlen++] = currQuad; [EOL] currQuad = 0; [EOL] currQuadBytes = 0; [EOL] } [EOL] if (ch < 0x800) { [EOL] currQuad = (currQuad << 8) | (0xc0 | (ch >> 6)); [EOL] ++currQuadBytes; [EOL] } else { [EOL] currQuad = (currQuad << 8) | (0xe0 | (ch >> 12)); [EOL] ++currQuadBytes; [EOL] if (currQuadBytes >= 4) { [EOL] if (qlen >= quads.length) { [EOL] _quadBuffer = quads = growArrayBy(quads, quads.length); [EOL] } [EOL] quads[qlen++] = currQuad; [EOL] currQuad = 0; [EOL] currQuadBytes = 0; [EOL] } [EOL] currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f)); [EOL] ++currQuadBytes; [EOL] } [EOL] ch = 0x80 | (ch & 0x3f); [EOL] } [EOL] } [EOL] if (currQuadBytes < 4) { [EOL] ++currQuadBytes; [EOL] currQuad = (currQuad << 8) | ch; [EOL] } else { [EOL] if (qlen >= quads.length) { [EOL] _quadBuffer = quads = growArrayBy(quads, quads.length); [EOL] } [EOL] quads[qlen++] = currQuad; [EOL] currQuad = ch; [EOL] currQuadBytes = 1; [EOL] } [EOL] if (_inputPtr >= _inputEnd) { [EOL] if (!loadMore()) { [EOL] _reportInvalidEOF(" in field name"); [EOL] } [EOL] } [EOL] ch = _inputBuffer[_inputPtr++] & 0xFF; [EOL] } [EOL] if (currQuadBytes > 0) { [EOL] if (qlen >= quads.length) { [EOL] _quadBuffer = quads = growArrayBy(quads, quads.length); [EOL] } [EOL] quads[qlen++] = currQuad; [EOL] } [EOL] Name name = _symbols.findName(quads, qlen); [EOL] if (name == null) { [EOL] name = addName(quads, qlen, currQuadBytes); [EOL] } [EOL] return name; [EOL] }
private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException { [EOL] int byteLen = (qlen << 2) - 4 + lastQuadBytes; [EOL] int lastQuad; [EOL] if (lastQuadBytes < 4) { [EOL] lastQuad = quads[qlen - 1]; [EOL] quads[qlen - 1] = (lastQuad << ((4 - lastQuadBytes) << 3)); [EOL] } else { [EOL] lastQuad = 0; [EOL] } [EOL] char[] cbuf = _textBuffer.emptyAndGetCurrentSegment(); [EOL] int cix = 0; [EOL] for (int ix = 0; ix < byteLen; ) { [EOL] int ch = quads[ix >> 2]; [EOL] int byteIx = (ix & 3); [EOL] ch = (ch >> ((3 - byteIx) << 3)) & 0xFF; [EOL] ++ix; [EOL] if (ch > 127) { [EOL] int needed; [EOL] if ((ch & 0xE0) == 0xC0) { [EOL] ch &= 0x1F; [EOL] needed = 1; [EOL] } else if ((ch & 0xF0) == 0xE0) { [EOL] ch &= 0x0F; [EOL] needed = 2; [EOL] } else if ((ch & 0xF8) == 0xF0) { [EOL] ch &= 0x07; [EOL] needed = 3; [EOL] } else { [EOL] _reportInvalidInitial(ch); [EOL] needed = ch = 1; [EOL] } [EOL] if ((ix + needed) > byteLen) { [EOL] _reportInvalidEOF(" in field name"); [EOL] } [EOL] int ch2 = quads[ix >> 2]; [EOL] byteIx = (ix & 3); [EOL] ch2 = (ch2 >> ((3 - byteIx) << 3)); [EOL] ++ix; [EOL] if ((ch2 & 0xC0) != 0x080) { [EOL] _reportInvalidOther(ch2); [EOL] } [EOL] ch = (ch << 6) | (ch2 & 0x3F); [EOL] if (needed > 1) { [EOL] ch2 = quads[ix >> 2]; [EOL] byteIx = (ix & 3); [EOL] ch2 = (ch2 >> ((3 - byteIx) << 3)); [EOL] ++ix; [EOL] if ((ch2 & 0xC0) != 0x080) { [EOL] _reportInvalidOther(ch2); [EOL] } [EOL] ch = (ch << 6) | (ch2 & 0x3F); [EOL] if (needed > 2) { [EOL] ch2 = quads[ix >> 2]; [EOL] byteIx = (ix & 3); [EOL] ch2 = (ch2 >> ((3 - byteIx) << 3)); [EOL] ++ix; [EOL] if ((ch2 & 0xC0) != 0x080) { [EOL] _reportInvalidOther(ch2 & 0xFF); [EOL] } [EOL] ch = (ch << 6) | (ch2 & 0x3F); [EOL] } [EOL] } [EOL] if (needed > 2) { [EOL] ch -= 0x10000; [EOL] if (cix >= cbuf.length) { [EOL] cbuf = _textBuffer.expandCurrentSegment(); [EOL] } [EOL] cbuf[cix++] = (char) (0xD800 + (ch >> 10)); [EOL] ch = 0xDC00 | (ch & 0x03FF); [EOL] } [EOL] } [EOL] if (cix >= cbuf.length) { [EOL] cbuf = _textBuffer.expandCurrentSegment(); [EOL] } [EOL] cbuf[cix++] = (char) ch; [EOL] } [EOL] String baseName = new String(cbuf, 0, cix); [EOL] if (lastQuadBytes < 4) { [EOL] quads[qlen - 1] = lastQuad; [EOL] } [EOL] return _symbols.addName(baseName, quads, qlen); [EOL] }
public void testHandleUnexpectedValueWithSingleQuote() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserWithFeatureEnabled(Feature.ALLOW_SINGLE_QUOTES); [EOL] JsonToken result = parser._handleUnexpectedValue('\''); [EOL] assertEquals(JsonToken.VALUE_STRING, result); [EOL] }
public void testHandleUnexpectedValueWithN() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserWithFeatureEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS); [EOL] JsonToken result = parser._handleUnexpectedValue('N'); [EOL] assertEquals(JsonToken.VALUE_NUMBER_FLOAT, result); [EOL] }
public void testHandleUnexpectedValueWithNWithoutFeature() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserWithFeatureDisabled(Feature.ALLOW_NON_NUMERIC_NUMBERS); [EOL] try { [EOL] parser._handleUnexpectedValue('N'); [EOL] fail("Should throw JsonParseException for non-standard token 'NaN'"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testHandleUnexpectedValueWithI() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserWithFeatureEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS); [EOL] JsonToken result = parser._handleUnexpectedValue('I'); [EOL] assertEquals(JsonToken.VALUE_NUMBER_FLOAT, result); [EOL] }
public void testHandleUnexpectedValueWithIWithoutFeature() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserWithFeatureDisabled(Feature.ALLOW_NON_NUMERIC_NUMBERS); [EOL] try { [EOL] parser._handleUnexpectedValue('I'); [EOL] fail("Should throw JsonParseException for non-standard token 'Infinity'"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testHandleUnexpectedValueWithPlus() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserWithInput("+"); [EOL] JsonToken result = parser._handleUnexpectedValue('+'); [EOL] assertEquals(JsonToken.VALUE_NUMBER_INT, result); [EOL] }
public void testHandleUnexpectedValueWithJavaIdentifierStart() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserWithInput("a"); [EOL] try { [EOL] parser._handleUnexpectedValue('a'); [EOL] fail("Should throw JsonParseException for invalid token starting with a Java identifier start character"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testHandleUnexpectedValueWithInvalidChar() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserWithInput("@"); [EOL] try { [EOL] parser._handleUnexpectedValue('@'); [EOL] fail("Should throw JsonParseException for unexpected character"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
protected JsonToken _handleApostropheValue() throws IOException, JsonParseException { [EOL] int c = 0; [EOL] int outPtr = 0; [EOL] char[] outBuf = _textBuffer.emptyAndGetCurrentSegment(); [EOL] final int[] codes = sInputCodesUtf8; [EOL] final byte[] inputBuffer = _inputBuffer; [EOL] main_loop: while (true) { [EOL] ascii_loop: while (true) { [EOL] if (_inputPtr >= _inputEnd) { [EOL] loadMoreGuaranteed(); [EOL] } [EOL] if (outPtr >= outBuf.length) { [EOL] outBuf = _textBuffer.finishCurrentSegment(); [EOL] outPtr = 0; [EOL] } [EOL] int max = _inputEnd; [EOL] { [EOL] int max2 = _inputPtr + (outBuf.length - outPtr); [EOL] if (max2 < max) { [EOL] max = max2; [EOL] } [EOL] } [EOL] while (_inputPtr < max) { [EOL] c = (int) inputBuffer[_inputPtr++] & 0xFF; [EOL] if (c == INT_APOSTROPHE || codes[c] != 0) { [EOL] break ascii_loop; [EOL] } [EOL] outBuf[outPtr++] = (char) c; [EOL] } [EOL] } [EOL] if (c == INT_APOSTROPHE) { [EOL] break main_loop; [EOL] } [EOL] switch(codes[c]) { [EOL] case 1: [EOL] if (c != INT_QUOTE) { [EOL] c = _decodeEscaped(); [EOL] } [EOL] break; [EOL] case 2: [EOL] c = _decodeUtf8_2(c); [EOL] break; [EOL] case 3: [EOL] if ((_inputEnd - _inputPtr) >= 2) { [EOL] c = _decodeUtf8_3fast(c); [EOL] } else { [EOL] c = _decodeUtf8_3(c); [EOL] } [EOL] break; [EOL] case 4: [EOL] c = _decodeUtf8_4(c); [EOL] outBuf[outPtr++] = (char) (0xD800 | (c >> 10)); [EOL] if (outPtr >= outBuf.length) { [EOL] outBuf = _textBuffer.finishCurrentSegment(); [EOL] outPtr = 0; [EOL] } [EOL] c = 0xDC00 | (c & 0x3FF); [EOL] break; [EOL] default: [EOL] if (c < INT_SPACE) { [EOL] _throwUnquotedSpace(c, "string value"); [EOL] } [EOL] _reportInvalidChar(c); [EOL] } [EOL] if (outPtr >= outBuf.length) { [EOL] outBuf = _textBuffer.finishCurrentSegment(); [EOL] outPtr = 0; [EOL] } [EOL] outBuf[outPtr++] = (char) c; [EOL] } [EOL] _textBuffer.setCurrentLength(outPtr); [EOL] return JsonToken.VALUE_STRING; [EOL] }
public void testMatchTokenWithExactMatch() throws IOException, JsonParseException { [EOL] String matchStr = "token"; [EOL] int i = 0; [EOL] _inputPtr = 0; [EOL] _inputEnd = matchStr.length(); [EOL] _inputBuffer = matchStr.toCharArray(); [EOL] _matchToken(matchStr, i); [EOL] assertEquals(_inputPtr, matchStr.length()); [EOL] }
public void testMatchTokenWithPartialMatch() throws IOException, JsonParseException { [EOL] String matchStr = "token"; [EOL] int i = 0; [EOL] _inputPtr = 0; [EOL] _inputEnd = 3; // simulate partial buffer load [EOL] _inputBuffer = new char[]{'t', 'o', 'k', 'e', 'n'}; [EOL] try { [EOL] _matchToken(matchStr, i); [EOL] fail("Should have thrown JsonParseException due to partial match"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testMatchTokenWithInvalidChar() throws IOException, JsonParseException { [EOL] String matchStr = "token"; [EOL] int i = 0; [EOL] _inputPtr = 0; [EOL] _inputEnd = matchStr.length() + 1; [EOL] _inputBuffer = new char[]{'t', 'o', 'k', 'e', 'n', '1'}; [EOL] try { [EOL] _matchToken(matchStr, i); [EOL] fail("Should have thrown JsonParseException due to invalid char after token"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testMatchTokenAtEndOfInput() throws IOException, JsonParseException { [EOL] String matchStr = "token"; [EOL] int i = 0; [EOL] _inputPtr = 0; [EOL] _inputEnd = matchStr.length(); [EOL] _inputBuffer = new char[]{'t', 'o', 'k', 'e', 'n', '}', ']'}; [EOL] _matchToken(matchStr, i); [EOL] assertEquals(_inputPtr, matchStr.length()); [EOL] }
protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException { [EOL] ByteArrayBuilder builder = _getByteArrayBuilder(); [EOL] while (true) { [EOL] int ch; [EOL] do { [EOL] if (_inputPtr >= _inputEnd) { [EOL] loadMoreGuaranteed(); [EOL] } [EOL] ch = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL] } while (ch <= INT_SPACE); [EOL] int bits = b64variant.decodeBase64Char(ch); [EOL] if (bits < 0) { [EOL] if (ch == INT_QUOTE) { [EOL] return builder.toByteArray(); [EOL] } [EOL] bits = _decodeBase64Escape(b64variant, ch, 0); [EOL] if (bits < 0) { [EOL] continue; [EOL] } [EOL] } [EOL] int decodedData = bits; [EOL] if (_inputPtr >= _inputEnd) { [EOL] loadMoreGuaranteed(); [EOL] } [EOL] ch = _inputBuffer[_inputPtr++] & 0xFF; [EOL] bits = b64variant.decodeBase64Char(ch); [EOL] if (bits < 0) { [EOL] bits = _decodeBase64Escape(b64variant, ch, 1); [EOL] } [EOL] decodedData = (decodedData << 6) | bits; [EOL] if (_inputPtr >= _inputEnd) { [EOL] loadMoreGuaranteed(); [EOL] } [EOL] ch = _inputBuffer[_inputPtr++] & 0xFF; [EOL] bits = b64variant.decodeBase64Char(ch); [EOL] if (bits < 0) { [EOL] if (bits != Base64Variant.BASE64_VALUE_PADDING) { [EOL] if (ch == '"' && !b64variant.usesPadding()) { [EOL] decodedData >>= 4; [EOL] builder.append(decodedData); [EOL] return builder.toByteArray(); [EOL] } [EOL] bits = _decodeBase64Escape(b64variant, ch, 2); [EOL] } [EOL] if (bits == Base64Variant.BASE64_VALUE_PADDING) { [EOL] if (_inputPtr >= _inputEnd) { [EOL] loadMoreGuaranteed(); [EOL] } [EOL] ch = _inputBuffer[_inputPtr++] & 0xFF; [EOL] if (!b64variant.usesPaddingChar(ch)) { [EOL] throw reportInvalidBase64Char(b64variant, ch, 3, "expected padding character '" + b64variant.getPaddingChar() + "'"); [EOL] } [EOL] decodedData >>= 4; [EOL] builder.append(decodedData); [EOL] continue; [EOL] } [EOL] } [EOL] decodedData = (decodedData << 6) | bits; [EOL] if (_inputPtr >= _inputEnd) { [EOL] loadMoreGuaranteed(); [EOL] } [EOL] ch = _inputBuffer[_inputPtr++] & 0xFF; [EOL] bits = b64variant.decodeBase64Char(ch); [EOL] if (bits < 0) { [EOL] if (bits != Base64Variant.BASE64_VALUE_PADDING) { [EOL] if (ch == '"' && !b64variant.usesPadding()) { [EOL] decodedData >>= 2; [EOL] builder.appendTwoBytes(decodedData); [EOL] return builder.toByteArray(); [EOL] } [EOL] bits = _decodeBase64Escape(b64variant, ch, 3); [EOL] } [EOL] if (bits == Base64Variant.BASE64_VALUE_PADDING) { [EOL] decodedData >>= 2; [EOL] builder.appendTwoBytes(decodedData); [EOL] continue; [EOL] } [EOL] } [EOL] decodedData = (decodedData << 6) | bits; [EOL] builder.appendThreeBytes(decodedData); [EOL] } [EOL] }
public void testUTF8WriterWithValidContextAndOutputStream() { [EOL] IOContext ctxt = new IOContext(new BufferRecycler(), new Object(), false); [EOL] OutputStream out = new ByteArrayOutputStream(); [EOL] UTF8Writer writer = new UTF8Writer(ctxt, out); [EOL] assertNotNull(writer); [EOL] assertNotNull(writer._context); [EOL] assertNotNull(writer._out); [EOL] assertNotNull(writer._outBuffer); [EOL] assertTrue(writer._outBufferEnd > 0); [EOL] assertEquals(0, writer._outPtr); [EOL] }

public void testCloseWithNonNullOutAndNonEmptyBuffer() throws IOException { [EOL] OutputStream mockOut = mock(OutputStream.class); [EOL] JsonGeneratorImpl generator = createGeneratorWithMockedOut(mockOut); [EOL] generator._outPtr = 10; // assuming _outPtr is accessible, otherwise use reflection or other means [EOL] generator.close(); [EOL] verify(mockOut).write(any(byte[].class), eq(0), eq(10)); [EOL] verify(mockOut).close(); [EOL] assertNull(generator._out); [EOL] assertNull(generator._outBuffer); [EOL] assertEquals(0, generator._surrogate); [EOL] }
public void testCloseWithNonNullOutAndEmptyBuffer() throws IOException { [EOL] OutputStream mockOut = mock(OutputStream.class); [EOL] JsonGeneratorImpl generator = createGeneratorWithMockedOut(mockOut); [EOL] generator.close(); [EOL] verify(mockOut, never()).write(any(byte[].class), anyInt(), anyInt()); [EOL] verify(mockOut).close(); [EOL] assertNull(generator._out); [EOL] assertNull(generator._outBuffer); [EOL] assertEquals(0, generator._surrogate); [EOL] }
public void testCloseWithNullOut() throws IOException { [EOL] JsonGeneratorImpl generator = new JsonGeneratorImpl(); [EOL] generator.close(); [EOL] }
public void testCloseWithIllegalSurrogate() throws IOException { [EOL] OutputStream mockOut = mock(OutputStream.class); [EOL] JsonGeneratorImpl generator = createGeneratorWithMockedOut(mockOut); [EOL] generator._surrogate = 55296; // assuming _surrogate is accessible, otherwise use reflection or other means [EOL] try { [EOL] generator.close(); [EOL] fail("Expected IOException due to illegal surrogate"); [EOL] } catch (IOException e) { [EOL] } [EOL] verify(mockOut).close(); [EOL] assertEquals(0, generator._surrogate); [EOL] }
public void testFlushWithNonNullOutAndNonZeroOutPtr() throws IOException { [EOL] OutputStream out = mock(OutputStream.class); [EOL] MyClass myClass = new MyClass(out); [EOL] myClass._outPtr = 10; [EOL] myClass.flush(); [EOL] verify(out).write(myClass._outBuffer, 0, myClass._outPtr); [EOL] assertEquals(0, myClass._outPtr); [EOL] verify(out).flush(); [EOL] }
public void testFlushWithNonNullOutAndZeroOutPtr() throws IOException { [EOL] OutputStream out = mock(OutputStream.class); [EOL] MyClass myClass = new MyClass(out); [EOL] myClass._outPtr = 0; [EOL] myClass.flush(); [EOL] verify(out, never()).write(any(byte[].class), anyInt(), anyInt()); [EOL] verify(out).flush(); [EOL] }
public void testFlushWithNullOut() throws IOException { [EOL] MyClass myClass = new MyClass(null); [EOL] myClass.flush(); [EOL] }
public void testWriteWithSurrogate() throws IOException { [EOL] _surrogate = 1; // Set surrogate to trigger the if block [EOL] int c = SURR1_FIRST; // Value within surrogate range [EOL] write(c); [EOL] assertEquals("Surrogate should be converted", expectedValue, _surrogate); [EOL] }
public void testWriteWithHighSurrogate() throws IOException { [EOL] _surrogate = 0; [EOL] int c = SURR1_LAST + 1; // Value just above the high surrogate range [EOL] write(c); [EOL] assertEquals("Should have set surrogate", c, _surrogate); [EOL] }
public void testWriteWithLowSurrogate() throws IOException { [EOL] _surrogate = 0; [EOL] int c = SURR1_LAST - 1; // Value just below the high surrogate range [EOL] write(c); [EOL] assertEquals("Should not have set surrogate", 0, _surrogate); [EOL] }
public void testWriteBufferOverflow() throws IOException { [EOL] _outPtr = _outBufferEnd; // Set to simulate buffer overflow [EOL] int c = 'a'; // ASCII value to avoid surrogate handling [EOL] write(c); [EOL] assertEquals("Buffer should be flushed", 0, _outPtr); [EOL] }
public void testWriteAscii() throws IOException { [EOL] _outPtr = 0; [EOL] int c = 'a'; // ASCII value to avoid surrogate handling [EOL] write(c); [EOL] assertEquals("ASCII character should be written to buffer", (byte) c, _outBuffer[_outPtr - 1]); [EOL] }
public void testWriteTwoByteUtf8() throws IOException { [EOL] _outPtr = 0; [EOL] int c = 0x80; // Start of two-byte UTF-8 range [EOL] write(c); [EOL] assertEquals("First byte of two-byte UTF-8 character should be written to buffer", (byte) (0xc0 | (c >> 6)), _outBuffer[_outPtr - 2]); [EOL] assertEquals("Second byte of two-byte UTF-8 character should be written to buffer", (byte) (0x80 | (c & 0x3f)), _outBuffer[_outPtr - 1]); [EOL] }
public void testWriteThreeByteUtf8() throws IOException { [EOL] _outPtr = 0; [EOL] int c = 0x800; // Start of three-byte UTF-8 range [EOL] write(c); [EOL] assertEquals("First byte of three-byte UTF-8 character should be written to buffer", (byte) (0xe0 | (c >> 12)), _outBuffer[_outPtr - 3]); [EOL] assertEquals("Second byte of three-byte UTF-8 character should be written to buffer", (byte) (0x80 | ((c >> 6) & 0x3f)), _outBuffer[_outPtr - 2]); [EOL] assertEquals("Third byte of three-byte UTF-8 character should be written to buffer", (byte) (0x80 | (c & 0x3f)), _outBuffer[_outPtr - 1]); [EOL] }
public void testWriteFourByteUtf8() throws IOException { [EOL] _outPtr = 0; [EOL] int c = 0x10000; // Start of four-byte UTF-8 range [EOL] write(c); [EOL] assertEquals("First byte of four-byte UTF-8 character should be written to buffer", (byte) (0xf0 | (c >> 18)), _outBuffer[_outPtr - 4]); [EOL] assertEquals("Second byte of four-byte UTF-8 character should be written to buffer", (byte) (0x80 | ((c >> 12) & 0x3f)), _outBuffer[_outPtr - 3]); [EOL] assertEquals("Third byte of four-byte UTF-8 character should be written to buffer", (byte) (0x80 | ((c >> 6) & 0x3f)), _outBuffer[_outPtr - 2]); [EOL] assertEquals("Fourth byte of four-byte UTF-8 character should be written to buffer", (byte) (0x80 | (c & 0x3f)), _outBuffer[_outPtr - 1]); [EOL] }
public void testWriteInvalidSurrogate() throws IOException { [EOL] _outPtr = 0; [EOL] int c = 0x110000; // Value above valid Unicode range [EOL] try { [EOL] write(c); [EOL] fail("Should have thrown an exception for invalid surrogate"); [EOL] } catch (IOException e) { [EOL] } [EOL] }
public void testSerializedStringWithNonNull() { [EOL] String testValue = "test"; [EOL] SerializedString serializedString = new SerializedString(testValue); [EOL] assertEquals(testValue, serializedString.getValue()); [EOL] }
public void testSerializedStringWithNull() { [EOL] try { [EOL] new SerializedString(null); [EOL] fail("Expected an IllegalStateException to be thrown"); [EOL] } catch (IllegalStateException e) { [EOL] assertEquals("Null String illegal for SerializedString", e.getMessage()); [EOL] } [EOL] }
public void testGetValue() { [EOL] JsonString jsonString = new JsonString("testValue"); [EOL] String result = jsonString.getValue(); [EOL] assertEquals("testValue", result); [EOL] }
public void testAsQuotedCharsWhenQuotedCharsIsNull() { [EOL] YourClass instance = new YourClass("someValue"); [EOL] char[] result = instance.asQuotedChars(); [EOL] assertNotNull(result); [EOL] char[] expected = JsonStringEncoder.getInstance().quoteAsString("someValue"); [EOL] assertArrayEquals(expected, result); [EOL] }
public void testAsQuotedCharsWhenQuotedCharsIsNotNull() { [EOL] YourClass instance = new YourClass("someValue"); [EOL] char[] prePopulatedChars = new char[]{'s', 'o', 'm', 'e', 'V', 'a', 'l', 'u', 'e'}; [EOL] instance.setQuotedChars(prePopulatedChars); // Assuming the existence of this setter method [EOL] char[] result = instance.asQuotedChars(); [EOL] assertSame(prePopulatedChars, result); [EOL] }
public void testAsUnquotedUTF8WhenCacheIsNull() { [EOL] SerializedString serializedString = new SerializedString("testValue"); [EOL] byte[] result = serializedString.asUnquotedUTF8(); [EOL] assertNotNull(result); [EOL] assertEquals("testValue", new String(result, StandardCharsets.UTF_8)); [EOL] } [EOL] public void testAsUnquotedUTF8WhenCacheIsNotNull() { [EOL] SerializedString serializedString = new SerializedString("testValue"); [EOL] serializedString.asUnquotedUTF8(); [EOL] byte[] cachedResult = serializedString.asUnquotedUTF8(); [EOL] assertNotNull(cachedResult); [EOL] assertEquals("testValue", new String(cachedResult, StandardCharsets.UTF_8)); [EOL] }
public void testAppendQuotedUTF8WithNullResult() { [EOL] MyClass instance = new MyClass("someValue"); [EOL] byte[] buffer = new byte[100]; [EOL] int offset = 0; [EOL] int result = instance.appendQuotedUTF8(buffer, offset); [EOL] assertTrue(result != -1); [EOL] byte[] expectedQuotedUTF8 = "expectedQuotedUTF8Bytes".getBytes(); [EOL] assertArrayEquals(expectedQuotedUTF8, Arrays.copyOfRange(buffer, offset, offset + result)); [EOL] }
public void testAppendQuotedUTF8WithInsufficientBufferSpace() { [EOL] MyClass instance = new MyClass("someValue"); [EOL] byte[] buffer = new byte[10]; // Smaller buffer than required [EOL] int offset = 0; [EOL] int result = instance.appendQuotedUTF8(buffer, offset); [EOL] assertEquals(-1, result); [EOL] }
public void testAppendQuotedWithSufficientBufferSpace() { [EOL] char[] buffer = new char[100]; [EOL] int offset = 10; [EOL] JsonStringEncoder encoder = JsonStringEncoder.getInstance(); [EOL] String value = "test"; [EOL] encoder.encode(value); // Assuming this method sets the _value and _quotedChars inside encoder [EOL] int length = encoder.appendQuoted(buffer, offset); [EOL] assertEquals(value.length(), length); [EOL] for (int i = offset; i < offset + length; i++) { [EOL] assertEquals(value.charAt(i - offset), buffer[i]); [EOL] } [EOL] }
public void testAppendQuotedWithInsufficientBufferSpace() { [EOL] char[] buffer = new char[10]; [EOL] int offset = 5; [EOL] JsonStringEncoder encoder = JsonStringEncoder.getInstance(); [EOL] String value = "longerTestValue"; [EOL] encoder.encode(value); // Assuming this method sets the _value and _quotedChars inside encoder [EOL] int result = encoder.appendQuoted(buffer, offset); [EOL] assertEquals(-1, result); [EOL] }
public void testAppendQuotedWhenQuotedCharsNotSet() { [EOL] char[] buffer = new char[100]; [EOL] int offset = 0; [EOL] JsonStringEncoder encoder = JsonStringEncoder.getInstance(); [EOL] String value = "newTest"; [EOL] int length = encoder.appendQuoted(buffer, offset); [EOL] assertEquals(value.length(), length); [EOL] for (int i = offset; i < offset + length; i++) { [EOL] assertEquals(value.charAt(i - offset), buffer[i]); [EOL] } [EOL] }
public void testAppendUnquotedUTF8WithNullRef() { [EOL] JsonStringEncoder encoder = new JsonStringEncoder(); [EOL] byte[] buffer = new byte[100]; [EOL] int offset = 0; [EOL] int length = encoder.appendUnquotedUTF8(buffer, offset); [EOL] assertTrue(length > 0); [EOL] assertTrue(length <= buffer.length); [EOL] } [EOL] public void testAppendUnquotedUTF8WithInsufficientBufferSpace() { [EOL] JsonStringEncoder encoder = new JsonStringEncoder(); [EOL] byte[] buffer = new byte[5]; // Assuming the encoded UTF8 is longer than 5 bytes [EOL] int offset = 0; [EOL] int length = encoder.appendUnquotedUTF8(buffer, offset); [EOL] assertEquals(-1, length); [EOL] }
public void testAppendUnquotedUTF8WithSufficientBufferSpace() { [EOL] JsonStringEncoder encoder = new JsonStringEncoder(); [EOL] byte[] buffer = new byte[100]; [EOL] int offset = 0; [EOL] encoder.appendUnquotedUTF8(buffer, offset); [EOL] int length = encoder.appendUnquotedUTF8(buffer, offset); [EOL] assertTrue(length > 0); [EOL] assertTrue((offset + length) <= buffer.length); [EOL] }
public void testAppendUnquotedBufferTooSmall() { [EOL] StringValue value = new StringValue("test"); [EOL] char[] buffer = new char[2]; [EOL] int result = value.appendUnquoted(buffer, 0); [EOL] assertEquals(-1, result); [EOL] }
public void testAppendUnquotedBufferExactFit() { [EOL] StringValue value = new StringValue("test"); [EOL] char[] buffer = new char[4]; [EOL] int result = value.appendUnquoted(buffer, 0); [EOL] assertEquals(4, result); [EOL] assertArrayEquals(new char[] {'t', 'e', 's', 't'}, buffer); [EOL] }
public void testAppendUnquotedBufferSufficientSize() { [EOL] StringValue value = new StringValue("test"); [EOL] char[] buffer = new char[10]; [EOL] int result = value.appendUnquoted(buffer, 3); [EOL] assertEquals(4, result); [EOL] assertArrayEquals(new char[] {'\u0000', '\u0000', '\u0000', 't', 'e', 's', 't', '\u0000', '\u0000', '\u0000'}, buffer); [EOL] }
public void testWriteQuotedUTF8WithNonNullQuotedRef() throws IOException { [EOL] JsonStringEncoderTestWrapper jsonStringEncoder = new JsonStringEncoderTestWrapper("testValue"); [EOL] byte[] quotedRef = new byte[] {34, 116, 101, 115, 116, 86, 97, 108, 117, 101, 34}; // UTF-8 for "testValue" [EOL] jsonStringEncoder.setQuotedUTF8Ref(quotedRef); [EOL] ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL] int length = jsonStringEncoder.writeQuotedUTF8(out); [EOL] assertArrayEquals(quotedRef, out.toByteArray()); [EOL] assertEquals(quotedRef.length, length); [EOL] }
public void testWriteQuotedUTF8WithNullQuotedRef() throws IOException { [EOL] JsonStringEncoderTestWrapper jsonStringEncoder = new JsonStringEncoderTestWrapper("testValue"); [EOL] ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL] byte[] expected = JsonStringEncoder.getInstance().quoteAsUTF8("testValue"); [EOL] int length = jsonStringEncoder.writeQuotedUTF8(out); [EOL] assertArrayEquals(expected, out.toByteArray()); [EOL] assertEquals(expected.length, length); [EOL] }
public void testWriteUnquotedUTF8WithNonNullRef() throws IOException { [EOL] OutputStream out = new ByteArrayOutputStream(); [EOL] SerializedString serializedString = new SerializedString("test"); [EOL] int length = serializedString.writeUnquotedUTF8(out); [EOL] assertEquals(4, length); [EOL] assertEquals("test", out.toString()); [EOL] }
public void testWriteUnquotedUTF8WithNullRef() throws IOException { [EOL] OutputStream out = new ByteArrayOutputStream(); [EOL] SerializedString serializedString = new SerializedString("test"); [EOL] Field unquotedUTF8RefField = SerializedString.class.getDeclaredField("_unquotedUTF8Ref"); [EOL] unquotedUTF8RefField.setAccessible(true); [EOL] unquotedUTF8RefField.set(serializedString, null); [EOL] int length = serializedString.writeUnquotedUTF8(out); [EOL] assertEquals(4, length); [EOL] assertEquals("test", out.toString()); [EOL] }
public void testPutQuotedUTF8WithNullResult() { [EOL] MyClass instance = new MyClass("someValue"); [EOL] ByteBuffer buffer = ByteBuffer.allocate(1024); // Ensure the buffer is large enough [EOL] int result = instance.putQuotedUTF8(buffer); [EOL] assertTrue("The result should be non-negative", result >= 0); [EOL] assertTrue("The buffer should contain the quoted UTF8 bytes", buffer.position() > 0); [EOL] }
public void testPutQuotedUTF8WithExistingResult() { [EOL] MyClass instance = new MyClass("someValue"); [EOL] instance.setQuotedUTF8Ref(new byte[] { /* some valid UTF-8 bytes */ }); [EOL] ByteBuffer buffer = ByteBuffer.allocate(1024); // Ensure the buffer is large enough [EOL] int result = instance.putQuotedUTF8(buffer); [EOL] assertTrue("The result should be non-negative", result >= 0); [EOL] assertTrue("The buffer should contain the quoted UTF8 bytes", buffer.position() > 0); [EOL] }
public void testPutQuotedUTF8WithInsufficientBufferSpace() { [EOL] MyClass instance = new MyClass("someValue"); [EOL] ByteBuffer buffer = ByteBuffer.allocate(1); // Intentionally small buffer [EOL] int result = instance.putQuotedUTF8(buffer); [EOL] assertEquals("The result should indicate buffer overflow with -1", -1, result); [EOL] }
public void testPutUnquotedUTF8WithSufficientBufferSpace() { [EOL] String value = "testValue"; [EOL] JsonStringEncoder encoder = new JsonStringEncoder(value); [EOL] ByteBuffer buffer = ByteBuffer.allocate(1024); // Assuming 1024 is sufficient [EOL] int length = encoder.putUnquotedUTF8(buffer); [EOL] assertEquals(value.getBytes(StandardCharsets.UTF_8).length, length); [EOL] }
public void testPutUnquotedUTF8WithInsufficientBufferSpace() { [EOL] String value = "testValue"; [EOL] JsonStringEncoder encoder = new JsonStringEncoder(value); [EOL] ByteBuffer buffer = ByteBuffer.allocate(4); // Assuming "testValue" is longer than 4 bytes [EOL] int length = encoder.putUnquotedUTF8(buffer); [EOL] assertEquals(-1, length); [EOL] }
public void testToStringReturnsCorrectValue() { [EOL] String expected = "testValue"; [EOL] JsonString jsonString = new JsonString(expected); [EOL] String result = jsonString.toString(); [EOL] assertEquals(expected, result); [EOL] }
public void testSetEncodingUtf8() { [EOL] JsonFactory factory = new JsonFactory(); [EOL] factory.setEncoding(JsonEncoding.UTF8); [EOL] assertEquals(JsonEncoding.UTF8, factory._encoding); [EOL] }
public void testSetEncodingUtf16() { [EOL] JsonFactory factory = new JsonFactory(); [EOL] factory.setEncoding(JsonEncoding.UTF16); [EOL] assertEquals(JsonEncoding.UTF16, factory._encoding); [EOL] }
public void testSetEncodingUtf16BE() { [EOL] JsonFactory factory = new JsonFactory(); [EOL] factory.setEncoding(JsonEncoding.UTF16_BE); [EOL] assertEquals(JsonEncoding.UTF16_BE, factory._encoding); [EOL] }
public void testSetEncodingUtf16LE() { [EOL] JsonFactory factory = new JsonFactory(); [EOL] factory.setEncoding(JsonEncoding.UTF16_LE); [EOL] assertEquals(JsonEncoding.UTF16_LE, factory._encoding); [EOL] }
public void testSetEncodingUtf32() { [EOL] JsonFactory factory = new JsonFactory(); [EOL] factory.setEncoding(JsonEncoding.UTF32); [EOL] assertEquals(JsonEncoding.UTF32, factory._encoding); [EOL] }
public void testSetEncodingUtf32BE() { [EOL] JsonFactory factory = new JsonFactory(); [EOL] factory.setEncoding(JsonEncoding.UTF32_BE); [EOL] assertEquals(JsonEncoding.UTF32_BE, factory._encoding); [EOL] }
public void testSetEncodingUtf32LE() { [EOL] JsonFactory factory = new JsonFactory(); [EOL] factory.setEncoding(JsonEncoding.UTF32_LE); [EOL] assertEquals(JsonEncoding.UTF32_LE, factory._encoding); [EOL] }
public void testIsResourceManaged_True() { [EOL] Resource resource = new Resource(true); // Constructor that sets _managedResource to true [EOL] assertTrue(resource.isResourceManaged()); [EOL] }
public void testIsResourceManaged_False() { [EOL] Resource resource = new Resource(false); // Constructor that sets _managedResource to false [EOL] assertFalse(resource.isResourceManaged()); [EOL] }
public void testConstructTextBuffer() { [EOL] JsonFactory jsonFactory = new JsonFactory(); [EOL] TextBuffer textBuffer = jsonFactory.constructTextBuffer(); [EOL] assertNotNull(textBuffer); [EOL] }
public void testReleaseReadIOBufferWithNonNullBuffer() { [EOL] byte[] buf = new byte[10]; // Assuming _readIOBuffer is initialized with some buffer [EOL] JsonFactory factory = new JsonFactory(); [EOL] BufferRecycler recycler = new BufferRecycler(); [EOL] factory._bufferRecycler = recycler; [EOL] factory._readIOBuffer = new byte[10]; [EOL] factory.releaseReadIOBuffer(buf); [EOL] assertNull(factory._readIOBuffer); [EOL] assertTrue(recycler.hasBeenReleased(BufferRecycler.ByteBufferType.READ_IO_BUFFER)); [EOL] }
public void testReleaseReadIOBufferWithNullBuffer() { [EOL] JsonFactory factory = new JsonFactory(); [EOL] factory._readIOBuffer = new byte[10]; // Assuming _readIOBuffer is initialized with some buffer [EOL] BufferRecycler recycler = new BufferRecycler(); [EOL] factory._bufferRecycler = recycler; [EOL] factory.releaseReadIOBuffer(null); [EOL] assertNotNull(factory._readIOBuffer); [EOL] assertFalse(recycler.hasBeenReleased(BufferRecycler.ByteBufferType.READ_IO_BUFFER)); [EOL] }
public void testReleaseTokenBufferWithNonNullBuffer() { [EOL] JsonFactory factory = new JsonFactory(); [EOL] JsonParser parser = factory.createParser("{}"); [EOL] char[] testBuffer = new char[10]; [EOL] parser.releaseTokenBuffer(testBuffer); [EOL] }
public void testReleaseTokenBufferWithNullBuffer() { [EOL] JsonFactory factory = new JsonFactory(); [EOL] JsonParser parser = factory.createParser("{}"); [EOL] parser.releaseTokenBuffer(null); [EOL] }
public void testStandardAsciiEscapesForJSON() { [EOL] int[] asciiEscapes = JsonStringEncoder.standardAsciiEscapesForJSON(); [EOL] int[] expectedEscapes = CharTypes.get7BitOutputEscapes(); [EOL] assertNotNull("The returned array should not be null", asciiEscapes); [EOL] assertEquals("The length of the arrays should be the same", expectedEscapes.length, asciiEscapes.length); [EOL] for (int i = 0; i < expectedEscapes.length; i++) { [EOL] assertEquals("The array content should match at index " + i, expectedEscapes[i], asciiEscapes[i]); [EOL] } [EOL] }
public void testGetEmptyName() { [EOL] Name1 result = Name1.getEmptyName(); [EOL] assertNotNull(result); [EOL] assertTrue(result.isEmpty()); [EOL] }
public void testEqualsWithBothQuadsZero() { [EOL] SomeClass instance = new SomeClass(0); [EOL] assertTrue(instance.equals(0, 0)); [EOL] }
public void testEqualsWithFirstQuadNonZero() { [EOL] SomeClass instance = new SomeClass(1); [EOL] assertFalse(instance.equals(2, 0)); [EOL] }
public void testEqualsWithSecondQuadNonZero() { [EOL] SomeClass instance = new SomeClass(0); [EOL] assertFalse(instance.equals(0, 1)); [EOL] }
public void testEqualsWithBothQuadsNonZeroAndDifferent() { [EOL] SomeClass instance = new SomeClass(1); [EOL] assertFalse(instance.equals(2, 3)); [EOL] }
public void testEqualsWithBothQuadsNonZeroAndFirstQuadMatches() { [EOL] SomeClass instance = new SomeClass(2); [EOL] assertFalse(instance.equals(2, 3)); [EOL] }
public void testDataFormatDetectorWithNullDetectors() { [EOL] JsonFactory[] detectors = null; [EOL] try { [EOL] new DataFormatDetector(detectors); [EOL] fail("Should not pass with null detectors array"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testDataFormatDetectorWithEmptyDetectors() { [EOL] JsonFactory[] detectors = new JsonFactory[0]; [EOL] DataFormatDetector detector = new DataFormatDetector(detectors); [EOL] assertNotNull(detector); [EOL] }
public void testDataFormatDetectorWithSingleDetector() { [EOL] JsonFactory[] detectors = new JsonFactory[] {new JsonFactory()}; [EOL] DataFormatDetector detector = new DataFormatDetector(detectors); [EOL] assertNotNull(detector); [EOL] }
public void testDataFormatDetectorWithMultipleDetectors() { [EOL] JsonFactory[] detectors = new JsonFactory[] {new JsonFactory(), new JsonFactory()}; [EOL] DataFormatDetector detector = new DataFormatDetector(detectors); [EOL] assertNotNull(detector); [EOL] }
public void testDataFormatDetectorConstructor() { [EOL] JsonFactory[] detectors = new JsonFactory[] { new JsonFactory(), new JsonFactory() }; [EOL] MatchStrength optMatch = MatchStrength.SOLID_MATCH; [EOL] MatchStrength minMatch = MatchStrength.WEAK_MATCH; [EOL] int maxInputLookahead = 1024; [EOL] DataFormatDetector detector = new DataFormatDetector(detectors, optMatch, minMatch, maxInputLookahead); [EOL] assertNotNull(detector); [EOL] assertArrayEquals(detectors, detector.getDetectors()); [EOL] assertEquals(optMatch, detector.getOptimalMatch()); [EOL] assertEquals(minMatch, detector.getMinimalMatch()); [EOL] assertEquals(maxInputLookahead, detector.getMaxInputLookahead()); [EOL] }
public void testFindFormatWithNullInputStream() throws IOException { [EOL] DataFormatMatcher matcher = new ObjectMapper().getFactory().findFormat(null); [EOL] assertNull(matcher); [EOL] }
public void testFindFormatWithEmptyInputStream() throws IOException { [EOL] InputStream in = new ByteArrayInputStream(new byte[0]); [EOL] DataFormatMatcher matcher = new ObjectMapper().getFactory().findFormat(in); [EOL] assertNotNull(matcher); [EOL] assertFalse(matcher.hasMatch()); [EOL] }
public void testFindFormatWithNonEmptyInputStream() throws IOException { [EOL] byte[] data = new byte[] { /* some byte sequence that a DataFormatDetector can detect, e.g., JSON bytes */ }; [EOL] InputStream in = new ByteArrayInputStream(data); [EOL] DataFormatMatcher matcher = new ObjectMapper().getFactory().findFormat(in); [EOL] assertNotNull(matcher); [EOL] assertTrue(matcher.hasMatch()); [EOL] }
public void testFindFormat_NoDetectors() throws IOException { [EOL] InputAccessor.Std acc = mock(InputAccessor.Std.class); [EOL] DataFormatMatcher matcher = _findFormat(acc); [EOL] assertNull(matcher.getMatchedFactory()); [EOL] assertNull(matcher.getMatchStrength()); [EOL] }
public void testFindFormat_WithDetectors_NoMatch() throws IOException { [EOL] InputAccessor.Std acc = mock(InputAccessor.Std.class); [EOL] JsonFactory factory = mock(JsonFactory.class); [EOL] when(factory.hasFormat(acc)).thenReturn(null); [EOL] _detectors.add(factory); [EOL] DataFormatMatcher matcher = _findFormat(acc); [EOL] assertNull(matcher.getMatchedFactory()); [EOL] assertNull(matcher.getMatchStrength()); [EOL] }
public void testFindFormat_WithDetectors_BelowMinimalMatch() throws IOException { [EOL] InputAccessor.Std acc = mock(InputAccessor.Std.class); [EOL] JsonFactory factory = mock(JsonFactory.class); [EOL] when(factory.hasFormat(acc)).thenReturn(MatchStrength.WEAK); [EOL] _minimalMatch = MatchStrength.SOLID_MATCH; [EOL] _detectors.add(factory); [EOL] DataFormatMatcher matcher = _findFormat(acc); [EOL] assertNull(matcher.getMatchedFactory()); [EOL] assertNull(matcher.getMatchStrength()); [EOL] }
public void testFindFormat_WithDetectors_AboveMinimalMatch() throws IOException { [EOL] InputAccessor.Std acc = mock(InputAccessor.Std.class); [EOL] JsonFactory factory = mock(JsonFactory.class); [EOL] when(factory.hasFormat(acc)).thenReturn(MatchStrength.SOLID_MATCH); [EOL] _minimalMatch = MatchStrength.WEAK; [EOL] _detectors.add(factory); [EOL] DataFormatMatcher matcher = _findFormat(acc); [EOL] assertEquals(factory, matcher.getMatchedFactory()); [EOL] assertEquals(MatchStrength.SOLID_MATCH, matcher.getMatchStrength()); [EOL] }
public void testFindFormat_WithMultipleDetectors_SelectBestMatch() throws IOException { [EOL] InputAccessor.Std acc = mock(InputAccessor.Std.class); [EOL] JsonFactory factory1 = mock(JsonFactory.class); [EOL] JsonFactory factory2 = mock(JsonFactory.class); [EOL] when(factory1.hasFormat(acc)).thenReturn(MatchStrength.SOLID_MATCH); [EOL] when(factory2.hasFormat(acc)).thenReturn(MatchStrength.FULL_MATCH); [EOL] _minimalMatch = MatchStrength.WEAK; [EOL] _detectors.add(factory1); [EOL] _detectors.add(factory2); [EOL] DataFormatMatcher matcher = _findFormat(acc); [EOL] assertEquals(factory2, matcher.getMatchedFactory()); [EOL] assertEquals(MatchStrength.FULL_MATCH, matcher.getMatchStrength()); [EOL] }
public void testFindFormat_WithMultipleDetectors_OptimalMatch() throws IOException { [EOL] InputAccessor.Std acc = mock(InputAccessor.Std.class); [EOL] JsonFactory factory1 = mock(JsonFactory.class); [EOL] JsonFactory factory2 = mock(JsonFactory.class); [EOL] when(factory1.hasFormat(acc)).thenReturn(MatchStrength.SOLID_MATCH); [EOL] when(factory2.hasFormat(acc)).thenReturn(MatchStrength.FULL_MATCH); [EOL] _minimalMatch = MatchStrength.WEAK; [EOL] _optimalMatch = MatchStrength.FULL_MATCH; [EOL] _detectors.add(factory1); [EOL] _detectors.add(factory2); [EOL] DataFormatMatcher matcher = _findFormat(acc); [EOL] assertEquals(factory2, matcher.getMatchedFactory()); [EOL] assertEquals(MatchStrength.FULL_MATCH, matcher.getMatchStrength()); [EOL] }
public void testAsStringReturnsSerializedValue() { [EOL] YourObject obj = new YourObject("expectedValue"); [EOL] String result = obj.asString(); [EOL] assertEquals("expectedValue", result); [EOL] }
public void testJsonParserConstructor() { [EOL] try { [EOL] JsonParser parser = new JsonParser(); [EOL] assertNotNull(parser); [EOL] } catch (Exception e) { [EOL] fail("Constructor threw an exception: " + e.getMessage()); [EOL] } [EOL] }
public void testGetBooleanValueTrue() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserWithToken(JsonToken.VALUE_TRUE); [EOL] boolean result = parser.getBooleanValue(); [EOL] assertTrue(result); [EOL] } [EOL] public void testGetBooleanValueFalse() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserWithToken(JsonToken.VALUE_FALSE); [EOL] boolean result = parser.getBooleanValue(); [EOL] assertFalse(result); [EOL] } [EOL] public void testGetBooleanValueException() throws IOException { [EOL] JsonParser parser = createParserWithToken(JsonToken.VALUE_STRING); [EOL] try { [EOL] parser.getBooleanValue(); [EOL] fail("Expected JsonParseException"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }

public long getValueAsLongTest_defaultValue() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserWithNumber("123"); [EOL] parser.nextToken(); // Assuming this method exists and it advances the parser to the next token [EOL] long result = parser.getValueAsLong(); [EOL] assertEquals(123L, result); [EOL] }
public long getValueAsLongTest_withDefaultValue() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserWithNumber(""); // Assuming this creates a parser with no numeric value [EOL] parser.nextToken(); // Assuming this method exists and it advances the parser to the next token [EOL] long result = parser.getValueAsLong(); [EOL] assertEquals(0L, result); [EOL] }
public void testGetValueAsDouble() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserWithDoubleValue(); [EOL] double value = parser.getValueAsDouble(); [EOL] assertEquals("Expected default value to be returned", 0.0, value, 0.0); [EOL] }
public void testGetValueAsDoubleWithNonDefaultValue() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserWithDoubleValue(5.5); [EOL] double value = parser.getValueAsDouble(); [EOL] assertEquals("Expected actual value to be returned", 5.5, value, 0.0); [EOL] }
public void testGetValueAsBooleanTrue() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserWithBooleanValue(true); [EOL] assertTrue(parser.getValueAsBoolean()); [EOL] } [EOL] public void testGetValueAsBooleanFalse() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserWithBooleanValue(false); [EOL] assertFalse(parser.getValueAsBoolean()); [EOL] } [EOL] public void testGetValueAsBooleanException() { [EOL] JsonParser parser = createParserWithNonBooleanValue(); [EOL] try { [EOL] parser.getValueAsBoolean(); [EOL] fail("Expected an exception to be thrown"); [EOL] } catch (JsonParseException e) { [EOL] } catch (IOException e) { [EOL] fail("Expected a JsonParseException, not IOException"); [EOL] } [EOL] }
public void testSetCharacterEscapesWithNull() { [EOL] JsonGenerator generator = createJsonGenerator(); // Replace with actual generator creation [EOL] generator.setCharacterEscapes(null); [EOL] assertNull(generator.getCharacterEscapes()); [EOL] assertArrayEquals(JsonGenerator.sOutputEscapes, generator.getOutputEscapes()); [EOL] }
public void testSetCharacterEscapesWithNonNull() { [EOL] JsonGenerator generator = createJsonGenerator(); // Replace with actual generator creation [EOL] CharacterEscapes customEscapes = new CustomCharacterEscapes(); // Replace with actual CharacterEscapes implementation [EOL] generator.setCharacterEscapes(customEscapes); [EOL] assertEquals(customEscapes, generator.getCharacterEscapes()); [EOL] assertArrayEquals(customEscapes.getEscapeCodesForAscii(), generator.getOutputEscapes()); [EOL] }
public void testWriteStringFieldWithValidInput() throws IOException, JsonGenerationException { [EOL] JsonGenerator generator = createJsonGenerator(); // You need to implement this method to create an instance of JsonGenerator [EOL] String fieldName = "testField"; [EOL] String value = "testValue"; [EOL] generator.writeStringField(fieldName, value); [EOL] verifyWriteFieldNameCalled(generator, fieldName); [EOL] verifyWriteStringCalled(generator, value); [EOL] }
public void testWriteStringFieldWithNullFieldName() throws IOException, JsonGenerationException { [EOL] JsonGenerator generator = createJsonGenerator(); // You need to implement this method to create an instance of JsonGenerator [EOL] String fieldName = null; [EOL] String value = "testValue"; [EOL] generator.writeStringField(fieldName, value); [EOL] verifyWriteFieldNameCalledWithNull(generator); [EOL] verifyWriteStringCalled(generator, value); [EOL] }
public void testWriteStringFieldWithNullValue() throws IOException, JsonGenerationException { [EOL] JsonGenerator generator = createJsonGenerator(); // You need to implement this method to create an instance of JsonGenerator [EOL] String fieldName = "testField"; [EOL] String value = null; [EOL] generator.writeStringField(fieldName, value); [EOL] verifyWriteFieldNameCalled(generator, fieldName); [EOL] verifyWriteStringCalledWithNull(generator); [EOL] }
public void testReleaseBuffersWithNullAllocator() { [EOL] JsonGeneratorImpl generator = new JsonGeneratorImpl(null); [EOL] generator.releaseBuffers(); [EOL] assertNull(generator.getCurrentSegment()); [EOL] }
public void testReleaseBuffersWithNonNullAllocatorAndNullCurrentSegment() { [EOL] BufferRecycler allocator = new BufferRecycler(); [EOL] JsonGeneratorImpl generator = new JsonGeneratorImpl(allocator); [EOL] generator.setCurrentSegment(null); [EOL] generator.releaseBuffers(); [EOL] assertNull(generator.getCurrentSegment()); [EOL] }
public void testReleaseBuffersWithNonNullAllocatorAndNonNullCurrentSegment() { [EOL] BufferRecycler allocator = new BufferRecycler(); [EOL] JsonGeneratorImpl generator = new JsonGeneratorImpl(allocator); [EOL] char[] segment = new char[100]; [EOL] generator.setCurrentSegment(segment); [EOL] generator.releaseBuffers(); [EOL] assertNull(generator.getCurrentSegment()); [EOL] assertTrue(allocator.hasReleasedCharBuffer(BufferRecycler.CharBufferType.TEXT_BUFFER, segment)); [EOL] }
public void testResetWithEmpty_NoSegments() { [EOL] TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL] tb.resetWithEmpty(); [EOL] assertNull(tb._inputBuffer); [EOL] assertEquals(-1, tb._inputStart); [EOL] assertEquals(0, tb._currentSize); [EOL] assertEquals(0, tb._inputLen); [EOL] assertNull(tb._resultString); [EOL] assertNull(tb._resultArray); [EOL] assertFalse(tb._hasSegments); [EOL] }
public void testResetWithEmpty_WithSegments() { [EOL] TextBuffer tb = new TextBuffer(new BufferRecycler()); [EOL] tb.append('a'); // This will create the first segment [EOL] tb.resetWithEmpty(); [EOL] assertNull(tb._inputBuffer); [EOL] assertEquals(-1, tb._inputStart); [EOL] assertEquals(0, tb._currentSize); [EOL] assertEquals(0, tb._inputLen); [EOL] assertNull(tb._resultString); [EOL] assertNull(tb._resultArray); [EOL] assertFalse(tb._hasSegments); // Assuming clearSegments() sets _hasSegments to false [EOL] }
private char[] findBuffer(int needed) { [EOL] if (_allocator != null) { [EOL] return _allocator.allocCharBuffer(BufferRecycler.CharBufferType.TEXT_BUFFER, needed); [EOL] } [EOL] return new char[Math.max(needed, MIN_SEGMENT_LEN)]; [EOL] }
public void testGetTextOffset_InputStartPositive() { [EOL] JsonParser parser = createParserWithInputStart(5); [EOL] int offset = parser.getTextOffset(); [EOL] assertEquals(5, offset); [EOL] } [EOL] public void testGetTextOffset_InputStartNegative() { [EOL] JsonParser parser = createParserWithInputStart(-1); [EOL] int offset = parser.getTextOffset(); [EOL] assertEquals(0, offset); [EOL] }
public void testGetTextBuffer_InputStartGreaterThanOrEqualToZero() { [EOL] YourClassUnderTest instance = new YourClassUnderTest(); [EOL] instance._inputStart = 1; // any value >= 0 [EOL] instance._inputBuffer = new char[]{'a', 'b', 'c'}; [EOL] char[] result = instance.getTextBuffer(); [EOL] assertArrayEquals(instance._inputBuffer, result); [EOL] }
public void testGetTextBuffer_ResultArrayNotNull() { [EOL] YourClassUnderTest instance = new YourClassUnderTest(); [EOL] instance._inputStart = -1; // to bypass the first if condition [EOL] instance._resultArray = new char[]{'x', 'y', 'z'}; [EOL] char[] result = instance.getTextBuffer(); [EOL] assertArrayEquals(instance._resultArray, result); [EOL] }
public void testGetTextBuffer_ResultStringNotNull() { [EOL] YourClassUnderTest instance = new YourClassUnderTest(); [EOL] instance._inputStart = -1; // to bypass the first if condition [EOL] instance._resultArray = null; [EOL] instance._resultString = "test"; [EOL] char[] result = instance.getTextBuffer(); [EOL] assertArrayEquals("test".toCharArray(), result); [EOL] }
public void testGetTextBuffer_HasSegmentsFalse() { [EOL] YourClassUnderTest instance = new YourClassUnderTest(); [EOL] instance._inputStart = -1; // to bypass the first if condition [EOL] instance._resultArray = null; [EOL] instance._resultString = null; [EOL] instance._hasSegments = false; [EOL] instance._currentSegment = new char[]{'s', 'e', 'g'}; [EOL] char[] result = instance.getTextBuffer(); [EOL] assertArrayEquals(instance._currentSegment, result); [EOL] }
public void testGetTextBuffer_Otherwise() { [EOL] YourClassUnderTest instance = new YourClassUnderTest(); [EOL] instance._inputStart = -1; // to bypass the first if condition [EOL] instance._resultArray = null; [EOL] instance._resultString = null; [EOL] instance._hasSegments = true; [EOL] char[] expected = instance.contentsAsArray(); [EOL] char[] result = instance.getTextBuffer(); [EOL] assertArrayEquals(expected, result); [EOL] }
public void testContentsAsString_resultStringNullAndResultArrayNotNull() { [EOL] instance._resultString = null; [EOL] instance._resultArray = new char[]{'a', 'b', 'c'}; [EOL] String result = instance.contentsAsString(); [EOL] assertEquals("abc", result); [EOL] }
public void testContentsAsString_resultStringNullAndInputStartNotNegative() { [EOL] instance._resultString = null; [EOL] instance._resultArray = null; [EOL] instance._inputStart = 0; [EOL] instance._inputLen = 3; [EOL] instance._inputBuffer = new char[]{'x', 'y', 'z'}; [EOL] String result = instance.contentsAsString(); [EOL] assertEquals("xyz", result); [EOL] }
public void testContentsAsString_resultStringNullAndInputLenLessThanOne() { [EOL] instance._resultString = null; [EOL] instance._resultArray = null; [EOL] instance._inputStart = 0; [EOL] instance._inputLen = 0; [EOL] String result = instance.contentsAsString(); [EOL] assertEquals("", result); [EOL] }
public void testContentsAsString_resultStringNullAndSegmentSizeZeroAndCurrentSizeZero() { [EOL] instance._resultString = null; [EOL] instance._resultArray = null; [EOL] instance._inputStart = -1; [EOL] instance._segmentSize = 0; [EOL] instance._currentSize = 0; [EOL] String result = instance.contentsAsString(); [EOL] assertEquals("", result); [EOL] }
public void testContentsAsString_resultStringNullAndSegmentSizeZeroAndCurrentSizeNotZero() { [EOL] instance._resultString = null; [EOL] instance._resultArray = null; [EOL] instance._inputStart = -1; [EOL] instance._segmentSize = 0; [EOL] instance._currentSize = 2; [EOL] instance._currentSegment = new char[]{'u', 'v'}; [EOL] String result = instance.contentsAsString(); [EOL] assertEquals("uv", result); [EOL] }
public void testContentsAsString_resultStringNullAndSegmentsNotNull() { [EOL] instance._resultString = null; [EOL] instance._resultArray = null; [EOL] instance._inputStart = -1; [EOL] instance._segmentSize = 1; [EOL] instance._currentSize = 1; [EOL] instance._currentSegment = new char[]{'w'}; [EOL] instance._segments = new ArrayList<>(); [EOL] instance._segments.add(new char[]{'t'}); [EOL] String result = instance.contentsAsString(); [EOL] assertEquals("tw", result); [EOL] }
public void testContentsAsString_resultStringNotNull() { [EOL] instance._resultString = "precomputed"; [EOL] String result = instance.contentsAsString(); [EOL] assertEquals("precomputed", result); [EOL] }
public void testContentsAsDoubleWithValidDouble() { [EOL] JsonParser parser = createParserWithContent("42.0"); [EOL] assertEquals(42.0, parser.contentsAsDouble(), 0.0); [EOL] } [EOL] public void testContentsAsDoubleWithInvalidDouble() { [EOL] JsonParser parser = createParserWithContent("not a number"); [EOL] try { [EOL] parser.contentsAsDouble(); [EOL] fail("Expected NumberFormatException to be thrown"); [EOL] } catch (NumberFormatException e) { [EOL] } [EOL] } [EOL] public void testContentsAsDoubleWithEmptyString() { [EOL] JsonParser parser = createParserWithContent(""); [EOL] try { [EOL] parser.contentsAsDouble(); [EOL] fail("Expected NumberFormatException to be thrown"); [EOL] } catch (NumberFormatException e) { [EOL] } [EOL] }

public void testEmptyAndGetCurrentSegment_WithoutSegments() { [EOL] YourClass instance = createInstance(false); [EOL] char[] result = instance.emptyAndGetCurrentSegment(); [EOL] assertNotNull(result); [EOL] assertEquals(0, instance.getCurrentSize()); [EOL] assertEquals(-1, instance.getInputStart()); [EOL] assertEquals(0, instance.getInputLen()); [EOL] assertNull(instance.getInputBuffer()); [EOL] assertNull(instance.getResultString()); [EOL] assertNull(instance.getResultArray()); [EOL] }
public void testEmptyAndGetCurrentSegment_WithSegments() { [EOL] YourClass instance = createInstance(true); [EOL] char[] result = instance.emptyAndGetCurrentSegment(); [EOL] assertNotNull(result); [EOL] assertEquals(0, instance.getCurrentSize()); [EOL] assertEquals(-1, instance.getInputStart()); [EOL] assertEquals(0, instance.getInputLen()); [EOL] assertNull(instance.getInputBuffer()); [EOL] assertNull(instance.getResultString()); [EOL] assertNull(instance.getResultArray()); [EOL] }
public void testSetCurrentLength_Positive() { [EOL] JsonGeneratorImpl generator = new JsonGeneratorImpl(); [EOL] generator.setCurrentLength(10); [EOL] assertEquals(10, generator.getCurrentSize()); [EOL] }
public void testSetCurrentLength_Zero() { [EOL] JsonGeneratorImpl generator = new JsonGeneratorImpl(); [EOL] generator.setCurrentLength(0); [EOL] assertEquals(0, generator.getCurrentSize()); [EOL] }
public void testSetCurrentLength_Negative() { [EOL] JsonGeneratorImpl generator = new JsonGeneratorImpl(); [EOL] try { [EOL] generator.setCurrentLength(-1); [EOL] fail("Should have thrown an exception for negative length"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public char[] finishCurrentSegment() { [EOL] if (_segments == null) { [EOL] _segments = new ArrayList<char[]>(); [EOL] } [EOL] _hasSegments = true; [EOL] _segments.add(_currentSegment); [EOL] int oldLen = _currentSegment.length; [EOL] _segmentSize += oldLen; [EOL] int newLen = Math.min(oldLen + (oldLen >> 1), MAX_SEGMENT_LEN); [EOL] char[] curr = _charArray(newLen); [EOL] _currentSize = 0; [EOL] _currentSegment = curr; [EOL] return curr; [EOL] }
public void testBuildResultArray_ResultStringNotNull() { [EOL] TextBuffer testInstance = new TextBuffer(); [EOL] testInstance._resultString = "test"; [EOL] char[] result = testInstance.buildResultArray(); [EOL] assertArrayEquals("test".toCharArray(), result); [EOL] }
public void testBuildResultArray_InputStartNotNegativeAndInputLenZero() { [EOL] TextBuffer testInstance = new TextBuffer(); [EOL] testInstance._inputStart = 0; [EOL] testInstance._inputLen = 0; [EOL] char[] result = testInstance.buildResultArray(); [EOL] assertArrayEquals(TextBuffer.NO_CHARS, result); [EOL] }
public void testBuildResultArray_InputStartZero() { [EOL] TextBuffer testInstance = new TextBuffer(); [EOL] testInstance._inputStart = 0; [EOL] testInstance._inputLen = 3; [EOL] testInstance._inputBuffer = new char[]{'a', 'b', 'c'}; [EOL] char[] result = testInstance.buildResultArray(); [EOL] assertArrayEquals(new char[]{'a', 'b', 'c'}, result); [EOL] }
public void testBuildResultArray_InputStartPositive() { [EOL] TextBuffer testInstance = new TextBuffer(); [EOL] testInstance._inputStart = 1; [EOL] testInstance._inputLen = 2; [EOL] testInstance._inputBuffer = new char[]{'a', 'b', 'c'}; [EOL] char[] result = testInstance.buildResultArray(); [EOL] assertArrayEquals(new char[]{'b', 'c'}, result); [EOL] }
public void testBuildResultArray_SizeZero() { [EOL] TextBuffer testInstance = new TextBuffer(); [EOL] testInstance._inputStart = -1; [EOL] testInstance._resultString = null; [EOL] char[] result = testInstance.buildResultArray(); [EOL] assertArrayEquals(TextBuffer.NO_CHARS, result); [EOL] }
public void testBuildResultArray_SegmentsNotNull() { [EOL] TextBuffer testInstance = new TextBuffer(); [EOL] testInstance._inputStart = -1; [EOL] testInstance._resultString = null; [EOL] testInstance._segments = new ArrayList<>(); [EOL] testInstance._segments.add(new char[]{'a', 'b'}); [EOL] testInstance._segments.add(new char[]{'c', 'd'}); [EOL] testInstance._currentSegment = new char[]{'e', 'f'}; [EOL] testInstance._currentSize = 2; [EOL] char[] result = testInstance.buildResultArray(); [EOL] assertArrayEquals(new char[]{'a', 'b', 'c', 'd', 'e', 'f'}, result); [EOL] }
public void testWriteRawValueWithNullText() throws IOException { [EOL] JsonGenerator gen = createGenerator(); [EOL] try { [EOL] gen.writeRawValue((String) null); [EOL] } catch (Exception e) { [EOL] fail("Should not throw exception for null text."); [EOL] } [EOL] }
public void testWriteRawValueWithEmptyText() throws IOException { [EOL] JsonGenerator gen = createGenerator(); [EOL] gen.writeRawValue(""); [EOL] assertEquals("", gen.getOutputTarget()); [EOL] }
public void testWriteRawValueWithValidText() throws IOException { [EOL] JsonGenerator gen = createGenerator(); [EOL] String text = "some raw value"; [EOL] gen.writeRawValue(text); [EOL] assertEquals(text, gen.getOutputTarget()); [EOL] }
public void testJsonReadContextConstructor() { [EOL] JsonReadContext parentContext = new JsonReadContext(null, JsonReadContext.TYPE_ROOT, 1, 0); [EOL] int type = JsonReadContext.TYPE_OBJECT; [EOL] int lineNr = 10; [EOL] int colNr = 5; [EOL] JsonReadContext context = new JsonReadContext(parentContext, type, lineNr, colNr); [EOL] assertNotNull(context); [EOL] assertEquals(type, context.getType()); [EOL] assertEquals(parentContext, context.getParent()); [EOL] assertEquals(lineNr, context.getLineNr()); [EOL] assertEquals(colNr, context.getColumnNr()); [EOL] assertEquals(-1, context.getCurrentIndex()); [EOL] }
public void testCreateRootContext() { [EOL] JsonReadContext result = JsonReadContext.createRootContext(); [EOL] assertNotNull(result); [EOL] assertNull(result.getParent()); [EOL] assertEquals(JsonReadContext.TYPE_ROOT, result.getType()); [EOL] assertEquals(1, result.getStartLocationLineNr()); [EOL] assertEquals(0, result.getStartLocationColumnNr()); [EOL] }
public void testCreateChildObjectContext_NewContext() { [EOL] JsonReadContext parentContext = new JsonReadContext(null, JsonReadContext.TYPE_ROOT, 1, 1); [EOL] JsonReadContext childContext = parentContext.createChildObjectContext(2, 5); [EOL] assertNotNull(childContext); [EOL] assertEquals(JsonReadContext.TYPE_OBJECT, childContext.getType()); [EOL] assertEquals(2, childContext.getLineNr()); [EOL] assertEquals(5, childContext.getColNr()); [EOL] }
public void testCreateChildObjectContext_ExistingContext() { [EOL] JsonReadContext parentContext = new JsonReadContext(null, JsonReadContext.TYPE_ROOT, 1, 1); [EOL] JsonReadContext firstChildContext = parentContext.createChildObjectContext(2, 5); [EOL] JsonReadContext secondChildContext = parentContext.createChildObjectContext(3, 10); [EOL] assertSame(firstChildContext, secondChildContext); [EOL] assertEquals(JsonReadContext.TYPE_OBJECT, secondChildContext.getType()); [EOL] assertEquals(3, secondChildContext.getLineNr()); [EOL] assertEquals(10, secondChildContext.getColNr()); [EOL] }
public void testGetCurrentNameWhenCurrentNameIsNull() { [EOL] JsonParser jp = createParserWithNullCurrentName(); [EOL] String currentName = jp.getCurrentName(); [EOL] assertNull(currentName); [EOL] } [EOL] public void testGetCurrentNameWhenCurrentNameIsNotNull() { [EOL] JsonParser jp = createParserWithNonNullCurrentName("testName"); [EOL] String currentName = jp.getCurrentName(); [EOL] assertEquals("testName", currentName); [EOL] }
public void testGetParent() { [EOL] JsonReadContext childContext = new JsonReadContext(null, null, 0); [EOL] JsonReadContext parentContext = new JsonReadContext(null, null, 1); [EOL] childContext._parent = parentContext; // Assuming _parent can be accessed or set directly, otherwise use a constructor or a setter method if available. [EOL] JsonReadContext result = childContext.getParent(); [EOL] assertSame("The parent context should be the same as the one set.", parentContext, result); [EOL] }
public void testExpectComma_TypeRootAndIndexZero() { [EOL] JsonReadContext context = new JsonReadContext(null, TYPE_ROOT, 0); [EOL] boolean result = context.expectComma(); [EOL] assertFalse(result); [EOL] }
public void testExpectComma_TypeRootAndIndexNonZero() { [EOL] JsonReadContext context = new JsonReadContext(null, TYPE_ROOT, 1); [EOL] boolean result = context.expectComma(); [EOL] assertFalse(result); [EOL] }
public void testExpectComma_NonTypeRootAndIndexZero() { [EOL] JsonReadContext context = new JsonReadContext(null, TYPE_OBJECT, 0); [EOL] boolean result = context.expectComma(); [EOL] assertFalse(result); [EOL] }
public void testExpectComma_NonTypeRootAndIndexNonZero() { [EOL] JsonReadContext context = new JsonReadContext(null, TYPE_OBJECT, 1); [EOL] boolean result = context.expectComma(); [EOL] assertTrue(result); [EOL] }
public void testSetCurrentName() { [EOL] JsonParser jp = createJsonParser(); [EOL] String expectedName = "testName"; [EOL] jp.setCurrentName(expectedName); [EOL] assertEquals(expectedName, jp.getCurrentName()); [EOL] }
@Override [EOL] public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException { [EOL] int status = _writeContext.writeFieldName(name.getValue()); [EOL] if (status == JsonWriteContext.STATUS_EXPECT_VALUE) { [EOL] _reportError("Can not write a field name, expecting a value"); [EOL] } [EOL] if (_cfgPrettyPrinter != null) { [EOL] _writePPFieldName(name, (status == JsonWriteContext.STATUS_OK_AFTER_COMMA)); [EOL] return; [EOL] } [EOL] if (status == JsonWriteContext.STATUS_OK_AFTER_COMMA) { [EOL] if (_outputTail >= _outputEnd) { [EOL] _flushBuffer(); [EOL] } [EOL] _outputBuffer[_outputTail++] = BYTE_COMMA; [EOL] } [EOL] _writeFieldName(name); [EOL] } [EOL] public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); [EOL] public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); [EOL] public Object getOutputTarget(); [EOL] public final void writeFieldName(String name) throws IOException, JsonGenerationException; [EOL] public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; [EOL] public final void writeStartArray() throws IOException, JsonGenerationException; [EOL] public final void writeEndArray() throws IOException, JsonGenerationException; [EOL] public final void writeStartObject() throws IOException, JsonGenerationException; [EOL] public final void writeEndObject() throws IOException, JsonGenerationException; [EOL] protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; [EOL] protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; [EOL] protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; [EOL] protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; [EOL] public void writeString(String text) throws IOException, JsonGenerationException; [EOL] private void _writeLongString(String text) throws IOException, JsonGenerationException; [EOL] private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; [EOL] public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; [EOL] public final void writeString(SerializableString text) throws IOException, JsonGenerationException; [EOL] public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; [EOL] public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; [EOL] public void writeRaw(String text) throws IOException, JsonGenerationException; [EOL] public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; [EOL] public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; [EOL] public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; [EOL] public void writeRaw(char ch) throws IOException, JsonGenerationException; [EOL] private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; [EOL] public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; [EOL] public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; [EOL] public void writeNumber(short s) throws IOException, JsonGenerationException; [EOL] private void _writeQuotedShort(short s) throws IOException; [EOL] public void writeNumber(int i) throws IOException, JsonGenerationException; [EOL] private void _writeQuotedInt(int i) throws IOException; [EOL] public void writeNumber(long l) throws IOException, JsonGenerationException; [EOL] private void _writeQuotedLong(long l) throws IOException; [EOL] public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; [EOL] public void writeNumber(double d) throws IOException, JsonGenerationException; [EOL] public void writeNumber(float f) throws IOException, JsonGenerationException; [EOL] public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; [EOL] public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; [EOL] private void _writeQuotedRaw(Object value) throws IOException; [EOL] public void writeBoolean(boolean state) throws IOException, JsonGenerationException; [EOL] public void writeNull() throws IOException, JsonGenerationException; [EOL] protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; [EOL] protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; [EOL] public final void flush() throws IOException; [EOL] public void close() throws IOException; [EOL] protected void _releaseBuffers(); [EOL] private final void _writeBytes(byte[] bytes) throws IOException; [EOL] private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; [EOL] private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; [EOL] private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; [EOL] private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; [EOL] private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; [EOL] private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; [EOL] private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; [EOL] private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; [EOL] private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; [EOL] private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; [EOL] private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; [EOL] private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; [EOL] protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; [EOL] protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; [EOL] protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; [EOL] private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; [EOL] private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; [EOL] protected final void _outputSurrogates(int surr1, int surr2) throws IOException; [EOL] private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; [EOL] protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; [EOL] private void _writeNull() throws IOException; [EOL] private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; [EOL] protected final void _flushBuffer() throws IOException; [EOL] byte BYTE_u=Optional[(byte) 'u']; [EOL] byte BYTE_0=Optional[(byte) '0']; [EOL] byte BYTE_LBRACKET=Optional[(byte) '[']; [EOL] byte BYTE_RBRACKET=Optional[(byte) ']']; [EOL] byte BYTE_LCURLY=Optional[(byte) '{']; [EOL] byte BYTE_RCURLY=Optional[(byte) '}']; [EOL] byte BYTE_BACKSLASH=Optional[(byte) '\\']; [EOL] byte BYTE_COMMA=Optional[(byte) ',']; [EOL] byte BYTE_COLON=Optional[(byte) ':']; [EOL] byte BYTE_QUOTE=Optional[(byte) '"']; [EOL] int SURR1_FIRST=Optional[0xD800]; [EOL] int SURR1_LAST=Optional[0xDBFF]; [EOL] int SURR2_FIRST=Optional[0xDC00]; [EOL] int SURR2_LAST=Optional[0xDFFF]; [EOL] int MAX_BYTES_TO_BUFFER=Optional[512]; [EOL] byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; [EOL] byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; [EOL] byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; [EOL] byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }];
protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException { [EOL] if (!isEnabled(Feature.QUOTE_FIELD_NAMES)) { [EOL] int len = name.appendQuotedUTF8(_outputBuffer, _outputTail); [EOL] if (len < 0) { [EOL] _writeBytes(name.asQuotedUTF8()); [EOL] } else { [EOL] _outputTail += len; [EOL] } [EOL] return; [EOL] } [EOL] if (_outputTail >= _outputEnd) { [EOL] _flushBuffer(); [EOL] } [EOL] _outputBuffer[_outputTail++] = BYTE_QUOTE; [EOL] int len = name.appendQuotedUTF8(_outputBuffer, _outputTail); [EOL] if (len < 0) { [EOL] _writeBytes(name.asQuotedUTF8()); [EOL] } else { [EOL] _outputTail += len; [EOL] } [EOL] if (_outputTail >= _outputEnd) { [EOL] _flushBuffer(); [EOL] } [EOL] _outputBuffer[_outputTail++] = BYTE_QUOTE; [EOL] } [EOL] public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); [EOL] public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); [EOL] public Object getOutputTarget(); [EOL] public final void writeFieldName(String name) throws IOException, JsonGenerationException; [EOL] public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; [EOL] public final void writeStartArray() throws IOException, JsonGenerationException; [EOL] public final void writeEndArray() throws IOException, JsonGenerationException; [EOL] public final void writeStartObject() throws IOException, JsonGenerationException; [EOL] public final void writeEndObject() throws IOException, JsonGenerationException; [EOL] protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; [EOL] protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; [EOL] protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; [EOL] protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; [EOL] public void writeString(String text) throws IOException, JsonGenerationException; [EOL] private void _writeLongString(String text) throws IOException, JsonGenerationException; [EOL] private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; [EOL] public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; [EOL] public final void writeString(SerializableString text) throws IOException, JsonGenerationException; [EOL] public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; [EOL] public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; [EOL] public void writeRaw(String text) throws IOException, JsonGenerationException; [EOL] public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; [EOL] public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; [EOL] public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; [EOL] public void writeRaw(char ch) throws IOException, JsonGenerationException; [EOL] private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; [EOL] public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; [EOL] public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; [EOL] public void writeNumber(short s) throws IOException, JsonGenerationException; [EOL] private void _writeQuotedShort(short s) throws IOException; [EOL] public void writeNumber(int i) throws IOException, JsonGenerationException; [EOL] private void _writeQuotedInt(int i) throws IOException; [EOL] public void writeNumber(long l) throws IOException, JsonGenerationException; [EOL] private void _writeQuotedLong(long l) throws IOException; [EOL] public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; [EOL] public void writeNumber(double d) throws IOException, JsonGenerationException; [EOL] public void writeNumber(float f) throws IOException, JsonGenerationException; [EOL] public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; [EOL] public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; [EOL] private void _writeQuotedRaw(Object value) throws IOException; [EOL] public void writeBoolean(boolean state) throws IOException, JsonGenerationException; [EOL] public void writeNull() throws IOException, JsonGenerationException; [EOL] protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; [EOL] protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; [EOL] public final void flush() throws IOException; [EOL] public void close() throws IOException; [EOL] protected void _releaseBuffers(); [EOL] private final void _writeBytes(byte[] bytes) throws IOException; [EOL] private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; [EOL] private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; [EOL] private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; [EOL] private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; [EOL] private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; [EOL] private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; [EOL] private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; [EOL] private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; [EOL] private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; [EOL] private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; [EOL] private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; [EOL] private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; [EOL] protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; [EOL] protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; [EOL] protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; [EOL] private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; [EOL] private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; [EOL] protected final void _outputSurrogates(int surr1, int surr2) throws IOException; [EOL] private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; [EOL] protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; [EOL] private void _writeNull() throws IOException; [EOL] private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; [EOL] protected final void _flushBuffer() throws IOException; [EOL] byte BYTE_u=Optional[(byte) 'u']; [EOL] byte BYTE_0=Optional[(byte) '0']; [EOL] byte BYTE_LBRACKET=Optional[(byte) '[']; [EOL] byte BYTE_RBRACKET=Optional[(byte) ']']; [EOL] byte BYTE_LCURLY=Optional[(byte) '{']; [EOL] byte BYTE_RCURLY=Optional[(byte) '}']; [EOL] byte BYTE_BACKSLASH=Optional[(byte) '\\']; [EOL] byte BYTE_COMMA=Optional[(byte) ',']; [EOL] byte BYTE_COLON=Optional[(byte) ':']; [EOL] byte BYTE_QUOTE=Optional[(byte) '"']; [EOL] int SURR1_FIRST=Optional[0xD800]; [EOL] int SURR1_LAST=Optional[0xDBFF]; [EOL] int SURR2_FIRST=Optional[0xDC00]; [EOL] int SURR2_LAST=Optional[0xDFFF]; [EOL] int MAX_BYTES_TO_BUFFER=Optional[512]; [EOL] byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; [EOL] byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; [EOL] byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; [EOL] byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }];
public void testWriteStringWithNullText() throws IOException { [EOL] UTF8JsonGenerator generator = createGenerator(); [EOL] generator.writeString(null); [EOL] }
public void testWriteStringWithEmptyText() throws IOException { [EOL] UTF8JsonGenerator generator = createGenerator(); [EOL] generator.writeString(""); [EOL] }
public void testWriteStringWithLongText() throws IOException { [EOL] UTF8JsonGenerator generator = createGenerator(); [EOL] String longText = createLongText(); [EOL] generator.writeString(longText); [EOL] }
public void testWriteStringWithTextExceedingMaxContiguous() throws IOException { [EOL] UTF8JsonGenerator generator = createGenerator(); [EOL] String text = createTextExceedingMaxContiguous(); [EOL] generator.writeString(text); [EOL] }
public void testWriteStringWithTextNotExceedingMaxContiguous() throws IOException { [EOL] UTF8JsonGenerator generator = createGenerator(); [EOL] String text = "short text"; [EOL] generator.writeString(text); [EOL] }
public void testWriteStringWithOutputBufferAlmostFull() throws IOException { [EOL] UTF8JsonGenerator generator = createGeneratorWithAlmostFullBuffer(); [EOL] String text = "text"; [EOL] generator.writeString(text); [EOL] } [EOL] private UTF8JsonGenerator createGenerator() { [EOL] } [EOL] private String createLongText() { [EOL] } [EOL] private String createTextExceedingMaxContiguous() { [EOL] } [EOL] private UTF8JsonGenerator createGeneratorWithAlmostFullBuffer() { [EOL] }
public void testWriteStringSegmentWithNoEscaping() throws IOException, JsonGenerationException { [EOL] char[] cbuf = "normalString".toCharArray(); [EOL] int offset = 0; [EOL] int len = cbuf.length; [EOL] _writeStringSegment(cbuf, offset, len); [EOL] } [EOL] public void testWriteStringSegmentWithEscaping() throws IOException, JsonGenerationException { [EOL] char[] cbuf = "stringWithEscapingChar\u00A9".toCharArray(); [EOL] int offset = 0; [EOL] int len = cbuf.length; [EOL] _writeStringSegment(cbuf, offset, len); [EOL] } [EOL] public void testWriteStringSegmentWithHighValueChar() throws IOException, JsonGenerationException { [EOL] char[] cbuf = "stringWithHighValueChar\u20AC".toCharArray(); [EOL] int offset = 0; [EOL] int len = cbuf.length; [EOL] _writeStringSegment(cbuf, offset, len); [EOL] } [EOL] public void testWriteStringSegmentWithCustomEscapes() throws IOException, JsonGenerationException { [EOL] char[] cbuf = "stringWithCustomEscape\u00A9".toCharArray(); [EOL] int offset = 0; [EOL] int len = cbuf.length; [EOL] _characterEscapes = new CustomCharacterEscapes(); // Assuming CustomCharacterEscapes is a valid implementation [EOL] _writeStringSegment(cbuf, offset, len); [EOL] } [EOL] public void testWriteStringSegmentWithMaximumNonEscapedChar() throws IOException, JsonGenerationException { [EOL] char[] cbuf = "stringWithNonEscapedChar\u007F".toCharArray(); [EOL] int offset = 0; [EOL] int len = cbuf.length; [EOL] _maximumNonEscapedChar = 0x7F; [EOL] _writeStringSegment(cbuf, offset, len); [EOL] } [EOL] public void testWriteStringSegmentWithOffsetAndLength() throws IOException, JsonGenerationException { [EOL] char[] cbuf = "stringWithOffsetAndLength".toCharArray(); [EOL] int offset = 7; [EOL] int len = 5; // "WithO" [EOL] _writeStringSegment(cbuf, offset, len); [EOL] }
public void testWriteCustomStringSegment2WithFlush() throws IOException { [EOL] char[] cbuf = new char[]{'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'}; [EOL] int offset = 0; [EOL] int end = cbuf.length; [EOL] UTF8JsonGenerator generator = createGeneratorWithCustomEscapes(); [EOL] generator._writeCustomStringSegment2(cbuf, offset, end); [EOL] assertEquals("Buffer should have been flushed", 0, generator._outputTail); [EOL] }
public void testWriteCustomStringSegment2WithoutFlush() throws IOException { [EOL] char[] cbuf = new char[]{'a', 'b', 'c'}; [EOL] int offset = 0; [EOL] int end = cbuf.length; [EOL] UTF8JsonGenerator generator = createGeneratorWithCustomEscapes(); [EOL] generator._writeCustomStringSegment2(cbuf, offset, end); [EOL] assertTrue("Buffer should not have been flushed", generator._outputTail > 0); [EOL] }
public void testWriteCustomStringSegment2WithEscaping() throws IOException { [EOL] char[] cbuf = new char[]{'a', '\\', 'n', 'b', '\\', 't', 'c', '\\', 'u', 'd'}; [EOL] int offset = 0; [EOL] int end = cbuf.length; [EOL] UTF8JsonGenerator generator = createGeneratorWithCustomEscapes(); [EOL] generator._writeCustomStringSegment2(cbuf, offset, end); [EOL] }
public void testWriteCustomStringSegment2WithCustomEscapes() throws IOException { [EOL] char[] cbuf = new char[]{'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'}; [EOL] int offset = 0; [EOL] int end = cbuf.length; [EOL] UTF8JsonGenerator generator = createGeneratorWithCustomEscapes(); [EOL] generator._characterEscapes = new CharacterEscapes() { [EOL] @Override [EOL] public int[] getEscapeCodesForAscii() { [EOL] } [EOL] @Override [EOL] public SerializableString getEscapeSequence(int ch) { [EOL] } [EOL] }; [EOL] generator._writeCustomStringSegment2(cbuf, offset, end); [EOL] }
private UTF8JsonGenerator createGeneratorWithCustomEscapes() throws IOException { [EOL] }
public void testWriteCustomEscapeShortLength() throws IOException, JsonGenerationException { [EOL] byte[] outputBuffer = new byte[20]; [EOL] int outputPtr = 0; [EOL] SerializableString esc = new SerializableString() { [EOL] @Override [EOL] public String getValue() { [EOL] return "short"; [EOL] } [EOL] @Override [EOL] public int charLength() { [EOL] return getValue().length(); [EOL] } [EOL] @Override [EOL] public char[] asQuotedChars() { [EOL] return getValue().toCharArray(); [EOL] } [EOL] @Override [EOL] public byte[] asUnquotedUTF8() { [EOL] return getValue().getBytes(StandardCharsets.UTF_8); [EOL] } [EOL] @Override [EOL] public byte[] asQuotedUTF8() { [EOL] return getValue().getBytes(StandardCharsets.UTF_8); [EOL] } [EOL] }; [EOL] int remainingChars = 5; [EOL] UTF8JsonGenerator generator = new UTF8JsonGenerator(null, 0, null, null); [EOL] int newOutputPtr = generator._writeCustomEscape(outputBuffer, outputPtr, esc, remainingChars); [EOL] assertEquals(outputPtr + esc.asUnquotedUTF8().length, newOutputPtr); [EOL] }
public void testWriteCustomEscapeLongLength() throws IOException, JsonGenerationException { [EOL] byte[] outputBuffer = new byte[20]; [EOL] int outputPtr = 0; [EOL] SerializableString esc = new SerializableString() { [EOL] @Override [EOL] public String getValue() { [EOL] return "veryLongEscapeSequence"; [EOL] } [EOL] @Override [EOL] public int charLength() { [EOL] return getValue().length(); [EOL] } [EOL] @Override [EOL] public char[] asQuotedChars() { [EOL] return getValue().toCharArray(); [EOL] } [EOL] @Override [EOL] public byte[] asUnquotedUTF8() { [EOL] return getValue().getBytes(StandardCharsets.UTF_8); [EOL] } [EOL] @Override [EOL] public byte[] asQuotedUTF8() { [EOL] return getValue().getBytes(StandardCharsets.UTF_8); [EOL] } [EOL] }; [EOL] int remainingChars = 5; [EOL] UTF8JsonGenerator generator = new UTF8JsonGenerator(null, 0, null, null); [EOL] int newOutputPtr = generator._writeCustomEscape(outputBuffer, outputPtr, esc, remainingChars); [EOL] assertEquals(outputPtr + remainingChars, newOutputPtr); [EOL] }
private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException { [EOL] final byte[] bbuf = _outputBuffer; [EOL] bbuf[outputPtr++] = BYTE_BACKSLASH; [EOL] bbuf[outputPtr++] = BYTE_u; [EOL] if (charToEscape > 0xFF) { [EOL] int hi = (charToEscape >> 8) & 0xFF; [EOL] bbuf[outputPtr++] = HEX_CHARS[hi >> 4]; [EOL] bbuf[outputPtr++] = HEX_CHARS[hi & 0xF]; [EOL] charToEscape &= 0xFF; [EOL] } else { [EOL] bbuf[outputPtr++] = BYTE_0; [EOL] bbuf[outputPtr++] = BYTE_0; [EOL] } [EOL] bbuf[outputPtr++] = HEX_CHARS[charToEscape >> 4]; [EOL] bbuf[outputPtr++] = HEX_CHARS[charToEscape & 0xF]; [EOL] return outputPtr; [EOL] }
Since the provided method `JsonStreamContext()` is an empty protected constructor, there is no executable code within it to cover with unit tests. Therefore, no unit test cases can be generated for this specific method as it does not contain any logic or lines of code that can be executed or tested. It simply initializes an instance of the class it belongs to. [EOL] If you have another method with executable code, please provide it, and I can help generate meaningful unit test cases for that method.
public void testInArrayTrue() { [EOL] JsonParser jp = createParserWithType(TYPE_ARRAY); [EOL] assertTrue(jp.inArray()); [EOL] }
public void testInArrayFalse() { [EOL] JsonParser jp = createParserWithType(TYPE_OBJECT); // Assuming TYPE_OBJECT is a different type constant [EOL] assertFalse(jp.inArray()); [EOL] }
public void testInObjectWhenTypeIsObject() { [EOL] JsonParser jp = createParserWithType(TYPE_OBJECT); [EOL] assertTrue(jp.inObject()); [EOL] } [EOL] public void testInObjectWhenTypeIsNotObject() { [EOL] JsonParser jp = createParserWithType(TYPE_ARRAY); // Assuming TYPE_ARRAY is a different type constant [EOL] assertFalse(jp.inObject()); [EOL] }
public void testGetTypeDescForTypeRoot() { [EOL] JsonToken token = JsonToken.START_OBJECT; // Assuming JsonToken is the class and TYPE_ROOT is a constant [EOL] token._type = JsonToken.TYPE_ROOT; // Assuming _type is the field that stores the type [EOL] String typeDesc = token.getTypeDesc(); [EOL] assertEquals("ROOT", typeDesc); [EOL] }
public void testGetTypeDescForTypeArray() { [EOL] JsonToken token = JsonToken.START_ARRAY; // Assuming JsonToken is the class and TYPE_ARRAY is a constant [EOL] token._type = JsonToken.TYPE_ARRAY; // Assuming _type is the field that stores the type [EOL] String typeDesc = token.getTypeDesc(); [EOL] assertEquals("ARRAY", typeDesc); [EOL] }
public void testGetTypeDescForTypeObject() { [EOL] JsonToken token = JsonToken.START_OBJECT; // Assuming JsonToken is the class and TYPE_OBJECT is a constant [EOL] token._type = JsonToken.TYPE_OBJECT; // Assuming _type is the field that stores the type [EOL] String typeDesc = token.getTypeDesc(); [EOL] assertEquals("OBJECT", typeDesc); [EOL] }
public void testGetTypeDescForUnknownType() { [EOL] JsonToken token = JsonToken.NOT_AVAILABLE; // Assuming JsonToken is the class and NOT_AVAILABLE is a constant for an undefined type [EOL] token._type = -1; // Assuming -1 is not a defined type [EOL] String typeDesc = token.getTypeDesc(); [EOL] assertEquals("?", typeDesc); [EOL] }
public void testByteSourceJsonBootstrapperWithValidInput() { [EOL] IOContext ctxt = new IOContext(new BufferRecycler(), new Object(), false); [EOL] byte[] inputBuffer = new byte[] { 0x1, 0x2, 0x3, 0x4 }; [EOL] int inputStart = 1; [EOL] int inputLen = 3; [EOL] ByteSourceJsonBootstrapper bootstrapper = new ByteSourceJsonBootstrapper(ctxt, inputBuffer, inputStart, inputLen); [EOL] assertNotNull(bootstrapper); [EOL] assertEquals(inputStart, bootstrapper._inputPtr); [EOL] assertEquals(inputStart + inputLen, bootstrapper._inputEnd); [EOL] assertEquals(-inputStart, bootstrapper._inputProcessed); [EOL] assertFalse(bootstrapper._bufferRecyclable); [EOL] }
public void testDetectEncodingWithNoBOMAndNotEnoughData() throws IOException, JsonParseException { [EOL] _inputBuffer = new byte[] {0, 0, 0}; // Less than 4 bytes [EOL] _inputPtr = 0; [EOL] JsonEncoding encoding = detectEncoding(); [EOL] assertEquals(JsonEncoding.UTF8, encoding); [EOL] }
public void testDetectEncodingWithUTF32BEBOM() throws IOException, JsonParseException { [EOL] _inputBuffer = new byte[] {(byte)0x00, (byte)0x00, (byte)0xFE, (byte)0xFF}; [EOL] _inputPtr = 0; [EOL] JsonEncoding encoding = detectEncoding(); [EOL] assertEquals(JsonEncoding.UTF32_BE, encoding); [EOL] }
public void testDetectEncodingWithUTF32LEBOM() throws IOException, JsonParseException { [EOL] _inputBuffer = new byte[] {(byte)0xFF, (byte)0xFE, (byte)0x00, (byte)0x00}; [EOL] _inputPtr = 0; [EOL] JsonEncoding encoding = detectEncoding(); [EOL] assertEquals(JsonEncoding.UTF32_LE, encoding); [EOL] }
public void testDetectEncodingWithUTF16BEBOM() throws IOException, JsonParseException { [EOL] _inputBuffer = new byte[] {(byte)0xFE, (byte)0xFF, 0, 0}; // Only need 2 bytes for UTF-16 BOM [EOL] _inputPtr = 0; [EOL] JsonEncoding encoding = detectEncoding(); [EOL] assertEquals(JsonEncoding.UTF16_BE, encoding); [EOL] }
public void testDetectEncodingWithUTF16LEBOM() throws IOException, JsonParseException { [EOL] _inputBuffer = new byte[] {(byte)0xFF, (byte)0xFE, 0, 0}; // Only need 2 bytes for UTF-16 BOM [EOL] _inputPtr = 0; [EOL] JsonEncoding encoding = detectEncoding(); [EOL] assertEquals(JsonEncoding.UTF16_LE, encoding); [EOL] }
public void testDetectEncodingWithUTF8BOM() throws IOException, JsonParseException { [EOL] _inputBuffer = new byte[] {(byte)0xEF, (byte)0xBB, (byte)0xBF, 0}; [EOL] _inputPtr = 0; [EOL] JsonEncoding encoding = detectEncoding(); [EOL] assertEquals(JsonEncoding.UTF8, encoding); [EOL] }
public void testDetectEncodingWithInvalidData() throws IOException, JsonParseException { [EOL] _inputBuffer = new byte[] {(byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF}; // Invalid BOM [EOL] _inputPtr = 0; [EOL] try { [EOL] JsonEncoding encoding = detectEncoding(); [EOL] fail("Should have thrown an exception due to invalid BOM"); [EOL] } catch (RuntimeException e) { [EOL] } [EOL] }
public void testDetectEncodingWithUTF16Data() throws IOException, JsonParseException { [EOL] _inputBuffer = new byte[] {0, (byte)0xFF, 0, (byte)0xFE}; // UTF-16 data without BOM [EOL] _inputPtr = 0; [EOL] JsonEncoding encoding = detectEncoding(); [EOL] assertTrue(encoding == JsonEncoding.UTF16_BE || encoding == JsonEncoding.UTF16_LE); [EOL] }
public void testDetectEncodingWithUTF32Data() throws IOException, JsonParseException { [EOL] _inputBuffer = new byte[] {(byte)0x00, (byte)0x00, (byte)0x00, (byte)0xFF}; // UTF-32 data without BOM [EOL] _inputPtr = 0; [EOL] JsonEncoding encoding = detectEncoding(); [EOL] assertTrue(encoding == JsonEncoding.UTF32_BE || encoding == JsonEncoding.UTF32_LE); [EOL] }
public void testHasJSONFormatWithNoMoreBytesInitially() throws IOException { [EOL] InputAccessor acc = mock(InputAccessor.class); [EOL] when(acc.hasMoreBytes()).thenReturn(false); [EOL] assertEquals(MatchStrength.INCONCLUSIVE, JsonFactory.hasJSONFormat(acc)); [EOL] }
public void testHasJSONFormatWithUTF8BOM() throws IOException { [EOL] InputAccessor acc = mock(InputAccessor.class); [EOL] when(acc.hasMoreBytes()).thenReturn(true).thenReturn(true).thenReturn(true).thenReturn(true); [EOL] when(acc.nextByte()).thenReturn((byte) 0xEF).thenReturn((byte) 0xBB).thenReturn((byte) 0xBF).thenReturn((byte) '{'); [EOL] assertEquals(MatchStrength.SOLID_MATCH, JsonFactory.hasJSONFormat(acc)); [EOL] }
public void testHasJSONFormatWithNoMatchOnBOM() throws IOException { [EOL] InputAccessor acc = mock(InputAccessor.class); [EOL] when(acc.hasMoreBytes()).thenReturn(true).thenReturn(true); [EOL] when(acc.nextByte()).thenReturn((byte) 0xEF).thenReturn((byte) 0xBB); [EOL] assertEquals(MatchStrength.NO_MATCH, JsonFactory.hasJSONFormat(acc)); [EOL] }
public void testHasJSONFormatWithNonJSONChar() throws IOException { [EOL] InputAccessor acc = mock(InputAccessor.class); [EOL] when(acc.hasMoreBytes()).thenReturn(true); [EOL] when(acc.nextByte()).thenReturn((byte) 'a'); [EOL] assertEquals(MatchStrength.NO_MATCH, JsonFactory.hasJSONFormat(acc)); [EOL] }
public void testHasJSONFormatWithJSONStartObject() throws IOException { [EOL] InputAccessor acc = mock(InputAccessor.class); [EOL] when(acc.hasMoreBytes()).thenReturn(true).thenReturn(true); [EOL] when(acc.nextByte()).thenReturn((byte) '{'); [EOL] when(JsonFactory.skipSpace(acc, (byte) '{')).thenReturn((int) '"'); [EOL] assertEquals(MatchStrength.SOLID_MATCH, JsonFactory.hasJSONFormat(acc)); [EOL] }
public void testHasJSONFormatWithJSONStartArray() throws IOException { [EOL] InputAccessor acc = mock(InputAccessor.class); [EOL] when(acc.hasMoreBytes()).thenReturn(true).thenReturn(true); [EOL] when(acc.nextByte()).thenReturn((byte) '['); [EOL] when(JsonFactory.skipSpace(acc, (byte) '[')).thenReturn((int) ']'); [EOL] assertEquals(MatchStrength.SOLID_MATCH, JsonFactory.hasJSONFormat(acc)); [EOL] }
public void testHasJSONFormatWithNegativeNumber() throws IOException { [EOL] InputAccessor acc = mock(InputAccessor.class); [EOL] when(acc.hasMoreBytes()).thenReturn(true).thenReturn(true); [EOL] when(acc.nextByte()).thenReturn((byte) '-'); [EOL] when(JsonFactory.skipSpace(acc)).thenReturn((int) '1'); [EOL] assertEquals(MatchStrength.WEAK_MATCH, JsonFactory.hasJSONFormat(acc)); [EOL] }
public void testHasJSONFormatWithInvalidNegative() throws IOException { [EOL] InputAccessor acc = mock(InputAccessor.class); [EOL] when(acc.hasMoreBytes()).thenReturn(true).thenReturn(true); [EOL] when(acc.nextByte()).thenReturn((byte) '-'); [EOL] when(JsonFactory.skipSpace(acc)).thenReturn((int) 'a'); [EOL] assertEquals(MatchStrength.NO_MATCH, JsonFactory.hasJSONFormat(acc)); [EOL] }
public void testHasJSONFormatWithLiteralTrue() throws IOException { [EOL] InputAccessor acc = mock(InputAccessor.class); [EOL] when(acc.hasMoreBytes()).thenReturn(true).thenReturn(true).thenReturn(true).thenReturn(true); [EOL] when(acc.nextByte()).thenReturn((byte) 't'); [EOL] when(JsonFactory.tryMatch(acc, "rue", MatchStrength.WEAK_MATCH)).thenReturn(MatchStrength.WEAK_MATCH); [EOL] assertEquals(MatchStrength.WEAK_MATCH, JsonFactory.hasJSONFormat(acc)); [EOL] }
public void testHasJSONFormatWithLiteralFalse() throws IOException { [EOL] InputAccessor acc = mock(InputAccessor.class); [EOL] when(acc.hasMoreBytes()).thenReturn(true).thenReturn(true).thenReturn(true).thenReturn(true).thenReturn(true); [EOL] when(acc.nextByte()).thenReturn((byte) 'f'); [EOL] when(JsonFactory.tryMatch(acc, "alse", MatchStrength.WEAK_MATCH)).thenReturn(MatchStrength.WEAK_MATCH); [EOL] assertEquals(MatchStrength.WEAK_MATCH, JsonFactory.hasJSONFormat(acc)); [EOL] }
public void testHasJSONFormatWithLiteralNull() throws IOException { [EOL] InputAccessor acc = mock(InputAccessor.class); [EOL] when(acc.hasMoreBytes()).thenReturn(true).thenReturn(true).thenReturn(true).thenReturn(true); [EOL] when(acc.nextByte()).thenReturn((byte) 'n'); [EOL] when(JsonFactory.tryMatch(acc, "ull", MatchStrength.WEAK_MATCH)).thenReturn(MatchStrength.WEAK_MATCH); [EOL] assertEquals(MatchStrength.WEAK_MATCH, JsonFactory.hasJSONFormat(acc)); [EOL] }
public void testHandleBOMWith0x0000FEFF() throws IOException { [EOL] int quad = 0x0000FEFF; [EOL] boolean result = handleBOM(quad); [EOL] assertTrue(result); [EOL] assertTrue(_bigEndian); [EOL] assertEquals(4, _inputPtr); [EOL] assertEquals(4, _bytesPerChar); [EOL] }
public void testHandleBOMWith0xFFFE0000() throws IOException { [EOL] int quad = 0xFFFE0000; [EOL] boolean result = handleBOM(quad); [EOL] assertTrue(result); [EOL] assertFalse(_bigEndian); [EOL] assertEquals(4, _inputPtr); [EOL] assertEquals(4, _bytesPerChar); [EOL] }
public void testHandleBOMWith0x0000FFFE() throws IOException { [EOL] int quad = 0x0000FFFE; [EOL] try { [EOL] handleBOM(quad); [EOL] fail("Should have thrown IOException due to weird UCS4"); [EOL] } catch (IOException e) { [EOL] } [EOL] }
public void testHandleBOMWith0xFEFF0000() throws IOException { [EOL] int quad = 0xFEFF0000; [EOL] try { [EOL] handleBOM(quad); [EOL] fail("Should have thrown IOException due to weird UCS4"); [EOL] } catch (IOException e) { [EOL] } [EOL] }
public void testHandleBOMWith0xFEFF() throws IOException { [EOL] int quad = 0x0000FEFF; [EOL] boolean result = handleBOM(quad); [EOL] assertTrue(result); [EOL] assertTrue(_bigEndian); [EOL] assertEquals(2, _inputPtr); [EOL] assertEquals(2, _bytesPerChar); [EOL] }
public void testHandleBOMWith0xFFFE() throws IOException { [EOL] int quad = 0x0000FFFE; [EOL] boolean result = handleBOM(quad); [EOL] assertTrue(result); [EOL] assertFalse(_bigEndian); [EOL] assertEquals(2, _inputPtr); [EOL] assertEquals(2, _bytesPerChar); [EOL] }
public void testHandleBOMWith0xEFBBBF() throws IOException { [EOL] int quad = 0x00EFBBBF; [EOL] boolean result = handleBOM(quad); [EOL] assertTrue(result); [EOL] assertTrue(_bigEndian); [EOL] assertEquals(3, _inputPtr); [EOL] assertEquals(1, _bytesPerChar); [EOL] }
public void testHandleBOMWithInvalidQuad() throws IOException { [EOL] int quad = 0x12345678; [EOL] boolean result = handleBOM(quad); [EOL] assertFalse(result); [EOL] }
public void testEnsureLoadedWithNullInput() throws IOException { [EOL] _inputEnd = 0; [EOL] _inputPtr = 0; [EOL] _inputBuffer = new byte[10]; [EOL] _in = null; [EOL] boolean result = ensureLoaded(5); [EOL] assertFalse(result); [EOL] }
public void testEnsureLoadedWithSufficientBuffer() throws IOException { [EOL] _inputEnd = 10; [EOL] _inputPtr = 5; [EOL] _inputBuffer = new byte[10]; [EOL] _in = new ByteArrayInputStream(new byte[]{1, 2, 3, 4, 5}); [EOL] boolean result = ensureLoaded(5); [EOL] assertTrue(result); [EOL] }
public void testEnsureLoadedWithPartialReads() throws IOException { [EOL] _inputEnd = 3; [EOL] _inputPtr = 0; [EOL] _inputBuffer = new byte[10]; [EOL] _in = new ByteArrayInputStream(new byte[]{1, 2, 3, 4, 5}); [EOL] boolean result = ensureLoaded(5); [EOL] assertTrue(result); [EOL] }
public void testEnsureLoadedWithEOF() throws IOException { [EOL] _inputEnd = 3; [EOL] _inputPtr = 0; [EOL] _inputBuffer = new byte[10]; [EOL] _in = new ByteArrayInputStream(new byte[]{1, 2, 3}); [EOL] boolean result = ensureLoaded(5); [EOL] assertFalse(result); [EOL] }
public void testWriteNumberFieldWithValidFieldNameAndValue() throws IOException { [EOL] JsonGenerator gen = createJsonGenerator(); [EOL] gen.writeStartObject(); [EOL] gen.writeNumberField("age", 25L); [EOL] gen.writeEndObject(); [EOL] gen.close(); [EOL] assertOutput("{\"age\":25}"); [EOL] }
public void testWriteNumberFieldWithEmptyFieldName() throws IOException { [EOL] JsonGenerator gen = createJsonGenerator(); [EOL] gen.writeStartObject(); [EOL] gen.writeNumberField("", 25L); [EOL] gen.writeEndObject(); [EOL] gen.close(); [EOL] assertOutput("{\"\":25}"); [EOL] }
public void testWriteNumberFieldWithNullFieldName() throws IOException { [EOL] JsonGenerator gen = createJsonGenerator(); [EOL] gen.writeStartObject(); [EOL] try { [EOL] gen.writeNumberField(null, 25L); [EOL] fail("Expected JsonGenerationException was not thrown."); [EOL] } catch (JsonGenerationException e) { [EOL] } [EOL] gen.writeEndObject(); [EOL] gen.close(); [EOL] }
public void testWriteNumberFieldWithValidInput() throws IOException, JsonGenerationException { [EOL] JsonGenerator gen = createJsonGenerator(); // Assuming createJsonGenerator() is a method that creates a JsonGenerator instance [EOL] gen.writeNumberField("testField", 123.45); [EOL] String output = getOutput(gen); [EOL] assertTrue(output.contains("\"testField\":123.45")); [EOL] }
public void testWriteNumberFieldWithEmptyFieldName() throws IOException, JsonGenerationException { [EOL] JsonGenerator gen = createJsonGenerator(); [EOL] gen.writeNumberField("", 123.45); [EOL] String output = getOutput(gen); [EOL] assertTrue(output.contains("\"\":123.45")); [EOL] }
public void testWriteNumberFieldWithNullFieldName() throws IOException, JsonGenerationException { [EOL] JsonGenerator gen = createJsonGenerator(); [EOL] try { [EOL] gen.writeNumberField(null, 123.45); [EOL] fail("Expected JsonGenerationException was not thrown"); [EOL] } catch (JsonGenerationException e) { [EOL] } [EOL] }
public void testWriteNumberFieldWithValidFieldNameAndFloatValue() throws IOException { [EOL] JsonGenerator gen = createJsonGenerator(); [EOL] gen.writeStartObject(); [EOL] gen.writeNumberField("testField", 1.23f); [EOL] gen.writeEndObject(); [EOL] gen.close(); [EOL] assertOutput("{\"testField\":1.23}"); [EOL] }
public void testWriteNumberFieldWithNullFieldName() throws IOException { [EOL] JsonGenerator gen = createJsonGenerator(); [EOL] gen.writeStartObject(); [EOL] try { [EOL] gen.writeNumberField(null, 1.23f); [EOL] fail("Expected JsonGenerationException"); [EOL] } catch (JsonGenerationException e) { [EOL] } [EOL] gen.writeEndObject(); [EOL] gen.close(); [EOL] }
public void testWriteNumberFieldAfterGeneratorClosed() throws IOException { [EOL] JsonGenerator gen = createJsonGenerator(); [EOL] gen.close(); [EOL] try { [EOL] gen.writeNumberField("testField", 1.23f); [EOL] fail("Expected IOException"); [EOL] } catch (IOException e) { [EOL] } [EOL] }
public void testDecodeBase64Char_ValidInput() { [EOL] int result = decodeBase64Char('A'); [EOL] assertEquals(0, result); [EOL] }
public void testDecodeBase64Char_InvalidInput() { [EOL] int result = decodeBase64Char('€'); [EOL] assertEquals(BASE64_VALUE_INVALID, result); [EOL] }
public void testDecodeBase64Char_ValidAsciiChar() { [EOL] int validAsciiChar = 'A'; // Assuming 'A' is a valid base64 character in the _asciiToBase64 array [EOL] int expectedValue = ...; // Expected value for 'A' from the _asciiToBase64 array [EOL] int actualValue = decodeBase64Char(validAsciiChar); [EOL] assertEquals(expectedValue, actualValue); [EOL] }
public void testDecodeBase64Char_InvalidAsciiChar() { [EOL] int invalidAsciiChar = 128; // Value outside the valid ASCII range [EOL] int actualValue = decodeBase64Char(invalidAsciiChar); [EOL] assertEquals(BASE64_VALUE_INVALID, actualValue); [EOL] }
public void testDecodeBase64Char_BorderlineAsciiChar() { [EOL] int borderlineAsciiChar = 127; // Borderline value for the valid ASCII range [EOL] int expectedValue = ...; // Expected value for the borderline character from the _asciiToBase64 array [EOL] int actualValue = decodeBase64Char(borderlineAsciiChar); [EOL] assertEquals(expectedValue, actualValue); [EOL] }
public void testEncodeBase64BitsAsChar_ValidInput() { [EOL] Base64Variant base64Variant = new Base64Variant("testVariant", "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", true, '=', 0); [EOL] for (int i = 0; i < 64; i++) { [EOL] char expectedChar = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt(i); [EOL] char result = base64Variant.encodeBase64BitsAsChar(i); [EOL] assertEquals(expectedChar, result); [EOL] } [EOL] }
public void testEncodeBase64BitsAsChar_InvalidInput() { [EOL] Base64Variant base64Variant = new Base64Variant("testVariant", "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", true, '=', 0); [EOL] try { [EOL] base64Variant.encodeBase64BitsAsChar(64); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void encodeBase64ChunkTest1() { [EOL] StringBuilder sb = new StringBuilder(); [EOL] int b24 = 0; // This will test the encoding of all zero bits [EOL] encodeBase64Chunk(sb, b24); [EOL] assertEquals("AAAA", sb.toString()); [EOL] }
public void encodeBase64ChunkTest2() { [EOL] StringBuilder sb = new StringBuilder(); [EOL] int b24 = 0xFC0000; // This will test the encoding of the first 6 bits [EOL] encodeBase64Chunk(sb, b24); [EOL] assertEquals("/AAA", sb.toString()); [EOL] }
public void encodeBase64ChunkTest3() { [EOL] StringBuilder sb = new StringBuilder(); [EOL] int b24 = 0x03F000; // This will test the encoding of the second 6 bits [EOL] encodeBase64Chunk(sb, b24); [EOL] assertEquals("A/AA", sb.toString()); [EOL] }
public void encodeBase64ChunkTest4() { [EOL] StringBuilder sb = new StringBuilder(); [EOL] int b24 = 0x000FC0; // This will test the encoding of the third 6 bits [EOL] encodeBase64Chunk(sb, b24); [EOL] assertEquals("AA/A", sb.toString()); [EOL] }
public void encodeBase64ChunkTest5() { [EOL] StringBuilder sb = new StringBuilder(); [EOL] int b24 = 0x00003F; // This will test the encoding of the last 6 bits [EOL] encodeBase64Chunk(sb, b24); [EOL] assertEquals("AAAA", sb.toString()); [EOL] }
public void testEncodeBase64BitsAsByte_ValidInput() { [EOL] Base64Variant base64Variant = new Base64Variant("testVariant", "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", true, '=', 1234); [EOL] for (int i = 0; i < 64; i++) { [EOL] byte result = base64Variant.encodeBase64BitsAsByte(i); [EOL] assertEquals(base64Variant._base64ToAsciiB[i], result); [EOL] } [EOL] }
public void testEncodeBase64BitsAsByte_InvalidInput() { [EOL] Base64Variant base64Variant = new Base64Variant("testVariant", "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", true, '=', 1234); [EOL] try { [EOL] base64Variant.encodeBase64BitsAsByte(64); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testReaderBasedJsonParserInitialization() { [EOL] IOContext ctxt = new IOContext(new BufferRecycler(), new Object(), false); [EOL] int features = 0; [EOL] Reader r = new StringReader("{}"); [EOL] ObjectCodec codec = new ObjectMapper(); [EOL] CharsToNameCanonicalizer st = CharsToNameCanonicalizer.createRoot(); [EOL] ReaderBasedJsonParser parser = new ReaderBasedJsonParser(ctxt, features, r, codec, st); [EOL] assertNotNull(parser); [EOL] assertEquals(codec, parser.getCodec()); [EOL] assertEquals(st, parser.getSt()); [EOL] assertNotNull(parser.getInputBuffer()); [EOL] }
public void testReleaseBufferedWithNoContent() throws IOException { [EOL] Writer w = new StringWriter(); [EOL] int released = instance.releaseBuffered(w); [EOL] assertEquals("Expected no content to be released", 0, released); [EOL] }
public void testReleaseBufferedWithContent() throws IOException { [EOL] Writer w = new StringWriter(); [EOL] instance._inputEnd = 10; [EOL] instance._inputPtr = 5; [EOL] instance._inputBuffer = new char[] {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'}; [EOL] int released = instance.releaseBuffered(w); [EOL] assertEquals("Expected content to be released", 5, released); [EOL] assertEquals("Content released is not correct", "fghij", w.toString()); [EOL] }
public void testLoadMoreWithNonNullReaderAndPositiveCount() throws IOException { [EOL] _currInputProcessed = 0; [EOL] _inputEnd = 10; [EOL] _currInputRowStart = 20; [EOL] _reader = Mockito.mock(Reader.class); [EOL] _inputBuffer = new char[100]; [EOL] Mockito.when(_reader.read(_inputBuffer, 0, _inputBuffer.length)).thenReturn(50); [EOL] boolean result = loadMore(); [EOL] assertEquals(10, _currInputProcessed); [EOL] assertEquals(10, _currInputRowStart); [EOL] assertEquals(0, _inputPtr); [EOL] assertEquals(50, _inputEnd); [EOL] assertTrue(result); [EOL] }
public void testLoadMoreWithNonNullReaderAndZeroCount() { [EOL] _currInputProcessed = 0; [EOL] _inputEnd = 10; [EOL] _currInputRowStart = 20; [EOL] _reader = Mockito.mock(Reader.class); [EOL] _inputBuffer = new char[100]; [EOL] Mockito.when(_reader.read(_inputBuffer, 0, _inputBuffer.length)).thenReturn(0); [EOL] assertThrows(IOException.class, this::loadMore); [EOL] assertEquals(10, _currInputProcessed); [EOL] assertEquals(10, _currInputRowStart); [EOL] }
public void testLoadMoreWithNonNullReaderAndNegativeCount() throws IOException { [EOL] _currInputProcessed = 0; [EOL] _inputEnd = 10; [EOL] _currInputRowStart = 20; [EOL] _reader = Mockito.mock(Reader.class); [EOL] _inputBuffer = new char[100]; [EOL] Mockito.when(_reader.read(_inputBuffer, 0, _inputBuffer.length)).thenReturn(-1); [EOL] boolean result = loadMore(); [EOL] assertEquals(10, _currInputProcessed); [EOL] assertEquals(10, _currInputRowStart); [EOL] assertFalse(result); [EOL] }
public void testLoadMoreWithNullReader() throws IOException { [EOL] _currInputProcessed = 0; [EOL] _inputEnd = 10; [EOL] _currInputRowStart = 20; [EOL] _reader = null; [EOL] _inputBuffer = new char[100]; [EOL] boolean result = loadMore(); [EOL] assertEquals(10, _currInputProcessed); [EOL] assertEquals(10, _currInputRowStart); [EOL] assertFalse(result); [EOL] }
public void test_closeInput_ResourceManaged() throws IOException { [EOL] JsonParser jp = createParserWithManagedResource(); [EOL] jp.close(); [EOL] assertTrue(jp.isClosed()); [EOL] } [EOL] public void test_closeInput_AutoCloseEnabled() throws IOException { [EOL] JsonParser jp = createParserWithAutoCloseEnabled(); [EOL] jp.close(); [EOL] assertTrue(jp.isClosed()); [EOL] } [EOL] public void test_closeInput_NoAutoClose() throws IOException { [EOL] JsonParser jp = createParserWithoutAutoClose(); [EOL] jp.close(); [EOL] assertFalse(jp.isClosed()); [EOL] }
public void test_releaseBuffers_withNonNullInputBuffer() throws IOException { [EOL] MyParser parser = new MyParser(new IOContext(new BufferRecycler(), new File("testFile"), true)); [EOL] parser._inputBuffer = new char[10]; // Assuming _inputBuffer is accessible, otherwise use reflection or a setter [EOL] parser._releaseBuffers(); [EOL] assertNull(parser._inputBuffer); [EOL] }
public void test_releaseBuffers_withNullInputBuffer() throws IOException { [EOL] MyParser parser = new MyParser(new IOContext(new BufferRecycler(), new File("testFile"), true)); [EOL] parser._inputBuffer = null; // Assuming _inputBuffer is accessible, otherwise use reflection or a setter [EOL] parser._releaseBuffers(); [EOL] assertNull(parser._inputBuffer); [EOL] }
public void testGetTextWithValueStringAndTokenIncomplete() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserWithToken(JsonToken.VALUE_STRING); [EOL] setTokenIncomplete(parser, true); [EOL] String result = parser.getText(); [EOL] assertFalse("Token should no longer be incomplete", isTokenIncomplete(parser)); [EOL] assertNotNull("Result should not be null when token is VALUE_STRING", result); [EOL] } [EOL] public void testGetTextWithValueStringAndTokenComplete() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserWithToken(JsonToken.VALUE_STRING); [EOL] setTokenIncomplete(parser, false); [EOL] String result = parser.getText(); [EOL] assertFalse("Token should not be incomplete", isTokenIncomplete(parser)); [EOL] assertNotNull("Result should not be null when token is VALUE_STRING", result); [EOL] } [EOL] public void testGetTextWithNonValueStringToken() throws IOException, JsonParseException { [EOL] for (JsonToken nonValueStringToken : getNonValueStringTokens()) { [EOL] JsonParser parser = createParserWithToken(nonValueStringToken); [EOL] String result = parser.getText(); [EOL] assertEquals("Result should match _getText2() output for non-VALUE_STRING tokens", [EOL] _getText2(nonValueStringToken), result); [EOL] } [EOL] }

public void testNextTokenWithFieldName() throws IOException, JsonParseException { [EOL] _currToken = JsonToken.FIELD_NAME; [EOL] JsonToken result = nextToken(); [EOL] assertNotNull(result); [EOL] }
public void testNextTokenWithIncompleteToken() throws IOException, JsonParseException { [EOL] _tokenIncomplete = true; [EOL] JsonToken result = nextToken(); [EOL] assertNotNull(result); [EOL] }
public void testNextTokenAtEndOfInput() throws IOException, JsonParseException { [EOL] int i = -1; // Simulate end of input [EOL] JsonToken result = nextToken(); [EOL] assertNull(result); [EOL] }
public void testNextTokenWithRBracket() throws IOException, JsonParseException { [EOL] int i = INT_RBRACKET; // Simulate ']' character [EOL] _parsingContext = new JsonReadContext(null, JsonReadContext.TYPE_ARRAY, 1, 1); [EOL] JsonToken result = nextToken(); [EOL] assertEquals(JsonToken.END_ARRAY, result); [EOL] }
public void testNextTokenWithRCurly() throws IOException, JsonParseException { [EOL] int i = INT_RCURLY; // Simulate '}' character [EOL] _parsingContext = new JsonReadContext(null, JsonReadContext.TYPE_OBJECT, 1, 1); [EOL] JsonToken result = nextToken(); [EOL] assertEquals(JsonToken.END_OBJECT, result); [EOL] }
public void testNextTokenExpectComma() throws IOException, JsonParseException { [EOL] _parsingContext = new JsonReadContext(null, JsonReadContext.TYPE_OBJECT, 1, 1); [EOL] _parsingContext.expectComma = true; [EOL] int i = INT_COMMA; // Simulate ',' character [EOL] JsonToken result = nextToken(); [EOL] assertNotNull(result); [EOL] }
public void testNextTokenInObject() throws IOException, JsonParseException { [EOL] _parsingContext = new JsonReadContext(null, JsonReadContext.TYPE_OBJECT, 1, 1); [EOL] int i = _parseFieldName(INT_f); // Simulate field name parsing [EOL] JsonToken result = nextToken(); [EOL] assertEquals(JsonToken.FIELD_NAME, result); [EOL] }
public void testNextTokenWithValueString() throws IOException, JsonParseException { [EOL] int i = INT_QUOTE; // Simulate '"' character [EOL] JsonToken result = nextToken(); [EOL] assertEquals(JsonToken.VALUE_STRING, result); [EOL] assertTrue(_tokenIncomplete); [EOL] }
public void testNextTokenWithStartArray() throws IOException, JsonParseException { [EOL] int i = INT_LBRACKET; // Simulate '[' character [EOL] JsonToken result = nextToken(); [EOL] assertEquals(JsonToken.START_ARRAY, result); [EOL] }
public void testNextTokenWithStartObject() throws IOException, JsonParseException { [EOL] int i = INT_LCURLY; // Simulate '{' character [EOL] JsonToken result = nextToken(); [EOL] assertEquals(JsonToken.START_OBJECT, result); [EOL] }
public void testNextTokenWithUnexpectedChar() throws IOException, JsonParseException { [EOL] int i = INT_RBRACKET; // Simulate ']' character in an unexpected place [EOL] try { [EOL] JsonToken result = nextToken(); [EOL] fail("Expected an exception to be thrown"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testNextTokenWithTrueValue() throws IOException, JsonParseException { [EOL] int i = INT_t; // Simulate 't' character [EOL] JsonToken result = nextToken(); [EOL] assertEquals(JsonToken.VALUE_TRUE, result); [EOL] }
public void testNextTokenWithFalseValue() throws IOException, JsonParseException { [EOL] int i = INT_f; // Simulate 'f' character [EOL] JsonToken result = nextToken(); [EOL] assertEquals(JsonToken.VALUE_FALSE, result); [EOL] }
public void testNextTokenWithNullValue() throws IOException, JsonParseException { [EOL] int i = INT_n; // Simulate 'n' character [EOL] JsonToken result = nextToken(); [EOL] assertEquals(JsonToken.VALUE_NULL, result); [EOL] }
public void testNextTokenWithNumber() throws IOException, JsonParseException { [EOL] int i = INT_0; // Simulate '0' character [EOL] JsonToken result = nextToken(); [EOL] assertEquals(JsonToken.VALUE_NUMBER_INT, result); [EOL] }
public void testNextTokenWithUnexpectedValue() throws IOException, JsonParseException { [EOL] int i = INT_AMPERSAND; // Simulate '&' character or any non-expected character [EOL] JsonToken result = nextToken(); [EOL] assertNotNull(result); [EOL] }
public void testNextAfterNameWithStartArray() { [EOL] _nameCopied = false; [EOL] _nextToken = JsonToken.START_ARRAY; [EOL] _tokenInputRow = 1; [EOL] _tokenInputCol = 1; [EOL] _parsingContext = new ParsingContext(); // Assuming ParsingContext is a class with a createChildArrayContext method [EOL] JsonToken result = _nextAfterName(); [EOL] assertFalse(_nameCopied); [EOL] assertNull(_nextToken); [EOL] assertEquals(JsonToken.START_ARRAY, result); [EOL] assertNotNull(_parsingContext); [EOL] assertTrue(_parsingContext.isArrayContext()); [EOL] }
public void testNextAfterNameWithStartObject() { [EOL] _nameCopied = false; [EOL] _nextToken = JsonToken.START_OBJECT; [EOL] _tokenInputRow = 1; [EOL] _tokenInputCol = 1; [EOL] _parsingContext = new ParsingContext(); // Assuming ParsingContext is a class with a createChildObjectContext method [EOL] JsonToken result = _nextAfterName(); [EOL] assertFalse(_nameCopied); [EOL] assertNull(_nextToken); [EOL] assertEquals(JsonToken.START_OBJECT, result); [EOL] assertNotNull(_parsingContext); [EOL] assertTrue(_parsingContext.isObjectContext()); [EOL] }
public void testNextAfterNameWithOtherToken() { [EOL] _nameCopied = false; [EOL] _nextToken = JsonToken.VALUE_STRING; // Any token other than START_ARRAY or START_OBJECT [EOL] _tokenInputRow = 1; [EOL] _tokenInputCol = 1; [EOL] _parsingContext = new ParsingContext(); // Assuming ParsingContext is a class without specific child context creation for this token [EOL] JsonToken result = _nextAfterName(); [EOL] assertFalse(_nameCopied); [EOL] assertNull(_nextToken); [EOL] assertEquals(JsonToken.VALUE_STRING, result); [EOL] assertFalse(_parsingContext.isArrayContext()); [EOL] assertFalse(_parsingContext.isObjectContext()); [EOL] }
public void testClose() throws IOException { [EOL] JsonFactory factory = new JsonFactory(); [EOL] JsonGenerator generator = factory.createGenerator(new StringWriter()); [EOL] generator.close(); [EOL] }

protected JsonToken parseNumberText(int ch) throws IOException, JsonParseException { [EOL] boolean negative = (ch == INT_MINUS); [EOL] int ptr = _inputPtr; [EOL] int startPtr = ptr - 1; [EOL] final int inputLen = _inputEnd; [EOL] dummy_loop: do { [EOL] if (negative) { [EOL] if (ptr >= _inputEnd) { [EOL] break dummy_loop; [EOL] } [EOL] ch = _inputBuffer[ptr++]; [EOL] if (ch > INT_9 || ch < INT_0) { [EOL] _inputPtr = ptr; [EOL] return _handleInvalidNumberStart(ch, true); [EOL] } [EOL] } [EOL] if (ch == INT_0) { [EOL] break dummy_loop; [EOL] } [EOL] int intLen = 1; [EOL] int_loop: while (true) { [EOL] if (ptr >= _inputEnd) { [EOL] break dummy_loop; [EOL] } [EOL] ch = (int) _inputBuffer[ptr++]; [EOL] if (ch < INT_0 || ch > INT_9) { [EOL] break int_loop; [EOL] } [EOL] ++intLen; [EOL] } [EOL] int fractLen = 0; [EOL] if (ch == INT_DECIMAL_POINT) { [EOL] fract_loop: while (true) { [EOL] if (ptr >= inputLen) { [EOL] break dummy_loop; [EOL] } [EOL] ch = (int) _inputBuffer[ptr++]; [EOL] if (ch < INT_0 || ch > INT_9) { [EOL] break fract_loop; [EOL] } [EOL] ++fractLen; [EOL] } [EOL] if (fractLen == 0) { [EOL] reportUnexpectedNumberChar(ch, "Decimal point not followed by a digit"); [EOL] } [EOL] } [EOL] int expLen = 0; [EOL] if (ch == INT_e || ch == INT_E) { [EOL] if (ptr >= inputLen) { [EOL] break dummy_loop; [EOL] } [EOL] ch = (int) _inputBuffer[ptr++]; [EOL] if (ch == INT_MINUS || ch == INT_PLUS) { [EOL] if (ptr >= inputLen) { [EOL] break dummy_loop; [EOL] } [EOL] ch = (int) _inputBuffer[ptr++]; [EOL] } [EOL] while (ch <= INT_9 && ch >= INT_0) { [EOL] ++expLen; [EOL] if (ptr >= inputLen) { [EOL] break dummy_loop; [EOL] } [EOL] ch = (int) _inputBuffer[ptr++]; [EOL] } [EOL] if (expLen == 0) { [EOL] reportUnexpectedNumberChar(ch, "Exponent indicator not followed by a digit"); [EOL] } [EOL] } [EOL] --ptr; [EOL] _inputPtr = ptr; [EOL] int len = ptr - startPtr; [EOL] _textBuffer.resetWithShared(_inputBuffer, startPtr, len); [EOL] return reset(negative, intLen, fractLen, expLen); [EOL] } while (false); [EOL] _inputPtr = negative ? (startPtr + 1) : startPtr; [EOL] return parseNumberText2(negative); [EOL] }
private JsonToken parseNumberText2(boolean negative) throws IOException, JsonParseException { [EOL] char[] outBuf = _textBuffer.emptyAndGetCurrentSegment(); [EOL] int outPtr = 0; [EOL] if (negative) { [EOL] outBuf[outPtr++] = '-'; [EOL] } [EOL] int intLen = 0; [EOL] char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar("No digit following minus sign"); [EOL] if (c == '0') { [EOL] c = _verifyNoLeadingZeroes(); [EOL] } [EOL] boolean eof = false; [EOL] int_loop: while (c >= '0' && c <= '9') { [EOL] ++intLen; [EOL] if (outPtr >= outBuf.length) { [EOL] outBuf = _textBuffer.finishCurrentSegment(); [EOL] outPtr = 0; [EOL] } [EOL] outBuf[outPtr++] = c; [EOL] if (_inputPtr >= _inputEnd && !loadMore()) { [EOL] c = CHAR_NULL; [EOL] eof = true; [EOL] break int_loop; [EOL] } [EOL] c = _inputBuffer[_inputPtr++]; [EOL] } [EOL] if (intLen == 0) { [EOL] reportInvalidNumber("Missing integer part (next char " + _getCharDesc(c) + ")"); [EOL] } [EOL] int fractLen = 0; [EOL] if (c == '.') { [EOL] outBuf[outPtr++] = c; [EOL] fract_loop: while (true) { [EOL] if (_inputPtr >= _inputEnd && !loadMore()) { [EOL] eof = true; [EOL] break fract_loop; [EOL] } [EOL] c = _inputBuffer[_inputPtr++]; [EOL] if (c < INT_0 || c > INT_9) { [EOL] break fract_loop; [EOL] } [EOL] ++fractLen; [EOL] if (outPtr >= outBuf.length) { [EOL] outBuf = _textBuffer.finishCurrentSegment(); [EOL] outPtr = 0; [EOL] } [EOL] outBuf[outPtr++] = c; [EOL] } [EOL] if (fractLen == 0) { [EOL] reportUnexpectedNumberChar(c, "Decimal point not followed by a digit"); [EOL] } [EOL] } [EOL] int expLen = 0; [EOL] if (c == 'e' || c == 'E') { [EOL] if (outPtr >= outBuf.length) { [EOL] outBuf = _textBuffer.finishCurrentSegment(); [EOL] outPtr = 0; [EOL] } [EOL] outBuf[outPtr++] = c; [EOL] c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar("expected a digit for number exponent"); [EOL] if (c == '-' || c == '+') { [EOL] if (outPtr >= outBuf.length) { [EOL] outBuf = _textBuffer.finishCurrentSegment(); [EOL] outPtr = 0; [EOL] } [EOL] outBuf[outPtr++] = c; [EOL] c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar("expected a digit for number exponent"); [EOL] } [EOL] exp_loop: while (c <= INT_9 && c >= INT_0) { [EOL] ++expLen; [EOL] if (outPtr >= outBuf.length) { [EOL] outBuf = _textBuffer.finishCurrentSegment(); [EOL] outPtr = 0; [EOL] } [EOL] outBuf[outPtr++] = c; [EOL] if (_inputPtr >= _inputEnd && !loadMore()) { [EOL] eof = true; [EOL] break exp_loop; [EOL] } [EOL] c = _inputBuffer[_inputPtr++]; [EOL] } [EOL] if (expLen == 0) { [EOL] reportUnexpectedNumberChar(c, "Exponent indicator not followed by a digit"); [EOL] } [EOL] } [EOL] if (!eof) { [EOL] --_inputPtr; [EOL] } [EOL] _textBuffer.setCurrentLength(outPtr); [EOL] return reset(negative, intLen, fractLen, expLen); [EOL] }
public void testVerifyNoLeadingZeroesWithEmptyBuffer() throws IOException, JsonParseException { [EOL] assertEquals('0', _verifyNoLeadingZeroes()); [EOL] } [EOL] public void testVerifyNoLeadingZeroesWithNonDigit() throws IOException, JsonParseException { [EOL] assertEquals('0', _verifyNoLeadingZeroes()); [EOL] } [EOL] public void testVerifyNoLeadingZeroesWithLeadingZeroesNotAllowed() throws IOException, JsonParseException { [EOL] try { [EOL] _verifyNoLeadingZeroes(); [EOL] fail("Expected JsonParseException for leading zeroes"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] } [EOL] public void testVerifyNoLeadingZeroesWithSingleZero() throws IOException, JsonParseException { [EOL] assertEquals('0', _verifyNoLeadingZeroes()); [EOL] } [EOL] public void testVerifyNoLeadingZeroesWithMultipleLeadingZeroes() throws IOException, JsonParseException { [EOL] assertEquals('0', _verifyNoLeadingZeroes()); [EOL] } [EOL] public void testVerifyNoLeadingZeroesWithNonZeroDigit() throws IOException, JsonParseException { [EOL] char expectedDigit = '1'; // Replace with actual non-zero digit from _inputBuffer [EOL] assertEquals(expectedDigit, _verifyNoLeadingZeroes()); [EOL] }

public void testParseFieldNameWithNonQuoteChar() throws IOException, JsonParseException { [EOL] final int NON_QUOTE_INT = 65; // 'A' for example, which is not a quote [EOL] String result = _parseFieldName(NON_QUOTE_INT); [EOL] assertNotNull(result); [EOL] }
public void testParseFieldNameWithQuoteCharAtBufferEnd() throws IOException, JsonParseException { [EOL] _inputPtr = 0; [EOL] _inputEnd = 0; // Set input end to simulate end of buffer [EOL] _hashSeed = 1; // Arbitrary hash seed [EOL] _inputBuffer = new char[]{'"'}; // Buffer with just a quote at the end [EOL] String result = _parseFieldName(INT_QUOTE); [EOL] assertNotNull(result); [EOL] }
public void testParseFieldNameWithQuoteCharBeforeBufferEnd() throws IOException, JsonParseException { [EOL] _inputPtr = 0; [EOL] _inputEnd = 10; // Set input end to simulate buffer with space [EOL] _hashSeed = 1; // Arbitrary hash seed [EOL] _inputBuffer = new char[]{'"', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'}; [EOL] String result = _parseFieldName(INT_QUOTE); [EOL] assertNotNull(result); [EOL] }
public void testHandleUnusualFieldNameWithApostropheAllowed() throws IOException, JsonParseException { [EOL] int i = INT_APOSTROPHE; [EOL] when(isEnabled(Feature.ALLOW_SINGLE_QUOTES)).thenReturn(true); [EOL] String result = _handleUnusualFieldName(i); [EOL] assertEquals("Expected result from _parseApostropheFieldName", result); [EOL] }
public void testHandleUnusualFieldNameWithUnquotedNotAllowed() throws IOException, JsonParseException { [EOL] int i = 'a'; // Some character that is not an apostrophe [EOL] when(isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)).thenReturn(false); [EOL] assertThrows(JsonParseException.class, () -> _handleUnusualFieldName(i)); [EOL] }
public void testHandleUnusualFieldNameWithUnquotedAllowedNonJavaIdentifier() throws IOException, JsonParseException { [EOL] int i = '@'; // Some character that is not a valid Java identifier part [EOL] when(isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)).thenReturn(true); [EOL] assertThrows(JsonParseException.class, () -> _handleUnusualFieldName(i)); [EOL] }
public void testHandleUnusualFieldNameWithUnquotedAllowedJavaIdentifier() throws IOException, JsonParseException { [EOL] int i = 'a'; // Some character that is a valid Java identifier part [EOL] when(isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)).thenReturn(true); [EOL] int[] codes = CharTypes.getInputCodeLatin1JsNames(); [EOL] _inputPtr = 0; [EOL] _inputEnd = 10; [EOL] _inputBuffer = new int[]{i, 'b', 'c'}; // Some buffer content [EOL] _hashSeed = 0; [EOL] String result = _handleUnusualFieldName(i); [EOL] assertNotNull(result); [EOL] }
public void testHandleUnusualFieldNameWithEndOfInput() throws IOException, JsonParseException { [EOL] int i = 'a'; // Some character that is a valid Java identifier part [EOL] when(isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)).thenReturn(true); [EOL] int[] codes = CharTypes.getInputCodeLatin1JsNames(); [EOL] _inputPtr = 0; [EOL] _inputEnd = 0; // Simulate end of input [EOL] _inputBuffer = new int[]{i}; [EOL] _hashSeed = 0; [EOL] String result = _handleUnusualFieldName(i); [EOL] assertNotNull(result); [EOL] }
public void testParseApostropheFieldNameWithApostrophe() throws IOException, JsonParseException { [EOL] _inputPtr = 0; [EOL] _inputBuffer = new char[]{'a', 'b', '\'', 'c', 'd'}; [EOL] _inputEnd = _inputBuffer.length; [EOL] _hashSeed = 1; [EOL] String fieldName = _parseApostropheFieldName(); [EOL] assertEquals("ab", fieldName); [EOL] }
public void testParseApostropheFieldNameWithoutApostrophe() throws IOException, JsonParseException { [EOL] _inputPtr = 0; [EOL] _inputBuffer = new char[]{'a', 'b', 'c', 'd'}; [EOL] _inputEnd = _inputBuffer.length; [EOL] _hashSeed = 1; [EOL] String fieldName = _parseApostropheFieldName(); [EOL] assertNull(fieldName); // Assuming _parseFieldName2 returns null for this case [EOL] }
public void testParseApostropheFieldNameAtEnd() throws IOException, JsonParseException { [EOL] _inputPtr = 0; [EOL] _inputBuffer = new char[]{'a', 'b', 'c', 'd', '\''}; [EOL] _inputEnd = _inputBuffer.length; [EOL] _hashSeed = 1; [EOL] String fieldName = _parseApostropheFieldName(); [EOL] assertEquals("abcd", fieldName); [EOL] }
public void testParseApostropheFieldNameWithSpecialChar() throws IOException, JsonParseException { [EOL] _inputPtr = 0; [EOL] _inputBuffer = new char[]{'a', 'b', '\n', 'c', 'd', '\''}; [EOL] _inputEnd = _inputBuffer.length; [EOL] _hashSeed = 1; [EOL] String fieldName = _parseApostropheFieldName(); [EOL] assertNull(fieldName); // Assuming the newline character breaks the parsing and _parseFieldName2 handles it [EOL] }
protected JsonToken _handleUnexpectedValue(int i) throws IOException, JsonParseException { [EOL] switch(i) { [EOL] case '\'': [EOL] if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) { [EOL] return _handleApostropheValue(); [EOL] } [EOL] break; [EOL] case 'N': [EOL] _matchToken("NaN", 1); [EOL] if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL] return resetAsNaN("NaN", Double.NaN); [EOL] } [EOL] _reportError("Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL] break; [EOL] case 'I': [EOL] _matchToken("Infinity", 1); [EOL] if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL] return resetAsNaN("Infinity", Double.POSITIVE_INFINITY); [EOL] } [EOL] _reportError("Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL] break; [EOL] case '+': [EOL] if (_inputPtr >= _inputEnd) { [EOL] if (!loadMore()) { [EOL] _reportInvalidEOFInValue(); [EOL] } [EOL] } [EOL] return _handleInvalidNumberStart(_inputBuffer[_inputPtr++], false); [EOL] } [EOL] if (Character.isJavaIdentifierStart(i)) { [EOL] _reportInvalidToken("" + ((char) i), "('true', 'false' or 'null')"); [EOL] } [EOL] _reportUnexpectedChar(i, "expected a valid value (number, String, array, object, 'true', 'false' or 'null')"); [EOL] return null; [EOL] }
public void testHandleApostropheValueEndOfFile() throws IOException, JsonParseException { [EOL] when(this.loadMore()).thenReturn(false); [EOL] this._inputPtr = this._inputEnd; [EOL] try { [EOL] this._handleApostropheValue(); [EOL] fail("Expected JsonParseException"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testHandleApostropheValueWithEscapedCharacter() throws IOException, JsonParseException { [EOL] this._inputBuffer = new char[] {'\\', 'n'}; [EOL] this._inputEnd = 2; [EOL] this._inputPtr = 0; [EOL] when(this._decodeEscaped()).thenReturn('\n'); [EOL] JsonToken result = this._handleApostropheValue(); [EOL] assertEquals(JsonToken.VALUE_STRING, result); [EOL] assertArrayEquals(new char[] {'\n'}, Arrays.copyOfRange(this._textBuffer.emptyAndGetCurrentSegment(), 0, 1)); [EOL] }
public void testHandleApostropheValueWithApostrophe() throws IOException, JsonParseException { [EOL] this._inputBuffer = new char[] {'\''}; [EOL] this._inputEnd = 1; [EOL] this._inputPtr = 0; [EOL] JsonToken result = this._handleApostropheValue(); [EOL] assertEquals(JsonToken.VALUE_STRING, result); [EOL] assertEquals(0, this._textBuffer.getCurrentSegmentSize()); [EOL] }
public void testHandleApostropheValueWithUnquotedSpace() throws IOException, JsonParseException { [EOL] this._inputBuffer = new char[] {' '}; [EOL] this._inputEnd = 1; [EOL] this._inputPtr = 0; [EOL] try { [EOL] this._handleApostropheValue(); [EOL] fail("Expected JsonParseException"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testHandleApostropheValueWithRegularCharacter() throws IOException, JsonParseException { [EOL] this._inputBuffer = new char[] {'a'}; [EOL] this._inputEnd = 1; [EOL] this._inputPtr = 0; [EOL] JsonToken result = this._handleApostropheValue(); [EOL] assertEquals(JsonToken.VALUE_STRING, result); [EOL] assertArrayEquals(new char[] {'a'}, Arrays.copyOfRange(this._textBuffer.emptyAndGetCurrentSegment(), 0, 1)); [EOL] }
public void testParseUnusualFieldName2WithLoadMore() throws IOException, JsonParseException { [EOL] int startPtr = 0; [EOL] int hash = 1; [EOL] int[] codes = new int[256]; // Assuming maxCode is 256 for simplicity [EOL] when(this.loadMore()).thenReturn(true); [EOL] this._inputPtr = 0; [EOL] this._inputEnd = 10; [EOL] this._inputBuffer = new char[]{'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'}; [EOL] String result = this._parseUnusualFieldName2(startPtr, hash, codes); [EOL] }
public void testParseUnusualFieldName2WithBreakOnCode() throws IOException, JsonParseException { [EOL] int startPtr = 0; [EOL] int hash = 1; [EOL] int[] codes = new int[256]; // Assuming maxCode is 256 for simplicity [EOL] codes['a'] = 1; // Set a code to break the loop [EOL] when(this.loadMore()).thenReturn(true); [EOL] this._inputPtr = 0; [EOL] this._inputEnd = 10; [EOL] this._inputBuffer = new char[]{'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'}; [EOL] String result = this._parseUnusualFieldName2(startPtr, hash, codes); [EOL] }
public void testParseUnusualFieldName2WithBreakOnNonJavaIdentifierPart() throws IOException, JsonParseException { [EOL] int startPtr = 0; [EOL] int hash = 1; [EOL] int[] codes = new int[256]; // Assuming maxCode is 256 for simplicity [EOL] when(this.loadMore()).thenReturn(true); [EOL] this._inputPtr = 0; [EOL] this._inputEnd = 10; [EOL] this._inputBuffer = new char[]{'a', 'b', 'c', 'd', 'e', 'f', 'g', '#', 'i', 'j'}; // '#' is not a Java identifier part [EOL] String result = this._parseUnusualFieldName2(startPtr, hash, codes); [EOL] }
public void testParseUnusualFieldName2WithEndOfInput() throws IOException, JsonParseException { [EOL] int startPtr = 0; [EOL] int hash = 1; [EOL] int[] codes = new int[256]; // Assuming maxCode is 256 for simplicity [EOL] when(this.loadMore()).thenReturn(false); [EOL] this._inputPtr = 0; [EOL] this._inputEnd = 0; // Simulate end of input [EOL] this._inputBuffer = new char[]{}; // Empty buffer [EOL] String result = this._parseUnusualFieldName2(startPtr, hash, codes); [EOL] }
public void testFinishStringWithQuoteEnding() throws IOException, JsonParseException { [EOL] _inputPtr = 0; [EOL] _inputEnd = 5; [EOL] _inputBuffer = new char[] {'T', 'e', 's', 't', '"'}; [EOL] _finishString(); [EOL] assertEquals("Test", _textBuffer.contentsAsString()); [EOL] assertEquals(5, _inputPtr); [EOL] }
public void testFinishStringWithoutQuoteEnding() throws IOException, JsonParseException { [EOL] _inputPtr = 0; [EOL] _inputEnd = 4; [EOL] _inputBuffer = new char[] {'T', 'e', 's', 't'}; [EOL] _finishString(); [EOL] assertEquals("Test", _textBuffer.contentsAsString()); [EOL] assertEquals(4, _inputPtr); [EOL] }
public void testFinishStringWithSpecialCharacter() throws IOException, JsonParseException { [EOL] _inputPtr = 0; [EOL] _inputEnd = 6; [EOL] _inputBuffer = new char[] {'T', 'e', 's', 't', '\\', 'n'}; [EOL] _finishString(); [EOL] assertEquals("Test", _textBuffer.contentsAsString()); // Assuming _finishString2() handles escaping [EOL] assertEquals(4, _inputPtr); [EOL] }
public void testSkipWSWithNonSpaceChar() throws IOException, JsonParseException { [EOL] _inputPtr = 0; [EOL] _inputEnd = 1; [EOL] _inputBuffer = new char[]{'a'}; // 'a' is a non-space character [EOL] int result = _skipWS(); [EOL] assertEquals('a', result); [EOL] }
public void testSkipWSWithSlash() throws IOException, JsonParseException { [EOL] _inputPtr = 0; [EOL] _inputEnd = 1; [EOL] _inputBuffer = new char[]{'/'}; // '/' should trigger _skipComment() [EOL] int result = _skipWS(); [EOL] assertEquals('/', result); [EOL] }
public void testSkipWSWithSpace() throws IOException, JsonParseException { [EOL] _inputPtr = 0; [EOL] _inputEnd = 1; [EOL] _inputBuffer = new char[]{' '}; // ' ' is a space character [EOL] int result = _skipWS(); [EOL] assertEquals(' ', result); [EOL] }
public void testSkipWSWithLineFeed() throws IOException, JsonParseException { [EOL] _inputPtr = 0; [EOL] _inputEnd = 1; [EOL] _inputBuffer = new char[]{'\n'}; // '\n' should trigger _skipLF() [EOL] int result = _skipWS(); [EOL] assertEquals('\n', result); [EOL] }
public void testSkipWSWithCarriageReturn() throws IOException, JsonParseException { [EOL] _inputPtr = 0; [EOL] _inputEnd = 1; [EOL] _inputBuffer = new char[]{'\r'}; // '\r' should trigger _skipCR() [EOL] int result = _skipWS(); [EOL] assertEquals('\r', result); [EOL] }
public void testSkipWSWithTab() throws IOException, JsonParseException { [EOL] _inputPtr = 0; [EOL] _inputEnd = 1; [EOL] _inputBuffer = new char[]{'\t'}; // '\t' is a tab character [EOL] int result = _skipWS(); [EOL] assertEquals('\t', result); [EOL] }
public void testSkipWSWithInvalidSpace() throws IOException, JsonParseException { [EOL] _inputPtr = 0; [EOL] _inputEnd = 1; [EOL] _inputBuffer = new char[]{'\b'}; // '\b' is an invalid space character [EOL] try { [EOL] _skipWS(); [EOL] fail("Expected JsonParseException"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testSkipWSWithEndOfInput() throws IOException, JsonParseException { [EOL] _inputPtr = 0; [EOL] _inputEnd = 0; [EOL] try { [EOL] _skipWS(); [EOL] fail("Expected JsonParseException"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testSkipWSOrEndWithNonSpaceChar() throws IOException, JsonParseException { [EOL] _inputBuffer = new char[]{'a'}; // 'a' is a non-space character [EOL] _inputPtr = 0; [EOL] _inputEnd = 1; [EOL] int result = _skipWSOrEnd(); [EOL] assertEquals('a', result); [EOL] }
public void testSkipWSOrEndWithSlash() throws IOException, JsonParseException { [EOL] _inputBuffer = new char[]{'/'}; // '/' to trigger _skipComment [EOL] _inputPtr = 0; [EOL] _inputEnd = 1; [EOL] int result = _skipWSOrEnd(); [EOL] assertEquals('/', result); [EOL] }
public void testSkipWSOrEndWithSpace() throws IOException, JsonParseException { [EOL] _inputBuffer = new char[]{' '}; // ' ' is a space character [EOL] _inputPtr = 0; [EOL] _inputEnd = 1; [EOL] int result = _skipWSOrEnd(); [EOL] assertEquals(-1, result); // Assuming _handleEOF() returns -1 [EOL] }
public void testSkipWSOrEndWithLF() throws IOException, JsonParseException { [EOL] _inputBuffer = new char[]{'\n'}; // '\n' to trigger _skipLF [EOL] _inputPtr = 0; [EOL] _inputEnd = 1; [EOL] int result = _skipWSOrEnd(); [EOL] assertEquals(-1, result); // Assuming _handleEOF() returns -1 [EOL] }
public void testSkipWSOrEndWithCR() throws IOException, JsonParseException { [EOL] _inputBuffer = new char[]{'\r'}; // '\r' to trigger _skipCR [EOL] _inputPtr = 0; [EOL] _inputEnd = 1; [EOL] int result = _skipWSOrEnd(); [EOL] assertEquals(-1, result); // Assuming _handleEOF() returns -1 [EOL] }
public void testSkipWSOrEndWithTab() throws IOException, JsonParseException { [EOL] _inputBuffer = new char[]{'\t'}; // '\t' is a tab character [EOL] _inputPtr = 0; [EOL] _inputEnd = 1; [EOL] int result = _skipWSOrEnd(); [EOL] assertEquals(-1, result); // Assuming _handleEOF() returns -1 [EOL] }
public void testSkipWSOrEndWithInvalidSpace() throws IOException, JsonParseException { [EOL] _inputBuffer = new char[]{(char) 0x01}; // Invalid space character [EOL] _inputPtr = 0; [EOL] _inputEnd = 1; [EOL] try { [EOL] _skipWSOrEnd(); [EOL] fail("Should have thrown JsonParseException"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testSkipWSOrEndAtEndOfBuffer() throws IOException, JsonParseException { [EOL] _inputBuffer = new char[]{' '}; // ' ' is a space character [EOL] _inputPtr = 0; [EOL] _inputEnd = 0; // Simulate end of buffer [EOL] when(loadMore()).thenReturn(false); // No more data to load [EOL] int result = _skipWSOrEnd(); [EOL] assertEquals(-1, result); // Assuming _handleEOF() returns -1 [EOL] }
public void testSkipWSOrEndWithLoadMore() throws IOException, JsonParseException { [EOL] _inputBuffer = new char[]{' '}; // ' ' is a space character [EOL] _inputPtr = 0; [EOL] _inputEnd = 0; // Simulate end of buffer [EOL] when(loadMore()).thenReturn(true); // Mock loadMore to simulate loading more data [EOL] _inputBuffer = new char[]{'a'}; // 'a' is a non-space character [EOL] _inputPtr = 0; [EOL] _inputEnd = 1; [EOL] int result = _skipWSOrEnd(); [EOL] assertEquals('a', result); [EOL] }
protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException { [EOL] final int len = matchStr.length(); [EOL] do { [EOL] if (_inputPtr >= _inputEnd) { [EOL] if (!loadMore()) { [EOL] _reportInvalidToken(matchStr.substring(0, i)); [EOL] } [EOL] } [EOL] if (_inputBuffer[_inputPtr] != matchStr.charAt(i)) { [EOL] _reportInvalidToken(matchStr.substring(0, i)); [EOL] } [EOL] ++_inputPtr; [EOL] } while (++i < len); [EOL] if (_inputPtr >= _inputEnd) { [EOL] if (!loadMore()) { [EOL] return; [EOL] } [EOL] } [EOL] char c = _inputBuffer[_inputPtr]; [EOL] if (c < '0' || c == ']' || c == '}') { [EOL] return; [EOL] } [EOL] if (Character.isJavaIdentifierPart(c)) { [EOL] _reportInvalidToken(matchStr.substring(0, i)); [EOL] } [EOL] return; [EOL] }
public void testDecodeBase64WithPadding() throws IOException, JsonParseException { [EOL] Base64Variant b64variant = Base64Variants.getDefaultVariant(); [EOL] _inputBuffer = new char[]{'d', 'G', 'h', 'l', '=', '='}; [EOL] _inputPtr = 0; [EOL] _inputEnd = _inputBuffer.length; [EOL] byte[] result = _decodeBase64(b64variant); [EOL] assertArrayEquals(new byte[]{104, 105}, result); [EOL] }
public void testDecodeBase64WithoutPadding() throws IOException, JsonParseException { [EOL] Base64Variant b64variant = Base64Variants.getDefaultVariant(); [EOL] _inputBuffer = new char[]{'d', 'G', 'h', 'l'}; [EOL] _inputPtr = 0; [EOL] _inputEnd = _inputBuffer.length; [EOL] byte[] result = _decodeBase64(b64variant); [EOL] assertArrayEquals(new byte[]{104, 105}, result); [EOL] }
public void testDecodeBase64WithInvalidChar() throws IOException, JsonParseException { [EOL] Base64Variant b64variant = Base64Variants.getDefaultVariant(); [EOL] _inputBuffer = new char[]{'d', 'G', 'h', 'l', '!', '='}; [EOL] _inputPtr = 0; [EOL] _inputEnd = _inputBuffer.length; [EOL] try { [EOL] _decodeBase64(b64variant); [EOL] fail("Should throw JsonParseException"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testDecodeBase64WithIncompletePadding() throws IOException, JsonParseException { [EOL] Base64Variant b64variant = Base64Variants.getDefaultVariant(); [EOL] _inputBuffer = new char[]{'d', 'G', 'h', 'l', '='}; [EOL] _inputPtr = 0; [EOL] _inputEnd = _inputBuffer.length; [EOL] try { [EOL] _decodeBase64(b64variant); [EOL] fail("Should throw JsonParseException"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testDecodeBase64WithEndQuoteAndNoPadding() throws IOException, JsonParseException { [EOL] Base64Variant b64variant = Base64Variants.getMimeNoPaddingVariant(); [EOL] _inputBuffer = new char[]{'d', 'G', 'h', 'l', '"'}; [EOL] _inputPtr = 0; [EOL] _inputEnd = _inputBuffer.length; [EOL] byte[] result = _decodeBase64(b64variant); [EOL] assertArrayEquals(new byte[]{104, 105}, result); [EOL] }
public void testHashCode() { [EOL] MyClass instance = new MyClass(123); // Assuming MyClass is the class containing the hashCode method and it has a constructor that sets _hashCode [EOL] int expectedHashCode = 123; [EOL] int actualHashCode = instance.hashCode(); [EOL] assertEquals(expectedHashCode, actualHashCode); [EOL] }
public void testWriteFieldNameWithStatusExpectValue() throws IOException { [EOL] JsonGenerator generator = createGenerator(); // Implement this method to return a JsonGenerator instance [EOL] JsonWriteContext writeContext = generator.getOutputContext(); // Implement this method to return the current write context [EOL] try { [EOL] generator.writeFieldName("fieldName"); [EOL] fail("Should not allow writing a field name when expecting a value"); [EOL] } catch (JsonGenerationException e) { [EOL] } [EOL] }
public void testWriteFieldNameWithStatusOkAfterComma() throws IOException { [EOL] JsonGenerator generator = createGenerator(); // Implement this method to return a JsonGenerator instance [EOL] JsonWriteContext writeContext = generator.getOutputContext(); // Implement this method to return the current write context [EOL] writeContext.writeFieldName("previousFieldName"); // Set the context to expect a field name [EOL] generator.writeFieldName("fieldName"); // Should be allowed as the context is correct [EOL] }
public void testWriteFieldNameWithStatusOk() throws IOException { [EOL] JsonGenerator generator = createGenerator(); // Implement this method to return a JsonGenerator instance [EOL] JsonWriteContext writeContext = generator.getOutputContext(); // Implement this method to return the current write context [EOL] writeContext.writeFieldName("fieldName"); // Set the context to expect a value [EOL] generator.writeFieldName("anotherFieldName"); // Should throw an exception as the context is not expecting a field name [EOL] }
public void testWriteFieldNameWithExpectedValueStatus() throws IOException { [EOL] JsonGenerator g = createGenerator(); // Assuming createGenerator() is a method that creates a JsonGenerator instance [EOL] SerializableString name = new SerializableStringImpl("fieldName"); // Assuming SerializableStringImpl is an implementation of SerializableString [EOL] g.writeStartObject(); // Set up the context to expect a field name [EOL] try { [EOL] g.writeFieldName(name); [EOL] fail("Expected JsonGenerationException"); [EOL] } catch (JsonGenerationException e) { [EOL] } [EOL] } [EOL] public void testWriteFieldNameWithOkAfterCommaStatus() throws IOException { [EOL] JsonGenerator g = createGenerator(); // Assuming createGenerator() is a method that creates a JsonGenerator instance [EOL] SerializableString name = new SerializableStringImpl("fieldName"); // Assuming SerializableStringImpl is an implementation of SerializableString [EOL] g.writeStartObject(); // Set up the context to expect a field name [EOL] g.writeFieldName("anotherFieldName"); // Write another field name to change the status [EOL] g.writeNumber(1); // Write a value to satisfy the context [EOL] g.writeFieldName(name); // Now the context is OK_AFTER_COMMA [EOL] }
public void testWriteFieldNameWithPrettyPrinterAndComma() throws IOException { [EOL] _cfgPrettyPrinter = mock(PrettyPrinter.class); [EOL] _writeFieldName("name", true); [EOL] verify(_cfgPrettyPrinter).writeFieldName("name"); [EOL] }
public void testWriteFieldNameWithBufferFlush() throws IOException { [EOL] _outputTail = _outputEnd; // Simulate buffer being full [EOL] _writeFieldName("name", false); [EOL] assertEquals(0, _outputTail); [EOL] }
public void testWriteFieldNameWithCommaBefore() throws IOException { [EOL] _outputTail = 0; [EOL] _writeFieldName("name", true); [EOL] assertEquals(',', _outputBuffer[0]); [EOL] }
public void testWriteFieldNameWithoutQuoteFieldNames() throws IOException { [EOL] enableFeature(Feature.QUOTE_FIELD_NAMES, false); [EOL] _writeFieldName("name", false); [EOL] assertNotEquals('"', _outputBuffer[_outputTail - 1]); [EOL] }
public void testWriteFieldNameWithQuoteFieldNames() throws IOException { [EOL] enableFeature(Feature.QUOTE_FIELD_NAMES, true); [EOL] _writeFieldName("name", false); [EOL] assertEquals('"', _outputBuffer[_outputTail - 1]); [EOL] }
public void testWriteFieldNameWithPrettyPrinterAndComma() throws IOException { [EOL] JsonGeneratorImpl gen = createGeneratorWithPrettyPrinter(); [EOL] SerializableString name = createSerializableString(); [EOL] boolean commaBefore = true; [EOL] gen._writeFieldName(name, commaBefore); [EOL] } [EOL] public void testWriteFieldNameWithoutPrettyPrinterAndComma() throws IOException { [EOL] JsonGeneratorImpl gen = createGeneratorWithoutPrettyPrinter(); [EOL] SerializableString name = createSerializableString(); [EOL] boolean commaBefore = true; [EOL] prepareOutputBuffer(gen, 2); [EOL] gen._writeFieldName(name, commaBefore); [EOL] assertTrue("Output buffer should contain comma", bufferContainsComma(gen)); [EOL] assertTrue("Output buffer should contain quoted field name", bufferContainsQuotedFieldName(gen, name)); [EOL] }
public void testWriteFieldNameWithoutPrettyPrinterNoComma() throws IOException { [EOL] JsonGeneratorImpl gen = createGeneratorWithoutPrettyPrinter(); [EOL] SerializableString name = createSerializableString(); [EOL] boolean commaBefore = false; [EOL] prepareOutputBuffer(gen, 1); [EOL] gen._writeFieldName(name, commaBefore); [EOL] assertFalse("Output buffer should not contain comma", bufferContainsComma(gen)); [EOL] assertTrue("Output buffer should contain quoted field name", bufferContainsQuotedFieldName(gen, name)); [EOL] }
public void testWriteFieldNameWithDisabledQuoteFieldNames() throws IOException { [EOL] JsonGeneratorImpl gen = createGeneratorWithDisabledQuoteFieldNames(); [EOL] SerializableString name = createSerializableString(); [EOL] boolean commaBefore = false; [EOL] gen._writeFieldName(name, commaBefore); [EOL] assertTrue("Output should contain raw field name", outputContainsRawFieldName(gen, name)); [EOL] }
public void testWriteFieldNameWithBufferOverflow() throws IOException { [EOL] JsonGeneratorImpl gen = createGeneratorWithSmallBuffer(); [EOL] SerializableString name = createSerializableString(); [EOL] boolean commaBefore = false; [EOL] gen._writeFieldName(name, commaBefore); [EOL] assertTrue("Output should contain field name after buffer flush", outputContainsFieldNameAfterFlush(gen, name)); [EOL] }
public void testWriteStringWithNullText() throws IOException { [EOL] JsonGeneratorImpl generator = createJsonGenerator(); [EOL] generator.writeString(null); [EOL] } [EOL] public void testWriteStringWithEmptyText() throws IOException { [EOL] JsonGeneratorImpl generator = createJsonGenerator(); [EOL] generator.writeString(""); [EOL] } [EOL] public void testWriteStringWithNonEmptyText() throws IOException { [EOL] JsonGeneratorImpl generator = createJsonGenerator(); [EOL] generator.writeString("non-empty"); [EOL] } [EOL] public void testWriteStringWithLargeTextCausingBufferFlush() throws IOException { [EOL] JsonGeneratorImpl generator = createJsonGenerator(); [EOL] String largeText = createLargeTextThatExceedsBuffer(); [EOL] generator.writeString(largeText); [EOL] }
public void testWriteNumberWithNumbersAsStringsTrue() throws IOException { [EOL] JsonGeneratorImpl generator = createJsonGeneratorWithNumbersAsStrings(true); [EOL] generator.writeNumber(123); [EOL] assertEquals("\"123\"", generator.getOutput()); [EOL] }
public void testWriteNumberWithNumbersAsStringsFalseAndBufferSpaceSufficient() throws IOException { [EOL] JsonGeneratorImpl generator = createJsonGeneratorWithNumbersAsStrings(false); [EOL] generator.writeNumber(123); [EOL] assertEquals("123", generator.getOutput()); [EOL] }
public void testWriteNumberWithNumbersAsStringsFalseAndBufferSpaceInsufficient() throws IOException { [EOL] JsonGeneratorImpl generator = createJsonGeneratorWithNumbersAsStrings(false); [EOL] generator.setOutputBufferLength(10); // Set buffer length to 10 to force buffer flush [EOL] generator.writeNumber(1234567890); [EOL] assertEquals("1234567890", generator.getOutput()); [EOL] }
public void testWriteQuotedIntFlushBuffer() throws IOException { [EOL] _outputTail = _outputEnd - 12; [EOL] _writeQuotedInt(123); [EOL] assertEquals('"', _outputBuffer[_outputTail - 3]); [EOL] assertTrue(_outputBuffer[_outputTail - 2] >= '0' && _outputBuffer[_outputTail - 2] <= '9'); // Assuming NumberOutput.outputInt writes at least one digit [EOL] assertEquals('"', _outputBuffer[_outputTail - 1]); [EOL] }
public void testWriteQuotedIntNoFlushBuffer() throws IOException { [EOL] _outputTail = _outputEnd - 14; [EOL] _writeQuotedInt(123); [EOL] assertEquals('"', _outputBuffer[_outputTail - 3]); [EOL] assertTrue(_outputBuffer[_outputTail - 2] >= '0' && _outputBuffer[_outputTail - 2] <= '9'); // Assuming NumberOutput.outputInt writes at least one digit [EOL] assertEquals('"', _outputBuffer[_outputTail - 1]); [EOL] }
public void testWriteNumberWithNumbersAsStringsEnabled() throws IOException { [EOL] JsonGenerator g = createGenerator(); // Assume createGenerator() properly initializes a JsonGenerator [EOL] g.enable(JsonGenerator.Feature.WRITE_NUMBERS_AS_STRINGS); // Enable the _cfgNumbersAsStrings [EOL] long testValue = 123L; [EOL] g.writeNumber(testValue); [EOL] }
public void testWriteNumberWithNumbersAsStringsDisabled() throws IOException { [EOL] JsonGenerator g = createGenerator(); // Assume createGenerator() properly initializes a JsonGenerator [EOL] g.disable(JsonGenerator.Feature.WRITE_NUMBERS_AS_STRINGS); // Disable the _cfgNumbersAsStrings [EOL] long testValue = 123L; [EOL] g.writeNumber(testValue); [EOL] }
public void testWriteNumberRequiresFlush() throws IOException { [EOL] JsonGenerator g = createGenerator(); // Assume createGenerator() properly initializes a JsonGenerator [EOL] g.disable(JsonGenerator.Feature.WRITE_NUMBERS_AS_STRINGS); // Disable the _cfgNumbersAsStrings [EOL] long testValue = 123L; [EOL] g.writeNumber(testValue); [EOL] }
public void testWriteQuotedLongWithBufferFlush() throws IOException { [EOL] _outputEnd = 100; [EOL] _outputTail = 80; [EOL] long valueToWrite = 123456789L; [EOL] _writeQuotedLong(valueToWrite); [EOL] assertTrue(_outputTail < _outputEnd); [EOL] assertEquals('"', _outputBuffer[0]); [EOL] assertTrue(new String(_outputBuffer, 1, _outputTail - 2).contains(Long.toString(valueToWrite))); [EOL] assertEquals('"', _outputBuffer[_outputTail - 1]); [EOL] }
public void testWriteQuotedLongWithoutBufferFlush() throws IOException { [EOL] _outputEnd = 100; [EOL] _outputTail = 10; [EOL] long valueToWrite = 123456789L; [EOL] _writeQuotedLong(valueToWrite); [EOL] assertTrue(_outputTail > 10); [EOL] assertEquals('"', _outputBuffer[10]); [EOL] assertTrue(new String(_outputBuffer, 11, _outputTail - 12).contains(Long.toString(valueToWrite))); [EOL] assertEquals('"', _outputBuffer[_outputTail - 1]); [EOL] }
public void testWriteNumberWithNullValue() throws IOException { [EOL] JsonGenerator gen = createJsonGenerator(); // Implement this with your actual generator creation logic [EOL] gen.writeNumber((BigInteger) null); [EOL] }
public void testWriteNumberWithNumbersAsStringsEnabled() throws IOException { [EOL] JsonGenerator gen = createJsonGenerator(); // Implement this with your actual generator creation logic [EOL] gen.enable(JsonGenerator.Feature.WRITE_NUMBERS_AS_STRINGS); [EOL] gen.writeNumber(new BigInteger("12345")); [EOL] }
public void testWriteNumberWithNumbersAsStringsDisabled() throws IOException { [EOL] JsonGenerator gen = createJsonGenerator(); // Implement this with your actual generator creation logic [EOL] gen.disable(JsonGenerator.Feature.WRITE_NUMBERS_AS_STRINGS); [EOL] gen.writeNumber(new BigInteger("12345")); [EOL] }
public void testWriteNumberWithNumbersAsStringsEnabled() throws IOException { [EOL] JsonGenerator g = createGenerator(); // Assume createGenerator() is a method that creates a JsonGenerator instance [EOL] g.enable(JsonGenerator.Feature.WRITE_NUMBERS_AS_STRINGS); [EOL] g.writeNumber(123.456); [EOL] assertEquals("\"123.456\"", g.getOutputTarget()); // Assume getOutputTarget() is a method that returns the output as a string [EOL] }
public void testWriteNumberWithNaN() throws IOException { [EOL] JsonGenerator g = createGenerator(); [EOL] g.enable(JsonGenerator.Feature.QUOTE_NON_NUMERIC_NUMBERS); [EOL] g.writeNumber(Double.NaN); [EOL] assertEquals("\"NaN\"", g.getOutputTarget()); [EOL] }
public void testWriteNumberWithInfinite() throws IOException { [EOL] JsonGenerator g = createGenerator(); [EOL] g.enable(JsonGenerator.Feature.QUOTE_NON_NUMERIC_NUMBERS); [EOL] g.writeNumber(Double.POSITIVE_INFINITY); [EOL] assertEquals("\"Infinity\"", g.getOutputTarget()); [EOL] }
public void testWriteNumberWithFinite() throws IOException { [EOL] JsonGenerator g = createGenerator(); [EOL] g.disable(JsonGenerator.Feature.WRITE_NUMBERS_AS_STRINGS); [EOL] g.disable(JsonGenerator.Feature.QUOTE_NON_NUMERIC_NUMBERS); [EOL] g.writeNumber(123.456); [EOL] assertEquals("123.456", g.getOutputTarget()); [EOL] }
public void testWriteNumberWithNumbersAsStringsEnabled() throws IOException { [EOL] JsonGenerator g = createGenerator(); // Assume createGenerator() is a method that creates a JsonGenerator instance [EOL] g.configure(JsonGenerator.Feature.WRITE_NUMBERS_AS_STRINGS, true); [EOL] g.writeNumber(1.23f); [EOL] assertEquals("\"1.23\"", g.getOutput()); // Assume getOutput() is a method that returns the generator's output as a string [EOL] }
public void testWriteNumberWithNaN() throws IOException { [EOL] JsonGenerator g = createGenerator(); [EOL] g.writeNumber(Float.NaN); [EOL] assertEquals("\"NaN\"", g.getOutput()); [EOL] }
public void testWriteNumberWithPositiveInfinity() throws IOException { [EOL] JsonGenerator g = createGenerator(); [EOL] g.writeNumber(Float.POSITIVE_INFINITY); [EOL] assertEquals("\"Infinity\"", g.getOutput()); [EOL] }
public void testWriteNumberWithNegativeInfinity() throws IOException { [EOL] JsonGenerator g = createGenerator(); [EOL] g.writeNumber(Float.NEGATIVE_INFINITY); [EOL] assertEquals("\"-Infinity\"", g.getOutput()); [EOL] }
public void testWriteNumberWithRegularFloat() throws IOException { [EOL] JsonGenerator g = createGenerator(); [EOL] g.writeNumber(1.23f); [EOL] assertEquals("1.23", g.getOutput()); [EOL] }
public void testWriteNumberWithNullValue() throws IOException { [EOL] JsonGenerator gen = createGenerator(); // Assume createGenerator() is a method that creates a JsonGenerator instance [EOL] gen.writeNumber((BigDecimal) null); [EOL] } [EOL] public void testWriteNumberWithCfgNumbersAsStringsEnabled() throws IOException { [EOL] JsonGenerator gen = createGenerator(); [EOL] gen.enable(JsonGenerator.Feature.WRITE_NUMBERS_AS_STRINGS); [EOL] gen.writeNumber(new BigDecimal("123.456")); [EOL] } [EOL] public void testWriteNumberWithWriteBigDecimalAsPlainEnabled() throws IOException { [EOL] JsonGenerator gen = createGenerator(); [EOL] gen.enable(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN); [EOL] gen.writeNumber(new BigDecimal("123.456")); [EOL] } [EOL] public void testWriteNumberWithDefaultBehavior() throws IOException { [EOL] JsonGenerator gen = createGenerator(); [EOL] gen.writeNumber(new BigDecimal("123.456")); [EOL] }
public void testWriteNumberWithNumbersAsStringsEnabled() throws IOException { [EOL] JsonGenerator gen = createGeneratorWithConfigNumbersAsStrings(true); [EOL] String encodedValue = "42"; [EOL] gen.writeNumber(encodedValue); [EOL] } [EOL] public void testWriteNumberWithNumbersAsStringsDisabled() throws IOException { [EOL] JsonGenerator gen = createGeneratorWithConfigNumbersAsStrings(false); [EOL] String encodedValue = "42"; [EOL] gen.writeNumber(encodedValue); [EOL] }
public void testWriteQuotedRawWithSufficientBufferSpace() throws IOException { [EOL] _outputEnd = 10; [EOL] _outputTail = 0; [EOL] _outputBuffer = new char[_outputEnd]; [EOL] Object value = "test"; [EOL] _writeQuotedRaw(value); [EOL] assertEquals('"', _outputBuffer[0]); [EOL] assertEquals('t', _outputBuffer[1]); [EOL] assertEquals('e', _outputBuffer[2]); [EOL] assertEquals('s', _outputBuffer[3]); [EOL] assertEquals('t', _outputBuffer[4]); [EOL] assertEquals('"', _outputBuffer[5]); [EOL] }
public void testWriteQuotedRawWithBufferFlushNeeded() throws IOException { [EOL] _outputEnd = 10; [EOL] _outputTail = 9; [EOL] _outputBuffer = new char[_outputEnd]; [EOL] Object value = "test"; [EOL] _writeQuotedRaw(value); [EOL] assertEquals('"', _outputBuffer[0]); // Assuming _flushBuffer() resets _outputTail to 0 [EOL] assertEquals('t', _outputBuffer[1]); [EOL] assertEquals('e', _outputBuffer[2]); [EOL] assertEquals('s', _outputBuffer[3]); [EOL] assertEquals('t', _outputBuffer[4]); [EOL] assertEquals('"', _outputBuffer[5]); [EOL] }
public void testVerifyValueWriteExpectingFieldName() throws IOException { [EOL] JsonGeneratorImpl generator = createGenerator(); // Assuming createGenerator() is a method that creates an instance of the generator [EOL] generator._writeContext = JsonWriteContext.createRootContext(null); // Set up context to expect a name [EOL] try { [EOL] generator._verifyValueWrite("start an array"); [EOL] fail("Should not allow writing a value when expecting a field name"); [EOL] } catch (JsonGenerationException e) { [EOL] } [EOL] }
public void testVerifyValueWriteAfterComma() throws IOException { [EOL] JsonGeneratorImpl generator = createGenerator(); [EOL] generator._writeContext = JsonWriteContext.createRootContext(null); [EOL] generator._writeContext.writeValue(); // Set up context to be after a value which would be after a comma in an array [EOL] generator._verifyValueWrite("start an array"); [EOL] assertEquals(',', generator._outputBuffer[generator._outputTail - 1]); // Check if comma is correctly written [EOL] }
public void testVerifyValueWriteAfterColon() throws IOException { [EOL] JsonGeneratorImpl generator = createGenerator(); [EOL] generator._writeContext = JsonWriteContext.createRootContext(null); [EOL] generator._writeContext.writeValue(); // Set up context to be after a value which would be after a colon in an object [EOL] generator._writeContext.writeFieldName("a"); // Set up context to expect a value after a field name [EOL] generator._verifyValueWrite("write a value"); [EOL] assertEquals(':', generator._outputBuffer[generator._outputTail - 1]); // Check if colon is correctly written [EOL] }
public void testVerifyValueWriteAfterSpaceWithRootValueSeparator() throws IOException { [EOL] JsonGeneratorImpl generator = createGenerator(); [EOL] generator._writeContext = JsonWriteContext.createRootContext(null); [EOL] generator._writeContext.writeValue(); // Set up context to be after a value which would be after a space [EOL] generator._rootValueSeparator = new SerializedString(" "); // Set a space as the root value separator [EOL] generator._verifyValueWrite("write a value"); [EOL] assertEquals(' ', generator._outputBuffer[generator._outputTail - 1]); [EOL] }
public void testVerifyValueWriteAfterSpaceWithoutRootValueSeparator() throws IOException { [EOL] JsonGeneratorImpl generator = createGenerator(); [EOL] generator._writeContext = JsonWriteContext.createRootContext(null); [EOL] generator._writeContext.writeValue(); // Set up context to be after a value which would be after a space [EOL] generator._rootValueSeparator = null; // No root value separator [EOL] generator._verifyValueWrite("write a value"); [EOL] }
public void testVerifyValueWriteAsIs() throws IOException { [EOL] JsonGeneratorImpl generator = createGenerator(); [EOL] generator._writeContext = JsonWriteContext.createRootContext(null); [EOL] generator._writeContext.writeValue(); // Set up context to be STATUS_OK_AS_IS [EOL] generator._verifyValueWrite("write a value"); [EOL] }
public void testVerifyValueWriteWithPrettyPrinter() throws IOException { [EOL] JsonGeneratorImpl generator = createGenerator(); [EOL] generator._writeContext = JsonWriteContext.createRootContext(null); [EOL] generator._cfgPrettyPrinter = mock(PrettyPrinter.class); // Assuming mock() is a method that creates a mock of the PrettyPrinter [EOL] generator._verifyValueWrite("write a value"); [EOL] verify(generator._cfgPrettyPrinter).writeValueSeparator(generator); // Assuming verify() is a method to verify interactions with the mock [EOL] }
public void testWriteStringWithLongString() throws IOException, JsonGenerationException { [EOL] String longText = createLongString(); // Helper method to create a string longer than _outputEnd [EOL] _writeString(longText); [EOL] }
public void testWriteStringWithFlushBuffer() throws IOException, JsonGenerationException { [EOL] String text = "short"; [EOL] _outputTail = _outputEnd - text.length() + 1; // Set _outputTail such that (_outputTail + len) > _outputEnd [EOL] _writeString(text); [EOL] }
public void testWriteStringWithCharacterEscapes() throws IOException, JsonGenerationException { [EOL] String text = "short"; [EOL] _characterEscapes = new CharacterEscapes(); // Set _characterEscapes to a non-null value [EOL] _writeString(text); [EOL] }
public void testWriteStringWithMaximumNonEscapedChar() throws IOException, JsonGenerationException { [EOL] String text = "short"; [EOL] _maximumNonEscapedChar = 127; // Set a value for _maximumNonEscapedChar [EOL] _writeString(text); [EOL] }
public void testWriteStringWithNoEscaping() throws IOException, JsonGenerationException { [EOL] String text = "short"; [EOL] _writeString(text); [EOL] }
public void testWriteString2WithNoEscaping() throws IOException, JsonGenerationException { [EOL] _outputTail = 0; [EOL] _outputHead = 0; [EOL] _outputBuffer = new char[]{'a', 'b', 'c'}; [EOL] _outputEscapes = new int[128]; [EOL] _writer = new StringWriter(); [EOL] _writeString2(3); [EOL] assertEquals("abc", _writer.toString()); [EOL] }
public void testWriteString2WithEscaping() throws IOException, JsonGenerationException { [EOL] _outputTail = 0; [EOL] _outputHead = 0; [EOL] _outputBuffer = new char[]{'a', '\n', 'c'}; [EOL] _outputEscapes = new int[128]; [EOL] Arrays.fill(_outputEscapes, 1); // Set all escapes to 1 for simplicity [EOL] _outputEscapes['\n'] = 0; // Except for newline, to simulate no escaping for it [EOL] _writer = new StringWriter(); [EOL] _writeString2(3); [EOL] assertEquals("a\n", _writer.toString()); // Only 'a' and '\n' should be written, 'c' should trigger the escape [EOL] }
public void testWriteString2AtBufferEnd() throws IOException, JsonGenerationException { [EOL] _outputTail = 0; [EOL] _outputHead = 0; [EOL] _outputBuffer = new char[]{'a', 'b', 'c'}; [EOL] _outputEscapes = new int[128]; [EOL] _writer = new StringWriter(); [EOL] _writeString2(2); // Write less than the buffer length to simulate end of buffer [EOL] assertEquals("ab", _writer.toString()); [EOL] }
public void testWriteString2WithFullEscaping() throws IOException, JsonGenerationException { [EOL] _outputTail = 0; [EOL] _outputHead = 0; [EOL] _outputBuffer = new char[]{'a', 'b', 'c', 'd', 'e', 'f'}; [EOL] _outputEscapes = new int[128]; [EOL] Arrays.fill(_outputEscapes, 1); // Set all escapes to 1 to force escaping on every character [EOL] _writer = new StringWriter(); [EOL] _writeString2(6); [EOL] assertEquals("", _writer.toString()); // No characters should be written as they all should be escaped [EOL] }
public void testGetInputCodeLatin1ShouldNotReturnNull() { [EOL] int[] codes = YourClass.getInputCodeLatin1(); [EOL] assertNotNull(codes); [EOL] }
public void testGetInputCodeLatin1JsNames() { [EOL] int[] result = JsonFactory.getInputCodeLatin1JsNames(); [EOL] assertNotNull("Result should not be null", result); [EOL] assertTrue("Result should be an array of int", result instanceof int[]); [EOL] }
public void testGetInputCodeUtf8JsNames() { [EOL] int[] result = JsonFactory.getInputCodeUtf8JsNames(); [EOL] assertNotNull(result); [EOL] assertTrue(result.length > 0); [EOL] }
public void testGet7BitOutputEscapes() { [EOL] int[] escapes = JacksonCore.get7BitOutputEscapes(); [EOL] assertNotNull("Escapes should not be null", escapes); [EOL] assertEquals("Escapes array length should be 128", 128, escapes.length); [EOL] }
public void testJsonStringEncoderConstructor() { [EOL] JsonStringEncoder jsonStringEncoder = new JsonStringEncoder(); [EOL] assertNotNull(jsonStringEncoder); [EOL] char[] quoteBuffer = jsonStringEncoder.getQuoteBuffer(); [EOL] assertEquals(6, quoteBuffer.length); [EOL] assertEquals('\\', quoteBuffer[0]); [EOL] assertEquals('0', quoteBuffer[2]); [EOL] assertEquals('0', quoteBuffer[3]); [EOL] }
public void testQuoteAsStringWithEmptyString() { [EOL] JacksonCore target = new JacksonCore(); [EOL] String input = ""; [EOL] char[] result = target.quoteAsString(input); [EOL] assertEquals(0, result.length); [EOL] }
public void testQuoteAsStringWithNoEscaping() { [EOL] JacksonCore target = new JacksonCore(); [EOL] String input = "normalString"; [EOL] char[] result = target.quoteAsString(input); [EOL] assertEquals("normalString", new String(result)); [EOL] }
public void testQuoteAsStringWithEscaping() { [EOL] JacksonCore target = new JacksonCore(); [EOL] String input = "stringWith\"Quotes\""; [EOL] char[] result = target.quoteAsString(input); [EOL] assertTrue(new String(result).contains("\\\"")); [EOL] }
public void testQuoteAsStringWithSpecialCharacters() { [EOL] JacksonCore target = new JacksonCore(); [EOL] String input = "stringWithSpecialChar\u0001"; [EOL] char[] result = target.quoteAsString(input); [EOL] assertTrue(new String(result).endsWith("\\u0001")); [EOL] }
public void testQuoteAsStringWithLongString() { [EOL] JacksonCore target = new JacksonCore(); [EOL] StringBuilder sb = new StringBuilder(); [EOL] for (int i = 0; i < 10000; i++) { [EOL] sb.append("a"); [EOL] } [EOL] String input = sb.toString(); [EOL] char[] result = target.quoteAsString(input); [EOL] assertEquals(10000, result.length); [EOL] assertEquals(input, new String(result)); [EOL] }
public void testAppendNamedEscapeValidCode() { [EOL] char[] quoteBuffer = new char[2]; [EOL] int escCode = 65; // 'A' [EOL] int result = _appendNamedEscape(escCode, quoteBuffer); [EOL] assert result == 2; [EOL] assert quoteBuffer[1] == 'A'; [EOL] }
protected void testParserMinimalBaseDefaultConstructor() { [EOL] ParserMinimalBase parser = new ParserMinimalBase() {}; [EOL] assertNull(parser.getCurrentToken()); [EOL] assertFalse(parser.hasCurrentToken()); [EOL] assertFalse(parser.isClosed()); [EOL] }
protected void testParserMinimalBaseIntConstructor() { [EOL] int features = 0; // Assuming 0 is a valid feature set [EOL] ParserMinimalBase parser = new ParserMinimalBase(features) {}; [EOL] assertNull(parser.getCurrentToken()); [EOL] assertFalse(parser.hasCurrentToken()); [EOL] assertFalse(parser.isClosed()); [EOL] }
protected void testVersion() { [EOL] ParserMinimalBase parser = new ParserMinimalBase() {}; [EOL] assertNotNull(parser.version()); [EOL] }
protected void testClearCurrentToken() { [EOL] ParserMinimalBase parser = new ParserMinimalBase() {}; [EOL] parser.clearCurrentToken(); [EOL] assertNull(parser.getCurrentToken()); [EOL] }
protected void testGetLastClearedToken() { [EOL] ParserMinimalBase parser = new ParserMinimalBase() {}; [EOL] parser.clearCurrentToken(); [EOL] assertNull(parser.getLastClearedToken()); [EOL] }
protected void testGetValueAsBoolean() { [EOL] ParserMinimalBase parser = new ParserMinimalBase() {}; [EOL] boolean defaultValue = false; [EOL] assertFalse(parser.getValueAsBoolean(defaultValue)); [EOL] }
protected void testGetValueAsInt() { [EOL] ParserMinimalBase parser = new ParserMinimalBase() {}; [EOL] int defaultValue = 0; [EOL] assertEquals(defaultValue, parser.getValueAsInt(defaultValue)); [EOL] }
protected void testGetValueAsLong() { [EOL] ParserMinimalBase parser = new ParserMinimalBase() {}; [EOL] long defaultValue = 0L; [EOL] assertEquals(defaultValue, parser.getValueAsLong(defaultValue)); [EOL] }
protected void testGetValueAsDouble() { [EOL] ParserMinimalBase parser = new ParserMinimalBase() {}; [EOL] double defaultValue = 0.0; [EOL] assertEquals(defaultValue, parser.getValueAsDouble(defaultValue), 0.0); [EOL] }
protected void testGetValueAsString() { [EOL] ParserMinimalBase parser = new ParserMinimalBase() {}; [EOL] String defaultValue = ""; [EOL] assertEquals(defaultValue, parser.getValueAsString(defaultValue)); [EOL] }
protected void testHasTextualNull() { [EOL] ParserMinimalBase parser = new ParserMinimalBase() {}; [EOL] assertFalse(parser._hasTextualNull("false")); [EOL] }
protected void testGetCharDesc() { [EOL] assertEquals("[TAB]", ParserMinimalBase._getCharDesc(ParserMinimalBase.INT_TAB)); [EOL] assertEquals("[LF]", ParserMinimalBase._getCharDesc(ParserMinimalBase.INT_LF)); [EOL] }
public JsonToken getCurrentToken() { [EOL] return _currToken; [EOL] }
@SuppressWarnings("incomplete-switch") [EOL] @Override [EOL] public JsonParser skipChildren() throws IOException, JsonParseException { [EOL] if (_currToken != JsonToken.START_OBJECT && _currToken != JsonToken.START_ARRAY) { [EOL] return this; [EOL] } [EOL] int open = 1; [EOL] while (true) { [EOL] JsonToken t = nextToken(); [EOL] if (t == null) { [EOL] _handleEOF(); [EOL] return this; [EOL] } [EOL] switch(t) { [EOL] case START_OBJECT: [EOL] case START_ARRAY: [EOL] ++open; [EOL] break; [EOL] case END_OBJECT: [EOL] case END_ARRAY: [EOL] if (--open == 0) { [EOL] return this; [EOL] } [EOL] break; [EOL] } [EOL] } [EOL] } [EOL] protected ParserMinimalBase(); [EOL] protected ParserMinimalBase(int features); [EOL] public Version version(); [EOL] public abstract JsonToken nextToken() throws IOException, JsonParseException; [EOL] public JsonToken getCurrentToken(); [EOL] public boolean hasCurrentToken(); [EOL] public JsonToken nextValue() throws IOException, JsonParseException; [EOL] public JsonParser skipChildren() throws IOException, JsonParseException; [EOL] protected abstract void _handleEOF() throws JsonParseException; [EOL] public abstract String getCurrentName() throws IOException, JsonParseException; [EOL] public abstract void close() throws IOException; [EOL] public abstract boolean isClosed(); [EOL] public abstract JsonStreamContext getParsingContext(); [EOL] public void clearCurrentToken(); [EOL] public JsonToken getLastClearedToken(); [EOL] public abstract void overrideCurrentName(String name); [EOL] public abstract String getText() throws IOException, JsonParseException; [EOL] public abstract char[] getTextCharacters() throws IOException, JsonParseException; [EOL] public abstract boolean hasTextCharacters(); [EOL] public abstract int getTextLength() throws IOException, JsonParseException; [EOL] public abstract int getTextOffset() throws IOException, JsonParseException; [EOL] public abstract byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; [EOL] public boolean getValueAsBoolean(boolean defaultValue) throws IOException, JsonParseException; [EOL] public int getValueAsInt(int defaultValue) throws IOException, JsonParseException; [EOL] public long getValueAsLong(long defaultValue) throws IOException, JsonParseException; [EOL] public double getValueAsDouble(double defaultValue) throws IOException, JsonParseException; [EOL] public String getValueAsString(String defaultValue) throws IOException, JsonParseException; [EOL] protected void _decodeBase64(String str, ByteArrayBuilder builder, Base64Variant b64variant) throws IOException, JsonParseException; [EOL] protected void _reportInvalidBase64(Base64Variant b64variant, char ch, int bindex, String msg) throws JsonParseException; [EOL] protected void _reportBase64EOF() throws JsonParseException; [EOL] protected boolean _hasTextualNull(String value); [EOL] protected void _reportUnexpectedChar(int ch, String comment) throws JsonParseException; [EOL] protected void _reportInvalidEOF() throws JsonParseException; [EOL] protected void _reportInvalidEOF(String msg) throws JsonParseException; [EOL] protected void _reportInvalidEOFInValue() throws JsonParseException; [EOL] protected void _throwInvalidSpace(int i) throws JsonParseException; [EOL] protected void _throwUnquotedSpace(int i, String ctxtDesc) throws JsonParseException; [EOL] protected char _handleUnrecognizedCharacterEscape(char ch) throws JsonProcessingException; [EOL] protected static final String _getCharDesc(int ch); [EOL] protected final void _reportError(String msg) throws JsonParseException; [EOL] protected final void _wrapError(String msg, Throwable t) throws JsonParseException; [EOL] protected final void _throwInternal(); [EOL] protected final JsonParseException _constructError(String msg, Throwable t); [EOL] int INT_TAB=Optional['\t']; [EOL] int INT_LF=Optional['\n']; [EOL] int INT_CR=Optional['\r']; [EOL] int INT_SPACE=Optional[0x0020]; [EOL] int INT_LBRACKET=Optional['[']; [EOL] int INT_RBRACKET=Optional[']']; [EOL] int INT_LCURLY=Optional['{']; [EOL] int INT_RCURLY=Optional['}'];
public boolean getValueAsBooleanTestWithCurrTokenNullAndDefaultValueTrue() throws IOException, JsonParseException { [EOL] ParserMinimalBase parser = createParserWithNullCurrToken(); [EOL] boolean defaultValue = true; [EOL] boolean result = parser.getValueAsBoolean(defaultValue); [EOL] assertTrue(result); [EOL] } [EOL] public boolean getValueAsBooleanTestWithCurrTokenNumberIntNonZero() throws IOException, JsonParseException { [EOL] ParserMinimalBase parser = createParserWithValueNumberInt(1); // Assuming getIntValue() would return 1 [EOL] boolean result = parser.getValueAsBoolean(false); [EOL] assertTrue(result); [EOL] } [EOL] public boolean getValueAsBooleanTestWithCurrTokenNumberIntZero() throws IOException, JsonParseException { [EOL] ParserMinimalBase parser = createParserWithValueNumberInt(0); // Assuming getIntValue() would return 0 [EOL] boolean result = parser.getValueAsBoolean(true); [EOL] assertFalse(result); [EOL] }
public boolean getValueAsBooleanTestWithCurrTokenTrue() throws IOException, JsonParseException { [EOL] ParserMinimalBase parser = createParserWithCurrToken(JsonToken.VALUE_TRUE); [EOL] boolean result = parser.getValueAsBoolean(false); [EOL] assertTrue(result); [EOL] }
public boolean getValueAsBooleanTestWithCurrTokenFalse() throws IOException, JsonParseException { [EOL] ParserMinimalBase parser = createParserWithCurrToken(JsonToken.VALUE_FALSE); [EOL] boolean result = parser.getValueAsBoolean(true); [EOL] assertFalse(result); [EOL] }
public boolean getValueAsBooleanTestWithCurrTokenNull() throws IOException, JsonParseException { [EOL] ParserMinimalBase parser = createParserWithCurrToken(JsonToken.VALUE_NULL); [EOL] boolean result = parser.getValueAsBoolean(true); [EOL] assertFalse(result); [EOL] }
public boolean getValueAsBooleanTestWithCurrTokenEmbeddedObjectBooleanTrue() throws IOException, JsonParseException { [EOL] ParserMinimalBase parser = createParserWithEmbeddedObject(Boolean.TRUE); [EOL] boolean result = parser.getValueAsBoolean(false); [EOL] assertTrue(result); [EOL] }
public boolean getValueAsBooleanTestWithCurrTokenEmbeddedObjectNotBoolean() throws IOException, JsonParseException { [EOL] ParserMinimalBase parser = createParserWithEmbeddedObject(new Object()); [EOL] boolean result = parser.getValueAsBoolean(true); [EOL] assertTrue(result); [EOL] }
public boolean getValueAsBooleanTestWithCurrTokenStringTrue() throws IOException, JsonParseException { [EOL] ParserMinimalBase parser = createParserWithStringValue("true"); [EOL] boolean result = parser.getValueAsBoolean(false); [EOL] assertTrue(result); [EOL] }
public boolean getValueAsBooleanTestWithCurrTokenStringTextualNull() throws IOException, JsonParseException { [EOL] ParserMinimalBase parser = createParserWithStringValue("null"); [EOL] when(parser._hasTextualNull("null")).thenReturn(true); [EOL] boolean result = parser.getValueAsBoolean(true); [EOL] assertFalse(result); [EOL] }
public boolean getValueAsBooleanTestWithCurrTokenStringNeitherTrueNorTextualNull() throws IOException, JsonParseException { [EOL] ParserMinimalBase parser = createParserWithStringValue("someString"); [EOL] when(parser._hasTextualNull("someString")).thenReturn(false); [EOL] boolean result = parser.getValueAsBoolean(true); [EOL] assertTrue(result); [EOL] }
public void testGetValueAsLongWithNumberIntToken() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserWithToken(JsonToken.VALUE_NUMBER_INT); [EOL] when(parser.getLongValue()).thenReturn(10L); [EOL] long result = parser.getValueAsLong(0L); [EOL] assertEquals(10L, result); [EOL] }
public void testGetValueAsLongWithNumberFloatToken() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserWithToken(JsonToken.VALUE_NUMBER_FLOAT); [EOL] when(parser.getLongValue()).thenReturn(20L); [EOL] long result = parser.getValueAsLong(0L); [EOL] assertEquals(20L, result); [EOL] }
public void testGetValueAsLongWithTrueToken() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserWithToken(JsonToken.VALUE_TRUE); [EOL] long result = parser.getValueAsLong(0L); [EOL] assertEquals(1L, result); [EOL] }
public void testGetValueAsLongWithFalseOrNullToken() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserWithToken(JsonToken.VALUE_FALSE); [EOL] long result = parser.getValueAsLong(0L); [EOL] assertEquals(0L, result); [EOL] }
public void testGetValueAsLongWithStringToken() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserWithToken(JsonToken.VALUE_STRING); [EOL] when(parser.getText()).thenReturn("30"); [EOL] when(parser._hasTextualNull("30")).thenReturn(false); [EOL] long result = parser.getValueAsLong(0L); [EOL] assertEquals(30L, result); [EOL] }
public void testGetValueAsLongWithStringTokenTextualNull() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserWithToken(JsonToken.VALUE_STRING); [EOL] when(parser.getText()).thenReturn("null"); [EOL] when(parser._hasTextualNull("null")).thenReturn(true); [EOL] long result = parser.getValueAsLong(0L); [EOL] assertEquals(0L, result); [EOL] }
public void testGetValueAsLongWithEmbeddedObjectToken() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserWithToken(JsonToken.VALUE_EMBEDDED_OBJECT); [EOL] when(parser.getEmbeddedObject()).thenReturn(40L); [EOL] long result = parser.getValueAsLong(0L); [EOL] assertEquals(40L, result); [EOL] }
public void testGetValueAsLongWithNoCurrentToken() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserWithToken(null); [EOL] long result = parser.getValueAsLong(0L); [EOL] assertEquals(0L, result); [EOL] }
@SuppressWarnings("incomplete-switch") [EOL] @Override [EOL] public double getValueAsDouble(double defaultValue) throws IOException, JsonParseException { [EOL] if (_currToken != null) { [EOL] switch(_currToken) { [EOL] case VALUE_NUMBER_INT: [EOL] case VALUE_NUMBER_FLOAT: [EOL] return getDoubleValue(); [EOL] case VALUE_TRUE: [EOL] return 1; [EOL] case VALUE_FALSE: [EOL] case VALUE_NULL: [EOL] return 0; [EOL] case VALUE_STRING: [EOL] String str = getText(); [EOL] if (_hasTextualNull(str)) { [EOL] return 0; [EOL] } [EOL] return NumberInput.parseAsDouble(str, defaultValue); [EOL] case VALUE_EMBEDDED_OBJECT: [EOL] { [EOL] Object value = this.getEmbeddedObject(); [EOL] if (value instanceof Number) { [EOL] return ((Number) value).doubleValue(); [EOL] } [EOL] } [EOL] } [EOL] } [EOL] return defaultValue; [EOL] } [EOL] protected ParserMinimalBase(); [EOL] protected ParserMinimalBase(int features); [EOL] public Version version(); [EOL] public abstract JsonToken nextToken() throws IOException, JsonParseException; [EOL] public JsonToken getCurrentToken(); [EOL] public boolean hasCurrentToken(); [EOL] public JsonToken nextValue() throws IOException, JsonParseException; [EOL] public JsonParser skipChildren() throws IOException, JsonParseException; [EOL] protected abstract void _handleEOF() throws JsonParseException; [EOL] public abstract String getCurrentName() throws IOException, JsonParseException; [EOL] public abstract void close() throws IOException; [EOL] public abstract boolean isClosed(); [EOL] public abstract JsonStreamContext getParsingContext(); [EOL] public void clearCurrentToken(); [EOL] public JsonToken getLastClearedToken(); [EOL] public abstract void overrideCurrentName(String name); [EOL] public abstract String getText() throws IOException, JsonParseException; [EOL] public abstract char[] getTextCharacters() throws IOException, JsonParseException; [EOL] public abstract boolean hasTextCharacters(); [EOL] public abstract int getTextLength() throws IOException, JsonParseException; [EOL] public abstract int getTextOffset() throws IOException, JsonParseException; [EOL] public abstract byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; [EOL] public boolean getValueAsBoolean(boolean defaultValue) throws IOException, JsonParseException; [EOL] public int getValueAsInt(int defaultValue) throws IOException, JsonParseException; [EOL] public long getValueAsLong(long defaultValue) throws IOException, JsonParseException; [EOL] public double getValueAsDouble(double defaultValue) throws IOException, JsonParseException; [EOL] public String getValueAsString(String defaultValue) throws IOException, JsonParseException; [EOL] protected void _decodeBase64(String str, ByteArrayBuilder builder, Base64Variant b64variant) throws IOException, JsonParseException; [EOL] protected void _reportInvalidBase64(Base64Variant b64variant, char ch, int bindex, String msg) throws JsonParseException; [EOL] protected void _reportBase64EOF() throws JsonParseException; [EOL] protected boolean _hasTextualNull(String value); [EOL] protected void _reportUnexpectedChar(int ch, String comment) throws JsonParseException; [EOL] protected void _reportInvalidEOF() throws JsonParseException; [EOL] protected void _reportInvalidEOF(String msg) throws JsonParseException; [EOL] protected void _reportInvalidEOFInValue() throws JsonParseException; [EOL] protected void _throwInvalidSpace(int i) throws JsonParseException; [EOL] protected void _throwUnquotedSpace(int i, String ctxtDesc) throws JsonParseException; [EOL] protected char _handleUnrecognizedCharacterEscape(char ch) throws JsonProcessingException; [EOL] protected static final String _getCharDesc(int ch); [EOL] protected final void _reportError(String msg) throws JsonParseException; [EOL] protected final void _wrapError(String msg, Throwable t) throws JsonParseException; [EOL] protected final void _throwInternal(); [EOL] protected final JsonParseException _constructError(String msg, Throwable t); [EOL] int INT_TAB=Optional['\t']; [EOL] int INT_LF=Optional['\n']; [EOL] int INT_CR=Optional['\r']; [EOL] int INT_SPACE=Optional[0x0020]; [EOL] int INT_LBRACKET=Optional['[']; [EOL] int INT_RBRACKET=Optional[']']; [EOL] int INT_LCURLY=Optional['{']; [EOL] int INT_RCURLY=Optional['}'];
protected boolean _hasTextualNull(String value) { [EOL] return "null".equals(value); [EOL] } [EOL] protected ParserMinimalBase(); [EOL] protected ParserMinimalBase(int features); [EOL] public Version version(); [EOL] public abstract JsonToken nextToken() throws IOException, JsonParseException; [EOL] public JsonToken getCurrentToken(); [EOL] public boolean hasCurrentToken(); [EOL] public JsonToken nextValue() throws IOException, JsonParseException; [EOL] public JsonParser skipChildren() throws IOException, JsonParseException; [EOL] protected abstract void _handleEOF() throws JsonParseException; [EOL] public abstract String getCurrentName() throws IOException, JsonParseException; [EOL] public abstract void close() throws IOException; [EOL] public abstract boolean isClosed(); [EOL] public abstract JsonStreamContext getParsingContext(); [EOL] public void clearCurrentToken(); [EOL] public JsonToken getLastClearedToken(); [EOL] public abstract void overrideCurrentName(String name); [EOL] public abstract String getText() throws IOException, JsonParseException; [EOL] public abstract char[] getTextCharacters() throws IOException, JsonParseException; [EOL] public abstract boolean hasTextCharacters(); [EOL] public abstract int getTextLength() throws IOException, JsonParseException; [EOL] public abstract int getTextOffset() throws IOException, JsonParseException; [EOL] public abstract byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; [EOL] public boolean getValueAsBoolean(boolean defaultValue) throws IOException, JsonParseException; [EOL] public int getValueAsInt(int defaultValue) throws IOException, JsonParseException; [EOL] public long getValueAsLong(long defaultValue) throws IOException, JsonParseException; [EOL] public double getValueAsDouble(double defaultValue) throws IOException, JsonParseException; [EOL] public String getValueAsString(String defaultValue) throws IOException, JsonParseException; [EOL] protected void _decodeBase64(String str, ByteArrayBuilder builder, Base64Variant b64variant) throws IOException, JsonParseException; [EOL] protected void _reportInvalidBase64(Base64Variant b64variant, char ch, int bindex, String msg) throws JsonParseException; [EOL] protected void _reportBase64EOF() throws JsonParseException; [EOL] protected boolean _hasTextualNull(String value); [EOL] protected void _reportUnexpectedChar(int ch, String comment) throws JsonParseException; [EOL] protected void _reportInvalidEOF() throws JsonParseException; [EOL] protected void _reportInvalidEOF(String msg) throws JsonParseException; [EOL] protected void _reportInvalidEOFInValue() throws JsonParseException; [EOL] protected void _throwInvalidSpace(int i) throws JsonParseException; [EOL] protected void _throwUnquotedSpace(int i, String ctxtDesc) throws JsonParseException; [EOL] protected char _handleUnrecognizedCharacterEscape(char ch) throws JsonProcessingException; [EOL] protected static final String _getCharDesc(int ch); [EOL] protected final void _reportError(String msg) throws JsonParseException; [EOL] protected final void _wrapError(String msg, Throwable t) throws JsonParseException; [EOL] protected final void _throwInternal(); [EOL] protected final JsonParseException _constructError(String msg, Throwable t); [EOL] int INT_TAB=Optional['\t']; [EOL] int INT_LF=Optional['\n']; [EOL] int INT_CR=Optional['\r']; [EOL] int INT_SPACE=Optional[0x0020]; [EOL] int INT_LBRACKET=Optional['[']; [EOL] int INT_RBRACKET=Optional[']']; [EOL] int INT_LCURLY=Optional['{']; [EOL] int INT_RCURLY=Optional['}'];
protected char _handleUnrecognizedCharacterEscape(char ch) throws JsonProcessingException { [EOL] if (isEnabled(Feature.ALLOW_BACKSLASH_ESCAPING_ANY_CHARACTER)) { [EOL] return ch; [EOL] } [EOL] if (ch == '\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) { [EOL] return ch; [EOL] } [EOL] _reportError("Unrecognized character escape " + _getCharDesc(ch)); [EOL] return ch; [EOL] } [EOL] protected ParserMinimalBase(); [EOL] protected ParserMinimalBase(int features); [EOL] public Version version(); [EOL] public abstract JsonToken nextToken() throws IOException, JsonParseException; [EOL] public JsonToken getCurrentToken(); [EOL] public boolean hasCurrentToken(); [EOL] public JsonToken nextValue() throws IOException, JsonParseException; [EOL] public JsonParser skipChildren() throws IOException, JsonParseException; [EOL] protected abstract void _handleEOF() throws JsonParseException; [EOL] public abstract String getCurrentName() throws IOException, JsonParseException; [EOL] public abstract void close() throws IOException; [EOL] public abstract boolean isClosed(); [EOL] public abstract JsonStreamContext getParsingContext(); [EOL] public void clearCurrentToken(); [EOL] public JsonToken getLastClearedToken(); [EOL] public abstract void overrideCurrentName(String name); [EOL] public abstract String getText() throws IOException, JsonParseException; [EOL] public abstract char[] getTextCharacters() throws IOException, JsonParseException; [EOL] public abstract boolean hasTextCharacters(); [EOL] public abstract int getTextLength() throws IOException, JsonParseException; [EOL] public abstract int getTextOffset() throws IOException, JsonParseException; [EOL] public abstract byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; [EOL] public boolean getValueAsBoolean(boolean defaultValue) throws IOException, JsonParseException; [EOL] public int getValueAsInt(int defaultValue) throws IOException, JsonParseException; [EOL] public long getValueAsLong(long defaultValue) throws IOException, JsonParseException; [EOL] public double getValueAsDouble(double defaultValue) throws IOException, JsonParseException; [EOL] public String getValueAsString(String defaultValue) throws IOException, JsonParseException; [EOL] protected void _decodeBase64(String str, ByteArrayBuilder builder, Base64Variant b64variant) throws IOException, JsonParseException; [EOL] protected void _reportInvalidBase64(Base64Variant b64variant, char ch, int bindex, String msg) throws JsonParseException; [EOL] protected void _reportBase64EOF() throws JsonParseException; [EOL] protected boolean _hasTextualNull(String value); [EOL] protected void _reportUnexpectedChar(int ch, String comment) throws JsonParseException; [EOL] protected void _reportInvalidEOF() throws JsonParseException; [EOL] protected void _reportInvalidEOF(String msg) throws JsonParseException; [EOL] protected void _reportInvalidEOFInValue() throws JsonParseException; [EOL] protected void _throwInvalidSpace(int i) throws JsonParseException; [EOL] protected void _throwUnquotedSpace(int i, String ctxtDesc) throws JsonParseException; [EOL] protected char _handleUnrecognizedCharacterEscape(char ch) throws JsonProcessingException; [EOL] protected static final String _getCharDesc(int ch); [EOL] protected final void _reportError(String msg) throws JsonParseException; [EOL] protected final void _wrapError(String msg, Throwable t) throws JsonParseException; [EOL] protected final void _throwInternal(); [EOL] protected final JsonParseException _constructError(String msg, Throwable t); [EOL] int INT_TAB=Optional['\t']; [EOL] int INT_LF=Optional['\n']; [EOL] int INT_CR=Optional['\r']; [EOL] int INT_SPACE=Optional[0x0020]; [EOL] int INT_LBRACKET=Optional['[']; [EOL] int INT_RBRACKET=Optional[']']; [EOL] int INT_LCURLY=Optional['{']; [EOL] int INT_RCURLY=Optional['}'];
public void testResetWithObject() { [EOL] JsonWriteContext context = JsonWriteContext.createRootContext(null); [EOL] context.writeFieldName("test"); [EOL] JsonWriteContext resetContext = context.reset(JsonWriteContext.TYPE_OBJECT); [EOL] assertEquals(JsonWriteContext.TYPE_OBJECT, resetContext.getType()); [EOL] assertEquals(-1, resetContext.getCurrentIndex()); [EOL] assertNull(resetContext.getCurrentName()); [EOL] } [EOL] public void testResetWithArray() { [EOL] JsonWriteContext context = JsonWriteContext.createRootContext(null); [EOL] context.writeStartArray(); [EOL] JsonWriteContext resetContext = context.reset(JsonWriteContext.TYPE_ARRAY); [EOL] assertEquals(JsonWriteContext.TYPE_ARRAY, resetContext.getType()); [EOL] assertEquals(-1, resetContext.getCurrentIndex()); [EOL] assertNull(resetContext.getCurrentName()); [EOL] } [EOL] public void testResetWithRoot() { [EOL] JsonWriteContext context = JsonWriteContext.createRootContext(null); [EOL] JsonWriteContext resetContext = context.reset(JsonWriteContext.TYPE_ROOT); [EOL] assertEquals(JsonWriteContext.TYPE_ROOT, resetContext.getType()); [EOL] assertEquals(-1, resetContext.getCurrentIndex()); [EOL] assertNull(resetContext.getCurrentName()); [EOL] }
public void testCreateChildObjectContext_WhenChildIsNull() { [EOL] JsonWriteContext parentContext = JsonWriteContext.createRootContext(null); [EOL] JsonWriteContext childContext = parentContext.createChildObjectContext(); [EOL] assertNotNull(childContext); [EOL] assertEquals(JsonWriteContext.TYPE_OBJECT, childContext.type()); [EOL] }
public void testCreateChildObjectContext_WhenChildIsNotNull() { [EOL] JsonWriteContext parentContext = JsonWriteContext.createRootContext(null); [EOL] JsonWriteContext existingChildContext = parentContext.createChildObjectContext(); [EOL] JsonWriteContext reusedChildContext = parentContext.createChildObjectContext(); [EOL] assertSame(existingChildContext, reusedChildContext); [EOL] assertEquals(JsonWriteContext.TYPE_OBJECT, reusedChildContext.type()); [EOL] }
public void testWriteFieldNameWhenTypeIsObjectAndCurrentNameIsNullAndIndexIsNegative() { [EOL] JsonGeneratorImpl generator = new JsonGeneratorImpl(TYPE_OBJECT, -1, null); [EOL] int status = generator.writeFieldName("fieldName"); [EOL] assertEquals(STATUS_OK_AS_IS, status); [EOL] assertEquals("fieldName", generator.getCurrentName()); [EOL] }
public void testWriteFieldNameWhenTypeIsObjectAndCurrentNameIsNullAndIndexIsNotNegative() { [EOL] JsonGeneratorImpl generator = new JsonGeneratorImpl(TYPE_OBJECT, 1, null); [EOL] int status = generator.writeFieldName("fieldName"); [EOL] assertEquals(STATUS_OK_AFTER_COMMA, status); [EOL] assertEquals("fieldName", generator.getCurrentName()); [EOL] }
public void testWriteFieldNameWhenTypeIsObjectAndCurrentNameIsNotNull() { [EOL] JsonGeneratorImpl generator = new JsonGeneratorImpl(TYPE_OBJECT, -1, "existingName"); [EOL] int status = generator.writeFieldName("fieldName"); [EOL] assertEquals(STATUS_EXPECT_VALUE, status); [EOL] assertEquals("existingName", generator.getCurrentName()); [EOL] }
public void testWriteFieldNameWhenTypeIsNotObject() { [EOL] JsonGeneratorImpl generator = new JsonGeneratorImpl(TYPE_ARRAY, -1, null); [EOL] int status = generator.writeFieldName("fieldName"); [EOL] assertEquals(STATUS_EXPECT_VALUE, status); [EOL] assertNull(generator.getCurrentName()); [EOL] }
public void testWriteValueWithObjectExpectingName() { [EOL] JsonGeneratorImpl gen = new JsonGeneratorImpl(TYPE_OBJECT, null); [EOL] int status = gen.writeValue(); [EOL] assertEquals(STATUS_EXPECT_NAME, status); [EOL] }
public void testWriteValueWithObjectAfterNameSet() { [EOL] JsonGeneratorImpl gen = new JsonGeneratorImpl(TYPE_OBJECT, "name"); [EOL] int status = gen.writeValue(); [EOL] assertEquals(STATUS_OK_AFTER_COLON, status); [EOL] assertNull(gen.getCurrentName()); [EOL] assertEquals(1, gen.getIndex()); [EOL] }
public void testWriteValueWithArrayBeforeFirstElement() { [EOL] JsonGeneratorImpl gen = new JsonGeneratorImpl(TYPE_ARRAY, -1); [EOL] int status = gen.writeValue(); [EOL] assertEquals(STATUS_OK_AS_IS, status); [EOL] assertEquals(0, gen.getIndex()); [EOL] }
public void testWriteValueWithArrayAfterFirstElement() { [EOL] JsonGeneratorImpl gen = new JsonGeneratorImpl(TYPE_ARRAY, 0); [EOL] int status = gen.writeValue(); [EOL] assertEquals(STATUS_OK_AFTER_COMMA, status); [EOL] assertEquals(1, gen.getIndex()); [EOL] }
public void testWriteValueWithNonArrayOrObjectAtStart() { [EOL] JsonGeneratorImpl gen = new JsonGeneratorImpl(TYPE_OTHER, -1); [EOL] int status = gen.writeValue(); [EOL] assertEquals(STATUS_OK_AS_IS, status); [EOL] assertEquals(0, gen.getIndex()); [EOL] }
public void testWriteValueWithNonArrayOrObjectAfterStart() { [EOL] JsonGeneratorImpl gen = new JsonGeneratorImpl(TYPE_OTHER, 0); [EOL] int status = gen.writeValue(); [EOL] assertEquals(STATUS_OK_AFTER_SPACE, status); [EOL] assertEquals(1, gen.getIndex()); [EOL] }
public void testConfigureEnableFeature() { [EOL] JsonFactory factory = new JsonFactory(); [EOL] JsonParser.Feature feature = JsonParser.Feature.AUTO_CLOSE_SOURCE; [EOL] JsonFactory result = factory.configure(feature, true); [EOL] assertTrue(result.isEnabled(feature)); [EOL] }
public void testConfigureDisableFeature() { [EOL] JsonFactory factory = new JsonFactory(); [EOL] JsonParser.Feature feature = JsonParser.Feature.AUTO_CLOSE_SOURCE; [EOL] factory.enable(feature); [EOL] JsonFactory result = factory.configure(feature, false); [EOL] assertFalse(result.isEnabled(feature)); [EOL] }
public void testSetCharacterEscapesWithNull() { [EOL] JsonFactory factory = new JsonFactory(); [EOL] CharacterEscapes esc = null; [EOL] JsonFactory result = factory.setCharacterEscapes(esc); [EOL] assertNull(factory.getCharacterEscapes()); [EOL] assertSame(factory, result); [EOL] }
public void testSetCharacterEscapesWithNonNull() { [EOL] JsonFactory factory = new JsonFactory(); [EOL] CharacterEscapes esc = new CustomCharacterEscapes(); [EOL] JsonFactory result = factory.setCharacterEscapes(esc); [EOL] assertNotNull(factory.getCharacterEscapes()); [EOL] assertSame(factory, result); [EOL] }
public void testCreateParserWithNullInput() throws IOException { [EOL] JsonFactory factory = new JsonFactory(); [EOL] try { [EOL] factory.createParser((InputStream) null); [EOL] fail("Expected IOException"); [EOL] } catch (IOException e) { [EOL] } [EOL] }
public void testCreateParserWithNonNullInputAndNoDecorator() throws IOException { [EOL] JsonFactory factory = new JsonFactory(); [EOL] InputStream inputStream = new ByteArrayInputStream(new byte[0]); [EOL] JsonParser parser = factory.createParser(inputStream); [EOL] assertNotNull(parser); [EOL] parser.close(); [EOL] }
public void testCreateParserWithNonNullInputAndDecorator() throws IOException { [EOL] JsonFactory factory = new JsonFactory() { [EOL] @Override [EOL] public InputDecorator getInputDecorator() { [EOL] return new InputDecorator() { [EOL] @Override [EOL] public InputStream decorate(IOContext ctxt, InputStream in) throws IOException { [EOL] return new ByteArrayInputStream(new byte[0]); [EOL] } [EOL] }; [EOL] } [EOL] }; [EOL] InputStream inputStream = new ByteArrayInputStream(new byte[0]); [EOL] JsonParser parser = factory.createParser(inputStream); [EOL] assertNotNull(parser); [EOL] parser.close(); [EOL] }
public void testCreateParserWithNullReader() throws IOException { [EOL] try { [EOL] JsonFactory factory = new JsonFactory(); [EOL] factory.createParser((Reader) null); [EOL] fail("Expected IOException"); [EOL] } catch (IOException e) { [EOL] } [EOL] } [EOL] public void testCreateParserWithNonNullReaderAndNoDecorator() throws IOException { [EOL] JsonFactory factory = new JsonFactory(); [EOL] Reader reader = new StringReader("{}"); [EOL] JsonParser parser = factory.createParser(reader); [EOL] assertNotNull(parser); [EOL] parser.close(); [EOL] } [EOL] public void testCreateParserWithNonNullReaderAndDecorator() throws IOException { [EOL] JsonFactory factory = new JsonFactory() { [EOL] @Override [EOL] public InputDecorator getInputDecorator() { [EOL] return new InputDecorator() { [EOL] @Override [EOL] public Reader decorate(IOContext ctxt, Reader r) throws IOException { [EOL] return new StringReader("decorated"); [EOL] } [EOL] }; [EOL] } [EOL] }; [EOL] Reader reader = new StringReader("{}"); [EOL] JsonParser parser = factory.createParser(reader); [EOL] assertNotNull(parser); [EOL] assertEquals("decorated", ((ReaderBasedJsonParser) parser).getText()); [EOL] parser.close(); [EOL] }
public void testCreateParserWithNullData() throws IOException { [EOL] JsonFactory factory = new JsonFactory(); [EOL] byte[] data = null; [EOL] try { [EOL] factory.createParser(data); [EOL] fail("Expected IOException"); [EOL] } catch (IOException e) { [EOL] } [EOL] }
public void testCreateParserWithEmptyData() throws IOException { [EOL] JsonFactory factory = new JsonFactory(); [EOL] byte[] data = new byte[0]; [EOL] JsonParser parser = factory.createParser(data); [EOL] assertNotNull(parser); [EOL] parser.close(); [EOL] }
public void testCreateParserWithNonNullDataNoDecorator() throws IOException { [EOL] JsonFactory factory = new JsonFactory(); [EOL] byte[] data = "test".getBytes(); [EOL] JsonParser parser = factory.createParser(data); [EOL] assertNotNull(parser); [EOL] parser.close(); [EOL] }
public void testCreateParserWithNonNullDataWithDecorator() throws IOException { [EOL] JsonFactory factory = new JsonFactory() { [EOL] @Override [EOL] protected InputStream decorate(IOContext ctxt, byte[] src, int offset, int length) { [EOL] return new ByteArrayInputStream(src, offset, length); [EOL] } [EOL] }; [EOL] byte[] data = "test".getBytes(); [EOL] JsonParser parser = factory.createParser(data); [EOL] assertNotNull(parser); [EOL] parser.close(); [EOL] }
public void testCreateParserWithCanonicalizeFieldNamesEnabled() throws IOException { [EOL] IOContext ctxt = new IOContext(new BufferRecycler(), null, false); [EOL] byte[] data = new byte[]{/* some JSON data */}; [EOL] int offset = 0; [EOL] int len = data.length; [EOL] JsonFactory jf = new JsonFactory(); [EOL] jf.enable(JsonFactory.Feature.CANONICALIZE_FIELD_NAMES); [EOL] JsonParser parser = jf._createParser(data, offset, len, ctxt); [EOL] }
public void testCreateParserWithInternFieldNamesEnabled() throws IOException { [EOL] IOContext ctxt = new IOContext(new BufferRecycler(), null, false); [EOL] byte[] data = new byte[]{/* some JSON data */}; [EOL] int offset = 0; [EOL] int len = data.length; [EOL] JsonFactory jf = new JsonFactory(); [EOL] jf.enable(JsonFactory.Feature.INTERN_FIELD_NAMES); [EOL] JsonParser parser = jf._createParser(data, offset, len, ctxt); [EOL] }
public void testCreateParserWithBothFeaturesDisabled() throws IOException { [EOL] IOContext ctxt = new IOContext(new BufferRecycler(), null, false); [EOL] byte[] data = new byte[]{/* some JSON data */}; [EOL] int offset = 0; [EOL] int len = data.length; [EOL] JsonFactory jf = new JsonFactory(); [EOL] jf.disable(JsonFactory.Feature.CANONICALIZE_FIELD_NAMES); [EOL] jf.disable(JsonFactory.Feature.INTERN_FIELD_NAMES); [EOL] JsonParser parser = jf._createParser(data, offset, len, ctxt); [EOL] }
public void testCreateUTF8GeneratorWithDefaultRootValueSeparator() throws IOException { [EOL] OutputStream out = new ByteArrayOutputStream(); [EOL] IOContext ctxt = new IOContext(new BufferRecycler(), out, false); [EOL] JsonFactory jsonFactory = new JsonFactory(); [EOL] JsonGenerator gen = jsonFactory._createUTF8Generator(out, ctxt); [EOL] assertNotNull(gen); [EOL] assertTrue(checkRootValueSeparatorIsDefault(gen)); [EOL] } [EOL] public void testCreateUTF8GeneratorWithNonDefaultRootValueSeparator() throws IOException { [EOL] OutputStream out = new ByteArrayOutputStream(); [EOL] IOContext ctxt = new IOContext(new BufferRecycler(), out, false); [EOL] JsonFactory jsonFactory = new JsonFactory(); [EOL] SerializableString nonDefaultRootValueSeparator = new SerializableString() { [EOL] @Override [EOL] public String getValue() { [EOL] return ";"; [EOL] } [EOL] @Override [EOL] public int charLength() { [EOL] return getValue().length(); [EOL] } [EOL] @Override [EOL] public char[] asQuotedChars() { [EOL] return getValue().toCharArray(); [EOL] } [EOL] @Override [EOL] public byte[] asUnquotedUTF8() { [EOL] return getValue().getBytes(StandardCharsets.UTF_8); [EOL] } [EOL] @Override [EOL] public byte[] asQuotedUTF8() { [EOL] return getValue().getBytes(StandardCharsets.UTF_8); [EOL] } [EOL] }; [EOL] jsonFactory.setRootValueSeparator(nonDefaultRootValueSeparator); [EOL] JsonGenerator gen = jsonFactory._createUTF8Generator(out, ctxt); [EOL] assertNotNull(gen); [EOL] assertTrue(checkRootValueSeparatorIsNotDefault(gen, nonDefaultRootValueSeparator)); [EOL] } [EOL] public void testCreateUTF8GeneratorWithCharacterEscapes() throws IOException { [EOL] OutputStream out = new ByteArrayOutputStream(); [EOL] IOContext ctxt = new IOContext(new BufferRecycler(), out, false); [EOL] JsonFactory jsonFactory = new JsonFactory(); [EOL] CharacterEscapes customEscapes = new CharacterEscapes() { [EOL] @Override [EOL] public int[] getEscapeCodesForAscii() { [EOL] return new int[128]; [EOL] } [EOL] @Override [EOL] public SerializableString getEscapeSequence(int ch) { [EOL] return null; [EOL] } [EOL] }; [EOL] jsonFactory.setCharacterEscapes(customEscapes); [EOL] UTF8JsonGenerator gen = (UTF8JsonGenerator) jsonFactory._createUTF8Generator(out, ctxt); [EOL] assertNotNull(gen); [EOL] assertEquals(customEscapes, gen.getCharacterEscapes()); [EOL] }
public void testOptimizedStreamFromURL_FileProtocolNoHostNoEncodedChars() throws IOException { [EOL] URL fileUrl = new URL("file:///path/to/file"); [EOL] InputStream stream = _optimizedStreamFromURL(fileUrl); [EOL] assertTrue(stream instanceof FileInputStream); [EOL] }
public void testOptimizedStreamFromURL_FileProtocolWithHost() throws IOException { [EOL] URL fileUrlWithHost = new URL("file://localhost/path/to/file"); [EOL] InputStream stream = _optimizedStreamFromURL(fileUrlWithHost); [EOL] assertFalse(stream instanceof FileInputStream); [EOL] }
public void testOptimizedStreamFromURL_FileProtocolWithEncodedChars() throws IOException { [EOL] URL fileUrlEncoded = new URL("file:///path%20to%20file"); [EOL] InputStream stream = _optimizedStreamFromURL(fileUrlEncoded); [EOL] assertFalse(stream instanceof FileInputStream); [EOL] }
public void testOptimizedStreamFromURL_NonFileProtocol() throws IOException { [EOL] URL httpUrl = new URL("http://example.com"); [EOL] InputStream stream = _optimizedStreamFromURL(httpUrl); [EOL] assertNotNull(stream); [EOL] }
