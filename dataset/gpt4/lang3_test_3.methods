public static boolean isFalse(final Boolean bool) { [EOL]     return Boolean.FALSE.equals(bool); [EOL] }
public static boolean isNotFalse(final Boolean bool) { [EOL]     return !isFalse(bool); [EOL] }
public static boolean toBoolean(final int value, final int trueValue, final int falseValue) { [EOL]     if (value == trueValue) { [EOL]         return true; [EOL]     } [EOL]     if (value == falseValue) { [EOL]         return false; [EOL]     } [EOL]     throw new IllegalArgumentException("The Integer did not match either specified value"); [EOL] }
public static Boolean toBooleanObject(final Integer value, final Integer trueValue, final Integer falseValue, final Integer nullValue) { [EOL]     if (value == null) { [EOL]         if (trueValue == null) { [EOL]             return Boolean.TRUE; [EOL]         } [EOL]         if (falseValue == null) { [EOL]             return Boolean.FALSE; [EOL]         } [EOL]         if (nullValue == null) { [EOL]             return null; [EOL]         } [EOL]     } else if (value.equals(trueValue)) { [EOL]         return Boolean.TRUE; [EOL]     } else if (value.equals(falseValue)) { [EOL]         return Boolean.FALSE; [EOL]     } else if (value.equals(nullValue)) { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("The Integer did not match any specified value"); [EOL] }
public static Boolean toBooleanObject(final Integer value, final Integer trueValue, final Integer falseValue, final Integer nullValue) { [EOL]     if (value == null) { [EOL]         if (trueValue == null) { [EOL]             return Boolean.TRUE; [EOL]         } [EOL]         if (falseValue == null) { [EOL]             return Boolean.FALSE; [EOL]         } [EOL]         if (nullValue == null) { [EOL]             return null; [EOL]         } [EOL]     } else if (value.equals(trueValue)) { [EOL]         return Boolean.TRUE; [EOL]     } else if (value.equals(falseValue)) { [EOL]         return Boolean.FALSE; [EOL]     } else if (value.equals(nullValue)) { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("The Integer did not match any specified value"); [EOL] }
public static Boolean toBooleanObject(final Integer value, final Integer trueValue, final Integer falseValue, final Integer nullValue) { [EOL]     if (value == null) { [EOL]         if (trueValue == null) { [EOL]             return Boolean.TRUE; [EOL]         } [EOL]         if (falseValue == null) { [EOL]             return Boolean.FALSE; [EOL]         } [EOL]         if (nullValue == null) { [EOL]             return null; [EOL]         } [EOL]     } else if (value.equals(trueValue)) { [EOL]         return Boolean.TRUE; [EOL]     } else if (value.equals(falseValue)) { [EOL]         return Boolean.FALSE; [EOL]     } else if (value.equals(nullValue)) { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("The Integer did not match any specified value"); [EOL] }
public static Boolean toBooleanObject(final Integer value, final Integer trueValue, final Integer falseValue, final Integer nullValue) { [EOL]     if (value == null) { [EOL]         if (trueValue == null) { [EOL]             return Boolean.TRUE; [EOL]         } [EOL]         if (falseValue == null) { [EOL]             return Boolean.FALSE; [EOL]         } [EOL]         if (nullValue == null) { [EOL]             return null; [EOL]         } [EOL]     } else if (value.equals(trueValue)) { [EOL]         return Boolean.TRUE; [EOL]     } else if (value.equals(falseValue)) { [EOL]         return Boolean.FALSE; [EOL]     } else if (value.equals(nullValue)) { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("The Integer did not match any specified value"); [EOL] }
public static Boolean toBooleanObject(final Integer value, final Integer trueValue, final Integer falseValue, final Integer nullValue) { [EOL]     if (value == null) { [EOL]         if (trueValue == null) { [EOL]             return Boolean.TRUE; [EOL]         } [EOL]         if (falseValue == null) { [EOL]             return Boolean.FALSE; [EOL]         } [EOL]         if (nullValue == null) { [EOL]             return null; [EOL]         } [EOL]     } else if (value.equals(trueValue)) { [EOL]         return Boolean.TRUE; [EOL]     } else if (value.equals(falseValue)) { [EOL]         return Boolean.FALSE; [EOL]     } else if (value.equals(nullValue)) { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("The Integer did not match any specified value"); [EOL] }
public static Boolean toBooleanObject(final Integer value, final Integer trueValue, final Integer falseValue, final Integer nullValue) { [EOL]     if (value == null) { [EOL]         if (trueValue == null) { [EOL]             return Boolean.TRUE; [EOL]         } [EOL]         if (falseValue == null) { [EOL]             return Boolean.FALSE; [EOL]         } [EOL]         if (nullValue == null) { [EOL]             return null; [EOL]         } [EOL]     } else if (value.equals(trueValue)) { [EOL]         return Boolean.TRUE; [EOL]     } else if (value.equals(falseValue)) { [EOL]         return Boolean.FALSE; [EOL]     } else if (value.equals(nullValue)) { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("The Integer did not match any specified value"); [EOL] }
public static Boolean toBooleanObject(final Integer value, final Integer trueValue, final Integer falseValue, final Integer nullValue) { [EOL]     if (value == null) { [EOL]         if (trueValue == null) { [EOL]             return Boolean.TRUE; [EOL]         } [EOL]         if (falseValue == null) { [EOL]             return Boolean.FALSE; [EOL]         } [EOL]         if (nullValue == null) { [EOL]             return null; [EOL]         } [EOL]     } else if (value.equals(trueValue)) { [EOL]         return Boolean.TRUE; [EOL]     } else if (value.equals(falseValue)) { [EOL]         return Boolean.FALSE; [EOL]     } else if (value.equals(nullValue)) { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("The Integer did not match any specified value"); [EOL] }
public static int toInteger(final boolean bool) { [EOL]     return bool ? 1 : 0; [EOL] }
public static int toInteger(final boolean bool) { [EOL]     return bool ? 1 : 0; [EOL] }
public static Integer toIntegerObject(final boolean bool) { [EOL]     return bool ? NumberUtils.INTEGER_ONE : NumberUtils.INTEGER_ZERO; [EOL] }
public static Integer toIntegerObject(final boolean bool) { [EOL]     return bool ? NumberUtils.INTEGER_ONE : NumberUtils.INTEGER_ZERO; [EOL] }
public static int toInteger(final Boolean bool, final int trueValue, final int falseValue, final int nullValue) { [EOL]     if (bool == null) { [EOL]         return nullValue; [EOL]     } [EOL]     return bool.booleanValue() ? trueValue : falseValue; [EOL] }
public static int toInteger(final Boolean bool, final int trueValue, final int falseValue, final int nullValue) { [EOL]     if (bool == null) { [EOL]         return nullValue; [EOL]     } [EOL]     return bool.booleanValue() ? trueValue : falseValue; [EOL] }
public static int toInteger(final Boolean bool, final int trueValue, final int falseValue, final int nullValue) { [EOL]     if (bool == null) { [EOL]         return nullValue; [EOL]     } [EOL]     return bool.booleanValue() ? trueValue : falseValue; [EOL] }
public static Integer toIntegerObject(final Boolean bool, final Integer trueValue, final Integer falseValue, final Integer nullValue) { [EOL]     if (bool == null) { [EOL]         return nullValue; [EOL]     } [EOL]     return bool.booleanValue() ? trueValue : falseValue; [EOL] }
public static Integer toIntegerObject(final Boolean bool, final Integer trueValue, final Integer falseValue, final Integer nullValue) { [EOL]     if (bool == null) { [EOL]         return nullValue; [EOL]     } [EOL]     return bool.booleanValue() ? trueValue : falseValue; [EOL] }
public static Integer toIntegerObject(final Boolean bool, final Integer trueValue, final Integer falseValue, final Integer nullValue) { [EOL]     if (bool == null) { [EOL]         return nullValue; [EOL]     } [EOL]     return bool.booleanValue() ? trueValue : falseValue; [EOL] }
public static Boolean toBooleanObject(final String str, final String trueString, final String falseString, final String nullString) { [EOL]     if (str == null) { [EOL]         if (trueString == null) { [EOL]             return Boolean.TRUE; [EOL]         } [EOL]         if (falseString == null) { [EOL]             return Boolean.FALSE; [EOL]         } [EOL]         if (nullString == null) { [EOL]             return null; [EOL]         } [EOL]     } else if (str.equals(trueString)) { [EOL]         return Boolean.TRUE; [EOL]     } else if (str.equals(falseString)) { [EOL]         return Boolean.FALSE; [EOL]     } else if (str.equals(nullString)) { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("The String did not match any specified value"); [EOL] }
public static Boolean toBooleanObject(final String str, final String trueString, final String falseString, final String nullString) { [EOL]     if (str == null) { [EOL]         if (trueString == null) { [EOL]             return Boolean.TRUE; [EOL]         } [EOL]         if (falseString == null) { [EOL]             return Boolean.FALSE; [EOL]         } [EOL]         if (nullString == null) { [EOL]             return null; [EOL]         } [EOL]     } else if (str.equals(trueString)) { [EOL]         return Boolean.TRUE; [EOL]     } else if (str.equals(falseString)) { [EOL]         return Boolean.FALSE; [EOL]     } else if (str.equals(nullString)) { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("The String did not match any specified value"); [EOL] }
public static Boolean toBooleanObject(final String str, final String trueString, final String falseString, final String nullString) { [EOL]     if (str == null) { [EOL]         if (trueString == null) { [EOL]             return Boolean.TRUE; [EOL]         } [EOL]         if (falseString == null) { [EOL]             return Boolean.FALSE; [EOL]         } [EOL]         if (nullString == null) { [EOL]             return null; [EOL]         } [EOL]     } else if (str.equals(trueString)) { [EOL]         return Boolean.TRUE; [EOL]     } else if (str.equals(falseString)) { [EOL]         return Boolean.FALSE; [EOL]     } else if (str.equals(nullString)) { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("The String did not match any specified value"); [EOL] }
public static Boolean toBooleanObject(final String str, final String trueString, final String falseString, final String nullString) { [EOL]     if (str == null) { [EOL]         if (trueString == null) { [EOL]             return Boolean.TRUE; [EOL]         } [EOL]         if (falseString == null) { [EOL]             return Boolean.FALSE; [EOL]         } [EOL]         if (nullString == null) { [EOL]             return null; [EOL]         } [EOL]     } else if (str.equals(trueString)) { [EOL]         return Boolean.TRUE; [EOL]     } else if (str.equals(falseString)) { [EOL]         return Boolean.FALSE; [EOL]     } else if (str.equals(nullString)) { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("The String did not match any specified value"); [EOL] }
public static Boolean toBooleanObject(final String str, final String trueString, final String falseString, final String nullString) { [EOL]     if (str == null) { [EOL]         if (trueString == null) { [EOL]             return Boolean.TRUE; [EOL]         } [EOL]         if (falseString == null) { [EOL]             return Boolean.FALSE; [EOL]         } [EOL]         if (nullString == null) { [EOL]             return null; [EOL]         } [EOL]     } else if (str.equals(trueString)) { [EOL]         return Boolean.TRUE; [EOL]     } else if (str.equals(falseString)) { [EOL]         return Boolean.FALSE; [EOL]     } else if (str.equals(nullString)) { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("The String did not match any specified value"); [EOL] }
public static String toStringOnOff(final boolean bool) { [EOL]     return toString(bool, "on", "off"); [EOL] }
public static String toStringOnOff(final boolean bool) { [EOL]     return toString(bool, "on", "off"); [EOL] }
public static String toStringYesNo(final boolean bool) { [EOL]     return toString(bool, "yes", "no"); [EOL] }
public static String toStringYesNo(final boolean bool) { [EOL]     return toString(bool, "yes", "no"); [EOL] }
public static String toString(final boolean bool, final String trueString, final String falseString) { [EOL]     return bool ? trueString : falseString; [EOL] }
public static String toString(final boolean bool, final String trueString, final String falseString) { [EOL]     return bool ? trueString : falseString; [EOL] }
public static boolean and(final boolean... array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } [EOL]     if (array.length == 0) { [EOL]         throw new IllegalArgumentException("Array is empty"); [EOL]     } [EOL]     for (final boolean element : array) { [EOL]         if (!element) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public static boolean and(final boolean... array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } [EOL]     if (array.length == 0) { [EOL]         throw new IllegalArgumentException("Array is empty"); [EOL]     } [EOL]     for (final boolean element : array) { [EOL]         if (!element) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public static boolean and(final boolean... array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } [EOL]     if (array.length == 0) { [EOL]         throw new IllegalArgumentException("Array is empty"); [EOL]     } [EOL]     for (final boolean element : array) { [EOL]         if (!element) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public static boolean and(final boolean... array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } [EOL]     if (array.length == 0) { [EOL]         throw new IllegalArgumentException("Array is empty"); [EOL]     } [EOL]     for (final boolean element : array) { [EOL]         if (!element) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public static Boolean and(final Boolean... array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } [EOL]     if (array.length == 0) { [EOL]         throw new IllegalArgumentException("Array is empty"); [EOL]     } [EOL]     try { [EOL]         final boolean[] primitive = ArrayUtils.toPrimitive(array); [EOL]         return and(primitive) ? Boolean.TRUE : Boolean.FALSE; [EOL]     } catch (final NullPointerException ex) { [EOL]         throw new IllegalArgumentException("The array must not contain any null elements"); [EOL]     } [EOL] }
public static Boolean and(final Boolean... array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } [EOL]     if (array.length == 0) { [EOL]         throw new IllegalArgumentException("Array is empty"); [EOL]     } [EOL]     try { [EOL]         final boolean[] primitive = ArrayUtils.toPrimitive(array); [EOL]         return and(primitive) ? Boolean.TRUE : Boolean.FALSE; [EOL]     } catch (final NullPointerException ex) { [EOL]         throw new IllegalArgumentException("The array must not contain any null elements"); [EOL]     } [EOL] }
public static Boolean and(final Boolean... array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } [EOL]     if (array.length == 0) { [EOL]         throw new IllegalArgumentException("Array is empty"); [EOL]     } [EOL]     try { [EOL]         final boolean[] primitive = ArrayUtils.toPrimitive(array); [EOL]         return and(primitive) ? Boolean.TRUE : Boolean.FALSE; [EOL]     } catch (final NullPointerException ex) { [EOL]         throw new IllegalArgumentException("The array must not contain any null elements"); [EOL]     } [EOL] }
public static Boolean and(final Boolean... array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } [EOL]     if (array.length == 0) { [EOL]         throw new IllegalArgumentException("Array is empty"); [EOL]     } [EOL]     try { [EOL]         final boolean[] primitive = ArrayUtils.toPrimitive(array); [EOL]         return and(primitive) ? Boolean.TRUE : Boolean.FALSE; [EOL]     } catch (final NullPointerException ex) { [EOL]         throw new IllegalArgumentException("The array must not contain any null elements"); [EOL]     } [EOL] }
public static Boolean and(final Boolean... array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } [EOL]     if (array.length == 0) { [EOL]         throw new IllegalArgumentException("Array is empty"); [EOL]     } [EOL]     try { [EOL]         final boolean[] primitive = ArrayUtils.toPrimitive(array); [EOL]         return and(primitive) ? Boolean.TRUE : Boolean.FALSE; [EOL]     } catch (final NullPointerException ex) { [EOL]         throw new IllegalArgumentException("The array must not contain any null elements"); [EOL]     } [EOL] }
public static boolean or(final boolean... array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } [EOL]     if (array.length == 0) { [EOL]         throw new IllegalArgumentException("Array is empty"); [EOL]     } [EOL]     for (final boolean element : array) { [EOL]         if (element) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public static boolean or(final boolean... array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } [EOL]     if (array.length == 0) { [EOL]         throw new IllegalArgumentException("Array is empty"); [EOL]     } [EOL]     for (final boolean element : array) { [EOL]         if (element) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public static boolean or(final boolean... array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } [EOL]     if (array.length == 0) { [EOL]         throw new IllegalArgumentException("Array is empty"); [EOL]     } [EOL]     for (final boolean element : array) { [EOL]         if (element) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public static boolean or(final boolean... array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } [EOL]     if (array.length == 0) { [EOL]         throw new IllegalArgumentException("Array is empty"); [EOL]     } [EOL]     for (final boolean element : array) { [EOL]         if (element) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public static boolean or(final boolean... array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } [EOL]     if (array.length == 0) { [EOL]         throw new IllegalArgumentException("Array is empty"); [EOL]     } [EOL]     for (final boolean element : array) { [EOL]         if (element) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public static Boolean or(final Boolean... array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } [EOL]     if (array.length == 0) { [EOL]         throw new IllegalArgumentException("Array is empty"); [EOL]     } [EOL]     try { [EOL]         final boolean[] primitive = ArrayUtils.toPrimitive(array); [EOL]         return or(primitive) ? Boolean.TRUE : Boolean.FALSE; [EOL]     } catch (final NullPointerException ex) { [EOL]         throw new IllegalArgumentException("The array must not contain any null elements"); [EOL]     } [EOL] }
public static Boolean or(final Boolean... array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } [EOL]     if (array.length == 0) { [EOL]         throw new IllegalArgumentException("Array is empty"); [EOL]     } [EOL]     try { [EOL]         final boolean[] primitive = ArrayUtils.toPrimitive(array); [EOL]         return or(primitive) ? Boolean.TRUE : Boolean.FALSE; [EOL]     } catch (final NullPointerException ex) { [EOL]         throw new IllegalArgumentException("The array must not contain any null elements"); [EOL]     } [EOL] }
public static Boolean or(final Boolean... array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } [EOL]     if (array.length == 0) { [EOL]         throw new IllegalArgumentException("Array is empty"); [EOL]     } [EOL]     try { [EOL]         final boolean[] primitive = ArrayUtils.toPrimitive(array); [EOL]         return or(primitive) ? Boolean.TRUE : Boolean.FALSE; [EOL]     } catch (final NullPointerException ex) { [EOL]         throw new IllegalArgumentException("The array must not contain any null elements"); [EOL]     } [EOL] }
public static Boolean or(final Boolean... array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } [EOL]     if (array.length == 0) { [EOL]         throw new IllegalArgumentException("Array is empty"); [EOL]     } [EOL]     try { [EOL]         final boolean[] primitive = ArrayUtils.toPrimitive(array); [EOL]         return or(primitive) ? Boolean.TRUE : Boolean.FALSE; [EOL]     } catch (final NullPointerException ex) { [EOL]         throw new IllegalArgumentException("The array must not contain any null elements"); [EOL]     } [EOL] }
public static Boolean or(final Boolean... array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } [EOL]     if (array.length == 0) { [EOL]         throw new IllegalArgumentException("Array is empty"); [EOL]     } [EOL]     try { [EOL]         final boolean[] primitive = ArrayUtils.toPrimitive(array); [EOL]         return or(primitive) ? Boolean.TRUE : Boolean.FALSE; [EOL]     } catch (final NullPointerException ex) { [EOL]         throw new IllegalArgumentException("The array must not contain any null elements"); [EOL]     } [EOL] }
public static Boolean or(final Boolean... array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } [EOL]     if (array.length == 0) { [EOL]         throw new IllegalArgumentException("Array is empty"); [EOL]     } [EOL]     try { [EOL]         final boolean[] primitive = ArrayUtils.toPrimitive(array); [EOL]         return or(primitive) ? Boolean.TRUE : Boolean.FALSE; [EOL]     } catch (final NullPointerException ex) { [EOL]         throw new IllegalArgumentException("The array must not contain any null elements"); [EOL]     } [EOL] }
public MethodUtils() { [EOL]     super(); [EOL] }
public static Method getAccessibleMethod(Method method) { [EOL]     if (!MemberUtils.isAccessible(method)) { [EOL]         return null; [EOL]     } [EOL]     final Class<?> cls = method.getDeclaringClass(); [EOL]     if (Modifier.isPublic(cls.getModifiers())) { [EOL]         return method; [EOL]     } [EOL]     final String methodName = method.getName(); [EOL]     final Class<?>[] parameterTypes = method.getParameterTypes(); [EOL]     method = getAccessibleMethodFromInterfaceNest(cls, methodName, parameterTypes); [EOL]     if (method == null) { [EOL]         method = getAccessibleMethodFromSuperclass(cls, methodName, parameterTypes); [EOL]     } [EOL]     return method; [EOL] }
public static int toInt(final String str, final int defaultValue) { [EOL]     if (str == null) { [EOL]         return defaultValue; [EOL]     } [EOL]     try { [EOL]         return Integer.parseInt(str); [EOL]     } catch (final NumberFormatException nfe) { [EOL]         return defaultValue; [EOL]     } [EOL] }
public static long toLong(final String str) { [EOL]     return toLong(str, 0L); [EOL] }
public static long toLong(final String str, final long defaultValue) { [EOL]     if (str == null) { [EOL]         return defaultValue; [EOL]     } [EOL]     try { [EOL]         return Long.parseLong(str); [EOL]     } catch (final NumberFormatException nfe) { [EOL]         return defaultValue; [EOL]     } [EOL] }
public static long toLong(final String str, final long defaultValue) { [EOL]     if (str == null) { [EOL]         return defaultValue; [EOL]     } [EOL]     try { [EOL]         return Long.parseLong(str); [EOL]     } catch (final NumberFormatException nfe) { [EOL]         return defaultValue; [EOL]     } [EOL] }
public static long toLong(final String str, final long defaultValue) { [EOL]     if (str == null) { [EOL]         return defaultValue; [EOL]     } [EOL]     try { [EOL]         return Long.parseLong(str); [EOL]     } catch (final NumberFormatException nfe) { [EOL]         return defaultValue; [EOL]     } [EOL] }
public static float toFloat(final String str) { [EOL]     return toFloat(str, 0.0f); [EOL] }
public static float toFloat(final String str) { [EOL]     return toFloat(str, 0.0f); [EOL] }
public static float toFloat(final String str, final float defaultValue) { [EOL]     if (str == null) { [EOL]         return defaultValue; [EOL]     } [EOL]     try { [EOL]         return Float.parseFloat(str); [EOL]     } catch (final NumberFormatException nfe) { [EOL]         return defaultValue; [EOL]     } [EOL] }
public static Double createDouble(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     return Double.valueOf(str); [EOL] }
public static BigDecimal createBigDecimal(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (StringUtils.isBlank(str)) { [EOL]         throw new NumberFormatException("A blank string is not a valid number"); [EOL]     } [EOL]     if (str.trim().startsWith("--")) { [EOL]         throw new NumberFormatException(str + " is not a valid number."); [EOL]     } [EOL]     return new BigDecimal(str); [EOL] }
public static BigDecimal createBigDecimal(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (StringUtils.isBlank(str)) { [EOL]         throw new NumberFormatException("A blank string is not a valid number"); [EOL]     } [EOL]     if (str.trim().startsWith("--")) { [EOL]         throw new NumberFormatException(str + " is not a valid number."); [EOL]     } [EOL]     return new BigDecimal(str); [EOL] }
public static BigDecimal createBigDecimal(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (StringUtils.isBlank(str)) { [EOL]         throw new NumberFormatException("A blank string is not a valid number"); [EOL]     } [EOL]     if (str.trim().startsWith("--")) { [EOL]         throw new NumberFormatException(str + " is not a valid number."); [EOL]     } [EOL]     return new BigDecimal(str); [EOL] }
public static BigDecimal createBigDecimal(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (StringUtils.isBlank(str)) { [EOL]         throw new NumberFormatException("A blank string is not a valid number"); [EOL]     } [EOL]     if (str.trim().startsWith("--")) { [EOL]         throw new NumberFormatException(str + " is not a valid number."); [EOL]     } [EOL]     return new BigDecimal(str); [EOL] }
public static int max(final int[] array) { [EOL]     validateArray(array); [EOL]     int max = array[0]; [EOL]     for (int j = 1; j < array.length; j++) { [EOL]         if (array[j] > max) { [EOL]             max = array[j]; [EOL]         } [EOL]     } [EOL]     return max; [EOL] }
public static double max(final double[] array) { [EOL]     validateArray(array); [EOL]     double max = array[0]; [EOL]     for (int j = 1; j < array.length; j++) { [EOL]         if (Double.isNaN(array[j])) { [EOL]             return Double.NaN; [EOL]         } [EOL]         if (array[j] > max) { [EOL]             max = array[j]; [EOL]         } [EOL]     } [EOL]     return max; [EOL] }
public static double max(final double[] array) { [EOL]     validateArray(array); [EOL]     double max = array[0]; [EOL]     for (int j = 1; j < array.length; j++) { [EOL]         if (Double.isNaN(array[j])) { [EOL]             return Double.NaN; [EOL]         } [EOL]         if (array[j] > max) { [EOL]             max = array[j]; [EOL]         } [EOL]     } [EOL]     return max; [EOL] }
public static double max(final double[] array) { [EOL]     validateArray(array); [EOL]     double max = array[0]; [EOL]     for (int j = 1; j < array.length; j++) { [EOL]         if (Double.isNaN(array[j])) { [EOL]             return Double.NaN; [EOL]         } [EOL]         if (array[j] > max) { [EOL]             max = array[j]; [EOL]         } [EOL]     } [EOL]     return max; [EOL] }
public static double max(final double[] array) { [EOL]     validateArray(array); [EOL]     double max = array[0]; [EOL]     for (int j = 1; j < array.length; j++) { [EOL]         if (Double.isNaN(array[j])) { [EOL]             return Double.NaN; [EOL]         } [EOL]         if (array[j] > max) { [EOL]             max = array[j]; [EOL]         } [EOL]     } [EOL]     return max; [EOL] }
public static float max(final float[] array) { [EOL]     validateArray(array); [EOL]     float max = array[0]; [EOL]     for (int j = 1; j < array.length; j++) { [EOL]         if (Float.isNaN(array[j])) { [EOL]             return Float.NaN; [EOL]         } [EOL]         if (array[j] > max) { [EOL]             max = array[j]; [EOL]         } [EOL]     } [EOL]     return max; [EOL] }
public static float max(final float[] array) { [EOL]     validateArray(array); [EOL]     float max = array[0]; [EOL]     for (int j = 1; j < array.length; j++) { [EOL]         if (Float.isNaN(array[j])) { [EOL]             return Float.NaN; [EOL]         } [EOL]         if (array[j] > max) { [EOL]             max = array[j]; [EOL]         } [EOL]     } [EOL]     return max; [EOL] }
public static float max(final float[] array) { [EOL]     validateArray(array); [EOL]     float max = array[0]; [EOL]     for (int j = 1; j < array.length; j++) { [EOL]         if (Float.isNaN(array[j])) { [EOL]             return Float.NaN; [EOL]         } [EOL]         if (array[j] > max) { [EOL]             max = array[j]; [EOL]         } [EOL]     } [EOL]     return max; [EOL] }
public static float max(final float[] array) { [EOL]     validateArray(array); [EOL]     float max = array[0]; [EOL]     for (int j = 1; j < array.length; j++) { [EOL]         if (Float.isNaN(array[j])) { [EOL]             return Float.NaN; [EOL]         } [EOL]         if (array[j] > max) { [EOL]             max = array[j]; [EOL]         } [EOL]     } [EOL]     return max; [EOL] }
public static float max(final float[] array) { [EOL]     validateArray(array); [EOL]     float max = array[0]; [EOL]     for (int j = 1; j < array.length; j++) { [EOL]         if (Float.isNaN(array[j])) { [EOL]             return Float.NaN; [EOL]         } [EOL]         if (array[j] > max) { [EOL]             max = array[j]; [EOL]         } [EOL]     } [EOL]     return max; [EOL] }
public static float max(final float[] array) { [EOL]     validateArray(array); [EOL]     float max = array[0]; [EOL]     for (int j = 1; j < array.length; j++) { [EOL]         if (Float.isNaN(array[j])) { [EOL]             return Float.NaN; [EOL]         } [EOL]         if (array[j] > max) { [EOL]             max = array[j]; [EOL]         } [EOL]     } [EOL]     return max; [EOL] }
public static float max(final float[] array) { [EOL]     validateArray(array); [EOL]     float max = array[0]; [EOL]     for (int j = 1; j < array.length; j++) { [EOL]         if (Float.isNaN(array[j])) { [EOL]             return Float.NaN; [EOL]         } [EOL]         if (array[j] > max) { [EOL]             max = array[j]; [EOL]         } [EOL]     } [EOL]     return max; [EOL] }
private static void validateArray(final Object array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } else if (Array.getLength(array) == 0) { [EOL]         throw new IllegalArgumentException("Array cannot be empty."); [EOL]     } [EOL] }
private static void validateArray(final Object array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } else if (Array.getLength(array) == 0) { [EOL]         throw new IllegalArgumentException("Array cannot be empty."); [EOL]     } [EOL] }
private static void validateArray(final Object array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } else if (Array.getLength(array) == 0) { [EOL]         throw new IllegalArgumentException("Array cannot be empty."); [EOL]     } [EOL] }
public static short min(short a, final short b, final short c) { [EOL]     if (b < a) { [EOL]         a = b; [EOL]     } [EOL]     if (c < a) { [EOL]         a = c; [EOL]     } [EOL]     return a; [EOL] }
public static double max(final double a, final double b, final double c) { [EOL]     return Math.max(Math.max(a, b), c); [EOL] }
public static double max(final double a, final double b, final double c) { [EOL]     return Math.max(Math.max(a, b), c); [EOL] }
public static double max(final double a, final double b, final double c) { [EOL]     return Math.max(Math.max(a, b), c); [EOL] }
public static double max(final double a, final double b, final double c) { [EOL]     return Math.max(Math.max(a, b), c); [EOL] }
public ConcurrentException(final Throwable cause) { [EOL]     super(ConcurrentUtils.checkedException(cause)); [EOL] }
public ConcurrentException(final Throwable cause) { [EOL]     super(ConcurrentUtils.checkedException(cause)); [EOL] }
public ConcurrentException(final String msg, final Throwable cause) { [EOL]     super(msg, ConcurrentUtils.checkedException(cause)); [EOL] }
public ConcurrentException(final String msg, final Throwable cause) { [EOL]     super(msg, ConcurrentUtils.checkedException(cause)); [EOL] }
@Override [EOL] public final void applyPattern(final String pattern) { [EOL]     if (registry == null) { [EOL]         super.applyPattern(pattern); [EOL]         toPattern = super.toPattern(); [EOL]         return; [EOL]     } [EOL]     final ArrayList<Format> foundFormats = new ArrayList<Format>(); [EOL]     final ArrayList<String> foundDescriptions = new ArrayList<String>(); [EOL]     final StringBuilder stripCustom = new StringBuilder(pattern.length()); [EOL]     final ParsePosition pos = new ParsePosition(0); [EOL]     final char[] c = pattern.toCharArray(); [EOL]     int fmtCount = 0; [EOL]     while (pos.getIndex() < pattern.length()) { [EOL]         switch(c[pos.getIndex()]) { [EOL]             case QUOTE: [EOL]                 appendQuotedString(pattern, pos, stripCustom, true); [EOL]                 break; [EOL]             case START_FE: [EOL]                 fmtCount++; [EOL]                 seekNonWs(pattern, pos); [EOL]                 final int start = pos.getIndex(); [EOL]                 final int index = readArgumentIndex(pattern, next(pos)); [EOL]                 stripCustom.append(START_FE).append(index); [EOL]                 seekNonWs(pattern, pos); [EOL]                 Format format = null; [EOL]                 String formatDescription = null; [EOL]                 if (c[pos.getIndex()] == START_FMT) { [EOL]                     formatDescription = parseFormatDescription(pattern, next(pos)); [EOL]                     format = getFormat(formatDescription); [EOL]                     if (format == null) { [EOL]                         stripCustom.append(START_FMT).append(formatDescription); [EOL]                     } [EOL]                 } [EOL]                 foundFormats.add(format); [EOL]                 foundDescriptions.add(format == null ? null : formatDescription); [EOL]                 Validate.isTrue(foundFormats.size() == fmtCount); [EOL]                 Validate.isTrue(foundDescriptions.size() == fmtCount); [EOL]                 if (c[pos.getIndex()] != END_FE) { [EOL]                     throw new IllegalArgumentException("Unreadable format element at position " + start); [EOL]                 } [EOL]             default: [EOL]                 stripCustom.append(c[pos.getIndex()]); [EOL]                 next(pos); [EOL]         } [EOL]     } [EOL]     super.applyPattern(stripCustom.toString()); [EOL]     toPattern = insertFormats(super.toPattern(), foundDescriptions); [EOL]     if (containsElements(foundFormats)) { [EOL]         final Format[] origFormats = getFormats(); [EOL]         int i = 0; [EOL]         for (final Iterator<Format> it = foundFormats.iterator(); it.hasNext(); i++) { [EOL]             final Format f = it.next(); [EOL]             if (f != null) { [EOL]                 origFormats[i] = f; [EOL]             } [EOL]         } [EOL]         super.setFormats(origFormats); [EOL]     } [EOL] } public ExtendedMessageFormat(final String pattern); public ExtendedMessageFormat(final String pattern, final Locale locale); public ExtendedMessageFormat(final String pattern, final Map<String, ? extends FormatFactory> registry); public ExtendedMessageFormat(final String pattern, final Locale locale, final Map<String, ? extends FormatFactory> registry); public String toPattern(); public final void applyPattern(final String pattern); public void setFormat(final int formatElementIndex, final Format newFormat); public void setFormatByArgumentIndex(final int argumentIndex, final Format newFormat); public void setFormats(final Format[] newFormats); public void setFormatsByArgumentIndex(final Format[] newFormats); public boolean equals(final Object obj); public int hashCode(); private Format getFormat(final String desc); private int readArgumentIndex(final String pattern, final ParsePosition pos); private String parseFormatDescription(final String pattern, final ParsePosition pos); private String insertFormats(final String pattern, final ArrayList<String> customPatterns); private void seekNonWs(final String pattern, final ParsePosition pos); private ParsePosition next(final ParsePosition pos); private StringBuilder appendQuotedString(final String pattern, final ParsePosition pos, final StringBuilder appendTo, final boolean escapingOn); private void getQuotedString(final String pattern, final ParsePosition pos, final boolean escapingOn); private boolean containsElements(final Collection<?> coll); long serialVersionUID=Optional[-2362048321261811743L]; int HASH_SEED=Optional[31]; String DUMMY_PATTERN=Optional[""]; String ESCAPED_QUOTE=Optional["''"]; char START_FMT=Optional[',']; char END_FE=Optional['}
@Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj == this) { [EOL]         return true; [EOL]     } [EOL]     if (obj == null) { [EOL]         return false; [EOL]     } [EOL]     if (!super.equals(obj)) { [EOL]         return false; [EOL]     } [EOL]     if (ObjectUtils.notEqual(getClass(), obj.getClass())) { [EOL]         return false; [EOL]     } [EOL]     final ExtendedMessageFormat rhs = (ExtendedMessageFormat) obj; [EOL]     if (ObjectUtils.notEqual(toPattern, rhs.toPattern)) { [EOL]         return false; [EOL]     } [EOL]     if (ObjectUtils.notEqual(registry, rhs.registry)) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] } public ExtendedMessageFormat(final String pattern); public ExtendedMessageFormat(final String pattern, final Locale locale); public ExtendedMessageFormat(final String pattern, final Map<String, ? extends FormatFactory> registry); public ExtendedMessageFormat(final String pattern, final Locale locale, final Map<String, ? extends FormatFactory> registry); public String toPattern(); public final void applyPattern(final String pattern); public void setFormat(final int formatElementIndex, final Format newFormat); public void setFormatByArgumentIndex(final int argumentIndex, final Format newFormat); public void setFormats(final Format[] newFormats); public void setFormatsByArgumentIndex(final Format[] newFormats); public boolean equals(final Object obj); public int hashCode(); private Format getFormat(final String desc); private int readArgumentIndex(final String pattern, final ParsePosition pos); private String parseFormatDescription(final String pattern, final ParsePosition pos); private String insertFormats(final String pattern, final ArrayList<String> customPatterns); private void seekNonWs(final String pattern, final ParsePosition pos); private ParsePosition next(final ParsePosition pos); private StringBuilder appendQuotedString(final String pattern, final ParsePosition pos, final StringBuilder appendTo, final boolean escapingOn); private void getQuotedString(final String pattern, final ParsePosition pos, final boolean escapingOn); private boolean containsElements(final Collection<?> coll); long serialVersionUID=Optional[-2362048321261811743L]; int HASH_SEED=Optional[31]; String DUMMY_PATTERN=Optional[""]; String ESCAPED_QUOTE=Optional["''"]; char START_FMT=Optional[',']; char END_FE=Optional['}
@Override [EOL] public int hashCode() { [EOL]     int result = super.hashCode(); [EOL]     result = HASH_SEED * result + ObjectUtils.hashCode(registry); [EOL]     result = HASH_SEED * result + ObjectUtils.hashCode(toPattern); [EOL]     return result; [EOL] } public ExtendedMessageFormat(final String pattern); public ExtendedMessageFormat(final String pattern, final Locale locale); public ExtendedMessageFormat(final String pattern, final Map<String, ? extends FormatFactory> registry); public ExtendedMessageFormat(final String pattern, final Locale locale, final Map<String, ? extends FormatFactory> registry); public String toPattern(); public final void applyPattern(final String pattern); public void setFormat(final int formatElementIndex, final Format newFormat); public void setFormatByArgumentIndex(final int argumentIndex, final Format newFormat); public void setFormats(final Format[] newFormats); public void setFormatsByArgumentIndex(final Format[] newFormats); public boolean equals(final Object obj); public int hashCode(); private Format getFormat(final String desc); private int readArgumentIndex(final String pattern, final ParsePosition pos); private String parseFormatDescription(final String pattern, final ParsePosition pos); private String insertFormats(final String pattern, final ArrayList<String> customPatterns); private void seekNonWs(final String pattern, final ParsePosition pos); private ParsePosition next(final ParsePosition pos); private StringBuilder appendQuotedString(final String pattern, final ParsePosition pos, final StringBuilder appendTo, final boolean escapingOn); private void getQuotedString(final String pattern, final ParsePosition pos, final boolean escapingOn); private boolean containsElements(final Collection<?> coll); long serialVersionUID=Optional[-2362048321261811743L]; int HASH_SEED=Optional[31]; String DUMMY_PATTERN=Optional[""]; String ESCAPED_QUOTE=Optional["''"]; char START_FMT=Optional[',']; char END_FE=Optional['}
@Override [EOL] public int hashCode() { [EOL]     int result = super.hashCode(); [EOL]     result = HASH_SEED * result + ObjectUtils.hashCode(registry); [EOL]     result = HASH_SEED * result + ObjectUtils.hashCode(toPattern); [EOL]     return result; [EOL] } public ExtendedMessageFormat(final String pattern); public ExtendedMessageFormat(final String pattern, final Locale locale); public ExtendedMessageFormat(final String pattern, final Map<String, ? extends FormatFactory> registry); public ExtendedMessageFormat(final String pattern, final Locale locale, final Map<String, ? extends FormatFactory> registry); public String toPattern(); public final void applyPattern(final String pattern); public void setFormat(final int formatElementIndex, final Format newFormat); public void setFormatByArgumentIndex(final int argumentIndex, final Format newFormat); public void setFormats(final Format[] newFormats); public void setFormatsByArgumentIndex(final Format[] newFormats); public boolean equals(final Object obj); public int hashCode(); private Format getFormat(final String desc); private int readArgumentIndex(final String pattern, final ParsePosition pos); private String parseFormatDescription(final String pattern, final ParsePosition pos); private String insertFormats(final String pattern, final ArrayList<String> customPatterns); private void seekNonWs(final String pattern, final ParsePosition pos); private ParsePosition next(final ParsePosition pos); private StringBuilder appendQuotedString(final String pattern, final ParsePosition pos, final StringBuilder appendTo, final boolean escapingOn); private void getQuotedString(final String pattern, final ParsePosition pos, final boolean escapingOn); private boolean containsElements(final Collection<?> coll); long serialVersionUID=Optional[-2362048321261811743L]; int HASH_SEED=Optional[31]; String DUMMY_PATTERN=Optional[""]; String ESCAPED_QUOTE=Optional["''"]; char START_FMT=Optional[',']; char END_FE=Optional['}
private Format getFormat(final String desc) { [EOL]     if (registry != null) { [EOL]         String name = desc; [EOL]         String args = null; [EOL]         final int i = desc.indexOf(START_FMT); [EOL]         if (i > 0) { [EOL]             name = desc.substring(0, i).trim(); [EOL]             args = desc.substring(i + 1).trim(); [EOL]         } [EOL]         final FormatFactory factory = registry.get(name); [EOL]         if (factory != null) { [EOL]             return factory.getFormat(name, args, getLocale()); [EOL]         } [EOL]     } [EOL]     return null; [EOL] } public ExtendedMessageFormat(final String pattern); public ExtendedMessageFormat(final String pattern, final Locale locale); public ExtendedMessageFormat(final String pattern, final Map<String, ? extends FormatFactory> registry); public ExtendedMessageFormat(final String pattern, final Locale locale, final Map<String, ? extends FormatFactory> registry); public String toPattern(); public final void applyPattern(final String pattern); public void setFormat(final int formatElementIndex, final Format newFormat); public void setFormatByArgumentIndex(final int argumentIndex, final Format newFormat); public void setFormats(final Format[] newFormats); public void setFormatsByArgumentIndex(final Format[] newFormats); public boolean equals(final Object obj); public int hashCode(); private Format getFormat(final String desc); private int readArgumentIndex(final String pattern, final ParsePosition pos); private String parseFormatDescription(final String pattern, final ParsePosition pos); private String insertFormats(final String pattern, final ArrayList<String> customPatterns); private void seekNonWs(final String pattern, final ParsePosition pos); private ParsePosition next(final ParsePosition pos); private StringBuilder appendQuotedString(final String pattern, final ParsePosition pos, final StringBuilder appendTo, final boolean escapingOn); private void getQuotedString(final String pattern, final ParsePosition pos, final boolean escapingOn); private boolean containsElements(final Collection<?> coll); long serialVersionUID=Optional[-2362048321261811743L]; int HASH_SEED=Optional[31]; String DUMMY_PATTERN=Optional[""]; String ESCAPED_QUOTE=Optional["''"]; char START_FMT=Optional[',']; char END_FE=Optional['}
private int readArgumentIndex(final String pattern, final ParsePosition pos) { [EOL]     final int start = pos.getIndex(); [EOL]     seekNonWs(pattern, pos); [EOL]     final StringBuilder result = new StringBuilder(); [EOL]     boolean error = false; [EOL]     for (; !error && pos.getIndex() < pattern.length(); next(pos)) { [EOL]         char c = pattern.charAt(pos.getIndex()); [EOL]         if (Character.isWhitespace(c)) { [EOL]             seekNonWs(pattern, pos); [EOL]             c = pattern.charAt(pos.getIndex()); [EOL]             if (c != START_FMT && c != END_FE) { [EOL]                 error = true; [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         if ((c == START_FMT || c == END_FE) && result.length() > 0) { [EOL]             try { [EOL]                 return Integer.parseInt(result.toString()); [EOL]             } catch (final NumberFormatException e) { [EOL]             } [EOL]         } [EOL]         error = !Character.isDigit(c); [EOL]         result.append(c); [EOL]     } [EOL]     if (error) { [EOL]         throw new IllegalArgumentException("Invalid format argument index at position " + start + ": " + pattern.substring(start, pos.getIndex())); [EOL]     } [EOL]     throw new IllegalArgumentException("Unterminated format element at position " + start); [EOL] } public ExtendedMessageFormat(final String pattern); public ExtendedMessageFormat(final String pattern, final Locale locale); public ExtendedMessageFormat(final String pattern, final Map<String, ? extends FormatFactory> registry); public ExtendedMessageFormat(final String pattern, final Locale locale, final Map<String, ? extends FormatFactory> registry); public String toPattern(); public final void applyPattern(final String pattern); public void setFormat(final int formatElementIndex, final Format newFormat); public void setFormatByArgumentIndex(final int argumentIndex, final Format newFormat); public void setFormats(final Format[] newFormats); public void setFormatsByArgumentIndex(final Format[] newFormats); public boolean equals(final Object obj); public int hashCode(); private Format getFormat(final String desc); private int readArgumentIndex(final String pattern, final ParsePosition pos); private String parseFormatDescription(final String pattern, final ParsePosition pos); private String insertFormats(final String pattern, final ArrayList<String> customPatterns); private void seekNonWs(final String pattern, final ParsePosition pos); private ParsePosition next(final ParsePosition pos); private StringBuilder appendQuotedString(final String pattern, final ParsePosition pos, final StringBuilder appendTo, final boolean escapingOn); private void getQuotedString(final String pattern, final ParsePosition pos, final boolean escapingOn); private boolean containsElements(final Collection<?> coll); long serialVersionUID=Optional[-2362048321261811743L]; int HASH_SEED=Optional[31]; String DUMMY_PATTERN=Optional[""]; String ESCAPED_QUOTE=Optional["''"]; char START_FMT=Optional[',']; char END_FE=Optional['}
private String parseFormatDescription(final String pattern, final ParsePosition pos) { [EOL]     final int start = pos.getIndex(); [EOL]     seekNonWs(pattern, pos); [EOL]     final int text = pos.getIndex(); [EOL]     int depth = 1; [EOL]     for (; pos.getIndex() < pattern.length(); next(pos)) { [EOL]         switch(pattern.charAt(pos.getIndex())) { [EOL]             case START_FE: [EOL]                 depth++; [EOL]                 break; [EOL]             case END_FE: [EOL]                 depth--; [EOL]                 if (depth == 0) { [EOL]                     return pattern.substring(text, pos.getIndex()); [EOL]                 } [EOL]                 break; [EOL]             case QUOTE: [EOL]                 getQuotedString(pattern, pos, false); [EOL]                 break; [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("Unterminated format element at position " + start); [EOL] } public ExtendedMessageFormat(final String pattern); public ExtendedMessageFormat(final String pattern, final Locale locale); public ExtendedMessageFormat(final String pattern, final Map<String, ? extends FormatFactory> registry); public ExtendedMessageFormat(final String pattern, final Locale locale, final Map<String, ? extends FormatFactory> registry); public String toPattern(); public final void applyPattern(final String pattern); public void setFormat(final int formatElementIndex, final Format newFormat); public void setFormatByArgumentIndex(final int argumentIndex, final Format newFormat); public void setFormats(final Format[] newFormats); public void setFormatsByArgumentIndex(final Format[] newFormats); public boolean equals(final Object obj); public int hashCode(); private Format getFormat(final String desc); private int readArgumentIndex(final String pattern, final ParsePosition pos); private String parseFormatDescription(final String pattern, final ParsePosition pos); private String insertFormats(final String pattern, final ArrayList<String> customPatterns); private void seekNonWs(final String pattern, final ParsePosition pos); private ParsePosition next(final ParsePosition pos); private StringBuilder appendQuotedString(final String pattern, final ParsePosition pos, final StringBuilder appendTo, final boolean escapingOn); private void getQuotedString(final String pattern, final ParsePosition pos, final boolean escapingOn); private boolean containsElements(final Collection<?> coll); long serialVersionUID=Optional[-2362048321261811743L]; int HASH_SEED=Optional[31]; String DUMMY_PATTERN=Optional[""]; String ESCAPED_QUOTE=Optional["''"]; char START_FMT=Optional[',']; char END_FE=Optional['}
private String insertFormats(final String pattern, final ArrayList<String> customPatterns) { [EOL]     if (!containsElements(customPatterns)) { [EOL]         return pattern; [EOL]     } [EOL]     final StringBuilder sb = new StringBuilder(pattern.length() * 2); [EOL]     final ParsePosition pos = new ParsePosition(0); [EOL]     int fe = -1; [EOL]     int depth = 0; [EOL]     while (pos.getIndex() < pattern.length()) { [EOL]         final char c = pattern.charAt(pos.getIndex()); [EOL]         switch(c) { [EOL]             case QUOTE: [EOL]                 appendQuotedString(pattern, pos, sb, false); [EOL]                 break; [EOL]             case START_FE: [EOL]                 depth++; [EOL]                 if (depth == 1) { [EOL]                     fe++; [EOL]                     sb.append(START_FE).append(readArgumentIndex(pattern, next(pos))); [EOL]                     final String customPattern = customPatterns.get(fe); [EOL]                     if (customPattern != null) { [EOL]                         sb.append(START_FMT).append(customPattern); [EOL]                     } [EOL]                 } [EOL]                 break; [EOL]             case END_FE: [EOL]                 depth--; [EOL]             default: [EOL]                 sb.append(c); [EOL]                 next(pos); [EOL]         } [EOL]     } [EOL]     return sb.toString(); [EOL] } public ExtendedMessageFormat(final String pattern); public ExtendedMessageFormat(final String pattern, final Locale locale); public ExtendedMessageFormat(final String pattern, final Map<String, ? extends FormatFactory> registry); public ExtendedMessageFormat(final String pattern, final Locale locale, final Map<String, ? extends FormatFactory> registry); public String toPattern(); public final void applyPattern(final String pattern); public void setFormat(final int formatElementIndex, final Format newFormat); public void setFormatByArgumentIndex(final int argumentIndex, final Format newFormat); public void setFormats(final Format[] newFormats); public void setFormatsByArgumentIndex(final Format[] newFormats); public boolean equals(final Object obj); public int hashCode(); private Format getFormat(final String desc); private int readArgumentIndex(final String pattern, final ParsePosition pos); private String parseFormatDescription(final String pattern, final ParsePosition pos); private String insertFormats(final String pattern, final ArrayList<String> customPatterns); private void seekNonWs(final String pattern, final ParsePosition pos); private ParsePosition next(final ParsePosition pos); private StringBuilder appendQuotedString(final String pattern, final ParsePosition pos, final StringBuilder appendTo, final boolean escapingOn); private void getQuotedString(final String pattern, final ParsePosition pos, final boolean escapingOn); private boolean containsElements(final Collection<?> coll); long serialVersionUID=Optional[-2362048321261811743L]; int HASH_SEED=Optional[31]; String DUMMY_PATTERN=Optional[""]; String ESCAPED_QUOTE=Optional["''"]; char START_FMT=Optional[',']; char END_FE=Optional['}
private void seekNonWs(final String pattern, final ParsePosition pos) { [EOL]     int len = 0; [EOL]     final char[] buffer = pattern.toCharArray(); [EOL]     do { [EOL]         len = StrMatcher.splitMatcher().isMatch(buffer, pos.getIndex()); [EOL]         pos.setIndex(pos.getIndex() + len); [EOL]     } while (len > 0 && pos.getIndex() < pattern.length()); [EOL] } public ExtendedMessageFormat(final String pattern); public ExtendedMessageFormat(final String pattern, final Locale locale); public ExtendedMessageFormat(final String pattern, final Map<String, ? extends FormatFactory> registry); public ExtendedMessageFormat(final String pattern, final Locale locale, final Map<String, ? extends FormatFactory> registry); public String toPattern(); public final void applyPattern(final String pattern); public void setFormat(final int formatElementIndex, final Format newFormat); public void setFormatByArgumentIndex(final int argumentIndex, final Format newFormat); public void setFormats(final Format[] newFormats); public void setFormatsByArgumentIndex(final Format[] newFormats); public boolean equals(final Object obj); public int hashCode(); private Format getFormat(final String desc); private int readArgumentIndex(final String pattern, final ParsePosition pos); private String parseFormatDescription(final String pattern, final ParsePosition pos); private String insertFormats(final String pattern, final ArrayList<String> customPatterns); private void seekNonWs(final String pattern, final ParsePosition pos); private ParsePosition next(final ParsePosition pos); private StringBuilder appendQuotedString(final String pattern, final ParsePosition pos, final StringBuilder appendTo, final boolean escapingOn); private void getQuotedString(final String pattern, final ParsePosition pos, final boolean escapingOn); private boolean containsElements(final Collection<?> coll); long serialVersionUID=Optional[-2362048321261811743L]; int HASH_SEED=Optional[31]; String DUMMY_PATTERN=Optional[""]; String ESCAPED_QUOTE=Optional["''"]; char START_FMT=Optional[',']; char END_FE=Optional['}
private ParsePosition next(final ParsePosition pos) { [EOL]     pos.setIndex(pos.getIndex() + 1); [EOL]     return pos; [EOL] } public ExtendedMessageFormat(final String pattern); public ExtendedMessageFormat(final String pattern, final Locale locale); public ExtendedMessageFormat(final String pattern, final Map<String, ? extends FormatFactory> registry); public ExtendedMessageFormat(final String pattern, final Locale locale, final Map<String, ? extends FormatFactory> registry); public String toPattern(); public final void applyPattern(final String pattern); public void setFormat(final int formatElementIndex, final Format newFormat); public void setFormatByArgumentIndex(final int argumentIndex, final Format newFormat); public void setFormats(final Format[] newFormats); public void setFormatsByArgumentIndex(final Format[] newFormats); public boolean equals(final Object obj); public int hashCode(); private Format getFormat(final String desc); private int readArgumentIndex(final String pattern, final ParsePosition pos); private String parseFormatDescription(final String pattern, final ParsePosition pos); private String insertFormats(final String pattern, final ArrayList<String> customPatterns); private void seekNonWs(final String pattern, final ParsePosition pos); private ParsePosition next(final ParsePosition pos); private StringBuilder appendQuotedString(final String pattern, final ParsePosition pos, final StringBuilder appendTo, final boolean escapingOn); private void getQuotedString(final String pattern, final ParsePosition pos, final boolean escapingOn); private boolean containsElements(final Collection<?> coll); long serialVersionUID=Optional[-2362048321261811743L]; int HASH_SEED=Optional[31]; String DUMMY_PATTERN=Optional[""]; String ESCAPED_QUOTE=Optional["''"]; char START_FMT=Optional[',']; char END_FE=Optional['}
private ParsePosition next(final ParsePosition pos) { [EOL]     pos.setIndex(pos.getIndex() + 1); [EOL]     return pos; [EOL] } public ExtendedMessageFormat(final String pattern); public ExtendedMessageFormat(final String pattern, final Locale locale); public ExtendedMessageFormat(final String pattern, final Map<String, ? extends FormatFactory> registry); public ExtendedMessageFormat(final String pattern, final Locale locale, final Map<String, ? extends FormatFactory> registry); public String toPattern(); public final void applyPattern(final String pattern); public void setFormat(final int formatElementIndex, final Format newFormat); public void setFormatByArgumentIndex(final int argumentIndex, final Format newFormat); public void setFormats(final Format[] newFormats); public void setFormatsByArgumentIndex(final Format[] newFormats); public boolean equals(final Object obj); public int hashCode(); private Format getFormat(final String desc); private int readArgumentIndex(final String pattern, final ParsePosition pos); private String parseFormatDescription(final String pattern, final ParsePosition pos); private String insertFormats(final String pattern, final ArrayList<String> customPatterns); private void seekNonWs(final String pattern, final ParsePosition pos); private ParsePosition next(final ParsePosition pos); private StringBuilder appendQuotedString(final String pattern, final ParsePosition pos, final StringBuilder appendTo, final boolean escapingOn); private void getQuotedString(final String pattern, final ParsePosition pos, final boolean escapingOn); private boolean containsElements(final Collection<?> coll); long serialVersionUID=Optional[-2362048321261811743L]; int HASH_SEED=Optional[31]; String DUMMY_PATTERN=Optional[""]; String ESCAPED_QUOTE=Optional["''"]; char START_FMT=Optional[',']; char END_FE=Optional['}
private boolean containsElements(final Collection<?> coll) { [EOL]     if (coll == null || coll.isEmpty()) { [EOL]         return false; [EOL]     } [EOL]     for (final Object name : coll) { [EOL]         if (name != null) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] } public ExtendedMessageFormat(final String pattern); public ExtendedMessageFormat(final String pattern, final Locale locale); public ExtendedMessageFormat(final String pattern, final Map<String, ? extends FormatFactory> registry); public ExtendedMessageFormat(final String pattern, final Locale locale, final Map<String, ? extends FormatFactory> registry); public String toPattern(); public final void applyPattern(final String pattern); public void setFormat(final int formatElementIndex, final Format newFormat); public void setFormatByArgumentIndex(final int argumentIndex, final Format newFormat); public void setFormats(final Format[] newFormats); public void setFormatsByArgumentIndex(final Format[] newFormats); public boolean equals(final Object obj); public int hashCode(); private Format getFormat(final String desc); private int readArgumentIndex(final String pattern, final ParsePosition pos); private String parseFormatDescription(final String pattern, final ParsePosition pos); private String insertFormats(final String pattern, final ArrayList<String> customPatterns); private void seekNonWs(final String pattern, final ParsePosition pos); private ParsePosition next(final ParsePosition pos); private StringBuilder appendQuotedString(final String pattern, final ParsePosition pos, final StringBuilder appendTo, final boolean escapingOn); private void getQuotedString(final String pattern, final ParsePosition pos, final boolean escapingOn); private boolean containsElements(final Collection<?> coll); long serialVersionUID=Optional[-2362048321261811743L]; int HASH_SEED=Optional[31]; String DUMMY_PATTERN=Optional[""]; String ESCAPED_QUOTE=Optional["''"]; char START_FMT=Optional[',']; char END_FE=Optional['}
@Override [EOL] public final L getKey() { [EOL]     return getLeft(); [EOL] }
@Override [EOL] public final L getKey() { [EOL]     return getLeft(); [EOL] }
@Override [EOL] public R getValue() { [EOL]     return getRight(); [EOL] }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj == this) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof Map.Entry<?, ?>) { [EOL]         final Map.Entry<?, ?> other = (Map.Entry<?, ?>) obj; [EOL]         return ObjectUtils.equals(getKey(), other.getKey()) && ObjectUtils.equals(getValue(), other.getValue()); [EOL]     } [EOL]     return false; [EOL] }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj == this) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof Map.Entry<?, ?>) { [EOL]         final Map.Entry<?, ?> other = (Map.Entry<?, ?>) obj; [EOL]         return ObjectUtils.equals(getKey(), other.getKey()) && ObjectUtils.equals(getValue(), other.getValue()); [EOL]     } [EOL]     return false; [EOL] }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj == this) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof Map.Entry<?, ?>) { [EOL]         final Map.Entry<?, ?> other = (Map.Entry<?, ?>) obj; [EOL]         return ObjectUtils.equals(getKey(), other.getKey()) && ObjectUtils.equals(getValue(), other.getValue()); [EOL]     } [EOL]     return false; [EOL] }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj == this) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof Map.Entry<?, ?>) { [EOL]         final Map.Entry<?, ?> other = (Map.Entry<?, ?>) obj; [EOL]         return ObjectUtils.equals(getKey(), other.getKey()) && ObjectUtils.equals(getValue(), other.getValue()); [EOL]     } [EOL]     return false; [EOL] }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj == this) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof Map.Entry<?, ?>) { [EOL]         final Map.Entry<?, ?> other = (Map.Entry<?, ?>) obj; [EOL]         return ObjectUtils.equals(getKey(), other.getKey()) && ObjectUtils.equals(getValue(), other.getValue()); [EOL]     } [EOL]     return false; [EOL] }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj == this) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof Map.Entry<?, ?>) { [EOL]         final Map.Entry<?, ?> other = (Map.Entry<?, ?>) obj; [EOL]         return ObjectUtils.equals(getKey(), other.getKey()) && ObjectUtils.equals(getValue(), other.getValue()); [EOL]     } [EOL]     return false; [EOL] }
@Override [EOL] public int hashCode() { [EOL]     return (getKey() == null ? 0 : getKey().hashCode()) ^ (getValue() == null ? 0 : getValue().hashCode()); [EOL] }
public ConstantInitializer(final T obj) { [EOL]     object = obj; [EOL] }
public ConstantInitializer(final T obj) { [EOL]     object = obj; [EOL] }
public final T getObject() { [EOL]     return object; [EOL] }
@Override [EOL] public int hashCode() { [EOL]     return getObject() != null ? getObject().hashCode() : 0; [EOL] }
@Override [EOL] public int hashCode() { [EOL]     return getObject() != null ? getObject().hashCode() : 0; [EOL] }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (!(obj instanceof ConstantInitializer<?>)) { [EOL]         return false; [EOL]     } [EOL]     final ConstantInitializer<?> c = (ConstantInitializer<?>) obj; [EOL]     return ObjectUtils.equals(getObject(), c.getObject()); [EOL] }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (!(obj instanceof ConstantInitializer<?>)) { [EOL]         return false; [EOL]     } [EOL]     final ConstantInitializer<?> c = (ConstantInitializer<?>) obj; [EOL]     return ObjectUtils.equals(getObject(), c.getObject()); [EOL] }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (!(obj instanceof ConstantInitializer<?>)) { [EOL]         return false; [EOL]     } [EOL]     final ConstantInitializer<?> c = (ConstantInitializer<?>) obj; [EOL]     return ObjectUtils.equals(getObject(), c.getObject()); [EOL] }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (!(obj instanceof ConstantInitializer<?>)) { [EOL]         return false; [EOL]     } [EOL]     final ConstantInitializer<?> c = (ConstantInitializer<?>) obj; [EOL]     return ObjectUtils.equals(getObject(), c.getObject()); [EOL] }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (!(obj instanceof ConstantInitializer<?>)) { [EOL]         return false; [EOL]     } [EOL]     final ConstantInitializer<?> c = (ConstantInitializer<?>) obj; [EOL]     return ObjectUtils.equals(getObject(), c.getObject()); [EOL] }
@Override [EOL] public String toString() { [EOL]     return String.format(FMT_TO_STRING, Integer.valueOf(System.identityHashCode(this)), String.valueOf(getObject())); [EOL] }
@Override [EOL] public String toString() { [EOL]     return String.format(FMT_TO_STRING, Integer.valueOf(System.identityHashCode(this)), String.valueOf(getObject())); [EOL] }
public SerializationException(final Throwable cause) { [EOL]     super(cause); [EOL] }
private BasicThreadFactory(final Builder builder) { [EOL]     if (builder.wrappedFactory == null) { [EOL]         wrappedFactory = Executors.defaultThreadFactory(); [EOL]     } else { [EOL]         wrappedFactory = builder.wrappedFactory; [EOL]     } [EOL]     namingPattern = builder.namingPattern; [EOL]     priority = builder.priority; [EOL]     daemonFlag = builder.daemonFlag; [EOL]     uncaughtExceptionHandler = builder.exceptionHandler; [EOL]     threadCounter = new AtomicLong(); [EOL] }
private BasicThreadFactory(final Builder builder) { [EOL]     if (builder.wrappedFactory == null) { [EOL]         wrappedFactory = Executors.defaultThreadFactory(); [EOL]     } else { [EOL]         wrappedFactory = builder.wrappedFactory; [EOL]     } [EOL]     namingPattern = builder.namingPattern; [EOL]     priority = builder.priority; [EOL]     daemonFlag = builder.daemonFlag; [EOL]     uncaughtExceptionHandler = builder.exceptionHandler; [EOL]     threadCounter = new AtomicLong(); [EOL] }
private BasicThreadFactory(final Builder builder) { [EOL]     if (builder.wrappedFactory == null) { [EOL]         wrappedFactory = Executors.defaultThreadFactory(); [EOL]     } else { [EOL]         wrappedFactory = builder.wrappedFactory; [EOL]     } [EOL]     namingPattern = builder.namingPattern; [EOL]     priority = builder.priority; [EOL]     daemonFlag = builder.daemonFlag; [EOL]     uncaughtExceptionHandler = builder.exceptionHandler; [EOL]     threadCounter = new AtomicLong(); [EOL] }
private BasicThreadFactory(final Builder builder) { [EOL]     if (builder.wrappedFactory == null) { [EOL]         wrappedFactory = Executors.defaultThreadFactory(); [EOL]     } else { [EOL]         wrappedFactory = builder.wrappedFactory; [EOL]     } [EOL]     namingPattern = builder.namingPattern; [EOL]     priority = builder.priority; [EOL]     daemonFlag = builder.daemonFlag; [EOL]     uncaughtExceptionHandler = builder.exceptionHandler; [EOL]     threadCounter = new AtomicLong(); [EOL] }
private BasicThreadFactory(final Builder builder) { [EOL]     if (builder.wrappedFactory == null) { [EOL]         wrappedFactory = Executors.defaultThreadFactory(); [EOL]     } else { [EOL]         wrappedFactory = builder.wrappedFactory; [EOL]     } [EOL]     namingPattern = builder.namingPattern; [EOL]     priority = builder.priority; [EOL]     daemonFlag = builder.daemonFlag; [EOL]     uncaughtExceptionHandler = builder.exceptionHandler; [EOL]     threadCounter = new AtomicLong(); [EOL] }
private BasicThreadFactory(final Builder builder) { [EOL]     if (builder.wrappedFactory == null) { [EOL]         wrappedFactory = Executors.defaultThreadFactory(); [EOL]     } else { [EOL]         wrappedFactory = builder.wrappedFactory; [EOL]     } [EOL]     namingPattern = builder.namingPattern; [EOL]     priority = builder.priority; [EOL]     daemonFlag = builder.daemonFlag; [EOL]     uncaughtExceptionHandler = builder.exceptionHandler; [EOL]     threadCounter = new AtomicLong(); [EOL] }
private void initializeThread(final Thread t) { [EOL]     if (getNamingPattern() != null) { [EOL]         final Long count = Long.valueOf(threadCounter.incrementAndGet()); [EOL]         t.setName(String.format(getNamingPattern(), count)); [EOL]     } [EOL]     if (getUncaughtExceptionHandler() != null) { [EOL]         t.setUncaughtExceptionHandler(getUncaughtExceptionHandler()); [EOL]     } [EOL]     if (getPriority() != null) { [EOL]         t.setPriority(getPriority().intValue()); [EOL]     } [EOL]     if (getDaemonFlag() != null) { [EOL]         t.setDaemon(getDaemonFlag().booleanValue()); [EOL]     } [EOL] }
private void initializeThread(final Thread t) { [EOL]     if (getNamingPattern() != null) { [EOL]         final Long count = Long.valueOf(threadCounter.incrementAndGet()); [EOL]         t.setName(String.format(getNamingPattern(), count)); [EOL]     } [EOL]     if (getUncaughtExceptionHandler() != null) { [EOL]         t.setUncaughtExceptionHandler(getUncaughtExceptionHandler()); [EOL]     } [EOL]     if (getPriority() != null) { [EOL]         t.setPriority(getPriority().intValue()); [EOL]     } [EOL]     if (getDaemonFlag() != null) { [EOL]         t.setDaemon(getDaemonFlag().booleanValue()); [EOL]     } [EOL] }
private void initializeThread(final Thread t) { [EOL]     if (getNamingPattern() != null) { [EOL]         final Long count = Long.valueOf(threadCounter.incrementAndGet()); [EOL]         t.setName(String.format(getNamingPattern(), count)); [EOL]     } [EOL]     if (getUncaughtExceptionHandler() != null) { [EOL]         t.setUncaughtExceptionHandler(getUncaughtExceptionHandler()); [EOL]     } [EOL]     if (getPriority() != null) { [EOL]         t.setPriority(getPriority().intValue()); [EOL]     } [EOL]     if (getDaemonFlag() != null) { [EOL]         t.setDaemon(getDaemonFlag().booleanValue()); [EOL]     } [EOL] }
private void initializeThread(final Thread t) { [EOL]     if (getNamingPattern() != null) { [EOL]         final Long count = Long.valueOf(threadCounter.incrementAndGet()); [EOL]         t.setName(String.format(getNamingPattern(), count)); [EOL]     } [EOL]     if (getUncaughtExceptionHandler() != null) { [EOL]         t.setUncaughtExceptionHandler(getUncaughtExceptionHandler()); [EOL]     } [EOL]     if (getPriority() != null) { [EOL]         t.setPriority(getPriority().intValue()); [EOL]     } [EOL]     if (getDaemonFlag() != null) { [EOL]         t.setDaemon(getDaemonFlag().booleanValue()); [EOL]     } [EOL] }
private void initializeThread(final Thread t) { [EOL]     if (getNamingPattern() != null) { [EOL]         final Long count = Long.valueOf(threadCounter.incrementAndGet()); [EOL]         t.setName(String.format(getNamingPattern(), count)); [EOL]     } [EOL]     if (getUncaughtExceptionHandler() != null) { [EOL]         t.setUncaughtExceptionHandler(getUncaughtExceptionHandler()); [EOL]     } [EOL]     if (getPriority() != null) { [EOL]         t.setPriority(getPriority().intValue()); [EOL]     } [EOL]     if (getDaemonFlag() != null) { [EOL]         t.setDaemon(getDaemonFlag().booleanValue()); [EOL]     } [EOL] }
public Builder namingPattern(final String pattern) { [EOL]     if (pattern == null) { [EOL]         throw new NullPointerException("Naming pattern must not be null!"); [EOL]     } [EOL]     namingPattern = pattern; [EOL]     return this; [EOL] }
public Builder priority(final int prio) { [EOL]     priority = Integer.valueOf(prio); [EOL]     return this; [EOL] }
public Builder priority(final int prio) { [EOL]     priority = Integer.valueOf(prio); [EOL]     return this; [EOL] }
public Builder priority(final int prio) { [EOL]     priority = Integer.valueOf(prio); [EOL]     return this; [EOL] }
public TimedSemaphore(final ScheduledExecutorService service, final long timePeriod, final TimeUnit timeUnit, final int limit) { [EOL]     if (timePeriod <= 0) { [EOL]         throw new IllegalArgumentException("Time period must be greater 0!"); [EOL]     } [EOL]     period = timePeriod; [EOL]     unit = timeUnit; [EOL]     if (service != null) { [EOL]         executorService = service; [EOL]         ownExecutor = false; [EOL]     } else { [EOL]         final ScheduledThreadPoolExecutor s = new ScheduledThreadPoolExecutor(THREAD_POOL_SIZE); [EOL]         s.setContinueExistingPeriodicTasksAfterShutdownPolicy(false); [EOL]         s.setExecuteExistingDelayedTasksAfterShutdownPolicy(false); [EOL]         executorService = s; [EOL]         ownExecutor = true; [EOL]     } [EOL]     setLimit(limit); [EOL] }
public TimedSemaphore(final ScheduledExecutorService service, final long timePeriod, final TimeUnit timeUnit, final int limit) { [EOL]     if (timePeriod <= 0) { [EOL]         throw new IllegalArgumentException("Time period must be greater 0!"); [EOL]     } [EOL]     period = timePeriod; [EOL]     unit = timeUnit; [EOL]     if (service != null) { [EOL]         executorService = service; [EOL]         ownExecutor = false; [EOL]     } else { [EOL]         final ScheduledThreadPoolExecutor s = new ScheduledThreadPoolExecutor(THREAD_POOL_SIZE); [EOL]         s.setContinueExistingPeriodicTasksAfterShutdownPolicy(false); [EOL]         s.setExecuteExistingDelayedTasksAfterShutdownPolicy(false); [EOL]         executorService = s; [EOL]         ownExecutor = true; [EOL]     } [EOL]     setLimit(limit); [EOL] }
public TimedSemaphore(final ScheduledExecutorService service, final long timePeriod, final TimeUnit timeUnit, final int limit) { [EOL]     if (timePeriod <= 0) { [EOL]         throw new IllegalArgumentException("Time period must be greater 0!"); [EOL]     } [EOL]     period = timePeriod; [EOL]     unit = timeUnit; [EOL]     if (service != null) { [EOL]         executorService = service; [EOL]         ownExecutor = false; [EOL]     } else { [EOL]         final ScheduledThreadPoolExecutor s = new ScheduledThreadPoolExecutor(THREAD_POOL_SIZE); [EOL]         s.setContinueExistingPeriodicTasksAfterShutdownPolicy(false); [EOL]         s.setExecuteExistingDelayedTasksAfterShutdownPolicy(false); [EOL]         executorService = s; [EOL]         ownExecutor = true; [EOL]     } [EOL]     setLimit(limit); [EOL] }
public synchronized void acquire() throws InterruptedException { [EOL]     if (isShutdown()) { [EOL]         throw new IllegalStateException("TimedSemaphore is shut down!"); [EOL]     } [EOL]     if (task == null) { [EOL]         task = startTimer(); [EOL]     } [EOL]     boolean canPass = false; [EOL]     do { [EOL]         canPass = getLimit() <= NO_LIMIT || acquireCount < getLimit(); [EOL]         if (!canPass) { [EOL]             wait(); [EOL]         } else { [EOL]             acquireCount++; [EOL]         } [EOL]     } while (!canPass); [EOL] }
public synchronized void acquire() throws InterruptedException { [EOL]     if (isShutdown()) { [EOL]         throw new IllegalStateException("TimedSemaphore is shut down!"); [EOL]     } [EOL]     if (task == null) { [EOL]         task = startTimer(); [EOL]     } [EOL]     boolean canPass = false; [EOL]     do { [EOL]         canPass = getLimit() <= NO_LIMIT || acquireCount < getLimit(); [EOL]         if (!canPass) { [EOL]             wait(); [EOL]         } else { [EOL]             acquireCount++; [EOL]         } [EOL]     } while (!canPass); [EOL] }
public synchronized void acquire() throws InterruptedException { [EOL]     if (isShutdown()) { [EOL]         throw new IllegalStateException("TimedSemaphore is shut down!"); [EOL]     } [EOL]     if (task == null) { [EOL]         task = startTimer(); [EOL]     } [EOL]     boolean canPass = false; [EOL]     do { [EOL]         canPass = getLimit() <= NO_LIMIT || acquireCount < getLimit(); [EOL]         if (!canPass) { [EOL]             wait(); [EOL]         } else { [EOL]             acquireCount++; [EOL]         } [EOL]     } while (!canPass); [EOL] }
public synchronized void acquire() throws InterruptedException { [EOL]     if (isShutdown()) { [EOL]         throw new IllegalStateException("TimedSemaphore is shut down!"); [EOL]     } [EOL]     if (task == null) { [EOL]         task = startTimer(); [EOL]     } [EOL]     boolean canPass = false; [EOL]     do { [EOL]         canPass = getLimit() <= NO_LIMIT || acquireCount < getLimit(); [EOL]         if (!canPass) { [EOL]             wait(); [EOL]         } else { [EOL]             acquireCount++; [EOL]         } [EOL]     } while (!canPass); [EOL] }
public synchronized void acquire() throws InterruptedException { [EOL]     if (isShutdown()) { [EOL]         throw new IllegalStateException("TimedSemaphore is shut down!"); [EOL]     } [EOL]     if (task == null) { [EOL]         task = startTimer(); [EOL]     } [EOL]     boolean canPass = false; [EOL]     do { [EOL]         canPass = getLimit() <= NO_LIMIT || acquireCount < getLimit(); [EOL]         if (!canPass) { [EOL]             wait(); [EOL]         } else { [EOL]             acquireCount++; [EOL]         } [EOL]     } while (!canPass); [EOL] }
public ContextedRuntimeException(final String message) { [EOL]     super(message); [EOL]     exceptionContext = new DefaultExceptionContext(); [EOL] }
public ContextedRuntimeException(final Throwable cause) { [EOL]     super(cause); [EOL]     exceptionContext = new DefaultExceptionContext(); [EOL] }
public ContextedRuntimeException(final Throwable cause) { [EOL]     super(cause); [EOL]     exceptionContext = new DefaultExceptionContext(); [EOL] }
@Override [EOL] public ContextedRuntimeException setContextValue(final String label, final Object value) { [EOL]     exceptionContext.setContextValue(label, value); [EOL]     return this; [EOL] }
@Override [EOL] public ContextedRuntimeException setContextValue(final String label, final Object value) { [EOL]     exceptionContext.setContextValue(label, value); [EOL]     return this; [EOL] }
@Override [EOL] public ContextedRuntimeException setContextValue(final String label, final Object value) { [EOL]     exceptionContext.setContextValue(label, value); [EOL]     return this; [EOL] }
@Override [EOL] public List<Object> getContextValues(final String label) { [EOL]     return this.exceptionContext.getContextValues(label); [EOL] }
@Override [EOL] public List<Object> getContextValues(final String label) { [EOL]     return this.exceptionContext.getContextValues(label); [EOL] }
@Override [EOL] public List<Object> getContextValues(final String label) { [EOL]     return this.exceptionContext.getContextValues(label); [EOL] }
@Override [EOL] public Object getFirstContextValue(final String label) { [EOL]     return this.exceptionContext.getFirstContextValue(label); [EOL] }
@Override [EOL] public Object getFirstContextValue(final String label) { [EOL]     return this.exceptionContext.getFirstContextValue(label); [EOL] }
@Override [EOL] public Object getFirstContextValue(final String label) { [EOL]     return this.exceptionContext.getFirstContextValue(label); [EOL] }
public void removeListener(final L listener) { [EOL]     Validate.notNull(listener, "Listener object cannot be null."); [EOL]     listeners.remove(listener); [EOL] }
public void removeListener(final L listener) { [EOL]     Validate.notNull(listener, "Listener object cannot be null."); [EOL]     listeners.remove(listener); [EOL] }
public L[] getListeners() { [EOL]     return listeners.toArray(prototypeArray); [EOL] }
public L[] getListeners() { [EOL]     return listeners.toArray(prototypeArray); [EOL] }
@Override [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL]     if (input.charAt(index) == '\\' && index + 1 < input.length() && input.charAt(index + 1) == 'u') { [EOL]         int i = 2; [EOL]         while (index + i < input.length() && input.charAt(index + i) == 'u') { [EOL]             i++; [EOL]         } [EOL]         if (index + i < input.length() && input.charAt(index + i) == '+') { [EOL]             i++; [EOL]         } [EOL]         if (index + i + 4 <= input.length()) { [EOL]             final CharSequence unicode = input.subSequence(index + i, index + i + 4); [EOL]             try { [EOL]                 final int value = Integer.parseInt(unicode.toString(), 16); [EOL]                 out.write((char) value); [EOL]             } catch (final NumberFormatException nfe) { [EOL]                 throw new IllegalArgumentException("Unable to parse unicode value: " + unicode, nfe); [EOL]             } [EOL]             return i + 4; [EOL]         } else { [EOL]             throw new IllegalArgumentException("Less than 4 hex digits in unicode value: '" + input.subSequence(index, input.length()) + "' due to end of CharSequence"); [EOL]         } [EOL]     } [EOL]     return 0; [EOL] }
@Override [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL]     if (input.charAt(index) == '\\' && index + 1 < input.length() && input.charAt(index + 1) == 'u') { [EOL]         int i = 2; [EOL]         while (index + i < input.length() && input.charAt(index + i) == 'u') { [EOL]             i++; [EOL]         } [EOL]         if (index + i < input.length() && input.charAt(index + i) == '+') { [EOL]             i++; [EOL]         } [EOL]         if (index + i + 4 <= input.length()) { [EOL]             final CharSequence unicode = input.subSequence(index + i, index + i + 4); [EOL]             try { [EOL]                 final int value = Integer.parseInt(unicode.toString(), 16); [EOL]                 out.write((char) value); [EOL]             } catch (final NumberFormatException nfe) { [EOL]                 throw new IllegalArgumentException("Unable to parse unicode value: " + unicode, nfe); [EOL]             } [EOL]             return i + 4; [EOL]         } else { [EOL]             throw new IllegalArgumentException("Less than 4 hex digits in unicode value: '" + input.subSequence(index, input.length()) + "' due to end of CharSequence"); [EOL]         } [EOL]     } [EOL]     return 0; [EOL] }
@Override [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL]     if (input.charAt(index) == '\\' && index + 1 < input.length() && input.charAt(index + 1) == 'u') { [EOL]         int i = 2; [EOL]         while (index + i < input.length() && input.charAt(index + i) == 'u') { [EOL]             i++; [EOL]         } [EOL]         if (index + i < input.length() && input.charAt(index + i) == '+') { [EOL]             i++; [EOL]         } [EOL]         if (index + i + 4 <= input.length()) { [EOL]             final CharSequence unicode = input.subSequence(index + i, index + i + 4); [EOL]             try { [EOL]                 final int value = Integer.parseInt(unicode.toString(), 16); [EOL]                 out.write((char) value); [EOL]             } catch (final NumberFormatException nfe) { [EOL]                 throw new IllegalArgumentException("Unable to parse unicode value: " + unicode, nfe); [EOL]             } [EOL]             return i + 4; [EOL]         } else { [EOL]             throw new IllegalArgumentException("Less than 4 hex digits in unicode value: '" + input.subSequence(index, input.length()) + "' due to end of CharSequence"); [EOL]         } [EOL]     } [EOL]     return 0; [EOL] }
@Override [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL]     if (input.charAt(index) == '\\' && index + 1 < input.length() && input.charAt(index + 1) == 'u') { [EOL]         int i = 2; [EOL]         while (index + i < input.length() && input.charAt(index + i) == 'u') { [EOL]             i++; [EOL]         } [EOL]         if (index + i < input.length() && input.charAt(index + i) == '+') { [EOL]             i++; [EOL]         } [EOL]         if (index + i + 4 <= input.length()) { [EOL]             final CharSequence unicode = input.subSequence(index + i, index + i + 4); [EOL]             try { [EOL]                 final int value = Integer.parseInt(unicode.toString(), 16); [EOL]                 out.write((char) value); [EOL]             } catch (final NumberFormatException nfe) { [EOL]                 throw new IllegalArgumentException("Unable to parse unicode value: " + unicode, nfe); [EOL]             } [EOL]             return i + 4; [EOL]         } else { [EOL]             throw new IllegalArgumentException("Less than 4 hex digits in unicode value: '" + input.subSequence(index, input.length()) + "' due to end of CharSequence"); [EOL]         } [EOL]     } [EOL]     return 0; [EOL] }
@Override [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL]     if (input.charAt(index) == '\\' && index + 1 < input.length() && input.charAt(index + 1) == 'u') { [EOL]         int i = 2; [EOL]         while (index + i < input.length() && input.charAt(index + i) == 'u') { [EOL]             i++; [EOL]         } [EOL]         if (index + i < input.length() && input.charAt(index + i) == '+') { [EOL]             i++; [EOL]         } [EOL]         if (index + i + 4 <= input.length()) { [EOL]             final CharSequence unicode = input.subSequence(index + i, index + i + 4); [EOL]             try { [EOL]                 final int value = Integer.parseInt(unicode.toString(), 16); [EOL]                 out.write((char) value); [EOL]             } catch (final NumberFormatException nfe) { [EOL]                 throw new IllegalArgumentException("Unable to parse unicode value: " + unicode, nfe); [EOL]             } [EOL]             return i + 4; [EOL]         } else { [EOL]             throw new IllegalArgumentException("Less than 4 hex digits in unicode value: '" + input.subSequence(index, input.length()) + "' due to end of CharSequence"); [EOL]         } [EOL]     } [EOL]     return 0; [EOL] }
@Override [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL]     if (input.charAt(index) == '\\' && index + 1 < input.length() && input.charAt(index + 1) == 'u') { [EOL]         int i = 2; [EOL]         while (index + i < input.length() && input.charAt(index + i) == 'u') { [EOL]             i++; [EOL]         } [EOL]         if (index + i < input.length() && input.charAt(index + i) == '+') { [EOL]             i++; [EOL]         } [EOL]         if (index + i + 4 <= input.length()) { [EOL]             final CharSequence unicode = input.subSequence(index + i, index + i + 4); [EOL]             try { [EOL]                 final int value = Integer.parseInt(unicode.toString(), 16); [EOL]                 out.write((char) value); [EOL]             } catch (final NumberFormatException nfe) { [EOL]                 throw new IllegalArgumentException("Unable to parse unicode value: " + unicode, nfe); [EOL]             } [EOL]             return i + 4; [EOL]         } else { [EOL]             throw new IllegalArgumentException("Less than 4 hex digits in unicode value: '" + input.subSequence(index, input.length()) + "' due to end of CharSequence"); [EOL]         } [EOL]     } [EOL]     return 0; [EOL] }
@Override [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL]     if (input.charAt(index) == '\\' && index + 1 < input.length() && input.charAt(index + 1) == 'u') { [EOL]         int i = 2; [EOL]         while (index + i < input.length() && input.charAt(index + i) == 'u') { [EOL]             i++; [EOL]         } [EOL]         if (index + i < input.length() && input.charAt(index + i) == '+') { [EOL]             i++; [EOL]         } [EOL]         if (index + i + 4 <= input.length()) { [EOL]             final CharSequence unicode = input.subSequence(index + i, index + i + 4); [EOL]             try { [EOL]                 final int value = Integer.parseInt(unicode.toString(), 16); [EOL]                 out.write((char) value); [EOL]             } catch (final NumberFormatException nfe) { [EOL]                 throw new IllegalArgumentException("Unable to parse unicode value: " + unicode, nfe); [EOL]             } [EOL]             return i + 4; [EOL]         } else { [EOL]             throw new IllegalArgumentException("Less than 4 hex digits in unicode value: '" + input.subSequence(index, input.length()) + "' due to end of CharSequence"); [EOL]         } [EOL]     } [EOL]     return 0; [EOL] }
@Override [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL]     if (input.charAt(index) == '\\' && index + 1 < input.length() && input.charAt(index + 1) == 'u') { [EOL]         int i = 2; [EOL]         while (index + i < input.length() && input.charAt(index + i) == 'u') { [EOL]             i++; [EOL]         } [EOL]         if (index + i < input.length() && input.charAt(index + i) == '+') { [EOL]             i++; [EOL]         } [EOL]         if (index + i + 4 <= input.length()) { [EOL]             final CharSequence unicode = input.subSequence(index + i, index + i + 4); [EOL]             try { [EOL]                 final int value = Integer.parseInt(unicode.toString(), 16); [EOL]                 out.write((char) value); [EOL]             } catch (final NumberFormatException nfe) { [EOL]                 throw new IllegalArgumentException("Unable to parse unicode value: " + unicode, nfe); [EOL]             } [EOL]             return i + 4; [EOL]         } else { [EOL]             throw new IllegalArgumentException("Less than 4 hex digits in unicode value: '" + input.subSequence(index, input.length()) + "' due to end of CharSequence"); [EOL]         } [EOL]     } [EOL]     return 0; [EOL] }
public static String getShortClassName(final Object object, final String valueIfNull) { [EOL]     if (object == null) { [EOL]         return valueIfNull; [EOL]     } [EOL]     return getShortClassName(object.getClass()); [EOL] }
public static String getShortClassName(String className) { [EOL]     if (StringUtils.isEmpty(className)) { [EOL]         return StringUtils.EMPTY; [EOL]     } [EOL]     final StringBuilder arrayPrefix = new StringBuilder(); [EOL]     if (className.startsWith("[")) { [EOL]         while (className.charAt(0) == '[') { [EOL]             className = className.substring(1); [EOL]             arrayPrefix.append("[]"); [EOL]         } [EOL]         if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') { [EOL]             className = className.substring(1, className.length() - 1); [EOL]         } [EOL]         if (reverseAbbreviationMap.containsKey(className)) { [EOL]             className = reverseAbbreviationMap.get(className); [EOL]         } [EOL]     } [EOL]     final int lastDotIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); [EOL]     final int innerIdx = className.indexOf(INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1 ? 0 : lastDotIdx + 1); [EOL]     String out = className.substring(lastDotIdx + 1); [EOL]     if (innerIdx != -1) { [EOL]         out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); [EOL]     } [EOL]     return out + arrayPrefix; [EOL] }
public static String getPackageName(String className) { [EOL]     if (StringUtils.isEmpty(className)) { [EOL]         return StringUtils.EMPTY; [EOL]     } [EOL]     while (className.charAt(0) == '[') { [EOL]         className = className.substring(1); [EOL]     } [EOL]     if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') { [EOL]         className = className.substring(1); [EOL]     } [EOL]     final int i = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); [EOL]     if (i == -1) { [EOL]         return StringUtils.EMPTY; [EOL]     } [EOL]     return className.substring(0, i); [EOL] }
public static Class<?>[] primitivesToWrappers(final Class<?>... classes) { [EOL]     if (classes == null) { [EOL]         return null; [EOL]     } [EOL]     if (classes.length == 0) { [EOL]         return classes; [EOL]     } [EOL]     final Class<?>[] convertedClasses = new Class[classes.length]; [EOL]     for (int i = 0; i < classes.length; i++) { [EOL]         convertedClasses[i] = primitiveToWrapper(classes[i]); [EOL]     } [EOL]     return convertedClasses; [EOL] }
public static Class<?>[] primitivesToWrappers(final Class<?>... classes) { [EOL]     if (classes == null) { [EOL]         return null; [EOL]     } [EOL]     if (classes.length == 0) { [EOL]         return classes; [EOL]     } [EOL]     final Class<?>[] convertedClasses = new Class[classes.length]; [EOL]     for (int i = 0; i < classes.length; i++) { [EOL]         convertedClasses[i] = primitiveToWrapper(classes[i]); [EOL]     } [EOL]     return convertedClasses; [EOL] }
public static Class<?>[] primitivesToWrappers(final Class<?>... classes) { [EOL]     if (classes == null) { [EOL]         return null; [EOL]     } [EOL]     if (classes.length == 0) { [EOL]         return classes; [EOL]     } [EOL]     final Class<?>[] convertedClasses = new Class[classes.length]; [EOL]     for (int i = 0; i < classes.length; i++) { [EOL]         convertedClasses[i] = primitiveToWrapper(classes[i]); [EOL]     } [EOL]     return convertedClasses; [EOL] }
public static boolean isInnerClass(final Class<?> cls) { [EOL]     return cls != null && cls.getEnclosingClass() != null; [EOL] }
public static boolean isInnerClass(final Class<?> cls) { [EOL]     return cls != null && cls.getEnclosingClass() != null; [EOL] }
public static boolean isInnerClass(final Class<?> cls) { [EOL]     return cls != null && cls.getEnclosingClass() != null; [EOL] }
protected BackgroundInitializer() { [EOL]     this(null); [EOL] }
protected BackgroundInitializer(final ExecutorService exec) { [EOL]     setExternalExecutor(exec); [EOL] }
public final synchronized ExecutorService getExternalExecutor() { [EOL]     return externalExecutor; [EOL] }
public synchronized boolean isStarted() { [EOL]     return future != null; [EOL] }
public synchronized boolean isStarted() { [EOL]     return future != null; [EOL] }
public final synchronized void setExternalExecutor(final ExecutorService externalExecutor) { [EOL]     if (isStarted()) { [EOL]         throw new IllegalStateException("Cannot set ExecutorService after start()!"); [EOL]     } [EOL]     this.externalExecutor = externalExecutor; [EOL] }
public final synchronized void setExternalExecutor(final ExecutorService externalExecutor) { [EOL]     if (isStarted()) { [EOL]         throw new IllegalStateException("Cannot set ExecutorService after start()!"); [EOL]     } [EOL]     this.externalExecutor = externalExecutor; [EOL] }
public synchronized boolean start() { [EOL]     if (!isStarted()) { [EOL]         ExecutorService tempExec; [EOL]         executor = getExternalExecutor(); [EOL]         if (executor == null) { [EOL]             executor = tempExec = createExecutor(); [EOL]         } else { [EOL]             tempExec = null; [EOL]         } [EOL]         future = executor.submit(createTask(tempExec)); [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] }
public synchronized boolean start() { [EOL]     if (!isStarted()) { [EOL]         ExecutorService tempExec; [EOL]         executor = getExternalExecutor(); [EOL]         if (executor == null) { [EOL]             executor = tempExec = createExecutor(); [EOL]         } else { [EOL]             tempExec = null; [EOL]         } [EOL]         future = executor.submit(createTask(tempExec)); [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] }
public synchronized boolean start() { [EOL]     if (!isStarted()) { [EOL]         ExecutorService tempExec; [EOL]         executor = getExternalExecutor(); [EOL]         if (executor == null) { [EOL]             executor = tempExec = createExecutor(); [EOL]         } else { [EOL]             tempExec = null; [EOL]         } [EOL]         future = executor.submit(createTask(tempExec)); [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] }
@Override [EOL] public T get() throws ConcurrentException { [EOL]     try { [EOL]         return getFuture().get(); [EOL]     } catch (final ExecutionException execex) { [EOL]         ConcurrentUtils.handleCause(execex); [EOL]         return null; [EOL]     } catch (final InterruptedException iex) { [EOL]         Thread.currentThread().interrupt(); [EOL]         throw new ConcurrentException(iex); [EOL]     } [EOL] }
@Override [EOL] public T get() throws ConcurrentException { [EOL]     try { [EOL]         return getFuture().get(); [EOL]     } catch (final ExecutionException execex) { [EOL]         ConcurrentUtils.handleCause(execex); [EOL]         return null; [EOL]     } catch (final InterruptedException iex) { [EOL]         Thread.currentThread().interrupt(); [EOL]         throw new ConcurrentException(iex); [EOL]     } [EOL] }
public synchronized Future<T> getFuture() { [EOL]     if (future == null) { [EOL]         throw new IllegalStateException("start() must be called first!"); [EOL]     } [EOL]     return future; [EOL] }
public synchronized Future<T> getFuture() { [EOL]     if (future == null) { [EOL]         throw new IllegalStateException("start() must be called first!"); [EOL]     } [EOL]     return future; [EOL] }
protected synchronized final ExecutorService getActiveExecutor() { [EOL]     return executor; [EOL] }
protected int getTaskCount() { [EOL]     return 1; [EOL] }
private Callable<T> createTask(final ExecutorService execDestroy) { [EOL]     return new InitializationTask(execDestroy); [EOL] }
private ExecutorService createExecutor() { [EOL]     return Executors.newFixedThreadPool(getTaskCount()); [EOL] }
public InitializationTask(final ExecutorService exec) { [EOL]     execFinally = exec; [EOL] }
public InitializationTask(final ExecutorService exec) { [EOL]     execFinally = exec; [EOL] }
@Override [EOL] public T call() throws Exception { [EOL]     try { [EOL]         return initialize(); [EOL]     } finally { [EOL]         if (execFinally != null) { [EOL]             execFinally.shutdown(); [EOL]         } [EOL]     } [EOL] }
@Override [EOL] public T call() throws Exception { [EOL]     try { [EOL]         return initialize(); [EOL]     } finally { [EOL]         if (execFinally != null) { [EOL]             execFinally.shutdown(); [EOL]         } [EOL]     } [EOL] }
@Override [EOL] public T call() throws Exception { [EOL]     try { [EOL]         return initialize(); [EOL]     } finally { [EOL]         if (execFinally != null) { [EOL]             execFinally.shutdown(); [EOL]         } [EOL]     } [EOL] }
public ConcurrentRuntimeException(final Throwable cause) { [EOL]     super(ConcurrentUtils.checkedException(cause)); [EOL] }
public ConcurrentRuntimeException(final Throwable cause) { [EOL]     super(ConcurrentUtils.checkedException(cause)); [EOL] }
public ConcurrentRuntimeException(final Throwable cause) { [EOL]     super(ConcurrentUtils.checkedException(cause)); [EOL] }
public static StrLookup<String> systemPropertiesLookup() { [EOL]     return SYSTEM_PROPERTIES_LOOKUP; [EOL] }
@Override [EOL] public String lookup(final String key) { [EOL]     if (map == null) { [EOL]         return null; [EOL]     } [EOL]     final Object obj = map.get(key); [EOL]     if (obj == null) { [EOL]         return null; [EOL]     } [EOL]     return obj.toString(); [EOL] }
public static ConcurrentException extractCause(final ExecutionException ex) { [EOL]     if (ex == null || ex.getCause() == null) { [EOL]         return null; [EOL]     } [EOL]     throwCause(ex); [EOL]     return new ConcurrentException(ex.getMessage(), ex.getCause()); [EOL] }
public static ConcurrentException extractCause(final ExecutionException ex) { [EOL]     if (ex == null || ex.getCause() == null) { [EOL]         return null; [EOL]     } [EOL]     throwCause(ex); [EOL]     return new ConcurrentException(ex.getMessage(), ex.getCause()); [EOL] }
public static ConcurrentException extractCause(final ExecutionException ex) { [EOL]     if (ex == null || ex.getCause() == null) { [EOL]         return null; [EOL]     } [EOL]     throwCause(ex); [EOL]     return new ConcurrentException(ex.getMessage(), ex.getCause()); [EOL] }
public static ConcurrentRuntimeException extractCauseUnchecked(final ExecutionException ex) { [EOL]     if (ex == null || ex.getCause() == null) { [EOL]         return null; [EOL]     } [EOL]     throwCause(ex); [EOL]     return new ConcurrentRuntimeException(ex.getMessage(), ex.getCause()); [EOL] }
static Throwable checkedException(final Throwable ex) { [EOL]     if (ex != null && !(ex instanceof RuntimeException) && !(ex instanceof Error)) { [EOL]         return ex; [EOL]     } else { [EOL]         throw new IllegalArgumentException("Not a checked exception: " + ex); [EOL]     } [EOL] }
private static void throwCause(final ExecutionException ex) { [EOL]     if (ex.getCause() instanceof RuntimeException) { [EOL]         throw (RuntimeException) ex.getCause(); [EOL]     } [EOL]     if (ex.getCause() instanceof Error) { [EOL]         throw (Error) ex.getCause(); [EOL]     } [EOL] }
private static void throwCause(final ExecutionException ex) { [EOL]     if (ex.getCause() instanceof RuntimeException) { [EOL]         throw (RuntimeException) ex.getCause(); [EOL]     } [EOL]     if (ex.getCause() instanceof Error) { [EOL]         throw (Error) ex.getCause(); [EOL]     } [EOL] }
private static void throwCause(final ExecutionException ex) { [EOL]     if (ex.getCause() instanceof RuntimeException) { [EOL]         throw (RuntimeException) ex.getCause(); [EOL]     } [EOL]     if (ex.getCause() instanceof Error) { [EOL]         throw (Error) ex.getCause(); [EOL]     } [EOL] }
public static <T> T initializeUnchecked(final ConcurrentInitializer<T> initializer) { [EOL]     try { [EOL]         return initialize(initializer); [EOL]     } catch (final ConcurrentException cex) { [EOL]         throw new ConcurrentRuntimeException(cex.getCause()); [EOL]     } [EOL] }
public static <T> T initializeUnchecked(final ConcurrentInitializer<T> initializer) { [EOL]     try { [EOL]         return initialize(initializer); [EOL]     } catch (final ConcurrentException cex) { [EOL]         throw new ConcurrentRuntimeException(cex.getCause()); [EOL]     } [EOL] }
public static <K, V> V createIfAbsent(final ConcurrentMap<K, V> map, final K key, final ConcurrentInitializer<V> init) throws ConcurrentException { [EOL]     if (map == null || init == null) { [EOL]         return null; [EOL]     } [EOL]     final V value = map.get(key); [EOL]     if (value == null) { [EOL]         return putIfAbsent(map, key, init.get()); [EOL]     } [EOL]     return value; [EOL] }
public static <K, V> V createIfAbsent(final ConcurrentMap<K, V> map, final K key, final ConcurrentInitializer<V> init) throws ConcurrentException { [EOL]     if (map == null || init == null) { [EOL]         return null; [EOL]     } [EOL]     final V value = map.get(key); [EOL]     if (value == null) { [EOL]         return putIfAbsent(map, key, init.get()); [EOL]     } [EOL]     return value; [EOL] }
public static <K, V> V createIfAbsent(final ConcurrentMap<K, V> map, final K key, final ConcurrentInitializer<V> init) throws ConcurrentException { [EOL]     if (map == null || init == null) { [EOL]         return null; [EOL]     } [EOL]     final V value = map.get(key); [EOL]     if (value == null) { [EOL]         return putIfAbsent(map, key, init.get()); [EOL]     } [EOL]     return value; [EOL] }
public static <K, V> V createIfAbsent(final ConcurrentMap<K, V> map, final K key, final ConcurrentInitializer<V> init) throws ConcurrentException { [EOL]     if (map == null || init == null) { [EOL]         return null; [EOL]     } [EOL]     final V value = map.get(key); [EOL]     if (value == null) { [EOL]         return putIfAbsent(map, key, init.get()); [EOL]     } [EOL]     return value; [EOL] }
protected FastDateParser(final String pattern, final TimeZone timeZone, final Locale locale) { [EOL]     this.pattern = pattern; [EOL]     this.timeZone = timeZone; [EOL]     this.locale = locale; [EOL]     init(); [EOL] } protected FastDateParser(final String pattern, final TimeZone timeZone, final Locale locale);  CopyQuotedStrategy(final String formatField);  TextStrategy(final int field, final Calendar definingCalendar, final Locale locale);  NumberStrategy(final int field);  TimeZoneStrategy(final Locale locale); private void init(); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale();  Pattern getParsePattern(); public boolean equals(final Object obj); public int hashCode(); public String toString(); private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException; public Object parseObject(final String source) throws ParseException; public Date parse(final String source) throws ParseException; public Object parseObject(final String source, final ParsePosition pos); public Date parse(final String source, final ParsePosition pos); private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote); private static Map<String, Integer> getDisplayNames(final int field, final Calendar definingCalendar, final Locale locale);  int adjustYear(final int twoDigitYear);  boolean isNextNumber();  int getFieldWidth();  boolean isNumber();  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  abstract boolean addRegex(FastDateParser parser, StringBuilder regex); private Strategy getStrategy(String formatField, final Calendar definingCalendar); private static ConcurrentMap<Locale, Strategy> getCache(final int field); private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  int modify(final int iValue);  int modify(final int iValue); long serialVersionUID=Optional[1L]; Locale JAPANESE_IMPERIAL=Optional[new Locale("ja", "JP", "JP")]; String pattern; TimeZone timeZone; Locale locale; Pattern parsePattern; Strategy[] strategies; int thisYear; String currentFormatField; Strategy nextStrategy; Pattern formatPattern=Optional[Pattern.compile("D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++")]; ConcurrentMap<Locale, Strategy>[] caches=Optional[new ConcurrentMap[Calendar.FIELD_COUNT]]; Strategy ABBREVIATED_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR) {; ;     /**;      * {@inheritDoc};      */;     @Override;     void setCalendar(final FastDateParser parser, final Calendar cal, final String value) {;         int iValue = Integer.parseInt(value);;         if (iValue < 100) {;             iValue = parser.adjustYear(iValue);;         };         cal.set(Calendar.YEAR, iValue);;     }; }]; Strategy NUMBER_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.MONTH) {; ;     @Override;     int modify(final int iValue) {;         return iValue - 1;;     }; }]; Strategy LITERAL_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR)]; Strategy WEEK_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_YEAR)]; Strategy WEEK_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_MONTH)]; Strategy DAY_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_YEAR)]; Strategy DAY_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_MONTH)]; Strategy DAY_OF_WEEK_IN_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_WEEK_IN_MONTH)]; Strategy HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY)]; Strategy MODULO_HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 24;;     }; }]; Strategy MODULO_HOUR_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 12;;     }; }
private void init() { [EOL]     final Calendar definingCalendar = Calendar.getInstance(timeZone, locale); [EOL]     thisYear = definingCalendar.get(Calendar.YEAR); [EOL]     final StringBuilder regex = new StringBuilder(); [EOL]     final List<Strategy> collector = new ArrayList<Strategy>(); [EOL]     final Matcher patternMatcher = formatPattern.matcher(pattern); [EOL]     if (!patternMatcher.lookingAt()) { [EOL]         throw new IllegalArgumentException("Illegal pattern character '" + pattern.charAt(patternMatcher.regionStart()) + "'"); [EOL]     } [EOL]     currentFormatField = patternMatcher.group(); [EOL]     Strategy currentStrategy = getStrategy(currentFormatField, definingCalendar); [EOL]     for (; ; ) { [EOL]         patternMatcher.region(patternMatcher.end(), patternMatcher.regionEnd()); [EOL]         if (!patternMatcher.lookingAt()) { [EOL]             nextStrategy = null; [EOL]             break; [EOL]         } [EOL]         final String nextFormatField = patternMatcher.group(); [EOL]         nextStrategy = getStrategy(nextFormatField, definingCalendar); [EOL]         if (currentStrategy.addRegex(this, regex)) { [EOL]             collector.add(currentStrategy); [EOL]         } [EOL]         currentFormatField = nextFormatField; [EOL]         currentStrategy = nextStrategy; [EOL]     } [EOL]     if (patternMatcher.regionStart() != patternMatcher.regionEnd()) { [EOL]         throw new IllegalArgumentException("Failed to parse \"" + pattern + "\" ; gave up at index " + patternMatcher.regionStart()); [EOL]     } [EOL]     if (currentStrategy.addRegex(this, regex)) { [EOL]         collector.add(currentStrategy); [EOL]     } [EOL]     currentFormatField = null; [EOL]     strategies = collector.toArray(new Strategy[collector.size()]); [EOL]     parsePattern = Pattern.compile(regex.toString()); [EOL] } protected FastDateParser(final String pattern, final TimeZone timeZone, final Locale locale);  CopyQuotedStrategy(final String formatField);  TextStrategy(final int field, final Calendar definingCalendar, final Locale locale);  NumberStrategy(final int field);  TimeZoneStrategy(final Locale locale); private void init(); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale();  Pattern getParsePattern(); public boolean equals(final Object obj); public int hashCode(); public String toString(); private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException; public Object parseObject(final String source) throws ParseException; public Date parse(final String source) throws ParseException; public Object parseObject(final String source, final ParsePosition pos); public Date parse(final String source, final ParsePosition pos); private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote); private static Map<String, Integer> getDisplayNames(final int field, final Calendar definingCalendar, final Locale locale);  int adjustYear(final int twoDigitYear);  boolean isNextNumber();  int getFieldWidth();  boolean isNumber();  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  abstract boolean addRegex(FastDateParser parser, StringBuilder regex); private Strategy getStrategy(String formatField, final Calendar definingCalendar); private static ConcurrentMap<Locale, Strategy> getCache(final int field); private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  int modify(final int iValue);  int modify(final int iValue); long serialVersionUID=Optional[1L]; Locale JAPANESE_IMPERIAL=Optional[new Locale("ja", "JP", "JP")]; String pattern; TimeZone timeZone; Locale locale; Pattern parsePattern; Strategy[] strategies; int thisYear; String currentFormatField; Strategy nextStrategy; Pattern formatPattern=Optional[Pattern.compile("D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++")]; ConcurrentMap<Locale, Strategy>[] caches=Optional[new ConcurrentMap[Calendar.FIELD_COUNT]]; Strategy ABBREVIATED_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR) {; ;     /**;      * {@inheritDoc};      */;     @Override;     void setCalendar(final FastDateParser parser, final Calendar cal, final String value) {;         int iValue = Integer.parseInt(value);;         if (iValue < 100) {;             iValue = parser.adjustYear(iValue);;         };         cal.set(Calendar.YEAR, iValue);;     }; }]; Strategy NUMBER_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.MONTH) {; ;     @Override;     int modify(final int iValue) {;         return iValue - 1;;     }; }]; Strategy LITERAL_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR)]; Strategy WEEK_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_YEAR)]; Strategy WEEK_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_MONTH)]; Strategy DAY_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_YEAR)]; Strategy DAY_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_MONTH)]; Strategy DAY_OF_WEEK_IN_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_WEEK_IN_MONTH)]; Strategy HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY)]; Strategy MODULO_HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 24;;     }; }]; Strategy MODULO_HOUR_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 12;;     }; }
private void init() { [EOL]     final Calendar definingCalendar = Calendar.getInstance(timeZone, locale); [EOL]     thisYear = definingCalendar.get(Calendar.YEAR); [EOL]     final StringBuilder regex = new StringBuilder(); [EOL]     final List<Strategy> collector = new ArrayList<Strategy>(); [EOL]     final Matcher patternMatcher = formatPattern.matcher(pattern); [EOL]     if (!patternMatcher.lookingAt()) { [EOL]         throw new IllegalArgumentException("Illegal pattern character '" + pattern.charAt(patternMatcher.regionStart()) + "'"); [EOL]     } [EOL]     currentFormatField = patternMatcher.group(); [EOL]     Strategy currentStrategy = getStrategy(currentFormatField, definingCalendar); [EOL]     for (; ; ) { [EOL]         patternMatcher.region(patternMatcher.end(), patternMatcher.regionEnd()); [EOL]         if (!patternMatcher.lookingAt()) { [EOL]             nextStrategy = null; [EOL]             break; [EOL]         } [EOL]         final String nextFormatField = patternMatcher.group(); [EOL]         nextStrategy = getStrategy(nextFormatField, definingCalendar); [EOL]         if (currentStrategy.addRegex(this, regex)) { [EOL]             collector.add(currentStrategy); [EOL]         } [EOL]         currentFormatField = nextFormatField; [EOL]         currentStrategy = nextStrategy; [EOL]     } [EOL]     if (patternMatcher.regionStart() != patternMatcher.regionEnd()) { [EOL]         throw new IllegalArgumentException("Failed to parse \"" + pattern + "\" ; gave up at index " + patternMatcher.regionStart()); [EOL]     } [EOL]     if (currentStrategy.addRegex(this, regex)) { [EOL]         collector.add(currentStrategy); [EOL]     } [EOL]     currentFormatField = null; [EOL]     strategies = collector.toArray(new Strategy[collector.size()]); [EOL]     parsePattern = Pattern.compile(regex.toString()); [EOL] } protected FastDateParser(final String pattern, final TimeZone timeZone, final Locale locale);  CopyQuotedStrategy(final String formatField);  TextStrategy(final int field, final Calendar definingCalendar, final Locale locale);  NumberStrategy(final int field);  TimeZoneStrategy(final Locale locale); private void init(); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale();  Pattern getParsePattern(); public boolean equals(final Object obj); public int hashCode(); public String toString(); private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException; public Object parseObject(final String source) throws ParseException; public Date parse(final String source) throws ParseException; public Object parseObject(final String source, final ParsePosition pos); public Date parse(final String source, final ParsePosition pos); private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote); private static Map<String, Integer> getDisplayNames(final int field, final Calendar definingCalendar, final Locale locale);  int adjustYear(final int twoDigitYear);  boolean isNextNumber();  int getFieldWidth();  boolean isNumber();  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  abstract boolean addRegex(FastDateParser parser, StringBuilder regex); private Strategy getStrategy(String formatField, final Calendar definingCalendar); private static ConcurrentMap<Locale, Strategy> getCache(final int field); private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  int modify(final int iValue);  int modify(final int iValue); long serialVersionUID=Optional[1L]; Locale JAPANESE_IMPERIAL=Optional[new Locale("ja", "JP", "JP")]; String pattern; TimeZone timeZone; Locale locale; Pattern parsePattern; Strategy[] strategies; int thisYear; String currentFormatField; Strategy nextStrategy; Pattern formatPattern=Optional[Pattern.compile("D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++")]; ConcurrentMap<Locale, Strategy>[] caches=Optional[new ConcurrentMap[Calendar.FIELD_COUNT]]; Strategy ABBREVIATED_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR) {; ;     /**;      * {@inheritDoc};      */;     @Override;     void setCalendar(final FastDateParser parser, final Calendar cal, final String value) {;         int iValue = Integer.parseInt(value);;         if (iValue < 100) {;             iValue = parser.adjustYear(iValue);;         };         cal.set(Calendar.YEAR, iValue);;     }; }]; Strategy NUMBER_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.MONTH) {; ;     @Override;     int modify(final int iValue) {;         return iValue - 1;;     }; }]; Strategy LITERAL_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR)]; Strategy WEEK_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_YEAR)]; Strategy WEEK_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_MONTH)]; Strategy DAY_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_YEAR)]; Strategy DAY_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_MONTH)]; Strategy DAY_OF_WEEK_IN_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_WEEK_IN_MONTH)]; Strategy HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY)]; Strategy MODULO_HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 24;;     }; }]; Strategy MODULO_HOUR_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 12;;     }; }
private void init() { [EOL]     final Calendar definingCalendar = Calendar.getInstance(timeZone, locale); [EOL]     thisYear = definingCalendar.get(Calendar.YEAR); [EOL]     final StringBuilder regex = new StringBuilder(); [EOL]     final List<Strategy> collector = new ArrayList<Strategy>(); [EOL]     final Matcher patternMatcher = formatPattern.matcher(pattern); [EOL]     if (!patternMatcher.lookingAt()) { [EOL]         throw new IllegalArgumentException("Illegal pattern character '" + pattern.charAt(patternMatcher.regionStart()) + "'"); [EOL]     } [EOL]     currentFormatField = patternMatcher.group(); [EOL]     Strategy currentStrategy = getStrategy(currentFormatField, definingCalendar); [EOL]     for (; ; ) { [EOL]         patternMatcher.region(patternMatcher.end(), patternMatcher.regionEnd()); [EOL]         if (!patternMatcher.lookingAt()) { [EOL]             nextStrategy = null; [EOL]             break; [EOL]         } [EOL]         final String nextFormatField = patternMatcher.group(); [EOL]         nextStrategy = getStrategy(nextFormatField, definingCalendar); [EOL]         if (currentStrategy.addRegex(this, regex)) { [EOL]             collector.add(currentStrategy); [EOL]         } [EOL]         currentFormatField = nextFormatField; [EOL]         currentStrategy = nextStrategy; [EOL]     } [EOL]     if (patternMatcher.regionStart() != patternMatcher.regionEnd()) { [EOL]         throw new IllegalArgumentException("Failed to parse \"" + pattern + "\" ; gave up at index " + patternMatcher.regionStart()); [EOL]     } [EOL]     if (currentStrategy.addRegex(this, regex)) { [EOL]         collector.add(currentStrategy); [EOL]     } [EOL]     currentFormatField = null; [EOL]     strategies = collector.toArray(new Strategy[collector.size()]); [EOL]     parsePattern = Pattern.compile(regex.toString()); [EOL] } protected FastDateParser(final String pattern, final TimeZone timeZone, final Locale locale);  CopyQuotedStrategy(final String formatField);  TextStrategy(final int field, final Calendar definingCalendar, final Locale locale);  NumberStrategy(final int field);  TimeZoneStrategy(final Locale locale); private void init(); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale();  Pattern getParsePattern(); public boolean equals(final Object obj); public int hashCode(); public String toString(); private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException; public Object parseObject(final String source) throws ParseException; public Date parse(final String source) throws ParseException; public Object parseObject(final String source, final ParsePosition pos); public Date parse(final String source, final ParsePosition pos); private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote); private static Map<String, Integer> getDisplayNames(final int field, final Calendar definingCalendar, final Locale locale);  int adjustYear(final int twoDigitYear);  boolean isNextNumber();  int getFieldWidth();  boolean isNumber();  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  abstract boolean addRegex(FastDateParser parser, StringBuilder regex); private Strategy getStrategy(String formatField, final Calendar definingCalendar); private static ConcurrentMap<Locale, Strategy> getCache(final int field); private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  int modify(final int iValue);  int modify(final int iValue); long serialVersionUID=Optional[1L]; Locale JAPANESE_IMPERIAL=Optional[new Locale("ja", "JP", "JP")]; String pattern; TimeZone timeZone; Locale locale; Pattern parsePattern; Strategy[] strategies; int thisYear; String currentFormatField; Strategy nextStrategy; Pattern formatPattern=Optional[Pattern.compile("D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++")]; ConcurrentMap<Locale, Strategy>[] caches=Optional[new ConcurrentMap[Calendar.FIELD_COUNT]]; Strategy ABBREVIATED_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR) {; ;     /**;      * {@inheritDoc};      */;     @Override;     void setCalendar(final FastDateParser parser, final Calendar cal, final String value) {;         int iValue = Integer.parseInt(value);;         if (iValue < 100) {;             iValue = parser.adjustYear(iValue);;         };         cal.set(Calendar.YEAR, iValue);;     }; }]; Strategy NUMBER_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.MONTH) {; ;     @Override;     int modify(final int iValue) {;         return iValue - 1;;     }; }]; Strategy LITERAL_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR)]; Strategy WEEK_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_YEAR)]; Strategy WEEK_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_MONTH)]; Strategy DAY_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_YEAR)]; Strategy DAY_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_MONTH)]; Strategy DAY_OF_WEEK_IN_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_WEEK_IN_MONTH)]; Strategy HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY)]; Strategy MODULO_HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 24;;     }; }]; Strategy MODULO_HOUR_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 12;;     }; }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     if (!(obj instanceof FastDateParser)) { [EOL]         return false; [EOL]     } [EOL]     final FastDateParser other = (FastDateParser) obj; [EOL]     return pattern.equals(other.pattern) && timeZone.equals(other.timeZone) && locale.equals(other.locale); [EOL] } protected FastDateParser(final String pattern, final TimeZone timeZone, final Locale locale);  CopyQuotedStrategy(final String formatField);  TextStrategy(final int field, final Calendar definingCalendar, final Locale locale);  NumberStrategy(final int field);  TimeZoneStrategy(final Locale locale); private void init(); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale();  Pattern getParsePattern(); public boolean equals(final Object obj); public int hashCode(); public String toString(); private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException; public Object parseObject(final String source) throws ParseException; public Date parse(final String source) throws ParseException; public Object parseObject(final String source, final ParsePosition pos); public Date parse(final String source, final ParsePosition pos); private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote); private static Map<String, Integer> getDisplayNames(final int field, final Calendar definingCalendar, final Locale locale);  int adjustYear(final int twoDigitYear);  boolean isNextNumber();  int getFieldWidth();  boolean isNumber();  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  abstract boolean addRegex(FastDateParser parser, StringBuilder regex); private Strategy getStrategy(String formatField, final Calendar definingCalendar); private static ConcurrentMap<Locale, Strategy> getCache(final int field); private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  int modify(final int iValue);  int modify(final int iValue); long serialVersionUID=Optional[1L]; Locale JAPANESE_IMPERIAL=Optional[new Locale("ja", "JP", "JP")]; String pattern; TimeZone timeZone; Locale locale; Pattern parsePattern; Strategy[] strategies; int thisYear; String currentFormatField; Strategy nextStrategy; Pattern formatPattern=Optional[Pattern.compile("D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++")]; ConcurrentMap<Locale, Strategy>[] caches=Optional[new ConcurrentMap[Calendar.FIELD_COUNT]]; Strategy ABBREVIATED_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR) {; ;     /**;      * {@inheritDoc};      */;     @Override;     void setCalendar(final FastDateParser parser, final Calendar cal, final String value) {;         int iValue = Integer.parseInt(value);;         if (iValue < 100) {;             iValue = parser.adjustYear(iValue);;         };         cal.set(Calendar.YEAR, iValue);;     }; }]; Strategy NUMBER_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.MONTH) {; ;     @Override;     int modify(final int iValue) {;         return iValue - 1;;     }; }]; Strategy LITERAL_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR)]; Strategy WEEK_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_YEAR)]; Strategy WEEK_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_MONTH)]; Strategy DAY_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_YEAR)]; Strategy DAY_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_MONTH)]; Strategy DAY_OF_WEEK_IN_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_WEEK_IN_MONTH)]; Strategy HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY)]; Strategy MODULO_HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 24;;     }; }]; Strategy MODULO_HOUR_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 12;;     }; }
@Override [EOL] public Date parse(final String source) throws ParseException { [EOL]     final Date date = parse(source, new ParsePosition(0)); [EOL]     if (date == null) { [EOL]         if (locale.equals(JAPANESE_IMPERIAL)) { [EOL]             throw new ParseException("(The " + locale + " locale does not support dates before 1868 AD)\n" + "Unparseable date: \"" + source + "\" does not match " + parsePattern.pattern(), 0); [EOL]         } [EOL]         throw new ParseException("Unparseable date: \"" + source + "\" does not match " + parsePattern.pattern(), 0); [EOL]     } [EOL]     return date; [EOL] } protected FastDateParser(final String pattern, final TimeZone timeZone, final Locale locale);  CopyQuotedStrategy(final String formatField);  TextStrategy(final int field, final Calendar definingCalendar, final Locale locale);  NumberStrategy(final int field);  TimeZoneStrategy(final Locale locale); private void init(); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale();  Pattern getParsePattern(); public boolean equals(final Object obj); public int hashCode(); public String toString(); private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException; public Object parseObject(final String source) throws ParseException; public Date parse(final String source) throws ParseException; public Object parseObject(final String source, final ParsePosition pos); public Date parse(final String source, final ParsePosition pos); private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote); private static Map<String, Integer> getDisplayNames(final int field, final Calendar definingCalendar, final Locale locale);  int adjustYear(final int twoDigitYear);  boolean isNextNumber();  int getFieldWidth();  boolean isNumber();  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  abstract boolean addRegex(FastDateParser parser, StringBuilder regex); private Strategy getStrategy(String formatField, final Calendar definingCalendar); private static ConcurrentMap<Locale, Strategy> getCache(final int field); private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  int modify(final int iValue);  int modify(final int iValue); long serialVersionUID=Optional[1L]; Locale JAPANESE_IMPERIAL=Optional[new Locale("ja", "JP", "JP")]; String pattern; TimeZone timeZone; Locale locale; Pattern parsePattern; Strategy[] strategies; int thisYear; String currentFormatField; Strategy nextStrategy; Pattern formatPattern=Optional[Pattern.compile("D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++")]; ConcurrentMap<Locale, Strategy>[] caches=Optional[new ConcurrentMap[Calendar.FIELD_COUNT]]; Strategy ABBREVIATED_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR) {; ;     /**;      * {@inheritDoc};      */;     @Override;     void setCalendar(final FastDateParser parser, final Calendar cal, final String value) {;         int iValue = Integer.parseInt(value);;         if (iValue < 100) {;             iValue = parser.adjustYear(iValue);;         };         cal.set(Calendar.YEAR, iValue);;     }; }]; Strategy NUMBER_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.MONTH) {; ;     @Override;     int modify(final int iValue) {;         return iValue - 1;;     }; }]; Strategy LITERAL_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR)]; Strategy WEEK_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_YEAR)]; Strategy WEEK_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_MONTH)]; Strategy DAY_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_YEAR)]; Strategy DAY_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_MONTH)]; Strategy DAY_OF_WEEK_IN_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_WEEK_IN_MONTH)]; Strategy HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY)]; Strategy MODULO_HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 24;;     }; }]; Strategy MODULO_HOUR_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 12;;     }; }
@Override [EOL] public Date parse(final String source) throws ParseException { [EOL]     final Date date = parse(source, new ParsePosition(0)); [EOL]     if (date == null) { [EOL]         if (locale.equals(JAPANESE_IMPERIAL)) { [EOL]             throw new ParseException("(The " + locale + " locale does not support dates before 1868 AD)\n" + "Unparseable date: \"" + source + "\" does not match " + parsePattern.pattern(), 0); [EOL]         } [EOL]         throw new ParseException("Unparseable date: \"" + source + "\" does not match " + parsePattern.pattern(), 0); [EOL]     } [EOL]     return date; [EOL] } protected FastDateParser(final String pattern, final TimeZone timeZone, final Locale locale);  CopyQuotedStrategy(final String formatField);  TextStrategy(final int field, final Calendar definingCalendar, final Locale locale);  NumberStrategy(final int field);  TimeZoneStrategy(final Locale locale); private void init(); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale();  Pattern getParsePattern(); public boolean equals(final Object obj); public int hashCode(); public String toString(); private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException; public Object parseObject(final String source) throws ParseException; public Date parse(final String source) throws ParseException; public Object parseObject(final String source, final ParsePosition pos); public Date parse(final String source, final ParsePosition pos); private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote); private static Map<String, Integer> getDisplayNames(final int field, final Calendar definingCalendar, final Locale locale);  int adjustYear(final int twoDigitYear);  boolean isNextNumber();  int getFieldWidth();  boolean isNumber();  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  abstract boolean addRegex(FastDateParser parser, StringBuilder regex); private Strategy getStrategy(String formatField, final Calendar definingCalendar); private static ConcurrentMap<Locale, Strategy> getCache(final int field); private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  int modify(final int iValue);  int modify(final int iValue); long serialVersionUID=Optional[1L]; Locale JAPANESE_IMPERIAL=Optional[new Locale("ja", "JP", "JP")]; String pattern; TimeZone timeZone; Locale locale; Pattern parsePattern; Strategy[] strategies; int thisYear; String currentFormatField; Strategy nextStrategy; Pattern formatPattern=Optional[Pattern.compile("D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++")]; ConcurrentMap<Locale, Strategy>[] caches=Optional[new ConcurrentMap[Calendar.FIELD_COUNT]]; Strategy ABBREVIATED_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR) {; ;     /**;      * {@inheritDoc};      */;     @Override;     void setCalendar(final FastDateParser parser, final Calendar cal, final String value) {;         int iValue = Integer.parseInt(value);;         if (iValue < 100) {;             iValue = parser.adjustYear(iValue);;         };         cal.set(Calendar.YEAR, iValue);;     }; }]; Strategy NUMBER_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.MONTH) {; ;     @Override;     int modify(final int iValue) {;         return iValue - 1;;     }; }]; Strategy LITERAL_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR)]; Strategy WEEK_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_YEAR)]; Strategy WEEK_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_MONTH)]; Strategy DAY_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_YEAR)]; Strategy DAY_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_MONTH)]; Strategy DAY_OF_WEEK_IN_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_WEEK_IN_MONTH)]; Strategy HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY)]; Strategy MODULO_HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 24;;     }; }]; Strategy MODULO_HOUR_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 12;;     }; }
@Override [EOL] public Date parse(final String source) throws ParseException { [EOL]     final Date date = parse(source, new ParsePosition(0)); [EOL]     if (date == null) { [EOL]         if (locale.equals(JAPANESE_IMPERIAL)) { [EOL]             throw new ParseException("(The " + locale + " locale does not support dates before 1868 AD)\n" + "Unparseable date: \"" + source + "\" does not match " + parsePattern.pattern(), 0); [EOL]         } [EOL]         throw new ParseException("Unparseable date: \"" + source + "\" does not match " + parsePattern.pattern(), 0); [EOL]     } [EOL]     return date; [EOL] } protected FastDateParser(final String pattern, final TimeZone timeZone, final Locale locale);  CopyQuotedStrategy(final String formatField);  TextStrategy(final int field, final Calendar definingCalendar, final Locale locale);  NumberStrategy(final int field);  TimeZoneStrategy(final Locale locale); private void init(); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale();  Pattern getParsePattern(); public boolean equals(final Object obj); public int hashCode(); public String toString(); private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException; public Object parseObject(final String source) throws ParseException; public Date parse(final String source) throws ParseException; public Object parseObject(final String source, final ParsePosition pos); public Date parse(final String source, final ParsePosition pos); private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote); private static Map<String, Integer> getDisplayNames(final int field, final Calendar definingCalendar, final Locale locale);  int adjustYear(final int twoDigitYear);  boolean isNextNumber();  int getFieldWidth();  boolean isNumber();  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  abstract boolean addRegex(FastDateParser parser, StringBuilder regex); private Strategy getStrategy(String formatField, final Calendar definingCalendar); private static ConcurrentMap<Locale, Strategy> getCache(final int field); private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  int modify(final int iValue);  int modify(final int iValue); long serialVersionUID=Optional[1L]; Locale JAPANESE_IMPERIAL=Optional[new Locale("ja", "JP", "JP")]; String pattern; TimeZone timeZone; Locale locale; Pattern parsePattern; Strategy[] strategies; int thisYear; String currentFormatField; Strategy nextStrategy; Pattern formatPattern=Optional[Pattern.compile("D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++")]; ConcurrentMap<Locale, Strategy>[] caches=Optional[new ConcurrentMap[Calendar.FIELD_COUNT]]; Strategy ABBREVIATED_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR) {; ;     /**;      * {@inheritDoc};      */;     @Override;     void setCalendar(final FastDateParser parser, final Calendar cal, final String value) {;         int iValue = Integer.parseInt(value);;         if (iValue < 100) {;             iValue = parser.adjustYear(iValue);;         };         cal.set(Calendar.YEAR, iValue);;     }; }]; Strategy NUMBER_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.MONTH) {; ;     @Override;     int modify(final int iValue) {;         return iValue - 1;;     }; }]; Strategy LITERAL_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR)]; Strategy WEEK_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_YEAR)]; Strategy WEEK_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_MONTH)]; Strategy DAY_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_YEAR)]; Strategy DAY_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_MONTH)]; Strategy DAY_OF_WEEK_IN_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_WEEK_IN_MONTH)]; Strategy HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY)]; Strategy MODULO_HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 24;;     }; }]; Strategy MODULO_HOUR_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 12;;     }; }
@Override [EOL] public Date parse(final String source, final ParsePosition pos) { [EOL]     final int offset = pos.getIndex(); [EOL]     final Matcher matcher = parsePattern.matcher(source.substring(offset)); [EOL]     if (!matcher.lookingAt()) { [EOL]         return null; [EOL]     } [EOL]     final Calendar cal = Calendar.getInstance(timeZone, locale); [EOL]     cal.clear(); [EOL]     for (int i = 0; i < strategies.length; ) { [EOL]         final Strategy strategy = strategies[i++]; [EOL]         strategy.setCalendar(this, cal, matcher.group(i)); [EOL]     } [EOL]     pos.setIndex(offset + matcher.end()); [EOL]     return cal.getTime(); [EOL] } protected FastDateParser(final String pattern, final TimeZone timeZone, final Locale locale);  CopyQuotedStrategy(final String formatField);  TextStrategy(final int field, final Calendar definingCalendar, final Locale locale);  NumberStrategy(final int field);  TimeZoneStrategy(final Locale locale); private void init(); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale();  Pattern getParsePattern(); public boolean equals(final Object obj); public int hashCode(); public String toString(); private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException; public Object parseObject(final String source) throws ParseException; public Date parse(final String source) throws ParseException; public Object parseObject(final String source, final ParsePosition pos); public Date parse(final String source, final ParsePosition pos); private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote); private static Map<String, Integer> getDisplayNames(final int field, final Calendar definingCalendar, final Locale locale);  int adjustYear(final int twoDigitYear);  boolean isNextNumber();  int getFieldWidth();  boolean isNumber();  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  abstract boolean addRegex(FastDateParser parser, StringBuilder regex); private Strategy getStrategy(String formatField, final Calendar definingCalendar); private static ConcurrentMap<Locale, Strategy> getCache(final int field); private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  int modify(final int iValue);  int modify(final int iValue); long serialVersionUID=Optional[1L]; Locale JAPANESE_IMPERIAL=Optional[new Locale("ja", "JP", "JP")]; String pattern; TimeZone timeZone; Locale locale; Pattern parsePattern; Strategy[] strategies; int thisYear; String currentFormatField; Strategy nextStrategy; Pattern formatPattern=Optional[Pattern.compile("D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++")]; ConcurrentMap<Locale, Strategy>[] caches=Optional[new ConcurrentMap[Calendar.FIELD_COUNT]]; Strategy ABBREVIATED_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR) {; ;     /**;      * {@inheritDoc};      */;     @Override;     void setCalendar(final FastDateParser parser, final Calendar cal, final String value) {;         int iValue = Integer.parseInt(value);;         if (iValue < 100) {;             iValue = parser.adjustYear(iValue);;         };         cal.set(Calendar.YEAR, iValue);;     }; }]; Strategy NUMBER_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.MONTH) {; ;     @Override;     int modify(final int iValue) {;         return iValue - 1;;     }; }]; Strategy LITERAL_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR)]; Strategy WEEK_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_YEAR)]; Strategy WEEK_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_MONTH)]; Strategy DAY_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_YEAR)]; Strategy DAY_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_MONTH)]; Strategy DAY_OF_WEEK_IN_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_WEEK_IN_MONTH)]; Strategy HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY)]; Strategy MODULO_HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 24;;     }; }]; Strategy MODULO_HOUR_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 12;;     }; }
private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote) { [EOL]     regex.append("\\Q"); [EOL]     for (int i = 0; i < value.length(); ++i) { [EOL]         char c = value.charAt(i); [EOL]         switch(c) { [EOL]             case '\'': [EOL]                 if (unquote) { [EOL]                     if (++i == value.length()) { [EOL]                         return regex; [EOL]                     } [EOL]                     c = value.charAt(i); [EOL]                 } [EOL]                 break; [EOL]             case '\\': [EOL]                 if (++i == value.length()) { [EOL]                     break; [EOL]                 } [EOL]                 regex.append(c); [EOL]                 c = value.charAt(i); [EOL]                 if (c == 'E') { [EOL]                     regex.append("E\\\\E\\"); [EOL]                     c = 'Q'; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         regex.append(c); [EOL]     } [EOL]     regex.append("\\E"); [EOL]     return regex; [EOL] } protected FastDateParser(final String pattern, final TimeZone timeZone, final Locale locale);  CopyQuotedStrategy(final String formatField);  TextStrategy(final int field, final Calendar definingCalendar, final Locale locale);  NumberStrategy(final int field);  TimeZoneStrategy(final Locale locale); private void init(); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale();  Pattern getParsePattern(); public boolean equals(final Object obj); public int hashCode(); public String toString(); private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException; public Object parseObject(final String source) throws ParseException; public Date parse(final String source) throws ParseException; public Object parseObject(final String source, final ParsePosition pos); public Date parse(final String source, final ParsePosition pos); private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote); private static Map<String, Integer> getDisplayNames(final int field, final Calendar definingCalendar, final Locale locale);  int adjustYear(final int twoDigitYear);  boolean isNextNumber();  int getFieldWidth();  boolean isNumber();  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  abstract boolean addRegex(FastDateParser parser, StringBuilder regex); private Strategy getStrategy(String formatField, final Calendar definingCalendar); private static ConcurrentMap<Locale, Strategy> getCache(final int field); private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  int modify(final int iValue);  int modify(final int iValue); long serialVersionUID=Optional[1L]; Locale JAPANESE_IMPERIAL=Optional[new Locale("ja", "JP", "JP")]; String pattern; TimeZone timeZone; Locale locale; Pattern parsePattern; Strategy[] strategies; int thisYear; String currentFormatField; Strategy nextStrategy; Pattern formatPattern=Optional[Pattern.compile("D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++")]; ConcurrentMap<Locale, Strategy>[] caches=Optional[new ConcurrentMap[Calendar.FIELD_COUNT]]; Strategy ABBREVIATED_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR) {; ;     /**;      * {@inheritDoc};      */;     @Override;     void setCalendar(final FastDateParser parser, final Calendar cal, final String value) {;         int iValue = Integer.parseInt(value);;         if (iValue < 100) {;             iValue = parser.adjustYear(iValue);;         };         cal.set(Calendar.YEAR, iValue);;     }; }]; Strategy NUMBER_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.MONTH) {; ;     @Override;     int modify(final int iValue) {;         return iValue - 1;;     }; }]; Strategy LITERAL_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR)]; Strategy WEEK_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_YEAR)]; Strategy WEEK_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_MONTH)]; Strategy DAY_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_YEAR)]; Strategy DAY_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_MONTH)]; Strategy DAY_OF_WEEK_IN_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_WEEK_IN_MONTH)]; Strategy HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY)]; Strategy MODULO_HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 24;;     }; }]; Strategy MODULO_HOUR_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 12;;     }; }
private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote) { [EOL]     regex.append("\\Q"); [EOL]     for (int i = 0; i < value.length(); ++i) { [EOL]         char c = value.charAt(i); [EOL]         switch(c) { [EOL]             case '\'': [EOL]                 if (unquote) { [EOL]                     if (++i == value.length()) { [EOL]                         return regex; [EOL]                     } [EOL]                     c = value.charAt(i); [EOL]                 } [EOL]                 break; [EOL]             case '\\': [EOL]                 if (++i == value.length()) { [EOL]                     break; [EOL]                 } [EOL]                 regex.append(c); [EOL]                 c = value.charAt(i); [EOL]                 if (c == 'E') { [EOL]                     regex.append("E\\\\E\\"); [EOL]                     c = 'Q'; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         regex.append(c); [EOL]     } [EOL]     regex.append("\\E"); [EOL]     return regex; [EOL] } protected FastDateParser(final String pattern, final TimeZone timeZone, final Locale locale);  CopyQuotedStrategy(final String formatField);  TextStrategy(final int field, final Calendar definingCalendar, final Locale locale);  NumberStrategy(final int field);  TimeZoneStrategy(final Locale locale); private void init(); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale();  Pattern getParsePattern(); public boolean equals(final Object obj); public int hashCode(); public String toString(); private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException; public Object parseObject(final String source) throws ParseException; public Date parse(final String source) throws ParseException; public Object parseObject(final String source, final ParsePosition pos); public Date parse(final String source, final ParsePosition pos); private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote); private static Map<String, Integer> getDisplayNames(final int field, final Calendar definingCalendar, final Locale locale);  int adjustYear(final int twoDigitYear);  boolean isNextNumber();  int getFieldWidth();  boolean isNumber();  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  abstract boolean addRegex(FastDateParser parser, StringBuilder regex); private Strategy getStrategy(String formatField, final Calendar definingCalendar); private static ConcurrentMap<Locale, Strategy> getCache(final int field); private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  int modify(final int iValue);  int modify(final int iValue); long serialVersionUID=Optional[1L]; Locale JAPANESE_IMPERIAL=Optional[new Locale("ja", "JP", "JP")]; String pattern; TimeZone timeZone; Locale locale; Pattern parsePattern; Strategy[] strategies; int thisYear; String currentFormatField; Strategy nextStrategy; Pattern formatPattern=Optional[Pattern.compile("D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++")]; ConcurrentMap<Locale, Strategy>[] caches=Optional[new ConcurrentMap[Calendar.FIELD_COUNT]]; Strategy ABBREVIATED_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR) {; ;     /**;      * {@inheritDoc};      */;     @Override;     void setCalendar(final FastDateParser parser, final Calendar cal, final String value) {;         int iValue = Integer.parseInt(value);;         if (iValue < 100) {;             iValue = parser.adjustYear(iValue);;         };         cal.set(Calendar.YEAR, iValue);;     }; }]; Strategy NUMBER_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.MONTH) {; ;     @Override;     int modify(final int iValue) {;         return iValue - 1;;     }; }]; Strategy LITERAL_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR)]; Strategy WEEK_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_YEAR)]; Strategy WEEK_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_MONTH)]; Strategy DAY_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_YEAR)]; Strategy DAY_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_MONTH)]; Strategy DAY_OF_WEEK_IN_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_WEEK_IN_MONTH)]; Strategy HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY)]; Strategy MODULO_HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 24;;     }; }]; Strategy MODULO_HOUR_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 12;;     }; }
private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote) { [EOL]     regex.append("\\Q"); [EOL]     for (int i = 0; i < value.length(); ++i) { [EOL]         char c = value.charAt(i); [EOL]         switch(c) { [EOL]             case '\'': [EOL]                 if (unquote) { [EOL]                     if (++i == value.length()) { [EOL]                         return regex; [EOL]                     } [EOL]                     c = value.charAt(i); [EOL]                 } [EOL]                 break; [EOL]             case '\\': [EOL]                 if (++i == value.length()) { [EOL]                     break; [EOL]                 } [EOL]                 regex.append(c); [EOL]                 c = value.charAt(i); [EOL]                 if (c == 'E') { [EOL]                     regex.append("E\\\\E\\"); [EOL]                     c = 'Q'; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         regex.append(c); [EOL]     } [EOL]     regex.append("\\E"); [EOL]     return regex; [EOL] } protected FastDateParser(final String pattern, final TimeZone timeZone, final Locale locale);  CopyQuotedStrategy(final String formatField);  TextStrategy(final int field, final Calendar definingCalendar, final Locale locale);  NumberStrategy(final int field);  TimeZoneStrategy(final Locale locale); private void init(); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale();  Pattern getParsePattern(); public boolean equals(final Object obj); public int hashCode(); public String toString(); private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException; public Object parseObject(final String source) throws ParseException; public Date parse(final String source) throws ParseException; public Object parseObject(final String source, final ParsePosition pos); public Date parse(final String source, final ParsePosition pos); private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote); private static Map<String, Integer> getDisplayNames(final int field, final Calendar definingCalendar, final Locale locale);  int adjustYear(final int twoDigitYear);  boolean isNextNumber();  int getFieldWidth();  boolean isNumber();  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  abstract boolean addRegex(FastDateParser parser, StringBuilder regex); private Strategy getStrategy(String formatField, final Calendar definingCalendar); private static ConcurrentMap<Locale, Strategy> getCache(final int field); private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  int modify(final int iValue);  int modify(final int iValue); long serialVersionUID=Optional[1L]; Locale JAPANESE_IMPERIAL=Optional[new Locale("ja", "JP", "JP")]; String pattern; TimeZone timeZone; Locale locale; Pattern parsePattern; Strategy[] strategies; int thisYear; String currentFormatField; Strategy nextStrategy; Pattern formatPattern=Optional[Pattern.compile("D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++")]; ConcurrentMap<Locale, Strategy>[] caches=Optional[new ConcurrentMap[Calendar.FIELD_COUNT]]; Strategy ABBREVIATED_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR) {; ;     /**;      * {@inheritDoc};      */;     @Override;     void setCalendar(final FastDateParser parser, final Calendar cal, final String value) {;         int iValue = Integer.parseInt(value);;         if (iValue < 100) {;             iValue = parser.adjustYear(iValue);;         };         cal.set(Calendar.YEAR, iValue);;     }; }]; Strategy NUMBER_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.MONTH) {; ;     @Override;     int modify(final int iValue) {;         return iValue - 1;;     }; }]; Strategy LITERAL_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR)]; Strategy WEEK_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_YEAR)]; Strategy WEEK_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_MONTH)]; Strategy DAY_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_YEAR)]; Strategy DAY_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_MONTH)]; Strategy DAY_OF_WEEK_IN_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_WEEK_IN_MONTH)]; Strategy HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY)]; Strategy MODULO_HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 24;;     }; }]; Strategy MODULO_HOUR_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 12;;     }; }
private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote) { [EOL]     regex.append("\\Q"); [EOL]     for (int i = 0; i < value.length(); ++i) { [EOL]         char c = value.charAt(i); [EOL]         switch(c) { [EOL]             case '\'': [EOL]                 if (unquote) { [EOL]                     if (++i == value.length()) { [EOL]                         return regex; [EOL]                     } [EOL]                     c = value.charAt(i); [EOL]                 } [EOL]                 break; [EOL]             case '\\': [EOL]                 if (++i == value.length()) { [EOL]                     break; [EOL]                 } [EOL]                 regex.append(c); [EOL]                 c = value.charAt(i); [EOL]                 if (c == 'E') { [EOL]                     regex.append("E\\\\E\\"); [EOL]                     c = 'Q'; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         regex.append(c); [EOL]     } [EOL]     regex.append("\\E"); [EOL]     return regex; [EOL] } protected FastDateParser(final String pattern, final TimeZone timeZone, final Locale locale);  CopyQuotedStrategy(final String formatField);  TextStrategy(final int field, final Calendar definingCalendar, final Locale locale);  NumberStrategy(final int field);  TimeZoneStrategy(final Locale locale); private void init(); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale();  Pattern getParsePattern(); public boolean equals(final Object obj); public int hashCode(); public String toString(); private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException; public Object parseObject(final String source) throws ParseException; public Date parse(final String source) throws ParseException; public Object parseObject(final String source, final ParsePosition pos); public Date parse(final String source, final ParsePosition pos); private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote); private static Map<String, Integer> getDisplayNames(final int field, final Calendar definingCalendar, final Locale locale);  int adjustYear(final int twoDigitYear);  boolean isNextNumber();  int getFieldWidth();  boolean isNumber();  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  abstract boolean addRegex(FastDateParser parser, StringBuilder regex); private Strategy getStrategy(String formatField, final Calendar definingCalendar); private static ConcurrentMap<Locale, Strategy> getCache(final int field); private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  int modify(final int iValue);  int modify(final int iValue); long serialVersionUID=Optional[1L]; Locale JAPANESE_IMPERIAL=Optional[new Locale("ja", "JP", "JP")]; String pattern; TimeZone timeZone; Locale locale; Pattern parsePattern; Strategy[] strategies; int thisYear; String currentFormatField; Strategy nextStrategy; Pattern formatPattern=Optional[Pattern.compile("D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++")]; ConcurrentMap<Locale, Strategy>[] caches=Optional[new ConcurrentMap[Calendar.FIELD_COUNT]]; Strategy ABBREVIATED_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR) {; ;     /**;      * {@inheritDoc};      */;     @Override;     void setCalendar(final FastDateParser parser, final Calendar cal, final String value) {;         int iValue = Integer.parseInt(value);;         if (iValue < 100) {;             iValue = parser.adjustYear(iValue);;         };         cal.set(Calendar.YEAR, iValue);;     }; }]; Strategy NUMBER_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.MONTH) {; ;     @Override;     int modify(final int iValue) {;         return iValue - 1;;     }; }]; Strategy LITERAL_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR)]; Strategy WEEK_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_YEAR)]; Strategy WEEK_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_MONTH)]; Strategy DAY_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_YEAR)]; Strategy DAY_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_MONTH)]; Strategy DAY_OF_WEEK_IN_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_WEEK_IN_MONTH)]; Strategy HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY)]; Strategy MODULO_HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 24;;     }; }]; Strategy MODULO_HOUR_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 12;;     }; }
private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote) { [EOL]     regex.append("\\Q"); [EOL]     for (int i = 0; i < value.length(); ++i) { [EOL]         char c = value.charAt(i); [EOL]         switch(c) { [EOL]             case '\'': [EOL]                 if (unquote) { [EOL]                     if (++i == value.length()) { [EOL]                         return regex; [EOL]                     } [EOL]                     c = value.charAt(i); [EOL]                 } [EOL]                 break; [EOL]             case '\\': [EOL]                 if (++i == value.length()) { [EOL]                     break; [EOL]                 } [EOL]                 regex.append(c); [EOL]                 c = value.charAt(i); [EOL]                 if (c == 'E') { [EOL]                     regex.append("E\\\\E\\"); [EOL]                     c = 'Q'; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         regex.append(c); [EOL]     } [EOL]     regex.append("\\E"); [EOL]     return regex; [EOL] } protected FastDateParser(final String pattern, final TimeZone timeZone, final Locale locale);  CopyQuotedStrategy(final String formatField);  TextStrategy(final int field, final Calendar definingCalendar, final Locale locale);  NumberStrategy(final int field);  TimeZoneStrategy(final Locale locale); private void init(); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale();  Pattern getParsePattern(); public boolean equals(final Object obj); public int hashCode(); public String toString(); private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException; public Object parseObject(final String source) throws ParseException; public Date parse(final String source) throws ParseException; public Object parseObject(final String source, final ParsePosition pos); public Date parse(final String source, final ParsePosition pos); private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote); private static Map<String, Integer> getDisplayNames(final int field, final Calendar definingCalendar, final Locale locale);  int adjustYear(final int twoDigitYear);  boolean isNextNumber();  int getFieldWidth();  boolean isNumber();  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  abstract boolean addRegex(FastDateParser parser, StringBuilder regex); private Strategy getStrategy(String formatField, final Calendar definingCalendar); private static ConcurrentMap<Locale, Strategy> getCache(final int field); private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  int modify(final int iValue);  int modify(final int iValue); long serialVersionUID=Optional[1L]; Locale JAPANESE_IMPERIAL=Optional[new Locale("ja", "JP", "JP")]; String pattern; TimeZone timeZone; Locale locale; Pattern parsePattern; Strategy[] strategies; int thisYear; String currentFormatField; Strategy nextStrategy; Pattern formatPattern=Optional[Pattern.compile("D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++")]; ConcurrentMap<Locale, Strategy>[] caches=Optional[new ConcurrentMap[Calendar.FIELD_COUNT]]; Strategy ABBREVIATED_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR) {; ;     /**;      * {@inheritDoc};      */;     @Override;     void setCalendar(final FastDateParser parser, final Calendar cal, final String value) {;         int iValue = Integer.parseInt(value);;         if (iValue < 100) {;             iValue = parser.adjustYear(iValue);;         };         cal.set(Calendar.YEAR, iValue);;     }; }]; Strategy NUMBER_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.MONTH) {; ;     @Override;     int modify(final int iValue) {;         return iValue - 1;;     }; }]; Strategy LITERAL_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR)]; Strategy WEEK_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_YEAR)]; Strategy WEEK_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_MONTH)]; Strategy DAY_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_YEAR)]; Strategy DAY_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_MONTH)]; Strategy DAY_OF_WEEK_IN_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_WEEK_IN_MONTH)]; Strategy HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY)]; Strategy MODULO_HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 24;;     }; }]; Strategy MODULO_HOUR_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 12;;     }; }
int adjustYear(final int twoDigitYear) { [EOL]     final int trial = twoDigitYear + thisYear - thisYear % 100; [EOL]     if (trial < thisYear + 20) { [EOL]         return trial; [EOL]     } [EOL]     return trial - 100; [EOL] } protected FastDateParser(final String pattern, final TimeZone timeZone, final Locale locale);  CopyQuotedStrategy(final String formatField);  TextStrategy(final int field, final Calendar definingCalendar, final Locale locale);  NumberStrategy(final int field);  TimeZoneStrategy(final Locale locale); private void init(); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale();  Pattern getParsePattern(); public boolean equals(final Object obj); public int hashCode(); public String toString(); private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException; public Object parseObject(final String source) throws ParseException; public Date parse(final String source) throws ParseException; public Object parseObject(final String source, final ParsePosition pos); public Date parse(final String source, final ParsePosition pos); private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote); private static Map<String, Integer> getDisplayNames(final int field, final Calendar definingCalendar, final Locale locale);  int adjustYear(final int twoDigitYear);  boolean isNextNumber();  int getFieldWidth();  boolean isNumber();  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  abstract boolean addRegex(FastDateParser parser, StringBuilder regex); private Strategy getStrategy(String formatField, final Calendar definingCalendar); private static ConcurrentMap<Locale, Strategy> getCache(final int field); private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  int modify(final int iValue);  int modify(final int iValue); long serialVersionUID=Optional[1L]; Locale JAPANESE_IMPERIAL=Optional[new Locale("ja", "JP", "JP")]; String pattern; TimeZone timeZone; Locale locale; Pattern parsePattern; Strategy[] strategies; int thisYear; String currentFormatField; Strategy nextStrategy; Pattern formatPattern=Optional[Pattern.compile("D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++")]; ConcurrentMap<Locale, Strategy>[] caches=Optional[new ConcurrentMap[Calendar.FIELD_COUNT]]; Strategy ABBREVIATED_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR) {; ;     /**;      * {@inheritDoc};      */;     @Override;     void setCalendar(final FastDateParser parser, final Calendar cal, final String value) {;         int iValue = Integer.parseInt(value);;         if (iValue < 100) {;             iValue = parser.adjustYear(iValue);;         };         cal.set(Calendar.YEAR, iValue);;     }; }]; Strategy NUMBER_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.MONTH) {; ;     @Override;     int modify(final int iValue) {;         return iValue - 1;;     }; }]; Strategy LITERAL_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR)]; Strategy WEEK_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_YEAR)]; Strategy WEEK_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_MONTH)]; Strategy DAY_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_YEAR)]; Strategy DAY_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_MONTH)]; Strategy DAY_OF_WEEK_IN_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_WEEK_IN_MONTH)]; Strategy HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY)]; Strategy MODULO_HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 24;;     }; }]; Strategy MODULO_HOUR_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 12;;     }; }
int adjustYear(final int twoDigitYear) { [EOL]     final int trial = twoDigitYear + thisYear - thisYear % 100; [EOL]     if (trial < thisYear + 20) { [EOL]         return trial; [EOL]     } [EOL]     return trial - 100; [EOL] } protected FastDateParser(final String pattern, final TimeZone timeZone, final Locale locale);  CopyQuotedStrategy(final String formatField);  TextStrategy(final int field, final Calendar definingCalendar, final Locale locale);  NumberStrategy(final int field);  TimeZoneStrategy(final Locale locale); private void init(); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale();  Pattern getParsePattern(); public boolean equals(final Object obj); public int hashCode(); public String toString(); private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException; public Object parseObject(final String source) throws ParseException; public Date parse(final String source) throws ParseException; public Object parseObject(final String source, final ParsePosition pos); public Date parse(final String source, final ParsePosition pos); private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote); private static Map<String, Integer> getDisplayNames(final int field, final Calendar definingCalendar, final Locale locale);  int adjustYear(final int twoDigitYear);  boolean isNextNumber();  int getFieldWidth();  boolean isNumber();  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  abstract boolean addRegex(FastDateParser parser, StringBuilder regex); private Strategy getStrategy(String formatField, final Calendar definingCalendar); private static ConcurrentMap<Locale, Strategy> getCache(final int field); private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  int modify(final int iValue);  int modify(final int iValue); long serialVersionUID=Optional[1L]; Locale JAPANESE_IMPERIAL=Optional[new Locale("ja", "JP", "JP")]; String pattern; TimeZone timeZone; Locale locale; Pattern parsePattern; Strategy[] strategies; int thisYear; String currentFormatField; Strategy nextStrategy; Pattern formatPattern=Optional[Pattern.compile("D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++")]; ConcurrentMap<Locale, Strategy>[] caches=Optional[new ConcurrentMap[Calendar.FIELD_COUNT]]; Strategy ABBREVIATED_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR) {; ;     /**;      * {@inheritDoc};      */;     @Override;     void setCalendar(final FastDateParser parser, final Calendar cal, final String value) {;         int iValue = Integer.parseInt(value);;         if (iValue < 100) {;             iValue = parser.adjustYear(iValue);;         };         cal.set(Calendar.YEAR, iValue);;     }; }]; Strategy NUMBER_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.MONTH) {; ;     @Override;     int modify(final int iValue) {;         return iValue - 1;;     }; }]; Strategy LITERAL_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR)]; Strategy WEEK_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_YEAR)]; Strategy WEEK_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_MONTH)]; Strategy DAY_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_YEAR)]; Strategy DAY_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_MONTH)]; Strategy DAY_OF_WEEK_IN_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_WEEK_IN_MONTH)]; Strategy HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY)]; Strategy MODULO_HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 24;;     }; }]; Strategy MODULO_HOUR_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 12;;     }; }
int adjustYear(final int twoDigitYear) { [EOL]     final int trial = twoDigitYear + thisYear - thisYear % 100; [EOL]     if (trial < thisYear + 20) { [EOL]         return trial; [EOL]     } [EOL]     return trial - 100; [EOL] } protected FastDateParser(final String pattern, final TimeZone timeZone, final Locale locale);  CopyQuotedStrategy(final String formatField);  TextStrategy(final int field, final Calendar definingCalendar, final Locale locale);  NumberStrategy(final int field);  TimeZoneStrategy(final Locale locale); private void init(); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale();  Pattern getParsePattern(); public boolean equals(final Object obj); public int hashCode(); public String toString(); private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException; public Object parseObject(final String source) throws ParseException; public Date parse(final String source) throws ParseException; public Object parseObject(final String source, final ParsePosition pos); public Date parse(final String source, final ParsePosition pos); private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote); private static Map<String, Integer> getDisplayNames(final int field, final Calendar definingCalendar, final Locale locale);  int adjustYear(final int twoDigitYear);  boolean isNextNumber();  int getFieldWidth();  boolean isNumber();  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  abstract boolean addRegex(FastDateParser parser, StringBuilder regex); private Strategy getStrategy(String formatField, final Calendar definingCalendar); private static ConcurrentMap<Locale, Strategy> getCache(final int field); private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  int modify(final int iValue);  int modify(final int iValue); long serialVersionUID=Optional[1L]; Locale JAPANESE_IMPERIAL=Optional[new Locale("ja", "JP", "JP")]; String pattern; TimeZone timeZone; Locale locale; Pattern parsePattern; Strategy[] strategies; int thisYear; String currentFormatField; Strategy nextStrategy; Pattern formatPattern=Optional[Pattern.compile("D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++")]; ConcurrentMap<Locale, Strategy>[] caches=Optional[new ConcurrentMap[Calendar.FIELD_COUNT]]; Strategy ABBREVIATED_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR) {; ;     /**;      * {@inheritDoc};      */;     @Override;     void setCalendar(final FastDateParser parser, final Calendar cal, final String value) {;         int iValue = Integer.parseInt(value);;         if (iValue < 100) {;             iValue = parser.adjustYear(iValue);;         };         cal.set(Calendar.YEAR, iValue);;     }; }]; Strategy NUMBER_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.MONTH) {; ;     @Override;     int modify(final int iValue) {;         return iValue - 1;;     }; }]; Strategy LITERAL_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR)]; Strategy WEEK_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_YEAR)]; Strategy WEEK_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_MONTH)]; Strategy DAY_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_YEAR)]; Strategy DAY_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_MONTH)]; Strategy DAY_OF_WEEK_IN_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_WEEK_IN_MONTH)]; Strategy HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY)]; Strategy MODULO_HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 24;;     }; }]; Strategy MODULO_HOUR_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 12;;     }; }
boolean isNextNumber() { [EOL]     return nextStrategy != null && nextStrategy.isNumber(); [EOL] } protected FastDateParser(final String pattern, final TimeZone timeZone, final Locale locale);  CopyQuotedStrategy(final String formatField);  TextStrategy(final int field, final Calendar definingCalendar, final Locale locale);  NumberStrategy(final int field);  TimeZoneStrategy(final Locale locale); private void init(); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale();  Pattern getParsePattern(); public boolean equals(final Object obj); public int hashCode(); public String toString(); private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException; public Object parseObject(final String source) throws ParseException; public Date parse(final String source) throws ParseException; public Object parseObject(final String source, final ParsePosition pos); public Date parse(final String source, final ParsePosition pos); private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote); private static Map<String, Integer> getDisplayNames(final int field, final Calendar definingCalendar, final Locale locale);  int adjustYear(final int twoDigitYear);  boolean isNextNumber();  int getFieldWidth();  boolean isNumber();  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  abstract boolean addRegex(FastDateParser parser, StringBuilder regex); private Strategy getStrategy(String formatField, final Calendar definingCalendar); private static ConcurrentMap<Locale, Strategy> getCache(final int field); private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  int modify(final int iValue);  int modify(final int iValue); long serialVersionUID=Optional[1L]; Locale JAPANESE_IMPERIAL=Optional[new Locale("ja", "JP", "JP")]; String pattern; TimeZone timeZone; Locale locale; Pattern parsePattern; Strategy[] strategies; int thisYear; String currentFormatField; Strategy nextStrategy; Pattern formatPattern=Optional[Pattern.compile("D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++")]; ConcurrentMap<Locale, Strategy>[] caches=Optional[new ConcurrentMap[Calendar.FIELD_COUNT]]; Strategy ABBREVIATED_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR) {; ;     /**;      * {@inheritDoc};      */;     @Override;     void setCalendar(final FastDateParser parser, final Calendar cal, final String value) {;         int iValue = Integer.parseInt(value);;         if (iValue < 100) {;             iValue = parser.adjustYear(iValue);;         };         cal.set(Calendar.YEAR, iValue);;     }; }]; Strategy NUMBER_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.MONTH) {; ;     @Override;     int modify(final int iValue) {;         return iValue - 1;;     }; }]; Strategy LITERAL_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR)]; Strategy WEEK_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_YEAR)]; Strategy WEEK_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_MONTH)]; Strategy DAY_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_YEAR)]; Strategy DAY_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_MONTH)]; Strategy DAY_OF_WEEK_IN_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_WEEK_IN_MONTH)]; Strategy HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY)]; Strategy MODULO_HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 24;;     }; }]; Strategy MODULO_HOUR_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 12;;     }; }
boolean isNextNumber() { [EOL]     return nextStrategy != null && nextStrategy.isNumber(); [EOL] } protected FastDateParser(final String pattern, final TimeZone timeZone, final Locale locale);  CopyQuotedStrategy(final String formatField);  TextStrategy(final int field, final Calendar definingCalendar, final Locale locale);  NumberStrategy(final int field);  TimeZoneStrategy(final Locale locale); private void init(); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale();  Pattern getParsePattern(); public boolean equals(final Object obj); public int hashCode(); public String toString(); private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException; public Object parseObject(final String source) throws ParseException; public Date parse(final String source) throws ParseException; public Object parseObject(final String source, final ParsePosition pos); public Date parse(final String source, final ParsePosition pos); private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote); private static Map<String, Integer> getDisplayNames(final int field, final Calendar definingCalendar, final Locale locale);  int adjustYear(final int twoDigitYear);  boolean isNextNumber();  int getFieldWidth();  boolean isNumber();  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  abstract boolean addRegex(FastDateParser parser, StringBuilder regex); private Strategy getStrategy(String formatField, final Calendar definingCalendar); private static ConcurrentMap<Locale, Strategy> getCache(final int field); private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  int modify(final int iValue);  int modify(final int iValue); long serialVersionUID=Optional[1L]; Locale JAPANESE_IMPERIAL=Optional[new Locale("ja", "JP", "JP")]; String pattern; TimeZone timeZone; Locale locale; Pattern parsePattern; Strategy[] strategies; int thisYear; String currentFormatField; Strategy nextStrategy; Pattern formatPattern=Optional[Pattern.compile("D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++")]; ConcurrentMap<Locale, Strategy>[] caches=Optional[new ConcurrentMap[Calendar.FIELD_COUNT]]; Strategy ABBREVIATED_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR) {; ;     /**;      * {@inheritDoc};      */;     @Override;     void setCalendar(final FastDateParser parser, final Calendar cal, final String value) {;         int iValue = Integer.parseInt(value);;         if (iValue < 100) {;             iValue = parser.adjustYear(iValue);;         };         cal.set(Calendar.YEAR, iValue);;     }; }]; Strategy NUMBER_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.MONTH) {; ;     @Override;     int modify(final int iValue) {;         return iValue - 1;;     }; }]; Strategy LITERAL_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR)]; Strategy WEEK_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_YEAR)]; Strategy WEEK_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_MONTH)]; Strategy DAY_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_YEAR)]; Strategy DAY_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_MONTH)]; Strategy DAY_OF_WEEK_IN_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_WEEK_IN_MONTH)]; Strategy HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY)]; Strategy MODULO_HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 24;;     }; }]; Strategy MODULO_HOUR_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 12;;     }; }
private Strategy getStrategy(String formatField, final Calendar definingCalendar) { [EOL]     switch(formatField.charAt(0)) { [EOL]         case '\'': [EOL]             if (formatField.length() > 2) { [EOL]                 formatField = formatField.substring(1, formatField.length() - 1); [EOL]             } [EOL]         default: [EOL]             return new CopyQuotedStrategy(formatField); [EOL]         case 'D': [EOL]             return DAY_OF_YEAR_STRATEGY; [EOL]         case 'E': [EOL]             return getLocaleSpecificStrategy(Calendar.DAY_OF_WEEK, definingCalendar); [EOL]         case 'F': [EOL]             return DAY_OF_WEEK_IN_MONTH_STRATEGY; [EOL]         case 'G': [EOL]             return getLocaleSpecificStrategy(Calendar.ERA, definingCalendar); [EOL]         case 'H': [EOL]             return MODULO_HOUR_OF_DAY_STRATEGY; [EOL]         case 'K': [EOL]             return HOUR_STRATEGY; [EOL]         case 'M': [EOL]             return formatField.length() >= 3 ? getLocaleSpecificStrategy(Calendar.MONTH, definingCalendar) : NUMBER_MONTH_STRATEGY; [EOL]         case 'S': [EOL]             return MILLISECOND_STRATEGY; [EOL]         case 'W': [EOL]             return WEEK_OF_MONTH_STRATEGY; [EOL]         case 'a': [EOL]             return getLocaleSpecificStrategy(Calendar.AM_PM, definingCalendar); [EOL]         case 'd': [EOL]             return DAY_OF_MONTH_STRATEGY; [EOL]         case 'h': [EOL]             return MODULO_HOUR_STRATEGY; [EOL]         case 'k': [EOL]             return HOUR_OF_DAY_STRATEGY; [EOL]         case 'm': [EOL]             return MINUTE_STRATEGY; [EOL]         case 's': [EOL]             return SECOND_STRATEGY; [EOL]         case 'w': [EOL]             return WEEK_OF_YEAR_STRATEGY; [EOL]         case 'y': [EOL]             return formatField.length() > 2 ? LITERAL_YEAR_STRATEGY : ABBREVIATED_YEAR_STRATEGY; [EOL]         case 'Z': [EOL]         case 'z': [EOL]             return getLocaleSpecificStrategy(Calendar.ZONE_OFFSET, definingCalendar); [EOL]     } [EOL] } protected FastDateParser(final String pattern, final TimeZone timeZone, final Locale locale);  CopyQuotedStrategy(final String formatField);  TextStrategy(final int field, final Calendar definingCalendar, final Locale locale);  NumberStrategy(final int field);  TimeZoneStrategy(final Locale locale); private void init(); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale();  Pattern getParsePattern(); public boolean equals(final Object obj); public int hashCode(); public String toString(); private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException; public Object parseObject(final String source) throws ParseException; public Date parse(final String source) throws ParseException; public Object parseObject(final String source, final ParsePosition pos); public Date parse(final String source, final ParsePosition pos); private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote); private static Map<String, Integer> getDisplayNames(final int field, final Calendar definingCalendar, final Locale locale);  int adjustYear(final int twoDigitYear);  boolean isNextNumber();  int getFieldWidth();  boolean isNumber();  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  abstract boolean addRegex(FastDateParser parser, StringBuilder regex); private Strategy getStrategy(String formatField, final Calendar definingCalendar); private static ConcurrentMap<Locale, Strategy> getCache(final int field); private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  int modify(final int iValue);  int modify(final int iValue); long serialVersionUID=Optional[1L]; Locale JAPANESE_IMPERIAL=Optional[new Locale("ja", "JP", "JP")]; String pattern; TimeZone timeZone; Locale locale; Pattern parsePattern; Strategy[] strategies; int thisYear; String currentFormatField; Strategy nextStrategy; Pattern formatPattern=Optional[Pattern.compile("D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++")]; ConcurrentMap<Locale, Strategy>[] caches=Optional[new ConcurrentMap[Calendar.FIELD_COUNT]]; Strategy ABBREVIATED_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR) {; ;     /**;      * {@inheritDoc};      */;     @Override;     void setCalendar(final FastDateParser parser, final Calendar cal, final String value) {;         int iValue = Integer.parseInt(value);;         if (iValue < 100) {;             iValue = parser.adjustYear(iValue);;         };         cal.set(Calendar.YEAR, iValue);;     }; }]; Strategy NUMBER_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.MONTH) {; ;     @Override;     int modify(final int iValue) {;         return iValue - 1;;     }; }]; Strategy LITERAL_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR)]; Strategy WEEK_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_YEAR)]; Strategy WEEK_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_MONTH)]; Strategy DAY_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_YEAR)]; Strategy DAY_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_MONTH)]; Strategy DAY_OF_WEEK_IN_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_WEEK_IN_MONTH)]; Strategy HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY)]; Strategy MODULO_HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 24;;     }; }]; Strategy MODULO_HOUR_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 12;;     }; }
private static ConcurrentMap<Locale, Strategy> getCache(final int field) { [EOL]     synchronized (caches) { [EOL]         if (caches[field] == null) { [EOL]             caches[field] = new ConcurrentHashMap<Locale, Strategy>(3); [EOL]         } [EOL]         return caches[field]; [EOL]     } [EOL] } protected FastDateParser(final String pattern, final TimeZone timeZone, final Locale locale);  CopyQuotedStrategy(final String formatField);  TextStrategy(final int field, final Calendar definingCalendar, final Locale locale);  NumberStrategy(final int field);  TimeZoneStrategy(final Locale locale); private void init(); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale();  Pattern getParsePattern(); public boolean equals(final Object obj); public int hashCode(); public String toString(); private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException; public Object parseObject(final String source) throws ParseException; public Date parse(final String source) throws ParseException; public Object parseObject(final String source, final ParsePosition pos); public Date parse(final String source, final ParsePosition pos); private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote); private static Map<String, Integer> getDisplayNames(final int field, final Calendar definingCalendar, final Locale locale);  int adjustYear(final int twoDigitYear);  boolean isNextNumber();  int getFieldWidth();  boolean isNumber();  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  abstract boolean addRegex(FastDateParser parser, StringBuilder regex); private Strategy getStrategy(String formatField, final Calendar definingCalendar); private static ConcurrentMap<Locale, Strategy> getCache(final int field); private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  int modify(final int iValue);  int modify(final int iValue); long serialVersionUID=Optional[1L]; Locale JAPANESE_IMPERIAL=Optional[new Locale("ja", "JP", "JP")]; String pattern; TimeZone timeZone; Locale locale; Pattern parsePattern; Strategy[] strategies; int thisYear; String currentFormatField; Strategy nextStrategy; Pattern formatPattern=Optional[Pattern.compile("D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++")]; ConcurrentMap<Locale, Strategy>[] caches=Optional[new ConcurrentMap[Calendar.FIELD_COUNT]]; Strategy ABBREVIATED_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR) {; ;     /**;      * {@inheritDoc};      */;     @Override;     void setCalendar(final FastDateParser parser, final Calendar cal, final String value) {;         int iValue = Integer.parseInt(value);;         if (iValue < 100) {;             iValue = parser.adjustYear(iValue);;         };         cal.set(Calendar.YEAR, iValue);;     }; }]; Strategy NUMBER_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.MONTH) {; ;     @Override;     int modify(final int iValue) {;         return iValue - 1;;     }; }]; Strategy LITERAL_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR)]; Strategy WEEK_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_YEAR)]; Strategy WEEK_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_MONTH)]; Strategy DAY_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_YEAR)]; Strategy DAY_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_MONTH)]; Strategy DAY_OF_WEEK_IN_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_WEEK_IN_MONTH)]; Strategy HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY)]; Strategy MODULO_HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 24;;     }; }]; Strategy MODULO_HOUR_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 12;;     }; }
private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar) { [EOL]     final ConcurrentMap<Locale, Strategy> cache = getCache(field); [EOL]     Strategy strategy = cache.get(locale); [EOL]     if (strategy == null) { [EOL]         strategy = field == Calendar.ZONE_OFFSET ? new TimeZoneStrategy(locale) : new TextStrategy(field, definingCalendar, locale); [EOL]         final Strategy inCache = cache.putIfAbsent(locale, strategy); [EOL]         if (inCache != null) { [EOL]             return inCache; [EOL]         } [EOL]     } [EOL]     return strategy; [EOL] } protected FastDateParser(final String pattern, final TimeZone timeZone, final Locale locale);  CopyQuotedStrategy(final String formatField);  TextStrategy(final int field, final Calendar definingCalendar, final Locale locale);  NumberStrategy(final int field);  TimeZoneStrategy(final Locale locale); private void init(); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale();  Pattern getParsePattern(); public boolean equals(final Object obj); public int hashCode(); public String toString(); private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException; public Object parseObject(final String source) throws ParseException; public Date parse(final String source) throws ParseException; public Object parseObject(final String source, final ParsePosition pos); public Date parse(final String source, final ParsePosition pos); private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote); private static Map<String, Integer> getDisplayNames(final int field, final Calendar definingCalendar, final Locale locale);  int adjustYear(final int twoDigitYear);  boolean isNextNumber();  int getFieldWidth();  boolean isNumber();  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  abstract boolean addRegex(FastDateParser parser, StringBuilder regex); private Strategy getStrategy(String formatField, final Calendar definingCalendar); private static ConcurrentMap<Locale, Strategy> getCache(final int field); private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  int modify(final int iValue);  int modify(final int iValue); long serialVersionUID=Optional[1L]; Locale JAPANESE_IMPERIAL=Optional[new Locale("ja", "JP", "JP")]; String pattern; TimeZone timeZone; Locale locale; Pattern parsePattern; Strategy[] strategies; int thisYear; String currentFormatField; Strategy nextStrategy; Pattern formatPattern=Optional[Pattern.compile("D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++")]; ConcurrentMap<Locale, Strategy>[] caches=Optional[new ConcurrentMap[Calendar.FIELD_COUNT]]; Strategy ABBREVIATED_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR) {; ;     /**;      * {@inheritDoc};      */;     @Override;     void setCalendar(final FastDateParser parser, final Calendar cal, final String value) {;         int iValue = Integer.parseInt(value);;         if (iValue < 100) {;             iValue = parser.adjustYear(iValue);;         };         cal.set(Calendar.YEAR, iValue);;     }; }]; Strategy NUMBER_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.MONTH) {; ;     @Override;     int modify(final int iValue) {;         return iValue - 1;;     }; }]; Strategy LITERAL_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR)]; Strategy WEEK_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_YEAR)]; Strategy WEEK_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_MONTH)]; Strategy DAY_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_YEAR)]; Strategy DAY_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_MONTH)]; Strategy DAY_OF_WEEK_IN_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_WEEK_IN_MONTH)]; Strategy HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY)]; Strategy MODULO_HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 24;;     }; }]; Strategy MODULO_HOUR_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 12;;     }; }
CopyQuotedStrategy(final String formatField) { [EOL]     this.formatField = formatField; [EOL] } protected FastDateParser(final String pattern, final TimeZone timeZone, final Locale locale);  CopyQuotedStrategy(final String formatField);  TextStrategy(final int field, final Calendar definingCalendar, final Locale locale);  NumberStrategy(final int field);  TimeZoneStrategy(final Locale locale); private void init(); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale();  Pattern getParsePattern(); public boolean equals(final Object obj); public int hashCode(); public String toString(); private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException; public Object parseObject(final String source) throws ParseException; public Date parse(final String source) throws ParseException; public Object parseObject(final String source, final ParsePosition pos); public Date parse(final String source, final ParsePosition pos); private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote); private static Map<String, Integer> getDisplayNames(final int field, final Calendar definingCalendar, final Locale locale);  int adjustYear(final int twoDigitYear);  boolean isNextNumber();  int getFieldWidth();  boolean isNumber();  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  abstract boolean addRegex(FastDateParser parser, StringBuilder regex); private Strategy getStrategy(String formatField, final Calendar definingCalendar); private static ConcurrentMap<Locale, Strategy> getCache(final int field); private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  int modify(final int iValue);  int modify(final int iValue); long serialVersionUID=Optional[1L]; Locale JAPANESE_IMPERIAL=Optional[new Locale("ja", "JP", "JP")]; String pattern; TimeZone timeZone; Locale locale; Pattern parsePattern; Strategy[] strategies; int thisYear; String currentFormatField; Strategy nextStrategy; Pattern formatPattern=Optional[Pattern.compile("D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++")]; ConcurrentMap<Locale, Strategy>[] caches=Optional[new ConcurrentMap[Calendar.FIELD_COUNT]]; Strategy ABBREVIATED_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR) {; ;     /**;      * {@inheritDoc};      */;     @Override;     void setCalendar(final FastDateParser parser, final Calendar cal, final String value) {;         int iValue = Integer.parseInt(value);;         if (iValue < 100) {;             iValue = parser.adjustYear(iValue);;         };         cal.set(Calendar.YEAR, iValue);;     }; }]; Strategy NUMBER_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.MONTH) {; ;     @Override;     int modify(final int iValue) {;         return iValue - 1;;     }; }]; Strategy LITERAL_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR)]; Strategy WEEK_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_YEAR)]; Strategy WEEK_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_MONTH)]; Strategy DAY_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_YEAR)]; Strategy DAY_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_MONTH)]; Strategy DAY_OF_WEEK_IN_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_WEEK_IN_MONTH)]; Strategy HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY)]; Strategy MODULO_HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 24;;     }; }]; Strategy MODULO_HOUR_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 12;;     }; }
@Override [EOL] boolean isNumber() { [EOL]     char c = formatField.charAt(0); [EOL]     if (c == '\'') { [EOL]         c = formatField.charAt(1); [EOL]     } [EOL]     return Character.isDigit(c); [EOL] } protected FastDateParser(final String pattern, final TimeZone timeZone, final Locale locale);  CopyQuotedStrategy(final String formatField);  TextStrategy(final int field, final Calendar definingCalendar, final Locale locale);  NumberStrategy(final int field);  TimeZoneStrategy(final Locale locale); private void init(); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale();  Pattern getParsePattern(); public boolean equals(final Object obj); public int hashCode(); public String toString(); private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException; public Object parseObject(final String source) throws ParseException; public Date parse(final String source) throws ParseException; public Object parseObject(final String source, final ParsePosition pos); public Date parse(final String source, final ParsePosition pos); private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote); private static Map<String, Integer> getDisplayNames(final int field, final Calendar definingCalendar, final Locale locale);  int adjustYear(final int twoDigitYear);  boolean isNextNumber();  int getFieldWidth();  boolean isNumber();  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  abstract boolean addRegex(FastDateParser parser, StringBuilder regex); private Strategy getStrategy(String formatField, final Calendar definingCalendar); private static ConcurrentMap<Locale, Strategy> getCache(final int field); private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  int modify(final int iValue);  int modify(final int iValue); long serialVersionUID=Optional[1L]; Locale JAPANESE_IMPERIAL=Optional[new Locale("ja", "JP", "JP")]; String pattern; TimeZone timeZone; Locale locale; Pattern parsePattern; Strategy[] strategies; int thisYear; String currentFormatField; Strategy nextStrategy; Pattern formatPattern=Optional[Pattern.compile("D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++")]; ConcurrentMap<Locale, Strategy>[] caches=Optional[new ConcurrentMap[Calendar.FIELD_COUNT]]; Strategy ABBREVIATED_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR) {; ;     /**;      * {@inheritDoc};      */;     @Override;     void setCalendar(final FastDateParser parser, final Calendar cal, final String value) {;         int iValue = Integer.parseInt(value);;         if (iValue < 100) {;             iValue = parser.adjustYear(iValue);;         };         cal.set(Calendar.YEAR, iValue);;     }; }]; Strategy NUMBER_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.MONTH) {; ;     @Override;     int modify(final int iValue) {;         return iValue - 1;;     }; }]; Strategy LITERAL_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR)]; Strategy WEEK_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_YEAR)]; Strategy WEEK_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_MONTH)]; Strategy DAY_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_YEAR)]; Strategy DAY_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_MONTH)]; Strategy DAY_OF_WEEK_IN_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_WEEK_IN_MONTH)]; Strategy HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY)]; Strategy MODULO_HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 24;;     }; }]; Strategy MODULO_HOUR_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 12;;     }; }
@Override [EOL] boolean isNumber() { [EOL]     char c = formatField.charAt(0); [EOL]     if (c == '\'') { [EOL]         c = formatField.charAt(1); [EOL]     } [EOL]     return Character.isDigit(c); [EOL] } protected FastDateParser(final String pattern, final TimeZone timeZone, final Locale locale);  CopyQuotedStrategy(final String formatField);  TextStrategy(final int field, final Calendar definingCalendar, final Locale locale);  NumberStrategy(final int field);  TimeZoneStrategy(final Locale locale); private void init(); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale();  Pattern getParsePattern(); public boolean equals(final Object obj); public int hashCode(); public String toString(); private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException; public Object parseObject(final String source) throws ParseException; public Date parse(final String source) throws ParseException; public Object parseObject(final String source, final ParsePosition pos); public Date parse(final String source, final ParsePosition pos); private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote); private static Map<String, Integer> getDisplayNames(final int field, final Calendar definingCalendar, final Locale locale);  int adjustYear(final int twoDigitYear);  boolean isNextNumber();  int getFieldWidth();  boolean isNumber();  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  abstract boolean addRegex(FastDateParser parser, StringBuilder regex); private Strategy getStrategy(String formatField, final Calendar definingCalendar); private static ConcurrentMap<Locale, Strategy> getCache(final int field); private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  int modify(final int iValue);  int modify(final int iValue); long serialVersionUID=Optional[1L]; Locale JAPANESE_IMPERIAL=Optional[new Locale("ja", "JP", "JP")]; String pattern; TimeZone timeZone; Locale locale; Pattern parsePattern; Strategy[] strategies; int thisYear; String currentFormatField; Strategy nextStrategy; Pattern formatPattern=Optional[Pattern.compile("D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++")]; ConcurrentMap<Locale, Strategy>[] caches=Optional[new ConcurrentMap[Calendar.FIELD_COUNT]]; Strategy ABBREVIATED_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR) {; ;     /**;      * {@inheritDoc};      */;     @Override;     void setCalendar(final FastDateParser parser, final Calendar cal, final String value) {;         int iValue = Integer.parseInt(value);;         if (iValue < 100) {;             iValue = parser.adjustYear(iValue);;         };         cal.set(Calendar.YEAR, iValue);;     }; }]; Strategy NUMBER_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.MONTH) {; ;     @Override;     int modify(final int iValue) {;         return iValue - 1;;     }; }]; Strategy LITERAL_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR)]; Strategy WEEK_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_YEAR)]; Strategy WEEK_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_MONTH)]; Strategy DAY_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_YEAR)]; Strategy DAY_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_MONTH)]; Strategy DAY_OF_WEEK_IN_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_WEEK_IN_MONTH)]; Strategy HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY)]; Strategy MODULO_HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 24;;     }; }]; Strategy MODULO_HOUR_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 12;;     }; }
@Override [EOL] boolean isNumber() { [EOL]     char c = formatField.charAt(0); [EOL]     if (c == '\'') { [EOL]         c = formatField.charAt(1); [EOL]     } [EOL]     return Character.isDigit(c); [EOL] } protected FastDateParser(final String pattern, final TimeZone timeZone, final Locale locale);  CopyQuotedStrategy(final String formatField);  TextStrategy(final int field, final Calendar definingCalendar, final Locale locale);  NumberStrategy(final int field);  TimeZoneStrategy(final Locale locale); private void init(); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale();  Pattern getParsePattern(); public boolean equals(final Object obj); public int hashCode(); public String toString(); private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException; public Object parseObject(final String source) throws ParseException; public Date parse(final String source) throws ParseException; public Object parseObject(final String source, final ParsePosition pos); public Date parse(final String source, final ParsePosition pos); private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote); private static Map<String, Integer> getDisplayNames(final int field, final Calendar definingCalendar, final Locale locale);  int adjustYear(final int twoDigitYear);  boolean isNextNumber();  int getFieldWidth();  boolean isNumber();  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  abstract boolean addRegex(FastDateParser parser, StringBuilder regex); private Strategy getStrategy(String formatField, final Calendar definingCalendar); private static ConcurrentMap<Locale, Strategy> getCache(final int field); private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  int modify(final int iValue);  int modify(final int iValue); long serialVersionUID=Optional[1L]; Locale JAPANESE_IMPERIAL=Optional[new Locale("ja", "JP", "JP")]; String pattern; TimeZone timeZone; Locale locale; Pattern parsePattern; Strategy[] strategies; int thisYear; String currentFormatField; Strategy nextStrategy; Pattern formatPattern=Optional[Pattern.compile("D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++")]; ConcurrentMap<Locale, Strategy>[] caches=Optional[new ConcurrentMap[Calendar.FIELD_COUNT]]; Strategy ABBREVIATED_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR) {; ;     /**;      * {@inheritDoc};      */;     @Override;     void setCalendar(final FastDateParser parser, final Calendar cal, final String value) {;         int iValue = Integer.parseInt(value);;         if (iValue < 100) {;             iValue = parser.adjustYear(iValue);;         };         cal.set(Calendar.YEAR, iValue);;     }; }]; Strategy NUMBER_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.MONTH) {; ;     @Override;     int modify(final int iValue) {;         return iValue - 1;;     }; }]; Strategy LITERAL_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR)]; Strategy WEEK_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_YEAR)]; Strategy WEEK_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_MONTH)]; Strategy DAY_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_YEAR)]; Strategy DAY_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_MONTH)]; Strategy DAY_OF_WEEK_IN_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_WEEK_IN_MONTH)]; Strategy HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY)]; Strategy MODULO_HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 24;;     }; }]; Strategy MODULO_HOUR_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 12;;     }; }
@Override [EOL] boolean isNumber() { [EOL]     char c = formatField.charAt(0); [EOL]     if (c == '\'') { [EOL]         c = formatField.charAt(1); [EOL]     } [EOL]     return Character.isDigit(c); [EOL] } protected FastDateParser(final String pattern, final TimeZone timeZone, final Locale locale);  CopyQuotedStrategy(final String formatField);  TextStrategy(final int field, final Calendar definingCalendar, final Locale locale);  NumberStrategy(final int field);  TimeZoneStrategy(final Locale locale); private void init(); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale();  Pattern getParsePattern(); public boolean equals(final Object obj); public int hashCode(); public String toString(); private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException; public Object parseObject(final String source) throws ParseException; public Date parse(final String source) throws ParseException; public Object parseObject(final String source, final ParsePosition pos); public Date parse(final String source, final ParsePosition pos); private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote); private static Map<String, Integer> getDisplayNames(final int field, final Calendar definingCalendar, final Locale locale);  int adjustYear(final int twoDigitYear);  boolean isNextNumber();  int getFieldWidth();  boolean isNumber();  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  abstract boolean addRegex(FastDateParser parser, StringBuilder regex); private Strategy getStrategy(String formatField, final Calendar definingCalendar); private static ConcurrentMap<Locale, Strategy> getCache(final int field); private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  int modify(final int iValue);  int modify(final int iValue); long serialVersionUID=Optional[1L]; Locale JAPANESE_IMPERIAL=Optional[new Locale("ja", "JP", "JP")]; String pattern; TimeZone timeZone; Locale locale; Pattern parsePattern; Strategy[] strategies; int thisYear; String currentFormatField; Strategy nextStrategy; Pattern formatPattern=Optional[Pattern.compile("D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++")]; ConcurrentMap<Locale, Strategy>[] caches=Optional[new ConcurrentMap[Calendar.FIELD_COUNT]]; Strategy ABBREVIATED_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR) {; ;     /**;      * {@inheritDoc};      */;     @Override;     void setCalendar(final FastDateParser parser, final Calendar cal, final String value) {;         int iValue = Integer.parseInt(value);;         if (iValue < 100) {;             iValue = parser.adjustYear(iValue);;         };         cal.set(Calendar.YEAR, iValue);;     }; }]; Strategy NUMBER_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.MONTH) {; ;     @Override;     int modify(final int iValue) {;         return iValue - 1;;     }; }]; Strategy LITERAL_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR)]; Strategy WEEK_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_YEAR)]; Strategy WEEK_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_MONTH)]; Strategy DAY_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_YEAR)]; Strategy DAY_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_MONTH)]; Strategy DAY_OF_WEEK_IN_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_WEEK_IN_MONTH)]; Strategy HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY)]; Strategy MODULO_HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 24;;     }; }]; Strategy MODULO_HOUR_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 12;;     }; }
@Override [EOL] boolean addRegex(final FastDateParser parser, final StringBuilder regex) { [EOL]     escapeRegex(regex, formatField, true); [EOL]     return false; [EOL] } protected FastDateParser(final String pattern, final TimeZone timeZone, final Locale locale);  CopyQuotedStrategy(final String formatField);  TextStrategy(final int field, final Calendar definingCalendar, final Locale locale);  NumberStrategy(final int field);  TimeZoneStrategy(final Locale locale); private void init(); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale();  Pattern getParsePattern(); public boolean equals(final Object obj); public int hashCode(); public String toString(); private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException; public Object parseObject(final String source) throws ParseException; public Date parse(final String source) throws ParseException; public Object parseObject(final String source, final ParsePosition pos); public Date parse(final String source, final ParsePosition pos); private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote); private static Map<String, Integer> getDisplayNames(final int field, final Calendar definingCalendar, final Locale locale);  int adjustYear(final int twoDigitYear);  boolean isNextNumber();  int getFieldWidth();  boolean isNumber();  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  abstract boolean addRegex(FastDateParser parser, StringBuilder regex); private Strategy getStrategy(String formatField, final Calendar definingCalendar); private static ConcurrentMap<Locale, Strategy> getCache(final int field); private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  int modify(final int iValue);  int modify(final int iValue); long serialVersionUID=Optional[1L]; Locale JAPANESE_IMPERIAL=Optional[new Locale("ja", "JP", "JP")]; String pattern; TimeZone timeZone; Locale locale; Pattern parsePattern; Strategy[] strategies; int thisYear; String currentFormatField; Strategy nextStrategy; Pattern formatPattern=Optional[Pattern.compile("D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++")]; ConcurrentMap<Locale, Strategy>[] caches=Optional[new ConcurrentMap[Calendar.FIELD_COUNT]]; Strategy ABBREVIATED_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR) {; ;     /**;      * {@inheritDoc};      */;     @Override;     void setCalendar(final FastDateParser parser, final Calendar cal, final String value) {;         int iValue = Integer.parseInt(value);;         if (iValue < 100) {;             iValue = parser.adjustYear(iValue);;         };         cal.set(Calendar.YEAR, iValue);;     }; }]; Strategy NUMBER_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.MONTH) {; ;     @Override;     int modify(final int iValue) {;         return iValue - 1;;     }; }]; Strategy LITERAL_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR)]; Strategy WEEK_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_YEAR)]; Strategy WEEK_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_MONTH)]; Strategy DAY_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_YEAR)]; Strategy DAY_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_MONTH)]; Strategy DAY_OF_WEEK_IN_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_WEEK_IN_MONTH)]; Strategy HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY)]; Strategy MODULO_HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 24;;     }; }]; Strategy MODULO_HOUR_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 12;;     }; }
@Override [EOL] boolean addRegex(final FastDateParser parser, final StringBuilder regex) { [EOL]     regex.append('('); [EOL]     for (final String textKeyValue : keyValues.keySet()) { [EOL]         escapeRegex(regex, textKeyValue, false).append('|'); [EOL]     } [EOL]     regex.setCharAt(regex.length() - 1, ')'); [EOL]     return true; [EOL] } protected FastDateParser(final String pattern, final TimeZone timeZone, final Locale locale);  CopyQuotedStrategy(final String formatField);  TextStrategy(final int field, final Calendar definingCalendar, final Locale locale);  NumberStrategy(final int field);  TimeZoneStrategy(final Locale locale); private void init(); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale();  Pattern getParsePattern(); public boolean equals(final Object obj); public int hashCode(); public String toString(); private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException; public Object parseObject(final String source) throws ParseException; public Date parse(final String source) throws ParseException; public Object parseObject(final String source, final ParsePosition pos); public Date parse(final String source, final ParsePosition pos); private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote); private static Map<String, Integer> getDisplayNames(final int field, final Calendar definingCalendar, final Locale locale);  int adjustYear(final int twoDigitYear);  boolean isNextNumber();  int getFieldWidth();  boolean isNumber();  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  abstract boolean addRegex(FastDateParser parser, StringBuilder regex); private Strategy getStrategy(String formatField, final Calendar definingCalendar); private static ConcurrentMap<Locale, Strategy> getCache(final int field); private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  int modify(final int iValue);  int modify(final int iValue); long serialVersionUID=Optional[1L]; Locale JAPANESE_IMPERIAL=Optional[new Locale("ja", "JP", "JP")]; String pattern; TimeZone timeZone; Locale locale; Pattern parsePattern; Strategy[] strategies; int thisYear; String currentFormatField; Strategy nextStrategy; Pattern formatPattern=Optional[Pattern.compile("D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++")]; ConcurrentMap<Locale, Strategy>[] caches=Optional[new ConcurrentMap[Calendar.FIELD_COUNT]]; Strategy ABBREVIATED_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR) {; ;     /**;      * {@inheritDoc};      */;     @Override;     void setCalendar(final FastDateParser parser, final Calendar cal, final String value) {;         int iValue = Integer.parseInt(value);;         if (iValue < 100) {;             iValue = parser.adjustYear(iValue);;         };         cal.set(Calendar.YEAR, iValue);;     }; }]; Strategy NUMBER_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.MONTH) {; ;     @Override;     int modify(final int iValue) {;         return iValue - 1;;     }; }]; Strategy LITERAL_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR)]; Strategy WEEK_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_YEAR)]; Strategy WEEK_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_MONTH)]; Strategy DAY_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_YEAR)]; Strategy DAY_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_MONTH)]; Strategy DAY_OF_WEEK_IN_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_WEEK_IN_MONTH)]; Strategy HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY)]; Strategy MODULO_HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 24;;     }; }]; Strategy MODULO_HOUR_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 12;;     }; }
@Override [EOL] boolean addRegex(final FastDateParser parser, final StringBuilder regex) { [EOL]     regex.append('('); [EOL]     for (final String textKeyValue : keyValues.keySet()) { [EOL]         escapeRegex(regex, textKeyValue, false).append('|'); [EOL]     } [EOL]     regex.setCharAt(regex.length() - 1, ')'); [EOL]     return true; [EOL] } protected FastDateParser(final String pattern, final TimeZone timeZone, final Locale locale);  CopyQuotedStrategy(final String formatField);  TextStrategy(final int field, final Calendar definingCalendar, final Locale locale);  NumberStrategy(final int field);  TimeZoneStrategy(final Locale locale); private void init(); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale();  Pattern getParsePattern(); public boolean equals(final Object obj); public int hashCode(); public String toString(); private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException; public Object parseObject(final String source) throws ParseException; public Date parse(final String source) throws ParseException; public Object parseObject(final String source, final ParsePosition pos); public Date parse(final String source, final ParsePosition pos); private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote); private static Map<String, Integer> getDisplayNames(final int field, final Calendar definingCalendar, final Locale locale);  int adjustYear(final int twoDigitYear);  boolean isNextNumber();  int getFieldWidth();  boolean isNumber();  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  abstract boolean addRegex(FastDateParser parser, StringBuilder regex); private Strategy getStrategy(String formatField, final Calendar definingCalendar); private static ConcurrentMap<Locale, Strategy> getCache(final int field); private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  int modify(final int iValue);  int modify(final int iValue); long serialVersionUID=Optional[1L]; Locale JAPANESE_IMPERIAL=Optional[new Locale("ja", "JP", "JP")]; String pattern; TimeZone timeZone; Locale locale; Pattern parsePattern; Strategy[] strategies; int thisYear; String currentFormatField; Strategy nextStrategy; Pattern formatPattern=Optional[Pattern.compile("D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++")]; ConcurrentMap<Locale, Strategy>[] caches=Optional[new ConcurrentMap[Calendar.FIELD_COUNT]]; Strategy ABBREVIATED_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR) {; ;     /**;      * {@inheritDoc};      */;     @Override;     void setCalendar(final FastDateParser parser, final Calendar cal, final String value) {;         int iValue = Integer.parseInt(value);;         if (iValue < 100) {;             iValue = parser.adjustYear(iValue);;         };         cal.set(Calendar.YEAR, iValue);;     }; }]; Strategy NUMBER_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.MONTH) {; ;     @Override;     int modify(final int iValue) {;         return iValue - 1;;     }; }]; Strategy LITERAL_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR)]; Strategy WEEK_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_YEAR)]; Strategy WEEK_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_MONTH)]; Strategy DAY_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_YEAR)]; Strategy DAY_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_MONTH)]; Strategy DAY_OF_WEEK_IN_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_WEEK_IN_MONTH)]; Strategy HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY)]; Strategy MODULO_HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 24;;     }; }]; Strategy MODULO_HOUR_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 12;;     }; }
@Override [EOL] boolean addRegex(final FastDateParser parser, final StringBuilder regex) { [EOL]     regex.append('('); [EOL]     for (final String textKeyValue : keyValues.keySet()) { [EOL]         escapeRegex(regex, textKeyValue, false).append('|'); [EOL]     } [EOL]     regex.setCharAt(regex.length() - 1, ')'); [EOL]     return true; [EOL] } protected FastDateParser(final String pattern, final TimeZone timeZone, final Locale locale);  CopyQuotedStrategy(final String formatField);  TextStrategy(final int field, final Calendar definingCalendar, final Locale locale);  NumberStrategy(final int field);  TimeZoneStrategy(final Locale locale); private void init(); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale();  Pattern getParsePattern(); public boolean equals(final Object obj); public int hashCode(); public String toString(); private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException; public Object parseObject(final String source) throws ParseException; public Date parse(final String source) throws ParseException; public Object parseObject(final String source, final ParsePosition pos); public Date parse(final String source, final ParsePosition pos); private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote); private static Map<String, Integer> getDisplayNames(final int field, final Calendar definingCalendar, final Locale locale);  int adjustYear(final int twoDigitYear);  boolean isNextNumber();  int getFieldWidth();  boolean isNumber();  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  abstract boolean addRegex(FastDateParser parser, StringBuilder regex); private Strategy getStrategy(String formatField, final Calendar definingCalendar); private static ConcurrentMap<Locale, Strategy> getCache(final int field); private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  int modify(final int iValue);  int modify(final int iValue); long serialVersionUID=Optional[1L]; Locale JAPANESE_IMPERIAL=Optional[new Locale("ja", "JP", "JP")]; String pattern; TimeZone timeZone; Locale locale; Pattern parsePattern; Strategy[] strategies; int thisYear; String currentFormatField; Strategy nextStrategy; Pattern formatPattern=Optional[Pattern.compile("D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++")]; ConcurrentMap<Locale, Strategy>[] caches=Optional[new ConcurrentMap[Calendar.FIELD_COUNT]]; Strategy ABBREVIATED_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR) {; ;     /**;      * {@inheritDoc};      */;     @Override;     void setCalendar(final FastDateParser parser, final Calendar cal, final String value) {;         int iValue = Integer.parseInt(value);;         if (iValue < 100) {;             iValue = parser.adjustYear(iValue);;         };         cal.set(Calendar.YEAR, iValue);;     }; }]; Strategy NUMBER_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.MONTH) {; ;     @Override;     int modify(final int iValue) {;         return iValue - 1;;     }; }]; Strategy LITERAL_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR)]; Strategy WEEK_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_YEAR)]; Strategy WEEK_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_MONTH)]; Strategy DAY_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_YEAR)]; Strategy DAY_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_MONTH)]; Strategy DAY_OF_WEEK_IN_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_WEEK_IN_MONTH)]; Strategy HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY)]; Strategy MODULO_HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 24;;     }; }]; Strategy MODULO_HOUR_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 12;;     }; }
@Override [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value) { [EOL]     final Integer iVal = keyValues.get(value); [EOL]     if (iVal == null) { [EOL]         final StringBuilder sb = new StringBuilder(value); [EOL]         sb.append(" not in ("); [EOL]         for (final String textKeyValue : keyValues.keySet()) { [EOL]             sb.append(textKeyValue).append(' '); [EOL]         } [EOL]         sb.setCharAt(sb.length() - 1, ')'); [EOL]         throw new IllegalArgumentException(sb.toString()); [EOL]     } [EOL]     cal.set(field, iVal.intValue()); [EOL] } protected FastDateParser(final String pattern, final TimeZone timeZone, final Locale locale);  CopyQuotedStrategy(final String formatField);  TextStrategy(final int field, final Calendar definingCalendar, final Locale locale);  NumberStrategy(final int field);  TimeZoneStrategy(final Locale locale); private void init(); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale();  Pattern getParsePattern(); public boolean equals(final Object obj); public int hashCode(); public String toString(); private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException; public Object parseObject(final String source) throws ParseException; public Date parse(final String source) throws ParseException; public Object parseObject(final String source, final ParsePosition pos); public Date parse(final String source, final ParsePosition pos); private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote); private static Map<String, Integer> getDisplayNames(final int field, final Calendar definingCalendar, final Locale locale);  int adjustYear(final int twoDigitYear);  boolean isNextNumber();  int getFieldWidth();  boolean isNumber();  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  abstract boolean addRegex(FastDateParser parser, StringBuilder regex); private Strategy getStrategy(String formatField, final Calendar definingCalendar); private static ConcurrentMap<Locale, Strategy> getCache(final int field); private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  int modify(final int iValue);  int modify(final int iValue); long serialVersionUID=Optional[1L]; Locale JAPANESE_IMPERIAL=Optional[new Locale("ja", "JP", "JP")]; String pattern; TimeZone timeZone; Locale locale; Pattern parsePattern; Strategy[] strategies; int thisYear; String currentFormatField; Strategy nextStrategy; Pattern formatPattern=Optional[Pattern.compile("D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++")]; ConcurrentMap<Locale, Strategy>[] caches=Optional[new ConcurrentMap[Calendar.FIELD_COUNT]]; Strategy ABBREVIATED_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR) {; ;     /**;      * {@inheritDoc};      */;     @Override;     void setCalendar(final FastDateParser parser, final Calendar cal, final String value) {;         int iValue = Integer.parseInt(value);;         if (iValue < 100) {;             iValue = parser.adjustYear(iValue);;         };         cal.set(Calendar.YEAR, iValue);;     }; }]; Strategy NUMBER_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.MONTH) {; ;     @Override;     int modify(final int iValue) {;         return iValue - 1;;     }; }]; Strategy LITERAL_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR)]; Strategy WEEK_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_YEAR)]; Strategy WEEK_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_MONTH)]; Strategy DAY_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_YEAR)]; Strategy DAY_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_MONTH)]; Strategy DAY_OF_WEEK_IN_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_WEEK_IN_MONTH)]; Strategy HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY)]; Strategy MODULO_HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 24;;     }; }]; Strategy MODULO_HOUR_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 12;;     }; }
@Override [EOL] boolean addRegex(final FastDateParser parser, final StringBuilder regex) { [EOL]     if (parser.isNextNumber()) { [EOL]         regex.append("(\\p{IsNd}{").append(parser.getFieldWidth()).append("}+)"); [EOL]     } else { [EOL]         regex.append("(\\p{IsNd}++)"); [EOL]     } [EOL]     return true; [EOL] } protected FastDateParser(final String pattern, final TimeZone timeZone, final Locale locale);  CopyQuotedStrategy(final String formatField);  TextStrategy(final int field, final Calendar definingCalendar, final Locale locale);  NumberStrategy(final int field);  TimeZoneStrategy(final Locale locale); private void init(); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale();  Pattern getParsePattern(); public boolean equals(final Object obj); public int hashCode(); public String toString(); private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException; public Object parseObject(final String source) throws ParseException; public Date parse(final String source) throws ParseException; public Object parseObject(final String source, final ParsePosition pos); public Date parse(final String source, final ParsePosition pos); private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote); private static Map<String, Integer> getDisplayNames(final int field, final Calendar definingCalendar, final Locale locale);  int adjustYear(final int twoDigitYear);  boolean isNextNumber();  int getFieldWidth();  boolean isNumber();  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  abstract boolean addRegex(FastDateParser parser, StringBuilder regex); private Strategy getStrategy(String formatField, final Calendar definingCalendar); private static ConcurrentMap<Locale, Strategy> getCache(final int field); private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  int modify(final int iValue);  int modify(final int iValue); long serialVersionUID=Optional[1L]; Locale JAPANESE_IMPERIAL=Optional[new Locale("ja", "JP", "JP")]; String pattern; TimeZone timeZone; Locale locale; Pattern parsePattern; Strategy[] strategies; int thisYear; String currentFormatField; Strategy nextStrategy; Pattern formatPattern=Optional[Pattern.compile("D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++")]; ConcurrentMap<Locale, Strategy>[] caches=Optional[new ConcurrentMap[Calendar.FIELD_COUNT]]; Strategy ABBREVIATED_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR) {; ;     /**;      * {@inheritDoc};      */;     @Override;     void setCalendar(final FastDateParser parser, final Calendar cal, final String value) {;         int iValue = Integer.parseInt(value);;         if (iValue < 100) {;             iValue = parser.adjustYear(iValue);;         };         cal.set(Calendar.YEAR, iValue);;     }; }]; Strategy NUMBER_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.MONTH) {; ;     @Override;     int modify(final int iValue) {;         return iValue - 1;;     }; }]; Strategy LITERAL_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR)]; Strategy WEEK_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_YEAR)]; Strategy WEEK_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_MONTH)]; Strategy DAY_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_YEAR)]; Strategy DAY_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_MONTH)]; Strategy DAY_OF_WEEK_IN_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_WEEK_IN_MONTH)]; Strategy HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY)]; Strategy MODULO_HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 24;;     }; }]; Strategy MODULO_HOUR_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 12;;     }; }
@Override [EOL] boolean addRegex(final FastDateParser parser, final StringBuilder regex) { [EOL]     if (parser.isNextNumber()) { [EOL]         regex.append("(\\p{IsNd}{").append(parser.getFieldWidth()).append("}+)"); [EOL]     } else { [EOL]         regex.append("(\\p{IsNd}++)"); [EOL]     } [EOL]     return true; [EOL] } protected FastDateParser(final String pattern, final TimeZone timeZone, final Locale locale);  CopyQuotedStrategy(final String formatField);  TextStrategy(final int field, final Calendar definingCalendar, final Locale locale);  NumberStrategy(final int field);  TimeZoneStrategy(final Locale locale); private void init(); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale();  Pattern getParsePattern(); public boolean equals(final Object obj); public int hashCode(); public String toString(); private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException; public Object parseObject(final String source) throws ParseException; public Date parse(final String source) throws ParseException; public Object parseObject(final String source, final ParsePosition pos); public Date parse(final String source, final ParsePosition pos); private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote); private static Map<String, Integer> getDisplayNames(final int field, final Calendar definingCalendar, final Locale locale);  int adjustYear(final int twoDigitYear);  boolean isNextNumber();  int getFieldWidth();  boolean isNumber();  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  abstract boolean addRegex(FastDateParser parser, StringBuilder regex); private Strategy getStrategy(String formatField, final Calendar definingCalendar); private static ConcurrentMap<Locale, Strategy> getCache(final int field); private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  int modify(final int iValue);  int modify(final int iValue); long serialVersionUID=Optional[1L]; Locale JAPANESE_IMPERIAL=Optional[new Locale("ja", "JP", "JP")]; String pattern; TimeZone timeZone; Locale locale; Pattern parsePattern; Strategy[] strategies; int thisYear; String currentFormatField; Strategy nextStrategy; Pattern formatPattern=Optional[Pattern.compile("D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++")]; ConcurrentMap<Locale, Strategy>[] caches=Optional[new ConcurrentMap[Calendar.FIELD_COUNT]]; Strategy ABBREVIATED_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR) {; ;     /**;      * {@inheritDoc};      */;     @Override;     void setCalendar(final FastDateParser parser, final Calendar cal, final String value) {;         int iValue = Integer.parseInt(value);;         if (iValue < 100) {;             iValue = parser.adjustYear(iValue);;         };         cal.set(Calendar.YEAR, iValue);;     }; }]; Strategy NUMBER_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.MONTH) {; ;     @Override;     int modify(final int iValue) {;         return iValue - 1;;     }; }]; Strategy LITERAL_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR)]; Strategy WEEK_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_YEAR)]; Strategy WEEK_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_MONTH)]; Strategy DAY_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_YEAR)]; Strategy DAY_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_MONTH)]; Strategy DAY_OF_WEEK_IN_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_WEEK_IN_MONTH)]; Strategy HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY)]; Strategy MODULO_HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 24;;     }; }]; Strategy MODULO_HOUR_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 12;;     }; }
@Override [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value) { [EOL]     cal.set(field, modify(Integer.parseInt(value))); [EOL] } protected FastDateParser(final String pattern, final TimeZone timeZone, final Locale locale);  CopyQuotedStrategy(final String formatField);  TextStrategy(final int field, final Calendar definingCalendar, final Locale locale);  NumberStrategy(final int field);  TimeZoneStrategy(final Locale locale); private void init(); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale();  Pattern getParsePattern(); public boolean equals(final Object obj); public int hashCode(); public String toString(); private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException; public Object parseObject(final String source) throws ParseException; public Date parse(final String source) throws ParseException; public Object parseObject(final String source, final ParsePosition pos); public Date parse(final String source, final ParsePosition pos); private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote); private static Map<String, Integer> getDisplayNames(final int field, final Calendar definingCalendar, final Locale locale);  int adjustYear(final int twoDigitYear);  boolean isNextNumber();  int getFieldWidth();  boolean isNumber();  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  abstract boolean addRegex(FastDateParser parser, StringBuilder regex); private Strategy getStrategy(String formatField, final Calendar definingCalendar); private static ConcurrentMap<Locale, Strategy> getCache(final int field); private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  int modify(final int iValue);  int modify(final int iValue); long serialVersionUID=Optional[1L]; Locale JAPANESE_IMPERIAL=Optional[new Locale("ja", "JP", "JP")]; String pattern; TimeZone timeZone; Locale locale; Pattern parsePattern; Strategy[] strategies; int thisYear; String currentFormatField; Strategy nextStrategy; Pattern formatPattern=Optional[Pattern.compile("D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++")]; ConcurrentMap<Locale, Strategy>[] caches=Optional[new ConcurrentMap[Calendar.FIELD_COUNT]]; Strategy ABBREVIATED_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR) {; ;     /**;      * {@inheritDoc};      */;     @Override;     void setCalendar(final FastDateParser parser, final Calendar cal, final String value) {;         int iValue = Integer.parseInt(value);;         if (iValue < 100) {;             iValue = parser.adjustYear(iValue);;         };         cal.set(Calendar.YEAR, iValue);;     }; }]; Strategy NUMBER_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.MONTH) {; ;     @Override;     int modify(final int iValue) {;         return iValue - 1;;     }; }]; Strategy LITERAL_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR)]; Strategy WEEK_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_YEAR)]; Strategy WEEK_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_MONTH)]; Strategy DAY_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_YEAR)]; Strategy DAY_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_MONTH)]; Strategy DAY_OF_WEEK_IN_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_WEEK_IN_MONTH)]; Strategy HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY)]; Strategy MODULO_HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 24;;     }; }]; Strategy MODULO_HOUR_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 12;;     }; }
@Override [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value) { [EOL]     cal.set(field, modify(Integer.parseInt(value))); [EOL] } protected FastDateParser(final String pattern, final TimeZone timeZone, final Locale locale);  CopyQuotedStrategy(final String formatField);  TextStrategy(final int field, final Calendar definingCalendar, final Locale locale);  NumberStrategy(final int field);  TimeZoneStrategy(final Locale locale); private void init(); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale();  Pattern getParsePattern(); public boolean equals(final Object obj); public int hashCode(); public String toString(); private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException; public Object parseObject(final String source) throws ParseException; public Date parse(final String source) throws ParseException; public Object parseObject(final String source, final ParsePosition pos); public Date parse(final String source, final ParsePosition pos); private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote); private static Map<String, Integer> getDisplayNames(final int field, final Calendar definingCalendar, final Locale locale);  int adjustYear(final int twoDigitYear);  boolean isNextNumber();  int getFieldWidth();  boolean isNumber();  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  abstract boolean addRegex(FastDateParser parser, StringBuilder regex); private Strategy getStrategy(String formatField, final Calendar definingCalendar); private static ConcurrentMap<Locale, Strategy> getCache(final int field); private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  int modify(final int iValue);  int modify(final int iValue); long serialVersionUID=Optional[1L]; Locale JAPANESE_IMPERIAL=Optional[new Locale("ja", "JP", "JP")]; String pattern; TimeZone timeZone; Locale locale; Pattern parsePattern; Strategy[] strategies; int thisYear; String currentFormatField; Strategy nextStrategy; Pattern formatPattern=Optional[Pattern.compile("D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++")]; ConcurrentMap<Locale, Strategy>[] caches=Optional[new ConcurrentMap[Calendar.FIELD_COUNT]]; Strategy ABBREVIATED_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR) {; ;     /**;      * {@inheritDoc};      */;     @Override;     void setCalendar(final FastDateParser parser, final Calendar cal, final String value) {;         int iValue = Integer.parseInt(value);;         if (iValue < 100) {;             iValue = parser.adjustYear(iValue);;         };         cal.set(Calendar.YEAR, iValue);;     }; }]; Strategy NUMBER_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.MONTH) {; ;     @Override;     int modify(final int iValue) {;         return iValue - 1;;     }; }]; Strategy LITERAL_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR)]; Strategy WEEK_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_YEAR)]; Strategy WEEK_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_MONTH)]; Strategy DAY_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_YEAR)]; Strategy DAY_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_MONTH)]; Strategy DAY_OF_WEEK_IN_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_WEEK_IN_MONTH)]; Strategy HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY)]; Strategy MODULO_HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 24;;     }; }]; Strategy MODULO_HOUR_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 12;;     }; }
@Override [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value) { [EOL]     cal.set(field, modify(Integer.parseInt(value))); [EOL] } protected FastDateParser(final String pattern, final TimeZone timeZone, final Locale locale);  CopyQuotedStrategy(final String formatField);  TextStrategy(final int field, final Calendar definingCalendar, final Locale locale);  NumberStrategy(final int field);  TimeZoneStrategy(final Locale locale); private void init(); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale();  Pattern getParsePattern(); public boolean equals(final Object obj); public int hashCode(); public String toString(); private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException; public Object parseObject(final String source) throws ParseException; public Date parse(final String source) throws ParseException; public Object parseObject(final String source, final ParsePosition pos); public Date parse(final String source, final ParsePosition pos); private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote); private static Map<String, Integer> getDisplayNames(final int field, final Calendar definingCalendar, final Locale locale);  int adjustYear(final int twoDigitYear);  boolean isNextNumber();  int getFieldWidth();  boolean isNumber();  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  abstract boolean addRegex(FastDateParser parser, StringBuilder regex); private Strategy getStrategy(String formatField, final Calendar definingCalendar); private static ConcurrentMap<Locale, Strategy> getCache(final int field); private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  int modify(final int iValue);  int modify(final int iValue); long serialVersionUID=Optional[1L]; Locale JAPANESE_IMPERIAL=Optional[new Locale("ja", "JP", "JP")]; String pattern; TimeZone timeZone; Locale locale; Pattern parsePattern; Strategy[] strategies; int thisYear; String currentFormatField; Strategy nextStrategy; Pattern formatPattern=Optional[Pattern.compile("D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++")]; ConcurrentMap<Locale, Strategy>[] caches=Optional[new ConcurrentMap[Calendar.FIELD_COUNT]]; Strategy ABBREVIATED_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR) {; ;     /**;      * {@inheritDoc};      */;     @Override;     void setCalendar(final FastDateParser parser, final Calendar cal, final String value) {;         int iValue = Integer.parseInt(value);;         if (iValue < 100) {;             iValue = parser.adjustYear(iValue);;         };         cal.set(Calendar.YEAR, iValue);;     }; }]; Strategy NUMBER_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.MONTH) {; ;     @Override;     int modify(final int iValue) {;         return iValue - 1;;     }; }]; Strategy LITERAL_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR)]; Strategy WEEK_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_YEAR)]; Strategy WEEK_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_MONTH)]; Strategy DAY_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_YEAR)]; Strategy DAY_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_MONTH)]; Strategy DAY_OF_WEEK_IN_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_WEEK_IN_MONTH)]; Strategy HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY)]; Strategy MODULO_HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 24;;     }; }]; Strategy MODULO_HOUR_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 12;;     }; }
@Override [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value) { [EOL]     cal.set(field, modify(Integer.parseInt(value))); [EOL] } protected FastDateParser(final String pattern, final TimeZone timeZone, final Locale locale);  CopyQuotedStrategy(final String formatField);  TextStrategy(final int field, final Calendar definingCalendar, final Locale locale);  NumberStrategy(final int field);  TimeZoneStrategy(final Locale locale); private void init(); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale();  Pattern getParsePattern(); public boolean equals(final Object obj); public int hashCode(); public String toString(); private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException; public Object parseObject(final String source) throws ParseException; public Date parse(final String source) throws ParseException; public Object parseObject(final String source, final ParsePosition pos); public Date parse(final String source, final ParsePosition pos); private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote); private static Map<String, Integer> getDisplayNames(final int field, final Calendar definingCalendar, final Locale locale);  int adjustYear(final int twoDigitYear);  boolean isNextNumber();  int getFieldWidth();  boolean isNumber();  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  abstract boolean addRegex(FastDateParser parser, StringBuilder regex); private Strategy getStrategy(String formatField, final Calendar definingCalendar); private static ConcurrentMap<Locale, Strategy> getCache(final int field); private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  int modify(final int iValue);  int modify(final int iValue); long serialVersionUID=Optional[1L]; Locale JAPANESE_IMPERIAL=Optional[new Locale("ja", "JP", "JP")]; String pattern; TimeZone timeZone; Locale locale; Pattern parsePattern; Strategy[] strategies; int thisYear; String currentFormatField; Strategy nextStrategy; Pattern formatPattern=Optional[Pattern.compile("D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++")]; ConcurrentMap<Locale, Strategy>[] caches=Optional[new ConcurrentMap[Calendar.FIELD_COUNT]]; Strategy ABBREVIATED_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR) {; ;     /**;      * {@inheritDoc};      */;     @Override;     void setCalendar(final FastDateParser parser, final Calendar cal, final String value) {;         int iValue = Integer.parseInt(value);;         if (iValue < 100) {;             iValue = parser.adjustYear(iValue);;         };         cal.set(Calendar.YEAR, iValue);;     }; }]; Strategy NUMBER_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.MONTH) {; ;     @Override;     int modify(final int iValue) {;         return iValue - 1;;     }; }]; Strategy LITERAL_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR)]; Strategy WEEK_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_YEAR)]; Strategy WEEK_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_MONTH)]; Strategy DAY_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_YEAR)]; Strategy DAY_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_MONTH)]; Strategy DAY_OF_WEEK_IN_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_WEEK_IN_MONTH)]; Strategy HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY)]; Strategy MODULO_HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 24;;     }; }]; Strategy MODULO_HOUR_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 12;;     }; }
int modify(final int iValue) { [EOL]     return iValue; [EOL] } protected FastDateParser(final String pattern, final TimeZone timeZone, final Locale locale);  CopyQuotedStrategy(final String formatField);  TextStrategy(final int field, final Calendar definingCalendar, final Locale locale);  NumberStrategy(final int field);  TimeZoneStrategy(final Locale locale); private void init(); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale();  Pattern getParsePattern(); public boolean equals(final Object obj); public int hashCode(); public String toString(); private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException; public Object parseObject(final String source) throws ParseException; public Date parse(final String source) throws ParseException; public Object parseObject(final String source, final ParsePosition pos); public Date parse(final String source, final ParsePosition pos); private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote); private static Map<String, Integer> getDisplayNames(final int field, final Calendar definingCalendar, final Locale locale);  int adjustYear(final int twoDigitYear);  boolean isNextNumber();  int getFieldWidth();  boolean isNumber();  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  abstract boolean addRegex(FastDateParser parser, StringBuilder regex); private Strategy getStrategy(String formatField, final Calendar definingCalendar); private static ConcurrentMap<Locale, Strategy> getCache(final int field); private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  int modify(final int iValue);  int modify(final int iValue); long serialVersionUID=Optional[1L]; Locale JAPANESE_IMPERIAL=Optional[new Locale("ja", "JP", "JP")]; String pattern; TimeZone timeZone; Locale locale; Pattern parsePattern; Strategy[] strategies; int thisYear; String currentFormatField; Strategy nextStrategy; Pattern formatPattern=Optional[Pattern.compile("D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++")]; ConcurrentMap<Locale, Strategy>[] caches=Optional[new ConcurrentMap[Calendar.FIELD_COUNT]]; Strategy ABBREVIATED_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR) {; ;     /**;      * {@inheritDoc};      */;     @Override;     void setCalendar(final FastDateParser parser, final Calendar cal, final String value) {;         int iValue = Integer.parseInt(value);;         if (iValue < 100) {;             iValue = parser.adjustYear(iValue);;         };         cal.set(Calendar.YEAR, iValue);;     }; }]; Strategy NUMBER_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.MONTH) {; ;     @Override;     int modify(final int iValue) {;         return iValue - 1;;     }; }]; Strategy LITERAL_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR)]; Strategy WEEK_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_YEAR)]; Strategy WEEK_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_MONTH)]; Strategy DAY_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_YEAR)]; Strategy DAY_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_MONTH)]; Strategy DAY_OF_WEEK_IN_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_WEEK_IN_MONTH)]; Strategy HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY)]; Strategy MODULO_HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 24;;     }; }]; Strategy MODULO_HOUR_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 12;;     }; }
int modify(final int iValue) { [EOL]     return iValue; [EOL] } protected FastDateParser(final String pattern, final TimeZone timeZone, final Locale locale);  CopyQuotedStrategy(final String formatField);  TextStrategy(final int field, final Calendar definingCalendar, final Locale locale);  NumberStrategy(final int field);  TimeZoneStrategy(final Locale locale); private void init(); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale();  Pattern getParsePattern(); public boolean equals(final Object obj); public int hashCode(); public String toString(); private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException; public Object parseObject(final String source) throws ParseException; public Date parse(final String source) throws ParseException; public Object parseObject(final String source, final ParsePosition pos); public Date parse(final String source, final ParsePosition pos); private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote); private static Map<String, Integer> getDisplayNames(final int field, final Calendar definingCalendar, final Locale locale);  int adjustYear(final int twoDigitYear);  boolean isNextNumber();  int getFieldWidth();  boolean isNumber();  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  abstract boolean addRegex(FastDateParser parser, StringBuilder regex); private Strategy getStrategy(String formatField, final Calendar definingCalendar); private static ConcurrentMap<Locale, Strategy> getCache(final int field); private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  int modify(final int iValue);  int modify(final int iValue); long serialVersionUID=Optional[1L]; Locale JAPANESE_IMPERIAL=Optional[new Locale("ja", "JP", "JP")]; String pattern; TimeZone timeZone; Locale locale; Pattern parsePattern; Strategy[] strategies; int thisYear; String currentFormatField; Strategy nextStrategy; Pattern formatPattern=Optional[Pattern.compile("D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++")]; ConcurrentMap<Locale, Strategy>[] caches=Optional[new ConcurrentMap[Calendar.FIELD_COUNT]]; Strategy ABBREVIATED_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR) {; ;     /**;      * {@inheritDoc};      */;     @Override;     void setCalendar(final FastDateParser parser, final Calendar cal, final String value) {;         int iValue = Integer.parseInt(value);;         if (iValue < 100) {;             iValue = parser.adjustYear(iValue);;         };         cal.set(Calendar.YEAR, iValue);;     }; }]; Strategy NUMBER_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.MONTH) {; ;     @Override;     int modify(final int iValue) {;         return iValue - 1;;     }; }]; Strategy LITERAL_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR)]; Strategy WEEK_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_YEAR)]; Strategy WEEK_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_MONTH)]; Strategy DAY_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_YEAR)]; Strategy DAY_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_MONTH)]; Strategy DAY_OF_WEEK_IN_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_WEEK_IN_MONTH)]; Strategy HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY)]; Strategy MODULO_HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 24;;     }; }]; Strategy MODULO_HOUR_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 12;;     }; }
int modify(final int iValue) { [EOL]     return iValue; [EOL] } protected FastDateParser(final String pattern, final TimeZone timeZone, final Locale locale);  CopyQuotedStrategy(final String formatField);  TextStrategy(final int field, final Calendar definingCalendar, final Locale locale);  NumberStrategy(final int field);  TimeZoneStrategy(final Locale locale); private void init(); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale();  Pattern getParsePattern(); public boolean equals(final Object obj); public int hashCode(); public String toString(); private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException; public Object parseObject(final String source) throws ParseException; public Date parse(final String source) throws ParseException; public Object parseObject(final String source, final ParsePosition pos); public Date parse(final String source, final ParsePosition pos); private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote); private static Map<String, Integer> getDisplayNames(final int field, final Calendar definingCalendar, final Locale locale);  int adjustYear(final int twoDigitYear);  boolean isNextNumber();  int getFieldWidth();  boolean isNumber();  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  abstract boolean addRegex(FastDateParser parser, StringBuilder regex); private Strategy getStrategy(String formatField, final Calendar definingCalendar); private static ConcurrentMap<Locale, Strategy> getCache(final int field); private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  int modify(final int iValue);  int modify(final int iValue); long serialVersionUID=Optional[1L]; Locale JAPANESE_IMPERIAL=Optional[new Locale("ja", "JP", "JP")]; String pattern; TimeZone timeZone; Locale locale; Pattern parsePattern; Strategy[] strategies; int thisYear; String currentFormatField; Strategy nextStrategy; Pattern formatPattern=Optional[Pattern.compile("D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++")]; ConcurrentMap<Locale, Strategy>[] caches=Optional[new ConcurrentMap[Calendar.FIELD_COUNT]]; Strategy ABBREVIATED_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR) {; ;     /**;      * {@inheritDoc};      */;     @Override;     void setCalendar(final FastDateParser parser, final Calendar cal, final String value) {;         int iValue = Integer.parseInt(value);;         if (iValue < 100) {;             iValue = parser.adjustYear(iValue);;         };         cal.set(Calendar.YEAR, iValue);;     }; }]; Strategy NUMBER_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.MONTH) {; ;     @Override;     int modify(final int iValue) {;         return iValue - 1;;     }; }]; Strategy LITERAL_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR)]; Strategy WEEK_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_YEAR)]; Strategy WEEK_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_MONTH)]; Strategy DAY_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_YEAR)]; Strategy DAY_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_MONTH)]; Strategy DAY_OF_WEEK_IN_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_WEEK_IN_MONTH)]; Strategy HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY)]; Strategy MODULO_HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 24;;     }; }]; Strategy MODULO_HOUR_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 12;;     }; }
@Override [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value) { [EOL]     int iValue = Integer.parseInt(value); [EOL]     if (iValue < 100) { [EOL]         iValue = parser.adjustYear(iValue); [EOL]     } [EOL]     cal.set(Calendar.YEAR, iValue); [EOL] } protected FastDateParser(final String pattern, final TimeZone timeZone, final Locale locale);  CopyQuotedStrategy(final String formatField);  TextStrategy(final int field, final Calendar definingCalendar, final Locale locale);  NumberStrategy(final int field);  TimeZoneStrategy(final Locale locale); private void init(); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale();  Pattern getParsePattern(); public boolean equals(final Object obj); public int hashCode(); public String toString(); private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException; public Object parseObject(final String source) throws ParseException; public Date parse(final String source) throws ParseException; public Object parseObject(final String source, final ParsePosition pos); public Date parse(final String source, final ParsePosition pos); private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote); private static Map<String, Integer> getDisplayNames(final int field, final Calendar definingCalendar, final Locale locale);  int adjustYear(final int twoDigitYear);  boolean isNextNumber();  int getFieldWidth();  boolean isNumber();  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  abstract boolean addRegex(FastDateParser parser, StringBuilder regex); private Strategy getStrategy(String formatField, final Calendar definingCalendar); private static ConcurrentMap<Locale, Strategy> getCache(final int field); private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  int modify(final int iValue);  int modify(final int iValue); long serialVersionUID=Optional[1L]; Locale JAPANESE_IMPERIAL=Optional[new Locale("ja", "JP", "JP")]; String pattern; TimeZone timeZone; Locale locale; Pattern parsePattern; Strategy[] strategies; int thisYear; String currentFormatField; Strategy nextStrategy; Pattern formatPattern=Optional[Pattern.compile("D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++")]; ConcurrentMap<Locale, Strategy>[] caches=Optional[new ConcurrentMap[Calendar.FIELD_COUNT]]; Strategy ABBREVIATED_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR) {; ;     /**;      * {@inheritDoc};      */;     @Override;     void setCalendar(final FastDateParser parser, final Calendar cal, final String value) {;         int iValue = Integer.parseInt(value);;         if (iValue < 100) {;             iValue = parser.adjustYear(iValue);;         };         cal.set(Calendar.YEAR, iValue);;     }; }]; Strategy NUMBER_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.MONTH) {; ;     @Override;     int modify(final int iValue) {;         return iValue - 1;;     }; }]; Strategy LITERAL_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR)]; Strategy WEEK_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_YEAR)]; Strategy WEEK_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_MONTH)]; Strategy DAY_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_YEAR)]; Strategy DAY_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_MONTH)]; Strategy DAY_OF_WEEK_IN_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_WEEK_IN_MONTH)]; Strategy HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY)]; Strategy MODULO_HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 24;;     }; }]; Strategy MODULO_HOUR_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 12;;     }; }
@Override [EOL] boolean addRegex(final FastDateParser parser, final StringBuilder regex) { [EOL]     regex.append(validTimeZoneChars); [EOL]     return true; [EOL] } protected FastDateParser(final String pattern, final TimeZone timeZone, final Locale locale);  CopyQuotedStrategy(final String formatField);  TextStrategy(final int field, final Calendar definingCalendar, final Locale locale);  NumberStrategy(final int field);  TimeZoneStrategy(final Locale locale); private void init(); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale();  Pattern getParsePattern(); public boolean equals(final Object obj); public int hashCode(); public String toString(); private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException; public Object parseObject(final String source) throws ParseException; public Date parse(final String source) throws ParseException; public Object parseObject(final String source, final ParsePosition pos); public Date parse(final String source, final ParsePosition pos); private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote); private static Map<String, Integer> getDisplayNames(final int field, final Calendar definingCalendar, final Locale locale);  int adjustYear(final int twoDigitYear);  boolean isNextNumber();  int getFieldWidth();  boolean isNumber();  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  abstract boolean addRegex(FastDateParser parser, StringBuilder regex); private Strategy getStrategy(String formatField, final Calendar definingCalendar); private static ConcurrentMap<Locale, Strategy> getCache(final int field); private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  int modify(final int iValue);  int modify(final int iValue); long serialVersionUID=Optional[1L]; Locale JAPANESE_IMPERIAL=Optional[new Locale("ja", "JP", "JP")]; String pattern; TimeZone timeZone; Locale locale; Pattern parsePattern; Strategy[] strategies; int thisYear; String currentFormatField; Strategy nextStrategy; Pattern formatPattern=Optional[Pattern.compile("D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++")]; ConcurrentMap<Locale, Strategy>[] caches=Optional[new ConcurrentMap[Calendar.FIELD_COUNT]]; Strategy ABBREVIATED_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR) {; ;     /**;      * {@inheritDoc};      */;     @Override;     void setCalendar(final FastDateParser parser, final Calendar cal, final String value) {;         int iValue = Integer.parseInt(value);;         if (iValue < 100) {;             iValue = parser.adjustYear(iValue);;         };         cal.set(Calendar.YEAR, iValue);;     }; }]; Strategy NUMBER_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.MONTH) {; ;     @Override;     int modify(final int iValue) {;         return iValue - 1;;     }; }]; Strategy LITERAL_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR)]; Strategy WEEK_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_YEAR)]; Strategy WEEK_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_MONTH)]; Strategy DAY_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_YEAR)]; Strategy DAY_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_MONTH)]; Strategy DAY_OF_WEEK_IN_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_WEEK_IN_MONTH)]; Strategy HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY)]; Strategy MODULO_HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 24;;     }; }]; Strategy MODULO_HOUR_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 12;;     }; }
@Override [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value) { [EOL]     TimeZone tz; [EOL]     if (value.charAt(0) == '+' || value.charAt(0) == '-') { [EOL]         tz = TimeZone.getTimeZone("GMT" + value); [EOL]     } else if (value.startsWith("GMT")) { [EOL]         tz = TimeZone.getTimeZone(value); [EOL]     } else { [EOL]         tz = tzNames.get(value); [EOL]         if (tz == null) { [EOL]             throw new IllegalArgumentException(value + " is not a supported timezone name"); [EOL]         } [EOL]     } [EOL]     cal.setTimeZone(tz); [EOL] } protected FastDateParser(final String pattern, final TimeZone timeZone, final Locale locale);  CopyQuotedStrategy(final String formatField);  TextStrategy(final int field, final Calendar definingCalendar, final Locale locale);  NumberStrategy(final int field);  TimeZoneStrategy(final Locale locale); private void init(); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale();  Pattern getParsePattern(); public boolean equals(final Object obj); public int hashCode(); public String toString(); private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException; public Object parseObject(final String source) throws ParseException; public Date parse(final String source) throws ParseException; public Object parseObject(final String source, final ParsePosition pos); public Date parse(final String source, final ParsePosition pos); private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote); private static Map<String, Integer> getDisplayNames(final int field, final Calendar definingCalendar, final Locale locale);  int adjustYear(final int twoDigitYear);  boolean isNextNumber();  int getFieldWidth();  boolean isNumber();  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  abstract boolean addRegex(FastDateParser parser, StringBuilder regex); private Strategy getStrategy(String formatField, final Calendar definingCalendar); private static ConcurrentMap<Locale, Strategy> getCache(final int field); private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  int modify(final int iValue);  int modify(final int iValue); long serialVersionUID=Optional[1L]; Locale JAPANESE_IMPERIAL=Optional[new Locale("ja", "JP", "JP")]; String pattern; TimeZone timeZone; Locale locale; Pattern parsePattern; Strategy[] strategies; int thisYear; String currentFormatField; Strategy nextStrategy; Pattern formatPattern=Optional[Pattern.compile("D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++")]; ConcurrentMap<Locale, Strategy>[] caches=Optional[new ConcurrentMap[Calendar.FIELD_COUNT]]; Strategy ABBREVIATED_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR) {; ;     /**;      * {@inheritDoc};      */;     @Override;     void setCalendar(final FastDateParser parser, final Calendar cal, final String value) {;         int iValue = Integer.parseInt(value);;         if (iValue < 100) {;             iValue = parser.adjustYear(iValue);;         };         cal.set(Calendar.YEAR, iValue);;     }; }]; Strategy NUMBER_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.MONTH) {; ;     @Override;     int modify(final int iValue) {;         return iValue - 1;;     }; }]; Strategy LITERAL_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR)]; Strategy WEEK_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_YEAR)]; Strategy WEEK_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_MONTH)]; Strategy DAY_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_YEAR)]; Strategy DAY_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_MONTH)]; Strategy DAY_OF_WEEK_IN_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_WEEK_IN_MONTH)]; Strategy HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY)]; Strategy MODULO_HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 24;;     }; }]; Strategy MODULO_HOUR_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 12;;     }; }
@Override [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value) { [EOL]     TimeZone tz; [EOL]     if (value.charAt(0) == '+' || value.charAt(0) == '-') { [EOL]         tz = TimeZone.getTimeZone("GMT" + value); [EOL]     } else if (value.startsWith("GMT")) { [EOL]         tz = TimeZone.getTimeZone(value); [EOL]     } else { [EOL]         tz = tzNames.get(value); [EOL]         if (tz == null) { [EOL]             throw new IllegalArgumentException(value + " is not a supported timezone name"); [EOL]         } [EOL]     } [EOL]     cal.setTimeZone(tz); [EOL] } protected FastDateParser(final String pattern, final TimeZone timeZone, final Locale locale);  CopyQuotedStrategy(final String formatField);  TextStrategy(final int field, final Calendar definingCalendar, final Locale locale);  NumberStrategy(final int field);  TimeZoneStrategy(final Locale locale); private void init(); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale();  Pattern getParsePattern(); public boolean equals(final Object obj); public int hashCode(); public String toString(); private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException; public Object parseObject(final String source) throws ParseException; public Date parse(final String source) throws ParseException; public Object parseObject(final String source, final ParsePosition pos); public Date parse(final String source, final ParsePosition pos); private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote); private static Map<String, Integer> getDisplayNames(final int field, final Calendar definingCalendar, final Locale locale);  int adjustYear(final int twoDigitYear);  boolean isNextNumber();  int getFieldWidth();  boolean isNumber();  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  abstract boolean addRegex(FastDateParser parser, StringBuilder regex); private Strategy getStrategy(String formatField, final Calendar definingCalendar); private static ConcurrentMap<Locale, Strategy> getCache(final int field); private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  int modify(final int iValue);  int modify(final int iValue); long serialVersionUID=Optional[1L]; Locale JAPANESE_IMPERIAL=Optional[new Locale("ja", "JP", "JP")]; String pattern; TimeZone timeZone; Locale locale; Pattern parsePattern; Strategy[] strategies; int thisYear; String currentFormatField; Strategy nextStrategy; Pattern formatPattern=Optional[Pattern.compile("D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++")]; ConcurrentMap<Locale, Strategy>[] caches=Optional[new ConcurrentMap[Calendar.FIELD_COUNT]]; Strategy ABBREVIATED_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR) {; ;     /**;      * {@inheritDoc};      */;     @Override;     void setCalendar(final FastDateParser parser, final Calendar cal, final String value) {;         int iValue = Integer.parseInt(value);;         if (iValue < 100) {;             iValue = parser.adjustYear(iValue);;         };         cal.set(Calendar.YEAR, iValue);;     }; }]; Strategy NUMBER_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.MONTH) {; ;     @Override;     int modify(final int iValue) {;         return iValue - 1;;     }; }]; Strategy LITERAL_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR)]; Strategy WEEK_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_YEAR)]; Strategy WEEK_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_MONTH)]; Strategy DAY_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_YEAR)]; Strategy DAY_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_MONTH)]; Strategy DAY_OF_WEEK_IN_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_WEEK_IN_MONTH)]; Strategy HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY)]; Strategy MODULO_HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 24;;     }; }]; Strategy MODULO_HOUR_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 12;;     }; }
@Override [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value) { [EOL]     TimeZone tz; [EOL]     if (value.charAt(0) == '+' || value.charAt(0) == '-') { [EOL]         tz = TimeZone.getTimeZone("GMT" + value); [EOL]     } else if (value.startsWith("GMT")) { [EOL]         tz = TimeZone.getTimeZone(value); [EOL]     } else { [EOL]         tz = tzNames.get(value); [EOL]         if (tz == null) { [EOL]             throw new IllegalArgumentException(value + " is not a supported timezone name"); [EOL]         } [EOL]     } [EOL]     cal.setTimeZone(tz); [EOL] } protected FastDateParser(final String pattern, final TimeZone timeZone, final Locale locale);  CopyQuotedStrategy(final String formatField);  TextStrategy(final int field, final Calendar definingCalendar, final Locale locale);  NumberStrategy(final int field);  TimeZoneStrategy(final Locale locale); private void init(); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale();  Pattern getParsePattern(); public boolean equals(final Object obj); public int hashCode(); public String toString(); private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException; public Object parseObject(final String source) throws ParseException; public Date parse(final String source) throws ParseException; public Object parseObject(final String source, final ParsePosition pos); public Date parse(final String source, final ParsePosition pos); private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote); private static Map<String, Integer> getDisplayNames(final int field, final Calendar definingCalendar, final Locale locale);  int adjustYear(final int twoDigitYear);  boolean isNextNumber();  int getFieldWidth();  boolean isNumber();  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  abstract boolean addRegex(FastDateParser parser, StringBuilder regex); private Strategy getStrategy(String formatField, final Calendar definingCalendar); private static ConcurrentMap<Locale, Strategy> getCache(final int field); private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  int modify(final int iValue);  int modify(final int iValue); long serialVersionUID=Optional[1L]; Locale JAPANESE_IMPERIAL=Optional[new Locale("ja", "JP", "JP")]; String pattern; TimeZone timeZone; Locale locale; Pattern parsePattern; Strategy[] strategies; int thisYear; String currentFormatField; Strategy nextStrategy; Pattern formatPattern=Optional[Pattern.compile("D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++")]; ConcurrentMap<Locale, Strategy>[] caches=Optional[new ConcurrentMap[Calendar.FIELD_COUNT]]; Strategy ABBREVIATED_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR) {; ;     /**;      * {@inheritDoc};      */;     @Override;     void setCalendar(final FastDateParser parser, final Calendar cal, final String value) {;         int iValue = Integer.parseInt(value);;         if (iValue < 100) {;             iValue = parser.adjustYear(iValue);;         };         cal.set(Calendar.YEAR, iValue);;     }; }]; Strategy NUMBER_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.MONTH) {; ;     @Override;     int modify(final int iValue) {;         return iValue - 1;;     }; }]; Strategy LITERAL_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR)]; Strategy WEEK_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_YEAR)]; Strategy WEEK_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_MONTH)]; Strategy DAY_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_YEAR)]; Strategy DAY_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_MONTH)]; Strategy DAY_OF_WEEK_IN_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_WEEK_IN_MONTH)]; Strategy HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY)]; Strategy MODULO_HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 24;;     }; }]; Strategy MODULO_HOUR_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 12;;     }; }
@Override [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value) { [EOL]     TimeZone tz; [EOL]     if (value.charAt(0) == '+' || value.charAt(0) == '-') { [EOL]         tz = TimeZone.getTimeZone("GMT" + value); [EOL]     } else if (value.startsWith("GMT")) { [EOL]         tz = TimeZone.getTimeZone(value); [EOL]     } else { [EOL]         tz = tzNames.get(value); [EOL]         if (tz == null) { [EOL]             throw new IllegalArgumentException(value + " is not a supported timezone name"); [EOL]         } [EOL]     } [EOL]     cal.setTimeZone(tz); [EOL] } protected FastDateParser(final String pattern, final TimeZone timeZone, final Locale locale);  CopyQuotedStrategy(final String formatField);  TextStrategy(final int field, final Calendar definingCalendar, final Locale locale);  NumberStrategy(final int field);  TimeZoneStrategy(final Locale locale); private void init(); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale();  Pattern getParsePattern(); public boolean equals(final Object obj); public int hashCode(); public String toString(); private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException; public Object parseObject(final String source) throws ParseException; public Date parse(final String source) throws ParseException; public Object parseObject(final String source, final ParsePosition pos); public Date parse(final String source, final ParsePosition pos); private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote); private static Map<String, Integer> getDisplayNames(final int field, final Calendar definingCalendar, final Locale locale);  int adjustYear(final int twoDigitYear);  boolean isNextNumber();  int getFieldWidth();  boolean isNumber();  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  abstract boolean addRegex(FastDateParser parser, StringBuilder regex); private Strategy getStrategy(String formatField, final Calendar definingCalendar); private static ConcurrentMap<Locale, Strategy> getCache(final int field); private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  int modify(final int iValue);  int modify(final int iValue); long serialVersionUID=Optional[1L]; Locale JAPANESE_IMPERIAL=Optional[new Locale("ja", "JP", "JP")]; String pattern; TimeZone timeZone; Locale locale; Pattern parsePattern; Strategy[] strategies; int thisYear; String currentFormatField; Strategy nextStrategy; Pattern formatPattern=Optional[Pattern.compile("D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++")]; ConcurrentMap<Locale, Strategy>[] caches=Optional[new ConcurrentMap[Calendar.FIELD_COUNT]]; Strategy ABBREVIATED_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR) {; ;     /**;      * {@inheritDoc};      */;     @Override;     void setCalendar(final FastDateParser parser, final Calendar cal, final String value) {;         int iValue = Integer.parseInt(value);;         if (iValue < 100) {;             iValue = parser.adjustYear(iValue);;         };         cal.set(Calendar.YEAR, iValue);;     }; }]; Strategy NUMBER_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.MONTH) {; ;     @Override;     int modify(final int iValue) {;         return iValue - 1;;     }; }]; Strategy LITERAL_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR)]; Strategy WEEK_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_YEAR)]; Strategy WEEK_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_MONTH)]; Strategy DAY_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_YEAR)]; Strategy DAY_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_MONTH)]; Strategy DAY_OF_WEEK_IN_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_WEEK_IN_MONTH)]; Strategy HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY)]; Strategy MODULO_HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 24;;     }; }]; Strategy MODULO_HOUR_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 12;;     }; }
@Override [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value) { [EOL]     TimeZone tz; [EOL]     if (value.charAt(0) == '+' || value.charAt(0) == '-') { [EOL]         tz = TimeZone.getTimeZone("GMT" + value); [EOL]     } else if (value.startsWith("GMT")) { [EOL]         tz = TimeZone.getTimeZone(value); [EOL]     } else { [EOL]         tz = tzNames.get(value); [EOL]         if (tz == null) { [EOL]             throw new IllegalArgumentException(value + " is not a supported timezone name"); [EOL]         } [EOL]     } [EOL]     cal.setTimeZone(tz); [EOL] } protected FastDateParser(final String pattern, final TimeZone timeZone, final Locale locale);  CopyQuotedStrategy(final String formatField);  TextStrategy(final int field, final Calendar definingCalendar, final Locale locale);  NumberStrategy(final int field);  TimeZoneStrategy(final Locale locale); private void init(); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale();  Pattern getParsePattern(); public boolean equals(final Object obj); public int hashCode(); public String toString(); private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException; public Object parseObject(final String source) throws ParseException; public Date parse(final String source) throws ParseException; public Object parseObject(final String source, final ParsePosition pos); public Date parse(final String source, final ParsePosition pos); private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote); private static Map<String, Integer> getDisplayNames(final int field, final Calendar definingCalendar, final Locale locale);  int adjustYear(final int twoDigitYear);  boolean isNextNumber();  int getFieldWidth();  boolean isNumber();  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  abstract boolean addRegex(FastDateParser parser, StringBuilder regex); private Strategy getStrategy(String formatField, final Calendar definingCalendar); private static ConcurrentMap<Locale, Strategy> getCache(final int field); private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  int modify(final int iValue);  int modify(final int iValue); long serialVersionUID=Optional[1L]; Locale JAPANESE_IMPERIAL=Optional[new Locale("ja", "JP", "JP")]; String pattern; TimeZone timeZone; Locale locale; Pattern parsePattern; Strategy[] strategies; int thisYear; String currentFormatField; Strategy nextStrategy; Pattern formatPattern=Optional[Pattern.compile("D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++")]; ConcurrentMap<Locale, Strategy>[] caches=Optional[new ConcurrentMap[Calendar.FIELD_COUNT]]; Strategy ABBREVIATED_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR) {; ;     /**;      * {@inheritDoc};      */;     @Override;     void setCalendar(final FastDateParser parser, final Calendar cal, final String value) {;         int iValue = Integer.parseInt(value);;         if (iValue < 100) {;             iValue = parser.adjustYear(iValue);;         };         cal.set(Calendar.YEAR, iValue);;     }; }]; Strategy NUMBER_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.MONTH) {; ;     @Override;     int modify(final int iValue) {;         return iValue - 1;;     }; }]; Strategy LITERAL_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR)]; Strategy WEEK_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_YEAR)]; Strategy WEEK_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_MONTH)]; Strategy DAY_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_YEAR)]; Strategy DAY_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_MONTH)]; Strategy DAY_OF_WEEK_IN_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_WEEK_IN_MONTH)]; Strategy HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY)]; Strategy MODULO_HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 24;;     }; }]; Strategy MODULO_HOUR_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 12;;     }; }
@Override [EOL] int modify(final int iValue) { [EOL]     return iValue - 1; [EOL] } protected FastDateParser(final String pattern, final TimeZone timeZone, final Locale locale);  CopyQuotedStrategy(final String formatField);  TextStrategy(final int field, final Calendar definingCalendar, final Locale locale);  NumberStrategy(final int field);  TimeZoneStrategy(final Locale locale); private void init(); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale();  Pattern getParsePattern(); public boolean equals(final Object obj); public int hashCode(); public String toString(); private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException; public Object parseObject(final String source) throws ParseException; public Date parse(final String source) throws ParseException; public Object parseObject(final String source, final ParsePosition pos); public Date parse(final String source, final ParsePosition pos); private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote); private static Map<String, Integer> getDisplayNames(final int field, final Calendar definingCalendar, final Locale locale);  int adjustYear(final int twoDigitYear);  boolean isNextNumber();  int getFieldWidth();  boolean isNumber();  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  abstract boolean addRegex(FastDateParser parser, StringBuilder regex); private Strategy getStrategy(String formatField, final Calendar definingCalendar); private static ConcurrentMap<Locale, Strategy> getCache(final int field); private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  int modify(final int iValue);  int modify(final int iValue); long serialVersionUID=Optional[1L]; Locale JAPANESE_IMPERIAL=Optional[new Locale("ja", "JP", "JP")]; String pattern; TimeZone timeZone; Locale locale; Pattern parsePattern; Strategy[] strategies; int thisYear; String currentFormatField; Strategy nextStrategy; Pattern formatPattern=Optional[Pattern.compile("D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++")]; ConcurrentMap<Locale, Strategy>[] caches=Optional[new ConcurrentMap[Calendar.FIELD_COUNT]]; Strategy ABBREVIATED_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR) {; ;     /**;      * {@inheritDoc};      */;     @Override;     void setCalendar(final FastDateParser parser, final Calendar cal, final String value) {;         int iValue = Integer.parseInt(value);;         if (iValue < 100) {;             iValue = parser.adjustYear(iValue);;         };         cal.set(Calendar.YEAR, iValue);;     }; }]; Strategy NUMBER_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.MONTH) {; ;     @Override;     int modify(final int iValue) {;         return iValue - 1;;     }; }]; Strategy LITERAL_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR)]; Strategy WEEK_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_YEAR)]; Strategy WEEK_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_MONTH)]; Strategy DAY_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_YEAR)]; Strategy DAY_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_MONTH)]; Strategy DAY_OF_WEEK_IN_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_WEEK_IN_MONTH)]; Strategy HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY)]; Strategy MODULO_HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 24;;     }; }]; Strategy MODULO_HOUR_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 12;;     }; }
@Override [EOL] int modify(final int iValue) { [EOL]     return iValue % 12; [EOL] } protected FastDateParser(final String pattern, final TimeZone timeZone, final Locale locale);  CopyQuotedStrategy(final String formatField);  TextStrategy(final int field, final Calendar definingCalendar, final Locale locale);  NumberStrategy(final int field);  TimeZoneStrategy(final Locale locale); private void init(); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale();  Pattern getParsePattern(); public boolean equals(final Object obj); public int hashCode(); public String toString(); private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException; public Object parseObject(final String source) throws ParseException; public Date parse(final String source) throws ParseException; public Object parseObject(final String source, final ParsePosition pos); public Date parse(final String source, final ParsePosition pos); private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote); private static Map<String, Integer> getDisplayNames(final int field, final Calendar definingCalendar, final Locale locale);  int adjustYear(final int twoDigitYear);  boolean isNextNumber();  int getFieldWidth();  boolean isNumber();  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  abstract boolean addRegex(FastDateParser parser, StringBuilder regex); private Strategy getStrategy(String formatField, final Calendar definingCalendar); private static ConcurrentMap<Locale, Strategy> getCache(final int field); private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  int modify(final int iValue);  int modify(final int iValue); long serialVersionUID=Optional[1L]; Locale JAPANESE_IMPERIAL=Optional[new Locale("ja", "JP", "JP")]; String pattern; TimeZone timeZone; Locale locale; Pattern parsePattern; Strategy[] strategies; int thisYear; String currentFormatField; Strategy nextStrategy; Pattern formatPattern=Optional[Pattern.compile("D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++")]; ConcurrentMap<Locale, Strategy>[] caches=Optional[new ConcurrentMap[Calendar.FIELD_COUNT]]; Strategy ABBREVIATED_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR) {; ;     /**;      * {@inheritDoc};      */;     @Override;     void setCalendar(final FastDateParser parser, final Calendar cal, final String value) {;         int iValue = Integer.parseInt(value);;         if (iValue < 100) {;             iValue = parser.adjustYear(iValue);;         };         cal.set(Calendar.YEAR, iValue);;     }; }]; Strategy NUMBER_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.MONTH) {; ;     @Override;     int modify(final int iValue) {;         return iValue - 1;;     }; }]; Strategy LITERAL_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR)]; Strategy WEEK_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_YEAR)]; Strategy WEEK_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_MONTH)]; Strategy DAY_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_YEAR)]; Strategy DAY_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_MONTH)]; Strategy DAY_OF_WEEK_IN_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_WEEK_IN_MONTH)]; Strategy HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY)]; Strategy MODULO_HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 24;;     }; }]; Strategy MODULO_HOUR_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 12;;     }; }
public static String replaceSystemProperties(final Object source) { [EOL]     return new StrSubstitutor(StrLookup.systemPropertiesLookup()).replace(source); [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public static String replaceSystemProperties(final Object source) { [EOL]     return new StrSubstitutor(StrLookup.systemPropertiesLookup()).replace(source); [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public static String replaceSystemProperties(final Object source) { [EOL]     return new StrSubstitutor(StrLookup.systemPropertiesLookup()).replace(source); [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public StrSubstitutor() { [EOL]     this((StrLookup<?>) null, DEFAULT_PREFIX, DEFAULT_SUFFIX, DEFAULT_ESCAPE); [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public StrSubstitutor(final StrLookup<?> variableResolver) { [EOL]     this(variableResolver, DEFAULT_PREFIX, DEFAULT_SUFFIX, DEFAULT_ESCAPE); [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public StrSubstitutor(final StrLookup<?> variableResolver) { [EOL]     this(variableResolver, DEFAULT_PREFIX, DEFAULT_SUFFIX, DEFAULT_ESCAPE); [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public String replace(final String source) { [EOL]     if (source == null) { [EOL]         return null; [EOL]     } [EOL]     final StrBuilder buf = new StrBuilder(source); [EOL]     if (substitute(buf, 0, source.length()) == false) { [EOL]         return source; [EOL]     } [EOL]     return buf.toString(); [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public String replace(final String source, final int offset, final int length) { [EOL]     if (source == null) { [EOL]         return null; [EOL]     } [EOL]     final StrBuilder buf = new StrBuilder(length).append(source, offset, length); [EOL]     if (substitute(buf, 0, length) == false) { [EOL]         return source.substring(offset, offset + length); [EOL]     } [EOL]     return buf.toString(); [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public String replace(final char[] source) { [EOL]     if (source == null) { [EOL]         return null; [EOL]     } [EOL]     final StrBuilder buf = new StrBuilder(source.length).append(source); [EOL]     substitute(buf, 0, source.length); [EOL]     return buf.toString(); [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public String replace(final char[] source) { [EOL]     if (source == null) { [EOL]         return null; [EOL]     } [EOL]     final StrBuilder buf = new StrBuilder(source.length).append(source); [EOL]     substitute(buf, 0, source.length); [EOL]     return buf.toString(); [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public String replace(final char[] source, final int offset, final int length) { [EOL]     if (source == null) { [EOL]         return null; [EOL]     } [EOL]     final StrBuilder buf = new StrBuilder(length).append(source, offset, length); [EOL]     substitute(buf, 0, length); [EOL]     return buf.toString(); [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public String replace(final char[] source, final int offset, final int length) { [EOL]     if (source == null) { [EOL]         return null; [EOL]     } [EOL]     final StrBuilder buf = new StrBuilder(length).append(source, offset, length); [EOL]     substitute(buf, 0, length); [EOL]     return buf.toString(); [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public String replace(final char[] source, final int offset, final int length) { [EOL]     if (source == null) { [EOL]         return null; [EOL]     } [EOL]     final StrBuilder buf = new StrBuilder(length).append(source, offset, length); [EOL]     substitute(buf, 0, length); [EOL]     return buf.toString(); [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public String replace(final char[] source, final int offset, final int length) { [EOL]     if (source == null) { [EOL]         return null; [EOL]     } [EOL]     final StrBuilder buf = new StrBuilder(length).append(source, offset, length); [EOL]     substitute(buf, 0, length); [EOL]     return buf.toString(); [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public String replace(final StringBuffer source) { [EOL]     if (source == null) { [EOL]         return null; [EOL]     } [EOL]     final StrBuilder buf = new StrBuilder(source.length()).append(source); [EOL]     substitute(buf, 0, buf.length()); [EOL]     return buf.toString(); [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public String replace(final StringBuffer source) { [EOL]     if (source == null) { [EOL]         return null; [EOL]     } [EOL]     final StrBuilder buf = new StrBuilder(source.length()).append(source); [EOL]     substitute(buf, 0, buf.length()); [EOL]     return buf.toString(); [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public String replace(final StringBuffer source, final int offset, final int length) { [EOL]     if (source == null) { [EOL]         return null; [EOL]     } [EOL]     final StrBuilder buf = new StrBuilder(length).append(source, offset, length); [EOL]     substitute(buf, 0, length); [EOL]     return buf.toString(); [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public String replace(final StringBuffer source, final int offset, final int length) { [EOL]     if (source == null) { [EOL]         return null; [EOL]     } [EOL]     final StrBuilder buf = new StrBuilder(length).append(source, offset, length); [EOL]     substitute(buf, 0, length); [EOL]     return buf.toString(); [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public String replace(final StringBuffer source, final int offset, final int length) { [EOL]     if (source == null) { [EOL]         return null; [EOL]     } [EOL]     final StrBuilder buf = new StrBuilder(length).append(source, offset, length); [EOL]     substitute(buf, 0, length); [EOL]     return buf.toString(); [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public String replace(final StringBuffer source, final int offset, final int length) { [EOL]     if (source == null) { [EOL]         return null; [EOL]     } [EOL]     final StrBuilder buf = new StrBuilder(length).append(source, offset, length); [EOL]     substitute(buf, 0, length); [EOL]     return buf.toString(); [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public String replace(final StringBuffer source, final int offset, final int length) { [EOL]     if (source == null) { [EOL]         return null; [EOL]     } [EOL]     final StrBuilder buf = new StrBuilder(length).append(source, offset, length); [EOL]     substitute(buf, 0, length); [EOL]     return buf.toString(); [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public String replace(final StrBuilder source) { [EOL]     if (source == null) { [EOL]         return null; [EOL]     } [EOL]     final StrBuilder buf = new StrBuilder(source.length()).append(source); [EOL]     substitute(buf, 0, buf.length()); [EOL]     return buf.toString(); [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public String replace(final StrBuilder source) { [EOL]     if (source == null) { [EOL]         return null; [EOL]     } [EOL]     final StrBuilder buf = new StrBuilder(source.length()).append(source); [EOL]     substitute(buf, 0, buf.length()); [EOL]     return buf.toString(); [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public String replace(final StrBuilder source, final int offset, final int length) { [EOL]     if (source == null) { [EOL]         return null; [EOL]     } [EOL]     final StrBuilder buf = new StrBuilder(length).append(source, offset, length); [EOL]     substitute(buf, 0, length); [EOL]     return buf.toString(); [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public String replace(final StrBuilder source, final int offset, final int length) { [EOL]     if (source == null) { [EOL]         return null; [EOL]     } [EOL]     final StrBuilder buf = new StrBuilder(length).append(source, offset, length); [EOL]     substitute(buf, 0, length); [EOL]     return buf.toString(); [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public String replace(final StrBuilder source, final int offset, final int length) { [EOL]     if (source == null) { [EOL]         return null; [EOL]     } [EOL]     final StrBuilder buf = new StrBuilder(length).append(source, offset, length); [EOL]     substitute(buf, 0, length); [EOL]     return buf.toString(); [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public String replace(final StrBuilder source, final int offset, final int length) { [EOL]     if (source == null) { [EOL]         return null; [EOL]     } [EOL]     final StrBuilder buf = new StrBuilder(length).append(source, offset, length); [EOL]     substitute(buf, 0, length); [EOL]     return buf.toString(); [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public String replace(final StrBuilder source, final int offset, final int length) { [EOL]     if (source == null) { [EOL]         return null; [EOL]     } [EOL]     final StrBuilder buf = new StrBuilder(length).append(source, offset, length); [EOL]     substitute(buf, 0, length); [EOL]     return buf.toString(); [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public String replace(final Object source) { [EOL]     if (source == null) { [EOL]         return null; [EOL]     } [EOL]     final StrBuilder buf = new StrBuilder().append(source); [EOL]     substitute(buf, 0, buf.length()); [EOL]     return buf.toString(); [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public String replace(final Object source) { [EOL]     if (source == null) { [EOL]         return null; [EOL]     } [EOL]     final StrBuilder buf = new StrBuilder().append(source); [EOL]     substitute(buf, 0, buf.length()); [EOL]     return buf.toString(); [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public boolean replaceIn(final StringBuffer source) { [EOL]     if (source == null) { [EOL]         return false; [EOL]     } [EOL]     return replaceIn(source, 0, source.length()); [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public boolean replaceIn(final StringBuffer source) { [EOL]     if (source == null) { [EOL]         return false; [EOL]     } [EOL]     return replaceIn(source, 0, source.length()); [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public boolean replaceIn(final StringBuffer source, final int offset, final int length) { [EOL]     if (source == null) { [EOL]         return false; [EOL]     } [EOL]     final StrBuilder buf = new StrBuilder(length).append(source, offset, length); [EOL]     if (substitute(buf, 0, length) == false) { [EOL]         return false; [EOL]     } [EOL]     source.replace(offset, offset + length, buf.toString()); [EOL]     return true; [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public boolean replaceIn(final StrBuilder source) { [EOL]     if (source == null) { [EOL]         return false; [EOL]     } [EOL]     return substitute(source, 0, source.length()); [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public boolean replaceIn(final StrBuilder source) { [EOL]     if (source == null) { [EOL]         return false; [EOL]     } [EOL]     return substitute(source, 0, source.length()); [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public boolean replaceIn(final StrBuilder source, final int offset, final int length) { [EOL]     if (source == null) { [EOL]         return false; [EOL]     } [EOL]     return substitute(source, offset, length); [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public boolean replaceIn(final StrBuilder source, final int offset, final int length) { [EOL]     if (source == null) { [EOL]         return false; [EOL]     } [EOL]     return substitute(source, offset, length); [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher) { [EOL]     if (suffixMatcher == null) { [EOL]         throw new IllegalArgumentException("Variable suffix matcher must not be null!"); [EOL]     } [EOL]     this.suffixMatcher = suffixMatcher; [EOL]     return this; [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher) { [EOL]     if (suffixMatcher == null) { [EOL]         throw new IllegalArgumentException("Variable suffix matcher must not be null!"); [EOL]     } [EOL]     this.suffixMatcher = suffixMatcher; [EOL]     return this; [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public StrSubstitutor setVariableSuffix(final char suffix) { [EOL]     return setVariableSuffixMatcher(StrMatcher.charMatcher(suffix)); [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public StrSubstitutor setVariableSuffix(final String suffix) { [EOL]     if (suffix == null) { [EOL]         throw new IllegalArgumentException("Variable suffix must not be null!"); [EOL]     } [EOL]     return setVariableSuffixMatcher(StrMatcher.stringMatcher(suffix)); [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public StrSubstitutor setVariableSuffix(final String suffix) { [EOL]     if (suffix == null) { [EOL]         throw new IllegalArgumentException("Variable suffix must not be null!"); [EOL]     } [EOL]     return setVariableSuffixMatcher(StrMatcher.stringMatcher(suffix)); [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
private Fraction(final int numerator, final int denominator) { [EOL]     super(); [EOL]     this.numerator = numerator; [EOL]     this.denominator = denominator; [EOL] }
private Fraction(final int numerator, final int denominator) { [EOL]     super(); [EOL]     this.numerator = numerator; [EOL]     this.denominator = denominator; [EOL] }
public static Fraction getFraction(int numerator, int denominator) { [EOL]     if (denominator == 0) { [EOL]         throw new ArithmeticException("The denominator must not be zero"); [EOL]     } [EOL]     if (denominator < 0) { [EOL]         if (numerator == Integer.MIN_VALUE || denominator == Integer.MIN_VALUE) { [EOL]             throw new ArithmeticException("overflow: can't negate"); [EOL]         } [EOL]         numerator = -numerator; [EOL]         denominator = -denominator; [EOL]     } [EOL]     return new Fraction(numerator, denominator); [EOL] }
public static Fraction getFraction(int numerator, int denominator) { [EOL]     if (denominator == 0) { [EOL]         throw new ArithmeticException("The denominator must not be zero"); [EOL]     } [EOL]     if (denominator < 0) { [EOL]         if (numerator == Integer.MIN_VALUE || denominator == Integer.MIN_VALUE) { [EOL]             throw new ArithmeticException("overflow: can't negate"); [EOL]         } [EOL]         numerator = -numerator; [EOL]         denominator = -denominator; [EOL]     } [EOL]     return new Fraction(numerator, denominator); [EOL] }
public static Fraction getFraction(int numerator, int denominator) { [EOL]     if (denominator == 0) { [EOL]         throw new ArithmeticException("The denominator must not be zero"); [EOL]     } [EOL]     if (denominator < 0) { [EOL]         if (numerator == Integer.MIN_VALUE || denominator == Integer.MIN_VALUE) { [EOL]             throw new ArithmeticException("overflow: can't negate"); [EOL]         } [EOL]         numerator = -numerator; [EOL]         denominator = -denominator; [EOL]     } [EOL]     return new Fraction(numerator, denominator); [EOL] }
public static Fraction getFraction(int numerator, int denominator) { [EOL]     if (denominator == 0) { [EOL]         throw new ArithmeticException("The denominator must not be zero"); [EOL]     } [EOL]     if (denominator < 0) { [EOL]         if (numerator == Integer.MIN_VALUE || denominator == Integer.MIN_VALUE) { [EOL]             throw new ArithmeticException("overflow: can't negate"); [EOL]         } [EOL]         numerator = -numerator; [EOL]         denominator = -denominator; [EOL]     } [EOL]     return new Fraction(numerator, denominator); [EOL] }
public static Fraction getFraction(int numerator, int denominator) { [EOL]     if (denominator == 0) { [EOL]         throw new ArithmeticException("The denominator must not be zero"); [EOL]     } [EOL]     if (denominator < 0) { [EOL]         if (numerator == Integer.MIN_VALUE || denominator == Integer.MIN_VALUE) { [EOL]             throw new ArithmeticException("overflow: can't negate"); [EOL]         } [EOL]         numerator = -numerator; [EOL]         denominator = -denominator; [EOL]     } [EOL]     return new Fraction(numerator, denominator); [EOL] }
public static Fraction getFraction(int numerator, int denominator) { [EOL]     if (denominator == 0) { [EOL]         throw new ArithmeticException("The denominator must not be zero"); [EOL]     } [EOL]     if (denominator < 0) { [EOL]         if (numerator == Integer.MIN_VALUE || denominator == Integer.MIN_VALUE) { [EOL]             throw new ArithmeticException("overflow: can't negate"); [EOL]         } [EOL]         numerator = -numerator; [EOL]         denominator = -denominator; [EOL]     } [EOL]     return new Fraction(numerator, denominator); [EOL] }
public static Fraction getFraction(double value) { [EOL]     final int sign = value < 0 ? -1 : 1; [EOL]     value = Math.abs(value); [EOL]     if (value > Integer.MAX_VALUE || Double.isNaN(value)) { [EOL]         throw new ArithmeticException("The value must not be greater than Integer.MAX_VALUE or NaN"); [EOL]     } [EOL]     final int wholeNumber = (int) value; [EOL]     value -= wholeNumber; [EOL]     int numer0 = 0; [EOL]     int denom0 = 1; [EOL]     int numer1 = 1; [EOL]     int denom1 = 0; [EOL]     int numer2 = 0; [EOL]     int denom2 = 0; [EOL]     int a1 = (int) value; [EOL]     int a2 = 0; [EOL]     double x1 = 1; [EOL]     double x2 = 0; [EOL]     double y1 = value - a1; [EOL]     double y2 = 0; [EOL]     double delta1, delta2 = Double.MAX_VALUE; [EOL]     double fraction; [EOL]     int i = 1; [EOL]     do { [EOL]         delta1 = delta2; [EOL]         a2 = (int) (x1 / y1); [EOL]         x2 = y1; [EOL]         y2 = x1 - a2 * y1; [EOL]         numer2 = a1 * numer1 + numer0; [EOL]         denom2 = a1 * denom1 + denom0; [EOL]         fraction = (double) numer2 / (double) denom2; [EOL]         delta2 = Math.abs(value - fraction); [EOL]         a1 = a2; [EOL]         x1 = x2; [EOL]         y1 = y2; [EOL]         numer0 = numer1; [EOL]         denom0 = denom1; [EOL]         numer1 = numer2; [EOL]         denom1 = denom2; [EOL]         i++; [EOL]     } while (delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25); [EOL]     if (i == 25) { [EOL]         throw new ArithmeticException("Unable to convert double to fraction"); [EOL]     } [EOL]     return getReducedFraction((numer0 + wholeNumber * denom0) * sign, denom0); [EOL] }
public static Fraction getFraction(double value) { [EOL]     final int sign = value < 0 ? -1 : 1; [EOL]     value = Math.abs(value); [EOL]     if (value > Integer.MAX_VALUE || Double.isNaN(value)) { [EOL]         throw new ArithmeticException("The value must not be greater than Integer.MAX_VALUE or NaN"); [EOL]     } [EOL]     final int wholeNumber = (int) value; [EOL]     value -= wholeNumber; [EOL]     int numer0 = 0; [EOL]     int denom0 = 1; [EOL]     int numer1 = 1; [EOL]     int denom1 = 0; [EOL]     int numer2 = 0; [EOL]     int denom2 = 0; [EOL]     int a1 = (int) value; [EOL]     int a2 = 0; [EOL]     double x1 = 1; [EOL]     double x2 = 0; [EOL]     double y1 = value - a1; [EOL]     double y2 = 0; [EOL]     double delta1, delta2 = Double.MAX_VALUE; [EOL]     double fraction; [EOL]     int i = 1; [EOL]     do { [EOL]         delta1 = delta2; [EOL]         a2 = (int) (x1 / y1); [EOL]         x2 = y1; [EOL]         y2 = x1 - a2 * y1; [EOL]         numer2 = a1 * numer1 + numer0; [EOL]         denom2 = a1 * denom1 + denom0; [EOL]         fraction = (double) numer2 / (double) denom2; [EOL]         delta2 = Math.abs(value - fraction); [EOL]         a1 = a2; [EOL]         x1 = x2; [EOL]         y1 = y2; [EOL]         numer0 = numer1; [EOL]         denom0 = denom1; [EOL]         numer1 = numer2; [EOL]         denom1 = denom2; [EOL]         i++; [EOL]     } while (delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25); [EOL]     if (i == 25) { [EOL]         throw new ArithmeticException("Unable to convert double to fraction"); [EOL]     } [EOL]     return getReducedFraction((numer0 + wholeNumber * denom0) * sign, denom0); [EOL] }
public int getNumerator() { [EOL]     return numerator; [EOL] }
public int getNumerator() { [EOL]     return numerator; [EOL] }
public int getNumerator() { [EOL]     return numerator; [EOL] }
public int getDenominator() { [EOL]     return denominator; [EOL] }
public Fraction invert() { [EOL]     if (numerator == 0) { [EOL]         throw new ArithmeticException("Unable to invert zero."); [EOL]     } [EOL]     if (numerator == Integer.MIN_VALUE) { [EOL]         throw new ArithmeticException("overflow: can't negate numerator"); [EOL]     } [EOL]     if (numerator < 0) { [EOL]         return new Fraction(-denominator, -numerator); [EOL]     } else { [EOL]         return new Fraction(denominator, numerator); [EOL]     } [EOL] }
public Fraction invert() { [EOL]     if (numerator == 0) { [EOL]         throw new ArithmeticException("Unable to invert zero."); [EOL]     } [EOL]     if (numerator == Integer.MIN_VALUE) { [EOL]         throw new ArithmeticException("overflow: can't negate numerator"); [EOL]     } [EOL]     if (numerator < 0) { [EOL]         return new Fraction(-denominator, -numerator); [EOL]     } else { [EOL]         return new Fraction(denominator, numerator); [EOL]     } [EOL] }
public Fraction invert() { [EOL]     if (numerator == 0) { [EOL]         throw new ArithmeticException("Unable to invert zero."); [EOL]     } [EOL]     if (numerator == Integer.MIN_VALUE) { [EOL]         throw new ArithmeticException("overflow: can't negate numerator"); [EOL]     } [EOL]     if (numerator < 0) { [EOL]         return new Fraction(-denominator, -numerator); [EOL]     } else { [EOL]         return new Fraction(denominator, numerator); [EOL]     } [EOL] }
public Fraction invert() { [EOL]     if (numerator == 0) { [EOL]         throw new ArithmeticException("Unable to invert zero."); [EOL]     } [EOL]     if (numerator == Integer.MIN_VALUE) { [EOL]         throw new ArithmeticException("overflow: can't negate numerator"); [EOL]     } [EOL]     if (numerator < 0) { [EOL]         return new Fraction(-denominator, -numerator); [EOL]     } else { [EOL]         return new Fraction(denominator, numerator); [EOL]     } [EOL] }
private static int greatestCommonDivisor(int u, int v) { [EOL]     if (u == 0 || v == 0) { [EOL]         if (u == Integer.MIN_VALUE || v == Integer.MIN_VALUE) { [EOL]             throw new ArithmeticException("overflow: gcd is 2^31"); [EOL]         } [EOL]         return Math.abs(u) + Math.abs(v); [EOL]     } [EOL]     if (Math.abs(u) == 1 || Math.abs(v) == 1) { [EOL]         return 1; [EOL]     } [EOL]     if (u > 0) { [EOL]         u = -u; [EOL]     } [EOL]     if (v > 0) { [EOL]         v = -v; [EOL]     } [EOL]     int k = 0; [EOL]     while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { [EOL]         u /= 2; [EOL]         v /= 2; [EOL]         k++; [EOL]     } [EOL]     if (k == 31) { [EOL]         throw new ArithmeticException("overflow: gcd is 2^31"); [EOL]     } [EOL]     int t = (u & 1) == 1 ? v : -(u / 2); [EOL]     do { [EOL]         while ((t & 1) == 0) { [EOL]             t /= 2; [EOL]         } [EOL]         if (t > 0) { [EOL]             u = -t; [EOL]         } else { [EOL]             v = t; [EOL]         } [EOL]         t = (v - u) / 2; [EOL]     } while (t != 0); [EOL]     return -u * (1 << k); [EOL] }
private static int mulAndCheck(final int x, final int y) { [EOL]     final long m = (long) x * (long) y; [EOL]     if (m < Integer.MIN_VALUE || m > Integer.MAX_VALUE) { [EOL]         throw new ArithmeticException("overflow: mul"); [EOL]     } [EOL]     return (int) m; [EOL] }
private static int mulAndCheck(final int x, final int y) { [EOL]     final long m = (long) x * (long) y; [EOL]     if (m < Integer.MIN_VALUE || m > Integer.MAX_VALUE) { [EOL]         throw new ArithmeticException("overflow: mul"); [EOL]     } [EOL]     return (int) m; [EOL] }
private static int mulAndCheck(final int x, final int y) { [EOL]     final long m = (long) x * (long) y; [EOL]     if (m < Integer.MIN_VALUE || m > Integer.MAX_VALUE) { [EOL]         throw new ArithmeticException("overflow: mul"); [EOL]     } [EOL]     return (int) m; [EOL] }
private static int mulPosAndCheck(final int x, final int y) { [EOL]     final long m = (long) x * (long) y; [EOL]     if (m > Integer.MAX_VALUE) { [EOL]         throw new ArithmeticException("overflow: mulPos"); [EOL]     } [EOL]     return (int) m; [EOL] }
private static int mulPosAndCheck(final int x, final int y) { [EOL]     final long m = (long) x * (long) y; [EOL]     if (m > Integer.MAX_VALUE) { [EOL]         throw new ArithmeticException("overflow: mulPos"); [EOL]     } [EOL]     return (int) m; [EOL] }
private static int mulPosAndCheck(final int x, final int y) { [EOL]     final long m = (long) x * (long) y; [EOL]     if (m > Integer.MAX_VALUE) { [EOL]         throw new ArithmeticException("overflow: mulPos"); [EOL]     } [EOL]     return (int) m; [EOL] }
public Fraction multiplyBy(final Fraction fraction) { [EOL]     if (fraction == null) { [EOL]         throw new IllegalArgumentException("The fraction must not be null"); [EOL]     } [EOL]     if (numerator == 0 || fraction.numerator == 0) { [EOL]         return ZERO; [EOL]     } [EOL]     final int d1 = greatestCommonDivisor(numerator, fraction.denominator); [EOL]     final int d2 = greatestCommonDivisor(fraction.numerator, denominator); [EOL]     return getReducedFraction(mulAndCheck(numerator / d1, fraction.numerator / d2), mulPosAndCheck(denominator / d2, fraction.denominator / d1)); [EOL] }
public Fraction multiplyBy(final Fraction fraction) { [EOL]     if (fraction == null) { [EOL]         throw new IllegalArgumentException("The fraction must not be null"); [EOL]     } [EOL]     if (numerator == 0 || fraction.numerator == 0) { [EOL]         return ZERO; [EOL]     } [EOL]     final int d1 = greatestCommonDivisor(numerator, fraction.denominator); [EOL]     final int d2 = greatestCommonDivisor(fraction.numerator, denominator); [EOL]     return getReducedFraction(mulAndCheck(numerator / d1, fraction.numerator / d2), mulPosAndCheck(denominator / d2, fraction.denominator / d1)); [EOL] }
public Fraction multiplyBy(final Fraction fraction) { [EOL]     if (fraction == null) { [EOL]         throw new IllegalArgumentException("The fraction must not be null"); [EOL]     } [EOL]     if (numerator == 0 || fraction.numerator == 0) { [EOL]         return ZERO; [EOL]     } [EOL]     final int d1 = greatestCommonDivisor(numerator, fraction.denominator); [EOL]     final int d2 = greatestCommonDivisor(fraction.numerator, denominator); [EOL]     return getReducedFraction(mulAndCheck(numerator / d1, fraction.numerator / d2), mulPosAndCheck(denominator / d2, fraction.denominator / d1)); [EOL] }
public Fraction multiplyBy(final Fraction fraction) { [EOL]     if (fraction == null) { [EOL]         throw new IllegalArgumentException("The fraction must not be null"); [EOL]     } [EOL]     if (numerator == 0 || fraction.numerator == 0) { [EOL]         return ZERO; [EOL]     } [EOL]     final int d1 = greatestCommonDivisor(numerator, fraction.denominator); [EOL]     final int d2 = greatestCommonDivisor(fraction.numerator, denominator); [EOL]     return getReducedFraction(mulAndCheck(numerator / d1, fraction.numerator / d2), mulPosAndCheck(denominator / d2, fraction.denominator / d1)); [EOL] }
public Fraction divideBy(final Fraction fraction) { [EOL]     if (fraction == null) { [EOL]         throw new IllegalArgumentException("The fraction must not be null"); [EOL]     } [EOL]     if (fraction.numerator == 0) { [EOL]         throw new ArithmeticException("The fraction to divide by must not be zero"); [EOL]     } [EOL]     return multiplyBy(fraction.invert()); [EOL] }
public Fraction divideBy(final Fraction fraction) { [EOL]     if (fraction == null) { [EOL]         throw new IllegalArgumentException("The fraction must not be null"); [EOL]     } [EOL]     if (fraction.numerator == 0) { [EOL]         throw new ArithmeticException("The fraction to divide by must not be zero"); [EOL]     } [EOL]     return multiplyBy(fraction.invert()); [EOL] }
public Fraction divideBy(final Fraction fraction) { [EOL]     if (fraction == null) { [EOL]         throw new IllegalArgumentException("The fraction must not be null"); [EOL]     } [EOL]     if (fraction.numerator == 0) { [EOL]         throw new ArithmeticException("The fraction to divide by must not be zero"); [EOL]     } [EOL]     return multiplyBy(fraction.invert()); [EOL] }
@Override [EOL] public int hashCode() { [EOL]     if (hashCode == 0) { [EOL]         hashCode = 37 * (37 * 17 + getNumerator()) + getDenominator(); [EOL]     } [EOL]     return hashCode; [EOL] }
@Override [EOL] public int hashCode() { [EOL]     if (hashCode == 0) { [EOL]         hashCode = 37 * (37 * 17 + getNumerator()) + getDenominator(); [EOL]     } [EOL]     return hashCode; [EOL] }
public CharSequenceUtils() { [EOL]     super(); [EOL] }
static int indexOf(final CharSequence cs, final CharSequence searchChar, final int start) { [EOL]     return cs.toString().indexOf(searchChar.toString(), start); [EOL] }
static int indexOf(final CharSequence cs, final CharSequence searchChar, final int start) { [EOL]     return cs.toString().indexOf(searchChar.toString(), start); [EOL] }
static int indexOf(final CharSequence cs, final CharSequence searchChar, final int start) { [EOL]     return cs.toString().indexOf(searchChar.toString(), start); [EOL] }
static int indexOf(final CharSequence cs, final CharSequence searchChar, final int start) { [EOL]     return cs.toString().indexOf(searchChar.toString(), start); [EOL] }
static int indexOf(final CharSequence cs, final CharSequence searchChar, final int start) { [EOL]     return cs.toString().indexOf(searchChar.toString(), start); [EOL] }
static int indexOf(final CharSequence cs, final CharSequence searchChar, final int start) { [EOL]     return cs.toString().indexOf(searchChar.toString(), start); [EOL] }
static int indexOf(final CharSequence cs, final CharSequence searchChar, final int start) { [EOL]     return cs.toString().indexOf(searchChar.toString(), start); [EOL] }
static int indexOf(final CharSequence cs, final CharSequence searchChar, final int start) { [EOL]     return cs.toString().indexOf(searchChar.toString(), start); [EOL] }
static int lastIndexOf(final CharSequence cs, final CharSequence searchChar, final int start) { [EOL]     return cs.toString().lastIndexOf(searchChar.toString(), start); [EOL] }
static int lastIndexOf(final CharSequence cs, final CharSequence searchChar, final int start) { [EOL]     return cs.toString().lastIndexOf(searchChar.toString(), start); [EOL] }
static int lastIndexOf(final CharSequence cs, final CharSequence searchChar, final int start) { [EOL]     return cs.toString().lastIndexOf(searchChar.toString(), start); [EOL] }
static int lastIndexOf(final CharSequence cs, final CharSequence searchChar, final int start) { [EOL]     return cs.toString().lastIndexOf(searchChar.toString(), start); [EOL] }
static int lastIndexOf(final CharSequence cs, final CharSequence searchChar, final int start) { [EOL]     return cs.toString().lastIndexOf(searchChar.toString(), start); [EOL] }
static int lastIndexOf(final CharSequence cs, final CharSequence searchChar, final int start) { [EOL]     return cs.toString().lastIndexOf(searchChar.toString(), start); [EOL] }
static int lastIndexOf(final CharSequence cs, final CharSequence searchChar, final int start) { [EOL]     return cs.toString().lastIndexOf(searchChar.toString(), start); [EOL] }
static int lastIndexOf(final CharSequence cs, final CharSequence searchChar, final int start) { [EOL]     return cs.toString().lastIndexOf(searchChar.toString(), start); [EOL] }
static char[] toCharArray(final CharSequence cs) { [EOL]     if (cs instanceof String) { [EOL]         return ((String) cs).toCharArray(); [EOL]     } else { [EOL]         final int sz = cs.length(); [EOL]         final char[] array = new char[cs.length()]; [EOL]         for (int i = 0; i < sz; i++) { [EOL]             array[i] = cs.charAt(i); [EOL]         } [EOL]         return array; [EOL]     } [EOL] }
static char[] toCharArray(final CharSequence cs) { [EOL]     if (cs instanceof String) { [EOL]         return ((String) cs).toCharArray(); [EOL]     } else { [EOL]         final int sz = cs.length(); [EOL]         final char[] array = new char[cs.length()]; [EOL]         for (int i = 0; i < sz; i++) { [EOL]             array[i] = cs.charAt(i); [EOL]         } [EOL]         return array; [EOL]     } [EOL] }
@Override [EOL] public String previous() { [EOL]     if (hasPrevious()) { [EOL]         return tokens[--tokenPos]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public String previous() { [EOL]     if (hasPrevious()) { [EOL]         return tokens[--tokenPos]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public void remove() { [EOL]     throw new UnsupportedOperationException("remove() is unsupported"); [EOL] }
@Override [EOL] public void set(final String obj) { [EOL]     throw new UnsupportedOperationException("set() is unsupported"); [EOL] }
@Override [EOL] public void add(final String obj) { [EOL]     throw new UnsupportedOperationException("add() is unsupported"); [EOL] }
public static boolean equals(final Annotation a1, final Annotation a2) { [EOL]     if (a1 == a2) { [EOL]         return true; [EOL]     } [EOL]     if (a1 == null || a2 == null) { [EOL]         return false; [EOL]     } [EOL]     final Class<? extends Annotation> type = a1.annotationType(); [EOL]     final Class<? extends Annotation> type2 = a2.annotationType(); [EOL]     Validate.notNull(type, "Annotation %s with null annotationType()", a1); [EOL]     Validate.notNull(type2, "Annotation %s with null annotationType()", a2); [EOL]     if (!type.equals(type2)) { [EOL]         return false; [EOL]     } [EOL]     try { [EOL]         for (final Method m : type.getDeclaredMethods()) { [EOL]             if (m.getParameterTypes().length == 0 && isValidAnnotationMemberType(m.getReturnType())) { [EOL]                 final Object v1 = m.invoke(a1); [EOL]                 final Object v2 = m.invoke(a2); [EOL]                 if (!memberEquals(m.getReturnType(), v1, v2)) { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } catch (final IllegalAccessException ex) { [EOL]         return false; [EOL]     } catch (final InvocationTargetException ex) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] } public AnnotationUtils(); protected String getShortClassName(final java.lang.Class<?> cls); protected void appendDetail(final StringBuffer buffer, final String fieldName, Object value); public static boolean equals(final Annotation a1, final Annotation a2); public static int hashCode(final Annotation a); public static String toString(final Annotation a); public static boolean isValidAnnotationMemberType(Class<?> type); private static int hashMember(final String name, final Object value); private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2); private static boolean arrayMemberEquals(final Class<?> componentType, final Object o1, final Object o2); private static boolean annotationArrayMemberEquals(final Annotation[] a1, final Annotation[] a2); private static int arrayMemberHash(final Class<?> componentType, final Object o); ToStringStyle TO_STRING_STYLE=Optional[new ToStringStyle() {; ;     /**;      * Serialization version;      */;     private static final long serialVersionUID = 1L;; ;     {;         setDefaultFullDetail(true);;         setArrayContentDetail(true);;         setUseClassName(true);;         setUseShortClassName(true);;         setUseIdentityHashCode(false);;         setContentStart("(");;         setContentEnd(")");;         setFieldSeparator(", ");;         setArrayStart("[");;         setArrayEnd("]");;     }; ;     /**;      * {@inheritDoc};      */;     @Override;     protected String getShortClassName(final java.lang.Class<?> cls) {;         Class<? extends Annotation> annotationType = null;;         for (final Class<?> iface : ClassUtils.getAllInterfaces(cls)) {;             if (Annotation.class.isAssignableFrom(iface)) {;                 // OK because we just checked the assignability;                 @SuppressWarnings("unchecked");                 final Class<? extends Annotation> found = (Class<? extends Annotation>) iface;;                 annotationType = found;;                 break;;             };         };         return new StringBuilder(annotationType == null ? "" : annotationType.getName()).insert(0, '@').toString();;     }; ;     /**;      * {@inheritDoc};      */;     @Override;     protected void appendDetail(final StringBuffer buffer, final String fieldName, Object value) {;         if (value instanceof Annotation) {;             value = AnnotationUtils.toString((Annotation) value);;         };         super.appendDetail(buffer, fieldName, value);;     }; }
public static boolean equals(final Annotation a1, final Annotation a2) { [EOL]     if (a1 == a2) { [EOL]         return true; [EOL]     } [EOL]     if (a1 == null || a2 == null) { [EOL]         return false; [EOL]     } [EOL]     final Class<? extends Annotation> type = a1.annotationType(); [EOL]     final Class<? extends Annotation> type2 = a2.annotationType(); [EOL]     Validate.notNull(type, "Annotation %s with null annotationType()", a1); [EOL]     Validate.notNull(type2, "Annotation %s with null annotationType()", a2); [EOL]     if (!type.equals(type2)) { [EOL]         return false; [EOL]     } [EOL]     try { [EOL]         for (final Method m : type.getDeclaredMethods()) { [EOL]             if (m.getParameterTypes().length == 0 && isValidAnnotationMemberType(m.getReturnType())) { [EOL]                 final Object v1 = m.invoke(a1); [EOL]                 final Object v2 = m.invoke(a2); [EOL]                 if (!memberEquals(m.getReturnType(), v1, v2)) { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } catch (final IllegalAccessException ex) { [EOL]         return false; [EOL]     } catch (final InvocationTargetException ex) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] } public AnnotationUtils(); protected String getShortClassName(final java.lang.Class<?> cls); protected void appendDetail(final StringBuffer buffer, final String fieldName, Object value); public static boolean equals(final Annotation a1, final Annotation a2); public static int hashCode(final Annotation a); public static String toString(final Annotation a); public static boolean isValidAnnotationMemberType(Class<?> type); private static int hashMember(final String name, final Object value); private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2); private static boolean arrayMemberEquals(final Class<?> componentType, final Object o1, final Object o2); private static boolean annotationArrayMemberEquals(final Annotation[] a1, final Annotation[] a2); private static int arrayMemberHash(final Class<?> componentType, final Object o); ToStringStyle TO_STRING_STYLE=Optional[new ToStringStyle() {; ;     /**;      * Serialization version;      */;     private static final long serialVersionUID = 1L;; ;     {;         setDefaultFullDetail(true);;         setArrayContentDetail(true);;         setUseClassName(true);;         setUseShortClassName(true);;         setUseIdentityHashCode(false);;         setContentStart("(");;         setContentEnd(")");;         setFieldSeparator(", ");;         setArrayStart("[");;         setArrayEnd("]");;     }; ;     /**;      * {@inheritDoc};      */;     @Override;     protected String getShortClassName(final java.lang.Class<?> cls) {;         Class<? extends Annotation> annotationType = null;;         for (final Class<?> iface : ClassUtils.getAllInterfaces(cls)) {;             if (Annotation.class.isAssignableFrom(iface)) {;                 // OK because we just checked the assignability;                 @SuppressWarnings("unchecked");                 final Class<? extends Annotation> found = (Class<? extends Annotation>) iface;;                 annotationType = found;;                 break;;             };         };         return new StringBuilder(annotationType == null ? "" : annotationType.getName()).insert(0, '@').toString();;     }; ;     /**;      * {@inheritDoc};      */;     @Override;     protected void appendDetail(final StringBuffer buffer, final String fieldName, Object value) {;         if (value instanceof Annotation) {;             value = AnnotationUtils.toString((Annotation) value);;         };         super.appendDetail(buffer, fieldName, value);;     }; }
public static boolean equals(final Annotation a1, final Annotation a2) { [EOL]     if (a1 == a2) { [EOL]         return true; [EOL]     } [EOL]     if (a1 == null || a2 == null) { [EOL]         return false; [EOL]     } [EOL]     final Class<? extends Annotation> type = a1.annotationType(); [EOL]     final Class<? extends Annotation> type2 = a2.annotationType(); [EOL]     Validate.notNull(type, "Annotation %s with null annotationType()", a1); [EOL]     Validate.notNull(type2, "Annotation %s with null annotationType()", a2); [EOL]     if (!type.equals(type2)) { [EOL]         return false; [EOL]     } [EOL]     try { [EOL]         for (final Method m : type.getDeclaredMethods()) { [EOL]             if (m.getParameterTypes().length == 0 && isValidAnnotationMemberType(m.getReturnType())) { [EOL]                 final Object v1 = m.invoke(a1); [EOL]                 final Object v2 = m.invoke(a2); [EOL]                 if (!memberEquals(m.getReturnType(), v1, v2)) { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } catch (final IllegalAccessException ex) { [EOL]         return false; [EOL]     } catch (final InvocationTargetException ex) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] } public AnnotationUtils(); protected String getShortClassName(final java.lang.Class<?> cls); protected void appendDetail(final StringBuffer buffer, final String fieldName, Object value); public static boolean equals(final Annotation a1, final Annotation a2); public static int hashCode(final Annotation a); public static String toString(final Annotation a); public static boolean isValidAnnotationMemberType(Class<?> type); private static int hashMember(final String name, final Object value); private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2); private static boolean arrayMemberEquals(final Class<?> componentType, final Object o1, final Object o2); private static boolean annotationArrayMemberEquals(final Annotation[] a1, final Annotation[] a2); private static int arrayMemberHash(final Class<?> componentType, final Object o); ToStringStyle TO_STRING_STYLE=Optional[new ToStringStyle() {; ;     /**;      * Serialization version;      */;     private static final long serialVersionUID = 1L;; ;     {;         setDefaultFullDetail(true);;         setArrayContentDetail(true);;         setUseClassName(true);;         setUseShortClassName(true);;         setUseIdentityHashCode(false);;         setContentStart("(");;         setContentEnd(")");;         setFieldSeparator(", ");;         setArrayStart("[");;         setArrayEnd("]");;     }; ;     /**;      * {@inheritDoc};      */;     @Override;     protected String getShortClassName(final java.lang.Class<?> cls) {;         Class<? extends Annotation> annotationType = null;;         for (final Class<?> iface : ClassUtils.getAllInterfaces(cls)) {;             if (Annotation.class.isAssignableFrom(iface)) {;                 // OK because we just checked the assignability;                 @SuppressWarnings("unchecked");                 final Class<? extends Annotation> found = (Class<? extends Annotation>) iface;;                 annotationType = found;;                 break;;             };         };         return new StringBuilder(annotationType == null ? "" : annotationType.getName()).insert(0, '@').toString();;     }; ;     /**;      * {@inheritDoc};      */;     @Override;     protected void appendDetail(final StringBuffer buffer, final String fieldName, Object value) {;         if (value instanceof Annotation) {;             value = AnnotationUtils.toString((Annotation) value);;         };         super.appendDetail(buffer, fieldName, value);;     }; }
public static boolean equals(final Annotation a1, final Annotation a2) { [EOL]     if (a1 == a2) { [EOL]         return true; [EOL]     } [EOL]     if (a1 == null || a2 == null) { [EOL]         return false; [EOL]     } [EOL]     final Class<? extends Annotation> type = a1.annotationType(); [EOL]     final Class<? extends Annotation> type2 = a2.annotationType(); [EOL]     Validate.notNull(type, "Annotation %s with null annotationType()", a1); [EOL]     Validate.notNull(type2, "Annotation %s with null annotationType()", a2); [EOL]     if (!type.equals(type2)) { [EOL]         return false; [EOL]     } [EOL]     try { [EOL]         for (final Method m : type.getDeclaredMethods()) { [EOL]             if (m.getParameterTypes().length == 0 && isValidAnnotationMemberType(m.getReturnType())) { [EOL]                 final Object v1 = m.invoke(a1); [EOL]                 final Object v2 = m.invoke(a2); [EOL]                 if (!memberEquals(m.getReturnType(), v1, v2)) { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } catch (final IllegalAccessException ex) { [EOL]         return false; [EOL]     } catch (final InvocationTargetException ex) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] } public AnnotationUtils(); protected String getShortClassName(final java.lang.Class<?> cls); protected void appendDetail(final StringBuffer buffer, final String fieldName, Object value); public static boolean equals(final Annotation a1, final Annotation a2); public static int hashCode(final Annotation a); public static String toString(final Annotation a); public static boolean isValidAnnotationMemberType(Class<?> type); private static int hashMember(final String name, final Object value); private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2); private static boolean arrayMemberEquals(final Class<?> componentType, final Object o1, final Object o2); private static boolean annotationArrayMemberEquals(final Annotation[] a1, final Annotation[] a2); private static int arrayMemberHash(final Class<?> componentType, final Object o); ToStringStyle TO_STRING_STYLE=Optional[new ToStringStyle() {; ;     /**;      * Serialization version;      */;     private static final long serialVersionUID = 1L;; ;     {;         setDefaultFullDetail(true);;         setArrayContentDetail(true);;         setUseClassName(true);;         setUseShortClassName(true);;         setUseIdentityHashCode(false);;         setContentStart("(");;         setContentEnd(")");;         setFieldSeparator(", ");;         setArrayStart("[");;         setArrayEnd("]");;     }; ;     /**;      * {@inheritDoc};      */;     @Override;     protected String getShortClassName(final java.lang.Class<?> cls) {;         Class<? extends Annotation> annotationType = null;;         for (final Class<?> iface : ClassUtils.getAllInterfaces(cls)) {;             if (Annotation.class.isAssignableFrom(iface)) {;                 // OK because we just checked the assignability;                 @SuppressWarnings("unchecked");                 final Class<? extends Annotation> found = (Class<? extends Annotation>) iface;;                 annotationType = found;;                 break;;             };         };         return new StringBuilder(annotationType == null ? "" : annotationType.getName()).insert(0, '@').toString();;     }; ;     /**;      * {@inheritDoc};      */;     @Override;     protected void appendDetail(final StringBuffer buffer, final String fieldName, Object value) {;         if (value instanceof Annotation) {;             value = AnnotationUtils.toString((Annotation) value);;         };         super.appendDetail(buffer, fieldName, value);;     }; }
public static boolean equals(final Annotation a1, final Annotation a2) { [EOL]     if (a1 == a2) { [EOL]         return true; [EOL]     } [EOL]     if (a1 == null || a2 == null) { [EOL]         return false; [EOL]     } [EOL]     final Class<? extends Annotation> type = a1.annotationType(); [EOL]     final Class<? extends Annotation> type2 = a2.annotationType(); [EOL]     Validate.notNull(type, "Annotation %s with null annotationType()", a1); [EOL]     Validate.notNull(type2, "Annotation %s with null annotationType()", a2); [EOL]     if (!type.equals(type2)) { [EOL]         return false; [EOL]     } [EOL]     try { [EOL]         for (final Method m : type.getDeclaredMethods()) { [EOL]             if (m.getParameterTypes().length == 0 && isValidAnnotationMemberType(m.getReturnType())) { [EOL]                 final Object v1 = m.invoke(a1); [EOL]                 final Object v2 = m.invoke(a2); [EOL]                 if (!memberEquals(m.getReturnType(), v1, v2)) { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } catch (final IllegalAccessException ex) { [EOL]         return false; [EOL]     } catch (final InvocationTargetException ex) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] } public AnnotationUtils(); protected String getShortClassName(final java.lang.Class<?> cls); protected void appendDetail(final StringBuffer buffer, final String fieldName, Object value); public static boolean equals(final Annotation a1, final Annotation a2); public static int hashCode(final Annotation a); public static String toString(final Annotation a); public static boolean isValidAnnotationMemberType(Class<?> type); private static int hashMember(final String name, final Object value); private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2); private static boolean arrayMemberEquals(final Class<?> componentType, final Object o1, final Object o2); private static boolean annotationArrayMemberEquals(final Annotation[] a1, final Annotation[] a2); private static int arrayMemberHash(final Class<?> componentType, final Object o); ToStringStyle TO_STRING_STYLE=Optional[new ToStringStyle() {; ;     /**;      * Serialization version;      */;     private static final long serialVersionUID = 1L;; ;     {;         setDefaultFullDetail(true);;         setArrayContentDetail(true);;         setUseClassName(true);;         setUseShortClassName(true);;         setUseIdentityHashCode(false);;         setContentStart("(");;         setContentEnd(")");;         setFieldSeparator(", ");;         setArrayStart("[");;         setArrayEnd("]");;     }; ;     /**;      * {@inheritDoc};      */;     @Override;     protected String getShortClassName(final java.lang.Class<?> cls) {;         Class<? extends Annotation> annotationType = null;;         for (final Class<?> iface : ClassUtils.getAllInterfaces(cls)) {;             if (Annotation.class.isAssignableFrom(iface)) {;                 // OK because we just checked the assignability;                 @SuppressWarnings("unchecked");                 final Class<? extends Annotation> found = (Class<? extends Annotation>) iface;;                 annotationType = found;;                 break;;             };         };         return new StringBuilder(annotationType == null ? "" : annotationType.getName()).insert(0, '@').toString();;     }; ;     /**;      * {@inheritDoc};      */;     @Override;     protected void appendDetail(final StringBuffer buffer, final String fieldName, Object value) {;         if (value instanceof Annotation) {;             value = AnnotationUtils.toString((Annotation) value);;         };         super.appendDetail(buffer, fieldName, value);;     }; }
public static boolean equals(final Annotation a1, final Annotation a2) { [EOL]     if (a1 == a2) { [EOL]         return true; [EOL]     } [EOL]     if (a1 == null || a2 == null) { [EOL]         return false; [EOL]     } [EOL]     final Class<? extends Annotation> type = a1.annotationType(); [EOL]     final Class<? extends Annotation> type2 = a2.annotationType(); [EOL]     Validate.notNull(type, "Annotation %s with null annotationType()", a1); [EOL]     Validate.notNull(type2, "Annotation %s with null annotationType()", a2); [EOL]     if (!type.equals(type2)) { [EOL]         return false; [EOL]     } [EOL]     try { [EOL]         for (final Method m : type.getDeclaredMethods()) { [EOL]             if (m.getParameterTypes().length == 0 && isValidAnnotationMemberType(m.getReturnType())) { [EOL]                 final Object v1 = m.invoke(a1); [EOL]                 final Object v2 = m.invoke(a2); [EOL]                 if (!memberEquals(m.getReturnType(), v1, v2)) { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } catch (final IllegalAccessException ex) { [EOL]         return false; [EOL]     } catch (final InvocationTargetException ex) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] } public AnnotationUtils(); protected String getShortClassName(final java.lang.Class<?> cls); protected void appendDetail(final StringBuffer buffer, final String fieldName, Object value); public static boolean equals(final Annotation a1, final Annotation a2); public static int hashCode(final Annotation a); public static String toString(final Annotation a); public static boolean isValidAnnotationMemberType(Class<?> type); private static int hashMember(final String name, final Object value); private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2); private static boolean arrayMemberEquals(final Class<?> componentType, final Object o1, final Object o2); private static boolean annotationArrayMemberEquals(final Annotation[] a1, final Annotation[] a2); private static int arrayMemberHash(final Class<?> componentType, final Object o); ToStringStyle TO_STRING_STYLE=Optional[new ToStringStyle() {; ;     /**;      * Serialization version;      */;     private static final long serialVersionUID = 1L;; ;     {;         setDefaultFullDetail(true);;         setArrayContentDetail(true);;         setUseClassName(true);;         setUseShortClassName(true);;         setUseIdentityHashCode(false);;         setContentStart("(");;         setContentEnd(")");;         setFieldSeparator(", ");;         setArrayStart("[");;         setArrayEnd("]");;     }; ;     /**;      * {@inheritDoc};      */;     @Override;     protected String getShortClassName(final java.lang.Class<?> cls) {;         Class<? extends Annotation> annotationType = null;;         for (final Class<?> iface : ClassUtils.getAllInterfaces(cls)) {;             if (Annotation.class.isAssignableFrom(iface)) {;                 // OK because we just checked the assignability;                 @SuppressWarnings("unchecked");                 final Class<? extends Annotation> found = (Class<? extends Annotation>) iface;;                 annotationType = found;;                 break;;             };         };         return new StringBuilder(annotationType == null ? "" : annotationType.getName()).insert(0, '@').toString();;     }; ;     /**;      * {@inheritDoc};      */;     @Override;     protected void appendDetail(final StringBuffer buffer, final String fieldName, Object value) {;         if (value instanceof Annotation) {;             value = AnnotationUtils.toString((Annotation) value);;         };         super.appendDetail(buffer, fieldName, value);;     }; }
public static boolean equals(final Annotation a1, final Annotation a2) { [EOL]     if (a1 == a2) { [EOL]         return true; [EOL]     } [EOL]     if (a1 == null || a2 == null) { [EOL]         return false; [EOL]     } [EOL]     final Class<? extends Annotation> type = a1.annotationType(); [EOL]     final Class<? extends Annotation> type2 = a2.annotationType(); [EOL]     Validate.notNull(type, "Annotation %s with null annotationType()", a1); [EOL]     Validate.notNull(type2, "Annotation %s with null annotationType()", a2); [EOL]     if (!type.equals(type2)) { [EOL]         return false; [EOL]     } [EOL]     try { [EOL]         for (final Method m : type.getDeclaredMethods()) { [EOL]             if (m.getParameterTypes().length == 0 && isValidAnnotationMemberType(m.getReturnType())) { [EOL]                 final Object v1 = m.invoke(a1); [EOL]                 final Object v2 = m.invoke(a2); [EOL]                 if (!memberEquals(m.getReturnType(), v1, v2)) { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } catch (final IllegalAccessException ex) { [EOL]         return false; [EOL]     } catch (final InvocationTargetException ex) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] } public AnnotationUtils(); protected String getShortClassName(final java.lang.Class<?> cls); protected void appendDetail(final StringBuffer buffer, final String fieldName, Object value); public static boolean equals(final Annotation a1, final Annotation a2); public static int hashCode(final Annotation a); public static String toString(final Annotation a); public static boolean isValidAnnotationMemberType(Class<?> type); private static int hashMember(final String name, final Object value); private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2); private static boolean arrayMemberEquals(final Class<?> componentType, final Object o1, final Object o2); private static boolean annotationArrayMemberEquals(final Annotation[] a1, final Annotation[] a2); private static int arrayMemberHash(final Class<?> componentType, final Object o); ToStringStyle TO_STRING_STYLE=Optional[new ToStringStyle() {; ;     /**;      * Serialization version;      */;     private static final long serialVersionUID = 1L;; ;     {;         setDefaultFullDetail(true);;         setArrayContentDetail(true);;         setUseClassName(true);;         setUseShortClassName(true);;         setUseIdentityHashCode(false);;         setContentStart("(");;         setContentEnd(")");;         setFieldSeparator(", ");;         setArrayStart("[");;         setArrayEnd("]");;     }; ;     /**;      * {@inheritDoc};      */;     @Override;     protected String getShortClassName(final java.lang.Class<?> cls) {;         Class<? extends Annotation> annotationType = null;;         for (final Class<?> iface : ClassUtils.getAllInterfaces(cls)) {;             if (Annotation.class.isAssignableFrom(iface)) {;                 // OK because we just checked the assignability;                 @SuppressWarnings("unchecked");                 final Class<? extends Annotation> found = (Class<? extends Annotation>) iface;;                 annotationType = found;;                 break;;             };         };         return new StringBuilder(annotationType == null ? "" : annotationType.getName()).insert(0, '@').toString();;     }; ;     /**;      * {@inheritDoc};      */;     @Override;     protected void appendDetail(final StringBuffer buffer, final String fieldName, Object value) {;         if (value instanceof Annotation) {;             value = AnnotationUtils.toString((Annotation) value);;         };         super.appendDetail(buffer, fieldName, value);;     }; }
public static boolean isValidAnnotationMemberType(Class<?> type) { [EOL]     if (type == null) { [EOL]         return false; [EOL]     } [EOL]     if (type.isArray()) { [EOL]         type = type.getComponentType(); [EOL]     } [EOL]     return type.isPrimitive() || type.isEnum() || type.isAnnotation() || String.class.equals(type) || Class.class.equals(type); [EOL] } public AnnotationUtils(); protected String getShortClassName(final java.lang.Class<?> cls); protected void appendDetail(final StringBuffer buffer, final String fieldName, Object value); public static boolean equals(final Annotation a1, final Annotation a2); public static int hashCode(final Annotation a); public static String toString(final Annotation a); public static boolean isValidAnnotationMemberType(Class<?> type); private static int hashMember(final String name, final Object value); private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2); private static boolean arrayMemberEquals(final Class<?> componentType, final Object o1, final Object o2); private static boolean annotationArrayMemberEquals(final Annotation[] a1, final Annotation[] a2); private static int arrayMemberHash(final Class<?> componentType, final Object o); ToStringStyle TO_STRING_STYLE=Optional[new ToStringStyle() {; ;     /**;      * Serialization version;      */;     private static final long serialVersionUID = 1L;; ;     {;         setDefaultFullDetail(true);;         setArrayContentDetail(true);;         setUseClassName(true);;         setUseShortClassName(true);;         setUseIdentityHashCode(false);;         setContentStart("(");;         setContentEnd(")");;         setFieldSeparator(", ");;         setArrayStart("[");;         setArrayEnd("]");;     }; ;     /**;      * {@inheritDoc};      */;     @Override;     protected String getShortClassName(final java.lang.Class<?> cls) {;         Class<? extends Annotation> annotationType = null;;         for (final Class<?> iface : ClassUtils.getAllInterfaces(cls)) {;             if (Annotation.class.isAssignableFrom(iface)) {;                 // OK because we just checked the assignability;                 @SuppressWarnings("unchecked");                 final Class<? extends Annotation> found = (Class<? extends Annotation>) iface;;                 annotationType = found;;                 break;;             };         };         return new StringBuilder(annotationType == null ? "" : annotationType.getName()).insert(0, '@').toString();;     }; ;     /**;      * {@inheritDoc};      */;     @Override;     protected void appendDetail(final StringBuffer buffer, final String fieldName, Object value) {;         if (value instanceof Annotation) {;             value = AnnotationUtils.toString((Annotation) value);;         };         super.appendDetail(buffer, fieldName, value);;     }; }
public static boolean isValidAnnotationMemberType(Class<?> type) { [EOL]     if (type == null) { [EOL]         return false; [EOL]     } [EOL]     if (type.isArray()) { [EOL]         type = type.getComponentType(); [EOL]     } [EOL]     return type.isPrimitive() || type.isEnum() || type.isAnnotation() || String.class.equals(type) || Class.class.equals(type); [EOL] } public AnnotationUtils(); protected String getShortClassName(final java.lang.Class<?> cls); protected void appendDetail(final StringBuffer buffer, final String fieldName, Object value); public static boolean equals(final Annotation a1, final Annotation a2); public static int hashCode(final Annotation a); public static String toString(final Annotation a); public static boolean isValidAnnotationMemberType(Class<?> type); private static int hashMember(final String name, final Object value); private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2); private static boolean arrayMemberEquals(final Class<?> componentType, final Object o1, final Object o2); private static boolean annotationArrayMemberEquals(final Annotation[] a1, final Annotation[] a2); private static int arrayMemberHash(final Class<?> componentType, final Object o); ToStringStyle TO_STRING_STYLE=Optional[new ToStringStyle() {; ;     /**;      * Serialization version;      */;     private static final long serialVersionUID = 1L;; ;     {;         setDefaultFullDetail(true);;         setArrayContentDetail(true);;         setUseClassName(true);;         setUseShortClassName(true);;         setUseIdentityHashCode(false);;         setContentStart("(");;         setContentEnd(")");;         setFieldSeparator(", ");;         setArrayStart("[");;         setArrayEnd("]");;     }; ;     /**;      * {@inheritDoc};      */;     @Override;     protected String getShortClassName(final java.lang.Class<?> cls) {;         Class<? extends Annotation> annotationType = null;;         for (final Class<?> iface : ClassUtils.getAllInterfaces(cls)) {;             if (Annotation.class.isAssignableFrom(iface)) {;                 // OK because we just checked the assignability;                 @SuppressWarnings("unchecked");                 final Class<? extends Annotation> found = (Class<? extends Annotation>) iface;;                 annotationType = found;;                 break;;             };         };         return new StringBuilder(annotationType == null ? "" : annotationType.getName()).insert(0, '@').toString();;     }; ;     /**;      * {@inheritDoc};      */;     @Override;     protected void appendDetail(final StringBuffer buffer, final String fieldName, Object value) {;         if (value instanceof Annotation) {;             value = AnnotationUtils.toString((Annotation) value);;         };         super.appendDetail(buffer, fieldName, value);;     }; }
public static boolean isValidAnnotationMemberType(Class<?> type) { [EOL]     if (type == null) { [EOL]         return false; [EOL]     } [EOL]     if (type.isArray()) { [EOL]         type = type.getComponentType(); [EOL]     } [EOL]     return type.isPrimitive() || type.isEnum() || type.isAnnotation() || String.class.equals(type) || Class.class.equals(type); [EOL] } public AnnotationUtils(); protected String getShortClassName(final java.lang.Class<?> cls); protected void appendDetail(final StringBuffer buffer, final String fieldName, Object value); public static boolean equals(final Annotation a1, final Annotation a2); public static int hashCode(final Annotation a); public static String toString(final Annotation a); public static boolean isValidAnnotationMemberType(Class<?> type); private static int hashMember(final String name, final Object value); private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2); private static boolean arrayMemberEquals(final Class<?> componentType, final Object o1, final Object o2); private static boolean annotationArrayMemberEquals(final Annotation[] a1, final Annotation[] a2); private static int arrayMemberHash(final Class<?> componentType, final Object o); ToStringStyle TO_STRING_STYLE=Optional[new ToStringStyle() {; ;     /**;      * Serialization version;      */;     private static final long serialVersionUID = 1L;; ;     {;         setDefaultFullDetail(true);;         setArrayContentDetail(true);;         setUseClassName(true);;         setUseShortClassName(true);;         setUseIdentityHashCode(false);;         setContentStart("(");;         setContentEnd(")");;         setFieldSeparator(", ");;         setArrayStart("[");;         setArrayEnd("]");;     }; ;     /**;      * {@inheritDoc};      */;     @Override;     protected String getShortClassName(final java.lang.Class<?> cls) {;         Class<? extends Annotation> annotationType = null;;         for (final Class<?> iface : ClassUtils.getAllInterfaces(cls)) {;             if (Annotation.class.isAssignableFrom(iface)) {;                 // OK because we just checked the assignability;                 @SuppressWarnings("unchecked");                 final Class<? extends Annotation> found = (Class<? extends Annotation>) iface;;                 annotationType = found;;                 break;;             };         };         return new StringBuilder(annotationType == null ? "" : annotationType.getName()).insert(0, '@').toString();;     }; ;     /**;      * {@inheritDoc};      */;     @Override;     protected void appendDetail(final StringBuffer buffer, final String fieldName, Object value) {;         if (value instanceof Annotation) {;             value = AnnotationUtils.toString((Annotation) value);;         };         super.appendDetail(buffer, fieldName, value);;     }; }
public static boolean isValidAnnotationMemberType(Class<?> type) { [EOL]     if (type == null) { [EOL]         return false; [EOL]     } [EOL]     if (type.isArray()) { [EOL]         type = type.getComponentType(); [EOL]     } [EOL]     return type.isPrimitive() || type.isEnum() || type.isAnnotation() || String.class.equals(type) || Class.class.equals(type); [EOL] } public AnnotationUtils(); protected String getShortClassName(final java.lang.Class<?> cls); protected void appendDetail(final StringBuffer buffer, final String fieldName, Object value); public static boolean equals(final Annotation a1, final Annotation a2); public static int hashCode(final Annotation a); public static String toString(final Annotation a); public static boolean isValidAnnotationMemberType(Class<?> type); private static int hashMember(final String name, final Object value); private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2); private static boolean arrayMemberEquals(final Class<?> componentType, final Object o1, final Object o2); private static boolean annotationArrayMemberEquals(final Annotation[] a1, final Annotation[] a2); private static int arrayMemberHash(final Class<?> componentType, final Object o); ToStringStyle TO_STRING_STYLE=Optional[new ToStringStyle() {; ;     /**;      * Serialization version;      */;     private static final long serialVersionUID = 1L;; ;     {;         setDefaultFullDetail(true);;         setArrayContentDetail(true);;         setUseClassName(true);;         setUseShortClassName(true);;         setUseIdentityHashCode(false);;         setContentStart("(");;         setContentEnd(")");;         setFieldSeparator(", ");;         setArrayStart("[");;         setArrayEnd("]");;     }; ;     /**;      * {@inheritDoc};      */;     @Override;     protected String getShortClassName(final java.lang.Class<?> cls) {;         Class<? extends Annotation> annotationType = null;;         for (final Class<?> iface : ClassUtils.getAllInterfaces(cls)) {;             if (Annotation.class.isAssignableFrom(iface)) {;                 // OK because we just checked the assignability;                 @SuppressWarnings("unchecked");                 final Class<? extends Annotation> found = (Class<? extends Annotation>) iface;;                 annotationType = found;;                 break;;             };         };         return new StringBuilder(annotationType == null ? "" : annotationType.getName()).insert(0, '@').toString();;     }; ;     /**;      * {@inheritDoc};      */;     @Override;     protected void appendDetail(final StringBuffer buffer, final String fieldName, Object value) {;         if (value instanceof Annotation) {;             value = AnnotationUtils.toString((Annotation) value);;         };         super.appendDetail(buffer, fieldName, value);;     }; }
public static boolean isValidAnnotationMemberType(Class<?> type) { [EOL]     if (type == null) { [EOL]         return false; [EOL]     } [EOL]     if (type.isArray()) { [EOL]         type = type.getComponentType(); [EOL]     } [EOL]     return type.isPrimitive() || type.isEnum() || type.isAnnotation() || String.class.equals(type) || Class.class.equals(type); [EOL] } public AnnotationUtils(); protected String getShortClassName(final java.lang.Class<?> cls); protected void appendDetail(final StringBuffer buffer, final String fieldName, Object value); public static boolean equals(final Annotation a1, final Annotation a2); public static int hashCode(final Annotation a); public static String toString(final Annotation a); public static boolean isValidAnnotationMemberType(Class<?> type); private static int hashMember(final String name, final Object value); private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2); private static boolean arrayMemberEquals(final Class<?> componentType, final Object o1, final Object o2); private static boolean annotationArrayMemberEquals(final Annotation[] a1, final Annotation[] a2); private static int arrayMemberHash(final Class<?> componentType, final Object o); ToStringStyle TO_STRING_STYLE=Optional[new ToStringStyle() {; ;     /**;      * Serialization version;      */;     private static final long serialVersionUID = 1L;; ;     {;         setDefaultFullDetail(true);;         setArrayContentDetail(true);;         setUseClassName(true);;         setUseShortClassName(true);;         setUseIdentityHashCode(false);;         setContentStart("(");;         setContentEnd(")");;         setFieldSeparator(", ");;         setArrayStart("[");;         setArrayEnd("]");;     }; ;     /**;      * {@inheritDoc};      */;     @Override;     protected String getShortClassName(final java.lang.Class<?> cls) {;         Class<? extends Annotation> annotationType = null;;         for (final Class<?> iface : ClassUtils.getAllInterfaces(cls)) {;             if (Annotation.class.isAssignableFrom(iface)) {;                 // OK because we just checked the assignability;                 @SuppressWarnings("unchecked");                 final Class<? extends Annotation> found = (Class<? extends Annotation>) iface;;                 annotationType = found;;                 break;;             };         };         return new StringBuilder(annotationType == null ? "" : annotationType.getName()).insert(0, '@').toString();;     }; ;     /**;      * {@inheritDoc};      */;     @Override;     protected void appendDetail(final StringBuffer buffer, final String fieldName, Object value) {;         if (value instanceof Annotation) {;             value = AnnotationUtils.toString((Annotation) value);;         };         super.appendDetail(buffer, fieldName, value);;     }; }
public static boolean isValidAnnotationMemberType(Class<?> type) { [EOL]     if (type == null) { [EOL]         return false; [EOL]     } [EOL]     if (type.isArray()) { [EOL]         type = type.getComponentType(); [EOL]     } [EOL]     return type.isPrimitive() || type.isEnum() || type.isAnnotation() || String.class.equals(type) || Class.class.equals(type); [EOL] } public AnnotationUtils(); protected String getShortClassName(final java.lang.Class<?> cls); protected void appendDetail(final StringBuffer buffer, final String fieldName, Object value); public static boolean equals(final Annotation a1, final Annotation a2); public static int hashCode(final Annotation a); public static String toString(final Annotation a); public static boolean isValidAnnotationMemberType(Class<?> type); private static int hashMember(final String name, final Object value); private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2); private static boolean arrayMemberEquals(final Class<?> componentType, final Object o1, final Object o2); private static boolean annotationArrayMemberEquals(final Annotation[] a1, final Annotation[] a2); private static int arrayMemberHash(final Class<?> componentType, final Object o); ToStringStyle TO_STRING_STYLE=Optional[new ToStringStyle() {; ;     /**;      * Serialization version;      */;     private static final long serialVersionUID = 1L;; ;     {;         setDefaultFullDetail(true);;         setArrayContentDetail(true);;         setUseClassName(true);;         setUseShortClassName(true);;         setUseIdentityHashCode(false);;         setContentStart("(");;         setContentEnd(")");;         setFieldSeparator(", ");;         setArrayStart("[");;         setArrayEnd("]");;     }; ;     /**;      * {@inheritDoc};      */;     @Override;     protected String getShortClassName(final java.lang.Class<?> cls) {;         Class<? extends Annotation> annotationType = null;;         for (final Class<?> iface : ClassUtils.getAllInterfaces(cls)) {;             if (Annotation.class.isAssignableFrom(iface)) {;                 // OK because we just checked the assignability;                 @SuppressWarnings("unchecked");                 final Class<? extends Annotation> found = (Class<? extends Annotation>) iface;;                 annotationType = found;;                 break;;             };         };         return new StringBuilder(annotationType == null ? "" : annotationType.getName()).insert(0, '@').toString();;     }; ;     /**;      * {@inheritDoc};      */;     @Override;     protected void appendDetail(final StringBuffer buffer, final String fieldName, Object value) {;         if (value instanceof Annotation) {;             value = AnnotationUtils.toString((Annotation) value);;         };         super.appendDetail(buffer, fieldName, value);;     }; }
public static boolean isValidAnnotationMemberType(Class<?> type) { [EOL]     if (type == null) { [EOL]         return false; [EOL]     } [EOL]     if (type.isArray()) { [EOL]         type = type.getComponentType(); [EOL]     } [EOL]     return type.isPrimitive() || type.isEnum() || type.isAnnotation() || String.class.equals(type) || Class.class.equals(type); [EOL] } public AnnotationUtils(); protected String getShortClassName(final java.lang.Class<?> cls); protected void appendDetail(final StringBuffer buffer, final String fieldName, Object value); public static boolean equals(final Annotation a1, final Annotation a2); public static int hashCode(final Annotation a); public static String toString(final Annotation a); public static boolean isValidAnnotationMemberType(Class<?> type); private static int hashMember(final String name, final Object value); private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2); private static boolean arrayMemberEquals(final Class<?> componentType, final Object o1, final Object o2); private static boolean annotationArrayMemberEquals(final Annotation[] a1, final Annotation[] a2); private static int arrayMemberHash(final Class<?> componentType, final Object o); ToStringStyle TO_STRING_STYLE=Optional[new ToStringStyle() {; ;     /**;      * Serialization version;      */;     private static final long serialVersionUID = 1L;; ;     {;         setDefaultFullDetail(true);;         setArrayContentDetail(true);;         setUseClassName(true);;         setUseShortClassName(true);;         setUseIdentityHashCode(false);;         setContentStart("(");;         setContentEnd(")");;         setFieldSeparator(", ");;         setArrayStart("[");;         setArrayEnd("]");;     }; ;     /**;      * {@inheritDoc};      */;     @Override;     protected String getShortClassName(final java.lang.Class<?> cls) {;         Class<? extends Annotation> annotationType = null;;         for (final Class<?> iface : ClassUtils.getAllInterfaces(cls)) {;             if (Annotation.class.isAssignableFrom(iface)) {;                 // OK because we just checked the assignability;                 @SuppressWarnings("unchecked");                 final Class<? extends Annotation> found = (Class<? extends Annotation>) iface;;                 annotationType = found;;                 break;;             };         };         return new StringBuilder(annotationType == null ? "" : annotationType.getName()).insert(0, '@').toString();;     }; ;     /**;      * {@inheritDoc};      */;     @Override;     protected void appendDetail(final StringBuffer buffer, final String fieldName, Object value) {;         if (value instanceof Annotation) {;             value = AnnotationUtils.toString((Annotation) value);;         };         super.appendDetail(buffer, fieldName, value);;     }; }
public static boolean isValidAnnotationMemberType(Class<?> type) { [EOL]     if (type == null) { [EOL]         return false; [EOL]     } [EOL]     if (type.isArray()) { [EOL]         type = type.getComponentType(); [EOL]     } [EOL]     return type.isPrimitive() || type.isEnum() || type.isAnnotation() || String.class.equals(type) || Class.class.equals(type); [EOL] } public AnnotationUtils(); protected String getShortClassName(final java.lang.Class<?> cls); protected void appendDetail(final StringBuffer buffer, final String fieldName, Object value); public static boolean equals(final Annotation a1, final Annotation a2); public static int hashCode(final Annotation a); public static String toString(final Annotation a); public static boolean isValidAnnotationMemberType(Class<?> type); private static int hashMember(final String name, final Object value); private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2); private static boolean arrayMemberEquals(final Class<?> componentType, final Object o1, final Object o2); private static boolean annotationArrayMemberEquals(final Annotation[] a1, final Annotation[] a2); private static int arrayMemberHash(final Class<?> componentType, final Object o); ToStringStyle TO_STRING_STYLE=Optional[new ToStringStyle() {; ;     /**;      * Serialization version;      */;     private static final long serialVersionUID = 1L;; ;     {;         setDefaultFullDetail(true);;         setArrayContentDetail(true);;         setUseClassName(true);;         setUseShortClassName(true);;         setUseIdentityHashCode(false);;         setContentStart("(");;         setContentEnd(")");;         setFieldSeparator(", ");;         setArrayStart("[");;         setArrayEnd("]");;     }; ;     /**;      * {@inheritDoc};      */;     @Override;     protected String getShortClassName(final java.lang.Class<?> cls) {;         Class<? extends Annotation> annotationType = null;;         for (final Class<?> iface : ClassUtils.getAllInterfaces(cls)) {;             if (Annotation.class.isAssignableFrom(iface)) {;                 // OK because we just checked the assignability;                 @SuppressWarnings("unchecked");                 final Class<? extends Annotation> found = (Class<? extends Annotation>) iface;;                 annotationType = found;;                 break;;             };         };         return new StringBuilder(annotationType == null ? "" : annotationType.getName()).insert(0, '@').toString();;     }; ;     /**;      * {@inheritDoc};      */;     @Override;     protected void appendDetail(final StringBuffer buffer, final String fieldName, Object value) {;         if (value instanceof Annotation) {;             value = AnnotationUtils.toString((Annotation) value);;         };         super.appendDetail(buffer, fieldName, value);;     }; }
private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2) { [EOL]     if (o1 == o2) { [EOL]         return true; [EOL]     } [EOL]     if (o1 == null || o2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (type.isArray()) { [EOL]         return arrayMemberEquals(type.getComponentType(), o1, o2); [EOL]     } [EOL]     if (type.isAnnotation()) { [EOL]         return equals((Annotation) o1, (Annotation) o2); [EOL]     } [EOL]     return o1.equals(o2); [EOL] } public AnnotationUtils(); protected String getShortClassName(final java.lang.Class<?> cls); protected void appendDetail(final StringBuffer buffer, final String fieldName, Object value); public static boolean equals(final Annotation a1, final Annotation a2); public static int hashCode(final Annotation a); public static String toString(final Annotation a); public static boolean isValidAnnotationMemberType(Class<?> type); private static int hashMember(final String name, final Object value); private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2); private static boolean arrayMemberEquals(final Class<?> componentType, final Object o1, final Object o2); private static boolean annotationArrayMemberEquals(final Annotation[] a1, final Annotation[] a2); private static int arrayMemberHash(final Class<?> componentType, final Object o); ToStringStyle TO_STRING_STYLE=Optional[new ToStringStyle() {; ;     /**;      * Serialization version;      */;     private static final long serialVersionUID = 1L;; ;     {;         setDefaultFullDetail(true);;         setArrayContentDetail(true);;         setUseClassName(true);;         setUseShortClassName(true);;         setUseIdentityHashCode(false);;         setContentStart("(");;         setContentEnd(")");;         setFieldSeparator(", ");;         setArrayStart("[");;         setArrayEnd("]");;     }; ;     /**;      * {@inheritDoc};      */;     @Override;     protected String getShortClassName(final java.lang.Class<?> cls) {;         Class<? extends Annotation> annotationType = null;;         for (final Class<?> iface : ClassUtils.getAllInterfaces(cls)) {;             if (Annotation.class.isAssignableFrom(iface)) {;                 // OK because we just checked the assignability;                 @SuppressWarnings("unchecked");                 final Class<? extends Annotation> found = (Class<? extends Annotation>) iface;;                 annotationType = found;;                 break;;             };         };         return new StringBuilder(annotationType == null ? "" : annotationType.getName()).insert(0, '@').toString();;     }; ;     /**;      * {@inheritDoc};      */;     @Override;     protected void appendDetail(final StringBuffer buffer, final String fieldName, Object value) {;         if (value instanceof Annotation) {;             value = AnnotationUtils.toString((Annotation) value);;         };         super.appendDetail(buffer, fieldName, value);;     }; }
private static boolean arrayMemberEquals(final Class<?> componentType, final Object o1, final Object o2) { [EOL]     if (componentType.isAnnotation()) { [EOL]         return annotationArrayMemberEquals((Annotation[]) o1, (Annotation[]) o2); [EOL]     } [EOL]     if (componentType.equals(Byte.TYPE)) { [EOL]         return Arrays.equals((byte[]) o1, (byte[]) o2); [EOL]     } [EOL]     if (componentType.equals(Short.TYPE)) { [EOL]         return Arrays.equals((short[]) o1, (short[]) o2); [EOL]     } [EOL]     if (componentType.equals(Integer.TYPE)) { [EOL]         return Arrays.equals((int[]) o1, (int[]) o2); [EOL]     } [EOL]     if (componentType.equals(Character.TYPE)) { [EOL]         return Arrays.equals((char[]) o1, (char[]) o2); [EOL]     } [EOL]     if (componentType.equals(Long.TYPE)) { [EOL]         return Arrays.equals((long[]) o1, (long[]) o2); [EOL]     } [EOL]     if (componentType.equals(Float.TYPE)) { [EOL]         return Arrays.equals((float[]) o1, (float[]) o2); [EOL]     } [EOL]     if (componentType.equals(Double.TYPE)) { [EOL]         return Arrays.equals((double[]) o1, (double[]) o2); [EOL]     } [EOL]     if (componentType.equals(Boolean.TYPE)) { [EOL]         return Arrays.equals((boolean[]) o1, (boolean[]) o2); [EOL]     } [EOL]     return Arrays.equals((Object[]) o1, (Object[]) o2); [EOL] } public AnnotationUtils(); protected String getShortClassName(final java.lang.Class<?> cls); protected void appendDetail(final StringBuffer buffer, final String fieldName, Object value); public static boolean equals(final Annotation a1, final Annotation a2); public static int hashCode(final Annotation a); public static String toString(final Annotation a); public static boolean isValidAnnotationMemberType(Class<?> type); private static int hashMember(final String name, final Object value); private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2); private static boolean arrayMemberEquals(final Class<?> componentType, final Object o1, final Object o2); private static boolean annotationArrayMemberEquals(final Annotation[] a1, final Annotation[] a2); private static int arrayMemberHash(final Class<?> componentType, final Object o); ToStringStyle TO_STRING_STYLE=Optional[new ToStringStyle() {; ;     /**;      * Serialization version;      */;     private static final long serialVersionUID = 1L;; ;     {;         setDefaultFullDetail(true);;         setArrayContentDetail(true);;         setUseClassName(true);;         setUseShortClassName(true);;         setUseIdentityHashCode(false);;         setContentStart("(");;         setContentEnd(")");;         setFieldSeparator(", ");;         setArrayStart("[");;         setArrayEnd("]");;     }; ;     /**;      * {@inheritDoc};      */;     @Override;     protected String getShortClassName(final java.lang.Class<?> cls) {;         Class<? extends Annotation> annotationType = null;;         for (final Class<?> iface : ClassUtils.getAllInterfaces(cls)) {;             if (Annotation.class.isAssignableFrom(iface)) {;                 // OK because we just checked the assignability;                 @SuppressWarnings("unchecked");                 final Class<? extends Annotation> found = (Class<? extends Annotation>) iface;;                 annotationType = found;;                 break;;             };         };         return new StringBuilder(annotationType == null ? "" : annotationType.getName()).insert(0, '@').toString();;     }; ;     /**;      * {@inheritDoc};      */;     @Override;     protected void appendDetail(final StringBuffer buffer, final String fieldName, Object value) {;         if (value instanceof Annotation) {;             value = AnnotationUtils.toString((Annotation) value);;         };         super.appendDetail(buffer, fieldName, value);;     }; }
private static boolean annotationArrayMemberEquals(final Annotation[] a1, final Annotation[] a2) { [EOL]     if (a1.length != a2.length) { [EOL]         return false; [EOL]     } [EOL]     for (int i = 0; i < a1.length; i++) { [EOL]         if (!equals(a1[i], a2[i])) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } public AnnotationUtils(); protected String getShortClassName(final java.lang.Class<?> cls); protected void appendDetail(final StringBuffer buffer, final String fieldName, Object value); public static boolean equals(final Annotation a1, final Annotation a2); public static int hashCode(final Annotation a); public static String toString(final Annotation a); public static boolean isValidAnnotationMemberType(Class<?> type); private static int hashMember(final String name, final Object value); private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2); private static boolean arrayMemberEquals(final Class<?> componentType, final Object o1, final Object o2); private static boolean annotationArrayMemberEquals(final Annotation[] a1, final Annotation[] a2); private static int arrayMemberHash(final Class<?> componentType, final Object o); ToStringStyle TO_STRING_STYLE=Optional[new ToStringStyle() {; ;     /**;      * Serialization version;      */;     private static final long serialVersionUID = 1L;; ;     {;         setDefaultFullDetail(true);;         setArrayContentDetail(true);;         setUseClassName(true);;         setUseShortClassName(true);;         setUseIdentityHashCode(false);;         setContentStart("(");;         setContentEnd(")");;         setFieldSeparator(", ");;         setArrayStart("[");;         setArrayEnd("]");;     }; ;     /**;      * {@inheritDoc};      */;     @Override;     protected String getShortClassName(final java.lang.Class<?> cls) {;         Class<? extends Annotation> annotationType = null;;         for (final Class<?> iface : ClassUtils.getAllInterfaces(cls)) {;             if (Annotation.class.isAssignableFrom(iface)) {;                 // OK because we just checked the assignability;                 @SuppressWarnings("unchecked");                 final Class<? extends Annotation> found = (Class<? extends Annotation>) iface;;                 annotationType = found;;                 break;;             };         };         return new StringBuilder(annotationType == null ? "" : annotationType.getName()).insert(0, '@').toString();;     }; ;     /**;      * {@inheritDoc};      */;     @Override;     protected void appendDetail(final StringBuffer buffer, final String fieldName, Object value) {;         if (value instanceof Annotation) {;             value = AnnotationUtils.toString((Annotation) value);;         };         super.appendDetail(buffer, fieldName, value);;     }; }
@Override [EOL] protected String toUtf16Escape(final int codepoint) { [EOL]     final char[] surrogatePair = Character.toChars(codepoint); [EOL]     return "\\u" + hex(surrogatePair[0]) + "\\u" + hex(surrogatePair[1]); [EOL] }
@Override [EOL] protected String toUtf16Escape(final int codepoint) { [EOL]     final char[] surrogatePair = Character.toChars(codepoint); [EOL]     return "\\u" + hex(surrogatePair[0]) + "\\u" + hex(surrogatePair[1]); [EOL] }
public static String format(final long millis, final String pattern, final TimeZone timeZone) { [EOL]     return format(new Date(millis), pattern, timeZone, null); [EOL] }
public static String format(final long millis, final String pattern, final TimeZone timeZone) { [EOL]     return format(new Date(millis), pattern, timeZone, null); [EOL] }
public static String format(final Date date, final String pattern, final TimeZone timeZone) { [EOL]     return format(date, pattern, timeZone, null); [EOL] }
public static String format(final Date date, final String pattern, final TimeZone timeZone) { [EOL]     return format(date, pattern, timeZone, null); [EOL] }
public static String format(final Date date, final String pattern, final TimeZone timeZone) { [EOL]     return format(date, pattern, timeZone, null); [EOL] }
public static String format(final Date date, final String pattern, final TimeZone timeZone) { [EOL]     return format(date, pattern, timeZone, null); [EOL] }
public static String format(final Date date, final String pattern, final TimeZone timeZone, final Locale locale) { [EOL]     final FastDateFormat df = FastDateFormat.getInstance(pattern, timeZone, locale); [EOL]     return df.format(date); [EOL] }
public static String format(final Date date, final String pattern, final TimeZone timeZone, final Locale locale) { [EOL]     final FastDateFormat df = FastDateFormat.getInstance(pattern, timeZone, locale); [EOL]     return df.format(date); [EOL] }
public static String format(final Date date, final String pattern, final TimeZone timeZone, final Locale locale) { [EOL]     final FastDateFormat df = FastDateFormat.getInstance(pattern, timeZone, locale); [EOL]     return df.format(date); [EOL] }
public static String format(final Date date, final String pattern, final TimeZone timeZone, final Locale locale) { [EOL]     final FastDateFormat df = FastDateFormat.getInstance(pattern, timeZone, locale); [EOL]     return df.format(date); [EOL] }
public static String format(final Date date, final String pattern, final TimeZone timeZone, final Locale locale) { [EOL]     final FastDateFormat df = FastDateFormat.getInstance(pattern, timeZone, locale); [EOL]     return df.format(date); [EOL] }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj instanceof FastDatePrinter == false) { [EOL]         return false; [EOL]     } [EOL]     final FastDatePrinter other = (FastDatePrinter) obj; [EOL]     return mPattern.equals(other.mPattern) && mTimeZone.equals(other.mTimeZone) && mLocale.equals(other.mLocale); [EOL] }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj instanceof FastDatePrinter == false) { [EOL]         return false; [EOL]     } [EOL]     final FastDatePrinter other = (FastDatePrinter) obj; [EOL]     return mPattern.equals(other.mPattern) && mTimeZone.equals(other.mTimeZone) && mLocale.equals(other.mLocale); [EOL] }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj instanceof FastDatePrinter == false) { [EOL]         return false; [EOL]     } [EOL]     final FastDatePrinter other = (FastDatePrinter) obj; [EOL]     return mPattern.equals(other.mPattern) && mTimeZone.equals(other.mTimeZone) && mLocale.equals(other.mLocale); [EOL] }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj instanceof FastDatePrinter == false) { [EOL]         return false; [EOL]     } [EOL]     final FastDatePrinter other = (FastDatePrinter) obj; [EOL]     return mPattern.equals(other.mPattern) && mTimeZone.equals(other.mTimeZone) && mLocale.equals(other.mLocale); [EOL] }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj instanceof FastDatePrinter == false) { [EOL]         return false; [EOL]     } [EOL]     final FastDatePrinter other = (FastDatePrinter) obj; [EOL]     return mPattern.equals(other.mPattern) && mTimeZone.equals(other.mTimeZone) && mLocale.equals(other.mLocale); [EOL] }
@Override [EOL] public int hashCode() { [EOL]     return mPattern.hashCode() + 13 * (mTimeZone.hashCode() + 13 * mLocale.hashCode()); [EOL] }
public EqualsBuilder appendSuper(final boolean superEquals) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     isEquals = superEquals; [EOL]     return this; [EOL] }
public EqualsBuilder append(final Object lhs, final Object rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     final Class<?> lhsClass = lhs.getClass(); [EOL]     if (!lhsClass.isArray()) { [EOL]         isEquals = lhs.equals(rhs); [EOL]     } else if (lhs.getClass() != rhs.getClass()) { [EOL]         this.setEquals(false); [EOL]     } else if (lhs instanceof long[]) { [EOL]         append((long[]) lhs, (long[]) rhs); [EOL]     } else if (lhs instanceof int[]) { [EOL]         append((int[]) lhs, (int[]) rhs); [EOL]     } else if (lhs instanceof short[]) { [EOL]         append((short[]) lhs, (short[]) rhs); [EOL]     } else if (lhs instanceof char[]) { [EOL]         append((char[]) lhs, (char[]) rhs); [EOL]     } else if (lhs instanceof byte[]) { [EOL]         append((byte[]) lhs, (byte[]) rhs); [EOL]     } else if (lhs instanceof double[]) { [EOL]         append((double[]) lhs, (double[]) rhs); [EOL]     } else if (lhs instanceof float[]) { [EOL]         append((float[]) lhs, (float[]) rhs); [EOL]     } else if (lhs instanceof boolean[]) { [EOL]         append((boolean[]) lhs, (boolean[]) rhs); [EOL]     } else { [EOL]         append((Object[]) lhs, (Object[]) rhs); [EOL]     } [EOL]     return this; [EOL] }
public EqualsBuilder append(final Object lhs, final Object rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     final Class<?> lhsClass = lhs.getClass(); [EOL]     if (!lhsClass.isArray()) { [EOL]         isEquals = lhs.equals(rhs); [EOL]     } else if (lhs.getClass() != rhs.getClass()) { [EOL]         this.setEquals(false); [EOL]     } else if (lhs instanceof long[]) { [EOL]         append((long[]) lhs, (long[]) rhs); [EOL]     } else if (lhs instanceof int[]) { [EOL]         append((int[]) lhs, (int[]) rhs); [EOL]     } else if (lhs instanceof short[]) { [EOL]         append((short[]) lhs, (short[]) rhs); [EOL]     } else if (lhs instanceof char[]) { [EOL]         append((char[]) lhs, (char[]) rhs); [EOL]     } else if (lhs instanceof byte[]) { [EOL]         append((byte[]) lhs, (byte[]) rhs); [EOL]     } else if (lhs instanceof double[]) { [EOL]         append((double[]) lhs, (double[]) rhs); [EOL]     } else if (lhs instanceof float[]) { [EOL]         append((float[]) lhs, (float[]) rhs); [EOL]     } else if (lhs instanceof boolean[]) { [EOL]         append((boolean[]) lhs, (boolean[]) rhs); [EOL]     } else { [EOL]         append((Object[]) lhs, (Object[]) rhs); [EOL]     } [EOL]     return this; [EOL] }
public EqualsBuilder append(final Object lhs, final Object rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     final Class<?> lhsClass = lhs.getClass(); [EOL]     if (!lhsClass.isArray()) { [EOL]         isEquals = lhs.equals(rhs); [EOL]     } else if (lhs.getClass() != rhs.getClass()) { [EOL]         this.setEquals(false); [EOL]     } else if (lhs instanceof long[]) { [EOL]         append((long[]) lhs, (long[]) rhs); [EOL]     } else if (lhs instanceof int[]) { [EOL]         append((int[]) lhs, (int[]) rhs); [EOL]     } else if (lhs instanceof short[]) { [EOL]         append((short[]) lhs, (short[]) rhs); [EOL]     } else if (lhs instanceof char[]) { [EOL]         append((char[]) lhs, (char[]) rhs); [EOL]     } else if (lhs instanceof byte[]) { [EOL]         append((byte[]) lhs, (byte[]) rhs); [EOL]     } else if (lhs instanceof double[]) { [EOL]         append((double[]) lhs, (double[]) rhs); [EOL]     } else if (lhs instanceof float[]) { [EOL]         append((float[]) lhs, (float[]) rhs); [EOL]     } else if (lhs instanceof boolean[]) { [EOL]         append((boolean[]) lhs, (boolean[]) rhs); [EOL]     } else { [EOL]         append((Object[]) lhs, (Object[]) rhs); [EOL]     } [EOL]     return this; [EOL] }
public EqualsBuilder append(final Object lhs, final Object rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     final Class<?> lhsClass = lhs.getClass(); [EOL]     if (!lhsClass.isArray()) { [EOL]         isEquals = lhs.equals(rhs); [EOL]     } else if (lhs.getClass() != rhs.getClass()) { [EOL]         this.setEquals(false); [EOL]     } else if (lhs instanceof long[]) { [EOL]         append((long[]) lhs, (long[]) rhs); [EOL]     } else if (lhs instanceof int[]) { [EOL]         append((int[]) lhs, (int[]) rhs); [EOL]     } else if (lhs instanceof short[]) { [EOL]         append((short[]) lhs, (short[]) rhs); [EOL]     } else if (lhs instanceof char[]) { [EOL]         append((char[]) lhs, (char[]) rhs); [EOL]     } else if (lhs instanceof byte[]) { [EOL]         append((byte[]) lhs, (byte[]) rhs); [EOL]     } else if (lhs instanceof double[]) { [EOL]         append((double[]) lhs, (double[]) rhs); [EOL]     } else if (lhs instanceof float[]) { [EOL]         append((float[]) lhs, (float[]) rhs); [EOL]     } else if (lhs instanceof boolean[]) { [EOL]         append((boolean[]) lhs, (boolean[]) rhs); [EOL]     } else { [EOL]         append((Object[]) lhs, (Object[]) rhs); [EOL]     } [EOL]     return this; [EOL] }
public EqualsBuilder append(final Object lhs, final Object rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     final Class<?> lhsClass = lhs.getClass(); [EOL]     if (!lhsClass.isArray()) { [EOL]         isEquals = lhs.equals(rhs); [EOL]     } else if (lhs.getClass() != rhs.getClass()) { [EOL]         this.setEquals(false); [EOL]     } else if (lhs instanceof long[]) { [EOL]         append((long[]) lhs, (long[]) rhs); [EOL]     } else if (lhs instanceof int[]) { [EOL]         append((int[]) lhs, (int[]) rhs); [EOL]     } else if (lhs instanceof short[]) { [EOL]         append((short[]) lhs, (short[]) rhs); [EOL]     } else if (lhs instanceof char[]) { [EOL]         append((char[]) lhs, (char[]) rhs); [EOL]     } else if (lhs instanceof byte[]) { [EOL]         append((byte[]) lhs, (byte[]) rhs); [EOL]     } else if (lhs instanceof double[]) { [EOL]         append((double[]) lhs, (double[]) rhs); [EOL]     } else if (lhs instanceof float[]) { [EOL]         append((float[]) lhs, (float[]) rhs); [EOL]     } else if (lhs instanceof boolean[]) { [EOL]         append((boolean[]) lhs, (boolean[]) rhs); [EOL]     } else { [EOL]         append((Object[]) lhs, (Object[]) rhs); [EOL]     } [EOL]     return this; [EOL] }
public EqualsBuilder append(final Object lhs, final Object rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     final Class<?> lhsClass = lhs.getClass(); [EOL]     if (!lhsClass.isArray()) { [EOL]         isEquals = lhs.equals(rhs); [EOL]     } else if (lhs.getClass() != rhs.getClass()) { [EOL]         this.setEquals(false); [EOL]     } else if (lhs instanceof long[]) { [EOL]         append((long[]) lhs, (long[]) rhs); [EOL]     } else if (lhs instanceof int[]) { [EOL]         append((int[]) lhs, (int[]) rhs); [EOL]     } else if (lhs instanceof short[]) { [EOL]         append((short[]) lhs, (short[]) rhs); [EOL]     } else if (lhs instanceof char[]) { [EOL]         append((char[]) lhs, (char[]) rhs); [EOL]     } else if (lhs instanceof byte[]) { [EOL]         append((byte[]) lhs, (byte[]) rhs); [EOL]     } else if (lhs instanceof double[]) { [EOL]         append((double[]) lhs, (double[]) rhs); [EOL]     } else if (lhs instanceof float[]) { [EOL]         append((float[]) lhs, (float[]) rhs); [EOL]     } else if (lhs instanceof boolean[]) { [EOL]         append((boolean[]) lhs, (boolean[]) rhs); [EOL]     } else { [EOL]         append((Object[]) lhs, (Object[]) rhs); [EOL]     } [EOL]     return this; [EOL] }
public EqualsBuilder append(final Object lhs, final Object rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     final Class<?> lhsClass = lhs.getClass(); [EOL]     if (!lhsClass.isArray()) { [EOL]         isEquals = lhs.equals(rhs); [EOL]     } else if (lhs.getClass() != rhs.getClass()) { [EOL]         this.setEquals(false); [EOL]     } else if (lhs instanceof long[]) { [EOL]         append((long[]) lhs, (long[]) rhs); [EOL]     } else if (lhs instanceof int[]) { [EOL]         append((int[]) lhs, (int[]) rhs); [EOL]     } else if (lhs instanceof short[]) { [EOL]         append((short[]) lhs, (short[]) rhs); [EOL]     } else if (lhs instanceof char[]) { [EOL]         append((char[]) lhs, (char[]) rhs); [EOL]     } else if (lhs instanceof byte[]) { [EOL]         append((byte[]) lhs, (byte[]) rhs); [EOL]     } else if (lhs instanceof double[]) { [EOL]         append((double[]) lhs, (double[]) rhs); [EOL]     } else if (lhs instanceof float[]) { [EOL]         append((float[]) lhs, (float[]) rhs); [EOL]     } else if (lhs instanceof boolean[]) { [EOL]         append((boolean[]) lhs, (boolean[]) rhs); [EOL]     } else { [EOL]         append((Object[]) lhs, (Object[]) rhs); [EOL]     } [EOL]     return this; [EOL] }
public EqualsBuilder append(final Object lhs, final Object rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     final Class<?> lhsClass = lhs.getClass(); [EOL]     if (!lhsClass.isArray()) { [EOL]         isEquals = lhs.equals(rhs); [EOL]     } else if (lhs.getClass() != rhs.getClass()) { [EOL]         this.setEquals(false); [EOL]     } else if (lhs instanceof long[]) { [EOL]         append((long[]) lhs, (long[]) rhs); [EOL]     } else if (lhs instanceof int[]) { [EOL]         append((int[]) lhs, (int[]) rhs); [EOL]     } else if (lhs instanceof short[]) { [EOL]         append((short[]) lhs, (short[]) rhs); [EOL]     } else if (lhs instanceof char[]) { [EOL]         append((char[]) lhs, (char[]) rhs); [EOL]     } else if (lhs instanceof byte[]) { [EOL]         append((byte[]) lhs, (byte[]) rhs); [EOL]     } else if (lhs instanceof double[]) { [EOL]         append((double[]) lhs, (double[]) rhs); [EOL]     } else if (lhs instanceof float[]) { [EOL]         append((float[]) lhs, (float[]) rhs); [EOL]     } else if (lhs instanceof boolean[]) { [EOL]         append((boolean[]) lhs, (boolean[]) rhs); [EOL]     } else { [EOL]         append((Object[]) lhs, (Object[]) rhs); [EOL]     } [EOL]     return this; [EOL] }
public EqualsBuilder append(final Object lhs, final Object rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     final Class<?> lhsClass = lhs.getClass(); [EOL]     if (!lhsClass.isArray()) { [EOL]         isEquals = lhs.equals(rhs); [EOL]     } else if (lhs.getClass() != rhs.getClass()) { [EOL]         this.setEquals(false); [EOL]     } else if (lhs instanceof long[]) { [EOL]         append((long[]) lhs, (long[]) rhs); [EOL]     } else if (lhs instanceof int[]) { [EOL]         append((int[]) lhs, (int[]) rhs); [EOL]     } else if (lhs instanceof short[]) { [EOL]         append((short[]) lhs, (short[]) rhs); [EOL]     } else if (lhs instanceof char[]) { [EOL]         append((char[]) lhs, (char[]) rhs); [EOL]     } else if (lhs instanceof byte[]) { [EOL]         append((byte[]) lhs, (byte[]) rhs); [EOL]     } else if (lhs instanceof double[]) { [EOL]         append((double[]) lhs, (double[]) rhs); [EOL]     } else if (lhs instanceof float[]) { [EOL]         append((float[]) lhs, (float[]) rhs); [EOL]     } else if (lhs instanceof boolean[]) { [EOL]         append((boolean[]) lhs, (boolean[]) rhs); [EOL]     } else { [EOL]         append((Object[]) lhs, (Object[]) rhs); [EOL]     } [EOL]     return this; [EOL] }
public EqualsBuilder append(final Object lhs, final Object rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     final Class<?> lhsClass = lhs.getClass(); [EOL]     if (!lhsClass.isArray()) { [EOL]         isEquals = lhs.equals(rhs); [EOL]     } else if (lhs.getClass() != rhs.getClass()) { [EOL]         this.setEquals(false); [EOL]     } else if (lhs instanceof long[]) { [EOL]         append((long[]) lhs, (long[]) rhs); [EOL]     } else if (lhs instanceof int[]) { [EOL]         append((int[]) lhs, (int[]) rhs); [EOL]     } else if (lhs instanceof short[]) { [EOL]         append((short[]) lhs, (short[]) rhs); [EOL]     } else if (lhs instanceof char[]) { [EOL]         append((char[]) lhs, (char[]) rhs); [EOL]     } else if (lhs instanceof byte[]) { [EOL]         append((byte[]) lhs, (byte[]) rhs); [EOL]     } else if (lhs instanceof double[]) { [EOL]         append((double[]) lhs, (double[]) rhs); [EOL]     } else if (lhs instanceof float[]) { [EOL]         append((float[]) lhs, (float[]) rhs); [EOL]     } else if (lhs instanceof boolean[]) { [EOL]         append((boolean[]) lhs, (boolean[]) rhs); [EOL]     } else { [EOL]         append((Object[]) lhs, (Object[]) rhs); [EOL]     } [EOL]     return this; [EOL] }
public EqualsBuilder append(final Object lhs, final Object rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     final Class<?> lhsClass = lhs.getClass(); [EOL]     if (!lhsClass.isArray()) { [EOL]         isEquals = lhs.equals(rhs); [EOL]     } else if (lhs.getClass() != rhs.getClass()) { [EOL]         this.setEquals(false); [EOL]     } else if (lhs instanceof long[]) { [EOL]         append((long[]) lhs, (long[]) rhs); [EOL]     } else if (lhs instanceof int[]) { [EOL]         append((int[]) lhs, (int[]) rhs); [EOL]     } else if (lhs instanceof short[]) { [EOL]         append((short[]) lhs, (short[]) rhs); [EOL]     } else if (lhs instanceof char[]) { [EOL]         append((char[]) lhs, (char[]) rhs); [EOL]     } else if (lhs instanceof byte[]) { [EOL]         append((byte[]) lhs, (byte[]) rhs); [EOL]     } else if (lhs instanceof double[]) { [EOL]         append((double[]) lhs, (double[]) rhs); [EOL]     } else if (lhs instanceof float[]) { [EOL]         append((float[]) lhs, (float[]) rhs); [EOL]     } else if (lhs instanceof boolean[]) { [EOL]         append((boolean[]) lhs, (boolean[]) rhs); [EOL]     } else { [EOL]         append((Object[]) lhs, (Object[]) rhs); [EOL]     } [EOL]     return this; [EOL] }
public EqualsBuilder append(final Object lhs, final Object rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     final Class<?> lhsClass = lhs.getClass(); [EOL]     if (!lhsClass.isArray()) { [EOL]         isEquals = lhs.equals(rhs); [EOL]     } else if (lhs.getClass() != rhs.getClass()) { [EOL]         this.setEquals(false); [EOL]     } else if (lhs instanceof long[]) { [EOL]         append((long[]) lhs, (long[]) rhs); [EOL]     } else if (lhs instanceof int[]) { [EOL]         append((int[]) lhs, (int[]) rhs); [EOL]     } else if (lhs instanceof short[]) { [EOL]         append((short[]) lhs, (short[]) rhs); [EOL]     } else if (lhs instanceof char[]) { [EOL]         append((char[]) lhs, (char[]) rhs); [EOL]     } else if (lhs instanceof byte[]) { [EOL]         append((byte[]) lhs, (byte[]) rhs); [EOL]     } else if (lhs instanceof double[]) { [EOL]         append((double[]) lhs, (double[]) rhs); [EOL]     } else if (lhs instanceof float[]) { [EOL]         append((float[]) lhs, (float[]) rhs); [EOL]     } else if (lhs instanceof boolean[]) { [EOL]         append((boolean[]) lhs, (boolean[]) rhs); [EOL]     } else { [EOL]         append((Object[]) lhs, (Object[]) rhs); [EOL]     } [EOL]     return this; [EOL] }
public EqualsBuilder append(final Object lhs, final Object rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     final Class<?> lhsClass = lhs.getClass(); [EOL]     if (!lhsClass.isArray()) { [EOL]         isEquals = lhs.equals(rhs); [EOL]     } else if (lhs.getClass() != rhs.getClass()) { [EOL]         this.setEquals(false); [EOL]     } else if (lhs instanceof long[]) { [EOL]         append((long[]) lhs, (long[]) rhs); [EOL]     } else if (lhs instanceof int[]) { [EOL]         append((int[]) lhs, (int[]) rhs); [EOL]     } else if (lhs instanceof short[]) { [EOL]         append((short[]) lhs, (short[]) rhs); [EOL]     } else if (lhs instanceof char[]) { [EOL]         append((char[]) lhs, (char[]) rhs); [EOL]     } else if (lhs instanceof byte[]) { [EOL]         append((byte[]) lhs, (byte[]) rhs); [EOL]     } else if (lhs instanceof double[]) { [EOL]         append((double[]) lhs, (double[]) rhs); [EOL]     } else if (lhs instanceof float[]) { [EOL]         append((float[]) lhs, (float[]) rhs); [EOL]     } else if (lhs instanceof boolean[]) { [EOL]         append((boolean[]) lhs, (boolean[]) rhs); [EOL]     } else { [EOL]         append((Object[]) lhs, (Object[]) rhs); [EOL]     } [EOL]     return this; [EOL] }
public EqualsBuilder append(final Object lhs, final Object rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     final Class<?> lhsClass = lhs.getClass(); [EOL]     if (!lhsClass.isArray()) { [EOL]         isEquals = lhs.equals(rhs); [EOL]     } else if (lhs.getClass() != rhs.getClass()) { [EOL]         this.setEquals(false); [EOL]     } else if (lhs instanceof long[]) { [EOL]         append((long[]) lhs, (long[]) rhs); [EOL]     } else if (lhs instanceof int[]) { [EOL]         append((int[]) lhs, (int[]) rhs); [EOL]     } else if (lhs instanceof short[]) { [EOL]         append((short[]) lhs, (short[]) rhs); [EOL]     } else if (lhs instanceof char[]) { [EOL]         append((char[]) lhs, (char[]) rhs); [EOL]     } else if (lhs instanceof byte[]) { [EOL]         append((byte[]) lhs, (byte[]) rhs); [EOL]     } else if (lhs instanceof double[]) { [EOL]         append((double[]) lhs, (double[]) rhs); [EOL]     } else if (lhs instanceof float[]) { [EOL]         append((float[]) lhs, (float[]) rhs); [EOL]     } else if (lhs instanceof boolean[]) { [EOL]         append((boolean[]) lhs, (boolean[]) rhs); [EOL]     } else { [EOL]         append((Object[]) lhs, (Object[]) rhs); [EOL]     } [EOL]     return this; [EOL] }
public EqualsBuilder append(final Object lhs, final Object rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     final Class<?> lhsClass = lhs.getClass(); [EOL]     if (!lhsClass.isArray()) { [EOL]         isEquals = lhs.equals(rhs); [EOL]     } else if (lhs.getClass() != rhs.getClass()) { [EOL]         this.setEquals(false); [EOL]     } else if (lhs instanceof long[]) { [EOL]         append((long[]) lhs, (long[]) rhs); [EOL]     } else if (lhs instanceof int[]) { [EOL]         append((int[]) lhs, (int[]) rhs); [EOL]     } else if (lhs instanceof short[]) { [EOL]         append((short[]) lhs, (short[]) rhs); [EOL]     } else if (lhs instanceof char[]) { [EOL]         append((char[]) lhs, (char[]) rhs); [EOL]     } else if (lhs instanceof byte[]) { [EOL]         append((byte[]) lhs, (byte[]) rhs); [EOL]     } else if (lhs instanceof double[]) { [EOL]         append((double[]) lhs, (double[]) rhs); [EOL]     } else if (lhs instanceof float[]) { [EOL]         append((float[]) lhs, (float[]) rhs); [EOL]     } else if (lhs instanceof boolean[]) { [EOL]         append((boolean[]) lhs, (boolean[]) rhs); [EOL]     } else { [EOL]         append((Object[]) lhs, (Object[]) rhs); [EOL]     } [EOL]     return this; [EOL] }
public EqualsBuilder append(final short lhs, final short rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     isEquals = (lhs == rhs); [EOL]     return this; [EOL] }
public EqualsBuilder append(final long[] lhs, final long[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public EqualsBuilder append(final long[] lhs, final long[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public EqualsBuilder append(final long[] lhs, final long[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public EqualsBuilder append(final long[] lhs, final long[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public EqualsBuilder append(final long[] lhs, final long[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public EqualsBuilder append(final long[] lhs, final long[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public EqualsBuilder append(final long[] lhs, final long[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public EqualsBuilder append(final int[] lhs, final int[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public EqualsBuilder append(final short[] lhs, final short[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public EqualsBuilder append(final short[] lhs, final short[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public EqualsBuilder append(final short[] lhs, final short[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public EqualsBuilder append(final short[] lhs, final short[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public EqualsBuilder append(final short[] lhs, final short[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public EqualsBuilder append(final short[] lhs, final short[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public EqualsBuilder append(final short[] lhs, final short[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public EqualsBuilder append(final byte[] lhs, final byte[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public EqualsBuilder append(final byte[] lhs, final byte[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public EqualsBuilder append(final byte[] lhs, final byte[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public EqualsBuilder append(final byte[] lhs, final byte[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public EqualsBuilder append(final byte[] lhs, final byte[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public EqualsBuilder append(final byte[] lhs, final byte[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public EqualsBuilder append(final byte[] lhs, final byte[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public Boolean build() { [EOL]     return Boolean.valueOf(isEquals()); [EOL] }
@Override [EOL] public Boolean build() { [EOL]     return Boolean.valueOf(isEquals()); [EOL] }
public static StrMatcher commaMatcher() { [EOL]     return COMMA_MATCHER; [EOL] }
public static StrMatcher spaceMatcher() { [EOL]     return SPACE_MATCHER; [EOL] }
public static StrMatcher stringMatcher(final String str) { [EOL]     if (StringUtils.isEmpty(str)) { [EOL]         return NONE_MATCHER; [EOL]     } [EOL]     return new StringMatcher(str); [EOL] }
@Override [EOL] public int isMatch(final char[] buffer, final int pos, final int bufferStart, final int bufferEnd) { [EOL]     return ch == buffer[pos] ? 1 : 0; [EOL] }
@Override [EOL] public int isMatch(final char[] buffer, final int pos, final int bufferStart, final int bufferEnd) { [EOL]     return ch == buffer[pos] ? 1 : 0; [EOL] }
public void decrement() { [EOL]     value--; [EOL] }
public void decrement() { [EOL]     value--; [EOL] }
public void decrement() { [EOL]     value--; [EOL] }
public void add(final byte operand) { [EOL]     this.value += operand; [EOL] }
public void add(final byte operand) { [EOL]     this.value += operand; [EOL] }
public void add(final byte operand) { [EOL]     this.value += operand; [EOL] }
@Override [EOL] public int intValue() { [EOL]     return value; [EOL] }
@Override [EOL] public int intValue() { [EOL]     return value; [EOL] }
@Override [EOL] public int intValue() { [EOL]     return value; [EOL] }
@Override [EOL] public long longValue() { [EOL]     return value; [EOL] }
@Override [EOL] public long longValue() { [EOL]     return value; [EOL] }
@Override [EOL] public long longValue() { [EOL]     return value; [EOL] }
public final void translate(final CharSequence input, final Writer out) throws IOException { [EOL]     if (out == null) { [EOL]         throw new IllegalArgumentException("The Writer must not be null"); [EOL]     } [EOL]     if (input == null) { [EOL]         return; [EOL]     } [EOL]     int pos = 0; [EOL]     final int len = input.length(); [EOL]     while (pos < len) { [EOL]         final int consumed = translate(input, pos, out); [EOL]         if (consumed == 0) { [EOL]             final char[] c = Character.toChars(Character.codePointAt(input, pos)); [EOL]             out.write(c); [EOL]             pos += c.length; [EOL]             continue; [EOL]         } [EOL]         for (int pt = 0; pt < consumed; pt++) { [EOL]             pos += Character.charCount(Character.codePointAt(input, pt)); [EOL]         } [EOL]     } [EOL] }
public final void translate(final CharSequence input, final Writer out) throws IOException { [EOL]     if (out == null) { [EOL]         throw new IllegalArgumentException("The Writer must not be null"); [EOL]     } [EOL]     if (input == null) { [EOL]         return; [EOL]     } [EOL]     int pos = 0; [EOL]     final int len = input.length(); [EOL]     while (pos < len) { [EOL]         final int consumed = translate(input, pos, out); [EOL]         if (consumed == 0) { [EOL]             final char[] c = Character.toChars(Character.codePointAt(input, pos)); [EOL]             out.write(c); [EOL]             pos += c.length; [EOL]             continue; [EOL]         } [EOL]         for (int pt = 0; pt < consumed; pt++) { [EOL]             pos += Character.charCount(Character.codePointAt(input, pt)); [EOL]         } [EOL]     } [EOL] }
public final void translate(final CharSequence input, final Writer out) throws IOException { [EOL]     if (out == null) { [EOL]         throw new IllegalArgumentException("The Writer must not be null"); [EOL]     } [EOL]     if (input == null) { [EOL]         return; [EOL]     } [EOL]     int pos = 0; [EOL]     final int len = input.length(); [EOL]     while (pos < len) { [EOL]         final int consumed = translate(input, pos, out); [EOL]         if (consumed == 0) { [EOL]             final char[] c = Character.toChars(Character.codePointAt(input, pos)); [EOL]             out.write(c); [EOL]             pos += c.length; [EOL]             continue; [EOL]         } [EOL]         for (int pt = 0; pt < consumed; pt++) { [EOL]             pos += Character.charCount(Character.codePointAt(input, pt)); [EOL]         } [EOL]     } [EOL] }
public final void translate(final CharSequence input, final Writer out) throws IOException { [EOL]     if (out == null) { [EOL]         throw new IllegalArgumentException("The Writer must not be null"); [EOL]     } [EOL]     if (input == null) { [EOL]         return; [EOL]     } [EOL]     int pos = 0; [EOL]     final int len = input.length(); [EOL]     while (pos < len) { [EOL]         final int consumed = translate(input, pos, out); [EOL]         if (consumed == 0) { [EOL]             final char[] c = Character.toChars(Character.codePointAt(input, pos)); [EOL]             out.write(c); [EOL]             pos += c.length; [EOL]             continue; [EOL]         } [EOL]         for (int pt = 0; pt < consumed; pt++) { [EOL]             pos += Character.charCount(Character.codePointAt(input, pt)); [EOL]         } [EOL]     } [EOL] }
public final void translate(final CharSequence input, final Writer out) throws IOException { [EOL]     if (out == null) { [EOL]         throw new IllegalArgumentException("The Writer must not be null"); [EOL]     } [EOL]     if (input == null) { [EOL]         return; [EOL]     } [EOL]     int pos = 0; [EOL]     final int len = input.length(); [EOL]     while (pos < len) { [EOL]         final int consumed = translate(input, pos, out); [EOL]         if (consumed == 0) { [EOL]             final char[] c = Character.toChars(Character.codePointAt(input, pos)); [EOL]             out.write(c); [EOL]             pos += c.length; [EOL]             continue; [EOL]         } [EOL]         for (int pt = 0; pt < consumed; pt++) { [EOL]             pos += Character.charCount(Character.codePointAt(input, pt)); [EOL]         } [EOL]     } [EOL] }
public static String hex(final int codepoint) { [EOL]     return Integer.toHexString(codepoint).toUpperCase(Locale.ENGLISH); [EOL] }
@Override [EOL] public boolean isUseIdentityHashCode() { [EOL]     return super.isUseIdentityHashCode(); [EOL] }
public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values) { [EOL]     asEnum(enumClass); [EOL]     Validate.notNull(values); [EOL]     final EnumSet<E> condensed = EnumSet.noneOf(enumClass); [EOL]     for (final E constant : values) { [EOL]         Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED); [EOL]         condensed.add(constant); [EOL]     } [EOL]     final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1]; [EOL]     for (final E value : condensed) { [EOL]         result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE); [EOL]     } [EOL]     ArrayUtils.reverse(result); [EOL]     return result; [EOL] }
public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values) { [EOL]     asEnum(enumClass); [EOL]     Validate.notNull(values); [EOL]     final EnumSet<E> condensed = EnumSet.noneOf(enumClass); [EOL]     for (final E constant : values) { [EOL]         Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED); [EOL]         condensed.add(constant); [EOL]     } [EOL]     final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1]; [EOL]     for (final E value : condensed) { [EOL]         result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE); [EOL]     } [EOL]     ArrayUtils.reverse(result); [EOL]     return result; [EOL] }
public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values) { [EOL]     asEnum(enumClass); [EOL]     Validate.notNull(values); [EOL]     final EnumSet<E> condensed = EnumSet.noneOf(enumClass); [EOL]     for (final E constant : values) { [EOL]         Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED); [EOL]         condensed.add(constant); [EOL]     } [EOL]     final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1]; [EOL]     for (final E value : condensed) { [EOL]         result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE); [EOL]     } [EOL]     ArrayUtils.reverse(result); [EOL]     return result; [EOL] }
public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values) { [EOL]     asEnum(enumClass); [EOL]     Validate.notNull(values); [EOL]     final EnumSet<E> condensed = EnumSet.noneOf(enumClass); [EOL]     for (final E constant : values) { [EOL]         Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED); [EOL]         condensed.add(constant); [EOL]     } [EOL]     final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1]; [EOL]     for (final E value : condensed) { [EOL]         result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE); [EOL]     } [EOL]     ArrayUtils.reverse(result); [EOL]     return result; [EOL] }
public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values) { [EOL]     asEnum(enumClass); [EOL]     Validate.notNull(values); [EOL]     final EnumSet<E> condensed = EnumSet.noneOf(enumClass); [EOL]     for (final E constant : values) { [EOL]         Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED); [EOL]         condensed.add(constant); [EOL]     } [EOL]     final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1]; [EOL]     for (final E value : condensed) { [EOL]         result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE); [EOL]     } [EOL]     ArrayUtils.reverse(result); [EOL]     return result; [EOL] }
public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final E... values) { [EOL]     asEnum(enumClass); [EOL]     Validate.noNullElements(values); [EOL]     final EnumSet<E> condensed = EnumSet.noneOf(enumClass); [EOL]     Collections.addAll(condensed, values); [EOL]     final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1]; [EOL]     for (final E value : condensed) { [EOL]         result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE); [EOL]     } [EOL]     ArrayUtils.reverse(result); [EOL]     return result; [EOL] }
public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final E... values) { [EOL]     asEnum(enumClass); [EOL]     Validate.noNullElements(values); [EOL]     final EnumSet<E> condensed = EnumSet.noneOf(enumClass); [EOL]     Collections.addAll(condensed, values); [EOL]     final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1]; [EOL]     for (final E value : condensed) { [EOL]         result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE); [EOL]     } [EOL]     ArrayUtils.reverse(result); [EOL]     return result; [EOL] }
public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final E... values) { [EOL]     asEnum(enumClass); [EOL]     Validate.noNullElements(values); [EOL]     final EnumSet<E> condensed = EnumSet.noneOf(enumClass); [EOL]     Collections.addAll(condensed, values); [EOL]     final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1]; [EOL]     for (final E value : condensed) { [EOL]         result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE); [EOL]     } [EOL]     ArrayUtils.reverse(result); [EOL]     return result; [EOL] }
public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final E... values) { [EOL]     asEnum(enumClass); [EOL]     Validate.noNullElements(values); [EOL]     final EnumSet<E> condensed = EnumSet.noneOf(enumClass); [EOL]     Collections.addAll(condensed, values); [EOL]     final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1]; [EOL]     for (final E value : condensed) { [EOL]         result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE); [EOL]     } [EOL]     ArrayUtils.reverse(result); [EOL]     return result; [EOL] }
public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final E... values) { [EOL]     asEnum(enumClass); [EOL]     Validate.noNullElements(values); [EOL]     final EnumSet<E> condensed = EnumSet.noneOf(enumClass); [EOL]     Collections.addAll(condensed, values); [EOL]     final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1]; [EOL]     for (final E value : condensed) { [EOL]         result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE); [EOL]     } [EOL]     ArrayUtils.reverse(result); [EOL]     return result; [EOL] }
public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final E... values) { [EOL]     asEnum(enumClass); [EOL]     Validate.noNullElements(values); [EOL]     final EnumSet<E> condensed = EnumSet.noneOf(enumClass); [EOL]     Collections.addAll(condensed, values); [EOL]     final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1]; [EOL]     for (final E value : condensed) { [EOL]         result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE); [EOL]     } [EOL]     ArrayUtils.reverse(result); [EOL]     return result; [EOL] }
public static <E extends Enum<E>> EnumSet<E> processBitVector(final Class<E> enumClass, final long value) { [EOL]     checkBitVectorable(enumClass).getEnumConstants(); [EOL]     return processBitVectors(enumClass, value); [EOL] }
public static <E extends Enum<E>> EnumSet<E> processBitVector(final Class<E> enumClass, final long value) { [EOL]     checkBitVectorable(enumClass).getEnumConstants(); [EOL]     return processBitVectors(enumClass, value); [EOL] }
public static <E extends Enum<E>> EnumSet<E> processBitVector(final Class<E> enumClass, final long value) { [EOL]     checkBitVectorable(enumClass).getEnumConstants(); [EOL]     return processBitVectors(enumClass, value); [EOL] }
public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values) { [EOL]     final EnumSet<E> results = EnumSet.noneOf(asEnum(enumClass)); [EOL]     values = ArrayUtils.clone(Validate.notNull(values)); [EOL]     ArrayUtils.reverse(values); [EOL]     for (final E constant : enumClass.getEnumConstants()) { [EOL]         final int block = constant.ordinal() / Long.SIZE; [EOL]         if (block < values.length && (values[block] & 1 << (constant.ordinal() % Long.SIZE)) != 0) { [EOL]             results.add(constant); [EOL]         } [EOL]     } [EOL]     return results; [EOL] }
public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values) { [EOL]     final EnumSet<E> results = EnumSet.noneOf(asEnum(enumClass)); [EOL]     values = ArrayUtils.clone(Validate.notNull(values)); [EOL]     ArrayUtils.reverse(values); [EOL]     for (final E constant : enumClass.getEnumConstants()) { [EOL]         final int block = constant.ordinal() / Long.SIZE; [EOL]         if (block < values.length && (values[block] & 1 << (constant.ordinal() % Long.SIZE)) != 0) { [EOL]             results.add(constant); [EOL]         } [EOL]     } [EOL]     return results; [EOL] }
private static <E extends Enum<E>> Class<E> asEnum(final Class<E> enumClass) { [EOL]     Validate.notNull(enumClass, ENUM_CLASS_MUST_BE_DEFINED); [EOL]     Validate.isTrue(enumClass.isEnum(), S_DOES_NOT_SEEM_TO_BE_AN_ENUM_TYPE, enumClass); [EOL]     return enumClass; [EOL] }
private static <E extends Enum<E>> Class<E> asEnum(final Class<E> enumClass) { [EOL]     Validate.notNull(enumClass, ENUM_CLASS_MUST_BE_DEFINED); [EOL]     Validate.isTrue(enumClass.isEnum(), S_DOES_NOT_SEEM_TO_BE_AN_ENUM_TYPE, enumClass); [EOL]     return enumClass; [EOL] }
private static <E extends Enum<E>> Class<E> asEnum(final Class<E> enumClass) { [EOL]     Validate.notNull(enumClass, ENUM_CLASS_MUST_BE_DEFINED); [EOL]     Validate.isTrue(enumClass.isEnum(), S_DOES_NOT_SEEM_TO_BE_AN_ENUM_TYPE, enumClass); [EOL]     return enumClass; [EOL] }
private F getDateTimeInstance(final Integer dateStyle, final Integer timeStyle, final TimeZone timeZone, Locale locale) { [EOL]     if (locale == null) { [EOL]         locale = Locale.getDefault(); [EOL]     } [EOL]     final String pattern = getPatternForStyle(dateStyle, timeStyle, locale); [EOL]     return getInstance(pattern, timeZone, locale); [EOL] }
private F getDateTimeInstance(final Integer dateStyle, final Integer timeStyle, final TimeZone timeZone, Locale locale) { [EOL]     if (locale == null) { [EOL]         locale = Locale.getDefault(); [EOL]     } [EOL]     final String pattern = getPatternForStyle(dateStyle, timeStyle, locale); [EOL]     return getInstance(pattern, timeZone, locale); [EOL] }
private F getDateTimeInstance(final Integer dateStyle, final Integer timeStyle, final TimeZone timeZone, Locale locale) { [EOL]     if (locale == null) { [EOL]         locale = Locale.getDefault(); [EOL]     } [EOL]     final String pattern = getPatternForStyle(dateStyle, timeStyle, locale); [EOL]     return getInstance(pattern, timeZone, locale); [EOL] }
F getDateInstance(final int dateStyle, final TimeZone timeZone, Locale locale) { [EOL]     return getDateTimeInstance(Integer.valueOf(dateStyle), null, timeZone, locale); [EOL] }
F getDateInstance(final int dateStyle, final TimeZone timeZone, Locale locale) { [EOL]     return getDateTimeInstance(Integer.valueOf(dateStyle), null, timeZone, locale); [EOL] }
F getDateInstance(final int dateStyle, final TimeZone timeZone, Locale locale) { [EOL]     return getDateTimeInstance(Integer.valueOf(dateStyle), null, timeZone, locale); [EOL] }
F getDateInstance(final int dateStyle, final TimeZone timeZone, Locale locale) { [EOL]     return getDateTimeInstance(Integer.valueOf(dateStyle), null, timeZone, locale); [EOL] }
static String getPatternForStyle(final Integer dateStyle, final Integer timeStyle, final Locale locale) { [EOL]     final MultipartKey key = new MultipartKey(dateStyle, timeStyle, locale); [EOL]     String pattern = cDateTimeInstanceCache.get(key); [EOL]     if (pattern == null) { [EOL]         try { [EOL]             DateFormat formatter; [EOL]             if (dateStyle == null) { [EOL]                 formatter = DateFormat.getTimeInstance(timeStyle.intValue(), locale); [EOL]             } else if (timeStyle == null) { [EOL]                 formatter = DateFormat.getDateInstance(dateStyle.intValue(), locale); [EOL]             } else { [EOL]                 formatter = DateFormat.getDateTimeInstance(dateStyle.intValue(), timeStyle.intValue(), locale); [EOL]             } [EOL]             pattern = ((SimpleDateFormat) formatter).toPattern(); [EOL]             final String previous = cDateTimeInstanceCache.putIfAbsent(key, pattern); [EOL]             if (previous != null) { [EOL]                 pattern = previous; [EOL]             } [EOL]         } catch (final ClassCastException ex) { [EOL]             throw new IllegalArgumentException("No date time pattern for locale: " + locale); [EOL]         } [EOL]     } [EOL]     return pattern; [EOL] }
static String getPatternForStyle(final Integer dateStyle, final Integer timeStyle, final Locale locale) { [EOL]     final MultipartKey key = new MultipartKey(dateStyle, timeStyle, locale); [EOL]     String pattern = cDateTimeInstanceCache.get(key); [EOL]     if (pattern == null) { [EOL]         try { [EOL]             DateFormat formatter; [EOL]             if (dateStyle == null) { [EOL]                 formatter = DateFormat.getTimeInstance(timeStyle.intValue(), locale); [EOL]             } else if (timeStyle == null) { [EOL]                 formatter = DateFormat.getDateInstance(dateStyle.intValue(), locale); [EOL]             } else { [EOL]                 formatter = DateFormat.getDateTimeInstance(dateStyle.intValue(), timeStyle.intValue(), locale); [EOL]             } [EOL]             pattern = ((SimpleDateFormat) formatter).toPattern(); [EOL]             final String previous = cDateTimeInstanceCache.putIfAbsent(key, pattern); [EOL]             if (previous != null) { [EOL]                 pattern = previous; [EOL]             } [EOL]         } catch (final ClassCastException ex) { [EOL]             throw new IllegalArgumentException("No date time pattern for locale: " + locale); [EOL]         } [EOL]     } [EOL]     return pattern; [EOL] }
static String getPatternForStyle(final Integer dateStyle, final Integer timeStyle, final Locale locale) { [EOL]     final MultipartKey key = new MultipartKey(dateStyle, timeStyle, locale); [EOL]     String pattern = cDateTimeInstanceCache.get(key); [EOL]     if (pattern == null) { [EOL]         try { [EOL]             DateFormat formatter; [EOL]             if (dateStyle == null) { [EOL]                 formatter = DateFormat.getTimeInstance(timeStyle.intValue(), locale); [EOL]             } else if (timeStyle == null) { [EOL]                 formatter = DateFormat.getDateInstance(dateStyle.intValue(), locale); [EOL]             } else { [EOL]                 formatter = DateFormat.getDateTimeInstance(dateStyle.intValue(), timeStyle.intValue(), locale); [EOL]             } [EOL]             pattern = ((SimpleDateFormat) formatter).toPattern(); [EOL]             final String previous = cDateTimeInstanceCache.putIfAbsent(key, pattern); [EOL]             if (previous != null) { [EOL]                 pattern = previous; [EOL]             } [EOL]         } catch (final ClassCastException ex) { [EOL]             throw new IllegalArgumentException("No date time pattern for locale: " + locale); [EOL]         } [EOL]     } [EOL]     return pattern; [EOL] }
static String getPatternForStyle(final Integer dateStyle, final Integer timeStyle, final Locale locale) { [EOL]     final MultipartKey key = new MultipartKey(dateStyle, timeStyle, locale); [EOL]     String pattern = cDateTimeInstanceCache.get(key); [EOL]     if (pattern == null) { [EOL]         try { [EOL]             DateFormat formatter; [EOL]             if (dateStyle == null) { [EOL]                 formatter = DateFormat.getTimeInstance(timeStyle.intValue(), locale); [EOL]             } else if (timeStyle == null) { [EOL]                 formatter = DateFormat.getDateInstance(dateStyle.intValue(), locale); [EOL]             } else { [EOL]                 formatter = DateFormat.getDateTimeInstance(dateStyle.intValue(), timeStyle.intValue(), locale); [EOL]             } [EOL]             pattern = ((SimpleDateFormat) formatter).toPattern(); [EOL]             final String previous = cDateTimeInstanceCache.putIfAbsent(key, pattern); [EOL]             if (previous != null) { [EOL]                 pattern = previous; [EOL]             } [EOL]         } catch (final ClassCastException ex) { [EOL]             throw new IllegalArgumentException("No date time pattern for locale: " + locale); [EOL]         } [EOL]     } [EOL]     return pattern; [EOL] }
static String getPatternForStyle(final Integer dateStyle, final Integer timeStyle, final Locale locale) { [EOL]     final MultipartKey key = new MultipartKey(dateStyle, timeStyle, locale); [EOL]     String pattern = cDateTimeInstanceCache.get(key); [EOL]     if (pattern == null) { [EOL]         try { [EOL]             DateFormat formatter; [EOL]             if (dateStyle == null) { [EOL]                 formatter = DateFormat.getTimeInstance(timeStyle.intValue(), locale); [EOL]             } else if (timeStyle == null) { [EOL]                 formatter = DateFormat.getDateInstance(dateStyle.intValue(), locale); [EOL]             } else { [EOL]                 formatter = DateFormat.getDateTimeInstance(dateStyle.intValue(), timeStyle.intValue(), locale); [EOL]             } [EOL]             pattern = ((SimpleDateFormat) formatter).toPattern(); [EOL]             final String previous = cDateTimeInstanceCache.putIfAbsent(key, pattern); [EOL]             if (previous != null) { [EOL]                 pattern = previous; [EOL]             } [EOL]         } catch (final ClassCastException ex) { [EOL]             throw new IllegalArgumentException("No date time pattern for locale: " + locale); [EOL]         } [EOL]     } [EOL]     return pattern; [EOL] }
public static ToStringStyle getDefaultStyle() { [EOL]     return defaultStyle; [EOL] }
public static String reflectionToString(final Object object, final ToStringStyle style) { [EOL]     return ReflectionToStringBuilder.toString(object, style); [EOL] }
public static String reflectionToString(final Object object, final ToStringStyle style) { [EOL]     return ReflectionToStringBuilder.toString(object, style); [EOL] }
public static String reflectionToString(final Object object, final ToStringStyle style) { [EOL]     return ReflectionToStringBuilder.toString(object, style); [EOL] }
public static String reflectionToString(final Object object, final ToStringStyle style, final boolean outputTransients) { [EOL]     return ReflectionToStringBuilder.toString(object, style, outputTransients, false, null); [EOL] }
public static String reflectionToString(final Object object, final ToStringStyle style, final boolean outputTransients) { [EOL]     return ReflectionToStringBuilder.toString(object, style, outputTransients, false, null); [EOL] }
public static String reflectionToString(final Object object, final ToStringStyle style, final boolean outputTransients) { [EOL]     return ReflectionToStringBuilder.toString(object, style, outputTransients, false, null); [EOL] }
public static String reflectionToString(final Object object, final ToStringStyle style, final boolean outputTransients) { [EOL]     return ReflectionToStringBuilder.toString(object, style, outputTransients, false, null); [EOL] }
public static String reflectionToString(final Object object, final ToStringStyle style, final boolean outputTransients) { [EOL]     return ReflectionToStringBuilder.toString(object, style, outputTransients, false, null); [EOL] }
public static String reflectionToString(final Object object, final ToStringStyle style, final boolean outputTransients) { [EOL]     return ReflectionToStringBuilder.toString(object, style, outputTransients, false, null); [EOL] }
public static <T> String reflectionToString(final T object, final ToStringStyle style, final boolean outputTransients, final Class<? super T> reflectUpToClass) { [EOL]     return ReflectionToStringBuilder.toString(object, style, outputTransients, false, reflectUpToClass); [EOL] }
public static <T> String reflectionToString(final T object, final ToStringStyle style, final boolean outputTransients, final Class<? super T> reflectUpToClass) { [EOL]     return ReflectionToStringBuilder.toString(object, style, outputTransients, false, reflectUpToClass); [EOL] }
public static <T> String reflectionToString(final T object, final ToStringStyle style, final boolean outputTransients, final Class<? super T> reflectUpToClass) { [EOL]     return ReflectionToStringBuilder.toString(object, style, outputTransients, false, reflectUpToClass); [EOL] }
public static <T> String reflectionToString(final T object, final ToStringStyle style, final boolean outputTransients, final Class<? super T> reflectUpToClass) { [EOL]     return ReflectionToStringBuilder.toString(object, style, outputTransients, false, reflectUpToClass); [EOL] }
public static <T> String reflectionToString(final T object, final ToStringStyle style, final boolean outputTransients, final Class<? super T> reflectUpToClass) { [EOL]     return ReflectionToStringBuilder.toString(object, style, outputTransients, false, reflectUpToClass); [EOL] }
public ToStringBuilder(final Object object) { [EOL]     this(object, null, null); [EOL] }
public ToStringBuilder(final Object object) { [EOL]     this(object, null, null); [EOL] }
public ToStringBuilder(final Object object, ToStringStyle style, StringBuffer buffer) { [EOL]     if (style == null) { [EOL]         style = getDefaultStyle(); [EOL]     } [EOL]     if (buffer == null) { [EOL]         buffer = new StringBuffer(512); [EOL]     } [EOL]     this.buffer = buffer; [EOL]     this.style = style; [EOL]     this.object = object; [EOL]     style.appendStart(buffer, object); [EOL] }
public ToStringBuilder(final Object object, ToStringStyle style, StringBuffer buffer) { [EOL]     if (style == null) { [EOL]         style = getDefaultStyle(); [EOL]     } [EOL]     if (buffer == null) { [EOL]         buffer = new StringBuffer(512); [EOL]     } [EOL]     this.buffer = buffer; [EOL]     this.style = style; [EOL]     this.object = object; [EOL]     style.appendStart(buffer, object); [EOL] }
public ToStringBuilder(final Object object, ToStringStyle style, StringBuffer buffer) { [EOL]     if (style == null) { [EOL]         style = getDefaultStyle(); [EOL]     } [EOL]     if (buffer == null) { [EOL]         buffer = new StringBuffer(512); [EOL]     } [EOL]     this.buffer = buffer; [EOL]     this.style = style; [EOL]     this.object = object; [EOL]     style.appendStart(buffer, object); [EOL] }
public ToStringBuilder(final Object object, ToStringStyle style, StringBuffer buffer) { [EOL]     if (style == null) { [EOL]         style = getDefaultStyle(); [EOL]     } [EOL]     if (buffer == null) { [EOL]         buffer = new StringBuffer(512); [EOL]     } [EOL]     this.buffer = buffer; [EOL]     this.style = style; [EOL]     this.object = object; [EOL]     style.appendStart(buffer, object); [EOL] }
public ToStringBuilder append(final boolean value) { [EOL]     style.append(buffer, null, value); [EOL]     return this; [EOL] }
public ToStringBuilder append(final boolean value) { [EOL]     style.append(buffer, null, value); [EOL]     return this; [EOL] }
public ToStringBuilder append(final byte value) { [EOL]     style.append(buffer, null, value); [EOL]     return this; [EOL] }
public ToStringBuilder append(final double value) { [EOL]     style.append(buffer, null, value); [EOL]     return this; [EOL] }
public ToStringBuilder append(final double value) { [EOL]     style.append(buffer, null, value); [EOL]     return this; [EOL] }
public ToStringBuilder append(final double value) { [EOL]     style.append(buffer, null, value); [EOL]     return this; [EOL] }
public ToStringBuilder append(final double value) { [EOL]     style.append(buffer, null, value); [EOL]     return this; [EOL] }
public ToStringBuilder append(final double[] array) { [EOL]     style.append(buffer, null, array, null); [EOL]     return this; [EOL] }
public ToStringBuilder append(final double[] array) { [EOL]     style.append(buffer, null, array, null); [EOL]     return this; [EOL] }
public ToStringBuilder append(final double[] array) { [EOL]     style.append(buffer, null, array, null); [EOL]     return this; [EOL] }
public ToStringBuilder append(final float[] array) { [EOL]     style.append(buffer, null, array, null); [EOL]     return this; [EOL] }
public ToStringBuilder append(final float[] array) { [EOL]     style.append(buffer, null, array, null); [EOL]     return this; [EOL] }
public ToStringBuilder append(final float[] array) { [EOL]     style.append(buffer, null, array, null); [EOL]     return this; [EOL] }
public ToStringBuilder append(final int value) { [EOL]     style.append(buffer, null, value); [EOL]     return this; [EOL] }
public ToStringBuilder append(final int value) { [EOL]     style.append(buffer, null, value); [EOL]     return this; [EOL] }
public ToStringBuilder append(final int[] array) { [EOL]     style.append(buffer, null, array, null); [EOL]     return this; [EOL] }
public ToStringBuilder append(final int[] array) { [EOL]     style.append(buffer, null, array, null); [EOL]     return this; [EOL] }
public ToStringBuilder append(final long value) { [EOL]     style.append(buffer, null, value); [EOL]     return this; [EOL] }
public ToStringBuilder append(final Object obj) { [EOL]     style.append(buffer, null, obj, null); [EOL]     return this; [EOL] }
public ToStringBuilder append(final Object obj) { [EOL]     style.append(buffer, null, obj, null); [EOL]     return this; [EOL] }
public ToStringBuilder append(final Object[] array) { [EOL]     style.append(buffer, null, array, null); [EOL]     return this; [EOL] }
public ToStringBuilder append(final Object[] array) { [EOL]     style.append(buffer, null, array, null); [EOL]     return this; [EOL] }
public ToStringBuilder append(final Object[] array) { [EOL]     style.append(buffer, null, array, null); [EOL]     return this; [EOL] }
public ToStringBuilder append(final String fieldName, final boolean value) { [EOL]     style.append(buffer, fieldName, value); [EOL]     return this; [EOL] }
public ToStringBuilder append(final String fieldName, final boolean value) { [EOL]     style.append(buffer, fieldName, value); [EOL]     return this; [EOL] }
public ToStringBuilder append(final String fieldName, final byte value) { [EOL]     style.append(buffer, fieldName, value); [EOL]     return this; [EOL] }
public ToStringBuilder append(final String fieldName, final double value) { [EOL]     style.append(buffer, fieldName, value); [EOL]     return this; [EOL] }
public ToStringBuilder append(final String fieldName, final double value) { [EOL]     style.append(buffer, fieldName, value); [EOL]     return this; [EOL] }
public ToStringBuilder append(final String fieldName, final int value) { [EOL]     style.append(buffer, fieldName, value); [EOL]     return this; [EOL] }
public ToStringBuilder append(final String fieldName, final int value) { [EOL]     style.append(buffer, fieldName, value); [EOL]     return this; [EOL] }
public ToStringBuilder append(final String fieldName, final long value) { [EOL]     style.append(buffer, fieldName, value); [EOL]     return this; [EOL] }
public ToStringBuilder append(final String fieldName, final long value) { [EOL]     style.append(buffer, fieldName, value); [EOL]     return this; [EOL] }
public ToStringBuilder append(final String fieldName, final Object obj, final boolean fullDetail) { [EOL]     style.append(buffer, fieldName, obj, Boolean.valueOf(fullDetail)); [EOL]     return this; [EOL] }
public ToStringBuilder append(final String fieldName, final Object obj, final boolean fullDetail) { [EOL]     style.append(buffer, fieldName, obj, Boolean.valueOf(fullDetail)); [EOL]     return this; [EOL] }
public Object getObject() { [EOL]     return object; [EOL] }
public Object getObject() { [EOL]     return object; [EOL] }
public StringBuffer getStringBuffer() { [EOL]     return buffer; [EOL] }
public StringBuffer getStringBuffer() { [EOL]     return buffer; [EOL] }
@Override [EOL] public String toString() { [EOL]     if (this.getObject() == null) { [EOL]         this.getStringBuffer().append(this.getStyle().getNullText()); [EOL]     } else { [EOL]         style.appendEnd(this.getStringBuffer(), this.getObject()); [EOL]     } [EOL]     return this.getStringBuffer().toString(); [EOL] }
@Override [EOL] public String toString() { [EOL]     if (this.getObject() == null) { [EOL]         this.getStringBuffer().append(this.getStyle().getNullText()); [EOL]     } else { [EOL]         style.appendEnd(this.getStringBuffer(), this.getObject()); [EOL]     } [EOL]     return this.getStringBuffer().toString(); [EOL] }
@Override [EOL] public void setValue(final T value) { [EOL]     this.value = value; [EOL] }
@Override [EOL] public int hashCode() { [EOL]     return value == null ? 0 : value.hashCode(); [EOL] }
@Override [EOL] public int hashCode() { [EOL]     return value == null ? 0 : value.hashCode(); [EOL] }
public static boolean isSameDay(final Date date1, final Date date2) { [EOL]     if (date1 == null || date2 == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     final Calendar cal1 = Calendar.getInstance(); [EOL]     cal1.setTime(date1); [EOL]     final Calendar cal2 = Calendar.getInstance(); [EOL]     cal2.setTime(date2); [EOL]     return isSameDay(cal1, cal2); [EOL] } public DateUtils();  DateIterator(final Calendar startFinal, final Calendar endFinal); public static boolean isSameDay(final Date date1, final Date date2); public static boolean isSameDay(final Calendar cal1, final Calendar cal2); public static boolean isSameInstant(final Date date1, final Date date2); public static boolean isSameInstant(final Calendar cal1, final Calendar cal2); public static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2); public static Date parseDate(final String str, final String... parsePatterns) throws ParseException; public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException; private static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException; public static Date addYears(final Date date, final int amount); public static Date addMonths(final Date date, final int amount); public static Date addWeeks(final Date date, final int amount); public static Date addDays(final Date date, final int amount); public static Date addHours(final Date date, final int amount); public static Date addMinutes(final Date date, final int amount); public static Date addSeconds(final Date date, final int amount); public static Date addMilliseconds(final Date date, final int amount); private static Date add(final Date date, final int calendarField, final int amount); public static Date setYears(final Date date, final int amount); public static Date setMonths(final Date date, final int amount); public static Date setDays(final Date date, final int amount); public static Date setHours(final Date date, final int amount); public static Date setMinutes(final Date date, final int amount); public static Date setSeconds(final Date date, final int amount); public static Date setMilliseconds(final Date date, final int amount); private static Date set(final Date date, final int calendarField, final int amount); public static Calendar toCalendar(final Date date); public static Date round(final Date date, final int field); public static Calendar round(final Calendar date, final int field); public static Date round(final Object date, final int field); public static Date truncate(final Date date, final int field); public static Calendar truncate(final Calendar date, final int field); public static Date truncate(final Object date, final int field); public static Date ceiling(final Date date, final int field); public static Calendar ceiling(final Calendar date, final int field); public static Date ceiling(final Object date, final int field); private static void modify(final Calendar val, final int field, final int modType); public static Iterator<Calendar> iterator(final Date focus, final int rangeStyle); public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle); public static Iterator<?> iterator(final Object focus, final int rangeStyle); public static long getFragmentInMilliseconds(final Date date, final int fragment); public static long getFragmentInSeconds(final Date date, final int fragment); public static long getFragmentInMinutes(final Date date, final int fragment); public static long getFragmentInHours(final Date date, final int fragment); public static long getFragmentInDays(final Date date, final int fragment); public static long getFragmentInMilliseconds(final Calendar calendar, final int fragment); public static long getFragmentInSeconds(final Calendar calendar, final int fragment); public static long getFragmentInMinutes(final Calendar calendar, final int fragment); public static long getFragmentInHours(final Calendar calendar, final int fragment); public static long getFragmentInDays(final Calendar calendar, final int fragment); private static long getFragment(final Date date, final int fragment, final int unit); private static long getFragment(final Calendar calendar, final int fragment, final int unit); public static boolean truncatedEquals(final Calendar cal1, final Calendar cal2, final int field); public static boolean truncatedEquals(final Date date1, final Date date2, final int field); public static int truncatedCompareTo(final Calendar cal1, final Calendar cal2, final int field); public static int truncatedCompareTo(final Date date1, final Date date2, final int field); private static long getMillisPerUnit(final int unit); public boolean hasNext(); public Calendar next(); public void remove(); long MILLIS_PER_SECOND=Optional[1000]; long MILLIS_PER_MINUTE=Optional[60 * MILLIS_PER_SECOND]; long MILLIS_PER_HOUR=Optional[60 * MILLIS_PER_MINUTE]; long MILLIS_PER_DAY=Optional[24 * MILLIS_PER_HOUR]; int SEMI_MONTH=Optional[1001]; int[][] fields=Optional[{ { Calendar.MILLISECOND }, { Calendar.SECOND }, { Calendar.MINUTE }, { Calendar.HOUR_OF_DAY, Calendar.HOUR }, { Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM /* Calendar.DAY_OF_YEAR, Calendar.DAY_OF_WEEK, Calendar.DAY_OF_WEEK_IN_MONTH */; }, { Calendar.MONTH, DateUtils.SEMI_MONTH }, { Calendar.YEAR }, { Calendar.ERA } }
public static boolean isSameDay(final Calendar cal1, final Calendar cal2) { [EOL]     if (cal1 == null || cal2 == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     return (cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) && cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) && cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR)); [EOL] } public DateUtils();  DateIterator(final Calendar startFinal, final Calendar endFinal); public static boolean isSameDay(final Date date1, final Date date2); public static boolean isSameDay(final Calendar cal1, final Calendar cal2); public static boolean isSameInstant(final Date date1, final Date date2); public static boolean isSameInstant(final Calendar cal1, final Calendar cal2); public static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2); public static Date parseDate(final String str, final String... parsePatterns) throws ParseException; public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException; private static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException; public static Date addYears(final Date date, final int amount); public static Date addMonths(final Date date, final int amount); public static Date addWeeks(final Date date, final int amount); public static Date addDays(final Date date, final int amount); public static Date addHours(final Date date, final int amount); public static Date addMinutes(final Date date, final int amount); public static Date addSeconds(final Date date, final int amount); public static Date addMilliseconds(final Date date, final int amount); private static Date add(final Date date, final int calendarField, final int amount); public static Date setYears(final Date date, final int amount); public static Date setMonths(final Date date, final int amount); public static Date setDays(final Date date, final int amount); public static Date setHours(final Date date, final int amount); public static Date setMinutes(final Date date, final int amount); public static Date setSeconds(final Date date, final int amount); public static Date setMilliseconds(final Date date, final int amount); private static Date set(final Date date, final int calendarField, final int amount); public static Calendar toCalendar(final Date date); public static Date round(final Date date, final int field); public static Calendar round(final Calendar date, final int field); public static Date round(final Object date, final int field); public static Date truncate(final Date date, final int field); public static Calendar truncate(final Calendar date, final int field); public static Date truncate(final Object date, final int field); public static Date ceiling(final Date date, final int field); public static Calendar ceiling(final Calendar date, final int field); public static Date ceiling(final Object date, final int field); private static void modify(final Calendar val, final int field, final int modType); public static Iterator<Calendar> iterator(final Date focus, final int rangeStyle); public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle); public static Iterator<?> iterator(final Object focus, final int rangeStyle); public static long getFragmentInMilliseconds(final Date date, final int fragment); public static long getFragmentInSeconds(final Date date, final int fragment); public static long getFragmentInMinutes(final Date date, final int fragment); public static long getFragmentInHours(final Date date, final int fragment); public static long getFragmentInDays(final Date date, final int fragment); public static long getFragmentInMilliseconds(final Calendar calendar, final int fragment); public static long getFragmentInSeconds(final Calendar calendar, final int fragment); public static long getFragmentInMinutes(final Calendar calendar, final int fragment); public static long getFragmentInHours(final Calendar calendar, final int fragment); public static long getFragmentInDays(final Calendar calendar, final int fragment); private static long getFragment(final Date date, final int fragment, final int unit); private static long getFragment(final Calendar calendar, final int fragment, final int unit); public static boolean truncatedEquals(final Calendar cal1, final Calendar cal2, final int field); public static boolean truncatedEquals(final Date date1, final Date date2, final int field); public static int truncatedCompareTo(final Calendar cal1, final Calendar cal2, final int field); public static int truncatedCompareTo(final Date date1, final Date date2, final int field); private static long getMillisPerUnit(final int unit); public boolean hasNext(); public Calendar next(); public void remove(); long MILLIS_PER_SECOND=Optional[1000]; long MILLIS_PER_MINUTE=Optional[60 * MILLIS_PER_SECOND]; long MILLIS_PER_HOUR=Optional[60 * MILLIS_PER_MINUTE]; long MILLIS_PER_DAY=Optional[24 * MILLIS_PER_HOUR]; int SEMI_MONTH=Optional[1001]; int[][] fields=Optional[{ { Calendar.MILLISECOND }, { Calendar.SECOND }, { Calendar.MINUTE }, { Calendar.HOUR_OF_DAY, Calendar.HOUR }, { Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM /* Calendar.DAY_OF_YEAR, Calendar.DAY_OF_WEEK, Calendar.DAY_OF_WEEK_IN_MONTH */; }, { Calendar.MONTH, DateUtils.SEMI_MONTH }, { Calendar.YEAR }, { Calendar.ERA } }
public static boolean isSameInstant(final Date date1, final Date date2) { [EOL]     if (date1 == null || date2 == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     return date1.getTime() == date2.getTime(); [EOL] } public DateUtils();  DateIterator(final Calendar startFinal, final Calendar endFinal); public static boolean isSameDay(final Date date1, final Date date2); public static boolean isSameDay(final Calendar cal1, final Calendar cal2); public static boolean isSameInstant(final Date date1, final Date date2); public static boolean isSameInstant(final Calendar cal1, final Calendar cal2); public static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2); public static Date parseDate(final String str, final String... parsePatterns) throws ParseException; public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException; private static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException; public static Date addYears(final Date date, final int amount); public static Date addMonths(final Date date, final int amount); public static Date addWeeks(final Date date, final int amount); public static Date addDays(final Date date, final int amount); public static Date addHours(final Date date, final int amount); public static Date addMinutes(final Date date, final int amount); public static Date addSeconds(final Date date, final int amount); public static Date addMilliseconds(final Date date, final int amount); private static Date add(final Date date, final int calendarField, final int amount); public static Date setYears(final Date date, final int amount); public static Date setMonths(final Date date, final int amount); public static Date setDays(final Date date, final int amount); public static Date setHours(final Date date, final int amount); public static Date setMinutes(final Date date, final int amount); public static Date setSeconds(final Date date, final int amount); public static Date setMilliseconds(final Date date, final int amount); private static Date set(final Date date, final int calendarField, final int amount); public static Calendar toCalendar(final Date date); public static Date round(final Date date, final int field); public static Calendar round(final Calendar date, final int field); public static Date round(final Object date, final int field); public static Date truncate(final Date date, final int field); public static Calendar truncate(final Calendar date, final int field); public static Date truncate(final Object date, final int field); public static Date ceiling(final Date date, final int field); public static Calendar ceiling(final Calendar date, final int field); public static Date ceiling(final Object date, final int field); private static void modify(final Calendar val, final int field, final int modType); public static Iterator<Calendar> iterator(final Date focus, final int rangeStyle); public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle); public static Iterator<?> iterator(final Object focus, final int rangeStyle); public static long getFragmentInMilliseconds(final Date date, final int fragment); public static long getFragmentInSeconds(final Date date, final int fragment); public static long getFragmentInMinutes(final Date date, final int fragment); public static long getFragmentInHours(final Date date, final int fragment); public static long getFragmentInDays(final Date date, final int fragment); public static long getFragmentInMilliseconds(final Calendar calendar, final int fragment); public static long getFragmentInSeconds(final Calendar calendar, final int fragment); public static long getFragmentInMinutes(final Calendar calendar, final int fragment); public static long getFragmentInHours(final Calendar calendar, final int fragment); public static long getFragmentInDays(final Calendar calendar, final int fragment); private static long getFragment(final Date date, final int fragment, final int unit); private static long getFragment(final Calendar calendar, final int fragment, final int unit); public static boolean truncatedEquals(final Calendar cal1, final Calendar cal2, final int field); public static boolean truncatedEquals(final Date date1, final Date date2, final int field); public static int truncatedCompareTo(final Calendar cal1, final Calendar cal2, final int field); public static int truncatedCompareTo(final Date date1, final Date date2, final int field); private static long getMillisPerUnit(final int unit); public boolean hasNext(); public Calendar next(); public void remove(); long MILLIS_PER_SECOND=Optional[1000]; long MILLIS_PER_MINUTE=Optional[60 * MILLIS_PER_SECOND]; long MILLIS_PER_HOUR=Optional[60 * MILLIS_PER_MINUTE]; long MILLIS_PER_DAY=Optional[24 * MILLIS_PER_HOUR]; int SEMI_MONTH=Optional[1001]; int[][] fields=Optional[{ { Calendar.MILLISECOND }, { Calendar.SECOND }, { Calendar.MINUTE }, { Calendar.HOUR_OF_DAY, Calendar.HOUR }, { Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM /* Calendar.DAY_OF_YEAR, Calendar.DAY_OF_WEEK, Calendar.DAY_OF_WEEK_IN_MONTH */; }, { Calendar.MONTH, DateUtils.SEMI_MONTH }, { Calendar.YEAR }, { Calendar.ERA } }
public static boolean isSameInstant(final Calendar cal1, final Calendar cal2) { [EOL]     if (cal1 == null || cal2 == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     return cal1.getTime().getTime() == cal2.getTime().getTime(); [EOL] } public DateUtils();  DateIterator(final Calendar startFinal, final Calendar endFinal); public static boolean isSameDay(final Date date1, final Date date2); public static boolean isSameDay(final Calendar cal1, final Calendar cal2); public static boolean isSameInstant(final Date date1, final Date date2); public static boolean isSameInstant(final Calendar cal1, final Calendar cal2); public static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2); public static Date parseDate(final String str, final String... parsePatterns) throws ParseException; public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException; private static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException; public static Date addYears(final Date date, final int amount); public static Date addMonths(final Date date, final int amount); public static Date addWeeks(final Date date, final int amount); public static Date addDays(final Date date, final int amount); public static Date addHours(final Date date, final int amount); public static Date addMinutes(final Date date, final int amount); public static Date addSeconds(final Date date, final int amount); public static Date addMilliseconds(final Date date, final int amount); private static Date add(final Date date, final int calendarField, final int amount); public static Date setYears(final Date date, final int amount); public static Date setMonths(final Date date, final int amount); public static Date setDays(final Date date, final int amount); public static Date setHours(final Date date, final int amount); public static Date setMinutes(final Date date, final int amount); public static Date setSeconds(final Date date, final int amount); public static Date setMilliseconds(final Date date, final int amount); private static Date set(final Date date, final int calendarField, final int amount); public static Calendar toCalendar(final Date date); public static Date round(final Date date, final int field); public static Calendar round(final Calendar date, final int field); public static Date round(final Object date, final int field); public static Date truncate(final Date date, final int field); public static Calendar truncate(final Calendar date, final int field); public static Date truncate(final Object date, final int field); public static Date ceiling(final Date date, final int field); public static Calendar ceiling(final Calendar date, final int field); public static Date ceiling(final Object date, final int field); private static void modify(final Calendar val, final int field, final int modType); public static Iterator<Calendar> iterator(final Date focus, final int rangeStyle); public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle); public static Iterator<?> iterator(final Object focus, final int rangeStyle); public static long getFragmentInMilliseconds(final Date date, final int fragment); public static long getFragmentInSeconds(final Date date, final int fragment); public static long getFragmentInMinutes(final Date date, final int fragment); public static long getFragmentInHours(final Date date, final int fragment); public static long getFragmentInDays(final Date date, final int fragment); public static long getFragmentInMilliseconds(final Calendar calendar, final int fragment); public static long getFragmentInSeconds(final Calendar calendar, final int fragment); public static long getFragmentInMinutes(final Calendar calendar, final int fragment); public static long getFragmentInHours(final Calendar calendar, final int fragment); public static long getFragmentInDays(final Calendar calendar, final int fragment); private static long getFragment(final Date date, final int fragment, final int unit); private static long getFragment(final Calendar calendar, final int fragment, final int unit); public static boolean truncatedEquals(final Calendar cal1, final Calendar cal2, final int field); public static boolean truncatedEquals(final Date date1, final Date date2, final int field); public static int truncatedCompareTo(final Calendar cal1, final Calendar cal2, final int field); public static int truncatedCompareTo(final Date date1, final Date date2, final int field); private static long getMillisPerUnit(final int unit); public boolean hasNext(); public Calendar next(); public void remove(); long MILLIS_PER_SECOND=Optional[1000]; long MILLIS_PER_MINUTE=Optional[60 * MILLIS_PER_SECOND]; long MILLIS_PER_HOUR=Optional[60 * MILLIS_PER_MINUTE]; long MILLIS_PER_DAY=Optional[24 * MILLIS_PER_HOUR]; int SEMI_MONTH=Optional[1001]; int[][] fields=Optional[{ { Calendar.MILLISECOND }, { Calendar.SECOND }, { Calendar.MINUTE }, { Calendar.HOUR_OF_DAY, Calendar.HOUR }, { Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM /* Calendar.DAY_OF_YEAR, Calendar.DAY_OF_WEEK, Calendar.DAY_OF_WEEK_IN_MONTH */; }, { Calendar.MONTH, DateUtils.SEMI_MONTH }, { Calendar.YEAR }, { Calendar.ERA } }
public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException { [EOL]     return parseDateWithLeniency(str, locale, parsePatterns, true); [EOL] } public DateUtils();  DateIterator(final Calendar startFinal, final Calendar endFinal); public static boolean isSameDay(final Date date1, final Date date2); public static boolean isSameDay(final Calendar cal1, final Calendar cal2); public static boolean isSameInstant(final Date date1, final Date date2); public static boolean isSameInstant(final Calendar cal1, final Calendar cal2); public static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2); public static Date parseDate(final String str, final String... parsePatterns) throws ParseException; public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException; private static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException; public static Date addYears(final Date date, final int amount); public static Date addMonths(final Date date, final int amount); public static Date addWeeks(final Date date, final int amount); public static Date addDays(final Date date, final int amount); public static Date addHours(final Date date, final int amount); public static Date addMinutes(final Date date, final int amount); public static Date addSeconds(final Date date, final int amount); public static Date addMilliseconds(final Date date, final int amount); private static Date add(final Date date, final int calendarField, final int amount); public static Date setYears(final Date date, final int amount); public static Date setMonths(final Date date, final int amount); public static Date setDays(final Date date, final int amount); public static Date setHours(final Date date, final int amount); public static Date setMinutes(final Date date, final int amount); public static Date setSeconds(final Date date, final int amount); public static Date setMilliseconds(final Date date, final int amount); private static Date set(final Date date, final int calendarField, final int amount); public static Calendar toCalendar(final Date date); public static Date round(final Date date, final int field); public static Calendar round(final Calendar date, final int field); public static Date round(final Object date, final int field); public static Date truncate(final Date date, final int field); public static Calendar truncate(final Calendar date, final int field); public static Date truncate(final Object date, final int field); public static Date ceiling(final Date date, final int field); public static Calendar ceiling(final Calendar date, final int field); public static Date ceiling(final Object date, final int field); private static void modify(final Calendar val, final int field, final int modType); public static Iterator<Calendar> iterator(final Date focus, final int rangeStyle); public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle); public static Iterator<?> iterator(final Object focus, final int rangeStyle); public static long getFragmentInMilliseconds(final Date date, final int fragment); public static long getFragmentInSeconds(final Date date, final int fragment); public static long getFragmentInMinutes(final Date date, final int fragment); public static long getFragmentInHours(final Date date, final int fragment); public static long getFragmentInDays(final Date date, final int fragment); public static long getFragmentInMilliseconds(final Calendar calendar, final int fragment); public static long getFragmentInSeconds(final Calendar calendar, final int fragment); public static long getFragmentInMinutes(final Calendar calendar, final int fragment); public static long getFragmentInHours(final Calendar calendar, final int fragment); public static long getFragmentInDays(final Calendar calendar, final int fragment); private static long getFragment(final Date date, final int fragment, final int unit); private static long getFragment(final Calendar calendar, final int fragment, final int unit); public static boolean truncatedEquals(final Calendar cal1, final Calendar cal2, final int field); public static boolean truncatedEquals(final Date date1, final Date date2, final int field); public static int truncatedCompareTo(final Calendar cal1, final Calendar cal2, final int field); public static int truncatedCompareTo(final Date date1, final Date date2, final int field); private static long getMillisPerUnit(final int unit); public boolean hasNext(); public Calendar next(); public void remove(); long MILLIS_PER_SECOND=Optional[1000]; long MILLIS_PER_MINUTE=Optional[60 * MILLIS_PER_SECOND]; long MILLIS_PER_HOUR=Optional[60 * MILLIS_PER_MINUTE]; long MILLIS_PER_DAY=Optional[24 * MILLIS_PER_HOUR]; int SEMI_MONTH=Optional[1001]; int[][] fields=Optional[{ { Calendar.MILLISECOND }, { Calendar.SECOND }, { Calendar.MINUTE }, { Calendar.HOUR_OF_DAY, Calendar.HOUR }, { Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM /* Calendar.DAY_OF_YEAR, Calendar.DAY_OF_WEEK, Calendar.DAY_OF_WEEK_IN_MONTH */; }, { Calendar.MONTH, DateUtils.SEMI_MONTH }, { Calendar.YEAR }, { Calendar.ERA } }
private static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException { [EOL]     if (str == null || parsePatterns == null) { [EOL]         throw new IllegalArgumentException("Date and Patterns must not be null"); [EOL]     } [EOL]     SimpleDateFormat parser; [EOL]     if (locale == null) { [EOL]         parser = new SimpleDateFormat(); [EOL]     } else { [EOL]         parser = new SimpleDateFormat("", locale); [EOL]     } [EOL]     parser.setLenient(lenient); [EOL]     final ParsePosition pos = new ParsePosition(0); [EOL]     for (final String parsePattern : parsePatterns) { [EOL]         String pattern = parsePattern; [EOL]         if (parsePattern.endsWith("ZZ")) { [EOL]             pattern = pattern.substring(0, pattern.length() - 1); [EOL]         } [EOL]         parser.applyPattern(pattern); [EOL]         pos.setIndex(0); [EOL]         String str2 = str; [EOL]         if (parsePattern.endsWith("ZZ")) { [EOL]             str2 = str.replaceAll("([-+][0-9][0-9]):([0-9][0-9])$", "$1$2"); [EOL]         } [EOL]         final Date date = parser.parse(str2, pos); [EOL]         if (date != null && pos.getIndex() == str2.length()) { [EOL]             return date; [EOL]         } [EOL]     } [EOL]     throw new ParseException("Unable to parse the date: " + str, -1); [EOL] } public DateUtils();  DateIterator(final Calendar startFinal, final Calendar endFinal); public static boolean isSameDay(final Date date1, final Date date2); public static boolean isSameDay(final Calendar cal1, final Calendar cal2); public static boolean isSameInstant(final Date date1, final Date date2); public static boolean isSameInstant(final Calendar cal1, final Calendar cal2); public static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2); public static Date parseDate(final String str, final String... parsePatterns) throws ParseException; public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException; private static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException; public static Date addYears(final Date date, final int amount); public static Date addMonths(final Date date, final int amount); public static Date addWeeks(final Date date, final int amount); public static Date addDays(final Date date, final int amount); public static Date addHours(final Date date, final int amount); public static Date addMinutes(final Date date, final int amount); public static Date addSeconds(final Date date, final int amount); public static Date addMilliseconds(final Date date, final int amount); private static Date add(final Date date, final int calendarField, final int amount); public static Date setYears(final Date date, final int amount); public static Date setMonths(final Date date, final int amount); public static Date setDays(final Date date, final int amount); public static Date setHours(final Date date, final int amount); public static Date setMinutes(final Date date, final int amount); public static Date setSeconds(final Date date, final int amount); public static Date setMilliseconds(final Date date, final int amount); private static Date set(final Date date, final int calendarField, final int amount); public static Calendar toCalendar(final Date date); public static Date round(final Date date, final int field); public static Calendar round(final Calendar date, final int field); public static Date round(final Object date, final int field); public static Date truncate(final Date date, final int field); public static Calendar truncate(final Calendar date, final int field); public static Date truncate(final Object date, final int field); public static Date ceiling(final Date date, final int field); public static Calendar ceiling(final Calendar date, final int field); public static Date ceiling(final Object date, final int field); private static void modify(final Calendar val, final int field, final int modType); public static Iterator<Calendar> iterator(final Date focus, final int rangeStyle); public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle); public static Iterator<?> iterator(final Object focus, final int rangeStyle); public static long getFragmentInMilliseconds(final Date date, final int fragment); public static long getFragmentInSeconds(final Date date, final int fragment); public static long getFragmentInMinutes(final Date date, final int fragment); public static long getFragmentInHours(final Date date, final int fragment); public static long getFragmentInDays(final Date date, final int fragment); public static long getFragmentInMilliseconds(final Calendar calendar, final int fragment); public static long getFragmentInSeconds(final Calendar calendar, final int fragment); public static long getFragmentInMinutes(final Calendar calendar, final int fragment); public static long getFragmentInHours(final Calendar calendar, final int fragment); public static long getFragmentInDays(final Calendar calendar, final int fragment); private static long getFragment(final Date date, final int fragment, final int unit); private static long getFragment(final Calendar calendar, final int fragment, final int unit); public static boolean truncatedEquals(final Calendar cal1, final Calendar cal2, final int field); public static boolean truncatedEquals(final Date date1, final Date date2, final int field); public static int truncatedCompareTo(final Calendar cal1, final Calendar cal2, final int field); public static int truncatedCompareTo(final Date date1, final Date date2, final int field); private static long getMillisPerUnit(final int unit); public boolean hasNext(); public Calendar next(); public void remove(); long MILLIS_PER_SECOND=Optional[1000]; long MILLIS_PER_MINUTE=Optional[60 * MILLIS_PER_SECOND]; long MILLIS_PER_HOUR=Optional[60 * MILLIS_PER_MINUTE]; long MILLIS_PER_DAY=Optional[24 * MILLIS_PER_HOUR]; int SEMI_MONTH=Optional[1001]; int[][] fields=Optional[{ { Calendar.MILLISECOND }, { Calendar.SECOND }, { Calendar.MINUTE }, { Calendar.HOUR_OF_DAY, Calendar.HOUR }, { Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM /* Calendar.DAY_OF_YEAR, Calendar.DAY_OF_WEEK, Calendar.DAY_OF_WEEK_IN_MONTH */; }, { Calendar.MONTH, DateUtils.SEMI_MONTH }, { Calendar.YEAR }, { Calendar.ERA } }
public static Date setMinutes(final Date date, final int amount) { [EOL]     return set(date, Calendar.MINUTE, amount); [EOL] } public DateUtils();  DateIterator(final Calendar startFinal, final Calendar endFinal); public static boolean isSameDay(final Date date1, final Date date2); public static boolean isSameDay(final Calendar cal1, final Calendar cal2); public static boolean isSameInstant(final Date date1, final Date date2); public static boolean isSameInstant(final Calendar cal1, final Calendar cal2); public static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2); public static Date parseDate(final String str, final String... parsePatterns) throws ParseException; public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException; private static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException; public static Date addYears(final Date date, final int amount); public static Date addMonths(final Date date, final int amount); public static Date addWeeks(final Date date, final int amount); public static Date addDays(final Date date, final int amount); public static Date addHours(final Date date, final int amount); public static Date addMinutes(final Date date, final int amount); public static Date addSeconds(final Date date, final int amount); public static Date addMilliseconds(final Date date, final int amount); private static Date add(final Date date, final int calendarField, final int amount); public static Date setYears(final Date date, final int amount); public static Date setMonths(final Date date, final int amount); public static Date setDays(final Date date, final int amount); public static Date setHours(final Date date, final int amount); public static Date setMinutes(final Date date, final int amount); public static Date setSeconds(final Date date, final int amount); public static Date setMilliseconds(final Date date, final int amount); private static Date set(final Date date, final int calendarField, final int amount); public static Calendar toCalendar(final Date date); public static Date round(final Date date, final int field); public static Calendar round(final Calendar date, final int field); public static Date round(final Object date, final int field); public static Date truncate(final Date date, final int field); public static Calendar truncate(final Calendar date, final int field); public static Date truncate(final Object date, final int field); public static Date ceiling(final Date date, final int field); public static Calendar ceiling(final Calendar date, final int field); public static Date ceiling(final Object date, final int field); private static void modify(final Calendar val, final int field, final int modType); public static Iterator<Calendar> iterator(final Date focus, final int rangeStyle); public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle); public static Iterator<?> iterator(final Object focus, final int rangeStyle); public static long getFragmentInMilliseconds(final Date date, final int fragment); public static long getFragmentInSeconds(final Date date, final int fragment); public static long getFragmentInMinutes(final Date date, final int fragment); public static long getFragmentInHours(final Date date, final int fragment); public static long getFragmentInDays(final Date date, final int fragment); public static long getFragmentInMilliseconds(final Calendar calendar, final int fragment); public static long getFragmentInSeconds(final Calendar calendar, final int fragment); public static long getFragmentInMinutes(final Calendar calendar, final int fragment); public static long getFragmentInHours(final Calendar calendar, final int fragment); public static long getFragmentInDays(final Calendar calendar, final int fragment); private static long getFragment(final Date date, final int fragment, final int unit); private static long getFragment(final Calendar calendar, final int fragment, final int unit); public static boolean truncatedEquals(final Calendar cal1, final Calendar cal2, final int field); public static boolean truncatedEquals(final Date date1, final Date date2, final int field); public static int truncatedCompareTo(final Calendar cal1, final Calendar cal2, final int field); public static int truncatedCompareTo(final Date date1, final Date date2, final int field); private static long getMillisPerUnit(final int unit); public boolean hasNext(); public Calendar next(); public void remove(); long MILLIS_PER_SECOND=Optional[1000]; long MILLIS_PER_MINUTE=Optional[60 * MILLIS_PER_SECOND]; long MILLIS_PER_HOUR=Optional[60 * MILLIS_PER_MINUTE]; long MILLIS_PER_DAY=Optional[24 * MILLIS_PER_HOUR]; int SEMI_MONTH=Optional[1001]; int[][] fields=Optional[{ { Calendar.MILLISECOND }, { Calendar.SECOND }, { Calendar.MINUTE }, { Calendar.HOUR_OF_DAY, Calendar.HOUR }, { Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM /* Calendar.DAY_OF_YEAR, Calendar.DAY_OF_WEEK, Calendar.DAY_OF_WEEK_IN_MONTH */; }, { Calendar.MONTH, DateUtils.SEMI_MONTH }, { Calendar.YEAR }, { Calendar.ERA } }
public static Date setMinutes(final Date date, final int amount) { [EOL]     return set(date, Calendar.MINUTE, amount); [EOL] } public DateUtils();  DateIterator(final Calendar startFinal, final Calendar endFinal); public static boolean isSameDay(final Date date1, final Date date2); public static boolean isSameDay(final Calendar cal1, final Calendar cal2); public static boolean isSameInstant(final Date date1, final Date date2); public static boolean isSameInstant(final Calendar cal1, final Calendar cal2); public static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2); public static Date parseDate(final String str, final String... parsePatterns) throws ParseException; public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException; private static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException; public static Date addYears(final Date date, final int amount); public static Date addMonths(final Date date, final int amount); public static Date addWeeks(final Date date, final int amount); public static Date addDays(final Date date, final int amount); public static Date addHours(final Date date, final int amount); public static Date addMinutes(final Date date, final int amount); public static Date addSeconds(final Date date, final int amount); public static Date addMilliseconds(final Date date, final int amount); private static Date add(final Date date, final int calendarField, final int amount); public static Date setYears(final Date date, final int amount); public static Date setMonths(final Date date, final int amount); public static Date setDays(final Date date, final int amount); public static Date setHours(final Date date, final int amount); public static Date setMinutes(final Date date, final int amount); public static Date setSeconds(final Date date, final int amount); public static Date setMilliseconds(final Date date, final int amount); private static Date set(final Date date, final int calendarField, final int amount); public static Calendar toCalendar(final Date date); public static Date round(final Date date, final int field); public static Calendar round(final Calendar date, final int field); public static Date round(final Object date, final int field); public static Date truncate(final Date date, final int field); public static Calendar truncate(final Calendar date, final int field); public static Date truncate(final Object date, final int field); public static Date ceiling(final Date date, final int field); public static Calendar ceiling(final Calendar date, final int field); public static Date ceiling(final Object date, final int field); private static void modify(final Calendar val, final int field, final int modType); public static Iterator<Calendar> iterator(final Date focus, final int rangeStyle); public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle); public static Iterator<?> iterator(final Object focus, final int rangeStyle); public static long getFragmentInMilliseconds(final Date date, final int fragment); public static long getFragmentInSeconds(final Date date, final int fragment); public static long getFragmentInMinutes(final Date date, final int fragment); public static long getFragmentInHours(final Date date, final int fragment); public static long getFragmentInDays(final Date date, final int fragment); public static long getFragmentInMilliseconds(final Calendar calendar, final int fragment); public static long getFragmentInSeconds(final Calendar calendar, final int fragment); public static long getFragmentInMinutes(final Calendar calendar, final int fragment); public static long getFragmentInHours(final Calendar calendar, final int fragment); public static long getFragmentInDays(final Calendar calendar, final int fragment); private static long getFragment(final Date date, final int fragment, final int unit); private static long getFragment(final Calendar calendar, final int fragment, final int unit); public static boolean truncatedEquals(final Calendar cal1, final Calendar cal2, final int field); public static boolean truncatedEquals(final Date date1, final Date date2, final int field); public static int truncatedCompareTo(final Calendar cal1, final Calendar cal2, final int field); public static int truncatedCompareTo(final Date date1, final Date date2, final int field); private static long getMillisPerUnit(final int unit); public boolean hasNext(); public Calendar next(); public void remove(); long MILLIS_PER_SECOND=Optional[1000]; long MILLIS_PER_MINUTE=Optional[60 * MILLIS_PER_SECOND]; long MILLIS_PER_HOUR=Optional[60 * MILLIS_PER_MINUTE]; long MILLIS_PER_DAY=Optional[24 * MILLIS_PER_HOUR]; int SEMI_MONTH=Optional[1001]; int[][] fields=Optional[{ { Calendar.MILLISECOND }, { Calendar.SECOND }, { Calendar.MINUTE }, { Calendar.HOUR_OF_DAY, Calendar.HOUR }, { Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM /* Calendar.DAY_OF_YEAR, Calendar.DAY_OF_WEEK, Calendar.DAY_OF_WEEK_IN_MONTH */; }, { Calendar.MONTH, DateUtils.SEMI_MONTH }, { Calendar.YEAR }, { Calendar.ERA } }
public static Date setMinutes(final Date date, final int amount) { [EOL]     return set(date, Calendar.MINUTE, amount); [EOL] } public DateUtils();  DateIterator(final Calendar startFinal, final Calendar endFinal); public static boolean isSameDay(final Date date1, final Date date2); public static boolean isSameDay(final Calendar cal1, final Calendar cal2); public static boolean isSameInstant(final Date date1, final Date date2); public static boolean isSameInstant(final Calendar cal1, final Calendar cal2); public static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2); public static Date parseDate(final String str, final String... parsePatterns) throws ParseException; public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException; private static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException; public static Date addYears(final Date date, final int amount); public static Date addMonths(final Date date, final int amount); public static Date addWeeks(final Date date, final int amount); public static Date addDays(final Date date, final int amount); public static Date addHours(final Date date, final int amount); public static Date addMinutes(final Date date, final int amount); public static Date addSeconds(final Date date, final int amount); public static Date addMilliseconds(final Date date, final int amount); private static Date add(final Date date, final int calendarField, final int amount); public static Date setYears(final Date date, final int amount); public static Date setMonths(final Date date, final int amount); public static Date setDays(final Date date, final int amount); public static Date setHours(final Date date, final int amount); public static Date setMinutes(final Date date, final int amount); public static Date setSeconds(final Date date, final int amount); public static Date setMilliseconds(final Date date, final int amount); private static Date set(final Date date, final int calendarField, final int amount); public static Calendar toCalendar(final Date date); public static Date round(final Date date, final int field); public static Calendar round(final Calendar date, final int field); public static Date round(final Object date, final int field); public static Date truncate(final Date date, final int field); public static Calendar truncate(final Calendar date, final int field); public static Date truncate(final Object date, final int field); public static Date ceiling(final Date date, final int field); public static Calendar ceiling(final Calendar date, final int field); public static Date ceiling(final Object date, final int field); private static void modify(final Calendar val, final int field, final int modType); public static Iterator<Calendar> iterator(final Date focus, final int rangeStyle); public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle); public static Iterator<?> iterator(final Object focus, final int rangeStyle); public static long getFragmentInMilliseconds(final Date date, final int fragment); public static long getFragmentInSeconds(final Date date, final int fragment); public static long getFragmentInMinutes(final Date date, final int fragment); public static long getFragmentInHours(final Date date, final int fragment); public static long getFragmentInDays(final Date date, final int fragment); public static long getFragmentInMilliseconds(final Calendar calendar, final int fragment); public static long getFragmentInSeconds(final Calendar calendar, final int fragment); public static long getFragmentInMinutes(final Calendar calendar, final int fragment); public static long getFragmentInHours(final Calendar calendar, final int fragment); public static long getFragmentInDays(final Calendar calendar, final int fragment); private static long getFragment(final Date date, final int fragment, final int unit); private static long getFragment(final Calendar calendar, final int fragment, final int unit); public static boolean truncatedEquals(final Calendar cal1, final Calendar cal2, final int field); public static boolean truncatedEquals(final Date date1, final Date date2, final int field); public static int truncatedCompareTo(final Calendar cal1, final Calendar cal2, final int field); public static int truncatedCompareTo(final Date date1, final Date date2, final int field); private static long getMillisPerUnit(final int unit); public boolean hasNext(); public Calendar next(); public void remove(); long MILLIS_PER_SECOND=Optional[1000]; long MILLIS_PER_MINUTE=Optional[60 * MILLIS_PER_SECOND]; long MILLIS_PER_HOUR=Optional[60 * MILLIS_PER_MINUTE]; long MILLIS_PER_DAY=Optional[24 * MILLIS_PER_HOUR]; int SEMI_MONTH=Optional[1001]; int[][] fields=Optional[{ { Calendar.MILLISECOND }, { Calendar.SECOND }, { Calendar.MINUTE }, { Calendar.HOUR_OF_DAY, Calendar.HOUR }, { Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM /* Calendar.DAY_OF_YEAR, Calendar.DAY_OF_WEEK, Calendar.DAY_OF_WEEK_IN_MONTH */; }, { Calendar.MONTH, DateUtils.SEMI_MONTH }, { Calendar.YEAR }, { Calendar.ERA } }
private static void modify(final Calendar val, final int field, final int modType) { [EOL]     if (val.get(Calendar.YEAR) > 280000000) { [EOL]         throw new ArithmeticException("Calendar value too large for accurate calculations"); [EOL]     } [EOL]     if (field == Calendar.MILLISECOND) { [EOL]         return; [EOL]     } [EOL]     final Date date = val.getTime(); [EOL]     long time = date.getTime(); [EOL]     boolean done = false; [EOL]     final int millisecs = val.get(Calendar.MILLISECOND); [EOL]     if (MODIFY_TRUNCATE == modType || millisecs < 500) { [EOL]         time = time - millisecs; [EOL]     } [EOL]     if (field == Calendar.SECOND) { [EOL]         done = true; [EOL]     } [EOL]     final int seconds = val.get(Calendar.SECOND); [EOL]     if (!done && (MODIFY_TRUNCATE == modType || seconds < 30)) { [EOL]         time = time - (seconds * 1000L); [EOL]     } [EOL]     if (field == Calendar.MINUTE) { [EOL]         done = true; [EOL]     } [EOL]     final int minutes = val.get(Calendar.MINUTE); [EOL]     if (!done && (MODIFY_TRUNCATE == modType || minutes < 30)) { [EOL]         time = time - (minutes * 60000L); [EOL]     } [EOL]     if (date.getTime() != time) { [EOL]         date.setTime(time); [EOL]         val.setTime(date); [EOL]     } [EOL]     boolean roundUp = false; [EOL]     for (final int[] aField : fields) { [EOL]         for (final int element : aField) { [EOL]             if (element == field) { [EOL]                 if (modType == MODIFY_CEILING || (modType == MODIFY_ROUND && roundUp)) { [EOL]                     if (field == DateUtils.SEMI_MONTH) { [EOL]                         if (val.get(Calendar.DATE) == 1) { [EOL]                             val.add(Calendar.DATE, 15); [EOL]                         } else { [EOL]                             val.add(Calendar.DATE, -15); [EOL]                             val.add(Calendar.MONTH, 1); [EOL]                         } [EOL]                     } else if (field == Calendar.AM_PM) { [EOL]                         if (val.get(Calendar.HOUR_OF_DAY) == 0) { [EOL]                             val.add(Calendar.HOUR_OF_DAY, 12); [EOL]                         } else { [EOL]                             val.add(Calendar.HOUR_OF_DAY, -12); [EOL]                             val.add(Calendar.DATE, 1); [EOL]                         } [EOL]                     } else { [EOL]                         val.add(aField[0], 1); [EOL]                     } [EOL]                 } [EOL]                 return; [EOL]             } [EOL]         } [EOL]         int offset = 0; [EOL]         boolean offsetSet = false; [EOL]         switch(field) { [EOL]             case DateUtils.SEMI_MONTH: [EOL]                 if (aField[0] == Calendar.DATE) { [EOL]                     offset = val.get(Calendar.DATE) - 1; [EOL]                     if (offset >= 15) { [EOL]                         offset -= 15; [EOL]                     } [EOL]                     roundUp = offset > 7; [EOL]                     offsetSet = true; [EOL]                 } [EOL]                 break; [EOL]             case Calendar.AM_PM: [EOL]                 if (aField[0] == Calendar.HOUR_OF_DAY) { [EOL]                     offset = val.get(Calendar.HOUR_OF_DAY); [EOL]                     if (offset >= 12) { [EOL]                         offset -= 12; [EOL]                     } [EOL]                     roundUp = offset >= 6; [EOL]                     offsetSet = true; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         if (!offsetSet) { [EOL]             final int min = val.getActualMinimum(aField[0]); [EOL]             final int max = val.getActualMaximum(aField[0]); [EOL]             offset = val.get(aField[0]) - min; [EOL]             roundUp = offset > ((max - min) / 2); [EOL]         } [EOL]         if (offset != 0) { [EOL]             val.set(aField[0], val.get(aField[0]) - offset); [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("The field " + field + " is not supported"); [EOL] } public DateUtils();  DateIterator(final Calendar startFinal, final Calendar endFinal); public static boolean isSameDay(final Date date1, final Date date2); public static boolean isSameDay(final Calendar cal1, final Calendar cal2); public static boolean isSameInstant(final Date date1, final Date date2); public static boolean isSameInstant(final Calendar cal1, final Calendar cal2); public static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2); public static Date parseDate(final String str, final String... parsePatterns) throws ParseException; public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException; private static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException; public static Date addYears(final Date date, final int amount); public static Date addMonths(final Date date, final int amount); public static Date addWeeks(final Date date, final int amount); public static Date addDays(final Date date, final int amount); public static Date addHours(final Date date, final int amount); public static Date addMinutes(final Date date, final int amount); public static Date addSeconds(final Date date, final int amount); public static Date addMilliseconds(final Date date, final int amount); private static Date add(final Date date, final int calendarField, final int amount); public static Date setYears(final Date date, final int amount); public static Date setMonths(final Date date, final int amount); public static Date setDays(final Date date, final int amount); public static Date setHours(final Date date, final int amount); public static Date setMinutes(final Date date, final int amount); public static Date setSeconds(final Date date, final int amount); public static Date setMilliseconds(final Date date, final int amount); private static Date set(final Date date, final int calendarField, final int amount); public static Calendar toCalendar(final Date date); public static Date round(final Date date, final int field); public static Calendar round(final Calendar date, final int field); public static Date round(final Object date, final int field); public static Date truncate(final Date date, final int field); public static Calendar truncate(final Calendar date, final int field); public static Date truncate(final Object date, final int field); public static Date ceiling(final Date date, final int field); public static Calendar ceiling(final Calendar date, final int field); public static Date ceiling(final Object date, final int field); private static void modify(final Calendar val, final int field, final int modType); public static Iterator<Calendar> iterator(final Date focus, final int rangeStyle); public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle); public static Iterator<?> iterator(final Object focus, final int rangeStyle); public static long getFragmentInMilliseconds(final Date date, final int fragment); public static long getFragmentInSeconds(final Date date, final int fragment); public static long getFragmentInMinutes(final Date date, final int fragment); public static long getFragmentInHours(final Date date, final int fragment); public static long getFragmentInDays(final Date date, final int fragment); public static long getFragmentInMilliseconds(final Calendar calendar, final int fragment); public static long getFragmentInSeconds(final Calendar calendar, final int fragment); public static long getFragmentInMinutes(final Calendar calendar, final int fragment); public static long getFragmentInHours(final Calendar calendar, final int fragment); public static long getFragmentInDays(final Calendar calendar, final int fragment); private static long getFragment(final Date date, final int fragment, final int unit); private static long getFragment(final Calendar calendar, final int fragment, final int unit); public static boolean truncatedEquals(final Calendar cal1, final Calendar cal2, final int field); public static boolean truncatedEquals(final Date date1, final Date date2, final int field); public static int truncatedCompareTo(final Calendar cal1, final Calendar cal2, final int field); public static int truncatedCompareTo(final Date date1, final Date date2, final int field); private static long getMillisPerUnit(final int unit); public boolean hasNext(); public Calendar next(); public void remove(); long MILLIS_PER_SECOND=Optional[1000]; long MILLIS_PER_MINUTE=Optional[60 * MILLIS_PER_SECOND]; long MILLIS_PER_HOUR=Optional[60 * MILLIS_PER_MINUTE]; long MILLIS_PER_DAY=Optional[24 * MILLIS_PER_HOUR]; int SEMI_MONTH=Optional[1001]; int[][] fields=Optional[{ { Calendar.MILLISECOND }, { Calendar.SECOND }, { Calendar.MINUTE }, { Calendar.HOUR_OF_DAY, Calendar.HOUR }, { Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM /* Calendar.DAY_OF_YEAR, Calendar.DAY_OF_WEEK, Calendar.DAY_OF_WEEK_IN_MONTH */; }, { Calendar.MONTH, DateUtils.SEMI_MONTH }, { Calendar.YEAR }, { Calendar.ERA } }
private static long getFragment(final Calendar calendar, final int fragment, final int unit) { [EOL]     if (calendar == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     final long millisPerUnit = getMillisPerUnit(unit); [EOL]     long result = 0; [EOL]     switch(fragment) { [EOL]         case Calendar.YEAR: [EOL]             result += (calendar.get(Calendar.DAY_OF_YEAR) * MILLIS_PER_DAY) / millisPerUnit; [EOL]             break; [EOL]         case Calendar.MONTH: [EOL]             result += (calendar.get(Calendar.DAY_OF_MONTH) * MILLIS_PER_DAY) / millisPerUnit; [EOL]             break; [EOL]     } [EOL]     switch(fragment) { [EOL]         case Calendar.YEAR: [EOL]         case Calendar.MONTH: [EOL]         case Calendar.DAY_OF_YEAR: [EOL]         case Calendar.DATE: [EOL]             result += (calendar.get(Calendar.HOUR_OF_DAY) * MILLIS_PER_HOUR) / millisPerUnit; [EOL]         case Calendar.HOUR_OF_DAY: [EOL]             result += (calendar.get(Calendar.MINUTE) * MILLIS_PER_MINUTE) / millisPerUnit; [EOL]         case Calendar.MINUTE: [EOL]             result += (calendar.get(Calendar.SECOND) * MILLIS_PER_SECOND) / millisPerUnit; [EOL]         case Calendar.SECOND: [EOL]             result += (calendar.get(Calendar.MILLISECOND) * 1) / millisPerUnit; [EOL]             break; [EOL]         case Calendar.MILLISECOND: [EOL]             break; [EOL]         default: [EOL]             throw new IllegalArgumentException("The fragment " + fragment + " is not supported"); [EOL]     } [EOL]     return result; [EOL] } public DateUtils();  DateIterator(final Calendar startFinal, final Calendar endFinal); public static boolean isSameDay(final Date date1, final Date date2); public static boolean isSameDay(final Calendar cal1, final Calendar cal2); public static boolean isSameInstant(final Date date1, final Date date2); public static boolean isSameInstant(final Calendar cal1, final Calendar cal2); public static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2); public static Date parseDate(final String str, final String... parsePatterns) throws ParseException; public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException; private static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException; public static Date addYears(final Date date, final int amount); public static Date addMonths(final Date date, final int amount); public static Date addWeeks(final Date date, final int amount); public static Date addDays(final Date date, final int amount); public static Date addHours(final Date date, final int amount); public static Date addMinutes(final Date date, final int amount); public static Date addSeconds(final Date date, final int amount); public static Date addMilliseconds(final Date date, final int amount); private static Date add(final Date date, final int calendarField, final int amount); public static Date setYears(final Date date, final int amount); public static Date setMonths(final Date date, final int amount); public static Date setDays(final Date date, final int amount); public static Date setHours(final Date date, final int amount); public static Date setMinutes(final Date date, final int amount); public static Date setSeconds(final Date date, final int amount); public static Date setMilliseconds(final Date date, final int amount); private static Date set(final Date date, final int calendarField, final int amount); public static Calendar toCalendar(final Date date); public static Date round(final Date date, final int field); public static Calendar round(final Calendar date, final int field); public static Date round(final Object date, final int field); public static Date truncate(final Date date, final int field); public static Calendar truncate(final Calendar date, final int field); public static Date truncate(final Object date, final int field); public static Date ceiling(final Date date, final int field); public static Calendar ceiling(final Calendar date, final int field); public static Date ceiling(final Object date, final int field); private static void modify(final Calendar val, final int field, final int modType); public static Iterator<Calendar> iterator(final Date focus, final int rangeStyle); public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle); public static Iterator<?> iterator(final Object focus, final int rangeStyle); public static long getFragmentInMilliseconds(final Date date, final int fragment); public static long getFragmentInSeconds(final Date date, final int fragment); public static long getFragmentInMinutes(final Date date, final int fragment); public static long getFragmentInHours(final Date date, final int fragment); public static long getFragmentInDays(final Date date, final int fragment); public static long getFragmentInMilliseconds(final Calendar calendar, final int fragment); public static long getFragmentInSeconds(final Calendar calendar, final int fragment); public static long getFragmentInMinutes(final Calendar calendar, final int fragment); public static long getFragmentInHours(final Calendar calendar, final int fragment); public static long getFragmentInDays(final Calendar calendar, final int fragment); private static long getFragment(final Date date, final int fragment, final int unit); private static long getFragment(final Calendar calendar, final int fragment, final int unit); public static boolean truncatedEquals(final Calendar cal1, final Calendar cal2, final int field); public static boolean truncatedEquals(final Date date1, final Date date2, final int field); public static int truncatedCompareTo(final Calendar cal1, final Calendar cal2, final int field); public static int truncatedCompareTo(final Date date1, final Date date2, final int field); private static long getMillisPerUnit(final int unit); public boolean hasNext(); public Calendar next(); public void remove(); long MILLIS_PER_SECOND=Optional[1000]; long MILLIS_PER_MINUTE=Optional[60 * MILLIS_PER_SECOND]; long MILLIS_PER_HOUR=Optional[60 * MILLIS_PER_MINUTE]; long MILLIS_PER_DAY=Optional[24 * MILLIS_PER_HOUR]; int SEMI_MONTH=Optional[1001]; int[][] fields=Optional[{ { Calendar.MILLISECOND }, { Calendar.SECOND }, { Calendar.MINUTE }, { Calendar.HOUR_OF_DAY, Calendar.HOUR }, { Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM /* Calendar.DAY_OF_YEAR, Calendar.DAY_OF_WEEK, Calendar.DAY_OF_WEEK_IN_MONTH */; }, { Calendar.MONTH, DateUtils.SEMI_MONTH }, { Calendar.YEAR }, { Calendar.ERA } }
public static String uncapitalize(final String str) { [EOL]     return uncapitalize(str, null); [EOL] }
public static String uncapitalize(final String str) { [EOL]     return uncapitalize(str, null); [EOL] }
public static String uncapitalize(final String str) { [EOL]     return uncapitalize(str, null); [EOL] }
public static String uncapitalize(final String str) { [EOL]     return uncapitalize(str, null); [EOL] }
public static String uncapitalize(final String str, final char... delimiters) { [EOL]     final int delimLen = delimiters == null ? -1 : delimiters.length; [EOL]     if (StringUtils.isEmpty(str) || delimLen == 0) { [EOL]         return str; [EOL]     } [EOL]     final char[] buffer = str.toCharArray(); [EOL]     boolean uncapitalizeNext = true; [EOL]     for (int i = 0; i < buffer.length; i++) { [EOL]         final char ch = buffer[i]; [EOL]         if (isDelimiter(ch, delimiters)) { [EOL]             uncapitalizeNext = true; [EOL]         } else if (uncapitalizeNext) { [EOL]             buffer[i] = Character.toLowerCase(ch); [EOL]             uncapitalizeNext = false; [EOL]         } [EOL]     } [EOL]     return new String(buffer); [EOL] }
private static boolean isDelimiter(final char ch, final char[] delimiters) { [EOL]     if (delimiters == null) { [EOL]         return Character.isWhitespace(ch); [EOL]     } [EOL]     for (final char delimiter : delimiters) { [EOL]         if (ch == delimiter) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public MultiBackgroundInitializer(final ExecutorService exec) { [EOL]     super(exec); [EOL] }
public void addInitializer(final String name, final BackgroundInitializer<?> init) { [EOL]     if (name == null) { [EOL]         throw new IllegalArgumentException("Name of child initializer must not be null!"); [EOL]     } [EOL]     if (init == null) { [EOL]         throw new IllegalArgumentException("Child initializer must not be null!"); [EOL]     } [EOL]     synchronized (this) { [EOL]         if (isStarted()) { [EOL]             throw new IllegalStateException("addInitializer() must not be called after start()!"); [EOL]         } [EOL]         childInitializers.put(name, init); [EOL]     } [EOL] }
public void addInitializer(final String name, final BackgroundInitializer<?> init) { [EOL]     if (name == null) { [EOL]         throw new IllegalArgumentException("Name of child initializer must not be null!"); [EOL]     } [EOL]     if (init == null) { [EOL]         throw new IllegalArgumentException("Child initializer must not be null!"); [EOL]     } [EOL]     synchronized (this) { [EOL]         if (isStarted()) { [EOL]             throw new IllegalStateException("addInitializer() must not be called after start()!"); [EOL]         } [EOL]         childInitializers.put(name, init); [EOL]     } [EOL] }
public void addInitializer(final String name, final BackgroundInitializer<?> init) { [EOL]     if (name == null) { [EOL]         throw new IllegalArgumentException("Name of child initializer must not be null!"); [EOL]     } [EOL]     if (init == null) { [EOL]         throw new IllegalArgumentException("Child initializer must not be null!"); [EOL]     } [EOL]     synchronized (this) { [EOL]         if (isStarted()) { [EOL]             throw new IllegalStateException("addInitializer() must not be called after start()!"); [EOL]         } [EOL]         childInitializers.put(name, init); [EOL]     } [EOL] }
public void addInitializer(final String name, final BackgroundInitializer<?> init) { [EOL]     if (name == null) { [EOL]         throw new IllegalArgumentException("Name of child initializer must not be null!"); [EOL]     } [EOL]     if (init == null) { [EOL]         throw new IllegalArgumentException("Child initializer must not be null!"); [EOL]     } [EOL]     synchronized (this) { [EOL]         if (isStarted()) { [EOL]             throw new IllegalStateException("addInitializer() must not be called after start()!"); [EOL]         } [EOL]         childInitializers.put(name, init); [EOL]     } [EOL] }
@Override [EOL] protected int getTaskCount() { [EOL]     int result = 1; [EOL]     for (final BackgroundInitializer<?> bi : childInitializers.values()) { [EOL]         result += bi.getTaskCount(); [EOL]     } [EOL]     return result; [EOL] }
@Override [EOL] protected int getTaskCount() { [EOL]     int result = 1; [EOL]     for (final BackgroundInitializer<?> bi : childInitializers.values()) { [EOL]         result += bi.getTaskCount(); [EOL]     } [EOL]     return result; [EOL] }
@Override [EOL] protected int getTaskCount() { [EOL]     int result = 1; [EOL]     for (final BackgroundInitializer<?> bi : childInitializers.values()) { [EOL]         result += bi.getTaskCount(); [EOL]     } [EOL]     return result; [EOL] }
@Override [EOL] protected MultiBackgroundInitializerResults initialize() throws Exception { [EOL]     Map<String, BackgroundInitializer<?>> inits; [EOL]     synchronized (this) { [EOL]         inits = new HashMap<String, BackgroundInitializer<?>>(childInitializers); [EOL]     } [EOL]     final ExecutorService exec = getActiveExecutor(); [EOL]     for (final BackgroundInitializer<?> bi : inits.values()) { [EOL]         if (bi.getExternalExecutor() == null) { [EOL]             bi.setExternalExecutor(exec); [EOL]         } [EOL]         bi.start(); [EOL]     } [EOL]     final Map<String, Object> results = new HashMap<String, Object>(); [EOL]     final Map<String, ConcurrentException> excepts = new HashMap<String, ConcurrentException>(); [EOL]     for (final Map.Entry<String, BackgroundInitializer<?>> e : inits.entrySet()) { [EOL]         try { [EOL]             results.put(e.getKey(), e.getValue().get()); [EOL]         } catch (final ConcurrentException cex) { [EOL]             excepts.put(e.getKey(), cex); [EOL]         } [EOL]     } [EOL]     return new MultiBackgroundInitializerResults(inits, results, excepts); [EOL] }
@Override [EOL] protected MultiBackgroundInitializerResults initialize() throws Exception { [EOL]     Map<String, BackgroundInitializer<?>> inits; [EOL]     synchronized (this) { [EOL]         inits = new HashMap<String, BackgroundInitializer<?>>(childInitializers); [EOL]     } [EOL]     final ExecutorService exec = getActiveExecutor(); [EOL]     for (final BackgroundInitializer<?> bi : inits.values()) { [EOL]         if (bi.getExternalExecutor() == null) { [EOL]             bi.setExternalExecutor(exec); [EOL]         } [EOL]         bi.start(); [EOL]     } [EOL]     final Map<String, Object> results = new HashMap<String, Object>(); [EOL]     final Map<String, ConcurrentException> excepts = new HashMap<String, ConcurrentException>(); [EOL]     for (final Map.Entry<String, BackgroundInitializer<?>> e : inits.entrySet()) { [EOL]         try { [EOL]             results.put(e.getKey(), e.getValue().get()); [EOL]         } catch (final ConcurrentException cex) { [EOL]             excepts.put(e.getKey(), cex); [EOL]         } [EOL]     } [EOL]     return new MultiBackgroundInitializerResults(inits, results, excepts); [EOL] }
@Override [EOL] protected MultiBackgroundInitializerResults initialize() throws Exception { [EOL]     Map<String, BackgroundInitializer<?>> inits; [EOL]     synchronized (this) { [EOL]         inits = new HashMap<String, BackgroundInitializer<?>>(childInitializers); [EOL]     } [EOL]     final ExecutorService exec = getActiveExecutor(); [EOL]     for (final BackgroundInitializer<?> bi : inits.values()) { [EOL]         if (bi.getExternalExecutor() == null) { [EOL]             bi.setExternalExecutor(exec); [EOL]         } [EOL]         bi.start(); [EOL]     } [EOL]     final Map<String, Object> results = new HashMap<String, Object>(); [EOL]     final Map<String, ConcurrentException> excepts = new HashMap<String, ConcurrentException>(); [EOL]     for (final Map.Entry<String, BackgroundInitializer<?>> e : inits.entrySet()) { [EOL]         try { [EOL]             results.put(e.getKey(), e.getValue().get()); [EOL]         } catch (final ConcurrentException cex) { [EOL]             excepts.put(e.getKey(), cex); [EOL]         } [EOL]     } [EOL]     return new MultiBackgroundInitializerResults(inits, results, excepts); [EOL] }
private MultiBackgroundInitializerResults(final Map<String, BackgroundInitializer<?>> inits, final Map<String, Object> results, final Map<String, ConcurrentException> excepts) { [EOL]     initializers = inits; [EOL]     resultObjects = results; [EOL]     exceptions = excepts; [EOL] }
public BackgroundInitializer<?> getInitializer(final String name) { [EOL]     return checkName(name); [EOL] }
public Object getResultObject(final String name) { [EOL]     checkName(name); [EOL]     return resultObjects.get(name); [EOL] }
public boolean isException(final String name) { [EOL]     checkName(name); [EOL]     return exceptions.containsKey(name); [EOL] }
public boolean isException(final String name) { [EOL]     checkName(name); [EOL]     return exceptions.containsKey(name); [EOL] }
public boolean isException(final String name) { [EOL]     checkName(name); [EOL]     return exceptions.containsKey(name); [EOL] }
public ConcurrentException getException(final String name) { [EOL]     checkName(name); [EOL]     return exceptions.get(name); [EOL] }
public ConcurrentException getException(final String name) { [EOL]     checkName(name); [EOL]     return exceptions.get(name); [EOL] }
public ConcurrentException getException(final String name) { [EOL]     checkName(name); [EOL]     return exceptions.get(name); [EOL] }
public ConcurrentException getException(final String name) { [EOL]     checkName(name); [EOL]     return exceptions.get(name); [EOL] }
public Set<String> initializerNames() { [EOL]     return Collections.unmodifiableSet(initializers.keySet()); [EOL] }
public Set<String> initializerNames() { [EOL]     return Collections.unmodifiableSet(initializers.keySet()); [EOL] }
private BackgroundInitializer<?> checkName(final String name) { [EOL]     final BackgroundInitializer<?> init = initializers.get(name); [EOL]     if (init == null) { [EOL]         throw new NoSuchElementException("No child initializer with name " + name); [EOL]     } [EOL]     return init; [EOL] }
private BackgroundInitializer<?> checkName(final String name) { [EOL]     final BackgroundInitializer<?> init = initializers.get(name); [EOL]     if (init == null) { [EOL]         throw new NoSuchElementException("No child initializer with name " + name); [EOL]     } [EOL]     return init; [EOL] }
public static Locale toLocale(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (str.contains("#")) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len < 2) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final char ch0 = str.charAt(0); [EOL]     if (ch0 == '_') { [EOL]         if (len < 3) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         final char ch1 = str.charAt(1); [EOL]         final char ch2 = str.charAt(2); [EOL]         if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         if (len == 3) { [EOL]             return new Locale("", str.substring(1, 3)); [EOL]         } [EOL]         if (len < 5) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         if (str.charAt(3) != '_') { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         return new Locale("", str.substring(1, 3), str.substring(4)); [EOL]     } [EOL]     final char ch1 = str.charAt(1); [EOL]     if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (len == 2) { [EOL]         return new Locale(str); [EOL]     } [EOL]     if (len < 5) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (str.charAt(2) != '_') { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final char ch3 = str.charAt(3); [EOL]     if (ch3 == '_') { [EOL]         return new Locale(str.substring(0, 2), "", str.substring(4)); [EOL]     } [EOL]     final char ch4 = str.charAt(4); [EOL]     if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (len == 5) { [EOL]         return new Locale(str.substring(0, 2), str.substring(3, 5)); [EOL]     } [EOL]     if (len < 7) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (str.charAt(5) != '_') { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6)); [EOL] }
public static Locale toLocale(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (str.contains("#")) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len < 2) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final char ch0 = str.charAt(0); [EOL]     if (ch0 == '_') { [EOL]         if (len < 3) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         final char ch1 = str.charAt(1); [EOL]         final char ch2 = str.charAt(2); [EOL]         if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         if (len == 3) { [EOL]             return new Locale("", str.substring(1, 3)); [EOL]         } [EOL]         if (len < 5) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         if (str.charAt(3) != '_') { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         return new Locale("", str.substring(1, 3), str.substring(4)); [EOL]     } [EOL]     final char ch1 = str.charAt(1); [EOL]     if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (len == 2) { [EOL]         return new Locale(str); [EOL]     } [EOL]     if (len < 5) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (str.charAt(2) != '_') { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final char ch3 = str.charAt(3); [EOL]     if (ch3 == '_') { [EOL]         return new Locale(str.substring(0, 2), "", str.substring(4)); [EOL]     } [EOL]     final char ch4 = str.charAt(4); [EOL]     if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (len == 5) { [EOL]         return new Locale(str.substring(0, 2), str.substring(3, 5)); [EOL]     } [EOL]     if (len < 7) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (str.charAt(5) != '_') { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6)); [EOL] }
public static Locale toLocale(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (str.contains("#")) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len < 2) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final char ch0 = str.charAt(0); [EOL]     if (ch0 == '_') { [EOL]         if (len < 3) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         final char ch1 = str.charAt(1); [EOL]         final char ch2 = str.charAt(2); [EOL]         if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         if (len == 3) { [EOL]             return new Locale("", str.substring(1, 3)); [EOL]         } [EOL]         if (len < 5) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         if (str.charAt(3) != '_') { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         return new Locale("", str.substring(1, 3), str.substring(4)); [EOL]     } [EOL]     final char ch1 = str.charAt(1); [EOL]     if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (len == 2) { [EOL]         return new Locale(str); [EOL]     } [EOL]     if (len < 5) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (str.charAt(2) != '_') { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final char ch3 = str.charAt(3); [EOL]     if (ch3 == '_') { [EOL]         return new Locale(str.substring(0, 2), "", str.substring(4)); [EOL]     } [EOL]     final char ch4 = str.charAt(4); [EOL]     if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (len == 5) { [EOL]         return new Locale(str.substring(0, 2), str.substring(3, 5)); [EOL]     } [EOL]     if (len < 7) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (str.charAt(5) != '_') { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6)); [EOL] }
public static Locale toLocale(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (str.contains("#")) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len < 2) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final char ch0 = str.charAt(0); [EOL]     if (ch0 == '_') { [EOL]         if (len < 3) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         final char ch1 = str.charAt(1); [EOL]         final char ch2 = str.charAt(2); [EOL]         if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         if (len == 3) { [EOL]             return new Locale("", str.substring(1, 3)); [EOL]         } [EOL]         if (len < 5) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         if (str.charAt(3) != '_') { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         return new Locale("", str.substring(1, 3), str.substring(4)); [EOL]     } [EOL]     final char ch1 = str.charAt(1); [EOL]     if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (len == 2) { [EOL]         return new Locale(str); [EOL]     } [EOL]     if (len < 5) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (str.charAt(2) != '_') { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final char ch3 = str.charAt(3); [EOL]     if (ch3 == '_') { [EOL]         return new Locale(str.substring(0, 2), "", str.substring(4)); [EOL]     } [EOL]     final char ch4 = str.charAt(4); [EOL]     if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (len == 5) { [EOL]         return new Locale(str.substring(0, 2), str.substring(3, 5)); [EOL]     } [EOL]     if (len < 7) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (str.charAt(5) != '_') { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6)); [EOL] }
public static Locale toLocale(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (str.contains("#")) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len < 2) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final char ch0 = str.charAt(0); [EOL]     if (ch0 == '_') { [EOL]         if (len < 3) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         final char ch1 = str.charAt(1); [EOL]         final char ch2 = str.charAt(2); [EOL]         if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         if (len == 3) { [EOL]             return new Locale("", str.substring(1, 3)); [EOL]         } [EOL]         if (len < 5) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         if (str.charAt(3) != '_') { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         return new Locale("", str.substring(1, 3), str.substring(4)); [EOL]     } [EOL]     final char ch1 = str.charAt(1); [EOL]     if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (len == 2) { [EOL]         return new Locale(str); [EOL]     } [EOL]     if (len < 5) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (str.charAt(2) != '_') { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final char ch3 = str.charAt(3); [EOL]     if (ch3 == '_') { [EOL]         return new Locale(str.substring(0, 2), "", str.substring(4)); [EOL]     } [EOL]     final char ch4 = str.charAt(4); [EOL]     if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (len == 5) { [EOL]         return new Locale(str.substring(0, 2), str.substring(3, 5)); [EOL]     } [EOL]     if (len < 7) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (str.charAt(5) != '_') { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6)); [EOL] }
public static Locale toLocale(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (str.contains("#")) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len < 2) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final char ch0 = str.charAt(0); [EOL]     if (ch0 == '_') { [EOL]         if (len < 3) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         final char ch1 = str.charAt(1); [EOL]         final char ch2 = str.charAt(2); [EOL]         if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         if (len == 3) { [EOL]             return new Locale("", str.substring(1, 3)); [EOL]         } [EOL]         if (len < 5) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         if (str.charAt(3) != '_') { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         return new Locale("", str.substring(1, 3), str.substring(4)); [EOL]     } [EOL]     final char ch1 = str.charAt(1); [EOL]     if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (len == 2) { [EOL]         return new Locale(str); [EOL]     } [EOL]     if (len < 5) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (str.charAt(2) != '_') { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final char ch3 = str.charAt(3); [EOL]     if (ch3 == '_') { [EOL]         return new Locale(str.substring(0, 2), "", str.substring(4)); [EOL]     } [EOL]     final char ch4 = str.charAt(4); [EOL]     if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (len == 5) { [EOL]         return new Locale(str.substring(0, 2), str.substring(3, 5)); [EOL]     } [EOL]     if (len < 7) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (str.charAt(5) != '_') { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6)); [EOL] }
public static Locale toLocale(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (str.contains("#")) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len < 2) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final char ch0 = str.charAt(0); [EOL]     if (ch0 == '_') { [EOL]         if (len < 3) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         final char ch1 = str.charAt(1); [EOL]         final char ch2 = str.charAt(2); [EOL]         if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         if (len == 3) { [EOL]             return new Locale("", str.substring(1, 3)); [EOL]         } [EOL]         if (len < 5) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         if (str.charAt(3) != '_') { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         return new Locale("", str.substring(1, 3), str.substring(4)); [EOL]     } [EOL]     final char ch1 = str.charAt(1); [EOL]     if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (len == 2) { [EOL]         return new Locale(str); [EOL]     } [EOL]     if (len < 5) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (str.charAt(2) != '_') { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final char ch3 = str.charAt(3); [EOL]     if (ch3 == '_') { [EOL]         return new Locale(str.substring(0, 2), "", str.substring(4)); [EOL]     } [EOL]     final char ch4 = str.charAt(4); [EOL]     if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (len == 5) { [EOL]         return new Locale(str.substring(0, 2), str.substring(3, 5)); [EOL]     } [EOL]     if (len < 7) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (str.charAt(5) != '_') { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6)); [EOL] }
public static Locale toLocale(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (str.contains("#")) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len < 2) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final char ch0 = str.charAt(0); [EOL]     if (ch0 == '_') { [EOL]         if (len < 3) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         final char ch1 = str.charAt(1); [EOL]         final char ch2 = str.charAt(2); [EOL]         if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         if (len == 3) { [EOL]             return new Locale("", str.substring(1, 3)); [EOL]         } [EOL]         if (len < 5) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         if (str.charAt(3) != '_') { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         return new Locale("", str.substring(1, 3), str.substring(4)); [EOL]     } [EOL]     final char ch1 = str.charAt(1); [EOL]     if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (len == 2) { [EOL]         return new Locale(str); [EOL]     } [EOL]     if (len < 5) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (str.charAt(2) != '_') { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final char ch3 = str.charAt(3); [EOL]     if (ch3 == '_') { [EOL]         return new Locale(str.substring(0, 2), "", str.substring(4)); [EOL]     } [EOL]     final char ch4 = str.charAt(4); [EOL]     if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (len == 5) { [EOL]         return new Locale(str.substring(0, 2), str.substring(3, 5)); [EOL]     } [EOL]     if (len < 7) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (str.charAt(5) != '_') { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6)); [EOL] }
public static Locale toLocale(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (str.contains("#")) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len < 2) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final char ch0 = str.charAt(0); [EOL]     if (ch0 == '_') { [EOL]         if (len < 3) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         final char ch1 = str.charAt(1); [EOL]         final char ch2 = str.charAt(2); [EOL]         if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         if (len == 3) { [EOL]             return new Locale("", str.substring(1, 3)); [EOL]         } [EOL]         if (len < 5) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         if (str.charAt(3) != '_') { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         return new Locale("", str.substring(1, 3), str.substring(4)); [EOL]     } [EOL]     final char ch1 = str.charAt(1); [EOL]     if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (len == 2) { [EOL]         return new Locale(str); [EOL]     } [EOL]     if (len < 5) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (str.charAt(2) != '_') { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final char ch3 = str.charAt(3); [EOL]     if (ch3 == '_') { [EOL]         return new Locale(str.substring(0, 2), "", str.substring(4)); [EOL]     } [EOL]     final char ch4 = str.charAt(4); [EOL]     if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (len == 5) { [EOL]         return new Locale(str.substring(0, 2), str.substring(3, 5)); [EOL]     } [EOL]     if (len < 7) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (str.charAt(5) != '_') { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6)); [EOL] }
public static Locale toLocale(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (str.contains("#")) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len < 2) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final char ch0 = str.charAt(0); [EOL]     if (ch0 == '_') { [EOL]         if (len < 3) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         final char ch1 = str.charAt(1); [EOL]         final char ch2 = str.charAt(2); [EOL]         if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         if (len == 3) { [EOL]             return new Locale("", str.substring(1, 3)); [EOL]         } [EOL]         if (len < 5) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         if (str.charAt(3) != '_') { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         return new Locale("", str.substring(1, 3), str.substring(4)); [EOL]     } [EOL]     final char ch1 = str.charAt(1); [EOL]     if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (len == 2) { [EOL]         return new Locale(str); [EOL]     } [EOL]     if (len < 5) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (str.charAt(2) != '_') { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final char ch3 = str.charAt(3); [EOL]     if (ch3 == '_') { [EOL]         return new Locale(str.substring(0, 2), "", str.substring(4)); [EOL]     } [EOL]     final char ch4 = str.charAt(4); [EOL]     if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (len == 5) { [EOL]         return new Locale(str.substring(0, 2), str.substring(3, 5)); [EOL]     } [EOL]     if (len < 7) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (str.charAt(5) != '_') { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6)); [EOL] }
public static Locale toLocale(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (str.contains("#")) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len < 2) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final char ch0 = str.charAt(0); [EOL]     if (ch0 == '_') { [EOL]         if (len < 3) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         final char ch1 = str.charAt(1); [EOL]         final char ch2 = str.charAt(2); [EOL]         if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         if (len == 3) { [EOL]             return new Locale("", str.substring(1, 3)); [EOL]         } [EOL]         if (len < 5) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         if (str.charAt(3) != '_') { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         return new Locale("", str.substring(1, 3), str.substring(4)); [EOL]     } [EOL]     final char ch1 = str.charAt(1); [EOL]     if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (len == 2) { [EOL]         return new Locale(str); [EOL]     } [EOL]     if (len < 5) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (str.charAt(2) != '_') { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final char ch3 = str.charAt(3); [EOL]     if (ch3 == '_') { [EOL]         return new Locale(str.substring(0, 2), "", str.substring(4)); [EOL]     } [EOL]     final char ch4 = str.charAt(4); [EOL]     if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (len == 5) { [EOL]         return new Locale(str.substring(0, 2), str.substring(3, 5)); [EOL]     } [EOL]     if (len < 7) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (str.charAt(5) != '_') { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6)); [EOL] }
public static Locale toLocale(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (str.contains("#")) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len < 2) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final char ch0 = str.charAt(0); [EOL]     if (ch0 == '_') { [EOL]         if (len < 3) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         final char ch1 = str.charAt(1); [EOL]         final char ch2 = str.charAt(2); [EOL]         if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         if (len == 3) { [EOL]             return new Locale("", str.substring(1, 3)); [EOL]         } [EOL]         if (len < 5) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         if (str.charAt(3) != '_') { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         return new Locale("", str.substring(1, 3), str.substring(4)); [EOL]     } [EOL]     final char ch1 = str.charAt(1); [EOL]     if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (len == 2) { [EOL]         return new Locale(str); [EOL]     } [EOL]     if (len < 5) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (str.charAt(2) != '_') { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final char ch3 = str.charAt(3); [EOL]     if (ch3 == '_') { [EOL]         return new Locale(str.substring(0, 2), "", str.substring(4)); [EOL]     } [EOL]     final char ch4 = str.charAt(4); [EOL]     if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (len == 5) { [EOL]         return new Locale(str.substring(0, 2), str.substring(3, 5)); [EOL]     } [EOL]     if (len < 7) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     if (str.charAt(5) != '_') { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6)); [EOL] }
public static Set<Locale> availableLocaleSet() { [EOL]     return SyncAvoid.AVAILABLE_LOCALE_SET; [EOL] }
public static boolean isAvailableLocale(final Locale locale) { [EOL]     return availableLocaleList().contains(locale); [EOL] }
public static <T> T[] clone(final T[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     return array.clone(); [EOL] }
public static <T> T[] clone(final T[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     return array.clone(); [EOL] }
public static boolean[] clone(final boolean[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     return array.clone(); [EOL] }
public static boolean[] clone(final boolean[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     return array.clone(); [EOL] }
public static boolean[] clone(final boolean[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     return array.clone(); [EOL] }
public static String[] nullToEmpty(final String[] array) { [EOL]     if (array == null || array.length == 0) { [EOL]         return EMPTY_STRING_ARRAY; [EOL]     } [EOL]     return array; [EOL] }
public static String[] nullToEmpty(final String[] array) { [EOL]     if (array == null || array.length == 0) { [EOL]         return EMPTY_STRING_ARRAY; [EOL]     } [EOL]     return array; [EOL] }
public static String[] nullToEmpty(final String[] array) { [EOL]     if (array == null || array.length == 0) { [EOL]         return EMPTY_STRING_ARRAY; [EOL]     } [EOL]     return array; [EOL] }
public static byte[] nullToEmpty(final byte[] array) { [EOL]     if (array == null || array.length == 0) { [EOL]         return EMPTY_BYTE_ARRAY; [EOL]     } [EOL]     return array; [EOL] }
public static byte[] nullToEmpty(final byte[] array) { [EOL]     if (array == null || array.length == 0) { [EOL]         return EMPTY_BYTE_ARRAY; [EOL]     } [EOL]     return array; [EOL] }
public static byte[] nullToEmpty(final byte[] array) { [EOL]     if (array == null || array.length == 0) { [EOL]         return EMPTY_BYTE_ARRAY; [EOL]     } [EOL]     return array; [EOL] }
public static Integer[] nullToEmpty(final Integer[] array) { [EOL]     if (array == null || array.length == 0) { [EOL]         return EMPTY_INTEGER_OBJECT_ARRAY; [EOL]     } [EOL]     return array; [EOL] }
public static Integer[] nullToEmpty(final Integer[] array) { [EOL]     if (array == null || array.length == 0) { [EOL]         return EMPTY_INTEGER_OBJECT_ARRAY; [EOL]     } [EOL]     return array; [EOL] }
public static Integer[] nullToEmpty(final Integer[] array) { [EOL]     if (array == null || array.length == 0) { [EOL]         return EMPTY_INTEGER_OBJECT_ARRAY; [EOL]     } [EOL]     return array; [EOL] }
public static int[] subarray(final int[] array, int startIndexInclusive, int endIndexExclusive) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     if (startIndexInclusive < 0) { [EOL]         startIndexInclusive = 0; [EOL]     } [EOL]     if (endIndexExclusive > array.length) { [EOL]         endIndexExclusive = array.length; [EOL]     } [EOL]     final int newSize = endIndexExclusive - startIndexInclusive; [EOL]     if (newSize <= 0) { [EOL]         return EMPTY_INT_ARRAY; [EOL]     } [EOL]     final int[] subarray = new int[newSize]; [EOL]     System.arraycopy(array, startIndexInclusive, subarray, 0, newSize); [EOL]     return subarray; [EOL] }
public static int[] subarray(final int[] array, int startIndexInclusive, int endIndexExclusive) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     if (startIndexInclusive < 0) { [EOL]         startIndexInclusive = 0; [EOL]     } [EOL]     if (endIndexExclusive > array.length) { [EOL]         endIndexExclusive = array.length; [EOL]     } [EOL]     final int newSize = endIndexExclusive - startIndexInclusive; [EOL]     if (newSize <= 0) { [EOL]         return EMPTY_INT_ARRAY; [EOL]     } [EOL]     final int[] subarray = new int[newSize]; [EOL]     System.arraycopy(array, startIndexInclusive, subarray, 0, newSize); [EOL]     return subarray; [EOL] }
public static boolean isSameLength(final int[] array1, final int[] array2) { [EOL]     if ((array1 == null && array2 != null && array2.length > 0) || (array2 == null && array1 != null && array1.length > 0) || (array1 != null && array2 != null && array1.length != array2.length)) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
public static boolean isSameLength(final int[] array1, final int[] array2) { [EOL]     if ((array1 == null && array2 != null && array2.length > 0) || (array2 == null && array1 != null && array1.length > 0) || (array1 != null && array2 != null && array1.length != array2.length)) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
public static boolean isSameLength(final char[] array1, final char[] array2) { [EOL]     if ((array1 == null && array2 != null && array2.length > 0) || (array2 == null && array1 != null && array1.length > 0) || (array1 != null && array2 != null && array1.length != array2.length)) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
public static int indexOf(final Object[] array, final Object objectToFind, int startIndex) { [EOL]     if (array == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     if (objectToFind == null) { [EOL]         for (int i = startIndex; i < array.length; i++) { [EOL]             if (array[i] == null) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]     } else if (array.getClass().getComponentType().isInstance(objectToFind)) { [EOL]         for (int i = startIndex; i < array.length; i++) { [EOL]             if (objectToFind.equals(array[i])) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int indexOf(final Object[] array, final Object objectToFind, int startIndex) { [EOL]     if (array == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     if (objectToFind == null) { [EOL]         for (int i = startIndex; i < array.length; i++) { [EOL]             if (array[i] == null) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]     } else if (array.getClass().getComponentType().isInstance(objectToFind)) { [EOL]         for (int i = startIndex; i < array.length; i++) { [EOL]             if (objectToFind.equals(array[i])) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int indexOf(final Object[] array, final Object objectToFind, int startIndex) { [EOL]     if (array == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     if (objectToFind == null) { [EOL]         for (int i = startIndex; i < array.length; i++) { [EOL]             if (array[i] == null) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]     } else if (array.getClass().getComponentType().isInstance(objectToFind)) { [EOL]         for (int i = startIndex; i < array.length; i++) { [EOL]             if (objectToFind.equals(array[i])) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int indexOf(final Object[] array, final Object objectToFind, int startIndex) { [EOL]     if (array == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     if (objectToFind == null) { [EOL]         for (int i = startIndex; i < array.length; i++) { [EOL]             if (array[i] == null) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]     } else if (array.getClass().getComponentType().isInstance(objectToFind)) { [EOL]         for (int i = startIndex; i < array.length; i++) { [EOL]             if (objectToFind.equals(array[i])) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int indexOf(final Object[] array, final Object objectToFind, int startIndex) { [EOL]     if (array == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     if (objectToFind == null) { [EOL]         for (int i = startIndex; i < array.length; i++) { [EOL]             if (array[i] == null) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]     } else if (array.getClass().getComponentType().isInstance(objectToFind)) { [EOL]         for (int i = startIndex; i < array.length; i++) { [EOL]             if (objectToFind.equals(array[i])) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int indexOf(final Object[] array, final Object objectToFind, int startIndex) { [EOL]     if (array == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     if (objectToFind == null) { [EOL]         for (int i = startIndex; i < array.length; i++) { [EOL]             if (array[i] == null) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]     } else if (array.getClass().getComponentType().isInstance(objectToFind)) { [EOL]         for (int i = startIndex; i < array.length; i++) { [EOL]             if (objectToFind.equals(array[i])) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int lastIndexOf(final Object[] array, final Object objectToFind) { [EOL]     return lastIndexOf(array, objectToFind, Integer.MAX_VALUE); [EOL] }
public static int lastIndexOf(final Object[] array, final Object objectToFind) { [EOL]     return lastIndexOf(array, objectToFind, Integer.MAX_VALUE); [EOL] }
public static int lastIndexOf(final Object[] array, final Object objectToFind) { [EOL]     return lastIndexOf(array, objectToFind, Integer.MAX_VALUE); [EOL] }
public static int lastIndexOf(final Object[] array, final Object objectToFind) { [EOL]     return lastIndexOf(array, objectToFind, Integer.MAX_VALUE); [EOL] }
public static int lastIndexOf(final Object[] array, final Object objectToFind) { [EOL]     return lastIndexOf(array, objectToFind, Integer.MAX_VALUE); [EOL] }
public static int lastIndexOf(final Object[] array, final Object objectToFind, int startIndex) { [EOL]     if (array == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     if (objectToFind == null) { [EOL]         for (int i = startIndex; i >= 0; i--) { [EOL]             if (array[i] == null) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]     } else if (array.getClass().getComponentType().isInstance(objectToFind)) { [EOL]         for (int i = startIndex; i >= 0; i--) { [EOL]             if (objectToFind.equals(array[i])) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int lastIndexOf(final Object[] array, final Object objectToFind, int startIndex) { [EOL]     if (array == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     if (objectToFind == null) { [EOL]         for (int i = startIndex; i >= 0; i--) { [EOL]             if (array[i] == null) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]     } else if (array.getClass().getComponentType().isInstance(objectToFind)) { [EOL]         for (int i = startIndex; i >= 0; i--) { [EOL]             if (objectToFind.equals(array[i])) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static boolean contains(final Object[] array, final Object objectToFind) { [EOL]     return indexOf(array, objectToFind) != INDEX_NOT_FOUND; [EOL] }
public static int indexOf(final long[] array, final long valueToFind, int startIndex) { [EOL]     if (array == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     for (int i = startIndex; i < array.length; i++) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int indexOf(final long[] array, final long valueToFind, int startIndex) { [EOL]     if (array == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     for (int i = startIndex; i < array.length; i++) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int indexOf(final long[] array, final long valueToFind, int startIndex) { [EOL]     if (array == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     for (int i = startIndex; i < array.length; i++) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int indexOf(final long[] array, final long valueToFind, int startIndex) { [EOL]     if (array == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     for (int i = startIndex; i < array.length; i++) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int indexOf(final long[] array, final long valueToFind, int startIndex) { [EOL]     if (array == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     for (int i = startIndex; i < array.length; i++) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int indexOf(final long[] array, final long valueToFind, int startIndex) { [EOL]     if (array == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     for (int i = startIndex; i < array.length; i++) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int lastIndexOf(final long[] array, final long valueToFind) { [EOL]     return lastIndexOf(array, valueToFind, Integer.MAX_VALUE); [EOL] }
public static int lastIndexOf(final long[] array, final long valueToFind) { [EOL]     return lastIndexOf(array, valueToFind, Integer.MAX_VALUE); [EOL] }
public static int lastIndexOf(final long[] array, final long valueToFind) { [EOL]     return lastIndexOf(array, valueToFind, Integer.MAX_VALUE); [EOL] }
public static int lastIndexOf(final long[] array, final long valueToFind) { [EOL]     return lastIndexOf(array, valueToFind, Integer.MAX_VALUE); [EOL] }
public static int lastIndexOf(final int[] array, final int valueToFind) { [EOL]     return lastIndexOf(array, valueToFind, Integer.MAX_VALUE); [EOL] }
public static int lastIndexOf(final int[] array, final int valueToFind) { [EOL]     return lastIndexOf(array, valueToFind, Integer.MAX_VALUE); [EOL] }
public static int lastIndexOf(final int[] array, final int valueToFind) { [EOL]     return lastIndexOf(array, valueToFind, Integer.MAX_VALUE); [EOL] }
public static int lastIndexOf(final int[] array, final int valueToFind) { [EOL]     return lastIndexOf(array, valueToFind, Integer.MAX_VALUE); [EOL] }
public static int lastIndexOf(final int[] array, final int valueToFind) { [EOL]     return lastIndexOf(array, valueToFind, Integer.MAX_VALUE); [EOL] }
public static int lastIndexOf(final int[] array, final int valueToFind, int startIndex) { [EOL]     if (array == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int lastIndexOf(final int[] array, final int valueToFind, int startIndex) { [EOL]     if (array == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int lastIndexOf(final int[] array, final int valueToFind, int startIndex) { [EOL]     if (array == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int lastIndexOf(final int[] array, final int valueToFind, int startIndex) { [EOL]     if (array == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int lastIndexOf(final int[] array, final int valueToFind, int startIndex) { [EOL]     if (array == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static boolean contains(final byte[] array, final byte valueToFind) { [EOL]     return indexOf(array, valueToFind) != INDEX_NOT_FOUND; [EOL] }
public static boolean contains(final byte[] array, final byte valueToFind) { [EOL]     return indexOf(array, valueToFind) != INDEX_NOT_FOUND; [EOL] }
public static boolean contains(final byte[] array, final byte valueToFind) { [EOL]     return indexOf(array, valueToFind) != INDEX_NOT_FOUND; [EOL] }
public static boolean contains(final byte[] array, final byte valueToFind) { [EOL]     return indexOf(array, valueToFind) != INDEX_NOT_FOUND; [EOL] }
public static boolean contains(final double[] array, final double valueToFind) { [EOL]     return indexOf(array, valueToFind) != INDEX_NOT_FOUND; [EOL] }
public static boolean contains(final double[] array, final double valueToFind) { [EOL]     return indexOf(array, valueToFind) != INDEX_NOT_FOUND; [EOL] }
public static boolean contains(final double[] array, final double valueToFind) { [EOL]     return indexOf(array, valueToFind) != INDEX_NOT_FOUND; [EOL] }
public static boolean contains(final double[] array, final double valueToFind, final double tolerance) { [EOL]     return indexOf(array, valueToFind, 0, tolerance) != INDEX_NOT_FOUND; [EOL] }
public static boolean contains(final double[] array, final double valueToFind, final double tolerance) { [EOL]     return indexOf(array, valueToFind, 0, tolerance) != INDEX_NOT_FOUND; [EOL] }
public static boolean contains(final double[] array, final double valueToFind, final double tolerance) { [EOL]     return indexOf(array, valueToFind, 0, tolerance) != INDEX_NOT_FOUND; [EOL] }
public static boolean contains(final double[] array, final double valueToFind, final double tolerance) { [EOL]     return indexOf(array, valueToFind, 0, tolerance) != INDEX_NOT_FOUND; [EOL] }
public static int lastIndexOf(final float[] array, final float valueToFind) { [EOL]     return lastIndexOf(array, valueToFind, Integer.MAX_VALUE); [EOL] }
public static int lastIndexOf(final float[] array, final float valueToFind) { [EOL]     return lastIndexOf(array, valueToFind, Integer.MAX_VALUE); [EOL] }
public static int lastIndexOf(final float[] array, final float valueToFind) { [EOL]     return lastIndexOf(array, valueToFind, Integer.MAX_VALUE); [EOL] }
public static int lastIndexOf(final float[] array, final float valueToFind) { [EOL]     return lastIndexOf(array, valueToFind, Integer.MAX_VALUE); [EOL] }
public static int lastIndexOf(final float[] array, final float valueToFind) { [EOL]     return lastIndexOf(array, valueToFind, Integer.MAX_VALUE); [EOL] }
public static int lastIndexOf(final float[] array, final float valueToFind) { [EOL]     return lastIndexOf(array, valueToFind, Integer.MAX_VALUE); [EOL] }
public static int lastIndexOf(final float[] array, final float valueToFind) { [EOL]     return lastIndexOf(array, valueToFind, Integer.MAX_VALUE); [EOL] }
public static int lastIndexOf(final float[] array, final float valueToFind) { [EOL]     return lastIndexOf(array, valueToFind, Integer.MAX_VALUE); [EOL] }
public static int lastIndexOf(final float[] array, final float valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int lastIndexOf(final float[] array, final float valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int lastIndexOf(final float[] array, final float valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int lastIndexOf(final float[] array, final float valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int lastIndexOf(final float[] array, final float valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static boolean contains(final float[] array, final float valueToFind) { [EOL]     return indexOf(array, valueToFind) != INDEX_NOT_FOUND; [EOL] }
public static boolean contains(final float[] array, final float valueToFind) { [EOL]     return indexOf(array, valueToFind) != INDEX_NOT_FOUND; [EOL] }
public static boolean contains(final float[] array, final float valueToFind) { [EOL]     return indexOf(array, valueToFind) != INDEX_NOT_FOUND; [EOL] }
public static boolean contains(final float[] array, final float valueToFind) { [EOL]     return indexOf(array, valueToFind) != INDEX_NOT_FOUND; [EOL] }
public static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     for (int i = startIndex; i < array.length; i++) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     for (int i = startIndex; i < array.length; i++) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     for (int i = startIndex; i < array.length; i++) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     for (int i = startIndex; i < array.length; i++) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     for (int i = startIndex; i < array.length; i++) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     for (int i = startIndex; i < array.length; i++) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static char[] toPrimitive(final Character[] array, final char valueForNull) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_CHAR_ARRAY; [EOL]     } [EOL]     final char[] result = new char[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         final Character b = array[i]; [EOL]         result[i] = (b == null ? valueForNull : b.charValue()); [EOL]     } [EOL]     return result; [EOL] }
public static char[] toPrimitive(final Character[] array, final char valueForNull) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_CHAR_ARRAY; [EOL]     } [EOL]     final char[] result = new char[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         final Character b = array[i]; [EOL]         result[i] = (b == null ? valueForNull : b.charValue()); [EOL]     } [EOL]     return result; [EOL] }
public static char[] toPrimitive(final Character[] array, final char valueForNull) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_CHAR_ARRAY; [EOL]     } [EOL]     final char[] result = new char[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         final Character b = array[i]; [EOL]         result[i] = (b == null ? valueForNull : b.charValue()); [EOL]     } [EOL]     return result; [EOL] }
public static char[] toPrimitive(final Character[] array, final char valueForNull) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_CHAR_ARRAY; [EOL]     } [EOL]     final char[] result = new char[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         final Character b = array[i]; [EOL]         result[i] = (b == null ? valueForNull : b.charValue()); [EOL]     } [EOL]     return result; [EOL] }
public static char[] toPrimitive(final Character[] array, final char valueForNull) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_CHAR_ARRAY; [EOL]     } [EOL]     final char[] result = new char[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         final Character b = array[i]; [EOL]         result[i] = (b == null ? valueForNull : b.charValue()); [EOL]     } [EOL]     return result; [EOL] }
public static int[] toPrimitive(final Integer[] array, final int valueForNull) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_INT_ARRAY; [EOL]     } [EOL]     final int[] result = new int[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         final Integer b = array[i]; [EOL]         result[i] = (b == null ? valueForNull : b.intValue()); [EOL]     } [EOL]     return result; [EOL] }
public static int[] toPrimitive(final Integer[] array, final int valueForNull) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_INT_ARRAY; [EOL]     } [EOL]     final int[] result = new int[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         final Integer b = array[i]; [EOL]         result[i] = (b == null ? valueForNull : b.intValue()); [EOL]     } [EOL]     return result; [EOL] }
public static int[] toPrimitive(final Integer[] array, final int valueForNull) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_INT_ARRAY; [EOL]     } [EOL]     final int[] result = new int[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         final Integer b = array[i]; [EOL]         result[i] = (b == null ? valueForNull : b.intValue()); [EOL]     } [EOL]     return result; [EOL] }
public static int[] toPrimitive(final Integer[] array, final int valueForNull) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_INT_ARRAY; [EOL]     } [EOL]     final int[] result = new int[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         final Integer b = array[i]; [EOL]         result[i] = (b == null ? valueForNull : b.intValue()); [EOL]     } [EOL]     return result; [EOL] }
public static int[] toPrimitive(final Integer[] array, final int valueForNull) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_INT_ARRAY; [EOL]     } [EOL]     final int[] result = new int[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         final Integer b = array[i]; [EOL]         result[i] = (b == null ? valueForNull : b.intValue()); [EOL]     } [EOL]     return result; [EOL] }
public static boolean[] toPrimitive(final Boolean[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_BOOLEAN_ARRAY; [EOL]     } [EOL]     final boolean[] result = new boolean[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         result[i] = array[i].booleanValue(); [EOL]     } [EOL]     return result; [EOL] }
public static boolean[] toPrimitive(final Boolean[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_BOOLEAN_ARRAY; [EOL]     } [EOL]     final boolean[] result = new boolean[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         result[i] = array[i].booleanValue(); [EOL]     } [EOL]     return result; [EOL] }
public static boolean[] toPrimitive(final Boolean[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_BOOLEAN_ARRAY; [EOL]     } [EOL]     final boolean[] result = new boolean[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         result[i] = array[i].booleanValue(); [EOL]     } [EOL]     return result; [EOL] }
public static <T> T[] add(final T[] array, final T element) { [EOL]     Class<?> type; [EOL]     if (array != null) { [EOL]         type = array.getClass(); [EOL]     } else if (element != null) { [EOL]         type = element.getClass(); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Arguments cannot both be null"); [EOL]     } [EOL]     @SuppressWarnings("unchecked") [EOL]     final T[] newArray = (T[]) copyArrayGrow1(array, type); [EOL]     newArray[newArray.length - 1] = element; [EOL]     return newArray; [EOL] }
public static <T> T[] add(final T[] array, final T element) { [EOL]     Class<?> type; [EOL]     if (array != null) { [EOL]         type = array.getClass(); [EOL]     } else if (element != null) { [EOL]         type = element.getClass(); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Arguments cannot both be null"); [EOL]     } [EOL]     @SuppressWarnings("unchecked") [EOL]     final T[] newArray = (T[]) copyArrayGrow1(array, type); [EOL]     newArray[newArray.length - 1] = element; [EOL]     return newArray; [EOL] }
public static <T> T[] add(final T[] array, final T element) { [EOL]     Class<?> type; [EOL]     if (array != null) { [EOL]         type = array.getClass(); [EOL]     } else if (element != null) { [EOL]         type = element.getClass(); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Arguments cannot both be null"); [EOL]     } [EOL]     @SuppressWarnings("unchecked") [EOL]     final T[] newArray = (T[]) copyArrayGrow1(array, type); [EOL]     newArray[newArray.length - 1] = element; [EOL]     return newArray; [EOL] }
public static <T> T[] add(final T[] array, final T element) { [EOL]     Class<?> type; [EOL]     if (array != null) { [EOL]         type = array.getClass(); [EOL]     } else if (element != null) { [EOL]         type = element.getClass(); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Arguments cannot both be null"); [EOL]     } [EOL]     @SuppressWarnings("unchecked") [EOL]     final T[] newArray = (T[]) copyArrayGrow1(array, type); [EOL]     newArray[newArray.length - 1] = element; [EOL]     return newArray; [EOL] }
public static boolean[] add(final boolean[] array, final boolean element) { [EOL]     final boolean[] newArray = (boolean[]) copyArrayGrow1(array, Boolean.TYPE); [EOL]     newArray[newArray.length - 1] = element; [EOL]     return newArray; [EOL] }
public static float[] add(final float[] array, final float element) { [EOL]     final float[] newArray = (float[]) copyArrayGrow1(array, Float.TYPE); [EOL]     newArray[newArray.length - 1] = element; [EOL]     return newArray; [EOL] }
public static long[] add(final long[] array, final long element) { [EOL]     final long[] newArray = (long[]) copyArrayGrow1(array, Long.TYPE); [EOL]     newArray[newArray.length - 1] = element; [EOL]     return newArray; [EOL] }
public static short[] add(final short[] array, final short element) { [EOL]     final short[] newArray = (short[]) copyArrayGrow1(array, Short.TYPE); [EOL]     newArray[newArray.length - 1] = element; [EOL]     return newArray; [EOL] }
public static short[] add(final short[] array, final short element) { [EOL]     final short[] newArray = (short[]) copyArrayGrow1(array, Short.TYPE); [EOL]     newArray[newArray.length - 1] = element; [EOL]     return newArray; [EOL] }
private static Object copyArrayGrow1(final Object array, final Class<?> newArrayComponentType) { [EOL]     if (array != null) { [EOL]         final int arrayLength = Array.getLength(array); [EOL]         final Object newArray = Array.newInstance(array.getClass().getComponentType(), arrayLength + 1); [EOL]         System.arraycopy(array, 0, newArray, 0, arrayLength); [EOL]         return newArray; [EOL]     } [EOL]     return Array.newInstance(newArrayComponentType, 1); [EOL] }
public static <T> T[] removeElement(final T[] array, final Object element) { [EOL]     final int index = indexOf(array, element); [EOL]     if (index == INDEX_NOT_FOUND) { [EOL]         return clone(array); [EOL]     } [EOL]     return remove(array, index); [EOL] }
public static <T> T[] removeElement(final T[] array, final Object element) { [EOL]     final int index = indexOf(array, element); [EOL]     if (index == INDEX_NOT_FOUND) { [EOL]         return clone(array); [EOL]     } [EOL]     return remove(array, index); [EOL] }
public static <T> T[] removeElement(final T[] array, final Object element) { [EOL]     final int index = indexOf(array, element); [EOL]     if (index == INDEX_NOT_FOUND) { [EOL]         return clone(array); [EOL]     } [EOL]     return remove(array, index); [EOL] }
public static <T> T[] removeElement(final T[] array, final Object element) { [EOL]     final int index = indexOf(array, element); [EOL]     if (index == INDEX_NOT_FOUND) { [EOL]         return clone(array); [EOL]     } [EOL]     return remove(array, index); [EOL] }
public static boolean[] removeElement(final boolean[] array, final boolean element) { [EOL]     final int index = indexOf(array, element); [EOL]     if (index == INDEX_NOT_FOUND) { [EOL]         return clone(array); [EOL]     } [EOL]     return remove(array, index); [EOL] }
public static byte[] removeAll(final byte[] array, final int... indices) { [EOL]     return (byte[]) removeAll((Object) array, clone(indices)); [EOL] }
public static byte[] removeAll(final byte[] array, final int... indices) { [EOL]     return (byte[]) removeAll((Object) array, clone(indices)); [EOL] }
public static byte[] removeAll(final byte[] array, final int... indices) { [EOL]     return (byte[]) removeAll((Object) array, clone(indices)); [EOL] }
public static byte[] removeAll(final byte[] array, final int... indices) { [EOL]     return (byte[]) removeAll((Object) array, clone(indices)); [EOL] }
public static byte[] removeAll(final byte[] array, final int... indices) { [EOL]     return (byte[]) removeAll((Object) array, clone(indices)); [EOL] }
public static byte[] removeAll(final byte[] array, final int... indices) { [EOL]     return (byte[]) removeAll((Object) array, clone(indices)); [EOL] }
public static byte[] removeAll(final byte[] array, final int... indices) { [EOL]     return (byte[]) removeAll((Object) array, clone(indices)); [EOL] }
public static byte[] removeAll(final byte[] array, final int... indices) { [EOL]     return (byte[]) removeAll((Object) array, clone(indices)); [EOL] }
public static short[] removeElements(final short[] array, final short... values) { [EOL]     if (isEmpty(array) || isEmpty(values)) { [EOL]         return clone(array); [EOL]     } [EOL]     final HashMap<Short, MutableInt> occurrences = new HashMap<Short, MutableInt>(values.length); [EOL]     for (final short v : values) { [EOL]         final Short boxed = Short.valueOf(v); [EOL]         final MutableInt count = occurrences.get(boxed); [EOL]         if (count == null) { [EOL]             occurrences.put(boxed, new MutableInt(1)); [EOL]         } else { [EOL]             count.increment(); [EOL]         } [EOL]     } [EOL]     final BitSet toRemove = new BitSet(); [EOL]     for (final Map.Entry<Short, MutableInt> e : occurrences.entrySet()) { [EOL]         final Short v = e.getKey(); [EOL]         int found = 0; [EOL]         for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) { [EOL]             found = indexOf(array, v.shortValue(), found); [EOL]             if (found < 0) { [EOL]                 break; [EOL]             } [EOL]             toRemove.set(found++); [EOL]         } [EOL]     } [EOL]     return (short[]) removeAll(array, toRemove); [EOL] }
public static long[] removeAll(final long[] array, final int... indices) { [EOL]     return (long[]) removeAll((Object) array, clone(indices)); [EOL] }
public static long[] removeAll(final long[] array, final int... indices) { [EOL]     return (long[]) removeAll((Object) array, clone(indices)); [EOL] }
public static long[] removeAll(final long[] array, final int... indices) { [EOL]     return (long[]) removeAll((Object) array, clone(indices)); [EOL] }
public static long[] removeAll(final long[] array, final int... indices) { [EOL]     return (long[]) removeAll((Object) array, clone(indices)); [EOL] }
public static long[] removeAll(final long[] array, final int... indices) { [EOL]     return (long[]) removeAll((Object) array, clone(indices)); [EOL] }
public static long[] removeAll(final long[] array, final int... indices) { [EOL]     return (long[]) removeAll((Object) array, clone(indices)); [EOL] }
public static long[] removeAll(final long[] array, final int... indices) { [EOL]     return (long[]) removeAll((Object) array, clone(indices)); [EOL] }
public static long[] removeAll(final long[] array, final int... indices) { [EOL]     return (long[]) removeAll((Object) array, clone(indices)); [EOL] }
public static float[] removeElements(final float[] array, final float... values) { [EOL]     if (isEmpty(array) || isEmpty(values)) { [EOL]         return clone(array); [EOL]     } [EOL]     final HashMap<Float, MutableInt> occurrences = new HashMap<Float, MutableInt>(values.length); [EOL]     for (final float v : values) { [EOL]         final Float boxed = Float.valueOf(v); [EOL]         final MutableInt count = occurrences.get(boxed); [EOL]         if (count == null) { [EOL]             occurrences.put(boxed, new MutableInt(1)); [EOL]         } else { [EOL]             count.increment(); [EOL]         } [EOL]     } [EOL]     final BitSet toRemove = new BitSet(); [EOL]     for (final Map.Entry<Float, MutableInt> e : occurrences.entrySet()) { [EOL]         final Float v = e.getKey(); [EOL]         int found = 0; [EOL]         for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) { [EOL]             found = indexOf(array, v.floatValue(), found); [EOL]             if (found < 0) { [EOL]                 break; [EOL]             } [EOL]             toRemove.set(found++); [EOL]         } [EOL]     } [EOL]     return (float[]) removeAll(array, toRemove); [EOL] }
public static double[] removeAll(final double[] array, final int... indices) { [EOL]     return (double[]) removeAll((Object) array, clone(indices)); [EOL] }
public static double[] removeAll(final double[] array, final int... indices) { [EOL]     return (double[]) removeAll((Object) array, clone(indices)); [EOL] }
public static double[] removeAll(final double[] array, final int... indices) { [EOL]     return (double[]) removeAll((Object) array, clone(indices)); [EOL] }
public static double[] removeAll(final double[] array, final int... indices) { [EOL]     return (double[]) removeAll((Object) array, clone(indices)); [EOL] }
public static double[] removeAll(final double[] array, final int... indices) { [EOL]     return (double[]) removeAll((Object) array, clone(indices)); [EOL] }
public static double[] removeAll(final double[] array, final int... indices) { [EOL]     return (double[]) removeAll((Object) array, clone(indices)); [EOL] }
static Object removeAll(final Object array, final int... indices) { [EOL]     final int length = getLength(array); [EOL]     int diff = 0; [EOL]     if (isNotEmpty(indices)) { [EOL]         Arrays.sort(indices); [EOL]         int i = indices.length; [EOL]         int prevIndex = length; [EOL]         while (--i >= 0) { [EOL]             final int index = indices[i]; [EOL]             if (index < 0 || index >= length) { [EOL]                 throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length); [EOL]             } [EOL]             if (index >= prevIndex) { [EOL]                 continue; [EOL]             } [EOL]             diff++; [EOL]             prevIndex = index; [EOL]         } [EOL]     } [EOL]     final Object result = Array.newInstance(array.getClass().getComponentType(), length - diff); [EOL]     if (diff < length) { [EOL]         int end = length; [EOL]         int dest = length - diff; [EOL]         for (int i = indices.length - 1; i >= 0; i--) { [EOL]             final int index = indices[i]; [EOL]             if (end - index > 1) { [EOL]                 final int cp = end - index - 1; [EOL]                 dest -= cp; [EOL]                 System.arraycopy(array, index + 1, result, dest, cp); [EOL]             } [EOL]             end = index; [EOL]         } [EOL]         if (end > 0) { [EOL]             System.arraycopy(array, 0, result, 0, end); [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
private static float getObjectTransformationCost(Class<?> srcClass, final Class<?> destClass) { [EOL]     if (destClass.isPrimitive()) { [EOL]         return getPrimitivePromotionCost(srcClass, destClass); [EOL]     } [EOL]     float cost = 0.0f; [EOL]     while (srcClass != null && !destClass.equals(srcClass)) { [EOL]         if (destClass.isInterface() && ClassUtils.isAssignable(srcClass, destClass)) { [EOL]             cost += 0.25f; [EOL]             break; [EOL]         } [EOL]         cost++; [EOL]         srcClass = srcClass.getSuperclass(); [EOL]     } [EOL]     if (srcClass == null) { [EOL]         cost += 1.5f; [EOL]     } [EOL]     return cost; [EOL] }  static void setAccessibleWorkaround(final AccessibleObject o);  static boolean isPackageAccess(final int modifiers);  static boolean isAccessible(final Member m);  static int compareParameterTypes(final Class<?>[] left, final Class<?>[] right, final Class<?>[] actual); private static float getTotalTransformationCost(final Class<?>[] srcArgs, final Class<?>[] destArgs); private static float getObjectTransformationCost(Class<?> srcClass, final Class<?> destClass); private static float getPrimitivePromotionCost(final Class<?> srcClass, final Class<?> destClass); int ACCESS_TEST=Optional[Modifier.PUBLIC | Modifier.PROTECTED | Modifier.PRIVATE]; Class<?>[] ORDERED_PRIMITIVE_TYPES=Optional[{ Byte.TYPE, Short.TYPE, Character.TYPE, Integer.TYPE, Long.TYPE, Float.TYPE, Double.TYPE }
public static boolean isInstance(final Object value, final Type type) { [EOL]     if (type == null) { [EOL]         return false; [EOL]     } [EOL]     return value == null ? !(type instanceof Class<?>) || !((Class<?>) type).isPrimitive() : isAssignable(value.getClass(), type, null); [EOL] }
@Override [EOL] public List<Object> getContextValues(final String label) { [EOL]     final List<Object> values = new ArrayList<Object>(); [EOL]     for (final Pair<String, Object> pair : contextValues) { [EOL]         if (StringUtils.equals(label, pair.getKey())) { [EOL]             values.add(pair.getValue()); [EOL]         } [EOL]     } [EOL]     return values; [EOL] }
@Override [EOL] public List<Object> getContextValues(final String label) { [EOL]     final List<Object> values = new ArrayList<Object>(); [EOL]     for (final Pair<String, Object> pair : contextValues) { [EOL]         if (StringUtils.equals(label, pair.getKey())) { [EOL]             values.add(pair.getValue()); [EOL]         } [EOL]     } [EOL]     return values; [EOL] }
@Override [EOL] public List<Object> getContextValues(final String label) { [EOL]     final List<Object> values = new ArrayList<Object>(); [EOL]     for (final Pair<String, Object> pair : contextValues) { [EOL]         if (StringUtils.equals(label, pair.getKey())) { [EOL]             values.add(pair.getValue()); [EOL]         } [EOL]     } [EOL]     return values; [EOL] }
public StrBuilder(int initialCapacity) { [EOL]     super(); [EOL]     if (initialCapacity <= 0) { [EOL]         initialCapacity = CAPACITY; [EOL]     } [EOL]     buffer = new char[initialCapacity]; [EOL] }
public StrBuilder(int initialCapacity) { [EOL]     super(); [EOL]     if (initialCapacity <= 0) { [EOL]         initialCapacity = CAPACITY; [EOL]     } [EOL]     buffer = new char[initialCapacity]; [EOL] }
public StrBuilder(int initialCapacity) { [EOL]     super(); [EOL]     if (initialCapacity <= 0) { [EOL]         initialCapacity = CAPACITY; [EOL]     } [EOL]     buffer = new char[initialCapacity]; [EOL] }
public StrBuilder(final String str) { [EOL]     super(); [EOL]     if (str == null) { [EOL]         buffer = new char[CAPACITY]; [EOL]     } else { [EOL]         buffer = new char[str.length() + CAPACITY]; [EOL]         append(str); [EOL]     } [EOL] }
public StrBuilder(final String str) { [EOL]     super(); [EOL]     if (str == null) { [EOL]         buffer = new char[CAPACITY]; [EOL]     } else { [EOL]         buffer = new char[str.length() + CAPACITY]; [EOL]         append(str); [EOL]     } [EOL] }
public StrBuilder(final String str) { [EOL]     super(); [EOL]     if (str == null) { [EOL]         buffer = new char[CAPACITY]; [EOL]     } else { [EOL]         buffer = new char[str.length() + CAPACITY]; [EOL]         append(str); [EOL]     } [EOL] }
public String getNewLineText() { [EOL]     return newLine; [EOL] }
public StrBuilder setNewLineText(final String newLine) { [EOL]     this.newLine = newLine; [EOL]     return this; [EOL] }
public StrBuilder setNewLineText(final String newLine) { [EOL]     this.newLine = newLine; [EOL]     return this; [EOL] }
public StrBuilder setNewLineText(final String newLine) { [EOL]     this.newLine = newLine; [EOL]     return this; [EOL] }
public StrBuilder setNewLineText(final String newLine) { [EOL]     this.newLine = newLine; [EOL]     return this; [EOL] }
public StrBuilder setNullText(String nullText) { [EOL]     if (nullText != null && nullText.isEmpty()) { [EOL]         nullText = null; [EOL]     } [EOL]     this.nullText = nullText; [EOL]     return this; [EOL] }
public StrBuilder setNullText(String nullText) { [EOL]     if (nullText != null && nullText.isEmpty()) { [EOL]         nullText = null; [EOL]     } [EOL]     this.nullText = nullText; [EOL]     return this; [EOL] }
public StrBuilder setNullText(String nullText) { [EOL]     if (nullText != null && nullText.isEmpty()) { [EOL]         nullText = null; [EOL]     } [EOL]     this.nullText = nullText; [EOL]     return this; [EOL] }
public StrBuilder setLength(final int length) { [EOL]     if (length < 0) { [EOL]         throw new StringIndexOutOfBoundsException(length); [EOL]     } [EOL]     if (length < size) { [EOL]         size = length; [EOL]     } else if (length > size) { [EOL]         ensureCapacity(length); [EOL]         final int oldEnd = size; [EOL]         final int newEnd = length; [EOL]         size = length; [EOL]         for (int i = oldEnd; i < newEnd; i++) { [EOL]             buffer[i] = '\0'; [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder setLength(final int length) { [EOL]     if (length < 0) { [EOL]         throw new StringIndexOutOfBoundsException(length); [EOL]     } [EOL]     if (length < size) { [EOL]         size = length; [EOL]     } else if (length > size) { [EOL]         ensureCapacity(length); [EOL]         final int oldEnd = size; [EOL]         final int newEnd = length; [EOL]         size = length; [EOL]         for (int i = oldEnd; i < newEnd; i++) { [EOL]             buffer[i] = '\0'; [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder setLength(final int length) { [EOL]     if (length < 0) { [EOL]         throw new StringIndexOutOfBoundsException(length); [EOL]     } [EOL]     if (length < size) { [EOL]         size = length; [EOL]     } else if (length > size) { [EOL]         ensureCapacity(length); [EOL]         final int oldEnd = size; [EOL]         final int newEnd = length; [EOL]         size = length; [EOL]         for (int i = oldEnd; i < newEnd; i++) { [EOL]             buffer[i] = '\0'; [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder setLength(final int length) { [EOL]     if (length < 0) { [EOL]         throw new StringIndexOutOfBoundsException(length); [EOL]     } [EOL]     if (length < size) { [EOL]         size = length; [EOL]     } else if (length > size) { [EOL]         ensureCapacity(length); [EOL]         final int oldEnd = size; [EOL]         final int newEnd = length; [EOL]         size = length; [EOL]         for (int i = oldEnd; i < newEnd; i++) { [EOL]             buffer[i] = '\0'; [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder minimizeCapacity() { [EOL]     if (buffer.length > length()) { [EOL]         final char[] old = buffer; [EOL]         buffer = new char[length()]; [EOL]         System.arraycopy(old, 0, buffer, 0, size); [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder minimizeCapacity() { [EOL]     if (buffer.length > length()) { [EOL]         final char[] old = buffer; [EOL]         buffer = new char[length()]; [EOL]         System.arraycopy(old, 0, buffer, 0, size); [EOL]     } [EOL]     return this; [EOL] }
public int size() { [EOL]     return size; [EOL] }
public int size() { [EOL]     return size; [EOL] }
public void getChars(final int startIndex, final int endIndex, final char[] destination, final int destinationIndex) { [EOL]     if (startIndex < 0) { [EOL]         throw new StringIndexOutOfBoundsException(startIndex); [EOL]     } [EOL]     if (endIndex < 0 || endIndex > length()) { [EOL]         throw new StringIndexOutOfBoundsException(endIndex); [EOL]     } [EOL]     if (startIndex > endIndex) { [EOL]         throw new StringIndexOutOfBoundsException("end < start"); [EOL]     } [EOL]     System.arraycopy(buffer, startIndex, destination, destinationIndex, endIndex - startIndex); [EOL] }
public void getChars(final int startIndex, final int endIndex, final char[] destination, final int destinationIndex) { [EOL]     if (startIndex < 0) { [EOL]         throw new StringIndexOutOfBoundsException(startIndex); [EOL]     } [EOL]     if (endIndex < 0 || endIndex > length()) { [EOL]         throw new StringIndexOutOfBoundsException(endIndex); [EOL]     } [EOL]     if (startIndex > endIndex) { [EOL]         throw new StringIndexOutOfBoundsException("end < start"); [EOL]     } [EOL]     System.arraycopy(buffer, startIndex, destination, destinationIndex, endIndex - startIndex); [EOL] }
public void getChars(final int startIndex, final int endIndex, final char[] destination, final int destinationIndex) { [EOL]     if (startIndex < 0) { [EOL]         throw new StringIndexOutOfBoundsException(startIndex); [EOL]     } [EOL]     if (endIndex < 0 || endIndex > length()) { [EOL]         throw new StringIndexOutOfBoundsException(endIndex); [EOL]     } [EOL]     if (startIndex > endIndex) { [EOL]         throw new StringIndexOutOfBoundsException("end < start"); [EOL]     } [EOL]     System.arraycopy(buffer, startIndex, destination, destinationIndex, endIndex - startIndex); [EOL] }
public void getChars(final int startIndex, final int endIndex, final char[] destination, final int destinationIndex) { [EOL]     if (startIndex < 0) { [EOL]         throw new StringIndexOutOfBoundsException(startIndex); [EOL]     } [EOL]     if (endIndex < 0 || endIndex > length()) { [EOL]         throw new StringIndexOutOfBoundsException(endIndex); [EOL]     } [EOL]     if (startIndex > endIndex) { [EOL]         throw new StringIndexOutOfBoundsException("end < start"); [EOL]     } [EOL]     System.arraycopy(buffer, startIndex, destination, destinationIndex, endIndex - startIndex); [EOL] }
public void getChars(final int startIndex, final int endIndex, final char[] destination, final int destinationIndex) { [EOL]     if (startIndex < 0) { [EOL]         throw new StringIndexOutOfBoundsException(startIndex); [EOL]     } [EOL]     if (endIndex < 0 || endIndex > length()) { [EOL]         throw new StringIndexOutOfBoundsException(endIndex); [EOL]     } [EOL]     if (startIndex > endIndex) { [EOL]         throw new StringIndexOutOfBoundsException("end < start"); [EOL]     } [EOL]     System.arraycopy(buffer, startIndex, destination, destinationIndex, endIndex - startIndex); [EOL] }
public StrBuilder appendNewLine() { [EOL]     if (newLine == null) { [EOL]         append(SystemUtils.LINE_SEPARATOR); [EOL]         return this; [EOL]     } [EOL]     return append(newLine); [EOL] }
public StrBuilder appendln(final StringBuffer str, final int startIndex, final int length) { [EOL]     return append(str, startIndex, length).appendNewLine(); [EOL] }
public StrBuilder appendln(final StringBuffer str, final int startIndex, final int length) { [EOL]     return append(str, startIndex, length).appendNewLine(); [EOL] }
public StrBuilder appendln(final StringBuffer str, final int startIndex, final int length) { [EOL]     return append(str, startIndex, length).appendNewLine(); [EOL] }
public StrBuilder appendln(final StringBuffer str, final int startIndex, final int length) { [EOL]     return append(str, startIndex, length).appendNewLine(); [EOL] }
public StrBuilder appendln(final StringBuffer str, final int startIndex, final int length) { [EOL]     return append(str, startIndex, length).appendNewLine(); [EOL] }
public StrBuilder appendln(final char[] chars) { [EOL]     return append(chars).appendNewLine(); [EOL] }
public StrBuilder appendln(final char[] chars) { [EOL]     return append(chars).appendNewLine(); [EOL] }
public StrBuilder appendln(final char[] chars) { [EOL]     return append(chars).appendNewLine(); [EOL] }
public StrBuilder appendln(final boolean value) { [EOL]     return append(value).appendNewLine(); [EOL] }
public StrBuilder appendln(final boolean value) { [EOL]     return append(value).appendNewLine(); [EOL] }
public StrBuilder appendAll(final Iterable<?> iterable) { [EOL]     if (iterable != null) { [EOL]         for (final Object o : iterable) { [EOL]             append(o); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder appendAll(final Iterable<?> iterable) { [EOL]     if (iterable != null) { [EOL]         for (final Object o : iterable) { [EOL]             append(o); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder appendAll(final Iterable<?> iterable) { [EOL]     if (iterable != null) { [EOL]         for (final Object o : iterable) { [EOL]             append(o); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder appendWithSeparators(final Object[] array, String separator) { [EOL]     if (array != null && array.length > 0) { [EOL]         separator = ObjectUtils.toString(separator); [EOL]         append(array[0]); [EOL]         for (int i = 1; i < array.length; i++) { [EOL]             append(separator); [EOL]             append(array[i]); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder appendWithSeparators(final Object[] array, String separator) { [EOL]     if (array != null && array.length > 0) { [EOL]         separator = ObjectUtils.toString(separator); [EOL]         append(array[0]); [EOL]         for (int i = 1; i < array.length; i++) { [EOL]             append(separator); [EOL]             append(array[i]); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder appendWithSeparators(final Iterable<?> iterable, String separator) { [EOL]     if (iterable != null) { [EOL]         separator = ObjectUtils.toString(separator); [EOL]         final Iterator<?> it = iterable.iterator(); [EOL]         while (it.hasNext()) { [EOL]             append(it.next()); [EOL]             if (it.hasNext()) { [EOL]                 append(separator); [EOL]             } [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder appendSeparator(final char standard, final char defaultIfEmpty) { [EOL]     if (size() > 0) { [EOL]         append(standard); [EOL]     } else { [EOL]         append(defaultIfEmpty); [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder appendSeparator(final char standard, final char defaultIfEmpty) { [EOL]     if (size() > 0) { [EOL]         append(standard); [EOL]     } else { [EOL]         append(defaultIfEmpty); [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder appendFixedWidthPadLeft(final Object obj, final int width, final char padChar) { [EOL]     if (width > 0) { [EOL]         ensureCapacity(size + width); [EOL]         String str = (obj == null ? getNullText() : obj.toString()); [EOL]         if (str == null) { [EOL]             str = ""; [EOL]         } [EOL]         final int strLen = str.length(); [EOL]         if (strLen >= width) { [EOL]             str.getChars(strLen - width, strLen, buffer, size); [EOL]         } else { [EOL]             final int padLen = width - strLen; [EOL]             for (int i = 0; i < padLen; i++) { [EOL]                 buffer[size + i] = padChar; [EOL]             } [EOL]             str.getChars(0, strLen, buffer, size + padLen); [EOL]         } [EOL]         size += width; [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder appendFixedWidthPadLeft(final Object obj, final int width, final char padChar) { [EOL]     if (width > 0) { [EOL]         ensureCapacity(size + width); [EOL]         String str = (obj == null ? getNullText() : obj.toString()); [EOL]         if (str == null) { [EOL]             str = ""; [EOL]         } [EOL]         final int strLen = str.length(); [EOL]         if (strLen >= width) { [EOL]             str.getChars(strLen - width, strLen, buffer, size); [EOL]         } else { [EOL]             final int padLen = width - strLen; [EOL]             for (int i = 0; i < padLen; i++) { [EOL]                 buffer[size + i] = padChar; [EOL]             } [EOL]             str.getChars(0, strLen, buffer, size + padLen); [EOL]         } [EOL]         size += width; [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder appendFixedWidthPadLeft(final Object obj, final int width, final char padChar) { [EOL]     if (width > 0) { [EOL]         ensureCapacity(size + width); [EOL]         String str = (obj == null ? getNullText() : obj.toString()); [EOL]         if (str == null) { [EOL]             str = ""; [EOL]         } [EOL]         final int strLen = str.length(); [EOL]         if (strLen >= width) { [EOL]             str.getChars(strLen - width, strLen, buffer, size); [EOL]         } else { [EOL]             final int padLen = width - strLen; [EOL]             for (int i = 0; i < padLen; i++) { [EOL]                 buffer[size + i] = padChar; [EOL]             } [EOL]             str.getChars(0, strLen, buffer, size + padLen); [EOL]         } [EOL]         size += width; [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder appendFixedWidthPadLeft(final Object obj, final int width, final char padChar) { [EOL]     if (width > 0) { [EOL]         ensureCapacity(size + width); [EOL]         String str = (obj == null ? getNullText() : obj.toString()); [EOL]         if (str == null) { [EOL]             str = ""; [EOL]         } [EOL]         final int strLen = str.length(); [EOL]         if (strLen >= width) { [EOL]             str.getChars(strLen - width, strLen, buffer, size); [EOL]         } else { [EOL]             final int padLen = width - strLen; [EOL]             for (int i = 0; i < padLen; i++) { [EOL]                 buffer[size + i] = padChar; [EOL]             } [EOL]             str.getChars(0, strLen, buffer, size + padLen); [EOL]         } [EOL]         size += width; [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder appendFixedWidthPadLeft(final Object obj, final int width, final char padChar) { [EOL]     if (width > 0) { [EOL]         ensureCapacity(size + width); [EOL]         String str = (obj == null ? getNullText() : obj.toString()); [EOL]         if (str == null) { [EOL]             str = ""; [EOL]         } [EOL]         final int strLen = str.length(); [EOL]         if (strLen >= width) { [EOL]             str.getChars(strLen - width, strLen, buffer, size); [EOL]         } else { [EOL]             final int padLen = width - strLen; [EOL]             for (int i = 0; i < padLen; i++) { [EOL]                 buffer[size + i] = padChar; [EOL]             } [EOL]             str.getChars(0, strLen, buffer, size + padLen); [EOL]         } [EOL]         size += width; [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder insert(final int index, final char[] chars) { [EOL]     validateIndex(index); [EOL]     if (chars == null) { [EOL]         return insert(index, nullText); [EOL]     } [EOL]     final int len = chars.length; [EOL]     if (len > 0) { [EOL]         ensureCapacity(size + len); [EOL]         System.arraycopy(buffer, index, buffer, index + len, size - index); [EOL]         System.arraycopy(chars, 0, buffer, index, len); [EOL]         size += len; [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder insert(final int index, final char[] chars) { [EOL]     validateIndex(index); [EOL]     if (chars == null) { [EOL]         return insert(index, nullText); [EOL]     } [EOL]     final int len = chars.length; [EOL]     if (len > 0) { [EOL]         ensureCapacity(size + len); [EOL]         System.arraycopy(buffer, index, buffer, index + len, size - index); [EOL]         System.arraycopy(chars, 0, buffer, index, len); [EOL]         size += len; [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder insert(final int index, final char[] chars) { [EOL]     validateIndex(index); [EOL]     if (chars == null) { [EOL]         return insert(index, nullText); [EOL]     } [EOL]     final int len = chars.length; [EOL]     if (len > 0) { [EOL]         ensureCapacity(size + len); [EOL]         System.arraycopy(buffer, index, buffer, index + len, size - index); [EOL]         System.arraycopy(chars, 0, buffer, index, len); [EOL]         size += len; [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder insert(final int index, final char[] chars) { [EOL]     validateIndex(index); [EOL]     if (chars == null) { [EOL]         return insert(index, nullText); [EOL]     } [EOL]     final int len = chars.length; [EOL]     if (len > 0) { [EOL]         ensureCapacity(size + len); [EOL]         System.arraycopy(buffer, index, buffer, index + len, size - index); [EOL]         System.arraycopy(chars, 0, buffer, index, len); [EOL]         size += len; [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder insert(final int index, final char[] chars, final int offset, final int length) { [EOL]     validateIndex(index); [EOL]     if (chars == null) { [EOL]         return insert(index, nullText); [EOL]     } [EOL]     if (offset < 0 || offset > chars.length) { [EOL]         throw new StringIndexOutOfBoundsException("Invalid offset: " + offset); [EOL]     } [EOL]     if (length < 0 || offset + length > chars.length) { [EOL]         throw new StringIndexOutOfBoundsException("Invalid length: " + length); [EOL]     } [EOL]     if (length > 0) { [EOL]         ensureCapacity(size + length); [EOL]         System.arraycopy(buffer, index, buffer, index + length, size - index); [EOL]         System.arraycopy(chars, offset, buffer, index, length); [EOL]         size += length; [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder insert(int index, final boolean value) { [EOL]     validateIndex(index); [EOL]     if (value) { [EOL]         ensureCapacity(size + 4); [EOL]         System.arraycopy(buffer, index, buffer, index + 4, size - index); [EOL]         buffer[index++] = 't'; [EOL]         buffer[index++] = 'r'; [EOL]         buffer[index++] = 'u'; [EOL]         buffer[index] = 'e'; [EOL]         size += 4; [EOL]     } else { [EOL]         ensureCapacity(size + 5); [EOL]         System.arraycopy(buffer, index, buffer, index + 5, size - index); [EOL]         buffer[index++] = 'f'; [EOL]         buffer[index++] = 'a'; [EOL]         buffer[index++] = 'l'; [EOL]         buffer[index++] = 's'; [EOL]         buffer[index] = 'e'; [EOL]         size += 5; [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder insert(int index, final boolean value) { [EOL]     validateIndex(index); [EOL]     if (value) { [EOL]         ensureCapacity(size + 4); [EOL]         System.arraycopy(buffer, index, buffer, index + 4, size - index); [EOL]         buffer[index++] = 't'; [EOL]         buffer[index++] = 'r'; [EOL]         buffer[index++] = 'u'; [EOL]         buffer[index] = 'e'; [EOL]         size += 4; [EOL]     } else { [EOL]         ensureCapacity(size + 5); [EOL]         System.arraycopy(buffer, index, buffer, index + 5, size - index); [EOL]         buffer[index++] = 'f'; [EOL]         buffer[index++] = 'a'; [EOL]         buffer[index++] = 'l'; [EOL]         buffer[index++] = 's'; [EOL]         buffer[index] = 'e'; [EOL]         size += 5; [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder insert(int index, final boolean value) { [EOL]     validateIndex(index); [EOL]     if (value) { [EOL]         ensureCapacity(size + 4); [EOL]         System.arraycopy(buffer, index, buffer, index + 4, size - index); [EOL]         buffer[index++] = 't'; [EOL]         buffer[index++] = 'r'; [EOL]         buffer[index++] = 'u'; [EOL]         buffer[index] = 'e'; [EOL]         size += 4; [EOL]     } else { [EOL]         ensureCapacity(size + 5); [EOL]         System.arraycopy(buffer, index, buffer, index + 5, size - index); [EOL]         buffer[index++] = 'f'; [EOL]         buffer[index++] = 'a'; [EOL]         buffer[index++] = 'l'; [EOL]         buffer[index++] = 's'; [EOL]         buffer[index] = 'e'; [EOL]         size += 5; [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder insert(int index, final boolean value) { [EOL]     validateIndex(index); [EOL]     if (value) { [EOL]         ensureCapacity(size + 4); [EOL]         System.arraycopy(buffer, index, buffer, index + 4, size - index); [EOL]         buffer[index++] = 't'; [EOL]         buffer[index++] = 'r'; [EOL]         buffer[index++] = 'u'; [EOL]         buffer[index] = 'e'; [EOL]         size += 4; [EOL]     } else { [EOL]         ensureCapacity(size + 5); [EOL]         System.arraycopy(buffer, index, buffer, index + 5, size - index); [EOL]         buffer[index++] = 'f'; [EOL]         buffer[index++] = 'a'; [EOL]         buffer[index++] = 'l'; [EOL]         buffer[index++] = 's'; [EOL]         buffer[index] = 'e'; [EOL]         size += 5; [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder insert(int index, final boolean value) { [EOL]     validateIndex(index); [EOL]     if (value) { [EOL]         ensureCapacity(size + 4); [EOL]         System.arraycopy(buffer, index, buffer, index + 4, size - index); [EOL]         buffer[index++] = 't'; [EOL]         buffer[index++] = 'r'; [EOL]         buffer[index++] = 'u'; [EOL]         buffer[index] = 'e'; [EOL]         size += 4; [EOL]     } else { [EOL]         ensureCapacity(size + 5); [EOL]         System.arraycopy(buffer, index, buffer, index + 5, size - index); [EOL]         buffer[index++] = 'f'; [EOL]         buffer[index++] = 'a'; [EOL]         buffer[index++] = 'l'; [EOL]         buffer[index++] = 's'; [EOL]         buffer[index] = 'e'; [EOL]         size += 5; [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder insert(final int index, final char value) { [EOL]     validateIndex(index); [EOL]     ensureCapacity(size + 1); [EOL]     System.arraycopy(buffer, index, buffer, index + 1, size - index); [EOL]     buffer[index] = value; [EOL]     size++; [EOL]     return this; [EOL] }
public StrBuilder insert(final int index, final char value) { [EOL]     validateIndex(index); [EOL]     ensureCapacity(size + 1); [EOL]     System.arraycopy(buffer, index, buffer, index + 1, size - index); [EOL]     buffer[index] = value; [EOL]     size++; [EOL]     return this; [EOL] }
public StrBuilder insert(final int index, final int value) { [EOL]     return insert(index, String.valueOf(value)); [EOL] }
public StrBuilder insert(final int index, final int value) { [EOL]     return insert(index, String.valueOf(value)); [EOL] }
public StrBuilder insert(final int index, final int value) { [EOL]     return insert(index, String.valueOf(value)); [EOL] }
public StrBuilder insert(final int index, final int value) { [EOL]     return insert(index, String.valueOf(value)); [EOL] }
public StrBuilder insert(final int index, final int value) { [EOL]     return insert(index, String.valueOf(value)); [EOL] }
public StrBuilder insert(final int index, final long value) { [EOL]     return insert(index, String.valueOf(value)); [EOL] }
public StrBuilder insert(final int index, final long value) { [EOL]     return insert(index, String.valueOf(value)); [EOL] }
public StrBuilder insert(final int index, final long value) { [EOL]     return insert(index, String.valueOf(value)); [EOL] }
public StrBuilder insert(final int index, final long value) { [EOL]     return insert(index, String.valueOf(value)); [EOL] }
public StrBuilder insert(final int index, final long value) { [EOL]     return insert(index, String.valueOf(value)); [EOL] }
public StrBuilder insert(final int index, final float value) { [EOL]     return insert(index, String.valueOf(value)); [EOL] }
public StrBuilder insert(final int index, final float value) { [EOL]     return insert(index, String.valueOf(value)); [EOL] }
public StrBuilder insert(final int index, final float value) { [EOL]     return insert(index, String.valueOf(value)); [EOL] }
public StrBuilder insert(final int index, final float value) { [EOL]     return insert(index, String.valueOf(value)); [EOL] }
public StrBuilder insert(final int index, final float value) { [EOL]     return insert(index, String.valueOf(value)); [EOL] }
public StrBuilder insert(final int index, final double value) { [EOL]     return insert(index, String.valueOf(value)); [EOL] }
public StrBuilder insert(final int index, final double value) { [EOL]     return insert(index, String.valueOf(value)); [EOL] }
public StrBuilder insert(final int index, final double value) { [EOL]     return insert(index, String.valueOf(value)); [EOL] }
public StrBuilder insert(final int index, final double value) { [EOL]     return insert(index, String.valueOf(value)); [EOL] }
public StrBuilder insert(final int index, final double value) { [EOL]     return insert(index, String.valueOf(value)); [EOL] }
public StrBuilder delete(final int startIndex, int endIndex) { [EOL]     endIndex = validateRange(startIndex, endIndex); [EOL]     final int len = endIndex - startIndex; [EOL]     if (len > 0) { [EOL]         deleteImpl(startIndex, endIndex, len); [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder delete(final int startIndex, int endIndex) { [EOL]     endIndex = validateRange(startIndex, endIndex); [EOL]     final int len = endIndex - startIndex; [EOL]     if (len > 0) { [EOL]         deleteImpl(startIndex, endIndex, len); [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder deleteAll(final char ch) { [EOL]     for (int i = 0; i < size; i++) { [EOL]         if (buffer[i] == ch) { [EOL]             final int start = i; [EOL]             while (++i < size) { [EOL]                 if (buffer[i] != ch) { [EOL]                     break; [EOL]                 } [EOL]             } [EOL]             final int len = i - start; [EOL]             deleteImpl(start, i, len); [EOL]             i -= len; [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder deleteAll(final char ch) { [EOL]     for (int i = 0; i < size; i++) { [EOL]         if (buffer[i] == ch) { [EOL]             final int start = i; [EOL]             while (++i < size) { [EOL]                 if (buffer[i] != ch) { [EOL]                     break; [EOL]                 } [EOL]             } [EOL]             final int len = i - start; [EOL]             deleteImpl(start, i, len); [EOL]             i -= len; [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder deleteAll(final char ch) { [EOL]     for (int i = 0; i < size; i++) { [EOL]         if (buffer[i] == ch) { [EOL]             final int start = i; [EOL]             while (++i < size) { [EOL]                 if (buffer[i] != ch) { [EOL]                     break; [EOL]                 } [EOL]             } [EOL]             final int len = i - start; [EOL]             deleteImpl(start, i, len); [EOL]             i -= len; [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder deleteAll(final char ch) { [EOL]     for (int i = 0; i < size; i++) { [EOL]         if (buffer[i] == ch) { [EOL]             final int start = i; [EOL]             while (++i < size) { [EOL]                 if (buffer[i] != ch) { [EOL]                     break; [EOL]                 } [EOL]             } [EOL]             final int len = i - start; [EOL]             deleteImpl(start, i, len); [EOL]             i -= len; [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder deleteAll(final char ch) { [EOL]     for (int i = 0; i < size; i++) { [EOL]         if (buffer[i] == ch) { [EOL]             final int start = i; [EOL]             while (++i < size) { [EOL]                 if (buffer[i] != ch) { [EOL]                     break; [EOL]                 } [EOL]             } [EOL]             final int len = i - start; [EOL]             deleteImpl(start, i, len); [EOL]             i -= len; [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder deleteAll(final char ch) { [EOL]     for (int i = 0; i < size; i++) { [EOL]         if (buffer[i] == ch) { [EOL]             final int start = i; [EOL]             while (++i < size) { [EOL]                 if (buffer[i] != ch) { [EOL]                     break; [EOL]                 } [EOL]             } [EOL]             final int len = i - start; [EOL]             deleteImpl(start, i, len); [EOL]             i -= len; [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder deleteAll(final char ch) { [EOL]     for (int i = 0; i < size; i++) { [EOL]         if (buffer[i] == ch) { [EOL]             final int start = i; [EOL]             while (++i < size) { [EOL]                 if (buffer[i] != ch) { [EOL]                     break; [EOL]                 } [EOL]             } [EOL]             final int len = i - start; [EOL]             deleteImpl(start, i, len); [EOL]             i -= len; [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder deleteAll(final char ch) { [EOL]     for (int i = 0; i < size; i++) { [EOL]         if (buffer[i] == ch) { [EOL]             final int start = i; [EOL]             while (++i < size) { [EOL]                 if (buffer[i] != ch) { [EOL]                     break; [EOL]                 } [EOL]             } [EOL]             final int len = i - start; [EOL]             deleteImpl(start, i, len); [EOL]             i -= len; [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder deleteFirst(final String str) { [EOL]     final int len = (str == null ? 0 : str.length()); [EOL]     if (len > 0) { [EOL]         final int index = indexOf(str, 0); [EOL]         if (index >= 0) { [EOL]             deleteImpl(index, index + len, len); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder deleteFirst(final String str) { [EOL]     final int len = (str == null ? 0 : str.length()); [EOL]     if (len > 0) { [EOL]         final int index = indexOf(str, 0); [EOL]         if (index >= 0) { [EOL]             deleteImpl(index, index + len, len); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder deleteFirst(final String str) { [EOL]     final int len = (str == null ? 0 : str.length()); [EOL]     if (len > 0) { [EOL]         final int index = indexOf(str, 0); [EOL]         if (index >= 0) { [EOL]             deleteImpl(index, index + len, len); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder deleteFirst(final String str) { [EOL]     final int len = (str == null ? 0 : str.length()); [EOL]     if (len > 0) { [EOL]         final int index = indexOf(str, 0); [EOL]         if (index >= 0) { [EOL]             deleteImpl(index, index + len, len); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public String substring(final int start) { [EOL]     return substring(start, size); [EOL] }
public String substring(final int start) { [EOL]     return substring(start, size); [EOL] }
public String substring(final int start) { [EOL]     return substring(start, size); [EOL] }
public String substring(final int start) { [EOL]     return substring(start, size); [EOL] }
public String substring(final int start) { [EOL]     return substring(start, size); [EOL] }
public String leftString(final int length) { [EOL]     if (length <= 0) { [EOL]         return ""; [EOL]     } else if (length >= size) { [EOL]         return new String(buffer, 0, size); [EOL]     } else { [EOL]         return new String(buffer, 0, length); [EOL]     } [EOL] }
public String leftString(final int length) { [EOL]     if (length <= 0) { [EOL]         return ""; [EOL]     } else if (length >= size) { [EOL]         return new String(buffer, 0, size); [EOL]     } else { [EOL]         return new String(buffer, 0, length); [EOL]     } [EOL] }
public String leftString(final int length) { [EOL]     if (length <= 0) { [EOL]         return ""; [EOL]     } else if (length >= size) { [EOL]         return new String(buffer, 0, size); [EOL]     } else { [EOL]         return new String(buffer, 0, length); [EOL]     } [EOL] }
public boolean contains(final char ch) { [EOL]     final char[] thisBuf = buffer; [EOL]     for (int i = 0; i < this.size; i++) { [EOL]         if (thisBuf[i] == ch) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public boolean contains(final char ch) { [EOL]     final char[] thisBuf = buffer; [EOL]     for (int i = 0; i < this.size; i++) { [EOL]         if (thisBuf[i] == ch) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public int indexOf(final char ch) { [EOL]     return indexOf(ch, 0); [EOL] }
public int indexOf(final char ch) { [EOL]     return indexOf(ch, 0); [EOL] }
public int indexOf(final char ch) { [EOL]     return indexOf(ch, 0); [EOL] }
public int indexOf(final char ch, int startIndex) { [EOL]     startIndex = (startIndex < 0 ? 0 : startIndex); [EOL]     if (startIndex >= size) { [EOL]         return -1; [EOL]     } [EOL]     final char[] thisBuf = buffer; [EOL]     for (int i = startIndex; i < size; i++) { [EOL]         if (thisBuf[i] == ch) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return -1; [EOL] }
public int indexOf(final char ch, int startIndex) { [EOL]     startIndex = (startIndex < 0 ? 0 : startIndex); [EOL]     if (startIndex >= size) { [EOL]         return -1; [EOL]     } [EOL]     final char[] thisBuf = buffer; [EOL]     for (int i = startIndex; i < size; i++) { [EOL]         if (thisBuf[i] == ch) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return -1; [EOL] }
public int indexOf(final char ch, int startIndex) { [EOL]     startIndex = (startIndex < 0 ? 0 : startIndex); [EOL]     if (startIndex >= size) { [EOL]         return -1; [EOL]     } [EOL]     final char[] thisBuf = buffer; [EOL]     for (int i = startIndex; i < size; i++) { [EOL]         if (thisBuf[i] == ch) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return -1; [EOL] }
public int indexOf(final char ch, int startIndex) { [EOL]     startIndex = (startIndex < 0 ? 0 : startIndex); [EOL]     if (startIndex >= size) { [EOL]         return -1; [EOL]     } [EOL]     final char[] thisBuf = buffer; [EOL]     for (int i = startIndex; i < size; i++) { [EOL]         if (thisBuf[i] == ch) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return -1; [EOL] }
public int indexOf(final char ch, int startIndex) { [EOL]     startIndex = (startIndex < 0 ? 0 : startIndex); [EOL]     if (startIndex >= size) { [EOL]         return -1; [EOL]     } [EOL]     final char[] thisBuf = buffer; [EOL]     for (int i = startIndex; i < size; i++) { [EOL]         if (thisBuf[i] == ch) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return -1; [EOL] }
public int indexOf(final String str) { [EOL]     return indexOf(str, 0); [EOL] }
public int indexOf(final StrMatcher matcher, int startIndex) { [EOL]     startIndex = (startIndex < 0 ? 0 : startIndex); [EOL]     if (matcher == null || startIndex >= size) { [EOL]         return -1; [EOL]     } [EOL]     final int len = size; [EOL]     final char[] buf = buffer; [EOL]     for (int i = startIndex; i < len; i++) { [EOL]         if (matcher.isMatch(buf, i, startIndex, len) > 0) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return -1; [EOL] }
public int lastIndexOf(final StrMatcher matcher) { [EOL]     return lastIndexOf(matcher, size); [EOL] }
public int lastIndexOf(final StrMatcher matcher, int startIndex) { [EOL]     startIndex = (startIndex >= size ? size - 1 : startIndex); [EOL]     if (matcher == null || startIndex < 0) { [EOL]         return -1; [EOL]     } [EOL]     final char[] buf = buffer; [EOL]     final int endIndex = startIndex + 1; [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (matcher.isMatch(buf, i, 0, endIndex) > 0) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return -1; [EOL] }
public int lastIndexOf(final StrMatcher matcher, int startIndex) { [EOL]     startIndex = (startIndex >= size ? size - 1 : startIndex); [EOL]     if (matcher == null || startIndex < 0) { [EOL]         return -1; [EOL]     } [EOL]     final char[] buf = buffer; [EOL]     final int endIndex = startIndex + 1; [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (matcher.isMatch(buf, i, 0, endIndex) > 0) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return -1; [EOL] }
public int lastIndexOf(final StrMatcher matcher, int startIndex) { [EOL]     startIndex = (startIndex >= size ? size - 1 : startIndex); [EOL]     if (matcher == null || startIndex < 0) { [EOL]         return -1; [EOL]     } [EOL]     final char[] buf = buffer; [EOL]     final int endIndex = startIndex + 1; [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (matcher.isMatch(buf, i, 0, endIndex) > 0) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return -1; [EOL] }
public int lastIndexOf(final StrMatcher matcher, int startIndex) { [EOL]     startIndex = (startIndex >= size ? size - 1 : startIndex); [EOL]     if (matcher == null || startIndex < 0) { [EOL]         return -1; [EOL]     } [EOL]     final char[] buf = buffer; [EOL]     final int endIndex = startIndex + 1; [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (matcher.isMatch(buf, i, 0, endIndex) > 0) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return -1; [EOL] }
public StringBuilder toStringBuilder() { [EOL]     return new StringBuilder(size).append(buffer, 0, size); [EOL] }
public StringBuilder toStringBuilder() { [EOL]     return new StringBuilder(size).append(buffer, 0, size); [EOL] }
protected int validateRange(final int startIndex, int endIndex) { [EOL]     if (startIndex < 0) { [EOL]         throw new StringIndexOutOfBoundsException(startIndex); [EOL]     } [EOL]     if (endIndex > size) { [EOL]         endIndex = size; [EOL]     } [EOL]     if (startIndex > endIndex) { [EOL]         throw new StringIndexOutOfBoundsException("end < start"); [EOL]     } [EOL]     return endIndex; [EOL] }
public static FastDateFormat getDateInstance(final int style) { [EOL]     return cache.getDateInstance(style, null, null); [EOL] } protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale); protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getInstance(); public static FastDateFormat getInstance(final String pattern); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone); public static FastDateFormat getInstance(final String pattern, final Locale locale); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateInstance(final int style); public static FastDateFormat getDateInstance(final int style, final Locale locale); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getTimeInstance(final int style); public static FastDateFormat getTimeInstance(final int style, final Locale locale); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale); public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos); public String format(final long millis); public String format(final Date date); public String format(final Calendar calendar); public StringBuffer format(final long millis, final StringBuffer buf); public StringBuffer format(final Date date, final StringBuffer buf); public StringBuffer format(final Calendar calendar, final StringBuffer buf); public Date parse(final String source) throws ParseException; public Date parse(final String source, final ParsePosition pos); public Object parseObject(final String source, final ParsePosition pos); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale(); public int getMaxLengthEstimate(); public boolean equals(final Object obj); public int hashCode(); public String toString(); protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf); long serialVersionUID=Optional[2L]; int FULL=Optional[DateFormat.FULL]; int LONG=Optional[DateFormat.LONG]; int MEDIUM=Optional[DateFormat.MEDIUM]; int SHORT=Optional[DateFormat.SHORT]; FormatCache<FastDateFormat> cache=Optional[new FormatCache<FastDateFormat>() {; ;     @Override;     protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) {;         return new FastDateFormat(pattern, timeZone, locale);;     }; }
public static FastDateFormat getDateInstance(final int style) { [EOL]     return cache.getDateInstance(style, null, null); [EOL] } protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale); protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getInstance(); public static FastDateFormat getInstance(final String pattern); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone); public static FastDateFormat getInstance(final String pattern, final Locale locale); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateInstance(final int style); public static FastDateFormat getDateInstance(final int style, final Locale locale); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getTimeInstance(final int style); public static FastDateFormat getTimeInstance(final int style, final Locale locale); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale); public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos); public String format(final long millis); public String format(final Date date); public String format(final Calendar calendar); public StringBuffer format(final long millis, final StringBuffer buf); public StringBuffer format(final Date date, final StringBuffer buf); public StringBuffer format(final Calendar calendar, final StringBuffer buf); public Date parse(final String source) throws ParseException; public Date parse(final String source, final ParsePosition pos); public Object parseObject(final String source, final ParsePosition pos); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale(); public int getMaxLengthEstimate(); public boolean equals(final Object obj); public int hashCode(); public String toString(); protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf); long serialVersionUID=Optional[2L]; int FULL=Optional[DateFormat.FULL]; int LONG=Optional[DateFormat.LONG]; int MEDIUM=Optional[DateFormat.MEDIUM]; int SHORT=Optional[DateFormat.SHORT]; FormatCache<FastDateFormat> cache=Optional[new FormatCache<FastDateFormat>() {; ;     @Override;     protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) {;         return new FastDateFormat(pattern, timeZone, locale);;     }; }
public static FastDateFormat getDateInstance(final int style, final Locale locale) { [EOL]     return cache.getDateInstance(style, null, locale); [EOL] } protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale); protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getInstance(); public static FastDateFormat getInstance(final String pattern); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone); public static FastDateFormat getInstance(final String pattern, final Locale locale); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateInstance(final int style); public static FastDateFormat getDateInstance(final int style, final Locale locale); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getTimeInstance(final int style); public static FastDateFormat getTimeInstance(final int style, final Locale locale); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale); public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos); public String format(final long millis); public String format(final Date date); public String format(final Calendar calendar); public StringBuffer format(final long millis, final StringBuffer buf); public StringBuffer format(final Date date, final StringBuffer buf); public StringBuffer format(final Calendar calendar, final StringBuffer buf); public Date parse(final String source) throws ParseException; public Date parse(final String source, final ParsePosition pos); public Object parseObject(final String source, final ParsePosition pos); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale(); public int getMaxLengthEstimate(); public boolean equals(final Object obj); public int hashCode(); public String toString(); protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf); long serialVersionUID=Optional[2L]; int FULL=Optional[DateFormat.FULL]; int LONG=Optional[DateFormat.LONG]; int MEDIUM=Optional[DateFormat.MEDIUM]; int SHORT=Optional[DateFormat.SHORT]; FormatCache<FastDateFormat> cache=Optional[new FormatCache<FastDateFormat>() {; ;     @Override;     protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) {;         return new FastDateFormat(pattern, timeZone, locale);;     }; }
public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone) { [EOL]     return cache.getDateInstance(style, timeZone, null); [EOL] } protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale); protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getInstance(); public static FastDateFormat getInstance(final String pattern); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone); public static FastDateFormat getInstance(final String pattern, final Locale locale); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateInstance(final int style); public static FastDateFormat getDateInstance(final int style, final Locale locale); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getTimeInstance(final int style); public static FastDateFormat getTimeInstance(final int style, final Locale locale); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale); public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos); public String format(final long millis); public String format(final Date date); public String format(final Calendar calendar); public StringBuffer format(final long millis, final StringBuffer buf); public StringBuffer format(final Date date, final StringBuffer buf); public StringBuffer format(final Calendar calendar, final StringBuffer buf); public Date parse(final String source) throws ParseException; public Date parse(final String source, final ParsePosition pos); public Object parseObject(final String source, final ParsePosition pos); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale(); public int getMaxLengthEstimate(); public boolean equals(final Object obj); public int hashCode(); public String toString(); protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf); long serialVersionUID=Optional[2L]; int FULL=Optional[DateFormat.FULL]; int LONG=Optional[DateFormat.LONG]; int MEDIUM=Optional[DateFormat.MEDIUM]; int SHORT=Optional[DateFormat.SHORT]; FormatCache<FastDateFormat> cache=Optional[new FormatCache<FastDateFormat>() {; ;     @Override;     protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) {;         return new FastDateFormat(pattern, timeZone, locale);;     }; }
public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone) { [EOL]     return cache.getDateInstance(style, timeZone, null); [EOL] } protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale); protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getInstance(); public static FastDateFormat getInstance(final String pattern); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone); public static FastDateFormat getInstance(final String pattern, final Locale locale); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateInstance(final int style); public static FastDateFormat getDateInstance(final int style, final Locale locale); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getTimeInstance(final int style); public static FastDateFormat getTimeInstance(final int style, final Locale locale); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale); public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos); public String format(final long millis); public String format(final Date date); public String format(final Calendar calendar); public StringBuffer format(final long millis, final StringBuffer buf); public StringBuffer format(final Date date, final StringBuffer buf); public StringBuffer format(final Calendar calendar, final StringBuffer buf); public Date parse(final String source) throws ParseException; public Date parse(final String source, final ParsePosition pos); public Object parseObject(final String source, final ParsePosition pos); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale(); public int getMaxLengthEstimate(); public boolean equals(final Object obj); public int hashCode(); public String toString(); protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf); long serialVersionUID=Optional[2L]; int FULL=Optional[DateFormat.FULL]; int LONG=Optional[DateFormat.LONG]; int MEDIUM=Optional[DateFormat.MEDIUM]; int SHORT=Optional[DateFormat.SHORT]; FormatCache<FastDateFormat> cache=Optional[new FormatCache<FastDateFormat>() {; ;     @Override;     protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) {;         return new FastDateFormat(pattern, timeZone, locale);;     }; }
public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale) { [EOL]     return cache.getDateInstance(style, timeZone, locale); [EOL] } protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale); protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getInstance(); public static FastDateFormat getInstance(final String pattern); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone); public static FastDateFormat getInstance(final String pattern, final Locale locale); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateInstance(final int style); public static FastDateFormat getDateInstance(final int style, final Locale locale); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getTimeInstance(final int style); public static FastDateFormat getTimeInstance(final int style, final Locale locale); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale); public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos); public String format(final long millis); public String format(final Date date); public String format(final Calendar calendar); public StringBuffer format(final long millis, final StringBuffer buf); public StringBuffer format(final Date date, final StringBuffer buf); public StringBuffer format(final Calendar calendar, final StringBuffer buf); public Date parse(final String source) throws ParseException; public Date parse(final String source, final ParsePosition pos); public Object parseObject(final String source, final ParsePosition pos); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale(); public int getMaxLengthEstimate(); public boolean equals(final Object obj); public int hashCode(); public String toString(); protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf); long serialVersionUID=Optional[2L]; int FULL=Optional[DateFormat.FULL]; int LONG=Optional[DateFormat.LONG]; int MEDIUM=Optional[DateFormat.MEDIUM]; int SHORT=Optional[DateFormat.SHORT]; FormatCache<FastDateFormat> cache=Optional[new FormatCache<FastDateFormat>() {; ;     @Override;     protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) {;         return new FastDateFormat(pattern, timeZone, locale);;     }; }
public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale) { [EOL]     return cache.getDateInstance(style, timeZone, locale); [EOL] } protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale); protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getInstance(); public static FastDateFormat getInstance(final String pattern); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone); public static FastDateFormat getInstance(final String pattern, final Locale locale); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateInstance(final int style); public static FastDateFormat getDateInstance(final int style, final Locale locale); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getTimeInstance(final int style); public static FastDateFormat getTimeInstance(final int style, final Locale locale); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale); public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos); public String format(final long millis); public String format(final Date date); public String format(final Calendar calendar); public StringBuffer format(final long millis, final StringBuffer buf); public StringBuffer format(final Date date, final StringBuffer buf); public StringBuffer format(final Calendar calendar, final StringBuffer buf); public Date parse(final String source) throws ParseException; public Date parse(final String source, final ParsePosition pos); public Object parseObject(final String source, final ParsePosition pos); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale(); public int getMaxLengthEstimate(); public boolean equals(final Object obj); public int hashCode(); public String toString(); protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf); long serialVersionUID=Optional[2L]; int FULL=Optional[DateFormat.FULL]; int LONG=Optional[DateFormat.LONG]; int MEDIUM=Optional[DateFormat.MEDIUM]; int SHORT=Optional[DateFormat.SHORT]; FormatCache<FastDateFormat> cache=Optional[new FormatCache<FastDateFormat>() {; ;     @Override;     protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) {;         return new FastDateFormat(pattern, timeZone, locale);;     }; }
public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale) { [EOL]     return cache.getDateInstance(style, timeZone, locale); [EOL] } protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale); protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getInstance(); public static FastDateFormat getInstance(final String pattern); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone); public static FastDateFormat getInstance(final String pattern, final Locale locale); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateInstance(final int style); public static FastDateFormat getDateInstance(final int style, final Locale locale); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getTimeInstance(final int style); public static FastDateFormat getTimeInstance(final int style, final Locale locale); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale); public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos); public String format(final long millis); public String format(final Date date); public String format(final Calendar calendar); public StringBuffer format(final long millis, final StringBuffer buf); public StringBuffer format(final Date date, final StringBuffer buf); public StringBuffer format(final Calendar calendar, final StringBuffer buf); public Date parse(final String source) throws ParseException; public Date parse(final String source, final ParsePosition pos); public Object parseObject(final String source, final ParsePosition pos); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale(); public int getMaxLengthEstimate(); public boolean equals(final Object obj); public int hashCode(); public String toString(); protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf); long serialVersionUID=Optional[2L]; int FULL=Optional[DateFormat.FULL]; int LONG=Optional[DateFormat.LONG]; int MEDIUM=Optional[DateFormat.MEDIUM]; int SHORT=Optional[DateFormat.SHORT]; FormatCache<FastDateFormat> cache=Optional[new FormatCache<FastDateFormat>() {; ;     @Override;     protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) {;         return new FastDateFormat(pattern, timeZone, locale);;     }; }
public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale) { [EOL]     return cache.getDateInstance(style, timeZone, locale); [EOL] } protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale); protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getInstance(); public static FastDateFormat getInstance(final String pattern); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone); public static FastDateFormat getInstance(final String pattern, final Locale locale); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateInstance(final int style); public static FastDateFormat getDateInstance(final int style, final Locale locale); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getTimeInstance(final int style); public static FastDateFormat getTimeInstance(final int style, final Locale locale); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale); public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos); public String format(final long millis); public String format(final Date date); public String format(final Calendar calendar); public StringBuffer format(final long millis, final StringBuffer buf); public StringBuffer format(final Date date, final StringBuffer buf); public StringBuffer format(final Calendar calendar, final StringBuffer buf); public Date parse(final String source) throws ParseException; public Date parse(final String source, final ParsePosition pos); public Object parseObject(final String source, final ParsePosition pos); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale(); public int getMaxLengthEstimate(); public boolean equals(final Object obj); public int hashCode(); public String toString(); protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf); long serialVersionUID=Optional[2L]; int FULL=Optional[DateFormat.FULL]; int LONG=Optional[DateFormat.LONG]; int MEDIUM=Optional[DateFormat.MEDIUM]; int SHORT=Optional[DateFormat.SHORT]; FormatCache<FastDateFormat> cache=Optional[new FormatCache<FastDateFormat>() {; ;     @Override;     protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) {;         return new FastDateFormat(pattern, timeZone, locale);;     }; }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj instanceof FastDateFormat == false) { [EOL]         return false; [EOL]     } [EOL]     final FastDateFormat other = (FastDateFormat) obj; [EOL]     return printer.equals(other.printer); [EOL] } protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale); protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getInstance(); public static FastDateFormat getInstance(final String pattern); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone); public static FastDateFormat getInstance(final String pattern, final Locale locale); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateInstance(final int style); public static FastDateFormat getDateInstance(final int style, final Locale locale); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getTimeInstance(final int style); public static FastDateFormat getTimeInstance(final int style, final Locale locale); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale); public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos); public String format(final long millis); public String format(final Date date); public String format(final Calendar calendar); public StringBuffer format(final long millis, final StringBuffer buf); public StringBuffer format(final Date date, final StringBuffer buf); public StringBuffer format(final Calendar calendar, final StringBuffer buf); public Date parse(final String source) throws ParseException; public Date parse(final String source, final ParsePosition pos); public Object parseObject(final String source, final ParsePosition pos); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale(); public int getMaxLengthEstimate(); public boolean equals(final Object obj); public int hashCode(); public String toString(); protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf); long serialVersionUID=Optional[2L]; int FULL=Optional[DateFormat.FULL]; int LONG=Optional[DateFormat.LONG]; int MEDIUM=Optional[DateFormat.MEDIUM]; int SHORT=Optional[DateFormat.SHORT]; FormatCache<FastDateFormat> cache=Optional[new FormatCache<FastDateFormat>() {; ;     @Override;     protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) {;         return new FastDateFormat(pattern, timeZone, locale);;     }; }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj instanceof FastDateFormat == false) { [EOL]         return false; [EOL]     } [EOL]     final FastDateFormat other = (FastDateFormat) obj; [EOL]     return printer.equals(other.printer); [EOL] } protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale); protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getInstance(); public static FastDateFormat getInstance(final String pattern); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone); public static FastDateFormat getInstance(final String pattern, final Locale locale); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateInstance(final int style); public static FastDateFormat getDateInstance(final int style, final Locale locale); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getTimeInstance(final int style); public static FastDateFormat getTimeInstance(final int style, final Locale locale); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale); public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos); public String format(final long millis); public String format(final Date date); public String format(final Calendar calendar); public StringBuffer format(final long millis, final StringBuffer buf); public StringBuffer format(final Date date, final StringBuffer buf); public StringBuffer format(final Calendar calendar, final StringBuffer buf); public Date parse(final String source) throws ParseException; public Date parse(final String source, final ParsePosition pos); public Object parseObject(final String source, final ParsePosition pos); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale(); public int getMaxLengthEstimate(); public boolean equals(final Object obj); public int hashCode(); public String toString(); protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf); long serialVersionUID=Optional[2L]; int FULL=Optional[DateFormat.FULL]; int LONG=Optional[DateFormat.LONG]; int MEDIUM=Optional[DateFormat.MEDIUM]; int SHORT=Optional[DateFormat.SHORT]; FormatCache<FastDateFormat> cache=Optional[new FormatCache<FastDateFormat>() {; ;     @Override;     protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) {;         return new FastDateFormat(pattern, timeZone, locale);;     }; }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj instanceof FastDateFormat == false) { [EOL]         return false; [EOL]     } [EOL]     final FastDateFormat other = (FastDateFormat) obj; [EOL]     return printer.equals(other.printer); [EOL] } protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale); protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getInstance(); public static FastDateFormat getInstance(final String pattern); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone); public static FastDateFormat getInstance(final String pattern, final Locale locale); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateInstance(final int style); public static FastDateFormat getDateInstance(final int style, final Locale locale); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getTimeInstance(final int style); public static FastDateFormat getTimeInstance(final int style, final Locale locale); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale); public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos); public String format(final long millis); public String format(final Date date); public String format(final Calendar calendar); public StringBuffer format(final long millis, final StringBuffer buf); public StringBuffer format(final Date date, final StringBuffer buf); public StringBuffer format(final Calendar calendar, final StringBuffer buf); public Date parse(final String source) throws ParseException; public Date parse(final String source, final ParsePosition pos); public Object parseObject(final String source, final ParsePosition pos); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale(); public int getMaxLengthEstimate(); public boolean equals(final Object obj); public int hashCode(); public String toString(); protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf); long serialVersionUID=Optional[2L]; int FULL=Optional[DateFormat.FULL]; int LONG=Optional[DateFormat.LONG]; int MEDIUM=Optional[DateFormat.MEDIUM]; int SHORT=Optional[DateFormat.SHORT]; FormatCache<FastDateFormat> cache=Optional[new FormatCache<FastDateFormat>() {; ;     @Override;     protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) {;         return new FastDateFormat(pattern, timeZone, locale);;     }; }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj instanceof FastDateFormat == false) { [EOL]         return false; [EOL]     } [EOL]     final FastDateFormat other = (FastDateFormat) obj; [EOL]     return printer.equals(other.printer); [EOL] } protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale); protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getInstance(); public static FastDateFormat getInstance(final String pattern); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone); public static FastDateFormat getInstance(final String pattern, final Locale locale); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateInstance(final int style); public static FastDateFormat getDateInstance(final int style, final Locale locale); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getTimeInstance(final int style); public static FastDateFormat getTimeInstance(final int style, final Locale locale); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale); public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos); public String format(final long millis); public String format(final Date date); public String format(final Calendar calendar); public StringBuffer format(final long millis, final StringBuffer buf); public StringBuffer format(final Date date, final StringBuffer buf); public StringBuffer format(final Calendar calendar, final StringBuffer buf); public Date parse(final String source) throws ParseException; public Date parse(final String source, final ParsePosition pos); public Object parseObject(final String source, final ParsePosition pos); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale(); public int getMaxLengthEstimate(); public boolean equals(final Object obj); public int hashCode(); public String toString(); protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf); long serialVersionUID=Optional[2L]; int FULL=Optional[DateFormat.FULL]; int LONG=Optional[DateFormat.LONG]; int MEDIUM=Optional[DateFormat.MEDIUM]; int SHORT=Optional[DateFormat.SHORT]; FormatCache<FastDateFormat> cache=Optional[new FormatCache<FastDateFormat>() {; ;     @Override;     protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) {;         return new FastDateFormat(pattern, timeZone, locale);;     }; }
@Override [EOL] public int hashCode() { [EOL]     return printer.hashCode(); [EOL] } protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale); protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getInstance(); public static FastDateFormat getInstance(final String pattern); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone); public static FastDateFormat getInstance(final String pattern, final Locale locale); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateInstance(final int style); public static FastDateFormat getDateInstance(final int style, final Locale locale); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getTimeInstance(final int style); public static FastDateFormat getTimeInstance(final int style, final Locale locale); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale); public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos); public String format(final long millis); public String format(final Date date); public String format(final Calendar calendar); public StringBuffer format(final long millis, final StringBuffer buf); public StringBuffer format(final Date date, final StringBuffer buf); public StringBuffer format(final Calendar calendar, final StringBuffer buf); public Date parse(final String source) throws ParseException; public Date parse(final String source, final ParsePosition pos); public Object parseObject(final String source, final ParsePosition pos); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale(); public int getMaxLengthEstimate(); public boolean equals(final Object obj); public int hashCode(); public String toString(); protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf); long serialVersionUID=Optional[2L]; int FULL=Optional[DateFormat.FULL]; int LONG=Optional[DateFormat.LONG]; int MEDIUM=Optional[DateFormat.MEDIUM]; int SHORT=Optional[DateFormat.SHORT]; FormatCache<FastDateFormat> cache=Optional[new FormatCache<FastDateFormat>() {; ;     @Override;     protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) {;         return new FastDateFormat(pattern, timeZone, locale);;     }; }
public static File getJavaIoTmpDir() { [EOL]     return new File(System.getProperty(JAVA_IO_TMPDIR_KEY)); [EOL] }
public SystemUtils() { [EOL]     super(); [EOL] }
public static Field getField(final Class<?> cls, final String fieldName, final boolean forceAccess) { [EOL]     if (cls == null) { [EOL]         throw new IllegalArgumentException("The class must not be null"); [EOL]     } [EOL]     if (fieldName == null) { [EOL]         throw new IllegalArgumentException("The field name must not be null"); [EOL]     } [EOL]     for (Class<?> acls = cls; acls != null; acls = acls.getSuperclass()) { [EOL]         try { [EOL]             final Field field = acls.getDeclaredField(fieldName); [EOL]             if (!Modifier.isPublic(field.getModifiers())) { [EOL]                 if (forceAccess) { [EOL]                     field.setAccessible(true); [EOL]                 } else { [EOL]                     continue; [EOL]                 } [EOL]             } [EOL]             return field; [EOL]         } catch (final NoSuchFieldException ex) { [EOL]         } [EOL]     } [EOL]     Field match = null; [EOL]     for (final Class<?> class1 : ClassUtils.getAllInterfaces(cls)) { [EOL]         try { [EOL]             final Field test = ((Class<?>) class1).getField(fieldName); [EOL]             if (match != null) { [EOL]                 throw new IllegalArgumentException("Reference to field " + fieldName + " is ambiguous relative to " + cls + "; a matching field exists on two or more implemented interfaces."); [EOL]             } [EOL]             match = test; [EOL]         } catch (final NoSuchFieldException ex) { [EOL]         } [EOL]     } [EOL]     return match; [EOL] }
public static Field getField(final Class<?> cls, final String fieldName, final boolean forceAccess) { [EOL]     if (cls == null) { [EOL]         throw new IllegalArgumentException("The class must not be null"); [EOL]     } [EOL]     if (fieldName == null) { [EOL]         throw new IllegalArgumentException("The field name must not be null"); [EOL]     } [EOL]     for (Class<?> acls = cls; acls != null; acls = acls.getSuperclass()) { [EOL]         try { [EOL]             final Field field = acls.getDeclaredField(fieldName); [EOL]             if (!Modifier.isPublic(field.getModifiers())) { [EOL]                 if (forceAccess) { [EOL]                     field.setAccessible(true); [EOL]                 } else { [EOL]                     continue; [EOL]                 } [EOL]             } [EOL]             return field; [EOL]         } catch (final NoSuchFieldException ex) { [EOL]         } [EOL]     } [EOL]     Field match = null; [EOL]     for (final Class<?> class1 : ClassUtils.getAllInterfaces(cls)) { [EOL]         try { [EOL]             final Field test = ((Class<?>) class1).getField(fieldName); [EOL]             if (match != null) { [EOL]                 throw new IllegalArgumentException("Reference to field " + fieldName + " is ambiguous relative to " + cls + "; a matching field exists on two or more implemented interfaces."); [EOL]             } [EOL]             match = test; [EOL]         } catch (final NoSuchFieldException ex) { [EOL]         } [EOL]     } [EOL]     return match; [EOL] }
public static Field getField(final Class<?> cls, final String fieldName, final boolean forceAccess) { [EOL]     if (cls == null) { [EOL]         throw new IllegalArgumentException("The class must not be null"); [EOL]     } [EOL]     if (fieldName == null) { [EOL]         throw new IllegalArgumentException("The field name must not be null"); [EOL]     } [EOL]     for (Class<?> acls = cls; acls != null; acls = acls.getSuperclass()) { [EOL]         try { [EOL]             final Field field = acls.getDeclaredField(fieldName); [EOL]             if (!Modifier.isPublic(field.getModifiers())) { [EOL]                 if (forceAccess) { [EOL]                     field.setAccessible(true); [EOL]                 } else { [EOL]                     continue; [EOL]                 } [EOL]             } [EOL]             return field; [EOL]         } catch (final NoSuchFieldException ex) { [EOL]         } [EOL]     } [EOL]     Field match = null; [EOL]     for (final Class<?> class1 : ClassUtils.getAllInterfaces(cls)) { [EOL]         try { [EOL]             final Field test = ((Class<?>) class1).getField(fieldName); [EOL]             if (match != null) { [EOL]                 throw new IllegalArgumentException("Reference to field " + fieldName + " is ambiguous relative to " + cls + "; a matching field exists on two or more implemented interfaces."); [EOL]             } [EOL]             match = test; [EOL]         } catch (final NoSuchFieldException ex) { [EOL]         } [EOL]     } [EOL]     return match; [EOL] }
public static Field getField(final Class<?> cls, final String fieldName, final boolean forceAccess) { [EOL]     if (cls == null) { [EOL]         throw new IllegalArgumentException("The class must not be null"); [EOL]     } [EOL]     if (fieldName == null) { [EOL]         throw new IllegalArgumentException("The field name must not be null"); [EOL]     } [EOL]     for (Class<?> acls = cls; acls != null; acls = acls.getSuperclass()) { [EOL]         try { [EOL]             final Field field = acls.getDeclaredField(fieldName); [EOL]             if (!Modifier.isPublic(field.getModifiers())) { [EOL]                 if (forceAccess) { [EOL]                     field.setAccessible(true); [EOL]                 } else { [EOL]                     continue; [EOL]                 } [EOL]             } [EOL]             return field; [EOL]         } catch (final NoSuchFieldException ex) { [EOL]         } [EOL]     } [EOL]     Field match = null; [EOL]     for (final Class<?> class1 : ClassUtils.getAllInterfaces(cls)) { [EOL]         try { [EOL]             final Field test = ((Class<?>) class1).getField(fieldName); [EOL]             if (match != null) { [EOL]                 throw new IllegalArgumentException("Reference to field " + fieldName + " is ambiguous relative to " + cls + "; a matching field exists on two or more implemented interfaces."); [EOL]             } [EOL]             match = test; [EOL]         } catch (final NoSuchFieldException ex) { [EOL]         } [EOL]     } [EOL]     return match; [EOL] }
public static Field getField(final Class<?> cls, final String fieldName, final boolean forceAccess) { [EOL]     if (cls == null) { [EOL]         throw new IllegalArgumentException("The class must not be null"); [EOL]     } [EOL]     if (fieldName == null) { [EOL]         throw new IllegalArgumentException("The field name must not be null"); [EOL]     } [EOL]     for (Class<?> acls = cls; acls != null; acls = acls.getSuperclass()) { [EOL]         try { [EOL]             final Field field = acls.getDeclaredField(fieldName); [EOL]             if (!Modifier.isPublic(field.getModifiers())) { [EOL]                 if (forceAccess) { [EOL]                     field.setAccessible(true); [EOL]                 } else { [EOL]                     continue; [EOL]                 } [EOL]             } [EOL]             return field; [EOL]         } catch (final NoSuchFieldException ex) { [EOL]         } [EOL]     } [EOL]     Field match = null; [EOL]     for (final Class<?> class1 : ClassUtils.getAllInterfaces(cls)) { [EOL]         try { [EOL]             final Field test = ((Class<?>) class1).getField(fieldName); [EOL]             if (match != null) { [EOL]                 throw new IllegalArgumentException("Reference to field " + fieldName + " is ambiguous relative to " + cls + "; a matching field exists on two or more implemented interfaces."); [EOL]             } [EOL]             match = test; [EOL]         } catch (final NoSuchFieldException ex) { [EOL]         } [EOL]     } [EOL]     return match; [EOL] }
public static Field getField(final Class<?> cls, final String fieldName, final boolean forceAccess) { [EOL]     if (cls == null) { [EOL]         throw new IllegalArgumentException("The class must not be null"); [EOL]     } [EOL]     if (fieldName == null) { [EOL]         throw new IllegalArgumentException("The field name must not be null"); [EOL]     } [EOL]     for (Class<?> acls = cls; acls != null; acls = acls.getSuperclass()) { [EOL]         try { [EOL]             final Field field = acls.getDeclaredField(fieldName); [EOL]             if (!Modifier.isPublic(field.getModifiers())) { [EOL]                 if (forceAccess) { [EOL]                     field.setAccessible(true); [EOL]                 } else { [EOL]                     continue; [EOL]                 } [EOL]             } [EOL]             return field; [EOL]         } catch (final NoSuchFieldException ex) { [EOL]         } [EOL]     } [EOL]     Field match = null; [EOL]     for (final Class<?> class1 : ClassUtils.getAllInterfaces(cls)) { [EOL]         try { [EOL]             final Field test = ((Class<?>) class1).getField(fieldName); [EOL]             if (match != null) { [EOL]                 throw new IllegalArgumentException("Reference to field " + fieldName + " is ambiguous relative to " + cls + "; a matching field exists on two or more implemented interfaces."); [EOL]             } [EOL]             match = test; [EOL]         } catch (final NoSuchFieldException ex) { [EOL]         } [EOL]     } [EOL]     return match; [EOL] }
public static Field getField(final Class<?> cls, final String fieldName, final boolean forceAccess) { [EOL]     if (cls == null) { [EOL]         throw new IllegalArgumentException("The class must not be null"); [EOL]     } [EOL]     if (fieldName == null) { [EOL]         throw new IllegalArgumentException("The field name must not be null"); [EOL]     } [EOL]     for (Class<?> acls = cls; acls != null; acls = acls.getSuperclass()) { [EOL]         try { [EOL]             final Field field = acls.getDeclaredField(fieldName); [EOL]             if (!Modifier.isPublic(field.getModifiers())) { [EOL]                 if (forceAccess) { [EOL]                     field.setAccessible(true); [EOL]                 } else { [EOL]                     continue; [EOL]                 } [EOL]             } [EOL]             return field; [EOL]         } catch (final NoSuchFieldException ex) { [EOL]         } [EOL]     } [EOL]     Field match = null; [EOL]     for (final Class<?> class1 : ClassUtils.getAllInterfaces(cls)) { [EOL]         try { [EOL]             final Field test = ((Class<?>) class1).getField(fieldName); [EOL]             if (match != null) { [EOL]                 throw new IllegalArgumentException("Reference to field " + fieldName + " is ambiguous relative to " + cls + "; a matching field exists on two or more implemented interfaces."); [EOL]             } [EOL]             match = test; [EOL]         } catch (final NoSuchFieldException ex) { [EOL]         } [EOL]     } [EOL]     return match; [EOL] }
public static Field getDeclaredField(final Class<?> cls, final String fieldName) { [EOL]     return getDeclaredField(cls, fieldName, false); [EOL] }
public static Field getDeclaredField(final Class<?> cls, final String fieldName) { [EOL]     return getDeclaredField(cls, fieldName, false); [EOL] }
public static Field getDeclaredField(final Class<?> cls, final String fieldName) { [EOL]     return getDeclaredField(cls, fieldName, false); [EOL] }
public static Field getDeclaredField(final Class<?> cls, final String fieldName) { [EOL]     return getDeclaredField(cls, fieldName, false); [EOL] }
public static List<Field> getAllFieldsList(Class<?> cls) { [EOL]     if (cls == null) { [EOL]         throw new IllegalArgumentException("The class must not be null"); [EOL]     } [EOL]     List<Field> allFields = new ArrayList<Field>(); [EOL]     Class<?> currentClass = cls; [EOL]     while (currentClass != null) { [EOL]         final Field[] declaredFields = currentClass.getDeclaredFields(); [EOL]         for (Field field : declaredFields) { [EOL]             allFields.add(field); [EOL]         } [EOL]         currentClass = currentClass.getSuperclass(); [EOL]     } [EOL]     return allFields; [EOL] }
public static List<Field> getAllFieldsList(Class<?> cls) { [EOL]     if (cls == null) { [EOL]         throw new IllegalArgumentException("The class must not be null"); [EOL]     } [EOL]     List<Field> allFields = new ArrayList<Field>(); [EOL]     Class<?> currentClass = cls; [EOL]     while (currentClass != null) { [EOL]         final Field[] declaredFields = currentClass.getDeclaredFields(); [EOL]         for (Field field : declaredFields) { [EOL]             allFields.add(field); [EOL]         } [EOL]         currentClass = currentClass.getSuperclass(); [EOL]     } [EOL]     return allFields; [EOL] }
public static List<Field> getAllFieldsList(Class<?> cls) { [EOL]     if (cls == null) { [EOL]         throw new IllegalArgumentException("The class must not be null"); [EOL]     } [EOL]     List<Field> allFields = new ArrayList<Field>(); [EOL]     Class<?> currentClass = cls; [EOL]     while (currentClass != null) { [EOL]         final Field[] declaredFields = currentClass.getDeclaredFields(); [EOL]         for (Field field : declaredFields) { [EOL]             allFields.add(field); [EOL]         } [EOL]         currentClass = currentClass.getSuperclass(); [EOL]     } [EOL]     return allFields; [EOL] }
public static List<Field> getAllFieldsList(Class<?> cls) { [EOL]     if (cls == null) { [EOL]         throw new IllegalArgumentException("The class must not be null"); [EOL]     } [EOL]     List<Field> allFields = new ArrayList<Field>(); [EOL]     Class<?> currentClass = cls; [EOL]     while (currentClass != null) { [EOL]         final Field[] declaredFields = currentClass.getDeclaredFields(); [EOL]         for (Field field : declaredFields) { [EOL]             allFields.add(field); [EOL]         } [EOL]         currentClass = currentClass.getSuperclass(); [EOL]     } [EOL]     return allFields; [EOL] }
public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException { [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("The field must not be null"); [EOL]     } [EOL]     if (!Modifier.isStatic(field.getModifiers())) { [EOL]         throw new IllegalArgumentException("The field '" + field.getName() + "' is not static"); [EOL]     } [EOL]     return readField(field, (Object) null, forceAccess); [EOL] }
public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException { [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("The field must not be null"); [EOL]     } [EOL]     if (!Modifier.isStatic(field.getModifiers())) { [EOL]         throw new IllegalArgumentException("The field '" + field.getName() + "' is not static"); [EOL]     } [EOL]     return readField(field, (Object) null, forceAccess); [EOL] }
public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException { [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("The field must not be null"); [EOL]     } [EOL]     if (!Modifier.isStatic(field.getModifiers())) { [EOL]         throw new IllegalArgumentException("The field '" + field.getName() + "' is not static"); [EOL]     } [EOL]     return readField(field, (Object) null, forceAccess); [EOL] }
public static Object readField(final Field field, final Object target, final boolean forceAccess) throws IllegalAccessException { [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("The field must not be null"); [EOL]     } [EOL]     if (forceAccess && !field.isAccessible()) { [EOL]         field.setAccessible(true); [EOL]     } else { [EOL]         MemberUtils.setAccessibleWorkaround(field); [EOL]     } [EOL]     return field.get(target); [EOL] }
public static Object readField(final Field field, final Object target, final boolean forceAccess) throws IllegalAccessException { [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("The field must not be null"); [EOL]     } [EOL]     if (forceAccess && !field.isAccessible()) { [EOL]         field.setAccessible(true); [EOL]     } else { [EOL]         MemberUtils.setAccessibleWorkaround(field); [EOL]     } [EOL]     return field.get(target); [EOL] }
public static Object readField(final Field field, final Object target, final boolean forceAccess) throws IllegalAccessException { [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("The field must not be null"); [EOL]     } [EOL]     if (forceAccess && !field.isAccessible()) { [EOL]         field.setAccessible(true); [EOL]     } else { [EOL]         MemberUtils.setAccessibleWorkaround(field); [EOL]     } [EOL]     return field.get(target); [EOL] }
public static void writeStaticField(final Field field, final Object value) throws IllegalAccessException { [EOL]     writeStaticField(field, value, false); [EOL] }
public static void writeStaticField(final Field field, final Object value, final boolean forceAccess) throws IllegalAccessException { [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("The field must not be null"); [EOL]     } [EOL]     if (!Modifier.isStatic(field.getModifiers())) { [EOL]         throw new IllegalArgumentException("The field '" + field.getName() + "' is not static"); [EOL]     } [EOL]     writeField(field, (Object) null, value, forceAccess); [EOL] }
public static void writeStaticField(final Class<?> cls, final String fieldName, final Object value) throws IllegalAccessException { [EOL]     writeStaticField(cls, fieldName, value, false); [EOL] }
public static void writeStaticField(final Class<?> cls, final String fieldName, final Object value) throws IllegalAccessException { [EOL]     writeStaticField(cls, fieldName, value, false); [EOL] }
public static void writeStaticField(final Class<?> cls, final String fieldName, final Object value) throws IllegalAccessException { [EOL]     writeStaticField(cls, fieldName, value, false); [EOL] }
public static void writeStaticField(final Class<?> cls, final String fieldName, final Object value) throws IllegalAccessException { [EOL]     writeStaticField(cls, fieldName, value, false); [EOL] }
public static void writeStaticField(final Class<?> cls, final String fieldName, final Object value, final boolean forceAccess) throws IllegalAccessException { [EOL]     final Field field = getField(cls, fieldName, forceAccess); [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("Cannot locate field " + fieldName + " on " + cls); [EOL]     } [EOL]     writeStaticField(field, value); [EOL] }
public static void writeStaticField(final Class<?> cls, final String fieldName, final Object value, final boolean forceAccess) throws IllegalAccessException { [EOL]     final Field field = getField(cls, fieldName, forceAccess); [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("Cannot locate field " + fieldName + " on " + cls); [EOL]     } [EOL]     writeStaticField(field, value); [EOL] }
public static void writeField(final Field field, final Object target, final Object value, final boolean forceAccess) throws IllegalAccessException { [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("The field must not be null"); [EOL]     } [EOL]     if (forceAccess && !field.isAccessible()) { [EOL]         field.setAccessible(true); [EOL]     } else { [EOL]         MemberUtils.setAccessibleWorkaround(field); [EOL]     } [EOL]     field.set(target, value); [EOL] }
public static void writeField(final Field field, final Object target, final Object value, final boolean forceAccess) throws IllegalAccessException { [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("The field must not be null"); [EOL]     } [EOL]     if (forceAccess && !field.isAccessible()) { [EOL]         field.setAccessible(true); [EOL]     } else { [EOL]         MemberUtils.setAccessibleWorkaround(field); [EOL]     } [EOL]     field.set(target, value); [EOL] }
public static void writeField(final Field field, final Object target, final Object value, final boolean forceAccess) throws IllegalAccessException { [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("The field must not be null"); [EOL]     } [EOL]     if (forceAccess && !field.isAccessible()) { [EOL]         field.setAccessible(true); [EOL]     } else { [EOL]         MemberUtils.setAccessibleWorkaround(field); [EOL]     } [EOL]     field.set(target, value); [EOL] }
protected void add(final String str) { [EOL]     if (str == null) { [EOL]         return; [EOL]     } [EOL]     final int len = str.length(); [EOL]     int pos = 0; [EOL]     while (pos < len) { [EOL]         final int remainder = len - pos; [EOL]         if (remainder >= 4 && str.charAt(pos) == '^' && str.charAt(pos + 2) == '-') { [EOL]             set.add(CharRange.isNotIn(str.charAt(pos + 1), str.charAt(pos + 3))); [EOL]             pos += 4; [EOL]         } else if (remainder >= 3 && str.charAt(pos + 1) == '-') { [EOL]             set.add(CharRange.isIn(str.charAt(pos), str.charAt(pos + 2))); [EOL]             pos += 3; [EOL]         } else if (remainder >= 2 && str.charAt(pos) == '^') { [EOL]             set.add(CharRange.isNot(str.charAt(pos + 1))); [EOL]             pos += 2; [EOL]         } else { [EOL]             set.add(CharRange.is(str.charAt(pos))); [EOL]             pos += 1; [EOL]         } [EOL]     } [EOL] }
protected void add(final String str) { [EOL]     if (str == null) { [EOL]         return; [EOL]     } [EOL]     final int len = str.length(); [EOL]     int pos = 0; [EOL]     while (pos < len) { [EOL]         final int remainder = len - pos; [EOL]         if (remainder >= 4 && str.charAt(pos) == '^' && str.charAt(pos + 2) == '-') { [EOL]             set.add(CharRange.isNotIn(str.charAt(pos + 1), str.charAt(pos + 3))); [EOL]             pos += 4; [EOL]         } else if (remainder >= 3 && str.charAt(pos + 1) == '-') { [EOL]             set.add(CharRange.isIn(str.charAt(pos), str.charAt(pos + 2))); [EOL]             pos += 3; [EOL]         } else if (remainder >= 2 && str.charAt(pos) == '^') { [EOL]             set.add(CharRange.isNot(str.charAt(pos + 1))); [EOL]             pos += 2; [EOL]         } else { [EOL]             set.add(CharRange.is(str.charAt(pos))); [EOL]             pos += 1; [EOL]         } [EOL]     } [EOL] }
protected void add(final String str) { [EOL]     if (str == null) { [EOL]         return; [EOL]     } [EOL]     final int len = str.length(); [EOL]     int pos = 0; [EOL]     while (pos < len) { [EOL]         final int remainder = len - pos; [EOL]         if (remainder >= 4 && str.charAt(pos) == '^' && str.charAt(pos + 2) == '-') { [EOL]             set.add(CharRange.isNotIn(str.charAt(pos + 1), str.charAt(pos + 3))); [EOL]             pos += 4; [EOL]         } else if (remainder >= 3 && str.charAt(pos + 1) == '-') { [EOL]             set.add(CharRange.isIn(str.charAt(pos), str.charAt(pos + 2))); [EOL]             pos += 3; [EOL]         } else if (remainder >= 2 && str.charAt(pos) == '^') { [EOL]             set.add(CharRange.isNot(str.charAt(pos + 1))); [EOL]             pos += 2; [EOL]         } else { [EOL]             set.add(CharRange.is(str.charAt(pos))); [EOL]             pos += 1; [EOL]         } [EOL]     } [EOL] }
protected void add(final String str) { [EOL]     if (str == null) { [EOL]         return; [EOL]     } [EOL]     final int len = str.length(); [EOL]     int pos = 0; [EOL]     while (pos < len) { [EOL]         final int remainder = len - pos; [EOL]         if (remainder >= 4 && str.charAt(pos) == '^' && str.charAt(pos + 2) == '-') { [EOL]             set.add(CharRange.isNotIn(str.charAt(pos + 1), str.charAt(pos + 3))); [EOL]             pos += 4; [EOL]         } else if (remainder >= 3 && str.charAt(pos + 1) == '-') { [EOL]             set.add(CharRange.isIn(str.charAt(pos), str.charAt(pos + 2))); [EOL]             pos += 3; [EOL]         } else if (remainder >= 2 && str.charAt(pos) == '^') { [EOL]             set.add(CharRange.isNot(str.charAt(pos + 1))); [EOL]             pos += 2; [EOL]         } else { [EOL]             set.add(CharRange.is(str.charAt(pos))); [EOL]             pos += 1; [EOL]         } [EOL]     } [EOL] }
protected void add(final String str) { [EOL]     if (str == null) { [EOL]         return; [EOL]     } [EOL]     final int len = str.length(); [EOL]     int pos = 0; [EOL]     while (pos < len) { [EOL]         final int remainder = len - pos; [EOL]         if (remainder >= 4 && str.charAt(pos) == '^' && str.charAt(pos + 2) == '-') { [EOL]             set.add(CharRange.isNotIn(str.charAt(pos + 1), str.charAt(pos + 3))); [EOL]             pos += 4; [EOL]         } else if (remainder >= 3 && str.charAt(pos + 1) == '-') { [EOL]             set.add(CharRange.isIn(str.charAt(pos), str.charAt(pos + 2))); [EOL]             pos += 3; [EOL]         } else if (remainder >= 2 && str.charAt(pos) == '^') { [EOL]             set.add(CharRange.isNot(str.charAt(pos + 1))); [EOL]             pos += 2; [EOL]         } else { [EOL]             set.add(CharRange.is(str.charAt(pos))); [EOL]             pos += 1; [EOL]         } [EOL]     } [EOL] }
protected void add(final String str) { [EOL]     if (str == null) { [EOL]         return; [EOL]     } [EOL]     final int len = str.length(); [EOL]     int pos = 0; [EOL]     while (pos < len) { [EOL]         final int remainder = len - pos; [EOL]         if (remainder >= 4 && str.charAt(pos) == '^' && str.charAt(pos + 2) == '-') { [EOL]             set.add(CharRange.isNotIn(str.charAt(pos + 1), str.charAt(pos + 3))); [EOL]             pos += 4; [EOL]         } else if (remainder >= 3 && str.charAt(pos + 1) == '-') { [EOL]             set.add(CharRange.isIn(str.charAt(pos), str.charAt(pos + 2))); [EOL]             pos += 3; [EOL]         } else if (remainder >= 2 && str.charAt(pos) == '^') { [EOL]             set.add(CharRange.isNot(str.charAt(pos + 1))); [EOL]             pos += 2; [EOL]         } else { [EOL]             set.add(CharRange.is(str.charAt(pos))); [EOL]             pos += 1; [EOL]         } [EOL]     } [EOL] }
protected void add(final String str) { [EOL]     if (str == null) { [EOL]         return; [EOL]     } [EOL]     final int len = str.length(); [EOL]     int pos = 0; [EOL]     while (pos < len) { [EOL]         final int remainder = len - pos; [EOL]         if (remainder >= 4 && str.charAt(pos) == '^' && str.charAt(pos + 2) == '-') { [EOL]             set.add(CharRange.isNotIn(str.charAt(pos + 1), str.charAt(pos + 3))); [EOL]             pos += 4; [EOL]         } else if (remainder >= 3 && str.charAt(pos + 1) == '-') { [EOL]             set.add(CharRange.isIn(str.charAt(pos), str.charAt(pos + 2))); [EOL]             pos += 3; [EOL]         } else if (remainder >= 2 && str.charAt(pos) == '^') { [EOL]             set.add(CharRange.isNot(str.charAt(pos + 1))); [EOL]             pos += 2; [EOL]         } else { [EOL]             set.add(CharRange.is(str.charAt(pos))); [EOL]             pos += 1; [EOL]         } [EOL]     } [EOL] }
protected void add(final String str) { [EOL]     if (str == null) { [EOL]         return; [EOL]     } [EOL]     final int len = str.length(); [EOL]     int pos = 0; [EOL]     while (pos < len) { [EOL]         final int remainder = len - pos; [EOL]         if (remainder >= 4 && str.charAt(pos) == '^' && str.charAt(pos + 2) == '-') { [EOL]             set.add(CharRange.isNotIn(str.charAt(pos + 1), str.charAt(pos + 3))); [EOL]             pos += 4; [EOL]         } else if (remainder >= 3 && str.charAt(pos + 1) == '-') { [EOL]             set.add(CharRange.isIn(str.charAt(pos), str.charAt(pos + 2))); [EOL]             pos += 3; [EOL]         } else if (remainder >= 2 && str.charAt(pos) == '^') { [EOL]             set.add(CharRange.isNot(str.charAt(pos + 1))); [EOL]             pos += 2; [EOL]         } else { [EOL]             set.add(CharRange.is(str.charAt(pos))); [EOL]             pos += 1; [EOL]         } [EOL]     } [EOL] }
protected void add(final String str) { [EOL]     if (str == null) { [EOL]         return; [EOL]     } [EOL]     final int len = str.length(); [EOL]     int pos = 0; [EOL]     while (pos < len) { [EOL]         final int remainder = len - pos; [EOL]         if (remainder >= 4 && str.charAt(pos) == '^' && str.charAt(pos + 2) == '-') { [EOL]             set.add(CharRange.isNotIn(str.charAt(pos + 1), str.charAt(pos + 3))); [EOL]             pos += 4; [EOL]         } else if (remainder >= 3 && str.charAt(pos + 1) == '-') { [EOL]             set.add(CharRange.isIn(str.charAt(pos), str.charAt(pos + 2))); [EOL]             pos += 3; [EOL]         } else if (remainder >= 2 && str.charAt(pos) == '^') { [EOL]             set.add(CharRange.isNot(str.charAt(pos + 1))); [EOL]             pos += 2; [EOL]         } else { [EOL]             set.add(CharRange.is(str.charAt(pos))); [EOL]             pos += 1; [EOL]         } [EOL]     } [EOL] }
CharRange[] getCharRanges() { [EOL]     return set.toArray(new CharRange[set.size()]); [EOL] }
CharRange[] getCharRanges() { [EOL]     return set.toArray(new CharRange[set.size()]); [EOL] }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj == this) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof CharSet == false) { [EOL]         return false; [EOL]     } [EOL]     final CharSet other = (CharSet) obj; [EOL]     return set.equals(other.set); [EOL] }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj == this) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof CharSet == false) { [EOL]         return false; [EOL]     } [EOL]     final CharSet other = (CharSet) obj; [EOL]     return set.equals(other.set); [EOL] }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj == this) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof CharSet == false) { [EOL]         return false; [EOL]     } [EOL]     final CharSet other = (CharSet) obj; [EOL]     return set.equals(other.set); [EOL] }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj == this) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof CharSet == false) { [EOL]         return false; [EOL]     } [EOL]     final CharSet other = (CharSet) obj; [EOL]     return set.equals(other.set); [EOL] }
@Override [EOL] public R setValue(final R value) { [EOL]     final R result = getRight(); [EOL]     setRight(value); [EOL]     return result; [EOL] }
@Override [EOL] public R setValue(final R value) { [EOL]     final R result = getRight(); [EOL]     setRight(value); [EOL]     return result; [EOL] }
public static <L, R> ImmutablePair<L, R> of(final L left, final R right) { [EOL]     return new ImmutablePair<L, R>(left, right); [EOL] }
public static <L, R> ImmutablePair<L, R> of(final L left, final R right) { [EOL]     return new ImmutablePair<L, R>(left, right); [EOL] }
public ImmutablePair(final L left, final R right) { [EOL]     super(); [EOL]     this.left = left; [EOL]     this.right = right; [EOL] }
public ImmutablePair(final L left, final R right) { [EOL]     super(); [EOL]     this.left = left; [EOL]     this.right = right; [EOL] }
@Override [EOL] public L getLeft() { [EOL]     return left; [EOL] }
@Override [EOL] public R getRight() { [EOL]     return right; [EOL] }
public static boolean isSupported(final String name) { [EOL]     if (name == null) { [EOL]         return false; [EOL]     } [EOL]     try { [EOL]         return Charset.isSupported(name); [EOL]     } catch (final IllegalCharsetNameException ex) { [EOL]         return false; [EOL]     } [EOL] }
public HashCodeBuilder(final int initialNonZeroOddNumber, final int multiplierNonZeroOddNumber) { [EOL]     if (initialNonZeroOddNumber == 0) { [EOL]         throw new IllegalArgumentException("HashCodeBuilder requires a non zero initial value"); [EOL]     } [EOL]     if (initialNonZeroOddNumber % 2 == 0) { [EOL]         throw new IllegalArgumentException("HashCodeBuilder requires an odd initial value"); [EOL]     } [EOL]     if (multiplierNonZeroOddNumber == 0) { [EOL]         throw new IllegalArgumentException("HashCodeBuilder requires a non zero multiplier"); [EOL]     } [EOL]     if (multiplierNonZeroOddNumber % 2 == 0) { [EOL]         throw new IllegalArgumentException("HashCodeBuilder requires an odd multiplier"); [EOL]     } [EOL]     iConstant = multiplierNonZeroOddNumber; [EOL]     iTotal = initialNonZeroOddNumber; [EOL] }
public HashCodeBuilder(final int initialNonZeroOddNumber, final int multiplierNonZeroOddNumber) { [EOL]     if (initialNonZeroOddNumber == 0) { [EOL]         throw new IllegalArgumentException("HashCodeBuilder requires a non zero initial value"); [EOL]     } [EOL]     if (initialNonZeroOddNumber % 2 == 0) { [EOL]         throw new IllegalArgumentException("HashCodeBuilder requires an odd initial value"); [EOL]     } [EOL]     if (multiplierNonZeroOddNumber == 0) { [EOL]         throw new IllegalArgumentException("HashCodeBuilder requires a non zero multiplier"); [EOL]     } [EOL]     if (multiplierNonZeroOddNumber % 2 == 0) { [EOL]         throw new IllegalArgumentException("HashCodeBuilder requires an odd multiplier"); [EOL]     } [EOL]     iConstant = multiplierNonZeroOddNumber; [EOL]     iTotal = initialNonZeroOddNumber; [EOL] }
public HashCodeBuilder(final int initialNonZeroOddNumber, final int multiplierNonZeroOddNumber) { [EOL]     if (initialNonZeroOddNumber == 0) { [EOL]         throw new IllegalArgumentException("HashCodeBuilder requires a non zero initial value"); [EOL]     } [EOL]     if (initialNonZeroOddNumber % 2 == 0) { [EOL]         throw new IllegalArgumentException("HashCodeBuilder requires an odd initial value"); [EOL]     } [EOL]     if (multiplierNonZeroOddNumber == 0) { [EOL]         throw new IllegalArgumentException("HashCodeBuilder requires a non zero multiplier"); [EOL]     } [EOL]     if (multiplierNonZeroOddNumber % 2 == 0) { [EOL]         throw new IllegalArgumentException("HashCodeBuilder requires an odd multiplier"); [EOL]     } [EOL]     iConstant = multiplierNonZeroOddNumber; [EOL]     iTotal = initialNonZeroOddNumber; [EOL] }
public HashCodeBuilder(final int initialNonZeroOddNumber, final int multiplierNonZeroOddNumber) { [EOL]     if (initialNonZeroOddNumber == 0) { [EOL]         throw new IllegalArgumentException("HashCodeBuilder requires a non zero initial value"); [EOL]     } [EOL]     if (initialNonZeroOddNumber % 2 == 0) { [EOL]         throw new IllegalArgumentException("HashCodeBuilder requires an odd initial value"); [EOL]     } [EOL]     if (multiplierNonZeroOddNumber == 0) { [EOL]         throw new IllegalArgumentException("HashCodeBuilder requires a non zero multiplier"); [EOL]     } [EOL]     if (multiplierNonZeroOddNumber % 2 == 0) { [EOL]         throw new IllegalArgumentException("HashCodeBuilder requires an odd multiplier"); [EOL]     } [EOL]     iConstant = multiplierNonZeroOddNumber; [EOL]     iTotal = initialNonZeroOddNumber; [EOL] }
public HashCodeBuilder(final int initialNonZeroOddNumber, final int multiplierNonZeroOddNumber) { [EOL]     if (initialNonZeroOddNumber == 0) { [EOL]         throw new IllegalArgumentException("HashCodeBuilder requires a non zero initial value"); [EOL]     } [EOL]     if (initialNonZeroOddNumber % 2 == 0) { [EOL]         throw new IllegalArgumentException("HashCodeBuilder requires an odd initial value"); [EOL]     } [EOL]     if (multiplierNonZeroOddNumber == 0) { [EOL]         throw new IllegalArgumentException("HashCodeBuilder requires a non zero multiplier"); [EOL]     } [EOL]     if (multiplierNonZeroOddNumber % 2 == 0) { [EOL]         throw new IllegalArgumentException("HashCodeBuilder requires an odd multiplier"); [EOL]     } [EOL]     iConstant = multiplierNonZeroOddNumber; [EOL]     iTotal = initialNonZeroOddNumber; [EOL] }
public HashCodeBuilder append(final boolean value) { [EOL]     iTotal = iTotal * iConstant + (value ? 0 : 1); [EOL]     return this; [EOL] }
public HashCodeBuilder append(final boolean value) { [EOL]     iTotal = iTotal * iConstant + (value ? 0 : 1); [EOL]     return this; [EOL] }
public HashCodeBuilder append(final boolean[] array) { [EOL]     if (array == null) { [EOL]         iTotal = iTotal * iConstant; [EOL]     } else { [EOL]         for (final boolean element : array) { [EOL]             append(element); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public HashCodeBuilder append(final boolean[] array) { [EOL]     if (array == null) { [EOL]         iTotal = iTotal * iConstant; [EOL]     } else { [EOL]         for (final boolean element : array) { [EOL]             append(element); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public HashCodeBuilder append(final boolean[] array) { [EOL]     if (array == null) { [EOL]         iTotal = iTotal * iConstant; [EOL]     } else { [EOL]         for (final boolean element : array) { [EOL]             append(element); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public HashCodeBuilder append(final double[] array) { [EOL]     if (array == null) { [EOL]         iTotal = iTotal * iConstant; [EOL]     } else { [EOL]         for (final double element : array) { [EOL]             append(element); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public HashCodeBuilder append(final double[] array) { [EOL]     if (array == null) { [EOL]         iTotal = iTotal * iConstant; [EOL]     } else { [EOL]         for (final double element : array) { [EOL]             append(element); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public HashCodeBuilder append(final double[] array) { [EOL]     if (array == null) { [EOL]         iTotal = iTotal * iConstant; [EOL]     } else { [EOL]         for (final double element : array) { [EOL]             append(element); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public HashCodeBuilder append(final float value) { [EOL]     iTotal = iTotal * iConstant + Float.floatToIntBits(value); [EOL]     return this; [EOL] }
public HashCodeBuilder append(final float value) { [EOL]     iTotal = iTotal * iConstant + Float.floatToIntBits(value); [EOL]     return this; [EOL] }
public HashCodeBuilder append(final float value) { [EOL]     iTotal = iTotal * iConstant + Float.floatToIntBits(value); [EOL]     return this; [EOL] }
public HashCodeBuilder append(final float value) { [EOL]     iTotal = iTotal * iConstant + Float.floatToIntBits(value); [EOL]     return this; [EOL] }
public HashCodeBuilder append(final float value) { [EOL]     iTotal = iTotal * iConstant + Float.floatToIntBits(value); [EOL]     return this; [EOL] }
public HashCodeBuilder append(final float value) { [EOL]     iTotal = iTotal * iConstant + Float.floatToIntBits(value); [EOL]     return this; [EOL] }
public HashCodeBuilder append(final long[] array) { [EOL]     if (array == null) { [EOL]         iTotal = iTotal * iConstant; [EOL]     } else { [EOL]         for (final long element : array) { [EOL]             append(element); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public HashCodeBuilder append(final long[] array) { [EOL]     if (array == null) { [EOL]         iTotal = iTotal * iConstant; [EOL]     } else { [EOL]         for (final long element : array) { [EOL]             append(element); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public HashCodeBuilder append(final long[] array) { [EOL]     if (array == null) { [EOL]         iTotal = iTotal * iConstant; [EOL]     } else { [EOL]         for (final long element : array) { [EOL]             append(element); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public HashCodeBuilder append(final Object object) { [EOL]     if (object == null) { [EOL]         iTotal = iTotal * iConstant; [EOL]     } else { [EOL]         if (object.getClass().isArray()) { [EOL]             if (object instanceof long[]) { [EOL]                 append((long[]) object); [EOL]             } else if (object instanceof int[]) { [EOL]                 append((int[]) object); [EOL]             } else if (object instanceof short[]) { [EOL]                 append((short[]) object); [EOL]             } else if (object instanceof char[]) { [EOL]                 append((char[]) object); [EOL]             } else if (object instanceof byte[]) { [EOL]                 append((byte[]) object); [EOL]             } else if (object instanceof double[]) { [EOL]                 append((double[]) object); [EOL]             } else if (object instanceof float[]) { [EOL]                 append((float[]) object); [EOL]             } else if (object instanceof boolean[]) { [EOL]                 append((boolean[]) object); [EOL]             } else { [EOL]                 append((Object[]) object); [EOL]             } [EOL]         } else { [EOL]             iTotal = iTotal * iConstant + object.hashCode(); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public HashCodeBuilder append(final Object object) { [EOL]     if (object == null) { [EOL]         iTotal = iTotal * iConstant; [EOL]     } else { [EOL]         if (object.getClass().isArray()) { [EOL]             if (object instanceof long[]) { [EOL]                 append((long[]) object); [EOL]             } else if (object instanceof int[]) { [EOL]                 append((int[]) object); [EOL]             } else if (object instanceof short[]) { [EOL]                 append((short[]) object); [EOL]             } else if (object instanceof char[]) { [EOL]                 append((char[]) object); [EOL]             } else if (object instanceof byte[]) { [EOL]                 append((byte[]) object); [EOL]             } else if (object instanceof double[]) { [EOL]                 append((double[]) object); [EOL]             } else if (object instanceof float[]) { [EOL]                 append((float[]) object); [EOL]             } else if (object instanceof boolean[]) { [EOL]                 append((boolean[]) object); [EOL]             } else { [EOL]                 append((Object[]) object); [EOL]             } [EOL]         } else { [EOL]             iTotal = iTotal * iConstant + object.hashCode(); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public HashCodeBuilder append(final Object object) { [EOL]     if (object == null) { [EOL]         iTotal = iTotal * iConstant; [EOL]     } else { [EOL]         if (object.getClass().isArray()) { [EOL]             if (object instanceof long[]) { [EOL]                 append((long[]) object); [EOL]             } else if (object instanceof int[]) { [EOL]                 append((int[]) object); [EOL]             } else if (object instanceof short[]) { [EOL]                 append((short[]) object); [EOL]             } else if (object instanceof char[]) { [EOL]                 append((char[]) object); [EOL]             } else if (object instanceof byte[]) { [EOL]                 append((byte[]) object); [EOL]             } else if (object instanceof double[]) { [EOL]                 append((double[]) object); [EOL]             } else if (object instanceof float[]) { [EOL]                 append((float[]) object); [EOL]             } else if (object instanceof boolean[]) { [EOL]                 append((boolean[]) object); [EOL]             } else { [EOL]                 append((Object[]) object); [EOL]             } [EOL]         } else { [EOL]             iTotal = iTotal * iConstant + object.hashCode(); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public HashCodeBuilder append(final Object object) { [EOL]     if (object == null) { [EOL]         iTotal = iTotal * iConstant; [EOL]     } else { [EOL]         if (object.getClass().isArray()) { [EOL]             if (object instanceof long[]) { [EOL]                 append((long[]) object); [EOL]             } else if (object instanceof int[]) { [EOL]                 append((int[]) object); [EOL]             } else if (object instanceof short[]) { [EOL]                 append((short[]) object); [EOL]             } else if (object instanceof char[]) { [EOL]                 append((char[]) object); [EOL]             } else if (object instanceof byte[]) { [EOL]                 append((byte[]) object); [EOL]             } else if (object instanceof double[]) { [EOL]                 append((double[]) object); [EOL]             } else if (object instanceof float[]) { [EOL]                 append((float[]) object); [EOL]             } else if (object instanceof boolean[]) { [EOL]                 append((boolean[]) object); [EOL]             } else { [EOL]                 append((Object[]) object); [EOL]             } [EOL]         } else { [EOL]             iTotal = iTotal * iConstant + object.hashCode(); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public HashCodeBuilder append(final Object object) { [EOL]     if (object == null) { [EOL]         iTotal = iTotal * iConstant; [EOL]     } else { [EOL]         if (object.getClass().isArray()) { [EOL]             if (object instanceof long[]) { [EOL]                 append((long[]) object); [EOL]             } else if (object instanceof int[]) { [EOL]                 append((int[]) object); [EOL]             } else if (object instanceof short[]) { [EOL]                 append((short[]) object); [EOL]             } else if (object instanceof char[]) { [EOL]                 append((char[]) object); [EOL]             } else if (object instanceof byte[]) { [EOL]                 append((byte[]) object); [EOL]             } else if (object instanceof double[]) { [EOL]                 append((double[]) object); [EOL]             } else if (object instanceof float[]) { [EOL]                 append((float[]) object); [EOL]             } else if (object instanceof boolean[]) { [EOL]                 append((boolean[]) object); [EOL]             } else { [EOL]                 append((Object[]) object); [EOL]             } [EOL]         } else { [EOL]             iTotal = iTotal * iConstant + object.hashCode(); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public HashCodeBuilder append(final Object object) { [EOL]     if (object == null) { [EOL]         iTotal = iTotal * iConstant; [EOL]     } else { [EOL]         if (object.getClass().isArray()) { [EOL]             if (object instanceof long[]) { [EOL]                 append((long[]) object); [EOL]             } else if (object instanceof int[]) { [EOL]                 append((int[]) object); [EOL]             } else if (object instanceof short[]) { [EOL]                 append((short[]) object); [EOL]             } else if (object instanceof char[]) { [EOL]                 append((char[]) object); [EOL]             } else if (object instanceof byte[]) { [EOL]                 append((byte[]) object); [EOL]             } else if (object instanceof double[]) { [EOL]                 append((double[]) object); [EOL]             } else if (object instanceof float[]) { [EOL]                 append((float[]) object); [EOL]             } else if (object instanceof boolean[]) { [EOL]                 append((boolean[]) object); [EOL]             } else { [EOL]                 append((Object[]) object); [EOL]             } [EOL]         } else { [EOL]             iTotal = iTotal * iConstant + object.hashCode(); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public HashCodeBuilder append(final Object object) { [EOL]     if (object == null) { [EOL]         iTotal = iTotal * iConstant; [EOL]     } else { [EOL]         if (object.getClass().isArray()) { [EOL]             if (object instanceof long[]) { [EOL]                 append((long[]) object); [EOL]             } else if (object instanceof int[]) { [EOL]                 append((int[]) object); [EOL]             } else if (object instanceof short[]) { [EOL]                 append((short[]) object); [EOL]             } else if (object instanceof char[]) { [EOL]                 append((char[]) object); [EOL]             } else if (object instanceof byte[]) { [EOL]                 append((byte[]) object); [EOL]             } else if (object instanceof double[]) { [EOL]                 append((double[]) object); [EOL]             } else if (object instanceof float[]) { [EOL]                 append((float[]) object); [EOL]             } else if (object instanceof boolean[]) { [EOL]                 append((boolean[]) object); [EOL]             } else { [EOL]                 append((Object[]) object); [EOL]             } [EOL]         } else { [EOL]             iTotal = iTotal * iConstant + object.hashCode(); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public HashCodeBuilder append(final Object object) { [EOL]     if (object == null) { [EOL]         iTotal = iTotal * iConstant; [EOL]     } else { [EOL]         if (object.getClass().isArray()) { [EOL]             if (object instanceof long[]) { [EOL]                 append((long[]) object); [EOL]             } else if (object instanceof int[]) { [EOL]                 append((int[]) object); [EOL]             } else if (object instanceof short[]) { [EOL]                 append((short[]) object); [EOL]             } else if (object instanceof char[]) { [EOL]                 append((char[]) object); [EOL]             } else if (object instanceof byte[]) { [EOL]                 append((byte[]) object); [EOL]             } else if (object instanceof double[]) { [EOL]                 append((double[]) object); [EOL]             } else if (object instanceof float[]) { [EOL]                 append((float[]) object); [EOL]             } else if (object instanceof boolean[]) { [EOL]                 append((boolean[]) object); [EOL]             } else { [EOL]                 append((Object[]) object); [EOL]             } [EOL]         } else { [EOL]             iTotal = iTotal * iConstant + object.hashCode(); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public HashCodeBuilder append(final Object object) { [EOL]     if (object == null) { [EOL]         iTotal = iTotal * iConstant; [EOL]     } else { [EOL]         if (object.getClass().isArray()) { [EOL]             if (object instanceof long[]) { [EOL]                 append((long[]) object); [EOL]             } else if (object instanceof int[]) { [EOL]                 append((int[]) object); [EOL]             } else if (object instanceof short[]) { [EOL]                 append((short[]) object); [EOL]             } else if (object instanceof char[]) { [EOL]                 append((char[]) object); [EOL]             } else if (object instanceof byte[]) { [EOL]                 append((byte[]) object); [EOL]             } else if (object instanceof double[]) { [EOL]                 append((double[]) object); [EOL]             } else if (object instanceof float[]) { [EOL]                 append((float[]) object); [EOL]             } else if (object instanceof boolean[]) { [EOL]                 append((boolean[]) object); [EOL]             } else { [EOL]                 append((Object[]) object); [EOL]             } [EOL]         } else { [EOL]             iTotal = iTotal * iConstant + object.hashCode(); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public HashCodeBuilder append(final Object object) { [EOL]     if (object == null) { [EOL]         iTotal = iTotal * iConstant; [EOL]     } else { [EOL]         if (object.getClass().isArray()) { [EOL]             if (object instanceof long[]) { [EOL]                 append((long[]) object); [EOL]             } else if (object instanceof int[]) { [EOL]                 append((int[]) object); [EOL]             } else if (object instanceof short[]) { [EOL]                 append((short[]) object); [EOL]             } else if (object instanceof char[]) { [EOL]                 append((char[]) object); [EOL]             } else if (object instanceof byte[]) { [EOL]                 append((byte[]) object); [EOL]             } else if (object instanceof double[]) { [EOL]                 append((double[]) object); [EOL]             } else if (object instanceof float[]) { [EOL]                 append((float[]) object); [EOL]             } else if (object instanceof boolean[]) { [EOL]                 append((boolean[]) object); [EOL]             } else { [EOL]                 append((Object[]) object); [EOL]             } [EOL]         } else { [EOL]             iTotal = iTotal * iConstant + object.hashCode(); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public HashCodeBuilder append(final Object object) { [EOL]     if (object == null) { [EOL]         iTotal = iTotal * iConstant; [EOL]     } else { [EOL]         if (object.getClass().isArray()) { [EOL]             if (object instanceof long[]) { [EOL]                 append((long[]) object); [EOL]             } else if (object instanceof int[]) { [EOL]                 append((int[]) object); [EOL]             } else if (object instanceof short[]) { [EOL]                 append((short[]) object); [EOL]             } else if (object instanceof char[]) { [EOL]                 append((char[]) object); [EOL]             } else if (object instanceof byte[]) { [EOL]                 append((byte[]) object); [EOL]             } else if (object instanceof double[]) { [EOL]                 append((double[]) object); [EOL]             } else if (object instanceof float[]) { [EOL]                 append((float[]) object); [EOL]             } else if (object instanceof boolean[]) { [EOL]                 append((boolean[]) object); [EOL]             } else { [EOL]                 append((Object[]) object); [EOL]             } [EOL]         } else { [EOL]             iTotal = iTotal * iConstant + object.hashCode(); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public Integer build() { [EOL]     return Integer.valueOf(toHashCode()); [EOL] }
@Override [EOL] public int hashCode() { [EOL]     return toHashCode(); [EOL] }
public static void serialize(final Serializable obj, final OutputStream outputStream) { [EOL]     if (outputStream == null) { [EOL]         throw new IllegalArgumentException("The OutputStream must not be null"); [EOL]     } [EOL]     ObjectOutputStream out = null; [EOL]     try { [EOL]         out = new ObjectOutputStream(outputStream); [EOL]         out.writeObject(obj); [EOL]     } catch (final IOException ex) { [EOL]         throw new SerializationException(ex); [EOL]     } finally { [EOL]         try { [EOL]             if (out != null) { [EOL]                 out.close(); [EOL]             } [EOL]         } catch (final IOException ex) { [EOL]         } [EOL]     } [EOL] }
public static void serialize(final Serializable obj, final OutputStream outputStream) { [EOL]     if (outputStream == null) { [EOL]         throw new IllegalArgumentException("The OutputStream must not be null"); [EOL]     } [EOL]     ObjectOutputStream out = null; [EOL]     try { [EOL]         out = new ObjectOutputStream(outputStream); [EOL]         out.writeObject(obj); [EOL]     } catch (final IOException ex) { [EOL]         throw new SerializationException(ex); [EOL]     } finally { [EOL]         try { [EOL]             if (out != null) { [EOL]                 out.close(); [EOL]             } [EOL]         } catch (final IOException ex) { [EOL]         } [EOL]     } [EOL] }
public static void serialize(final Serializable obj, final OutputStream outputStream) { [EOL]     if (outputStream == null) { [EOL]         throw new IllegalArgumentException("The OutputStream must not be null"); [EOL]     } [EOL]     ObjectOutputStream out = null; [EOL]     try { [EOL]         out = new ObjectOutputStream(outputStream); [EOL]         out.writeObject(obj); [EOL]     } catch (final IOException ex) { [EOL]         throw new SerializationException(ex); [EOL]     } finally { [EOL]         try { [EOL]             if (out != null) { [EOL]                 out.close(); [EOL]             } [EOL]         } catch (final IOException ex) { [EOL]         } [EOL]     } [EOL] }
public static byte[] serialize(final Serializable obj) { [EOL]     final ByteArrayOutputStream baos = new ByteArrayOutputStream(512); [EOL]     serialize(obj, baos); [EOL]     return baos.toByteArray(); [EOL] }
public static byte[] serialize(final Serializable obj) { [EOL]     final ByteArrayOutputStream baos = new ByteArrayOutputStream(512); [EOL]     serialize(obj, baos); [EOL]     return baos.toByteArray(); [EOL] }
public static <T> T deserialize(final InputStream inputStream) { [EOL]     if (inputStream == null) { [EOL]         throw new IllegalArgumentException("The InputStream must not be null"); [EOL]     } [EOL]     ObjectInputStream in = null; [EOL]     try { [EOL]         in = new ObjectInputStream(inputStream); [EOL]         @SuppressWarnings("unchecked") [EOL]         final T obj = (T) in.readObject(); [EOL]         return obj; [EOL]     } catch (final ClassCastException ex) { [EOL]         throw new SerializationException(ex); [EOL]     } catch (final ClassNotFoundException ex) { [EOL]         throw new SerializationException(ex); [EOL]     } catch (final IOException ex) { [EOL]         throw new SerializationException(ex); [EOL]     } finally { [EOL]         try { [EOL]             if (in != null) { [EOL]                 in.close(); [EOL]             } [EOL]         } catch (final IOException ex) { [EOL]         } [EOL]     } [EOL] }
public static <T> T deserialize(final byte[] objectData) { [EOL]     if (objectData == null) { [EOL]         throw new IllegalArgumentException("The byte[] must not be null"); [EOL]     } [EOL]     return SerializationUtils.<T>deserialize(new ByteArrayInputStream(objectData)); [EOL] }
@Override [EOL] protected Class<?> resolveClass(final ObjectStreamClass desc) throws IOException, ClassNotFoundException { [EOL]     final String name = desc.getName(); [EOL]     try { [EOL]         return Class.forName(name, false, classLoader); [EOL]     } catch (final ClassNotFoundException ex) { [EOL]         try { [EOL]             return Class.forName(name, false, Thread.currentThread().getContextClassLoader()); [EOL]         } catch (final ClassNotFoundException cnfe) { [EOL]             final Class<?> cls = primitiveTypes.get(name); [EOL]             if (cls != null) { [EOL]                 return cls; [EOL]             } else { [EOL]                 throw cnfe; [EOL]             } [EOL]         } [EOL]     } [EOL] }
public static char toChar(final Character ch, final char defaultValue) { [EOL]     if (ch == null) { [EOL]         return defaultValue; [EOL]     } [EOL]     return ch.charValue(); [EOL] }
public static char toChar(final Character ch, final char defaultValue) { [EOL]     if (ch == null) { [EOL]         return defaultValue; [EOL]     } [EOL]     return ch.charValue(); [EOL] }
public static int toIntValue(final char ch) { [EOL]     if (isAsciiNumeric(ch) == false) { [EOL]         throw new IllegalArgumentException("The character " + ch + " is not in the range '0' - '9'"); [EOL]     } [EOL]     return ch - 48; [EOL] }
public static int toIntValue(final char ch) { [EOL]     if (isAsciiNumeric(ch) == false) { [EOL]         throw new IllegalArgumentException("The character " + ch + " is not in the range '0' - '9'"); [EOL]     } [EOL]     return ch - 48; [EOL] }
public static int toIntValue(final Character ch) { [EOL]     if (ch == null) { [EOL]         throw new IllegalArgumentException("The character must not be null"); [EOL]     } [EOL]     return toIntValue(ch.charValue()); [EOL] }
public static String unicodeEscaped(final char ch) { [EOL]     if (ch < 0x10) { [EOL]         return "\\u000" + Integer.toHexString(ch); [EOL]     } else if (ch < 0x100) { [EOL]         return "\\u00" + Integer.toHexString(ch); [EOL]     } else if (ch < 0x1000) { [EOL]         return "\\u0" + Integer.toHexString(ch); [EOL]     } [EOL]     return "\\u" + Integer.toHexString(ch); [EOL] }
public static String unicodeEscaped(final Character ch) { [EOL]     if (ch == null) { [EOL]         return null; [EOL]     } [EOL]     return unicodeEscaped(ch.charValue()); [EOL] }
public static String unicodeEscaped(final Character ch) { [EOL]     if (ch == null) { [EOL]         return null; [EOL]     } [EOL]     return unicodeEscaped(ch.charValue()); [EOL] }
public T getMinimum() { [EOL]     return minimum; [EOL] }
public boolean isAfterRange(final Range<T> otherRange) { [EOL]     if (otherRange == null) { [EOL]         return false; [EOL]     } [EOL]     return isAfter(otherRange.maximum); [EOL] }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj == this) { [EOL]         return true; [EOL]     } else if (obj == null || obj.getClass() != getClass()) { [EOL]         return false; [EOL]     } else { [EOL]         @SuppressWarnings("unchecked") [EOL]         final Range<T> range = (Range<T>) obj; [EOL]         return minimum.equals(range.minimum) && maximum.equals(range.maximum); [EOL]     } [EOL] }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj == this) { [EOL]         return true; [EOL]     } else if (obj == null || obj.getClass() != getClass()) { [EOL]         return false; [EOL]     } else { [EOL]         @SuppressWarnings("unchecked") [EOL]         final Range<T> range = (Range<T>) obj; [EOL]         return minimum.equals(range.minimum) && maximum.equals(range.maximum); [EOL]     } [EOL] }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj == this) { [EOL]         return true; [EOL]     } else if (obj == null || obj.getClass() != getClass()) { [EOL]         return false; [EOL]     } else { [EOL]         @SuppressWarnings("unchecked") [EOL]         final Range<T> range = (Range<T>) obj; [EOL]         return minimum.equals(range.minimum) && maximum.equals(range.maximum); [EOL]     } [EOL] }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj == this) { [EOL]         return true; [EOL]     } else if (obj == null || obj.getClass() != getClass()) { [EOL]         return false; [EOL]     } else { [EOL]         @SuppressWarnings("unchecked") [EOL]         final Range<T> range = (Range<T>) obj; [EOL]         return minimum.equals(range.minimum) && maximum.equals(range.maximum); [EOL]     } [EOL] }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj == this) { [EOL]         return true; [EOL]     } else if (obj == null || obj.getClass() != getClass()) { [EOL]         return false; [EOL]     } else { [EOL]         @SuppressWarnings("unchecked") [EOL]         final Range<T> range = (Range<T>) obj; [EOL]         return minimum.equals(range.minimum) && maximum.equals(range.maximum); [EOL]     } [EOL] }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj == this) { [EOL]         return true; [EOL]     } else if (obj == null || obj.getClass() != getClass()) { [EOL]         return false; [EOL]     } else { [EOL]         @SuppressWarnings("unchecked") [EOL]         final Range<T> range = (Range<T>) obj; [EOL]         return minimum.equals(range.minimum) && maximum.equals(range.maximum); [EOL]     } [EOL] }
public static String toString(final Object object, final ToStringStyle style) { [EOL]     return toString(object, style, false, false, null); [EOL] }
public static String toString(final Object object, final ToStringStyle style) { [EOL]     return toString(object, style, false, false, null); [EOL] }
public static String toString(final Object object, final ToStringStyle style) { [EOL]     return toString(object, style, false, false, null); [EOL] }
public static String toString(final Object object, final ToStringStyle style) { [EOL]     return toString(object, style, false, false, null); [EOL] }
public void subtract(final long operand) { [EOL]     this.value -= operand; [EOL] }
public void subtract(final long operand) { [EOL]     this.value -= operand; [EOL] }
public void subtract(final long operand) { [EOL]     this.value -= operand; [EOL] }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj instanceof MutableLong) { [EOL]         return value == ((MutableLong) obj).longValue(); [EOL]     } [EOL]     return false; [EOL] }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj instanceof MutableLong) { [EOL]         return value == ((MutableLong) obj).longValue(); [EOL]     } [EOL]     return false; [EOL] }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj instanceof MutableLong) { [EOL]         return value == ((MutableLong) obj).longValue(); [EOL]     } [EOL]     return false; [EOL] }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj instanceof MutableLong) { [EOL]         return value == ((MutableLong) obj).longValue(); [EOL]     } [EOL]     return false; [EOL] }
@Override [EOL] public int compareTo(final MutableLong other) { [EOL]     final long anotherVal = other.value; [EOL]     return value < anotherVal ? -1 : (value == anotherVal ? 0 : 1); [EOL] }
@Override [EOL] public int compareTo(final MutableLong other) { [EOL]     final long anotherVal = other.value; [EOL]     return value < anotherVal ? -1 : (value == anotherVal ? 0 : 1); [EOL] }
@Override [EOL] public int compareTo(final MutableLong other) { [EOL]     final long anotherVal = other.value; [EOL]     return value < anotherVal ? -1 : (value == anotherVal ? 0 : 1); [EOL] }
public MutableInt(final int value) { [EOL]     super(); [EOL]     this.value = value; [EOL] }
public void add(final Number operand) { [EOL]     this.value += operand.intValue(); [EOL] }
public void add(final Number operand) { [EOL]     this.value += operand.intValue(); [EOL] }
public void add(final Number operand) { [EOL]     this.value += operand.intValue(); [EOL] }
public Integer toInteger() { [EOL]     return Integer.valueOf(intValue()); [EOL] }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj instanceof MutableInt) { [EOL]         return value == ((MutableInt) obj).intValue(); [EOL]     } [EOL]     return false; [EOL] }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj instanceof MutableInt) { [EOL]         return value == ((MutableInt) obj).intValue(); [EOL]     } [EOL]     return false; [EOL] }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj instanceof MutableInt) { [EOL]         return value == ((MutableInt) obj).intValue(); [EOL]     } [EOL]     return false; [EOL] }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj instanceof MutableInt) { [EOL]         return value == ((MutableInt) obj).intValue(); [EOL]     } [EOL]     return false; [EOL] }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj instanceof MutableInt) { [EOL]         return value == ((MutableInt) obj).intValue(); [EOL]     } [EOL]     return false; [EOL] }
@Override [EOL] public int compareTo(final MutableInt other) { [EOL]     final int anotherVal = other.value; [EOL]     return value < anotherVal ? -1 : (value == anotherVal ? 0 : 1); [EOL] }
public static boolean equals(final Object object1, final Object object2) { [EOL]     if (object1 == object2) { [EOL]         return true; [EOL]     } [EOL]     if (object1 == null || object2 == null) { [EOL]         return false; [EOL]     } [EOL]     return object1.equals(object2); [EOL] }
public static boolean equals(final Object object1, final Object object2) { [EOL]     if (object1 == object2) { [EOL]         return true; [EOL]     } [EOL]     if (object1 == null || object2 == null) { [EOL]         return false; [EOL]     } [EOL]     return object1.equals(object2); [EOL] }
public static boolean equals(final Object object1, final Object object2) { [EOL]     if (object1 == object2) { [EOL]         return true; [EOL]     } [EOL]     if (object1 == null || object2 == null) { [EOL]         return false; [EOL]     } [EOL]     return object1.equals(object2); [EOL] }
public static boolean equals(final Object object1, final Object object2) { [EOL]     if (object1 == object2) { [EOL]         return true; [EOL]     } [EOL]     if (object1 == null || object2 == null) { [EOL]         return false; [EOL]     } [EOL]     return object1.equals(object2); [EOL] }
public static boolean equals(final Object object1, final Object object2) { [EOL]     if (object1 == object2) { [EOL]         return true; [EOL]     } [EOL]     if (object1 == null || object2 == null) { [EOL]         return false; [EOL]     } [EOL]     return object1.equals(object2); [EOL] }
public static boolean equals(final Object object1, final Object object2) { [EOL]     if (object1 == object2) { [EOL]         return true; [EOL]     } [EOL]     if (object1 == null || object2 == null) { [EOL]         return false; [EOL]     } [EOL]     return object1.equals(object2); [EOL] }
public static String identityToString(final Object object) { [EOL]     if (object == null) { [EOL]         return null; [EOL]     } [EOL]     final StringBuilder builder = new StringBuilder(); [EOL]     identityToString(builder, object); [EOL]     return builder.toString(); [EOL] }
public static void identityToString(final StringBuilder builder, final Object object) { [EOL]     if (object == null) { [EOL]         throw new NullPointerException("Cannot get the toString of a null identity"); [EOL]     } [EOL]     builder.append(object.getClass().getName()).append('@').append(Integer.toHexString(System.identityHashCode(object))); [EOL] }
public static void identityToString(final StringBuilder builder, final Object object) { [EOL]     if (object == null) { [EOL]         throw new NullPointerException("Cannot get the toString of a null identity"); [EOL]     } [EOL]     builder.append(object.getClass().getName()).append('@').append(Integer.toHexString(System.identityHashCode(object))); [EOL] }
public static <T extends Comparable<? super T>> T max(final T... values) { [EOL]     T result = null; [EOL]     if (values != null) { [EOL]         for (final T value : values) { [EOL]             if (compare(value, result, false) > 0) { [EOL]                 result = value; [EOL]             } [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
public static <T extends Comparable<? super T>> T max(final T... values) { [EOL]     T result = null; [EOL]     if (values != null) { [EOL]         for (final T value : values) { [EOL]             if (compare(value, result, false) > 0) { [EOL]                 result = value; [EOL]             } [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
public static <T extends Comparable<? super T>> T max(final T... values) { [EOL]     T result = null; [EOL]     if (values != null) { [EOL]         for (final T value : values) { [EOL]             if (compare(value, result, false) > 0) { [EOL]                 result = value; [EOL]             } [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
public static <T extends Comparable<? super T>> T max(final T... values) { [EOL]     T result = null; [EOL]     if (values != null) { [EOL]         for (final T value : values) { [EOL]             if (compare(value, result, false) > 0) { [EOL]                 result = value; [EOL]             } [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
public static <T extends Comparable<? super T>> T max(final T... values) { [EOL]     T result = null; [EOL]     if (values != null) { [EOL]         for (final T value : values) { [EOL]             if (compare(value, result, false) > 0) { [EOL]                 result = value; [EOL]             } [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
public static <T extends Comparable<? super T>> T max(final T... values) { [EOL]     T result = null; [EOL]     if (values != null) { [EOL]         for (final T value : values) { [EOL]             if (compare(value, result, false) > 0) { [EOL]                 result = value; [EOL]             } [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
public static void isTrue(final boolean expression, final String message, final long value) { [EOL]     if (expression == false) { [EOL]         throw new IllegalArgumentException(String.format(message, Long.valueOf(value))); [EOL]     } [EOL] }
public static void isTrue(final boolean expression, final String message, final long value) { [EOL]     if (expression == false) { [EOL]         throw new IllegalArgumentException(String.format(message, Long.valueOf(value))); [EOL]     } [EOL] }
public static <T extends CharSequence> T notBlank(final T chars, final String message, final Object... values) { [EOL]     if (chars == null) { [EOL]         throw new NullPointerException(String.format(message, values)); [EOL]     } [EOL]     if (StringUtils.isBlank(chars)) { [EOL]         throw new IllegalArgumentException(String.format(message, values)); [EOL]     } [EOL]     return chars; [EOL] }
public static <T extends CharSequence> T notBlank(final T chars, final String message, final Object... values) { [EOL]     if (chars == null) { [EOL]         throw new NullPointerException(String.format(message, values)); [EOL]     } [EOL]     if (StringUtils.isBlank(chars)) { [EOL]         throw new IllegalArgumentException(String.format(message, values)); [EOL]     } [EOL]     return chars; [EOL] }
public static <T extends CharSequence> T notBlank(final T chars, final String message, final Object... values) { [EOL]     if (chars == null) { [EOL]         throw new NullPointerException(String.format(message, values)); [EOL]     } [EOL]     if (StringUtils.isBlank(chars)) { [EOL]         throw new IllegalArgumentException(String.format(message, values)); [EOL]     } [EOL]     return chars; [EOL] }
public static <T> void inclusiveBetween(final T start, final T end, final Comparable<T> value, final String message, final Object... values) { [EOL]     if (value.compareTo(start) < 0 || value.compareTo(end) > 0) { [EOL]         throw new IllegalArgumentException(String.format(message, values)); [EOL]     } [EOL] }
public static <T> void inclusiveBetween(final T start, final T end, final Comparable<T> value, final String message, final Object... values) { [EOL]     if (value.compareTo(start) < 0 || value.compareTo(end) > 0) { [EOL]         throw new IllegalArgumentException(String.format(message, values)); [EOL]     } [EOL] }
public static <T> void exclusiveBetween(final T start, final T end, final Comparable<T> value, final String message, final Object... values) { [EOL]     if (value.compareTo(start) <= 0 || value.compareTo(end) >= 0) { [EOL]         throw new IllegalArgumentException(String.format(message, values)); [EOL]     } [EOL] }
public static <T> void exclusiveBetween(final T start, final T end, final Comparable<T> value, final String message, final Object... values) { [EOL]     if (value.compareTo(start) <= 0 || value.compareTo(end) >= 0) { [EOL]         throw new IllegalArgumentException(String.format(message, values)); [EOL]     } [EOL] }
public static <T> void exclusiveBetween(final T start, final T end, final Comparable<T> value, final String message, final Object... values) { [EOL]     if (value.compareTo(start) <= 0 || value.compareTo(end) >= 0) { [EOL]         throw new IllegalArgumentException(String.format(message, values)); [EOL]     } [EOL] }
public static <T> void exclusiveBetween(final T start, final T end, final Comparable<T> value, final String message, final Object... values) { [EOL]     if (value.compareTo(start) <= 0 || value.compareTo(end) >= 0) { [EOL]         throw new IllegalArgumentException(String.format(message, values)); [EOL]     } [EOL] }
public static <T> void exclusiveBetween(final T start, final T end, final Comparable<T> value, final String message, final Object... values) { [EOL]     if (value.compareTo(start) <= 0 || value.compareTo(end) >= 0) { [EOL]         throw new IllegalArgumentException(String.format(message, values)); [EOL]     } [EOL] }
@Override [EOL] public String toString() { [EOL]     return String.valueOf(value); [EOL] }
public DurationFormatUtils() { [EOL]     super(); [EOL] }
public static boolean containsAny(final String str, final String... set) { [EOL]     if (StringUtils.isEmpty(str) || deepEmpty(set)) { [EOL]         return false; [EOL]     } [EOL]     final CharSet chars = CharSet.getInstance(set); [EOL]     for (final char c : str.toCharArray()) { [EOL]         if (chars.contains(c)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
@Deprecated [EOL] public static Throwable getCause(final Throwable throwable, String[] methodNames) { [EOL]     if (throwable == null) { [EOL]         return null; [EOL]     } [EOL]     if (methodNames == null) { [EOL]         methodNames = CAUSE_METHOD_NAMES; [EOL]     } [EOL]     for (final String methodName : methodNames) { [EOL]         if (methodName != null) { [EOL]             final Throwable cause = getCauseUsingMethodName(throwable, methodName); [EOL]             if (cause != null) { [EOL]                 return cause; [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] } public ExceptionUtils(); public static String[] getDefaultCauseMethodNames(); public static Throwable getCause(final Throwable throwable); public static Throwable getCause(final Throwable throwable, String[] methodNames); public static Throwable getRootCause(final Throwable throwable); private static Throwable getCauseUsingMethodName(final Throwable throwable, final String methodName); public static int getThrowableCount(final Throwable throwable); public static Throwable[] getThrowables(final Throwable throwable); public static List<Throwable> getThrowableList(Throwable throwable); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz, final int fromIndex); public static int indexOfType(final Throwable throwable, final Class<?> type); public static int indexOfType(final Throwable throwable, final Class<?> type, final int fromIndex); private static int indexOf(final Throwable throwable, final Class<?> type, int fromIndex, final boolean subclass); public static void printRootCauseStackTrace(final Throwable throwable); public static void printRootCauseStackTrace(final Throwable throwable, final PrintStream stream); public static void printRootCauseStackTrace(final Throwable throwable, final PrintWriter writer); public static String[] getRootCauseStackTrace(final Throwable throwable); public static void removeCommonFrames(final List<String> causeFrames, final List<String> wrapperFrames); public static String getStackTrace(final Throwable throwable); public static String[] getStackFrames(final Throwable throwable);  static String[] getStackFrames(final String stackTrace);  static List<String> getStackFrameList(final Throwable t); public static String getMessage(final Throwable th); public static String getRootCauseMessage(final Throwable th); String WRAPPED_MARKER=Optional[" [wrapped] "]; String[] CAUSE_METHOD_NAMES=Optional[{ "getCause", "getNextException", "getTargetException", "getException", "getSourceException", "getRootCause", "getCausedByException", "getNested", "getLinkedException", "getNestedException", "getLinkedCause", "getThrowable" }
@Deprecated [EOL] public static Throwable getCause(final Throwable throwable, String[] methodNames) { [EOL]     if (throwable == null) { [EOL]         return null; [EOL]     } [EOL]     if (methodNames == null) { [EOL]         methodNames = CAUSE_METHOD_NAMES; [EOL]     } [EOL]     for (final String methodName : methodNames) { [EOL]         if (methodName != null) { [EOL]             final Throwable cause = getCauseUsingMethodName(throwable, methodName); [EOL]             if (cause != null) { [EOL]                 return cause; [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] } public ExceptionUtils(); public static String[] getDefaultCauseMethodNames(); public static Throwable getCause(final Throwable throwable); public static Throwable getCause(final Throwable throwable, String[] methodNames); public static Throwable getRootCause(final Throwable throwable); private static Throwable getCauseUsingMethodName(final Throwable throwable, final String methodName); public static int getThrowableCount(final Throwable throwable); public static Throwable[] getThrowables(final Throwable throwable); public static List<Throwable> getThrowableList(Throwable throwable); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz, final int fromIndex); public static int indexOfType(final Throwable throwable, final Class<?> type); public static int indexOfType(final Throwable throwable, final Class<?> type, final int fromIndex); private static int indexOf(final Throwable throwable, final Class<?> type, int fromIndex, final boolean subclass); public static void printRootCauseStackTrace(final Throwable throwable); public static void printRootCauseStackTrace(final Throwable throwable, final PrintStream stream); public static void printRootCauseStackTrace(final Throwable throwable, final PrintWriter writer); public static String[] getRootCauseStackTrace(final Throwable throwable); public static void removeCommonFrames(final List<String> causeFrames, final List<String> wrapperFrames); public static String getStackTrace(final Throwable throwable); public static String[] getStackFrames(final Throwable throwable);  static String[] getStackFrames(final String stackTrace);  static List<String> getStackFrameList(final Throwable t); public static String getMessage(final Throwable th); public static String getRootCauseMessage(final Throwable th); String WRAPPED_MARKER=Optional[" [wrapped] "]; String[] CAUSE_METHOD_NAMES=Optional[{ "getCause", "getNextException", "getTargetException", "getException", "getSourceException", "getRootCause", "getCausedByException", "getNested", "getLinkedException", "getNestedException", "getLinkedCause", "getThrowable" }
@Deprecated [EOL] public static Throwable getCause(final Throwable throwable, String[] methodNames) { [EOL]     if (throwable == null) { [EOL]         return null; [EOL]     } [EOL]     if (methodNames == null) { [EOL]         methodNames = CAUSE_METHOD_NAMES; [EOL]     } [EOL]     for (final String methodName : methodNames) { [EOL]         if (methodName != null) { [EOL]             final Throwable cause = getCauseUsingMethodName(throwable, methodName); [EOL]             if (cause != null) { [EOL]                 return cause; [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] } public ExceptionUtils(); public static String[] getDefaultCauseMethodNames(); public static Throwable getCause(final Throwable throwable); public static Throwable getCause(final Throwable throwable, String[] methodNames); public static Throwable getRootCause(final Throwable throwable); private static Throwable getCauseUsingMethodName(final Throwable throwable, final String methodName); public static int getThrowableCount(final Throwable throwable); public static Throwable[] getThrowables(final Throwable throwable); public static List<Throwable> getThrowableList(Throwable throwable); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz, final int fromIndex); public static int indexOfType(final Throwable throwable, final Class<?> type); public static int indexOfType(final Throwable throwable, final Class<?> type, final int fromIndex); private static int indexOf(final Throwable throwable, final Class<?> type, int fromIndex, final boolean subclass); public static void printRootCauseStackTrace(final Throwable throwable); public static void printRootCauseStackTrace(final Throwable throwable, final PrintStream stream); public static void printRootCauseStackTrace(final Throwable throwable, final PrintWriter writer); public static String[] getRootCauseStackTrace(final Throwable throwable); public static void removeCommonFrames(final List<String> causeFrames, final List<String> wrapperFrames); public static String getStackTrace(final Throwable throwable); public static String[] getStackFrames(final Throwable throwable);  static String[] getStackFrames(final String stackTrace);  static List<String> getStackFrameList(final Throwable t); public static String getMessage(final Throwable th); public static String getRootCauseMessage(final Throwable th); String WRAPPED_MARKER=Optional[" [wrapped] "]; String[] CAUSE_METHOD_NAMES=Optional[{ "getCause", "getNextException", "getTargetException", "getException", "getSourceException", "getRootCause", "getCausedByException", "getNested", "getLinkedException", "getNestedException", "getLinkedCause", "getThrowable" }
@Deprecated [EOL] public static Throwable getCause(final Throwable throwable, String[] methodNames) { [EOL]     if (throwable == null) { [EOL]         return null; [EOL]     } [EOL]     if (methodNames == null) { [EOL]         methodNames = CAUSE_METHOD_NAMES; [EOL]     } [EOL]     for (final String methodName : methodNames) { [EOL]         if (methodName != null) { [EOL]             final Throwable cause = getCauseUsingMethodName(throwable, methodName); [EOL]             if (cause != null) { [EOL]                 return cause; [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] } public ExceptionUtils(); public static String[] getDefaultCauseMethodNames(); public static Throwable getCause(final Throwable throwable); public static Throwable getCause(final Throwable throwable, String[] methodNames); public static Throwable getRootCause(final Throwable throwable); private static Throwable getCauseUsingMethodName(final Throwable throwable, final String methodName); public static int getThrowableCount(final Throwable throwable); public static Throwable[] getThrowables(final Throwable throwable); public static List<Throwable> getThrowableList(Throwable throwable); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz, final int fromIndex); public static int indexOfType(final Throwable throwable, final Class<?> type); public static int indexOfType(final Throwable throwable, final Class<?> type, final int fromIndex); private static int indexOf(final Throwable throwable, final Class<?> type, int fromIndex, final boolean subclass); public static void printRootCauseStackTrace(final Throwable throwable); public static void printRootCauseStackTrace(final Throwable throwable, final PrintStream stream); public static void printRootCauseStackTrace(final Throwable throwable, final PrintWriter writer); public static String[] getRootCauseStackTrace(final Throwable throwable); public static void removeCommonFrames(final List<String> causeFrames, final List<String> wrapperFrames); public static String getStackTrace(final Throwable throwable); public static String[] getStackFrames(final Throwable throwable);  static String[] getStackFrames(final String stackTrace);  static List<String> getStackFrameList(final Throwable t); public static String getMessage(final Throwable th); public static String getRootCauseMessage(final Throwable th); String WRAPPED_MARKER=Optional[" [wrapped] "]; String[] CAUSE_METHOD_NAMES=Optional[{ "getCause", "getNextException", "getTargetException", "getException", "getSourceException", "getRootCause", "getCausedByException", "getNested", "getLinkedException", "getNestedException", "getLinkedCause", "getThrowable" }
@Deprecated [EOL] public static Throwable getCause(final Throwable throwable, String[] methodNames) { [EOL]     if (throwable == null) { [EOL]         return null; [EOL]     } [EOL]     if (methodNames == null) { [EOL]         methodNames = CAUSE_METHOD_NAMES; [EOL]     } [EOL]     for (final String methodName : methodNames) { [EOL]         if (methodName != null) { [EOL]             final Throwable cause = getCauseUsingMethodName(throwable, methodName); [EOL]             if (cause != null) { [EOL]                 return cause; [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] } public ExceptionUtils(); public static String[] getDefaultCauseMethodNames(); public static Throwable getCause(final Throwable throwable); public static Throwable getCause(final Throwable throwable, String[] methodNames); public static Throwable getRootCause(final Throwable throwable); private static Throwable getCauseUsingMethodName(final Throwable throwable, final String methodName); public static int getThrowableCount(final Throwable throwable); public static Throwable[] getThrowables(final Throwable throwable); public static List<Throwable> getThrowableList(Throwable throwable); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz, final int fromIndex); public static int indexOfType(final Throwable throwable, final Class<?> type); public static int indexOfType(final Throwable throwable, final Class<?> type, final int fromIndex); private static int indexOf(final Throwable throwable, final Class<?> type, int fromIndex, final boolean subclass); public static void printRootCauseStackTrace(final Throwable throwable); public static void printRootCauseStackTrace(final Throwable throwable, final PrintStream stream); public static void printRootCauseStackTrace(final Throwable throwable, final PrintWriter writer); public static String[] getRootCauseStackTrace(final Throwable throwable); public static void removeCommonFrames(final List<String> causeFrames, final List<String> wrapperFrames); public static String getStackTrace(final Throwable throwable); public static String[] getStackFrames(final Throwable throwable);  static String[] getStackFrames(final String stackTrace);  static List<String> getStackFrameList(final Throwable t); public static String getMessage(final Throwable th); public static String getRootCauseMessage(final Throwable th); String WRAPPED_MARKER=Optional[" [wrapped] "]; String[] CAUSE_METHOD_NAMES=Optional[{ "getCause", "getNextException", "getTargetException", "getException", "getSourceException", "getRootCause", "getCausedByException", "getNested", "getLinkedException", "getNestedException", "getLinkedCause", "getThrowable" }
@Deprecated [EOL] public static Throwable getCause(final Throwable throwable, String[] methodNames) { [EOL]     if (throwable == null) { [EOL]         return null; [EOL]     } [EOL]     if (methodNames == null) { [EOL]         methodNames = CAUSE_METHOD_NAMES; [EOL]     } [EOL]     for (final String methodName : methodNames) { [EOL]         if (methodName != null) { [EOL]             final Throwable cause = getCauseUsingMethodName(throwable, methodName); [EOL]             if (cause != null) { [EOL]                 return cause; [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] } public ExceptionUtils(); public static String[] getDefaultCauseMethodNames(); public static Throwable getCause(final Throwable throwable); public static Throwable getCause(final Throwable throwable, String[] methodNames); public static Throwable getRootCause(final Throwable throwable); private static Throwable getCauseUsingMethodName(final Throwable throwable, final String methodName); public static int getThrowableCount(final Throwable throwable); public static Throwable[] getThrowables(final Throwable throwable); public static List<Throwable> getThrowableList(Throwable throwable); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz, final int fromIndex); public static int indexOfType(final Throwable throwable, final Class<?> type); public static int indexOfType(final Throwable throwable, final Class<?> type, final int fromIndex); private static int indexOf(final Throwable throwable, final Class<?> type, int fromIndex, final boolean subclass); public static void printRootCauseStackTrace(final Throwable throwable); public static void printRootCauseStackTrace(final Throwable throwable, final PrintStream stream); public static void printRootCauseStackTrace(final Throwable throwable, final PrintWriter writer); public static String[] getRootCauseStackTrace(final Throwable throwable); public static void removeCommonFrames(final List<String> causeFrames, final List<String> wrapperFrames); public static String getStackTrace(final Throwable throwable); public static String[] getStackFrames(final Throwable throwable);  static String[] getStackFrames(final String stackTrace);  static List<String> getStackFrameList(final Throwable t); public static String getMessage(final Throwable th); public static String getRootCauseMessage(final Throwable th); String WRAPPED_MARKER=Optional[" [wrapped] "]; String[] CAUSE_METHOD_NAMES=Optional[{ "getCause", "getNextException", "getTargetException", "getException", "getSourceException", "getRootCause", "getCausedByException", "getNested", "getLinkedException", "getNestedException", "getLinkedCause", "getThrowable" }
public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz) { [EOL]     return indexOf(throwable, clazz, 0, false); [EOL] } public ExceptionUtils(); public static String[] getDefaultCauseMethodNames(); public static Throwable getCause(final Throwable throwable); public static Throwable getCause(final Throwable throwable, String[] methodNames); public static Throwable getRootCause(final Throwable throwable); private static Throwable getCauseUsingMethodName(final Throwable throwable, final String methodName); public static int getThrowableCount(final Throwable throwable); public static Throwable[] getThrowables(final Throwable throwable); public static List<Throwable> getThrowableList(Throwable throwable); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz, final int fromIndex); public static int indexOfType(final Throwable throwable, final Class<?> type); public static int indexOfType(final Throwable throwable, final Class<?> type, final int fromIndex); private static int indexOf(final Throwable throwable, final Class<?> type, int fromIndex, final boolean subclass); public static void printRootCauseStackTrace(final Throwable throwable); public static void printRootCauseStackTrace(final Throwable throwable, final PrintStream stream); public static void printRootCauseStackTrace(final Throwable throwable, final PrintWriter writer); public static String[] getRootCauseStackTrace(final Throwable throwable); public static void removeCommonFrames(final List<String> causeFrames, final List<String> wrapperFrames); public static String getStackTrace(final Throwable throwable); public static String[] getStackFrames(final Throwable throwable);  static String[] getStackFrames(final String stackTrace);  static List<String> getStackFrameList(final Throwable t); public static String getMessage(final Throwable th); public static String getRootCauseMessage(final Throwable th); String WRAPPED_MARKER=Optional[" [wrapped] "]; String[] CAUSE_METHOD_NAMES=Optional[{ "getCause", "getNextException", "getTargetException", "getException", "getSourceException", "getRootCause", "getCausedByException", "getNested", "getLinkedException", "getNestedException", "getLinkedCause", "getThrowable" }
public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz, final int fromIndex) { [EOL]     return indexOf(throwable, clazz, fromIndex, false); [EOL] } public ExceptionUtils(); public static String[] getDefaultCauseMethodNames(); public static Throwable getCause(final Throwable throwable); public static Throwable getCause(final Throwable throwable, String[] methodNames); public static Throwable getRootCause(final Throwable throwable); private static Throwable getCauseUsingMethodName(final Throwable throwable, final String methodName); public static int getThrowableCount(final Throwable throwable); public static Throwable[] getThrowables(final Throwable throwable); public static List<Throwable> getThrowableList(Throwable throwable); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz, final int fromIndex); public static int indexOfType(final Throwable throwable, final Class<?> type); public static int indexOfType(final Throwable throwable, final Class<?> type, final int fromIndex); private static int indexOf(final Throwable throwable, final Class<?> type, int fromIndex, final boolean subclass); public static void printRootCauseStackTrace(final Throwable throwable); public static void printRootCauseStackTrace(final Throwable throwable, final PrintStream stream); public static void printRootCauseStackTrace(final Throwable throwable, final PrintWriter writer); public static String[] getRootCauseStackTrace(final Throwable throwable); public static void removeCommonFrames(final List<String> causeFrames, final List<String> wrapperFrames); public static String getStackTrace(final Throwable throwable); public static String[] getStackFrames(final Throwable throwable);  static String[] getStackFrames(final String stackTrace);  static List<String> getStackFrameList(final Throwable t); public static String getMessage(final Throwable th); public static String getRootCauseMessage(final Throwable th); String WRAPPED_MARKER=Optional[" [wrapped] "]; String[] CAUSE_METHOD_NAMES=Optional[{ "getCause", "getNextException", "getTargetException", "getException", "getSourceException", "getRootCause", "getCausedByException", "getNested", "getLinkedException", "getNestedException", "getLinkedCause", "getThrowable" }
public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz, final int fromIndex) { [EOL]     return indexOf(throwable, clazz, fromIndex, false); [EOL] } public ExceptionUtils(); public static String[] getDefaultCauseMethodNames(); public static Throwable getCause(final Throwable throwable); public static Throwable getCause(final Throwable throwable, String[] methodNames); public static Throwable getRootCause(final Throwable throwable); private static Throwable getCauseUsingMethodName(final Throwable throwable, final String methodName); public static int getThrowableCount(final Throwable throwable); public static Throwable[] getThrowables(final Throwable throwable); public static List<Throwable> getThrowableList(Throwable throwable); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz, final int fromIndex); public static int indexOfType(final Throwable throwable, final Class<?> type); public static int indexOfType(final Throwable throwable, final Class<?> type, final int fromIndex); private static int indexOf(final Throwable throwable, final Class<?> type, int fromIndex, final boolean subclass); public static void printRootCauseStackTrace(final Throwable throwable); public static void printRootCauseStackTrace(final Throwable throwable, final PrintStream stream); public static void printRootCauseStackTrace(final Throwable throwable, final PrintWriter writer); public static String[] getRootCauseStackTrace(final Throwable throwable); public static void removeCommonFrames(final List<String> causeFrames, final List<String> wrapperFrames); public static String getStackTrace(final Throwable throwable); public static String[] getStackFrames(final Throwable throwable);  static String[] getStackFrames(final String stackTrace);  static List<String> getStackFrameList(final Throwable t); public static String getMessage(final Throwable th); public static String getRootCauseMessage(final Throwable th); String WRAPPED_MARKER=Optional[" [wrapped] "]; String[] CAUSE_METHOD_NAMES=Optional[{ "getCause", "getNextException", "getTargetException", "getException", "getSourceException", "getRootCause", "getCausedByException", "getNested", "getLinkedException", "getNestedException", "getLinkedCause", "getThrowable" }
public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz, final int fromIndex) { [EOL]     return indexOf(throwable, clazz, fromIndex, false); [EOL] } public ExceptionUtils(); public static String[] getDefaultCauseMethodNames(); public static Throwable getCause(final Throwable throwable); public static Throwable getCause(final Throwable throwable, String[] methodNames); public static Throwable getRootCause(final Throwable throwable); private static Throwable getCauseUsingMethodName(final Throwable throwable, final String methodName); public static int getThrowableCount(final Throwable throwable); public static Throwable[] getThrowables(final Throwable throwable); public static List<Throwable> getThrowableList(Throwable throwable); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz, final int fromIndex); public static int indexOfType(final Throwable throwable, final Class<?> type); public static int indexOfType(final Throwable throwable, final Class<?> type, final int fromIndex); private static int indexOf(final Throwable throwable, final Class<?> type, int fromIndex, final boolean subclass); public static void printRootCauseStackTrace(final Throwable throwable); public static void printRootCauseStackTrace(final Throwable throwable, final PrintStream stream); public static void printRootCauseStackTrace(final Throwable throwable, final PrintWriter writer); public static String[] getRootCauseStackTrace(final Throwable throwable); public static void removeCommonFrames(final List<String> causeFrames, final List<String> wrapperFrames); public static String getStackTrace(final Throwable throwable); public static String[] getStackFrames(final Throwable throwable);  static String[] getStackFrames(final String stackTrace);  static List<String> getStackFrameList(final Throwable t); public static String getMessage(final Throwable th); public static String getRootCauseMessage(final Throwable th); String WRAPPED_MARKER=Optional[" [wrapped] "]; String[] CAUSE_METHOD_NAMES=Optional[{ "getCause", "getNextException", "getTargetException", "getException", "getSourceException", "getRootCause", "getCausedByException", "getNested", "getLinkedException", "getNestedException", "getLinkedCause", "getThrowable" }
public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz, final int fromIndex) { [EOL]     return indexOf(throwable, clazz, fromIndex, false); [EOL] } public ExceptionUtils(); public static String[] getDefaultCauseMethodNames(); public static Throwable getCause(final Throwable throwable); public static Throwable getCause(final Throwable throwable, String[] methodNames); public static Throwable getRootCause(final Throwable throwable); private static Throwable getCauseUsingMethodName(final Throwable throwable, final String methodName); public static int getThrowableCount(final Throwable throwable); public static Throwable[] getThrowables(final Throwable throwable); public static List<Throwable> getThrowableList(Throwable throwable); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz, final int fromIndex); public static int indexOfType(final Throwable throwable, final Class<?> type); public static int indexOfType(final Throwable throwable, final Class<?> type, final int fromIndex); private static int indexOf(final Throwable throwable, final Class<?> type, int fromIndex, final boolean subclass); public static void printRootCauseStackTrace(final Throwable throwable); public static void printRootCauseStackTrace(final Throwable throwable, final PrintStream stream); public static void printRootCauseStackTrace(final Throwable throwable, final PrintWriter writer); public static String[] getRootCauseStackTrace(final Throwable throwable); public static void removeCommonFrames(final List<String> causeFrames, final List<String> wrapperFrames); public static String getStackTrace(final Throwable throwable); public static String[] getStackFrames(final Throwable throwable);  static String[] getStackFrames(final String stackTrace);  static List<String> getStackFrameList(final Throwable t); public static String getMessage(final Throwable th); public static String getRootCauseMessage(final Throwable th); String WRAPPED_MARKER=Optional[" [wrapped] "]; String[] CAUSE_METHOD_NAMES=Optional[{ "getCause", "getNextException", "getTargetException", "getException", "getSourceException", "getRootCause", "getCausedByException", "getNested", "getLinkedException", "getNestedException", "getLinkedCause", "getThrowable" }
public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz, final int fromIndex) { [EOL]     return indexOf(throwable, clazz, fromIndex, false); [EOL] } public ExceptionUtils(); public static String[] getDefaultCauseMethodNames(); public static Throwable getCause(final Throwable throwable); public static Throwable getCause(final Throwable throwable, String[] methodNames); public static Throwable getRootCause(final Throwable throwable); private static Throwable getCauseUsingMethodName(final Throwable throwable, final String methodName); public static int getThrowableCount(final Throwable throwable); public static Throwable[] getThrowables(final Throwable throwable); public static List<Throwable> getThrowableList(Throwable throwable); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz, final int fromIndex); public static int indexOfType(final Throwable throwable, final Class<?> type); public static int indexOfType(final Throwable throwable, final Class<?> type, final int fromIndex); private static int indexOf(final Throwable throwable, final Class<?> type, int fromIndex, final boolean subclass); public static void printRootCauseStackTrace(final Throwable throwable); public static void printRootCauseStackTrace(final Throwable throwable, final PrintStream stream); public static void printRootCauseStackTrace(final Throwable throwable, final PrintWriter writer); public static String[] getRootCauseStackTrace(final Throwable throwable); public static void removeCommonFrames(final List<String> causeFrames, final List<String> wrapperFrames); public static String getStackTrace(final Throwable throwable); public static String[] getStackFrames(final Throwable throwable);  static String[] getStackFrames(final String stackTrace);  static List<String> getStackFrameList(final Throwable t); public static String getMessage(final Throwable th); public static String getRootCauseMessage(final Throwable th); String WRAPPED_MARKER=Optional[" [wrapped] "]; String[] CAUSE_METHOD_NAMES=Optional[{ "getCause", "getNextException", "getTargetException", "getException", "getSourceException", "getRootCause", "getCausedByException", "getNested", "getLinkedException", "getNestedException", "getLinkedCause", "getThrowable" }
public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz, final int fromIndex) { [EOL]     return indexOf(throwable, clazz, fromIndex, false); [EOL] } public ExceptionUtils(); public static String[] getDefaultCauseMethodNames(); public static Throwable getCause(final Throwable throwable); public static Throwable getCause(final Throwable throwable, String[] methodNames); public static Throwable getRootCause(final Throwable throwable); private static Throwable getCauseUsingMethodName(final Throwable throwable, final String methodName); public static int getThrowableCount(final Throwable throwable); public static Throwable[] getThrowables(final Throwable throwable); public static List<Throwable> getThrowableList(Throwable throwable); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz, final int fromIndex); public static int indexOfType(final Throwable throwable, final Class<?> type); public static int indexOfType(final Throwable throwable, final Class<?> type, final int fromIndex); private static int indexOf(final Throwable throwable, final Class<?> type, int fromIndex, final boolean subclass); public static void printRootCauseStackTrace(final Throwable throwable); public static void printRootCauseStackTrace(final Throwable throwable, final PrintStream stream); public static void printRootCauseStackTrace(final Throwable throwable, final PrintWriter writer); public static String[] getRootCauseStackTrace(final Throwable throwable); public static void removeCommonFrames(final List<String> causeFrames, final List<String> wrapperFrames); public static String getStackTrace(final Throwable throwable); public static String[] getStackFrames(final Throwable throwable);  static String[] getStackFrames(final String stackTrace);  static List<String> getStackFrameList(final Throwable t); public static String getMessage(final Throwable th); public static String getRootCauseMessage(final Throwable th); String WRAPPED_MARKER=Optional[" [wrapped] "]; String[] CAUSE_METHOD_NAMES=Optional[{ "getCause", "getNextException", "getTargetException", "getException", "getSourceException", "getRootCause", "getCausedByException", "getNested", "getLinkedException", "getNestedException", "getLinkedCause", "getThrowable" }
private static int indexOf(final Throwable throwable, final Class<?> type, int fromIndex, final boolean subclass) { [EOL]     if (throwable == null || type == null) { [EOL]         return -1; [EOL]     } [EOL]     if (fromIndex < 0) { [EOL]         fromIndex = 0; [EOL]     } [EOL]     final Throwable[] throwables = ExceptionUtils.getThrowables(throwable); [EOL]     if (fromIndex >= throwables.length) { [EOL]         return -1; [EOL]     } [EOL]     if (subclass) { [EOL]         for (int i = fromIndex; i < throwables.length; i++) { [EOL]             if (type.isAssignableFrom(throwables[i].getClass())) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         for (int i = fromIndex; i < throwables.length; i++) { [EOL]             if (type.equals(throwables[i].getClass())) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]     } [EOL]     return -1; [EOL] } public ExceptionUtils(); public static String[] getDefaultCauseMethodNames(); public static Throwable getCause(final Throwable throwable); public static Throwable getCause(final Throwable throwable, String[] methodNames); public static Throwable getRootCause(final Throwable throwable); private static Throwable getCauseUsingMethodName(final Throwable throwable, final String methodName); public static int getThrowableCount(final Throwable throwable); public static Throwable[] getThrowables(final Throwable throwable); public static List<Throwable> getThrowableList(Throwable throwable); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz, final int fromIndex); public static int indexOfType(final Throwable throwable, final Class<?> type); public static int indexOfType(final Throwable throwable, final Class<?> type, final int fromIndex); private static int indexOf(final Throwable throwable, final Class<?> type, int fromIndex, final boolean subclass); public static void printRootCauseStackTrace(final Throwable throwable); public static void printRootCauseStackTrace(final Throwable throwable, final PrintStream stream); public static void printRootCauseStackTrace(final Throwable throwable, final PrintWriter writer); public static String[] getRootCauseStackTrace(final Throwable throwable); public static void removeCommonFrames(final List<String> causeFrames, final List<String> wrapperFrames); public static String getStackTrace(final Throwable throwable); public static String[] getStackFrames(final Throwable throwable);  static String[] getStackFrames(final String stackTrace);  static List<String> getStackFrameList(final Throwable t); public static String getMessage(final Throwable th); public static String getRootCauseMessage(final Throwable th); String WRAPPED_MARKER=Optional[" [wrapped] "]; String[] CAUSE_METHOD_NAMES=Optional[{ "getCause", "getNextException", "getTargetException", "getException", "getSourceException", "getRootCause", "getCausedByException", "getNested", "getLinkedException", "getNestedException", "getLinkedCause", "getThrowable" }
private static int indexOf(final Throwable throwable, final Class<?> type, int fromIndex, final boolean subclass) { [EOL]     if (throwable == null || type == null) { [EOL]         return -1; [EOL]     } [EOL]     if (fromIndex < 0) { [EOL]         fromIndex = 0; [EOL]     } [EOL]     final Throwable[] throwables = ExceptionUtils.getThrowables(throwable); [EOL]     if (fromIndex >= throwables.length) { [EOL]         return -1; [EOL]     } [EOL]     if (subclass) { [EOL]         for (int i = fromIndex; i < throwables.length; i++) { [EOL]             if (type.isAssignableFrom(throwables[i].getClass())) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         for (int i = fromIndex; i < throwables.length; i++) { [EOL]             if (type.equals(throwables[i].getClass())) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]     } [EOL]     return -1; [EOL] } public ExceptionUtils(); public static String[] getDefaultCauseMethodNames(); public static Throwable getCause(final Throwable throwable); public static Throwable getCause(final Throwable throwable, String[] methodNames); public static Throwable getRootCause(final Throwable throwable); private static Throwable getCauseUsingMethodName(final Throwable throwable, final String methodName); public static int getThrowableCount(final Throwable throwable); public static Throwable[] getThrowables(final Throwable throwable); public static List<Throwable> getThrowableList(Throwable throwable); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz, final int fromIndex); public static int indexOfType(final Throwable throwable, final Class<?> type); public static int indexOfType(final Throwable throwable, final Class<?> type, final int fromIndex); private static int indexOf(final Throwable throwable, final Class<?> type, int fromIndex, final boolean subclass); public static void printRootCauseStackTrace(final Throwable throwable); public static void printRootCauseStackTrace(final Throwable throwable, final PrintStream stream); public static void printRootCauseStackTrace(final Throwable throwable, final PrintWriter writer); public static String[] getRootCauseStackTrace(final Throwable throwable); public static void removeCommonFrames(final List<String> causeFrames, final List<String> wrapperFrames); public static String getStackTrace(final Throwable throwable); public static String[] getStackFrames(final Throwable throwable);  static String[] getStackFrames(final String stackTrace);  static List<String> getStackFrameList(final Throwable t); public static String getMessage(final Throwable th); public static String getRootCauseMessage(final Throwable th); String WRAPPED_MARKER=Optional[" [wrapped] "]; String[] CAUSE_METHOD_NAMES=Optional[{ "getCause", "getNextException", "getTargetException", "getException", "getSourceException", "getRootCause", "getCausedByException", "getNested", "getLinkedException", "getNestedException", "getLinkedCause", "getThrowable" }
private static int indexOf(final Throwable throwable, final Class<?> type, int fromIndex, final boolean subclass) { [EOL]     if (throwable == null || type == null) { [EOL]         return -1; [EOL]     } [EOL]     if (fromIndex < 0) { [EOL]         fromIndex = 0; [EOL]     } [EOL]     final Throwable[] throwables = ExceptionUtils.getThrowables(throwable); [EOL]     if (fromIndex >= throwables.length) { [EOL]         return -1; [EOL]     } [EOL]     if (subclass) { [EOL]         for (int i = fromIndex; i < throwables.length; i++) { [EOL]             if (type.isAssignableFrom(throwables[i].getClass())) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         for (int i = fromIndex; i < throwables.length; i++) { [EOL]             if (type.equals(throwables[i].getClass())) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]     } [EOL]     return -1; [EOL] } public ExceptionUtils(); public static String[] getDefaultCauseMethodNames(); public static Throwable getCause(final Throwable throwable); public static Throwable getCause(final Throwable throwable, String[] methodNames); public static Throwable getRootCause(final Throwable throwable); private static Throwable getCauseUsingMethodName(final Throwable throwable, final String methodName); public static int getThrowableCount(final Throwable throwable); public static Throwable[] getThrowables(final Throwable throwable); public static List<Throwable> getThrowableList(Throwable throwable); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz, final int fromIndex); public static int indexOfType(final Throwable throwable, final Class<?> type); public static int indexOfType(final Throwable throwable, final Class<?> type, final int fromIndex); private static int indexOf(final Throwable throwable, final Class<?> type, int fromIndex, final boolean subclass); public static void printRootCauseStackTrace(final Throwable throwable); public static void printRootCauseStackTrace(final Throwable throwable, final PrintStream stream); public static void printRootCauseStackTrace(final Throwable throwable, final PrintWriter writer); public static String[] getRootCauseStackTrace(final Throwable throwable); public static void removeCommonFrames(final List<String> causeFrames, final List<String> wrapperFrames); public static String getStackTrace(final Throwable throwable); public static String[] getStackFrames(final Throwable throwable);  static String[] getStackFrames(final String stackTrace);  static List<String> getStackFrameList(final Throwable t); public static String getMessage(final Throwable th); public static String getRootCauseMessage(final Throwable th); String WRAPPED_MARKER=Optional[" [wrapped] "]; String[] CAUSE_METHOD_NAMES=Optional[{ "getCause", "getNextException", "getTargetException", "getException", "getSourceException", "getRootCause", "getCausedByException", "getNested", "getLinkedException", "getNestedException", "getLinkedCause", "getThrowable" }
private static int indexOf(final Throwable throwable, final Class<?> type, int fromIndex, final boolean subclass) { [EOL]     if (throwable == null || type == null) { [EOL]         return -1; [EOL]     } [EOL]     if (fromIndex < 0) { [EOL]         fromIndex = 0; [EOL]     } [EOL]     final Throwable[] throwables = ExceptionUtils.getThrowables(throwable); [EOL]     if (fromIndex >= throwables.length) { [EOL]         return -1; [EOL]     } [EOL]     if (subclass) { [EOL]         for (int i = fromIndex; i < throwables.length; i++) { [EOL]             if (type.isAssignableFrom(throwables[i].getClass())) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         for (int i = fromIndex; i < throwables.length; i++) { [EOL]             if (type.equals(throwables[i].getClass())) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]     } [EOL]     return -1; [EOL] } public ExceptionUtils(); public static String[] getDefaultCauseMethodNames(); public static Throwable getCause(final Throwable throwable); public static Throwable getCause(final Throwable throwable, String[] methodNames); public static Throwable getRootCause(final Throwable throwable); private static Throwable getCauseUsingMethodName(final Throwable throwable, final String methodName); public static int getThrowableCount(final Throwable throwable); public static Throwable[] getThrowables(final Throwable throwable); public static List<Throwable> getThrowableList(Throwable throwable); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz, final int fromIndex); public static int indexOfType(final Throwable throwable, final Class<?> type); public static int indexOfType(final Throwable throwable, final Class<?> type, final int fromIndex); private static int indexOf(final Throwable throwable, final Class<?> type, int fromIndex, final boolean subclass); public static void printRootCauseStackTrace(final Throwable throwable); public static void printRootCauseStackTrace(final Throwable throwable, final PrintStream stream); public static void printRootCauseStackTrace(final Throwable throwable, final PrintWriter writer); public static String[] getRootCauseStackTrace(final Throwable throwable); public static void removeCommonFrames(final List<String> causeFrames, final List<String> wrapperFrames); public static String getStackTrace(final Throwable throwable); public static String[] getStackFrames(final Throwable throwable);  static String[] getStackFrames(final String stackTrace);  static List<String> getStackFrameList(final Throwable t); public static String getMessage(final Throwable th); public static String getRootCauseMessage(final Throwable th); String WRAPPED_MARKER=Optional[" [wrapped] "]; String[] CAUSE_METHOD_NAMES=Optional[{ "getCause", "getNextException", "getTargetException", "getException", "getSourceException", "getRootCause", "getCausedByException", "getNested", "getLinkedException", "getNestedException", "getLinkedCause", "getThrowable" }
private static int indexOf(final Throwable throwable, final Class<?> type, int fromIndex, final boolean subclass) { [EOL]     if (throwable == null || type == null) { [EOL]         return -1; [EOL]     } [EOL]     if (fromIndex < 0) { [EOL]         fromIndex = 0; [EOL]     } [EOL]     final Throwable[] throwables = ExceptionUtils.getThrowables(throwable); [EOL]     if (fromIndex >= throwables.length) { [EOL]         return -1; [EOL]     } [EOL]     if (subclass) { [EOL]         for (int i = fromIndex; i < throwables.length; i++) { [EOL]             if (type.isAssignableFrom(throwables[i].getClass())) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         for (int i = fromIndex; i < throwables.length; i++) { [EOL]             if (type.equals(throwables[i].getClass())) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]     } [EOL]     return -1; [EOL] } public ExceptionUtils(); public static String[] getDefaultCauseMethodNames(); public static Throwable getCause(final Throwable throwable); public static Throwable getCause(final Throwable throwable, String[] methodNames); public static Throwable getRootCause(final Throwable throwable); private static Throwable getCauseUsingMethodName(final Throwable throwable, final String methodName); public static int getThrowableCount(final Throwable throwable); public static Throwable[] getThrowables(final Throwable throwable); public static List<Throwable> getThrowableList(Throwable throwable); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz, final int fromIndex); public static int indexOfType(final Throwable throwable, final Class<?> type); public static int indexOfType(final Throwable throwable, final Class<?> type, final int fromIndex); private static int indexOf(final Throwable throwable, final Class<?> type, int fromIndex, final boolean subclass); public static void printRootCauseStackTrace(final Throwable throwable); public static void printRootCauseStackTrace(final Throwable throwable, final PrintStream stream); public static void printRootCauseStackTrace(final Throwable throwable, final PrintWriter writer); public static String[] getRootCauseStackTrace(final Throwable throwable); public static void removeCommonFrames(final List<String> causeFrames, final List<String> wrapperFrames); public static String getStackTrace(final Throwable throwable); public static String[] getStackFrames(final Throwable throwable);  static String[] getStackFrames(final String stackTrace);  static List<String> getStackFrameList(final Throwable t); public static String getMessage(final Throwable th); public static String getRootCauseMessage(final Throwable th); String WRAPPED_MARKER=Optional[" [wrapped] "]; String[] CAUSE_METHOD_NAMES=Optional[{ "getCause", "getNextException", "getTargetException", "getException", "getSourceException", "getRootCause", "getCausedByException", "getNested", "getLinkedException", "getNestedException", "getLinkedCause", "getThrowable" }
private static int indexOf(final Throwable throwable, final Class<?> type, int fromIndex, final boolean subclass) { [EOL]     if (throwable == null || type == null) { [EOL]         return -1; [EOL]     } [EOL]     if (fromIndex < 0) { [EOL]         fromIndex = 0; [EOL]     } [EOL]     final Throwable[] throwables = ExceptionUtils.getThrowables(throwable); [EOL]     if (fromIndex >= throwables.length) { [EOL]         return -1; [EOL]     } [EOL]     if (subclass) { [EOL]         for (int i = fromIndex; i < throwables.length; i++) { [EOL]             if (type.isAssignableFrom(throwables[i].getClass())) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         for (int i = fromIndex; i < throwables.length; i++) { [EOL]             if (type.equals(throwables[i].getClass())) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]     } [EOL]     return -1; [EOL] } public ExceptionUtils(); public static String[] getDefaultCauseMethodNames(); public static Throwable getCause(final Throwable throwable); public static Throwable getCause(final Throwable throwable, String[] methodNames); public static Throwable getRootCause(final Throwable throwable); private static Throwable getCauseUsingMethodName(final Throwable throwable, final String methodName); public static int getThrowableCount(final Throwable throwable); public static Throwable[] getThrowables(final Throwable throwable); public static List<Throwable> getThrowableList(Throwable throwable); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz, final int fromIndex); public static int indexOfType(final Throwable throwable, final Class<?> type); public static int indexOfType(final Throwable throwable, final Class<?> type, final int fromIndex); private static int indexOf(final Throwable throwable, final Class<?> type, int fromIndex, final boolean subclass); public static void printRootCauseStackTrace(final Throwable throwable); public static void printRootCauseStackTrace(final Throwable throwable, final PrintStream stream); public static void printRootCauseStackTrace(final Throwable throwable, final PrintWriter writer); public static String[] getRootCauseStackTrace(final Throwable throwable); public static void removeCommonFrames(final List<String> causeFrames, final List<String> wrapperFrames); public static String getStackTrace(final Throwable throwable); public static String[] getStackFrames(final Throwable throwable);  static String[] getStackFrames(final String stackTrace);  static List<String> getStackFrameList(final Throwable t); public static String getMessage(final Throwable th); public static String getRootCauseMessage(final Throwable th); String WRAPPED_MARKER=Optional[" [wrapped] "]; String[] CAUSE_METHOD_NAMES=Optional[{ "getCause", "getNextException", "getTargetException", "getException", "getSourceException", "getRootCause", "getCausedByException", "getNested", "getLinkedException", "getNestedException", "getLinkedCause", "getThrowable" }
private static int indexOf(final Throwable throwable, final Class<?> type, int fromIndex, final boolean subclass) { [EOL]     if (throwable == null || type == null) { [EOL]         return -1; [EOL]     } [EOL]     if (fromIndex < 0) { [EOL]         fromIndex = 0; [EOL]     } [EOL]     final Throwable[] throwables = ExceptionUtils.getThrowables(throwable); [EOL]     if (fromIndex >= throwables.length) { [EOL]         return -1; [EOL]     } [EOL]     if (subclass) { [EOL]         for (int i = fromIndex; i < throwables.length; i++) { [EOL]             if (type.isAssignableFrom(throwables[i].getClass())) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         for (int i = fromIndex; i < throwables.length; i++) { [EOL]             if (type.equals(throwables[i].getClass())) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]     } [EOL]     return -1; [EOL] } public ExceptionUtils(); public static String[] getDefaultCauseMethodNames(); public static Throwable getCause(final Throwable throwable); public static Throwable getCause(final Throwable throwable, String[] methodNames); public static Throwable getRootCause(final Throwable throwable); private static Throwable getCauseUsingMethodName(final Throwable throwable, final String methodName); public static int getThrowableCount(final Throwable throwable); public static Throwable[] getThrowables(final Throwable throwable); public static List<Throwable> getThrowableList(Throwable throwable); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz, final int fromIndex); public static int indexOfType(final Throwable throwable, final Class<?> type); public static int indexOfType(final Throwable throwable, final Class<?> type, final int fromIndex); private static int indexOf(final Throwable throwable, final Class<?> type, int fromIndex, final boolean subclass); public static void printRootCauseStackTrace(final Throwable throwable); public static void printRootCauseStackTrace(final Throwable throwable, final PrintStream stream); public static void printRootCauseStackTrace(final Throwable throwable, final PrintWriter writer); public static String[] getRootCauseStackTrace(final Throwable throwable); public static void removeCommonFrames(final List<String> causeFrames, final List<String> wrapperFrames); public static String getStackTrace(final Throwable throwable); public static String[] getStackFrames(final Throwable throwable);  static String[] getStackFrames(final String stackTrace);  static List<String> getStackFrameList(final Throwable t); public static String getMessage(final Throwable th); public static String getRootCauseMessage(final Throwable th); String WRAPPED_MARKER=Optional[" [wrapped] "]; String[] CAUSE_METHOD_NAMES=Optional[{ "getCause", "getNextException", "getTargetException", "getException", "getSourceException", "getRootCause", "getCausedByException", "getNested", "getLinkedException", "getNestedException", "getLinkedCause", "getThrowable" }
private static int indexOf(final Throwable throwable, final Class<?> type, int fromIndex, final boolean subclass) { [EOL]     if (throwable == null || type == null) { [EOL]         return -1; [EOL]     } [EOL]     if (fromIndex < 0) { [EOL]         fromIndex = 0; [EOL]     } [EOL]     final Throwable[] throwables = ExceptionUtils.getThrowables(throwable); [EOL]     if (fromIndex >= throwables.length) { [EOL]         return -1; [EOL]     } [EOL]     if (subclass) { [EOL]         for (int i = fromIndex; i < throwables.length; i++) { [EOL]             if (type.isAssignableFrom(throwables[i].getClass())) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         for (int i = fromIndex; i < throwables.length; i++) { [EOL]             if (type.equals(throwables[i].getClass())) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]     } [EOL]     return -1; [EOL] } public ExceptionUtils(); public static String[] getDefaultCauseMethodNames(); public static Throwable getCause(final Throwable throwable); public static Throwable getCause(final Throwable throwable, String[] methodNames); public static Throwable getRootCause(final Throwable throwable); private static Throwable getCauseUsingMethodName(final Throwable throwable, final String methodName); public static int getThrowableCount(final Throwable throwable); public static Throwable[] getThrowables(final Throwable throwable); public static List<Throwable> getThrowableList(Throwable throwable); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz, final int fromIndex); public static int indexOfType(final Throwable throwable, final Class<?> type); public static int indexOfType(final Throwable throwable, final Class<?> type, final int fromIndex); private static int indexOf(final Throwable throwable, final Class<?> type, int fromIndex, final boolean subclass); public static void printRootCauseStackTrace(final Throwable throwable); public static void printRootCauseStackTrace(final Throwable throwable, final PrintStream stream); public static void printRootCauseStackTrace(final Throwable throwable, final PrintWriter writer); public static String[] getRootCauseStackTrace(final Throwable throwable); public static void removeCommonFrames(final List<String> causeFrames, final List<String> wrapperFrames); public static String getStackTrace(final Throwable throwable); public static String[] getStackFrames(final Throwable throwable);  static String[] getStackFrames(final String stackTrace);  static List<String> getStackFrameList(final Throwable t); public static String getMessage(final Throwable th); public static String getRootCauseMessage(final Throwable th); String WRAPPED_MARKER=Optional[" [wrapped] "]; String[] CAUSE_METHOD_NAMES=Optional[{ "getCause", "getNextException", "getTargetException", "getException", "getSourceException", "getRootCause", "getCausedByException", "getNested", "getLinkedException", "getNestedException", "getLinkedCause", "getThrowable" }
public void increment() { [EOL]     value++; [EOL] }
public void increment() { [EOL]     value++; [EOL] }
public void subtract(final Number operand) { [EOL]     this.value -= operand.shortValue(); [EOL] }
@Override [EOL] public int compareTo(final MutableShort other) { [EOL]     final short anotherVal = other.value; [EOL]     return value < anotherVal ? -1 : (value == anotherVal ? 0 : 1); [EOL] }
@Override [EOL] public int compareTo(final MutableShort other) { [EOL]     final short anotherVal = other.value; [EOL]     return value < anotherVal ? -1 : (value == anotherVal ? 0 : 1); [EOL] }
@Override [EOL] public int compareTo(final MutableShort other) { [EOL]     final short anotherVal = other.value; [EOL]     return value < anotherVal ? -1 : (value == anotherVal ? 0 : 1); [EOL] }
public static int reflectionCompare(final Object lhs, final Object rhs, final boolean compareTransients) { [EOL]     return reflectionCompare(lhs, rhs, compareTransients, null); [EOL] }
public static int reflectionCompare(final Object lhs, final Object rhs, final boolean compareTransients) { [EOL]     return reflectionCompare(lhs, rhs, compareTransients, null); [EOL] }
public static int reflectionCompare(final Object lhs, final Object rhs, final boolean compareTransients) { [EOL]     return reflectionCompare(lhs, rhs, compareTransients, null); [EOL] }
public static int reflectionCompare(final Object lhs, final Object rhs, final boolean compareTransients) { [EOL]     return reflectionCompare(lhs, rhs, compareTransients, null); [EOL] }
public static int reflectionCompare(final Object lhs, final Object rhs, final boolean compareTransients, final Class<?> reflectUpToClass, final String... excludeFields) { [EOL]     if (lhs == rhs) { [EOL]         return 0; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         throw new NullPointerException(); [EOL]     } [EOL]     Class<?> lhsClazz = lhs.getClass(); [EOL]     if (!lhsClazz.isInstance(rhs)) { [EOL]         throw new ClassCastException(); [EOL]     } [EOL]     final CompareToBuilder compareToBuilder = new CompareToBuilder(); [EOL]     reflectionAppend(lhs, rhs, lhsClazz, compareToBuilder, compareTransients, excludeFields); [EOL]     while (lhsClazz.getSuperclass() != null && lhsClazz != reflectUpToClass) { [EOL]         lhsClazz = lhsClazz.getSuperclass(); [EOL]         reflectionAppend(lhs, rhs, lhsClazz, compareToBuilder, compareTransients, excludeFields); [EOL]     } [EOL]     return compareToBuilder.toComparison(); [EOL] }
public CompareToBuilder append(final Object lhs, final Object rhs, final Comparator<?> comparator) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.getClass().isArray()) { [EOL]         if (lhs instanceof long[]) { [EOL]             append((long[]) lhs, (long[]) rhs); [EOL]         } else if (lhs instanceof int[]) { [EOL]             append((int[]) lhs, (int[]) rhs); [EOL]         } else if (lhs instanceof short[]) { [EOL]             append((short[]) lhs, (short[]) rhs); [EOL]         } else if (lhs instanceof char[]) { [EOL]             append((char[]) lhs, (char[]) rhs); [EOL]         } else if (lhs instanceof byte[]) { [EOL]             append((byte[]) lhs, (byte[]) rhs); [EOL]         } else if (lhs instanceof double[]) { [EOL]             append((double[]) lhs, (double[]) rhs); [EOL]         } else if (lhs instanceof float[]) { [EOL]             append((float[]) lhs, (float[]) rhs); [EOL]         } else if (lhs instanceof boolean[]) { [EOL]             append((boolean[]) lhs, (boolean[]) rhs); [EOL]         } else { [EOL]             append((Object[]) lhs, (Object[]) rhs, comparator); [EOL]         } [EOL]     } else { [EOL]         if (comparator == null) { [EOL]             @SuppressWarnings("unchecked") [EOL]             final Comparable<Object> comparable = (Comparable<Object>) lhs; [EOL]             comparison = comparable.compareTo(rhs); [EOL]         } else { [EOL]             @SuppressWarnings("unchecked") [EOL]             final Comparator<Object> comparator2 = (Comparator<Object>) comparator; [EOL]             comparison = comparator2.compare(lhs, rhs); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public CompareToBuilder append(final Object lhs, final Object rhs, final Comparator<?> comparator) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.getClass().isArray()) { [EOL]         if (lhs instanceof long[]) { [EOL]             append((long[]) lhs, (long[]) rhs); [EOL]         } else if (lhs instanceof int[]) { [EOL]             append((int[]) lhs, (int[]) rhs); [EOL]         } else if (lhs instanceof short[]) { [EOL]             append((short[]) lhs, (short[]) rhs); [EOL]         } else if (lhs instanceof char[]) { [EOL]             append((char[]) lhs, (char[]) rhs); [EOL]         } else if (lhs instanceof byte[]) { [EOL]             append((byte[]) lhs, (byte[]) rhs); [EOL]         } else if (lhs instanceof double[]) { [EOL]             append((double[]) lhs, (double[]) rhs); [EOL]         } else if (lhs instanceof float[]) { [EOL]             append((float[]) lhs, (float[]) rhs); [EOL]         } else if (lhs instanceof boolean[]) { [EOL]             append((boolean[]) lhs, (boolean[]) rhs); [EOL]         } else { [EOL]             append((Object[]) lhs, (Object[]) rhs, comparator); [EOL]         } [EOL]     } else { [EOL]         if (comparator == null) { [EOL]             @SuppressWarnings("unchecked") [EOL]             final Comparable<Object> comparable = (Comparable<Object>) lhs; [EOL]             comparison = comparable.compareTo(rhs); [EOL]         } else { [EOL]             @SuppressWarnings("unchecked") [EOL]             final Comparator<Object> comparator2 = (Comparator<Object>) comparator; [EOL]             comparison = comparator2.compare(lhs, rhs); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public CompareToBuilder append(final Object lhs, final Object rhs, final Comparator<?> comparator) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.getClass().isArray()) { [EOL]         if (lhs instanceof long[]) { [EOL]             append((long[]) lhs, (long[]) rhs); [EOL]         } else if (lhs instanceof int[]) { [EOL]             append((int[]) lhs, (int[]) rhs); [EOL]         } else if (lhs instanceof short[]) { [EOL]             append((short[]) lhs, (short[]) rhs); [EOL]         } else if (lhs instanceof char[]) { [EOL]             append((char[]) lhs, (char[]) rhs); [EOL]         } else if (lhs instanceof byte[]) { [EOL]             append((byte[]) lhs, (byte[]) rhs); [EOL]         } else if (lhs instanceof double[]) { [EOL]             append((double[]) lhs, (double[]) rhs); [EOL]         } else if (lhs instanceof float[]) { [EOL]             append((float[]) lhs, (float[]) rhs); [EOL]         } else if (lhs instanceof boolean[]) { [EOL]             append((boolean[]) lhs, (boolean[]) rhs); [EOL]         } else { [EOL]             append((Object[]) lhs, (Object[]) rhs, comparator); [EOL]         } [EOL]     } else { [EOL]         if (comparator == null) { [EOL]             @SuppressWarnings("unchecked") [EOL]             final Comparable<Object> comparable = (Comparable<Object>) lhs; [EOL]             comparison = comparable.compareTo(rhs); [EOL]         } else { [EOL]             @SuppressWarnings("unchecked") [EOL]             final Comparator<Object> comparator2 = (Comparator<Object>) comparator; [EOL]             comparison = comparator2.compare(lhs, rhs); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public CompareToBuilder append(final Object lhs, final Object rhs, final Comparator<?> comparator) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.getClass().isArray()) { [EOL]         if (lhs instanceof long[]) { [EOL]             append((long[]) lhs, (long[]) rhs); [EOL]         } else if (lhs instanceof int[]) { [EOL]             append((int[]) lhs, (int[]) rhs); [EOL]         } else if (lhs instanceof short[]) { [EOL]             append((short[]) lhs, (short[]) rhs); [EOL]         } else if (lhs instanceof char[]) { [EOL]             append((char[]) lhs, (char[]) rhs); [EOL]         } else if (lhs instanceof byte[]) { [EOL]             append((byte[]) lhs, (byte[]) rhs); [EOL]         } else if (lhs instanceof double[]) { [EOL]             append((double[]) lhs, (double[]) rhs); [EOL]         } else if (lhs instanceof float[]) { [EOL]             append((float[]) lhs, (float[]) rhs); [EOL]         } else if (lhs instanceof boolean[]) { [EOL]             append((boolean[]) lhs, (boolean[]) rhs); [EOL]         } else { [EOL]             append((Object[]) lhs, (Object[]) rhs, comparator); [EOL]         } [EOL]     } else { [EOL]         if (comparator == null) { [EOL]             @SuppressWarnings("unchecked") [EOL]             final Comparable<Object> comparable = (Comparable<Object>) lhs; [EOL]             comparison = comparable.compareTo(rhs); [EOL]         } else { [EOL]             @SuppressWarnings("unchecked") [EOL]             final Comparator<Object> comparator2 = (Comparator<Object>) comparator; [EOL]             comparison = comparator2.compare(lhs, rhs); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public CompareToBuilder append(final Object lhs, final Object rhs, final Comparator<?> comparator) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.getClass().isArray()) { [EOL]         if (lhs instanceof long[]) { [EOL]             append((long[]) lhs, (long[]) rhs); [EOL]         } else if (lhs instanceof int[]) { [EOL]             append((int[]) lhs, (int[]) rhs); [EOL]         } else if (lhs instanceof short[]) { [EOL]             append((short[]) lhs, (short[]) rhs); [EOL]         } else if (lhs instanceof char[]) { [EOL]             append((char[]) lhs, (char[]) rhs); [EOL]         } else if (lhs instanceof byte[]) { [EOL]             append((byte[]) lhs, (byte[]) rhs); [EOL]         } else if (lhs instanceof double[]) { [EOL]             append((double[]) lhs, (double[]) rhs); [EOL]         } else if (lhs instanceof float[]) { [EOL]             append((float[]) lhs, (float[]) rhs); [EOL]         } else if (lhs instanceof boolean[]) { [EOL]             append((boolean[]) lhs, (boolean[]) rhs); [EOL]         } else { [EOL]             append((Object[]) lhs, (Object[]) rhs, comparator); [EOL]         } [EOL]     } else { [EOL]         if (comparator == null) { [EOL]             @SuppressWarnings("unchecked") [EOL]             final Comparable<Object> comparable = (Comparable<Object>) lhs; [EOL]             comparison = comparable.compareTo(rhs); [EOL]         } else { [EOL]             @SuppressWarnings("unchecked") [EOL]             final Comparator<Object> comparator2 = (Comparator<Object>) comparator; [EOL]             comparison = comparator2.compare(lhs, rhs); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public CompareToBuilder append(final Object lhs, final Object rhs, final Comparator<?> comparator) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.getClass().isArray()) { [EOL]         if (lhs instanceof long[]) { [EOL]             append((long[]) lhs, (long[]) rhs); [EOL]         } else if (lhs instanceof int[]) { [EOL]             append((int[]) lhs, (int[]) rhs); [EOL]         } else if (lhs instanceof short[]) { [EOL]             append((short[]) lhs, (short[]) rhs); [EOL]         } else if (lhs instanceof char[]) { [EOL]             append((char[]) lhs, (char[]) rhs); [EOL]         } else if (lhs instanceof byte[]) { [EOL]             append((byte[]) lhs, (byte[]) rhs); [EOL]         } else if (lhs instanceof double[]) { [EOL]             append((double[]) lhs, (double[]) rhs); [EOL]         } else if (lhs instanceof float[]) { [EOL]             append((float[]) lhs, (float[]) rhs); [EOL]         } else if (lhs instanceof boolean[]) { [EOL]             append((boolean[]) lhs, (boolean[]) rhs); [EOL]         } else { [EOL]             append((Object[]) lhs, (Object[]) rhs, comparator); [EOL]         } [EOL]     } else { [EOL]         if (comparator == null) { [EOL]             @SuppressWarnings("unchecked") [EOL]             final Comparable<Object> comparable = (Comparable<Object>) lhs; [EOL]             comparison = comparable.compareTo(rhs); [EOL]         } else { [EOL]             @SuppressWarnings("unchecked") [EOL]             final Comparator<Object> comparator2 = (Comparator<Object>) comparator; [EOL]             comparison = comparator2.compare(lhs, rhs); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public CompareToBuilder append(final Object lhs, final Object rhs, final Comparator<?> comparator) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.getClass().isArray()) { [EOL]         if (lhs instanceof long[]) { [EOL]             append((long[]) lhs, (long[]) rhs); [EOL]         } else if (lhs instanceof int[]) { [EOL]             append((int[]) lhs, (int[]) rhs); [EOL]         } else if (lhs instanceof short[]) { [EOL]             append((short[]) lhs, (short[]) rhs); [EOL]         } else if (lhs instanceof char[]) { [EOL]             append((char[]) lhs, (char[]) rhs); [EOL]         } else if (lhs instanceof byte[]) { [EOL]             append((byte[]) lhs, (byte[]) rhs); [EOL]         } else if (lhs instanceof double[]) { [EOL]             append((double[]) lhs, (double[]) rhs); [EOL]         } else if (lhs instanceof float[]) { [EOL]             append((float[]) lhs, (float[]) rhs); [EOL]         } else if (lhs instanceof boolean[]) { [EOL]             append((boolean[]) lhs, (boolean[]) rhs); [EOL]         } else { [EOL]             append((Object[]) lhs, (Object[]) rhs, comparator); [EOL]         } [EOL]     } else { [EOL]         if (comparator == null) { [EOL]             @SuppressWarnings("unchecked") [EOL]             final Comparable<Object> comparable = (Comparable<Object>) lhs; [EOL]             comparison = comparable.compareTo(rhs); [EOL]         } else { [EOL]             @SuppressWarnings("unchecked") [EOL]             final Comparator<Object> comparator2 = (Comparator<Object>) comparator; [EOL]             comparison = comparator2.compare(lhs, rhs); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public CompareToBuilder append(final Object lhs, final Object rhs, final Comparator<?> comparator) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.getClass().isArray()) { [EOL]         if (lhs instanceof long[]) { [EOL]             append((long[]) lhs, (long[]) rhs); [EOL]         } else if (lhs instanceof int[]) { [EOL]             append((int[]) lhs, (int[]) rhs); [EOL]         } else if (lhs instanceof short[]) { [EOL]             append((short[]) lhs, (short[]) rhs); [EOL]         } else if (lhs instanceof char[]) { [EOL]             append((char[]) lhs, (char[]) rhs); [EOL]         } else if (lhs instanceof byte[]) { [EOL]             append((byte[]) lhs, (byte[]) rhs); [EOL]         } else if (lhs instanceof double[]) { [EOL]             append((double[]) lhs, (double[]) rhs); [EOL]         } else if (lhs instanceof float[]) { [EOL]             append((float[]) lhs, (float[]) rhs); [EOL]         } else if (lhs instanceof boolean[]) { [EOL]             append((boolean[]) lhs, (boolean[]) rhs); [EOL]         } else { [EOL]             append((Object[]) lhs, (Object[]) rhs, comparator); [EOL]         } [EOL]     } else { [EOL]         if (comparator == null) { [EOL]             @SuppressWarnings("unchecked") [EOL]             final Comparable<Object> comparable = (Comparable<Object>) lhs; [EOL]             comparison = comparable.compareTo(rhs); [EOL]         } else { [EOL]             @SuppressWarnings("unchecked") [EOL]             final Comparator<Object> comparator2 = (Comparator<Object>) comparator; [EOL]             comparison = comparator2.compare(lhs, rhs); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public CompareToBuilder append(final boolean lhs, final boolean rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == false) { [EOL]         comparison = -1; [EOL]     } else { [EOL]         comparison = +1; [EOL]     } [EOL]     return this; [EOL] }
public CompareToBuilder append(final boolean lhs, final boolean rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == false) { [EOL]         comparison = -1; [EOL]     } else { [EOL]         comparison = +1; [EOL]     } [EOL]     return this; [EOL] }
public CompareToBuilder append(final boolean lhs, final boolean rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == false) { [EOL]         comparison = -1; [EOL]     } else { [EOL]         comparison = +1; [EOL]     } [EOL]     return this; [EOL] }
public CompareToBuilder append(final boolean lhs, final boolean rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == false) { [EOL]         comparison = -1; [EOL]     } else { [EOL]         comparison = +1; [EOL]     } [EOL]     return this; [EOL] }
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public static boolean isBlank(final CharSequence cs) { [EOL]     int strLen; [EOL]     if (cs == null || (strLen = cs.length()) == 0) { [EOL]         return true; [EOL]     } [EOL]     for (int i = 0; i < strLen; i++) { [EOL]         if (Character.isWhitespace(cs.charAt(i)) == false) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public static boolean isBlank(final CharSequence cs) { [EOL]     int strLen; [EOL]     if (cs == null || (strLen = cs.length()) == 0) { [EOL]         return true; [EOL]     } [EOL]     for (int i = 0; i < strLen; i++) { [EOL]         if (Character.isWhitespace(cs.charAt(i)) == false) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public static boolean isBlank(final CharSequence cs) { [EOL]     int strLen; [EOL]     if (cs == null || (strLen = cs.length()) == 0) { [EOL]         return true; [EOL]     } [EOL]     for (int i = 0; i < strLen; i++) { [EOL]         if (Character.isWhitespace(cs.charAt(i)) == false) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public static boolean isBlank(final CharSequence cs) { [EOL]     int strLen; [EOL]     if (cs == null || (strLen = cs.length()) == 0) { [EOL]         return true; [EOL]     } [EOL]     for (int i = 0; i < strLen; i++) { [EOL]         if (Character.isWhitespace(cs.charAt(i)) == false) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public static boolean isBlank(final CharSequence cs) { [EOL]     int strLen; [EOL]     if (cs == null || (strLen = cs.length()) == 0) { [EOL]         return true; [EOL]     } [EOL]     for (int i = 0; i < strLen; i++) { [EOL]         if (Character.isWhitespace(cs.charAt(i)) == false) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public static boolean isNotBlank(final CharSequence cs) { [EOL]     return !StringUtils.isBlank(cs); [EOL] }
public static boolean isNotBlank(final CharSequence cs) { [EOL]     return !StringUtils.isBlank(cs); [EOL] }
public static boolean isNotBlank(final CharSequence cs) { [EOL]     return !StringUtils.isBlank(cs); [EOL] }
public static boolean isNotBlank(final CharSequence cs) { [EOL]     return !StringUtils.isBlank(cs); [EOL] }
public static String trim(final String str) { [EOL]     return str == null ? null : str.trim(); [EOL] }
public static String trim(final String str) { [EOL]     return str == null ? null : str.trim(); [EOL] }
public static String trim(final String str) { [EOL]     return str == null ? null : str.trim(); [EOL] }
public static String trim(final String str) { [EOL]     return str == null ? null : str.trim(); [EOL] }
public static String trim(final String str) { [EOL]     return str == null ? null : str.trim(); [EOL] }
public static String strip(final String str) { [EOL]     return strip(str, null); [EOL] }
public static String strip(final String str) { [EOL]     return strip(str, null); [EOL] }
public static String strip(final String str) { [EOL]     return strip(str, null); [EOL] }
public static String strip(final String str) { [EOL]     return strip(str, null); [EOL] }
public static String strip(final String str) { [EOL]     return strip(str, null); [EOL] }
public static String strip(final String str) { [EOL]     return strip(str, null); [EOL] }
public static String strip(final String str) { [EOL]     return strip(str, null); [EOL] }
public static String strip(String str, final String stripChars) { [EOL]     if (isEmpty(str)) { [EOL]         return str; [EOL]     } [EOL]     str = stripStart(str, stripChars); [EOL]     return stripEnd(str, stripChars); [EOL] }
public static String stripStart(final String str, final String stripChars) { [EOL]     int strLen; [EOL]     if (str == null || (strLen = str.length()) == 0) { [EOL]         return str; [EOL]     } [EOL]     int start = 0; [EOL]     if (stripChars == null) { [EOL]         while (start != strLen && Character.isWhitespace(str.charAt(start))) { [EOL]             start++; [EOL]         } [EOL]     } else if (stripChars.isEmpty()) { [EOL]         return str; [EOL]     } else { [EOL]         while (start != strLen && stripChars.indexOf(str.charAt(start)) != INDEX_NOT_FOUND) { [EOL]             start++; [EOL]         } [EOL]     } [EOL]     return str.substring(start); [EOL] }
public static String stripEnd(final String str, final String stripChars) { [EOL]     int end; [EOL]     if (str == null || (end = str.length()) == 0) { [EOL]         return str; [EOL]     } [EOL]     if (stripChars == null) { [EOL]         while (end != 0 && Character.isWhitespace(str.charAt(end - 1))) { [EOL]             end--; [EOL]         } [EOL]     } else if (stripChars.isEmpty()) { [EOL]         return str; [EOL]     } else { [EOL]         while (end != 0 && stripChars.indexOf(str.charAt(end - 1)) != INDEX_NOT_FOUND) { [EOL]             end--; [EOL]         } [EOL]     } [EOL]     return str.substring(0, end); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int indexOf(final CharSequence seq, final int searchChar) { [EOL]     if (isEmpty(seq)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     return CharSequenceUtils.indexOf(seq, searchChar, 0); [EOL] }
public static int indexOf(final CharSequence seq, final int searchChar) { [EOL]     if (isEmpty(seq)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     return CharSequenceUtils.indexOf(seq, searchChar, 0); [EOL] }
public static int indexOf(final CharSequence seq, final int searchChar) { [EOL]     if (isEmpty(seq)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     return CharSequenceUtils.indexOf(seq, searchChar, 0); [EOL] }
public static int indexOf(final CharSequence seq, final int searchChar) { [EOL]     if (isEmpty(seq)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     return CharSequenceUtils.indexOf(seq, searchChar, 0); [EOL] }
public static int ordinalIndexOf(final CharSequence str, final CharSequence searchStr, final int ordinal) { [EOL]     return ordinalIndexOf(str, searchStr, ordinal, false); [EOL] }
public static int ordinalIndexOf(final CharSequence str, final CharSequence searchStr, final int ordinal) { [EOL]     return ordinalIndexOf(str, searchStr, ordinal, false); [EOL] }
public static int ordinalIndexOf(final CharSequence str, final CharSequence searchStr, final int ordinal) { [EOL]     return ordinalIndexOf(str, searchStr, ordinal, false); [EOL] }
public static int ordinalIndexOf(final CharSequence str, final CharSequence searchStr, final int ordinal) { [EOL]     return ordinalIndexOf(str, searchStr, ordinal, false); [EOL] }
public static int ordinalIndexOf(final CharSequence str, final CharSequence searchStr, final int ordinal) { [EOL]     return ordinalIndexOf(str, searchStr, ordinal, false); [EOL] }
public static int ordinalIndexOf(final CharSequence str, final CharSequence searchStr, final int ordinal) { [EOL]     return ordinalIndexOf(str, searchStr, ordinal, false); [EOL] }
private static int ordinalIndexOf(final CharSequence str, final CharSequence searchStr, final int ordinal, final boolean lastIndex) { [EOL]     if (str == null || searchStr == null || ordinal <= 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (searchStr.length() == 0) { [EOL]         return lastIndex ? str.length() : 0; [EOL]     } [EOL]     int found = 0; [EOL]     int index = lastIndex ? str.length() : INDEX_NOT_FOUND; [EOL]     do { [EOL]         if (lastIndex) { [EOL]             index = CharSequenceUtils.lastIndexOf(str, searchStr, index - 1); [EOL]         } else { [EOL]             index = CharSequenceUtils.indexOf(str, searchStr, index + 1); [EOL]         } [EOL]         if (index < 0) { [EOL]             return index; [EOL]         } [EOL]         found++; [EOL]     } while (found < ordinal); [EOL]     return index; [EOL] }
private static int ordinalIndexOf(final CharSequence str, final CharSequence searchStr, final int ordinal, final boolean lastIndex) { [EOL]     if (str == null || searchStr == null || ordinal <= 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (searchStr.length() == 0) { [EOL]         return lastIndex ? str.length() : 0; [EOL]     } [EOL]     int found = 0; [EOL]     int index = lastIndex ? str.length() : INDEX_NOT_FOUND; [EOL]     do { [EOL]         if (lastIndex) { [EOL]             index = CharSequenceUtils.lastIndexOf(str, searchStr, index - 1); [EOL]         } else { [EOL]             index = CharSequenceUtils.indexOf(str, searchStr, index + 1); [EOL]         } [EOL]         if (index < 0) { [EOL]             return index; [EOL]         } [EOL]         found++; [EOL]     } while (found < ordinal); [EOL]     return index; [EOL] }
public static int indexOfIgnoreCase(final CharSequence str, final CharSequence searchStr, int startPos) { [EOL]     if (str == null || searchStr == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startPos < 0) { [EOL]         startPos = 0; [EOL]     } [EOL]     final int endLimit = str.length() - searchStr.length() + 1; [EOL]     if (startPos > endLimit) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (searchStr.length() == 0) { [EOL]         return startPos; [EOL]     } [EOL]     for (int i = startPos; i < endLimit; i++) { [EOL]         if (CharSequenceUtils.regionMatches(str, true, i, searchStr, 0, searchStr.length())) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int lastIndexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) { [EOL]     if (seq == null || searchSeq == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     return CharSequenceUtils.lastIndexOf(seq, searchSeq, startPos); [EOL] }
public static boolean containsAny(final CharSequence cs, final char... searchChars) { [EOL]     if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) { [EOL]         return false; [EOL]     } [EOL]     final int csLength = cs.length(); [EOL]     final int searchLength = searchChars.length; [EOL]     final int csLast = csLength - 1; [EOL]     final int searchLast = searchLength - 1; [EOL]     for (int i = 0; i < csLength; i++) { [EOL]         final char ch = cs.charAt(i); [EOL]         for (int j = 0; j < searchLength; j++) { [EOL]             if (searchChars[j] == ch) { [EOL]                 if (Character.isHighSurrogate(ch)) { [EOL]                     if (j == searchLast) { [EOL]                         return true; [EOL]                     } [EOL]                     if (i < csLast && searchChars[j + 1] == cs.charAt(i + 1)) { [EOL]                         return true; [EOL]                     } [EOL]                 } else { [EOL]                     return true; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public static boolean containsAny(final CharSequence cs, final char... searchChars) { [EOL]     if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) { [EOL]         return false; [EOL]     } [EOL]     final int csLength = cs.length(); [EOL]     final int searchLength = searchChars.length; [EOL]     final int csLast = csLength - 1; [EOL]     final int searchLast = searchLength - 1; [EOL]     for (int i = 0; i < csLength; i++) { [EOL]         final char ch = cs.charAt(i); [EOL]         for (int j = 0; j < searchLength; j++) { [EOL]             if (searchChars[j] == ch) { [EOL]                 if (Character.isHighSurrogate(ch)) { [EOL]                     if (j == searchLast) { [EOL]                         return true; [EOL]                     } [EOL]                     if (i < csLast && searchChars[j + 1] == cs.charAt(i + 1)) { [EOL]                         return true; [EOL]                     } [EOL]                 } else { [EOL]                     return true; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public static boolean containsAny(final CharSequence cs, final char... searchChars) { [EOL]     if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) { [EOL]         return false; [EOL]     } [EOL]     final int csLength = cs.length(); [EOL]     final int searchLength = searchChars.length; [EOL]     final int csLast = csLength - 1; [EOL]     final int searchLast = searchLength - 1; [EOL]     for (int i = 0; i < csLength; i++) { [EOL]         final char ch = cs.charAt(i); [EOL]         for (int j = 0; j < searchLength; j++) { [EOL]             if (searchChars[j] == ch) { [EOL]                 if (Character.isHighSurrogate(ch)) { [EOL]                     if (j == searchLast) { [EOL]                         return true; [EOL]                     } [EOL]                     if (i < csLast && searchChars[j + 1] == cs.charAt(i + 1)) { [EOL]                         return true; [EOL]                     } [EOL]                 } else { [EOL]                     return true; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public static boolean containsAny(final CharSequence cs, final char... searchChars) { [EOL]     if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) { [EOL]         return false; [EOL]     } [EOL]     final int csLength = cs.length(); [EOL]     final int searchLength = searchChars.length; [EOL]     final int csLast = csLength - 1; [EOL]     final int searchLast = searchLength - 1; [EOL]     for (int i = 0; i < csLength; i++) { [EOL]         final char ch = cs.charAt(i); [EOL]         for (int j = 0; j < searchLength; j++) { [EOL]             if (searchChars[j] == ch) { [EOL]                 if (Character.isHighSurrogate(ch)) { [EOL]                     if (j == searchLast) { [EOL]                         return true; [EOL]                     } [EOL]                     if (i < csLast && searchChars[j + 1] == cs.charAt(i + 1)) { [EOL]                         return true; [EOL]                     } [EOL]                 } else { [EOL]                     return true; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public static boolean containsAny(final CharSequence cs, final CharSequence searchChars) { [EOL]     if (searchChars == null) { [EOL]         return false; [EOL]     } [EOL]     return containsAny(cs, CharSequenceUtils.toCharArray(searchChars)); [EOL] }
public static String right(final String str, final int len) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (len < 0) { [EOL]         return EMPTY; [EOL]     } [EOL]     if (str.length() <= len) { [EOL]         return str; [EOL]     } [EOL]     return str.substring(str.length() - len); [EOL] }
public static String right(final String str, final int len) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (len < 0) { [EOL]         return EMPTY; [EOL]     } [EOL]     if (str.length() <= len) { [EOL]         return str; [EOL]     } [EOL]     return str.substring(str.length() - len); [EOL] }
public static String right(final String str, final int len) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (len < 0) { [EOL]         return EMPTY; [EOL]     } [EOL]     if (str.length() <= len) { [EOL]         return str; [EOL]     } [EOL]     return str.substring(str.length() - len); [EOL] }
public static String right(final String str, final int len) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (len < 0) { [EOL]         return EMPTY; [EOL]     } [EOL]     if (str.length() <= len) { [EOL]         return str; [EOL]     } [EOL]     return str.substring(str.length() - len); [EOL] }
public static String[] split(final String str, final char separatorChar) { [EOL]     return splitWorker(str, separatorChar, false); [EOL] }
public static String[] split(final String str, final char separatorChar) { [EOL]     return splitWorker(str, separatorChar, false); [EOL] }
public static String[] split(final String str, final char separatorChar) { [EOL]     return splitWorker(str, separatorChar, false); [EOL] }
public static String[] split(final String str, final char separatorChar) { [EOL]     return splitWorker(str, separatorChar, false); [EOL] }
public static String[] splitByWholeSeparatorPreserveAllTokens(final String str, final String separator, final int max) { [EOL]     return splitByWholeSeparatorWorker(str, separator, max, true); [EOL] }
public static String[] splitByWholeSeparatorPreserveAllTokens(final String str, final String separator, final int max) { [EOL]     return splitByWholeSeparatorWorker(str, separator, max, true); [EOL] }
public static String[] splitByWholeSeparatorPreserveAllTokens(final String str, final String separator, final int max) { [EOL]     return splitByWholeSeparatorWorker(str, separator, max, true); [EOL] }
public static String[] splitByWholeSeparatorPreserveAllTokens(final String str, final String separator, final int max) { [EOL]     return splitByWholeSeparatorWorker(str, separator, max, true); [EOL] }
public static String[] splitByWholeSeparatorPreserveAllTokens(final String str, final String separator, final int max) { [EOL]     return splitByWholeSeparatorWorker(str, separator, max, true); [EOL] }
public static String[] splitByWholeSeparatorPreserveAllTokens(final String str, final String separator, final int max) { [EOL]     return splitByWholeSeparatorWorker(str, separator, max, true); [EOL] }
private static String[] splitByWholeSeparatorWorker(final String str, final String separator, final int max, final boolean preserveAllTokens) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len == 0) { [EOL]         return ArrayUtils.EMPTY_STRING_ARRAY; [EOL]     } [EOL]     if (separator == null || EMPTY.equals(separator)) { [EOL]         return splitWorker(str, null, max, preserveAllTokens); [EOL]     } [EOL]     final int separatorLength = separator.length(); [EOL]     final ArrayList<String> substrings = new ArrayList<String>(); [EOL]     int numberOfSubstrings = 0; [EOL]     int beg = 0; [EOL]     int end = 0; [EOL]     while (end < len) { [EOL]         end = str.indexOf(separator, beg); [EOL]         if (end > -1) { [EOL]             if (end > beg) { [EOL]                 numberOfSubstrings += 1; [EOL]                 if (numberOfSubstrings == max) { [EOL]                     end = len; [EOL]                     substrings.add(str.substring(beg)); [EOL]                 } else { [EOL]                     substrings.add(str.substring(beg, end)); [EOL]                     beg = end + separatorLength; [EOL]                 } [EOL]             } else { [EOL]                 if (preserveAllTokens) { [EOL]                     numberOfSubstrings += 1; [EOL]                     if (numberOfSubstrings == max) { [EOL]                         end = len; [EOL]                         substrings.add(str.substring(beg)); [EOL]                     } else { [EOL]                         substrings.add(EMPTY); [EOL]                     } [EOL]                 } [EOL]                 beg = end + separatorLength; [EOL]             } [EOL]         } else { [EOL]             substrings.add(str.substring(beg)); [EOL]             end = len; [EOL]         } [EOL]     } [EOL]     return substrings.toArray(new String[substrings.size()]); [EOL] }
public static String[] splitPreserveAllTokens(final String str) { [EOL]     return splitWorker(str, null, -1, true); [EOL] }
public static String[] splitPreserveAllTokens(final String str) { [EOL]     return splitWorker(str, null, -1, true); [EOL] }
public static String[] splitPreserveAllTokens(final String str) { [EOL]     return splitWorker(str, null, -1, true); [EOL] }
public static String[] splitPreserveAllTokens(final String str) { [EOL]     return splitWorker(str, null, -1, true); [EOL] }
public static String[] splitPreserveAllTokens(final String str) { [EOL]     return splitWorker(str, null, -1, true); [EOL] }
private static String[] splitWorker(final String str, final char separatorChar, final boolean preserveAllTokens) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len == 0) { [EOL]         return ArrayUtils.EMPTY_STRING_ARRAY; [EOL]     } [EOL]     final List<String> list = new ArrayList<String>(); [EOL]     int i = 0, start = 0; [EOL]     boolean match = false; [EOL]     boolean lastMatch = false; [EOL]     while (i < len) { [EOL]         if (str.charAt(i) == separatorChar) { [EOL]             if (match || preserveAllTokens) { [EOL]                 list.add(str.substring(start, i)); [EOL]                 match = false; [EOL]                 lastMatch = true; [EOL]             } [EOL]             start = ++i; [EOL]             continue; [EOL]         } [EOL]         lastMatch = false; [EOL]         match = true; [EOL]         i++; [EOL]     } [EOL]     if (match || preserveAllTokens && lastMatch) { [EOL]         list.add(str.substring(start, i)); [EOL]     } [EOL]     return list.toArray(new String[list.size()]); [EOL] }
private static String[] splitWorker(final String str, final char separatorChar, final boolean preserveAllTokens) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len == 0) { [EOL]         return ArrayUtils.EMPTY_STRING_ARRAY; [EOL]     } [EOL]     final List<String> list = new ArrayList<String>(); [EOL]     int i = 0, start = 0; [EOL]     boolean match = false; [EOL]     boolean lastMatch = false; [EOL]     while (i < len) { [EOL]         if (str.charAt(i) == separatorChar) { [EOL]             if (match || preserveAllTokens) { [EOL]                 list.add(str.substring(start, i)); [EOL]                 match = false; [EOL]                 lastMatch = true; [EOL]             } [EOL]             start = ++i; [EOL]             continue; [EOL]         } [EOL]         lastMatch = false; [EOL]         match = true; [EOL]         i++; [EOL]     } [EOL]     if (match || preserveAllTokens && lastMatch) { [EOL]         list.add(str.substring(start, i)); [EOL]     } [EOL]     return list.toArray(new String[list.size()]); [EOL] }
private static String[] splitWorker(final String str, final char separatorChar, final boolean preserveAllTokens) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len == 0) { [EOL]         return ArrayUtils.EMPTY_STRING_ARRAY; [EOL]     } [EOL]     final List<String> list = new ArrayList<String>(); [EOL]     int i = 0, start = 0; [EOL]     boolean match = false; [EOL]     boolean lastMatch = false; [EOL]     while (i < len) { [EOL]         if (str.charAt(i) == separatorChar) { [EOL]             if (match || preserveAllTokens) { [EOL]                 list.add(str.substring(start, i)); [EOL]                 match = false; [EOL]                 lastMatch = true; [EOL]             } [EOL]             start = ++i; [EOL]             continue; [EOL]         } [EOL]         lastMatch = false; [EOL]         match = true; [EOL]         i++; [EOL]     } [EOL]     if (match || preserveAllTokens && lastMatch) { [EOL]         list.add(str.substring(start, i)); [EOL]     } [EOL]     return list.toArray(new String[list.size()]); [EOL] }
private static String[] splitWorker(final String str, final char separatorChar, final boolean preserveAllTokens) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len == 0) { [EOL]         return ArrayUtils.EMPTY_STRING_ARRAY; [EOL]     } [EOL]     final List<String> list = new ArrayList<String>(); [EOL]     int i = 0, start = 0; [EOL]     boolean match = false; [EOL]     boolean lastMatch = false; [EOL]     while (i < len) { [EOL]         if (str.charAt(i) == separatorChar) { [EOL]             if (match || preserveAllTokens) { [EOL]                 list.add(str.substring(start, i)); [EOL]                 match = false; [EOL]                 lastMatch = true; [EOL]             } [EOL]             start = ++i; [EOL]             continue; [EOL]         } [EOL]         lastMatch = false; [EOL]         match = true; [EOL]         i++; [EOL]     } [EOL]     if (match || preserveAllTokens && lastMatch) { [EOL]         list.add(str.substring(start, i)); [EOL]     } [EOL]     return list.toArray(new String[list.size()]); [EOL] }
private static String[] splitWorker(final String str, final char separatorChar, final boolean preserveAllTokens) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len == 0) { [EOL]         return ArrayUtils.EMPTY_STRING_ARRAY; [EOL]     } [EOL]     final List<String> list = new ArrayList<String>(); [EOL]     int i = 0, start = 0; [EOL]     boolean match = false; [EOL]     boolean lastMatch = false; [EOL]     while (i < len) { [EOL]         if (str.charAt(i) == separatorChar) { [EOL]             if (match || preserveAllTokens) { [EOL]                 list.add(str.substring(start, i)); [EOL]                 match = false; [EOL]                 lastMatch = true; [EOL]             } [EOL]             start = ++i; [EOL]             continue; [EOL]         } [EOL]         lastMatch = false; [EOL]         match = true; [EOL]         i++; [EOL]     } [EOL]     if (match || preserveAllTokens && lastMatch) { [EOL]         list.add(str.substring(start, i)); [EOL]     } [EOL]     return list.toArray(new String[list.size()]); [EOL] }
private static String[] splitWorker(final String str, final char separatorChar, final boolean preserveAllTokens) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len == 0) { [EOL]         return ArrayUtils.EMPTY_STRING_ARRAY; [EOL]     } [EOL]     final List<String> list = new ArrayList<String>(); [EOL]     int i = 0, start = 0; [EOL]     boolean match = false; [EOL]     boolean lastMatch = false; [EOL]     while (i < len) { [EOL]         if (str.charAt(i) == separatorChar) { [EOL]             if (match || preserveAllTokens) { [EOL]                 list.add(str.substring(start, i)); [EOL]                 match = false; [EOL]                 lastMatch = true; [EOL]             } [EOL]             start = ++i; [EOL]             continue; [EOL]         } [EOL]         lastMatch = false; [EOL]         match = true; [EOL]         i++; [EOL]     } [EOL]     if (match || preserveAllTokens && lastMatch) { [EOL]         list.add(str.substring(start, i)); [EOL]     } [EOL]     return list.toArray(new String[list.size()]); [EOL] }
private static String[] splitWorker(final String str, final char separatorChar, final boolean preserveAllTokens) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len == 0) { [EOL]         return ArrayUtils.EMPTY_STRING_ARRAY; [EOL]     } [EOL]     final List<String> list = new ArrayList<String>(); [EOL]     int i = 0, start = 0; [EOL]     boolean match = false; [EOL]     boolean lastMatch = false; [EOL]     while (i < len) { [EOL]         if (str.charAt(i) == separatorChar) { [EOL]             if (match || preserveAllTokens) { [EOL]                 list.add(str.substring(start, i)); [EOL]                 match = false; [EOL]                 lastMatch = true; [EOL]             } [EOL]             start = ++i; [EOL]             continue; [EOL]         } [EOL]         lastMatch = false; [EOL]         match = true; [EOL]         i++; [EOL]     } [EOL]     if (match || preserveAllTokens && lastMatch) { [EOL]         list.add(str.substring(start, i)); [EOL]     } [EOL]     return list.toArray(new String[list.size()]); [EOL] }
private static String[] splitWorker(final String str, final char separatorChar, final boolean preserveAllTokens) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len == 0) { [EOL]         return ArrayUtils.EMPTY_STRING_ARRAY; [EOL]     } [EOL]     final List<String> list = new ArrayList<String>(); [EOL]     int i = 0, start = 0; [EOL]     boolean match = false; [EOL]     boolean lastMatch = false; [EOL]     while (i < len) { [EOL]         if (str.charAt(i) == separatorChar) { [EOL]             if (match || preserveAllTokens) { [EOL]                 list.add(str.substring(start, i)); [EOL]                 match = false; [EOL]                 lastMatch = true; [EOL]             } [EOL]             start = ++i; [EOL]             continue; [EOL]         } [EOL]         lastMatch = false; [EOL]         match = true; [EOL]         i++; [EOL]     } [EOL]     if (match || preserveAllTokens && lastMatch) { [EOL]         list.add(str.substring(start, i)); [EOL]     } [EOL]     return list.toArray(new String[list.size()]); [EOL] }
private static String[] splitWorker(final String str, final char separatorChar, final boolean preserveAllTokens) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len == 0) { [EOL]         return ArrayUtils.EMPTY_STRING_ARRAY; [EOL]     } [EOL]     final List<String> list = new ArrayList<String>(); [EOL]     int i = 0, start = 0; [EOL]     boolean match = false; [EOL]     boolean lastMatch = false; [EOL]     while (i < len) { [EOL]         if (str.charAt(i) == separatorChar) { [EOL]             if (match || preserveAllTokens) { [EOL]                 list.add(str.substring(start, i)); [EOL]                 match = false; [EOL]                 lastMatch = true; [EOL]             } [EOL]             start = ++i; [EOL]             continue; [EOL]         } [EOL]         lastMatch = false; [EOL]         match = true; [EOL]         i++; [EOL]     } [EOL]     if (match || preserveAllTokens && lastMatch) { [EOL]         list.add(str.substring(start, i)); [EOL]     } [EOL]     return list.toArray(new String[list.size()]); [EOL] }
private static String[] splitWorker(final String str, final char separatorChar, final boolean preserveAllTokens) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len == 0) { [EOL]         return ArrayUtils.EMPTY_STRING_ARRAY; [EOL]     } [EOL]     final List<String> list = new ArrayList<String>(); [EOL]     int i = 0, start = 0; [EOL]     boolean match = false; [EOL]     boolean lastMatch = false; [EOL]     while (i < len) { [EOL]         if (str.charAt(i) == separatorChar) { [EOL]             if (match || preserveAllTokens) { [EOL]                 list.add(str.substring(start, i)); [EOL]                 match = false; [EOL]                 lastMatch = true; [EOL]             } [EOL]             start = ++i; [EOL]             continue; [EOL]         } [EOL]         lastMatch = false; [EOL]         match = true; [EOL]         i++; [EOL]     } [EOL]     if (match || preserveAllTokens && lastMatch) { [EOL]         list.add(str.substring(start, i)); [EOL]     } [EOL]     return list.toArray(new String[list.size()]); [EOL] }
public static String join(final Iterator<?> iterator, final char separator) { [EOL]     if (iterator == null) { [EOL]         return null; [EOL]     } [EOL]     if (!iterator.hasNext()) { [EOL]         return EMPTY; [EOL]     } [EOL]     final Object first = iterator.next(); [EOL]     if (!iterator.hasNext()) { [EOL]         return ObjectUtils.toString(first); [EOL]     } [EOL]     final StringBuilder buf = new StringBuilder(256); [EOL]     if (first != null) { [EOL]         buf.append(first); [EOL]     } [EOL]     while (iterator.hasNext()) { [EOL]         buf.append(separator); [EOL]         final Object obj = iterator.next(); [EOL]         if (obj != null) { [EOL]             buf.append(obj); [EOL]         } [EOL]     } [EOL]     return buf.toString(); [EOL] }
public static String join(final Iterator<?> iterator, final char separator) { [EOL]     if (iterator == null) { [EOL]         return null; [EOL]     } [EOL]     if (!iterator.hasNext()) { [EOL]         return EMPTY; [EOL]     } [EOL]     final Object first = iterator.next(); [EOL]     if (!iterator.hasNext()) { [EOL]         return ObjectUtils.toString(first); [EOL]     } [EOL]     final StringBuilder buf = new StringBuilder(256); [EOL]     if (first != null) { [EOL]         buf.append(first); [EOL]     } [EOL]     while (iterator.hasNext()) { [EOL]         buf.append(separator); [EOL]         final Object obj = iterator.next(); [EOL]         if (obj != null) { [EOL]             buf.append(obj); [EOL]         } [EOL]     } [EOL]     return buf.toString(); [EOL] }
public static String join(final Iterator<?> iterator, final char separator) { [EOL]     if (iterator == null) { [EOL]         return null; [EOL]     } [EOL]     if (!iterator.hasNext()) { [EOL]         return EMPTY; [EOL]     } [EOL]     final Object first = iterator.next(); [EOL]     if (!iterator.hasNext()) { [EOL]         return ObjectUtils.toString(first); [EOL]     } [EOL]     final StringBuilder buf = new StringBuilder(256); [EOL]     if (first != null) { [EOL]         buf.append(first); [EOL]     } [EOL]     while (iterator.hasNext()) { [EOL]         buf.append(separator); [EOL]         final Object obj = iterator.next(); [EOL]         if (obj != null) { [EOL]             buf.append(obj); [EOL]         } [EOL]     } [EOL]     return buf.toString(); [EOL] }
public static String join(final Iterator<?> iterator, final char separator) { [EOL]     if (iterator == null) { [EOL]         return null; [EOL]     } [EOL]     if (!iterator.hasNext()) { [EOL]         return EMPTY; [EOL]     } [EOL]     final Object first = iterator.next(); [EOL]     if (!iterator.hasNext()) { [EOL]         return ObjectUtils.toString(first); [EOL]     } [EOL]     final StringBuilder buf = new StringBuilder(256); [EOL]     if (first != null) { [EOL]         buf.append(first); [EOL]     } [EOL]     while (iterator.hasNext()) { [EOL]         buf.append(separator); [EOL]         final Object obj = iterator.next(); [EOL]         if (obj != null) { [EOL]             buf.append(obj); [EOL]         } [EOL]     } [EOL]     return buf.toString(); [EOL] }
public static String join(final Iterator<?> iterator, final char separator) { [EOL]     if (iterator == null) { [EOL]         return null; [EOL]     } [EOL]     if (!iterator.hasNext()) { [EOL]         return EMPTY; [EOL]     } [EOL]     final Object first = iterator.next(); [EOL]     if (!iterator.hasNext()) { [EOL]         return ObjectUtils.toString(first); [EOL]     } [EOL]     final StringBuilder buf = new StringBuilder(256); [EOL]     if (first != null) { [EOL]         buf.append(first); [EOL]     } [EOL]     while (iterator.hasNext()) { [EOL]         buf.append(separator); [EOL]         final Object obj = iterator.next(); [EOL]         if (obj != null) { [EOL]             buf.append(obj); [EOL]         } [EOL]     } [EOL]     return buf.toString(); [EOL] }
public static String join(final Iterator<?> iterator, final char separator) { [EOL]     if (iterator == null) { [EOL]         return null; [EOL]     } [EOL]     if (!iterator.hasNext()) { [EOL]         return EMPTY; [EOL]     } [EOL]     final Object first = iterator.next(); [EOL]     if (!iterator.hasNext()) { [EOL]         return ObjectUtils.toString(first); [EOL]     } [EOL]     final StringBuilder buf = new StringBuilder(256); [EOL]     if (first != null) { [EOL]         buf.append(first); [EOL]     } [EOL]     while (iterator.hasNext()) { [EOL]         buf.append(separator); [EOL]         final Object obj = iterator.next(); [EOL]         if (obj != null) { [EOL]             buf.append(obj); [EOL]         } [EOL]     } [EOL]     return buf.toString(); [EOL] }
public static String deleteWhitespace(final String str) { [EOL]     if (isEmpty(str)) { [EOL]         return str; [EOL]     } [EOL]     final int sz = str.length(); [EOL]     final char[] chs = new char[sz]; [EOL]     int count = 0; [EOL]     for (int i = 0; i < sz; i++) { [EOL]         if (!Character.isWhitespace(str.charAt(i))) { [EOL]             chs[count++] = str.charAt(i); [EOL]         } [EOL]     } [EOL]     if (count == sz) { [EOL]         return str; [EOL]     } [EOL]     return new String(chs, 0, count); [EOL] }
public static String deleteWhitespace(final String str) { [EOL]     if (isEmpty(str)) { [EOL]         return str; [EOL]     } [EOL]     final int sz = str.length(); [EOL]     final char[] chs = new char[sz]; [EOL]     int count = 0; [EOL]     for (int i = 0; i < sz; i++) { [EOL]         if (!Character.isWhitespace(str.charAt(i))) { [EOL]             chs[count++] = str.charAt(i); [EOL]         } [EOL]     } [EOL]     if (count == sz) { [EOL]         return str; [EOL]     } [EOL]     return new String(chs, 0, count); [EOL] }
public static String deleteWhitespace(final String str) { [EOL]     if (isEmpty(str)) { [EOL]         return str; [EOL]     } [EOL]     final int sz = str.length(); [EOL]     final char[] chs = new char[sz]; [EOL]     int count = 0; [EOL]     for (int i = 0; i < sz; i++) { [EOL]         if (!Character.isWhitespace(str.charAt(i))) { [EOL]             chs[count++] = str.charAt(i); [EOL]         } [EOL]     } [EOL]     if (count == sz) { [EOL]         return str; [EOL]     } [EOL]     return new String(chs, 0, count); [EOL] }
public static String deleteWhitespace(final String str) { [EOL]     if (isEmpty(str)) { [EOL]         return str; [EOL]     } [EOL]     final int sz = str.length(); [EOL]     final char[] chs = new char[sz]; [EOL]     int count = 0; [EOL]     for (int i = 0; i < sz; i++) { [EOL]         if (!Character.isWhitespace(str.charAt(i))) { [EOL]             chs[count++] = str.charAt(i); [EOL]         } [EOL]     } [EOL]     if (count == sz) { [EOL]         return str; [EOL]     } [EOL]     return new String(chs, 0, count); [EOL] }
public static String deleteWhitespace(final String str) { [EOL]     if (isEmpty(str)) { [EOL]         return str; [EOL]     } [EOL]     final int sz = str.length(); [EOL]     final char[] chs = new char[sz]; [EOL]     int count = 0; [EOL]     for (int i = 0; i < sz; i++) { [EOL]         if (!Character.isWhitespace(str.charAt(i))) { [EOL]             chs[count++] = str.charAt(i); [EOL]         } [EOL]     } [EOL]     if (count == sz) { [EOL]         return str; [EOL]     } [EOL]     return new String(chs, 0, count); [EOL] }
public static String deleteWhitespace(final String str) { [EOL]     if (isEmpty(str)) { [EOL]         return str; [EOL]     } [EOL]     final int sz = str.length(); [EOL]     final char[] chs = new char[sz]; [EOL]     int count = 0; [EOL]     for (int i = 0; i < sz; i++) { [EOL]         if (!Character.isWhitespace(str.charAt(i))) { [EOL]             chs[count++] = str.charAt(i); [EOL]         } [EOL]     } [EOL]     if (count == sz) { [EOL]         return str; [EOL]     } [EOL]     return new String(chs, 0, count); [EOL] }
public static String deleteWhitespace(final String str) { [EOL]     if (isEmpty(str)) { [EOL]         return str; [EOL]     } [EOL]     final int sz = str.length(); [EOL]     final char[] chs = new char[sz]; [EOL]     int count = 0; [EOL]     for (int i = 0; i < sz; i++) { [EOL]         if (!Character.isWhitespace(str.charAt(i))) { [EOL]             chs[count++] = str.charAt(i); [EOL]         } [EOL]     } [EOL]     if (count == sz) { [EOL]         return str; [EOL]     } [EOL]     return new String(chs, 0, count); [EOL] }
public static String removeStartIgnoreCase(final String str, final String remove) { [EOL]     if (isEmpty(str) || isEmpty(remove)) { [EOL]         return str; [EOL]     } [EOL]     if (startsWithIgnoreCase(str, remove)) { [EOL]         return str.substring(remove.length()); [EOL]     } [EOL]     return str; [EOL] }
public static String removeEndIgnoreCase(final String str, final String remove) { [EOL]     if (isEmpty(str) || isEmpty(remove)) { [EOL]         return str; [EOL]     } [EOL]     if (endsWithIgnoreCase(str, remove)) { [EOL]         return str.substring(0, str.length() - remove.length()); [EOL]     } [EOL]     return str; [EOL] }
public static String removeEndIgnoreCase(final String str, final String remove) { [EOL]     if (isEmpty(str) || isEmpty(remove)) { [EOL]         return str; [EOL]     } [EOL]     if (endsWithIgnoreCase(str, remove)) { [EOL]         return str.substring(0, str.length() - remove.length()); [EOL]     } [EOL]     return str; [EOL] }
public static String removeEndIgnoreCase(final String str, final String remove) { [EOL]     if (isEmpty(str) || isEmpty(remove)) { [EOL]         return str; [EOL]     } [EOL]     if (endsWithIgnoreCase(str, remove)) { [EOL]         return str.substring(0, str.length() - remove.length()); [EOL]     } [EOL]     return str; [EOL] }
public static String removeEndIgnoreCase(final String str, final String remove) { [EOL]     if (isEmpty(str) || isEmpty(remove)) { [EOL]         return str; [EOL]     } [EOL]     if (endsWithIgnoreCase(str, remove)) { [EOL]         return str.substring(0, str.length() - remove.length()); [EOL]     } [EOL]     return str; [EOL] }
public static String removeEndIgnoreCase(final String str, final String remove) { [EOL]     if (isEmpty(str) || isEmpty(remove)) { [EOL]         return str; [EOL]     } [EOL]     if (endsWithIgnoreCase(str, remove)) { [EOL]         return str.substring(0, str.length() - remove.length()); [EOL]     } [EOL]     return str; [EOL] }
public static String removeEndIgnoreCase(final String str, final String remove) { [EOL]     if (isEmpty(str) || isEmpty(remove)) { [EOL]         return str; [EOL]     } [EOL]     if (endsWithIgnoreCase(str, remove)) { [EOL]         return str.substring(0, str.length() - remove.length()); [EOL]     } [EOL]     return str; [EOL] }
public static String removeEndIgnoreCase(final String str, final String remove) { [EOL]     if (isEmpty(str) || isEmpty(remove)) { [EOL]         return str; [EOL]     } [EOL]     if (endsWithIgnoreCase(str, remove)) { [EOL]         return str.substring(0, str.length() - remove.length()); [EOL]     } [EOL]     return str; [EOL] }
public static String replaceOnce(final String text, final String searchString, final String replacement) { [EOL]     return replace(text, searchString, replacement, 1); [EOL] }
public static String replaceOnce(final String text, final String searchString, final String replacement) { [EOL]     return replace(text, searchString, replacement, 1); [EOL] }
public static String replaceOnce(final String text, final String searchString, final String replacement) { [EOL]     return replace(text, searchString, replacement, 1); [EOL] }
public static String replaceOnce(final String text, final String searchString, final String replacement) { [EOL]     return replace(text, searchString, replacement, 1); [EOL] }
public static String replaceOnce(final String text, final String searchString, final String replacement) { [EOL]     return replace(text, searchString, replacement, 1); [EOL] }
public static String replaceOnce(final String text, final String searchString, final String replacement) { [EOL]     return replace(text, searchString, replacement, 1); [EOL] }
public static String removePattern(final String source, final String regex) { [EOL]     return replacePattern(source, regex, StringUtils.EMPTY); [EOL] }
public static String removePattern(final String source, final String regex) { [EOL]     return replacePattern(source, regex, StringUtils.EMPTY); [EOL] }
public static String removePattern(final String source, final String regex) { [EOL]     return replacePattern(source, regex, StringUtils.EMPTY); [EOL] }
public static String removePattern(final String source, final String regex) { [EOL]     return replacePattern(source, regex, StringUtils.EMPTY); [EOL] }
public static String removePattern(final String source, final String regex) { [EOL]     return replacePattern(source, regex, StringUtils.EMPTY); [EOL] }
public static String overlay(final String str, String overlay, int start, int end) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (overlay == null) { [EOL]         overlay = EMPTY; [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (start < 0) { [EOL]         start = 0; [EOL]     } [EOL]     if (start > len) { [EOL]         start = len; [EOL]     } [EOL]     if (end < 0) { [EOL]         end = 0; [EOL]     } [EOL]     if (end > len) { [EOL]         end = len; [EOL]     } [EOL]     if (start > end) { [EOL]         final int temp = start; [EOL]         start = end; [EOL]         end = temp; [EOL]     } [EOL]     return new StringBuilder(len + start - end + overlay.length() + 1).append(str.substring(0, start)).append(overlay).append(str.substring(end)).toString(); [EOL] }
public static String overlay(final String str, String overlay, int start, int end) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (overlay == null) { [EOL]         overlay = EMPTY; [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (start < 0) { [EOL]         start = 0; [EOL]     } [EOL]     if (start > len) { [EOL]         start = len; [EOL]     } [EOL]     if (end < 0) { [EOL]         end = 0; [EOL]     } [EOL]     if (end > len) { [EOL]         end = len; [EOL]     } [EOL]     if (start > end) { [EOL]         final int temp = start; [EOL]         start = end; [EOL]         end = temp; [EOL]     } [EOL]     return new StringBuilder(len + start - end + overlay.length() + 1).append(str.substring(0, start)).append(overlay).append(str.substring(end)).toString(); [EOL] }
public static String rightPad(final String str, final int size, String padStr) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (isEmpty(padStr)) { [EOL]         padStr = SPACE; [EOL]     } [EOL]     final int padLen = padStr.length(); [EOL]     final int strLen = str.length(); [EOL]     final int pads = size - strLen; [EOL]     if (pads <= 0) { [EOL]         return str; [EOL]     } [EOL]     if (padLen == 1 && pads <= PAD_LIMIT) { [EOL]         return rightPad(str, size, padStr.charAt(0)); [EOL]     } [EOL]     if (pads == padLen) { [EOL]         return str.concat(padStr); [EOL]     } else if (pads < padLen) { [EOL]         return str.concat(padStr.substring(0, pads)); [EOL]     } else { [EOL]         final char[] padding = new char[pads]; [EOL]         final char[] padChars = padStr.toCharArray(); [EOL]         for (int i = 0; i < pads; i++) { [EOL]             padding[i] = padChars[i % padLen]; [EOL]         } [EOL]         return str.concat(new String(padding)); [EOL]     } [EOL] }
public static String rightPad(final String str, final int size, String padStr) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (isEmpty(padStr)) { [EOL]         padStr = SPACE; [EOL]     } [EOL]     final int padLen = padStr.length(); [EOL]     final int strLen = str.length(); [EOL]     final int pads = size - strLen; [EOL]     if (pads <= 0) { [EOL]         return str; [EOL]     } [EOL]     if (padLen == 1 && pads <= PAD_LIMIT) { [EOL]         return rightPad(str, size, padStr.charAt(0)); [EOL]     } [EOL]     if (pads == padLen) { [EOL]         return str.concat(padStr); [EOL]     } else if (pads < padLen) { [EOL]         return str.concat(padStr.substring(0, pads)); [EOL]     } else { [EOL]         final char[] padding = new char[pads]; [EOL]         final char[] padChars = padStr.toCharArray(); [EOL]         for (int i = 0; i < pads; i++) { [EOL]             padding[i] = padChars[i % padLen]; [EOL]         } [EOL]         return str.concat(new String(padding)); [EOL]     } [EOL] }
public static String leftPad(final String str, final int size) { [EOL]     return leftPad(str, size, ' '); [EOL] }
public static String leftPad(final String str, final int size) { [EOL]     return leftPad(str, size, ' '); [EOL] }
public static String leftPad(final String str, final int size) { [EOL]     return leftPad(str, size, ' '); [EOL] }
public static String leftPad(final String str, final int size) { [EOL]     return leftPad(str, size, ' '); [EOL] }
public static boolean isAlphanumeric(final CharSequence cs) { [EOL]     if (cs == null || cs.length() == 0) { [EOL]         return false; [EOL]     } [EOL]     final int sz = cs.length(); [EOL]     for (int i = 0; i < sz; i++) { [EOL]         if (Character.isLetterOrDigit(cs.charAt(i)) == false) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public static boolean isAlphanumeric(final CharSequence cs) { [EOL]     if (cs == null || cs.length() == 0) { [EOL]         return false; [EOL]     } [EOL]     final int sz = cs.length(); [EOL]     for (int i = 0; i < sz; i++) { [EOL]         if (Character.isLetterOrDigit(cs.charAt(i)) == false) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public static boolean isAlphanumeric(final CharSequence cs) { [EOL]     if (cs == null || cs.length() == 0) { [EOL]         return false; [EOL]     } [EOL]     final int sz = cs.length(); [EOL]     for (int i = 0; i < sz; i++) { [EOL]         if (Character.isLetterOrDigit(cs.charAt(i)) == false) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public static boolean isAlphanumeric(final CharSequence cs) { [EOL]     if (cs == null || cs.length() == 0) { [EOL]         return false; [EOL]     } [EOL]     final int sz = cs.length(); [EOL]     for (int i = 0; i < sz; i++) { [EOL]         if (Character.isLetterOrDigit(cs.charAt(i)) == false) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public static boolean isAlphanumeric(final CharSequence cs) { [EOL]     if (cs == null || cs.length() == 0) { [EOL]         return false; [EOL]     } [EOL]     final int sz = cs.length(); [EOL]     for (int i = 0; i < sz; i++) { [EOL]         if (Character.isLetterOrDigit(cs.charAt(i)) == false) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public static <T extends CharSequence> T defaultIfEmpty(final T str, final T defaultStr) { [EOL]     return StringUtils.isEmpty(str) ? defaultStr : str; [EOL] }
public static <T extends CharSequence> T defaultIfEmpty(final T str, final T defaultStr) { [EOL]     return StringUtils.isEmpty(str) ? defaultStr : str; [EOL] }
public static <T extends CharSequence> T defaultIfEmpty(final T str, final T defaultStr) { [EOL]     return StringUtils.isEmpty(str) ? defaultStr : str; [EOL] }
public static <T extends CharSequence> T defaultIfEmpty(final T str, final T defaultStr) { [EOL]     return StringUtils.isEmpty(str) ? defaultStr : str; [EOL] }
public static <T extends CharSequence> T defaultIfEmpty(final T str, final T defaultStr) { [EOL]     return StringUtils.isEmpty(str) ? defaultStr : str; [EOL] }
public static String reverseDelimited(final String str, final char separatorChar) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     final String[] strs = split(str, separatorChar); [EOL]     ArrayUtils.reverse(strs); [EOL]     return join(strs, separatorChar); [EOL] }
public static String reverseDelimited(final String str, final char separatorChar) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     final String[] strs = split(str, separatorChar); [EOL]     ArrayUtils.reverse(strs); [EOL]     return join(strs, separatorChar); [EOL] }
public static String reverseDelimited(final String str, final char separatorChar) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     final String[] strs = split(str, separatorChar); [EOL]     ArrayUtils.reverse(strs); [EOL]     return join(strs, separatorChar); [EOL] }
public static String reverseDelimited(final String str, final char separatorChar) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     final String[] strs = split(str, separatorChar); [EOL]     ArrayUtils.reverse(strs); [EOL]     return join(strs, separatorChar); [EOL] }
public static String reverseDelimited(final String str, final char separatorChar) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     final String[] strs = split(str, separatorChar); [EOL]     ArrayUtils.reverse(strs); [EOL]     return join(strs, separatorChar); [EOL] }
public static String reverseDelimited(final String str, final char separatorChar) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     final String[] strs = split(str, separatorChar); [EOL]     ArrayUtils.reverse(strs); [EOL]     return join(strs, separatorChar); [EOL] }
public static boolean endsWithIgnoreCase(final CharSequence str, final CharSequence suffix) { [EOL]     return endsWith(str, suffix, true); [EOL] }
public static boolean endsWithIgnoreCase(final CharSequence str, final CharSequence suffix) { [EOL]     return endsWith(str, suffix, true); [EOL] }
public static String appendIfMissingIgnoreCase(final String str, final CharSequence suffix, final CharSequence... suffixes) { [EOL]     return appendIfMissing(str, suffix, true, suffixes); [EOL] }
public static String appendIfMissingIgnoreCase(final String str, final CharSequence suffix, final CharSequence... suffixes) { [EOL]     return appendIfMissing(str, suffix, true, suffixes); [EOL] }
public static String appendIfMissingIgnoreCase(final String str, final CharSequence suffix, final CharSequence... suffixes) { [EOL]     return appendIfMissing(str, suffix, true, suffixes); [EOL] }
public static String appendIfMissingIgnoreCase(final String str, final CharSequence suffix, final CharSequence... suffixes) { [EOL]     return appendIfMissing(str, suffix, true, suffixes); [EOL] }
public static String appendIfMissingIgnoreCase(final String str, final CharSequence suffix, final CharSequence... suffixes) { [EOL]     return appendIfMissing(str, suffix, true, suffixes); [EOL] }
public static String appendIfMissingIgnoreCase(final String str, final CharSequence suffix, final CharSequence... suffixes) { [EOL]     return appendIfMissing(str, suffix, true, suffixes); [EOL] }
public static String appendIfMissingIgnoreCase(final String str, final CharSequence suffix, final CharSequence... suffixes) { [EOL]     return appendIfMissing(str, suffix, true, suffixes); [EOL] }
public static String appendIfMissingIgnoreCase(final String str, final CharSequence suffix, final CharSequence... suffixes) { [EOL]     return appendIfMissing(str, suffix, true, suffixes); [EOL] }
public void subtract(final double operand) { [EOL]     this.value -= operand; [EOL] }
public void subtract(final double operand) { [EOL]     this.value -= operand; [EOL] }
public void subtract(final double operand) { [EOL]     this.value -= operand; [EOL] }
public void subtract(final Number operand) { [EOL]     this.value -= operand.doubleValue(); [EOL] }
public void subtract(final Number operand) { [EOL]     this.value -= operand.doubleValue(); [EOL] }
public void subtract(final Number operand) { [EOL]     this.value -= operand.doubleValue(); [EOL] }
@Override [EOL] public int intValue() { [EOL]     return (int) value; [EOL] }
@Override [EOL] public int intValue() { [EOL]     return (int) value; [EOL] }
@Override [EOL] public int intValue() { [EOL]     return (int) value; [EOL] }
@Override [EOL] public long longValue() { [EOL]     return (long) value; [EOL] }
@Override [EOL] public long longValue() { [EOL]     return (long) value; [EOL] }
@Override [EOL] public long longValue() { [EOL]     return (long) value; [EOL] }
public LookupTranslator(final CharSequence[]... lookup) { [EOL]     lookupMap = new HashMap<String, CharSequence>(); [EOL]     int _shortest = Integer.MAX_VALUE; [EOL]     int _longest = 0; [EOL]     if (lookup != null) { [EOL]         for (final CharSequence[] seq : lookup) { [EOL]             this.lookupMap.put(seq[0].toString(), seq[1]); [EOL]             final int sz = seq[0].length(); [EOL]             if (sz < _shortest) { [EOL]                 _shortest = sz; [EOL]             } [EOL]             if (sz > _longest) { [EOL]                 _longest = sz; [EOL]             } [EOL]         } [EOL]     } [EOL]     shortest = _shortest; [EOL]     longest = _longest; [EOL] }
public LookupTranslator(final CharSequence[]... lookup) { [EOL]     lookupMap = new HashMap<String, CharSequence>(); [EOL]     int _shortest = Integer.MAX_VALUE; [EOL]     int _longest = 0; [EOL]     if (lookup != null) { [EOL]         for (final CharSequence[] seq : lookup) { [EOL]             this.lookupMap.put(seq[0].toString(), seq[1]); [EOL]             final int sz = seq[0].length(); [EOL]             if (sz < _shortest) { [EOL]                 _shortest = sz; [EOL]             } [EOL]             if (sz > _longest) { [EOL]                 _longest = sz; [EOL]             } [EOL]         } [EOL]     } [EOL]     shortest = _shortest; [EOL]     longest = _longest; [EOL] }
public LookupTranslator(final CharSequence[]... lookup) { [EOL]     lookupMap = new HashMap<String, CharSequence>(); [EOL]     int _shortest = Integer.MAX_VALUE; [EOL]     int _longest = 0; [EOL]     if (lookup != null) { [EOL]         for (final CharSequence[] seq : lookup) { [EOL]             this.lookupMap.put(seq[0].toString(), seq[1]); [EOL]             final int sz = seq[0].length(); [EOL]             if (sz < _shortest) { [EOL]                 _shortest = sz; [EOL]             } [EOL]             if (sz > _longest) { [EOL]                 _longest = sz; [EOL]             } [EOL]         } [EOL]     } [EOL]     shortest = _shortest; [EOL]     longest = _longest; [EOL] }
public LookupTranslator(final CharSequence[]... lookup) { [EOL]     lookupMap = new HashMap<String, CharSequence>(); [EOL]     int _shortest = Integer.MAX_VALUE; [EOL]     int _longest = 0; [EOL]     if (lookup != null) { [EOL]         for (final CharSequence[] seq : lookup) { [EOL]             this.lookupMap.put(seq[0].toString(), seq[1]); [EOL]             final int sz = seq[0].length(); [EOL]             if (sz < _shortest) { [EOL]                 _shortest = sz; [EOL]             } [EOL]             if (sz > _longest) { [EOL]                 _longest = sz; [EOL]             } [EOL]         } [EOL]     } [EOL]     shortest = _shortest; [EOL]     longest = _longest; [EOL] }
@Override [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL]     int max = longest; [EOL]     if (index + longest > input.length()) { [EOL]         max = input.length() - index; [EOL]     } [EOL]     for (int i = max; i >= shortest; i--) { [EOL]         final CharSequence subSeq = input.subSequence(index, index + i); [EOL]         final CharSequence result = lookupMap.get(subSeq.toString()); [EOL]         if (result != null) { [EOL]             out.write(result.toString()); [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return 0; [EOL] }
protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail) { [EOL]     if (isRegistered(value) && !(value instanceof Number || value instanceof Boolean || value instanceof Character)) { [EOL]         appendCyclicObject(buffer, fieldName, value); [EOL]         return; [EOL]     } [EOL]     register(value); [EOL]     try { [EOL]         if (value instanceof Collection<?>) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (Collection<?>) value); [EOL]             } else { [EOL]                 appendSummarySize(buffer, fieldName, ((Collection<?>) value).size()); [EOL]             } [EOL]         } else if (value instanceof Map<?, ?>) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (Map<?, ?>) value); [EOL]             } else { [EOL]                 appendSummarySize(buffer, fieldName, ((Map<?, ?>) value).size()); [EOL]             } [EOL]         } else if (value instanceof long[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (long[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (long[]) value); [EOL]             } [EOL]         } else if (value instanceof int[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (int[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (int[]) value); [EOL]             } [EOL]         } else if (value instanceof short[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (short[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (short[]) value); [EOL]             } [EOL]         } else if (value instanceof byte[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (byte[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (byte[]) value); [EOL]             } [EOL]         } else if (value instanceof char[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (char[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (char[]) value); [EOL]             } [EOL]         } else if (value instanceof double[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (double[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (double[]) value); [EOL]             } [EOL]         } else if (value instanceof float[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (float[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (float[]) value); [EOL]             } [EOL]         } else if (value instanceof boolean[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (boolean[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (boolean[]) value); [EOL]             } [EOL]         } else if (value.getClass().isArray()) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (Object[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (Object[]) value); [EOL]             } [EOL]         } else { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, value); [EOL]             } [EOL]         } [EOL]     } finally { [EOL]         unregister(value); [EOL]     } [EOL] } protected ToStringStyle();  DefaultToStringStyle();  NoFieldNameToStringStyle();  ShortPrefixToStringStyle();  SimpleToStringStyle();  MultiLineToStringStyle();  static Map<Object, Object> getRegistry();  static boolean isRegistered(final Object value);  static void register(final Object value);  static void unregister(final Object value); public void appendSuper(final StringBuffer buffer, final String superToString); public void appendToString(final StringBuffer buffer, final String toString); public void appendStart(final StringBuffer buffer, final Object object); public void appendEnd(final StringBuffer buffer, final Object object); protected void removeLastFieldSeparator(final StringBuffer buffer); public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); public void append(final StringBuffer buffer, final String fieldName, final long value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); public void append(final StringBuffer buffer, final String fieldName, final int value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); public void append(final StringBuffer buffer, final String fieldName, final short value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); public void append(final StringBuffer buffer, final String fieldName, final byte value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); public void append(final StringBuffer buffer, final String fieldName, final char value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); public void append(final StringBuffer buffer, final String fieldName, final double value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); public void append(final StringBuffer buffer, final String fieldName, final float value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); public void append(final StringBuffer buffer, final String fieldName, final boolean value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendClassName(final StringBuffer buffer, final Object object); protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); protected void appendContentStart(final StringBuffer buffer); protected void appendContentEnd(final StringBuffer buffer); protected void appendNullText(final StringBuffer buffer, final String fieldName); protected void appendFieldSeparator(final StringBuffer buffer); protected void appendFieldStart(final StringBuffer buffer, final String fieldName); protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); protected boolean isFullDetail(final Boolean fullDetailRequest); protected String getShortClassName(final Class<?> cls); protected boolean isUseClassName(); protected void setUseClassName(final boolean useClassName); protected boolean isUseShortClassName(); protected void setUseShortClassName(final boolean useShortClassName); protected boolean isUseIdentityHashCode(); protected void setUseIdentityHashCode(final boolean useIdentityHashCode); protected boolean isUseFieldNames(); protected void setUseFieldNames(final boolean useFieldNames); protected boolean isDefaultFullDetail(); protected void setDefaultFullDetail(final boolean defaultFullDetail); protected boolean isArrayContentDetail(); protected void setArrayContentDetail(final boolean arrayContentDetail); protected String getArrayStart(); protected void setArrayStart(String arrayStart); protected String getArrayEnd(); protected void setArrayEnd(String arrayEnd); protected String getArraySeparator(); protected void setArraySeparator(String arraySeparator); protected String getContentStart(); protected void setContentStart(String contentStart); protected String getContentEnd(); protected void setContentEnd(String contentEnd); protected String getFieldNameValueSeparator(); protected void setFieldNameValueSeparator(String fieldNameValueSeparator); protected String getFieldSeparator(); protected void setFieldSeparator(String fieldSeparator); protected boolean isFieldSeparatorAtStart(); protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); protected boolean isFieldSeparatorAtEnd(); protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); protected String getNullText(); protected void setNullText(String nullText); protected String getSizeStartText(); protected void setSizeStartText(String sizeStartText); protected String getSizeEndText(); protected void setSizeEndText(String sizeEndText); protected String getSummaryObjectStartText(); protected void setSummaryObjectStartText(String summaryObjectStartText); protected String getSummaryObjectEndText(); protected void setSummaryObjectEndText(String summaryObjectEndText); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); long serialVersionUID=Optional[-2587890625525655916L]; ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; boolean useFieldNames=Optional[true]; boolean useClassName=Optional[true]; boolean useShortClassName=Optional[false]; boolean useIdentityHashCode=Optional[true]; String contentStart=Optional["["]; String contentEnd=Optional["]"]; String fieldNameValueSeparator=Optional["="]; boolean fieldSeparatorAtStart=Optional[false]; boolean fieldSeparatorAtEnd=Optional[false]; String fieldSeparator=Optional[","]; String arrayStart=Optional["{"]; String arraySeparator=Optional[","]; boolean arrayContentDetail=Optional[true]; String arrayEnd=Optional["}
public void append(final StringBuffer buffer, final String fieldName, final long value) { [EOL]     appendFieldStart(buffer, fieldName); [EOL]     appendDetail(buffer, fieldName, value); [EOL]     appendFieldEnd(buffer, fieldName); [EOL] } protected ToStringStyle();  DefaultToStringStyle();  NoFieldNameToStringStyle();  ShortPrefixToStringStyle();  SimpleToStringStyle();  MultiLineToStringStyle();  static Map<Object, Object> getRegistry();  static boolean isRegistered(final Object value);  static void register(final Object value);  static void unregister(final Object value); public void appendSuper(final StringBuffer buffer, final String superToString); public void appendToString(final StringBuffer buffer, final String toString); public void appendStart(final StringBuffer buffer, final Object object); public void appendEnd(final StringBuffer buffer, final Object object); protected void removeLastFieldSeparator(final StringBuffer buffer); public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); public void append(final StringBuffer buffer, final String fieldName, final long value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); public void append(final StringBuffer buffer, final String fieldName, final int value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); public void append(final StringBuffer buffer, final String fieldName, final short value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); public void append(final StringBuffer buffer, final String fieldName, final byte value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); public void append(final StringBuffer buffer, final String fieldName, final char value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); public void append(final StringBuffer buffer, final String fieldName, final double value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); public void append(final StringBuffer buffer, final String fieldName, final float value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); public void append(final StringBuffer buffer, final String fieldName, final boolean value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendClassName(final StringBuffer buffer, final Object object); protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); protected void appendContentStart(final StringBuffer buffer); protected void appendContentEnd(final StringBuffer buffer); protected void appendNullText(final StringBuffer buffer, final String fieldName); protected void appendFieldSeparator(final StringBuffer buffer); protected void appendFieldStart(final StringBuffer buffer, final String fieldName); protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); protected boolean isFullDetail(final Boolean fullDetailRequest); protected String getShortClassName(final Class<?> cls); protected boolean isUseClassName(); protected void setUseClassName(final boolean useClassName); protected boolean isUseShortClassName(); protected void setUseShortClassName(final boolean useShortClassName); protected boolean isUseIdentityHashCode(); protected void setUseIdentityHashCode(final boolean useIdentityHashCode); protected boolean isUseFieldNames(); protected void setUseFieldNames(final boolean useFieldNames); protected boolean isDefaultFullDetail(); protected void setDefaultFullDetail(final boolean defaultFullDetail); protected boolean isArrayContentDetail(); protected void setArrayContentDetail(final boolean arrayContentDetail); protected String getArrayStart(); protected void setArrayStart(String arrayStart); protected String getArrayEnd(); protected void setArrayEnd(String arrayEnd); protected String getArraySeparator(); protected void setArraySeparator(String arraySeparator); protected String getContentStart(); protected void setContentStart(String contentStart); protected String getContentEnd(); protected void setContentEnd(String contentEnd); protected String getFieldNameValueSeparator(); protected void setFieldNameValueSeparator(String fieldNameValueSeparator); protected String getFieldSeparator(); protected void setFieldSeparator(String fieldSeparator); protected boolean isFieldSeparatorAtStart(); protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); protected boolean isFieldSeparatorAtEnd(); protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); protected String getNullText(); protected void setNullText(String nullText); protected String getSizeStartText(); protected void setSizeStartText(String sizeStartText); protected String getSizeEndText(); protected void setSizeEndText(String sizeEndText); protected String getSummaryObjectStartText(); protected void setSummaryObjectStartText(String summaryObjectStartText); protected String getSummaryObjectEndText(); protected void setSummaryObjectEndText(String summaryObjectEndText); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); long serialVersionUID=Optional[-2587890625525655916L]; ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; boolean useFieldNames=Optional[true]; boolean useClassName=Optional[true]; boolean useShortClassName=Optional[false]; boolean useIdentityHashCode=Optional[true]; String contentStart=Optional["["]; String contentEnd=Optional["]"]; String fieldNameValueSeparator=Optional["="]; boolean fieldSeparatorAtStart=Optional[false]; boolean fieldSeparatorAtEnd=Optional[false]; String fieldSeparator=Optional[","]; String arrayStart=Optional["{"]; String arraySeparator=Optional[","]; boolean arrayContentDetail=Optional[true]; String arrayEnd=Optional["}
public void append(final StringBuffer buffer, final String fieldName, final long value) { [EOL]     appendFieldStart(buffer, fieldName); [EOL]     appendDetail(buffer, fieldName, value); [EOL]     appendFieldEnd(buffer, fieldName); [EOL] } protected ToStringStyle();  DefaultToStringStyle();  NoFieldNameToStringStyle();  ShortPrefixToStringStyle();  SimpleToStringStyle();  MultiLineToStringStyle();  static Map<Object, Object> getRegistry();  static boolean isRegistered(final Object value);  static void register(final Object value);  static void unregister(final Object value); public void appendSuper(final StringBuffer buffer, final String superToString); public void appendToString(final StringBuffer buffer, final String toString); public void appendStart(final StringBuffer buffer, final Object object); public void appendEnd(final StringBuffer buffer, final Object object); protected void removeLastFieldSeparator(final StringBuffer buffer); public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); public void append(final StringBuffer buffer, final String fieldName, final long value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); public void append(final StringBuffer buffer, final String fieldName, final int value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); public void append(final StringBuffer buffer, final String fieldName, final short value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); public void append(final StringBuffer buffer, final String fieldName, final byte value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); public void append(final StringBuffer buffer, final String fieldName, final char value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); public void append(final StringBuffer buffer, final String fieldName, final double value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); public void append(final StringBuffer buffer, final String fieldName, final float value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); public void append(final StringBuffer buffer, final String fieldName, final boolean value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendClassName(final StringBuffer buffer, final Object object); protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); protected void appendContentStart(final StringBuffer buffer); protected void appendContentEnd(final StringBuffer buffer); protected void appendNullText(final StringBuffer buffer, final String fieldName); protected void appendFieldSeparator(final StringBuffer buffer); protected void appendFieldStart(final StringBuffer buffer, final String fieldName); protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); protected boolean isFullDetail(final Boolean fullDetailRequest); protected String getShortClassName(final Class<?> cls); protected boolean isUseClassName(); protected void setUseClassName(final boolean useClassName); protected boolean isUseShortClassName(); protected void setUseShortClassName(final boolean useShortClassName); protected boolean isUseIdentityHashCode(); protected void setUseIdentityHashCode(final boolean useIdentityHashCode); protected boolean isUseFieldNames(); protected void setUseFieldNames(final boolean useFieldNames); protected boolean isDefaultFullDetail(); protected void setDefaultFullDetail(final boolean defaultFullDetail); protected boolean isArrayContentDetail(); protected void setArrayContentDetail(final boolean arrayContentDetail); protected String getArrayStart(); protected void setArrayStart(String arrayStart); protected String getArrayEnd(); protected void setArrayEnd(String arrayEnd); protected String getArraySeparator(); protected void setArraySeparator(String arraySeparator); protected String getContentStart(); protected void setContentStart(String contentStart); protected String getContentEnd(); protected void setContentEnd(String contentEnd); protected String getFieldNameValueSeparator(); protected void setFieldNameValueSeparator(String fieldNameValueSeparator); protected String getFieldSeparator(); protected void setFieldSeparator(String fieldSeparator); protected boolean isFieldSeparatorAtStart(); protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); protected boolean isFieldSeparatorAtEnd(); protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); protected String getNullText(); protected void setNullText(String nullText); protected String getSizeStartText(); protected void setSizeStartText(String sizeStartText); protected String getSizeEndText(); protected void setSizeEndText(String sizeEndText); protected String getSummaryObjectStartText(); protected void setSummaryObjectStartText(String summaryObjectStartText); protected String getSummaryObjectEndText(); protected void setSummaryObjectEndText(String summaryObjectEndText); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); long serialVersionUID=Optional[-2587890625525655916L]; ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; boolean useFieldNames=Optional[true]; boolean useClassName=Optional[true]; boolean useShortClassName=Optional[false]; boolean useIdentityHashCode=Optional[true]; String contentStart=Optional["["]; String contentEnd=Optional["]"]; String fieldNameValueSeparator=Optional["="]; boolean fieldSeparatorAtStart=Optional[false]; boolean fieldSeparatorAtEnd=Optional[false]; String fieldSeparator=Optional[","]; String arrayStart=Optional["{"]; String arraySeparator=Optional[","]; boolean arrayContentDetail=Optional[true]; String arrayEnd=Optional["}
public void append(final StringBuffer buffer, final String fieldName, final long value) { [EOL]     appendFieldStart(buffer, fieldName); [EOL]     appendDetail(buffer, fieldName, value); [EOL]     appendFieldEnd(buffer, fieldName); [EOL] } protected ToStringStyle();  DefaultToStringStyle();  NoFieldNameToStringStyle();  ShortPrefixToStringStyle();  SimpleToStringStyle();  MultiLineToStringStyle();  static Map<Object, Object> getRegistry();  static boolean isRegistered(final Object value);  static void register(final Object value);  static void unregister(final Object value); public void appendSuper(final StringBuffer buffer, final String superToString); public void appendToString(final StringBuffer buffer, final String toString); public void appendStart(final StringBuffer buffer, final Object object); public void appendEnd(final StringBuffer buffer, final Object object); protected void removeLastFieldSeparator(final StringBuffer buffer); public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); public void append(final StringBuffer buffer, final String fieldName, final long value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); public void append(final StringBuffer buffer, final String fieldName, final int value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); public void append(final StringBuffer buffer, final String fieldName, final short value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); public void append(final StringBuffer buffer, final String fieldName, final byte value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); public void append(final StringBuffer buffer, final String fieldName, final char value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); public void append(final StringBuffer buffer, final String fieldName, final double value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); public void append(final StringBuffer buffer, final String fieldName, final float value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); public void append(final StringBuffer buffer, final String fieldName, final boolean value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendClassName(final StringBuffer buffer, final Object object); protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); protected void appendContentStart(final StringBuffer buffer); protected void appendContentEnd(final StringBuffer buffer); protected void appendNullText(final StringBuffer buffer, final String fieldName); protected void appendFieldSeparator(final StringBuffer buffer); protected void appendFieldStart(final StringBuffer buffer, final String fieldName); protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); protected boolean isFullDetail(final Boolean fullDetailRequest); protected String getShortClassName(final Class<?> cls); protected boolean isUseClassName(); protected void setUseClassName(final boolean useClassName); protected boolean isUseShortClassName(); protected void setUseShortClassName(final boolean useShortClassName); protected boolean isUseIdentityHashCode(); protected void setUseIdentityHashCode(final boolean useIdentityHashCode); protected boolean isUseFieldNames(); protected void setUseFieldNames(final boolean useFieldNames); protected boolean isDefaultFullDetail(); protected void setDefaultFullDetail(final boolean defaultFullDetail); protected boolean isArrayContentDetail(); protected void setArrayContentDetail(final boolean arrayContentDetail); protected String getArrayStart(); protected void setArrayStart(String arrayStart); protected String getArrayEnd(); protected void setArrayEnd(String arrayEnd); protected String getArraySeparator(); protected void setArraySeparator(String arraySeparator); protected String getContentStart(); protected void setContentStart(String contentStart); protected String getContentEnd(); protected void setContentEnd(String contentEnd); protected String getFieldNameValueSeparator(); protected void setFieldNameValueSeparator(String fieldNameValueSeparator); protected String getFieldSeparator(); protected void setFieldSeparator(String fieldSeparator); protected boolean isFieldSeparatorAtStart(); protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); protected boolean isFieldSeparatorAtEnd(); protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); protected String getNullText(); protected void setNullText(String nullText); protected String getSizeStartText(); protected void setSizeStartText(String sizeStartText); protected String getSizeEndText(); protected void setSizeEndText(String sizeEndText); protected String getSummaryObjectStartText(); protected void setSummaryObjectStartText(String summaryObjectStartText); protected String getSummaryObjectEndText(); protected void setSummaryObjectEndText(String summaryObjectEndText); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); long serialVersionUID=Optional[-2587890625525655916L]; ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; boolean useFieldNames=Optional[true]; boolean useClassName=Optional[true]; boolean useShortClassName=Optional[false]; boolean useIdentityHashCode=Optional[true]; String contentStart=Optional["["]; String contentEnd=Optional["]"]; String fieldNameValueSeparator=Optional["="]; boolean fieldSeparatorAtStart=Optional[false]; boolean fieldSeparatorAtEnd=Optional[false]; String fieldSeparator=Optional[","]; String arrayStart=Optional["{"]; String arraySeparator=Optional[","]; boolean arrayContentDetail=Optional[true]; String arrayEnd=Optional["}
public void append(final StringBuffer buffer, final String fieldName, final long value) { [EOL]     appendFieldStart(buffer, fieldName); [EOL]     appendDetail(buffer, fieldName, value); [EOL]     appendFieldEnd(buffer, fieldName); [EOL] } protected ToStringStyle();  DefaultToStringStyle();  NoFieldNameToStringStyle();  ShortPrefixToStringStyle();  SimpleToStringStyle();  MultiLineToStringStyle();  static Map<Object, Object> getRegistry();  static boolean isRegistered(final Object value);  static void register(final Object value);  static void unregister(final Object value); public void appendSuper(final StringBuffer buffer, final String superToString); public void appendToString(final StringBuffer buffer, final String toString); public void appendStart(final StringBuffer buffer, final Object object); public void appendEnd(final StringBuffer buffer, final Object object); protected void removeLastFieldSeparator(final StringBuffer buffer); public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); public void append(final StringBuffer buffer, final String fieldName, final long value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); public void append(final StringBuffer buffer, final String fieldName, final int value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); public void append(final StringBuffer buffer, final String fieldName, final short value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); public void append(final StringBuffer buffer, final String fieldName, final byte value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); public void append(final StringBuffer buffer, final String fieldName, final char value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); public void append(final StringBuffer buffer, final String fieldName, final double value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); public void append(final StringBuffer buffer, final String fieldName, final float value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); public void append(final StringBuffer buffer, final String fieldName, final boolean value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendClassName(final StringBuffer buffer, final Object object); protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); protected void appendContentStart(final StringBuffer buffer); protected void appendContentEnd(final StringBuffer buffer); protected void appendNullText(final StringBuffer buffer, final String fieldName); protected void appendFieldSeparator(final StringBuffer buffer); protected void appendFieldStart(final StringBuffer buffer, final String fieldName); protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); protected boolean isFullDetail(final Boolean fullDetailRequest); protected String getShortClassName(final Class<?> cls); protected boolean isUseClassName(); protected void setUseClassName(final boolean useClassName); protected boolean isUseShortClassName(); protected void setUseShortClassName(final boolean useShortClassName); protected boolean isUseIdentityHashCode(); protected void setUseIdentityHashCode(final boolean useIdentityHashCode); protected boolean isUseFieldNames(); protected void setUseFieldNames(final boolean useFieldNames); protected boolean isDefaultFullDetail(); protected void setDefaultFullDetail(final boolean defaultFullDetail); protected boolean isArrayContentDetail(); protected void setArrayContentDetail(final boolean arrayContentDetail); protected String getArrayStart(); protected void setArrayStart(String arrayStart); protected String getArrayEnd(); protected void setArrayEnd(String arrayEnd); protected String getArraySeparator(); protected void setArraySeparator(String arraySeparator); protected String getContentStart(); protected void setContentStart(String contentStart); protected String getContentEnd(); protected void setContentEnd(String contentEnd); protected String getFieldNameValueSeparator(); protected void setFieldNameValueSeparator(String fieldNameValueSeparator); protected String getFieldSeparator(); protected void setFieldSeparator(String fieldSeparator); protected boolean isFieldSeparatorAtStart(); protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); protected boolean isFieldSeparatorAtEnd(); protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); protected String getNullText(); protected void setNullText(String nullText); protected String getSizeStartText(); protected void setSizeStartText(String sizeStartText); protected String getSizeEndText(); protected void setSizeEndText(String sizeEndText); protected String getSummaryObjectStartText(); protected void setSummaryObjectStartText(String summaryObjectStartText); protected String getSummaryObjectEndText(); protected void setSummaryObjectEndText(String summaryObjectEndText); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); long serialVersionUID=Optional[-2587890625525655916L]; ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; boolean useFieldNames=Optional[true]; boolean useClassName=Optional[true]; boolean useShortClassName=Optional[false]; boolean useIdentityHashCode=Optional[true]; String contentStart=Optional["["]; String contentEnd=Optional["]"]; String fieldNameValueSeparator=Optional["="]; boolean fieldSeparatorAtStart=Optional[false]; boolean fieldSeparatorAtEnd=Optional[false]; String fieldSeparator=Optional[","]; String arrayStart=Optional["{"]; String arraySeparator=Optional[","]; boolean arrayContentDetail=Optional[true]; String arrayEnd=Optional["}
public void append(final StringBuffer buffer, final String fieldName, final long value) { [EOL]     appendFieldStart(buffer, fieldName); [EOL]     appendDetail(buffer, fieldName, value); [EOL]     appendFieldEnd(buffer, fieldName); [EOL] } protected ToStringStyle();  DefaultToStringStyle();  NoFieldNameToStringStyle();  ShortPrefixToStringStyle();  SimpleToStringStyle();  MultiLineToStringStyle();  static Map<Object, Object> getRegistry();  static boolean isRegistered(final Object value);  static void register(final Object value);  static void unregister(final Object value); public void appendSuper(final StringBuffer buffer, final String superToString); public void appendToString(final StringBuffer buffer, final String toString); public void appendStart(final StringBuffer buffer, final Object object); public void appendEnd(final StringBuffer buffer, final Object object); protected void removeLastFieldSeparator(final StringBuffer buffer); public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); public void append(final StringBuffer buffer, final String fieldName, final long value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); public void append(final StringBuffer buffer, final String fieldName, final int value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); public void append(final StringBuffer buffer, final String fieldName, final short value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); public void append(final StringBuffer buffer, final String fieldName, final byte value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); public void append(final StringBuffer buffer, final String fieldName, final char value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); public void append(final StringBuffer buffer, final String fieldName, final double value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); public void append(final StringBuffer buffer, final String fieldName, final float value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); public void append(final StringBuffer buffer, final String fieldName, final boolean value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendClassName(final StringBuffer buffer, final Object object); protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); protected void appendContentStart(final StringBuffer buffer); protected void appendContentEnd(final StringBuffer buffer); protected void appendNullText(final StringBuffer buffer, final String fieldName); protected void appendFieldSeparator(final StringBuffer buffer); protected void appendFieldStart(final StringBuffer buffer, final String fieldName); protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); protected boolean isFullDetail(final Boolean fullDetailRequest); protected String getShortClassName(final Class<?> cls); protected boolean isUseClassName(); protected void setUseClassName(final boolean useClassName); protected boolean isUseShortClassName(); protected void setUseShortClassName(final boolean useShortClassName); protected boolean isUseIdentityHashCode(); protected void setUseIdentityHashCode(final boolean useIdentityHashCode); protected boolean isUseFieldNames(); protected void setUseFieldNames(final boolean useFieldNames); protected boolean isDefaultFullDetail(); protected void setDefaultFullDetail(final boolean defaultFullDetail); protected boolean isArrayContentDetail(); protected void setArrayContentDetail(final boolean arrayContentDetail); protected String getArrayStart(); protected void setArrayStart(String arrayStart); protected String getArrayEnd(); protected void setArrayEnd(String arrayEnd); protected String getArraySeparator(); protected void setArraySeparator(String arraySeparator); protected String getContentStart(); protected void setContentStart(String contentStart); protected String getContentEnd(); protected void setContentEnd(String contentEnd); protected String getFieldNameValueSeparator(); protected void setFieldNameValueSeparator(String fieldNameValueSeparator); protected String getFieldSeparator(); protected void setFieldSeparator(String fieldSeparator); protected boolean isFieldSeparatorAtStart(); protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); protected boolean isFieldSeparatorAtEnd(); protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); protected String getNullText(); protected void setNullText(String nullText); protected String getSizeStartText(); protected void setSizeStartText(String sizeStartText); protected String getSizeEndText(); protected void setSizeEndText(String sizeEndText); protected String getSummaryObjectStartText(); protected void setSummaryObjectStartText(String summaryObjectStartText); protected String getSummaryObjectEndText(); protected void setSummaryObjectEndText(String summaryObjectEndText); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); long serialVersionUID=Optional[-2587890625525655916L]; ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; boolean useFieldNames=Optional[true]; boolean useClassName=Optional[true]; boolean useShortClassName=Optional[false]; boolean useIdentityHashCode=Optional[true]; String contentStart=Optional["["]; String contentEnd=Optional["]"]; String fieldNameValueSeparator=Optional["="]; boolean fieldSeparatorAtStart=Optional[false]; boolean fieldSeparatorAtEnd=Optional[false]; String fieldSeparator=Optional[","]; String arrayStart=Optional["{"]; String arraySeparator=Optional[","]; boolean arrayContentDetail=Optional[true]; String arrayEnd=Optional["}
public void append(final StringBuffer buffer, final String fieldName, final byte value) { [EOL]     appendFieldStart(buffer, fieldName); [EOL]     appendDetail(buffer, fieldName, value); [EOL]     appendFieldEnd(buffer, fieldName); [EOL] } protected ToStringStyle();  DefaultToStringStyle();  NoFieldNameToStringStyle();  ShortPrefixToStringStyle();  SimpleToStringStyle();  MultiLineToStringStyle();  static Map<Object, Object> getRegistry();  static boolean isRegistered(final Object value);  static void register(final Object value);  static void unregister(final Object value); public void appendSuper(final StringBuffer buffer, final String superToString); public void appendToString(final StringBuffer buffer, final String toString); public void appendStart(final StringBuffer buffer, final Object object); public void appendEnd(final StringBuffer buffer, final Object object); protected void removeLastFieldSeparator(final StringBuffer buffer); public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); public void append(final StringBuffer buffer, final String fieldName, final long value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); public void append(final StringBuffer buffer, final String fieldName, final int value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); public void append(final StringBuffer buffer, final String fieldName, final short value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); public void append(final StringBuffer buffer, final String fieldName, final byte value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); public void append(final StringBuffer buffer, final String fieldName, final char value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); public void append(final StringBuffer buffer, final String fieldName, final double value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); public void append(final StringBuffer buffer, final String fieldName, final float value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); public void append(final StringBuffer buffer, final String fieldName, final boolean value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendClassName(final StringBuffer buffer, final Object object); protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); protected void appendContentStart(final StringBuffer buffer); protected void appendContentEnd(final StringBuffer buffer); protected void appendNullText(final StringBuffer buffer, final String fieldName); protected void appendFieldSeparator(final StringBuffer buffer); protected void appendFieldStart(final StringBuffer buffer, final String fieldName); protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); protected boolean isFullDetail(final Boolean fullDetailRequest); protected String getShortClassName(final Class<?> cls); protected boolean isUseClassName(); protected void setUseClassName(final boolean useClassName); protected boolean isUseShortClassName(); protected void setUseShortClassName(final boolean useShortClassName); protected boolean isUseIdentityHashCode(); protected void setUseIdentityHashCode(final boolean useIdentityHashCode); protected boolean isUseFieldNames(); protected void setUseFieldNames(final boolean useFieldNames); protected boolean isDefaultFullDetail(); protected void setDefaultFullDetail(final boolean defaultFullDetail); protected boolean isArrayContentDetail(); protected void setArrayContentDetail(final boolean arrayContentDetail); protected String getArrayStart(); protected void setArrayStart(String arrayStart); protected String getArrayEnd(); protected void setArrayEnd(String arrayEnd); protected String getArraySeparator(); protected void setArraySeparator(String arraySeparator); protected String getContentStart(); protected void setContentStart(String contentStart); protected String getContentEnd(); protected void setContentEnd(String contentEnd); protected String getFieldNameValueSeparator(); protected void setFieldNameValueSeparator(String fieldNameValueSeparator); protected String getFieldSeparator(); protected void setFieldSeparator(String fieldSeparator); protected boolean isFieldSeparatorAtStart(); protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); protected boolean isFieldSeparatorAtEnd(); protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); protected String getNullText(); protected void setNullText(String nullText); protected String getSizeStartText(); protected void setSizeStartText(String sizeStartText); protected String getSizeEndText(); protected void setSizeEndText(String sizeEndText); protected String getSummaryObjectStartText(); protected void setSummaryObjectStartText(String summaryObjectStartText); protected String getSummaryObjectEndText(); protected void setSummaryObjectEndText(String summaryObjectEndText); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); long serialVersionUID=Optional[-2587890625525655916L]; ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; boolean useFieldNames=Optional[true]; boolean useClassName=Optional[true]; boolean useShortClassName=Optional[false]; boolean useIdentityHashCode=Optional[true]; String contentStart=Optional["["]; String contentEnd=Optional["]"]; String fieldNameValueSeparator=Optional["="]; boolean fieldSeparatorAtStart=Optional[false]; boolean fieldSeparatorAtEnd=Optional[false]; String fieldSeparator=Optional[","]; String arrayStart=Optional["{"]; String arraySeparator=Optional[","]; boolean arrayContentDetail=Optional[true]; String arrayEnd=Optional["}
public void append(final StringBuffer buffer, final String fieldName, final byte value) { [EOL]     appendFieldStart(buffer, fieldName); [EOL]     appendDetail(buffer, fieldName, value); [EOL]     appendFieldEnd(buffer, fieldName); [EOL] } protected ToStringStyle();  DefaultToStringStyle();  NoFieldNameToStringStyle();  ShortPrefixToStringStyle();  SimpleToStringStyle();  MultiLineToStringStyle();  static Map<Object, Object> getRegistry();  static boolean isRegistered(final Object value);  static void register(final Object value);  static void unregister(final Object value); public void appendSuper(final StringBuffer buffer, final String superToString); public void appendToString(final StringBuffer buffer, final String toString); public void appendStart(final StringBuffer buffer, final Object object); public void appendEnd(final StringBuffer buffer, final Object object); protected void removeLastFieldSeparator(final StringBuffer buffer); public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); public void append(final StringBuffer buffer, final String fieldName, final long value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); public void append(final StringBuffer buffer, final String fieldName, final int value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); public void append(final StringBuffer buffer, final String fieldName, final short value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); public void append(final StringBuffer buffer, final String fieldName, final byte value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); public void append(final StringBuffer buffer, final String fieldName, final char value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); public void append(final StringBuffer buffer, final String fieldName, final double value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); public void append(final StringBuffer buffer, final String fieldName, final float value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); public void append(final StringBuffer buffer, final String fieldName, final boolean value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendClassName(final StringBuffer buffer, final Object object); protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); protected void appendContentStart(final StringBuffer buffer); protected void appendContentEnd(final StringBuffer buffer); protected void appendNullText(final StringBuffer buffer, final String fieldName); protected void appendFieldSeparator(final StringBuffer buffer); protected void appendFieldStart(final StringBuffer buffer, final String fieldName); protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); protected boolean isFullDetail(final Boolean fullDetailRequest); protected String getShortClassName(final Class<?> cls); protected boolean isUseClassName(); protected void setUseClassName(final boolean useClassName); protected boolean isUseShortClassName(); protected void setUseShortClassName(final boolean useShortClassName); protected boolean isUseIdentityHashCode(); protected void setUseIdentityHashCode(final boolean useIdentityHashCode); protected boolean isUseFieldNames(); protected void setUseFieldNames(final boolean useFieldNames); protected boolean isDefaultFullDetail(); protected void setDefaultFullDetail(final boolean defaultFullDetail); protected boolean isArrayContentDetail(); protected void setArrayContentDetail(final boolean arrayContentDetail); protected String getArrayStart(); protected void setArrayStart(String arrayStart); protected String getArrayEnd(); protected void setArrayEnd(String arrayEnd); protected String getArraySeparator(); protected void setArraySeparator(String arraySeparator); protected String getContentStart(); protected void setContentStart(String contentStart); protected String getContentEnd(); protected void setContentEnd(String contentEnd); protected String getFieldNameValueSeparator(); protected void setFieldNameValueSeparator(String fieldNameValueSeparator); protected String getFieldSeparator(); protected void setFieldSeparator(String fieldSeparator); protected boolean isFieldSeparatorAtStart(); protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); protected boolean isFieldSeparatorAtEnd(); protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); protected String getNullText(); protected void setNullText(String nullText); protected String getSizeStartText(); protected void setSizeStartText(String sizeStartText); protected String getSizeEndText(); protected void setSizeEndText(String sizeEndText); protected String getSummaryObjectStartText(); protected void setSummaryObjectStartText(String summaryObjectStartText); protected String getSummaryObjectEndText(); protected void setSummaryObjectEndText(String summaryObjectEndText); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); long serialVersionUID=Optional[-2587890625525655916L]; ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; boolean useFieldNames=Optional[true]; boolean useClassName=Optional[true]; boolean useShortClassName=Optional[false]; boolean useIdentityHashCode=Optional[true]; String contentStart=Optional["["]; String contentEnd=Optional["]"]; String fieldNameValueSeparator=Optional["="]; boolean fieldSeparatorAtStart=Optional[false]; boolean fieldSeparatorAtEnd=Optional[false]; String fieldSeparator=Optional[","]; String arrayStart=Optional["{"]; String arraySeparator=Optional[","]; boolean arrayContentDetail=Optional[true]; String arrayEnd=Optional["}
public void append(final StringBuffer buffer, final String fieldName, final byte value) { [EOL]     appendFieldStart(buffer, fieldName); [EOL]     appendDetail(buffer, fieldName, value); [EOL]     appendFieldEnd(buffer, fieldName); [EOL] } protected ToStringStyle();  DefaultToStringStyle();  NoFieldNameToStringStyle();  ShortPrefixToStringStyle();  SimpleToStringStyle();  MultiLineToStringStyle();  static Map<Object, Object> getRegistry();  static boolean isRegistered(final Object value);  static void register(final Object value);  static void unregister(final Object value); public void appendSuper(final StringBuffer buffer, final String superToString); public void appendToString(final StringBuffer buffer, final String toString); public void appendStart(final StringBuffer buffer, final Object object); public void appendEnd(final StringBuffer buffer, final Object object); protected void removeLastFieldSeparator(final StringBuffer buffer); public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); public void append(final StringBuffer buffer, final String fieldName, final long value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); public void append(final StringBuffer buffer, final String fieldName, final int value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); public void append(final StringBuffer buffer, final String fieldName, final short value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); public void append(final StringBuffer buffer, final String fieldName, final byte value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); public void append(final StringBuffer buffer, final String fieldName, final char value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); public void append(final StringBuffer buffer, final String fieldName, final double value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); public void append(final StringBuffer buffer, final String fieldName, final float value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); public void append(final StringBuffer buffer, final String fieldName, final boolean value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendClassName(final StringBuffer buffer, final Object object); protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); protected void appendContentStart(final StringBuffer buffer); protected void appendContentEnd(final StringBuffer buffer); protected void appendNullText(final StringBuffer buffer, final String fieldName); protected void appendFieldSeparator(final StringBuffer buffer); protected void appendFieldStart(final StringBuffer buffer, final String fieldName); protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); protected boolean isFullDetail(final Boolean fullDetailRequest); protected String getShortClassName(final Class<?> cls); protected boolean isUseClassName(); protected void setUseClassName(final boolean useClassName); protected boolean isUseShortClassName(); protected void setUseShortClassName(final boolean useShortClassName); protected boolean isUseIdentityHashCode(); protected void setUseIdentityHashCode(final boolean useIdentityHashCode); protected boolean isUseFieldNames(); protected void setUseFieldNames(final boolean useFieldNames); protected boolean isDefaultFullDetail(); protected void setDefaultFullDetail(final boolean defaultFullDetail); protected boolean isArrayContentDetail(); protected void setArrayContentDetail(final boolean arrayContentDetail); protected String getArrayStart(); protected void setArrayStart(String arrayStart); protected String getArrayEnd(); protected void setArrayEnd(String arrayEnd); protected String getArraySeparator(); protected void setArraySeparator(String arraySeparator); protected String getContentStart(); protected void setContentStart(String contentStart); protected String getContentEnd(); protected void setContentEnd(String contentEnd); protected String getFieldNameValueSeparator(); protected void setFieldNameValueSeparator(String fieldNameValueSeparator); protected String getFieldSeparator(); protected void setFieldSeparator(String fieldSeparator); protected boolean isFieldSeparatorAtStart(); protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); protected boolean isFieldSeparatorAtEnd(); protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); protected String getNullText(); protected void setNullText(String nullText); protected String getSizeStartText(); protected void setSizeStartText(String sizeStartText); protected String getSizeEndText(); protected void setSizeEndText(String sizeEndText); protected String getSummaryObjectStartText(); protected void setSummaryObjectStartText(String summaryObjectStartText); protected String getSummaryObjectEndText(); protected void setSummaryObjectEndText(String summaryObjectEndText); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); long serialVersionUID=Optional[-2587890625525655916L]; ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; boolean useFieldNames=Optional[true]; boolean useClassName=Optional[true]; boolean useShortClassName=Optional[false]; boolean useIdentityHashCode=Optional[true]; String contentStart=Optional["["]; String contentEnd=Optional["]"]; String fieldNameValueSeparator=Optional["="]; boolean fieldSeparatorAtStart=Optional[false]; boolean fieldSeparatorAtEnd=Optional[false]; String fieldSeparator=Optional[","]; String arrayStart=Optional["{"]; String arraySeparator=Optional[","]; boolean arrayContentDetail=Optional[true]; String arrayEnd=Optional["}
public void append(final StringBuffer buffer, final String fieldName, final byte value) { [EOL]     appendFieldStart(buffer, fieldName); [EOL]     appendDetail(buffer, fieldName, value); [EOL]     appendFieldEnd(buffer, fieldName); [EOL] } protected ToStringStyle();  DefaultToStringStyle();  NoFieldNameToStringStyle();  ShortPrefixToStringStyle();  SimpleToStringStyle();  MultiLineToStringStyle();  static Map<Object, Object> getRegistry();  static boolean isRegistered(final Object value);  static void register(final Object value);  static void unregister(final Object value); public void appendSuper(final StringBuffer buffer, final String superToString); public void appendToString(final StringBuffer buffer, final String toString); public void appendStart(final StringBuffer buffer, final Object object); public void appendEnd(final StringBuffer buffer, final Object object); protected void removeLastFieldSeparator(final StringBuffer buffer); public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); public void append(final StringBuffer buffer, final String fieldName, final long value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); public void append(final StringBuffer buffer, final String fieldName, final int value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); public void append(final StringBuffer buffer, final String fieldName, final short value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); public void append(final StringBuffer buffer, final String fieldName, final byte value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); public void append(final StringBuffer buffer, final String fieldName, final char value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); public void append(final StringBuffer buffer, final String fieldName, final double value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); public void append(final StringBuffer buffer, final String fieldName, final float value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); public void append(final StringBuffer buffer, final String fieldName, final boolean value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendClassName(final StringBuffer buffer, final Object object); protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); protected void appendContentStart(final StringBuffer buffer); protected void appendContentEnd(final StringBuffer buffer); protected void appendNullText(final StringBuffer buffer, final String fieldName); protected void appendFieldSeparator(final StringBuffer buffer); protected void appendFieldStart(final StringBuffer buffer, final String fieldName); protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); protected boolean isFullDetail(final Boolean fullDetailRequest); protected String getShortClassName(final Class<?> cls); protected boolean isUseClassName(); protected void setUseClassName(final boolean useClassName); protected boolean isUseShortClassName(); protected void setUseShortClassName(final boolean useShortClassName); protected boolean isUseIdentityHashCode(); protected void setUseIdentityHashCode(final boolean useIdentityHashCode); protected boolean isUseFieldNames(); protected void setUseFieldNames(final boolean useFieldNames); protected boolean isDefaultFullDetail(); protected void setDefaultFullDetail(final boolean defaultFullDetail); protected boolean isArrayContentDetail(); protected void setArrayContentDetail(final boolean arrayContentDetail); protected String getArrayStart(); protected void setArrayStart(String arrayStart); protected String getArrayEnd(); protected void setArrayEnd(String arrayEnd); protected String getArraySeparator(); protected void setArraySeparator(String arraySeparator); protected String getContentStart(); protected void setContentStart(String contentStart); protected String getContentEnd(); protected void setContentEnd(String contentEnd); protected String getFieldNameValueSeparator(); protected void setFieldNameValueSeparator(String fieldNameValueSeparator); protected String getFieldSeparator(); protected void setFieldSeparator(String fieldSeparator); protected boolean isFieldSeparatorAtStart(); protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); protected boolean isFieldSeparatorAtEnd(); protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); protected String getNullText(); protected void setNullText(String nullText); protected String getSizeStartText(); protected void setSizeStartText(String sizeStartText); protected String getSizeEndText(); protected void setSizeEndText(String sizeEndText); protected String getSummaryObjectStartText(); protected void setSummaryObjectStartText(String summaryObjectStartText); protected String getSummaryObjectEndText(); protected void setSummaryObjectEndText(String summaryObjectEndText); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); long serialVersionUID=Optional[-2587890625525655916L]; ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; boolean useFieldNames=Optional[true]; boolean useClassName=Optional[true]; boolean useShortClassName=Optional[false]; boolean useIdentityHashCode=Optional[true]; String contentStart=Optional["["]; String contentEnd=Optional["]"]; String fieldNameValueSeparator=Optional["="]; boolean fieldSeparatorAtStart=Optional[false]; boolean fieldSeparatorAtEnd=Optional[false]; String fieldSeparator=Optional[","]; String arrayStart=Optional["{"]; String arraySeparator=Optional[","]; boolean arrayContentDetail=Optional[true]; String arrayEnd=Optional["}
public void append(final StringBuffer buffer, final String fieldName, final byte value) { [EOL]     appendFieldStart(buffer, fieldName); [EOL]     appendDetail(buffer, fieldName, value); [EOL]     appendFieldEnd(buffer, fieldName); [EOL] } protected ToStringStyle();  DefaultToStringStyle();  NoFieldNameToStringStyle();  ShortPrefixToStringStyle();  SimpleToStringStyle();  MultiLineToStringStyle();  static Map<Object, Object> getRegistry();  static boolean isRegistered(final Object value);  static void register(final Object value);  static void unregister(final Object value); public void appendSuper(final StringBuffer buffer, final String superToString); public void appendToString(final StringBuffer buffer, final String toString); public void appendStart(final StringBuffer buffer, final Object object); public void appendEnd(final StringBuffer buffer, final Object object); protected void removeLastFieldSeparator(final StringBuffer buffer); public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); public void append(final StringBuffer buffer, final String fieldName, final long value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); public void append(final StringBuffer buffer, final String fieldName, final int value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); public void append(final StringBuffer buffer, final String fieldName, final short value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); public void append(final StringBuffer buffer, final String fieldName, final byte value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); public void append(final StringBuffer buffer, final String fieldName, final char value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); public void append(final StringBuffer buffer, final String fieldName, final double value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); public void append(final StringBuffer buffer, final String fieldName, final float value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); public void append(final StringBuffer buffer, final String fieldName, final boolean value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendClassName(final StringBuffer buffer, final Object object); protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); protected void appendContentStart(final StringBuffer buffer); protected void appendContentEnd(final StringBuffer buffer); protected void appendNullText(final StringBuffer buffer, final String fieldName); protected void appendFieldSeparator(final StringBuffer buffer); protected void appendFieldStart(final StringBuffer buffer, final String fieldName); protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); protected boolean isFullDetail(final Boolean fullDetailRequest); protected String getShortClassName(final Class<?> cls); protected boolean isUseClassName(); protected void setUseClassName(final boolean useClassName); protected boolean isUseShortClassName(); protected void setUseShortClassName(final boolean useShortClassName); protected boolean isUseIdentityHashCode(); protected void setUseIdentityHashCode(final boolean useIdentityHashCode); protected boolean isUseFieldNames(); protected void setUseFieldNames(final boolean useFieldNames); protected boolean isDefaultFullDetail(); protected void setDefaultFullDetail(final boolean defaultFullDetail); protected boolean isArrayContentDetail(); protected void setArrayContentDetail(final boolean arrayContentDetail); protected String getArrayStart(); protected void setArrayStart(String arrayStart); protected String getArrayEnd(); protected void setArrayEnd(String arrayEnd); protected String getArraySeparator(); protected void setArraySeparator(String arraySeparator); protected String getContentStart(); protected void setContentStart(String contentStart); protected String getContentEnd(); protected void setContentEnd(String contentEnd); protected String getFieldNameValueSeparator(); protected void setFieldNameValueSeparator(String fieldNameValueSeparator); protected String getFieldSeparator(); protected void setFieldSeparator(String fieldSeparator); protected boolean isFieldSeparatorAtStart(); protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); protected boolean isFieldSeparatorAtEnd(); protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); protected String getNullText(); protected void setNullText(String nullText); protected String getSizeStartText(); protected void setSizeStartText(String sizeStartText); protected String getSizeEndText(); protected void setSizeEndText(String sizeEndText); protected String getSummaryObjectStartText(); protected void setSummaryObjectStartText(String summaryObjectStartText); protected String getSummaryObjectEndText(); protected void setSummaryObjectEndText(String summaryObjectEndText); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); long serialVersionUID=Optional[-2587890625525655916L]; ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; boolean useFieldNames=Optional[true]; boolean useClassName=Optional[true]; boolean useShortClassName=Optional[false]; boolean useIdentityHashCode=Optional[true]; String contentStart=Optional["["]; String contentEnd=Optional["]"]; String fieldNameValueSeparator=Optional["="]; boolean fieldSeparatorAtStart=Optional[false]; boolean fieldSeparatorAtEnd=Optional[false]; String fieldSeparator=Optional[","]; String arrayStart=Optional["{"]; String arraySeparator=Optional[","]; boolean arrayContentDetail=Optional[true]; String arrayEnd=Optional["}
public void append(final StringBuffer buffer, final String fieldName, final byte value) { [EOL]     appendFieldStart(buffer, fieldName); [EOL]     appendDetail(buffer, fieldName, value); [EOL]     appendFieldEnd(buffer, fieldName); [EOL] } protected ToStringStyle();  DefaultToStringStyle();  NoFieldNameToStringStyle();  ShortPrefixToStringStyle();  SimpleToStringStyle();  MultiLineToStringStyle();  static Map<Object, Object> getRegistry();  static boolean isRegistered(final Object value);  static void register(final Object value);  static void unregister(final Object value); public void appendSuper(final StringBuffer buffer, final String superToString); public void appendToString(final StringBuffer buffer, final String toString); public void appendStart(final StringBuffer buffer, final Object object); public void appendEnd(final StringBuffer buffer, final Object object); protected void removeLastFieldSeparator(final StringBuffer buffer); public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); public void append(final StringBuffer buffer, final String fieldName, final long value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); public void append(final StringBuffer buffer, final String fieldName, final int value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); public void append(final StringBuffer buffer, final String fieldName, final short value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); public void append(final StringBuffer buffer, final String fieldName, final byte value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); public void append(final StringBuffer buffer, final String fieldName, final char value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); public void append(final StringBuffer buffer, final String fieldName, final double value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); public void append(final StringBuffer buffer, final String fieldName, final float value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); public void append(final StringBuffer buffer, final String fieldName, final boolean value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendClassName(final StringBuffer buffer, final Object object); protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); protected void appendContentStart(final StringBuffer buffer); protected void appendContentEnd(final StringBuffer buffer); protected void appendNullText(final StringBuffer buffer, final String fieldName); protected void appendFieldSeparator(final StringBuffer buffer); protected void appendFieldStart(final StringBuffer buffer, final String fieldName); protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); protected boolean isFullDetail(final Boolean fullDetailRequest); protected String getShortClassName(final Class<?> cls); protected boolean isUseClassName(); protected void setUseClassName(final boolean useClassName); protected boolean isUseShortClassName(); protected void setUseShortClassName(final boolean useShortClassName); protected boolean isUseIdentityHashCode(); protected void setUseIdentityHashCode(final boolean useIdentityHashCode); protected boolean isUseFieldNames(); protected void setUseFieldNames(final boolean useFieldNames); protected boolean isDefaultFullDetail(); protected void setDefaultFullDetail(final boolean defaultFullDetail); protected boolean isArrayContentDetail(); protected void setArrayContentDetail(final boolean arrayContentDetail); protected String getArrayStart(); protected void setArrayStart(String arrayStart); protected String getArrayEnd(); protected void setArrayEnd(String arrayEnd); protected String getArraySeparator(); protected void setArraySeparator(String arraySeparator); protected String getContentStart(); protected void setContentStart(String contentStart); protected String getContentEnd(); protected void setContentEnd(String contentEnd); protected String getFieldNameValueSeparator(); protected void setFieldNameValueSeparator(String fieldNameValueSeparator); protected String getFieldSeparator(); protected void setFieldSeparator(String fieldSeparator); protected boolean isFieldSeparatorAtStart(); protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); protected boolean isFieldSeparatorAtEnd(); protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); protected String getNullText(); protected void setNullText(String nullText); protected String getSizeStartText(); protected void setSizeStartText(String sizeStartText); protected String getSizeEndText(); protected void setSizeEndText(String sizeEndText); protected String getSummaryObjectStartText(); protected void setSummaryObjectStartText(String summaryObjectStartText); protected String getSummaryObjectEndText(); protected void setSummaryObjectEndText(String summaryObjectEndText); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); long serialVersionUID=Optional[-2587890625525655916L]; ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; boolean useFieldNames=Optional[true]; boolean useClassName=Optional[true]; boolean useShortClassName=Optional[false]; boolean useIdentityHashCode=Optional[true]; String contentStart=Optional["["]; String contentEnd=Optional["]"]; String fieldNameValueSeparator=Optional["="]; boolean fieldSeparatorAtStart=Optional[false]; boolean fieldSeparatorAtEnd=Optional[false]; String fieldSeparator=Optional[","]; String arrayStart=Optional["{"]; String arraySeparator=Optional[","]; boolean arrayContentDetail=Optional[true]; String arrayEnd=Optional["}
public void append(final StringBuffer buffer, final String fieldName, final double value) { [EOL]     appendFieldStart(buffer, fieldName); [EOL]     appendDetail(buffer, fieldName, value); [EOL]     appendFieldEnd(buffer, fieldName); [EOL] } protected ToStringStyle();  DefaultToStringStyle();  NoFieldNameToStringStyle();  ShortPrefixToStringStyle();  SimpleToStringStyle();  MultiLineToStringStyle();  static Map<Object, Object> getRegistry();  static boolean isRegistered(final Object value);  static void register(final Object value);  static void unregister(final Object value); public void appendSuper(final StringBuffer buffer, final String superToString); public void appendToString(final StringBuffer buffer, final String toString); public void appendStart(final StringBuffer buffer, final Object object); public void appendEnd(final StringBuffer buffer, final Object object); protected void removeLastFieldSeparator(final StringBuffer buffer); public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); public void append(final StringBuffer buffer, final String fieldName, final long value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); public void append(final StringBuffer buffer, final String fieldName, final int value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); public void append(final StringBuffer buffer, final String fieldName, final short value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); public void append(final StringBuffer buffer, final String fieldName, final byte value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); public void append(final StringBuffer buffer, final String fieldName, final char value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); public void append(final StringBuffer buffer, final String fieldName, final double value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); public void append(final StringBuffer buffer, final String fieldName, final float value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); public void append(final StringBuffer buffer, final String fieldName, final boolean value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendClassName(final StringBuffer buffer, final Object object); protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); protected void appendContentStart(final StringBuffer buffer); protected void appendContentEnd(final StringBuffer buffer); protected void appendNullText(final StringBuffer buffer, final String fieldName); protected void appendFieldSeparator(final StringBuffer buffer); protected void appendFieldStart(final StringBuffer buffer, final String fieldName); protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); protected boolean isFullDetail(final Boolean fullDetailRequest); protected String getShortClassName(final Class<?> cls); protected boolean isUseClassName(); protected void setUseClassName(final boolean useClassName); protected boolean isUseShortClassName(); protected void setUseShortClassName(final boolean useShortClassName); protected boolean isUseIdentityHashCode(); protected void setUseIdentityHashCode(final boolean useIdentityHashCode); protected boolean isUseFieldNames(); protected void setUseFieldNames(final boolean useFieldNames); protected boolean isDefaultFullDetail(); protected void setDefaultFullDetail(final boolean defaultFullDetail); protected boolean isArrayContentDetail(); protected void setArrayContentDetail(final boolean arrayContentDetail); protected String getArrayStart(); protected void setArrayStart(String arrayStart); protected String getArrayEnd(); protected void setArrayEnd(String arrayEnd); protected String getArraySeparator(); protected void setArraySeparator(String arraySeparator); protected String getContentStart(); protected void setContentStart(String contentStart); protected String getContentEnd(); protected void setContentEnd(String contentEnd); protected String getFieldNameValueSeparator(); protected void setFieldNameValueSeparator(String fieldNameValueSeparator); protected String getFieldSeparator(); protected void setFieldSeparator(String fieldSeparator); protected boolean isFieldSeparatorAtStart(); protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); protected boolean isFieldSeparatorAtEnd(); protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); protected String getNullText(); protected void setNullText(String nullText); protected String getSizeStartText(); protected void setSizeStartText(String sizeStartText); protected String getSizeEndText(); protected void setSizeEndText(String sizeEndText); protected String getSummaryObjectStartText(); protected void setSummaryObjectStartText(String summaryObjectStartText); protected String getSummaryObjectEndText(); protected void setSummaryObjectEndText(String summaryObjectEndText); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); long serialVersionUID=Optional[-2587890625525655916L]; ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; boolean useFieldNames=Optional[true]; boolean useClassName=Optional[true]; boolean useShortClassName=Optional[false]; boolean useIdentityHashCode=Optional[true]; String contentStart=Optional["["]; String contentEnd=Optional["]"]; String fieldNameValueSeparator=Optional["="]; boolean fieldSeparatorAtStart=Optional[false]; boolean fieldSeparatorAtEnd=Optional[false]; String fieldSeparator=Optional[","]; String arrayStart=Optional["{"]; String arraySeparator=Optional[","]; boolean arrayContentDetail=Optional[true]; String arrayEnd=Optional["}
protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value) { [EOL]     buffer.append(value); [EOL] } protected ToStringStyle();  DefaultToStringStyle();  NoFieldNameToStringStyle();  ShortPrefixToStringStyle();  SimpleToStringStyle();  MultiLineToStringStyle();  static Map<Object, Object> getRegistry();  static boolean isRegistered(final Object value);  static void register(final Object value);  static void unregister(final Object value); public void appendSuper(final StringBuffer buffer, final String superToString); public void appendToString(final StringBuffer buffer, final String toString); public void appendStart(final StringBuffer buffer, final Object object); public void appendEnd(final StringBuffer buffer, final Object object); protected void removeLastFieldSeparator(final StringBuffer buffer); public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); public void append(final StringBuffer buffer, final String fieldName, final long value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); public void append(final StringBuffer buffer, final String fieldName, final int value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); public void append(final StringBuffer buffer, final String fieldName, final short value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); public void append(final StringBuffer buffer, final String fieldName, final byte value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); public void append(final StringBuffer buffer, final String fieldName, final char value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); public void append(final StringBuffer buffer, final String fieldName, final double value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); public void append(final StringBuffer buffer, final String fieldName, final float value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); public void append(final StringBuffer buffer, final String fieldName, final boolean value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendClassName(final StringBuffer buffer, final Object object); protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); protected void appendContentStart(final StringBuffer buffer); protected void appendContentEnd(final StringBuffer buffer); protected void appendNullText(final StringBuffer buffer, final String fieldName); protected void appendFieldSeparator(final StringBuffer buffer); protected void appendFieldStart(final StringBuffer buffer, final String fieldName); protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); protected boolean isFullDetail(final Boolean fullDetailRequest); protected String getShortClassName(final Class<?> cls); protected boolean isUseClassName(); protected void setUseClassName(final boolean useClassName); protected boolean isUseShortClassName(); protected void setUseShortClassName(final boolean useShortClassName); protected boolean isUseIdentityHashCode(); protected void setUseIdentityHashCode(final boolean useIdentityHashCode); protected boolean isUseFieldNames(); protected void setUseFieldNames(final boolean useFieldNames); protected boolean isDefaultFullDetail(); protected void setDefaultFullDetail(final boolean defaultFullDetail); protected boolean isArrayContentDetail(); protected void setArrayContentDetail(final boolean arrayContentDetail); protected String getArrayStart(); protected void setArrayStart(String arrayStart); protected String getArrayEnd(); protected void setArrayEnd(String arrayEnd); protected String getArraySeparator(); protected void setArraySeparator(String arraySeparator); protected String getContentStart(); protected void setContentStart(String contentStart); protected String getContentEnd(); protected void setContentEnd(String contentEnd); protected String getFieldNameValueSeparator(); protected void setFieldNameValueSeparator(String fieldNameValueSeparator); protected String getFieldSeparator(); protected void setFieldSeparator(String fieldSeparator); protected boolean isFieldSeparatorAtStart(); protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); protected boolean isFieldSeparatorAtEnd(); protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); protected String getNullText(); protected void setNullText(String nullText); protected String getSizeStartText(); protected void setSizeStartText(String sizeStartText); protected String getSizeEndText(); protected void setSizeEndText(String sizeEndText); protected String getSummaryObjectStartText(); protected void setSummaryObjectStartText(String summaryObjectStartText); protected String getSummaryObjectEndText(); protected void setSummaryObjectEndText(String summaryObjectEndText); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); long serialVersionUID=Optional[-2587890625525655916L]; ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; boolean useFieldNames=Optional[true]; boolean useClassName=Optional[true]; boolean useShortClassName=Optional[false]; boolean useIdentityHashCode=Optional[true]; String contentStart=Optional["["]; String contentEnd=Optional["]"]; String fieldNameValueSeparator=Optional["="]; boolean fieldSeparatorAtStart=Optional[false]; boolean fieldSeparatorAtEnd=Optional[false]; String fieldSeparator=Optional[","]; String arrayStart=Optional["{"]; String arraySeparator=Optional[","]; boolean arrayContentDetail=Optional[true]; String arrayEnd=Optional["}
protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value) { [EOL]     buffer.append(value); [EOL] } protected ToStringStyle();  DefaultToStringStyle();  NoFieldNameToStringStyle();  ShortPrefixToStringStyle();  SimpleToStringStyle();  MultiLineToStringStyle();  static Map<Object, Object> getRegistry();  static boolean isRegistered(final Object value);  static void register(final Object value);  static void unregister(final Object value); public void appendSuper(final StringBuffer buffer, final String superToString); public void appendToString(final StringBuffer buffer, final String toString); public void appendStart(final StringBuffer buffer, final Object object); public void appendEnd(final StringBuffer buffer, final Object object); protected void removeLastFieldSeparator(final StringBuffer buffer); public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); public void append(final StringBuffer buffer, final String fieldName, final long value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); public void append(final StringBuffer buffer, final String fieldName, final int value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); public void append(final StringBuffer buffer, final String fieldName, final short value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); public void append(final StringBuffer buffer, final String fieldName, final byte value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); public void append(final StringBuffer buffer, final String fieldName, final char value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); public void append(final StringBuffer buffer, final String fieldName, final double value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); public void append(final StringBuffer buffer, final String fieldName, final float value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); public void append(final StringBuffer buffer, final String fieldName, final boolean value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendClassName(final StringBuffer buffer, final Object object); protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); protected void appendContentStart(final StringBuffer buffer); protected void appendContentEnd(final StringBuffer buffer); protected void appendNullText(final StringBuffer buffer, final String fieldName); protected void appendFieldSeparator(final StringBuffer buffer); protected void appendFieldStart(final StringBuffer buffer, final String fieldName); protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); protected boolean isFullDetail(final Boolean fullDetailRequest); protected String getShortClassName(final Class<?> cls); protected boolean isUseClassName(); protected void setUseClassName(final boolean useClassName); protected boolean isUseShortClassName(); protected void setUseShortClassName(final boolean useShortClassName); protected boolean isUseIdentityHashCode(); protected void setUseIdentityHashCode(final boolean useIdentityHashCode); protected boolean isUseFieldNames(); protected void setUseFieldNames(final boolean useFieldNames); protected boolean isDefaultFullDetail(); protected void setDefaultFullDetail(final boolean defaultFullDetail); protected boolean isArrayContentDetail(); protected void setArrayContentDetail(final boolean arrayContentDetail); protected String getArrayStart(); protected void setArrayStart(String arrayStart); protected String getArrayEnd(); protected void setArrayEnd(String arrayEnd); protected String getArraySeparator(); protected void setArraySeparator(String arraySeparator); protected String getContentStart(); protected void setContentStart(String contentStart); protected String getContentEnd(); protected void setContentEnd(String contentEnd); protected String getFieldNameValueSeparator(); protected void setFieldNameValueSeparator(String fieldNameValueSeparator); protected String getFieldSeparator(); protected void setFieldSeparator(String fieldSeparator); protected boolean isFieldSeparatorAtStart(); protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); protected boolean isFieldSeparatorAtEnd(); protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); protected String getNullText(); protected void setNullText(String nullText); protected String getSizeStartText(); protected void setSizeStartText(String sizeStartText); protected String getSizeEndText(); protected void setSizeEndText(String sizeEndText); protected String getSummaryObjectStartText(); protected void setSummaryObjectStartText(String summaryObjectStartText); protected String getSummaryObjectEndText(); protected void setSummaryObjectEndText(String summaryObjectEndText); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); long serialVersionUID=Optional[-2587890625525655916L]; ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; boolean useFieldNames=Optional[true]; boolean useClassName=Optional[true]; boolean useShortClassName=Optional[false]; boolean useIdentityHashCode=Optional[true]; String contentStart=Optional["["]; String contentEnd=Optional["]"]; String fieldNameValueSeparator=Optional["="]; boolean fieldSeparatorAtStart=Optional[false]; boolean fieldSeparatorAtEnd=Optional[false]; String fieldSeparator=Optional[","]; String arrayStart=Optional["{"]; String arraySeparator=Optional[","]; boolean arrayContentDetail=Optional[true]; String arrayEnd=Optional["}
protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value) { [EOL]     buffer.append(value); [EOL] } protected ToStringStyle();  DefaultToStringStyle();  NoFieldNameToStringStyle();  ShortPrefixToStringStyle();  SimpleToStringStyle();  MultiLineToStringStyle();  static Map<Object, Object> getRegistry();  static boolean isRegistered(final Object value);  static void register(final Object value);  static void unregister(final Object value); public void appendSuper(final StringBuffer buffer, final String superToString); public void appendToString(final StringBuffer buffer, final String toString); public void appendStart(final StringBuffer buffer, final Object object); public void appendEnd(final StringBuffer buffer, final Object object); protected void removeLastFieldSeparator(final StringBuffer buffer); public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); public void append(final StringBuffer buffer, final String fieldName, final long value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); public void append(final StringBuffer buffer, final String fieldName, final int value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); public void append(final StringBuffer buffer, final String fieldName, final short value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); public void append(final StringBuffer buffer, final String fieldName, final byte value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); public void append(final StringBuffer buffer, final String fieldName, final char value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); public void append(final StringBuffer buffer, final String fieldName, final double value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); public void append(final StringBuffer buffer, final String fieldName, final float value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); public void append(final StringBuffer buffer, final String fieldName, final boolean value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendClassName(final StringBuffer buffer, final Object object); protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); protected void appendContentStart(final StringBuffer buffer); protected void appendContentEnd(final StringBuffer buffer); protected void appendNullText(final StringBuffer buffer, final String fieldName); protected void appendFieldSeparator(final StringBuffer buffer); protected void appendFieldStart(final StringBuffer buffer, final String fieldName); protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); protected boolean isFullDetail(final Boolean fullDetailRequest); protected String getShortClassName(final Class<?> cls); protected boolean isUseClassName(); protected void setUseClassName(final boolean useClassName); protected boolean isUseShortClassName(); protected void setUseShortClassName(final boolean useShortClassName); protected boolean isUseIdentityHashCode(); protected void setUseIdentityHashCode(final boolean useIdentityHashCode); protected boolean isUseFieldNames(); protected void setUseFieldNames(final boolean useFieldNames); protected boolean isDefaultFullDetail(); protected void setDefaultFullDetail(final boolean defaultFullDetail); protected boolean isArrayContentDetail(); protected void setArrayContentDetail(final boolean arrayContentDetail); protected String getArrayStart(); protected void setArrayStart(String arrayStart); protected String getArrayEnd(); protected void setArrayEnd(String arrayEnd); protected String getArraySeparator(); protected void setArraySeparator(String arraySeparator); protected String getContentStart(); protected void setContentStart(String contentStart); protected String getContentEnd(); protected void setContentEnd(String contentEnd); protected String getFieldNameValueSeparator(); protected void setFieldNameValueSeparator(String fieldNameValueSeparator); protected String getFieldSeparator(); protected void setFieldSeparator(String fieldSeparator); protected boolean isFieldSeparatorAtStart(); protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); protected boolean isFieldSeparatorAtEnd(); protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); protected String getNullText(); protected void setNullText(String nullText); protected String getSizeStartText(); protected void setSizeStartText(String sizeStartText); protected String getSizeEndText(); protected void setSizeEndText(String sizeEndText); protected String getSummaryObjectStartText(); protected void setSummaryObjectStartText(String summaryObjectStartText); protected String getSummaryObjectEndText(); protected void setSummaryObjectEndText(String summaryObjectEndText); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); long serialVersionUID=Optional[-2587890625525655916L]; ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; boolean useFieldNames=Optional[true]; boolean useClassName=Optional[true]; boolean useShortClassName=Optional[false]; boolean useIdentityHashCode=Optional[true]; String contentStart=Optional["["]; String contentEnd=Optional["]"]; String fieldNameValueSeparator=Optional["="]; boolean fieldSeparatorAtStart=Optional[false]; boolean fieldSeparatorAtEnd=Optional[false]; String fieldSeparator=Optional[","]; String arrayStart=Optional["{"]; String arraySeparator=Optional[","]; boolean arrayContentDetail=Optional[true]; String arrayEnd=Optional["}
public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail) { [EOL]     appendFieldStart(buffer, fieldName); [EOL]     if (array == null) { [EOL]         appendNullText(buffer, fieldName); [EOL]     } else if (isFullDetail(fullDetail)) { [EOL]         appendDetail(buffer, fieldName, array); [EOL]     } else { [EOL]         appendSummary(buffer, fieldName, array); [EOL]     } [EOL]     appendFieldEnd(buffer, fieldName); [EOL] } protected ToStringStyle();  DefaultToStringStyle();  NoFieldNameToStringStyle();  ShortPrefixToStringStyle();  SimpleToStringStyle();  MultiLineToStringStyle();  static Map<Object, Object> getRegistry();  static boolean isRegistered(final Object value);  static void register(final Object value);  static void unregister(final Object value); public void appendSuper(final StringBuffer buffer, final String superToString); public void appendToString(final StringBuffer buffer, final String toString); public void appendStart(final StringBuffer buffer, final Object object); public void appendEnd(final StringBuffer buffer, final Object object); protected void removeLastFieldSeparator(final StringBuffer buffer); public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); public void append(final StringBuffer buffer, final String fieldName, final long value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); public void append(final StringBuffer buffer, final String fieldName, final int value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); public void append(final StringBuffer buffer, final String fieldName, final short value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); public void append(final StringBuffer buffer, final String fieldName, final byte value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); public void append(final StringBuffer buffer, final String fieldName, final char value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); public void append(final StringBuffer buffer, final String fieldName, final double value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); public void append(final StringBuffer buffer, final String fieldName, final float value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); public void append(final StringBuffer buffer, final String fieldName, final boolean value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendClassName(final StringBuffer buffer, final Object object); protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); protected void appendContentStart(final StringBuffer buffer); protected void appendContentEnd(final StringBuffer buffer); protected void appendNullText(final StringBuffer buffer, final String fieldName); protected void appendFieldSeparator(final StringBuffer buffer); protected void appendFieldStart(final StringBuffer buffer, final String fieldName); protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); protected boolean isFullDetail(final Boolean fullDetailRequest); protected String getShortClassName(final Class<?> cls); protected boolean isUseClassName(); protected void setUseClassName(final boolean useClassName); protected boolean isUseShortClassName(); protected void setUseShortClassName(final boolean useShortClassName); protected boolean isUseIdentityHashCode(); protected void setUseIdentityHashCode(final boolean useIdentityHashCode); protected boolean isUseFieldNames(); protected void setUseFieldNames(final boolean useFieldNames); protected boolean isDefaultFullDetail(); protected void setDefaultFullDetail(final boolean defaultFullDetail); protected boolean isArrayContentDetail(); protected void setArrayContentDetail(final boolean arrayContentDetail); protected String getArrayStart(); protected void setArrayStart(String arrayStart); protected String getArrayEnd(); protected void setArrayEnd(String arrayEnd); protected String getArraySeparator(); protected void setArraySeparator(String arraySeparator); protected String getContentStart(); protected void setContentStart(String contentStart); protected String getContentEnd(); protected void setContentEnd(String contentEnd); protected String getFieldNameValueSeparator(); protected void setFieldNameValueSeparator(String fieldNameValueSeparator); protected String getFieldSeparator(); protected void setFieldSeparator(String fieldSeparator); protected boolean isFieldSeparatorAtStart(); protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); protected boolean isFieldSeparatorAtEnd(); protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); protected String getNullText(); protected void setNullText(String nullText); protected String getSizeStartText(); protected void setSizeStartText(String sizeStartText); protected String getSizeEndText(); protected void setSizeEndText(String sizeEndText); protected String getSummaryObjectStartText(); protected void setSummaryObjectStartText(String summaryObjectStartText); protected String getSummaryObjectEndText(); protected void setSummaryObjectEndText(String summaryObjectEndText); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); long serialVersionUID=Optional[-2587890625525655916L]; ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; boolean useFieldNames=Optional[true]; boolean useClassName=Optional[true]; boolean useShortClassName=Optional[false]; boolean useIdentityHashCode=Optional[true]; String contentStart=Optional["["]; String contentEnd=Optional["]"]; String fieldNameValueSeparator=Optional["="]; boolean fieldSeparatorAtStart=Optional[false]; boolean fieldSeparatorAtEnd=Optional[false]; String fieldSeparator=Optional[","]; String arrayStart=Optional["{"]; String arraySeparator=Optional[","]; boolean arrayContentDetail=Optional[true]; String arrayEnd=Optional["}
public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail) { [EOL]     appendFieldStart(buffer, fieldName); [EOL]     if (array == null) { [EOL]         appendNullText(buffer, fieldName); [EOL]     } else if (isFullDetail(fullDetail)) { [EOL]         appendDetail(buffer, fieldName, array); [EOL]     } else { [EOL]         appendSummary(buffer, fieldName, array); [EOL]     } [EOL]     appendFieldEnd(buffer, fieldName); [EOL] } protected ToStringStyle();  DefaultToStringStyle();  NoFieldNameToStringStyle();  ShortPrefixToStringStyle();  SimpleToStringStyle();  MultiLineToStringStyle();  static Map<Object, Object> getRegistry();  static boolean isRegistered(final Object value);  static void register(final Object value);  static void unregister(final Object value); public void appendSuper(final StringBuffer buffer, final String superToString); public void appendToString(final StringBuffer buffer, final String toString); public void appendStart(final StringBuffer buffer, final Object object); public void appendEnd(final StringBuffer buffer, final Object object); protected void removeLastFieldSeparator(final StringBuffer buffer); public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); public void append(final StringBuffer buffer, final String fieldName, final long value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); public void append(final StringBuffer buffer, final String fieldName, final int value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); public void append(final StringBuffer buffer, final String fieldName, final short value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); public void append(final StringBuffer buffer, final String fieldName, final byte value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); public void append(final StringBuffer buffer, final String fieldName, final char value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); public void append(final StringBuffer buffer, final String fieldName, final double value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); public void append(final StringBuffer buffer, final String fieldName, final float value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); public void append(final StringBuffer buffer, final String fieldName, final boolean value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendClassName(final StringBuffer buffer, final Object object); protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); protected void appendContentStart(final StringBuffer buffer); protected void appendContentEnd(final StringBuffer buffer); protected void appendNullText(final StringBuffer buffer, final String fieldName); protected void appendFieldSeparator(final StringBuffer buffer); protected void appendFieldStart(final StringBuffer buffer, final String fieldName); protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); protected boolean isFullDetail(final Boolean fullDetailRequest); protected String getShortClassName(final Class<?> cls); protected boolean isUseClassName(); protected void setUseClassName(final boolean useClassName); protected boolean isUseShortClassName(); protected void setUseShortClassName(final boolean useShortClassName); protected boolean isUseIdentityHashCode(); protected void setUseIdentityHashCode(final boolean useIdentityHashCode); protected boolean isUseFieldNames(); protected void setUseFieldNames(final boolean useFieldNames); protected boolean isDefaultFullDetail(); protected void setDefaultFullDetail(final boolean defaultFullDetail); protected boolean isArrayContentDetail(); protected void setArrayContentDetail(final boolean arrayContentDetail); protected String getArrayStart(); protected void setArrayStart(String arrayStart); protected String getArrayEnd(); protected void setArrayEnd(String arrayEnd); protected String getArraySeparator(); protected void setArraySeparator(String arraySeparator); protected String getContentStart(); protected void setContentStart(String contentStart); protected String getContentEnd(); protected void setContentEnd(String contentEnd); protected String getFieldNameValueSeparator(); protected void setFieldNameValueSeparator(String fieldNameValueSeparator); protected String getFieldSeparator(); protected void setFieldSeparator(String fieldSeparator); protected boolean isFieldSeparatorAtStart(); protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); protected boolean isFieldSeparatorAtEnd(); protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); protected String getNullText(); protected void setNullText(String nullText); protected String getSizeStartText(); protected void setSizeStartText(String sizeStartText); protected String getSizeEndText(); protected void setSizeEndText(String sizeEndText); protected String getSummaryObjectStartText(); protected void setSummaryObjectStartText(String summaryObjectStartText); protected String getSummaryObjectEndText(); protected void setSummaryObjectEndText(String summaryObjectEndText); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); long serialVersionUID=Optional[-2587890625525655916L]; ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; boolean useFieldNames=Optional[true]; boolean useClassName=Optional[true]; boolean useShortClassName=Optional[false]; boolean useIdentityHashCode=Optional[true]; String contentStart=Optional["["]; String contentEnd=Optional["]"]; String fieldNameValueSeparator=Optional["="]; boolean fieldSeparatorAtStart=Optional[false]; boolean fieldSeparatorAtEnd=Optional[false]; String fieldSeparator=Optional[","]; String arrayStart=Optional["{"]; String arraySeparator=Optional[","]; boolean arrayContentDetail=Optional[true]; String arrayEnd=Optional["}
public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail) { [EOL]     appendFieldStart(buffer, fieldName); [EOL]     if (array == null) { [EOL]         appendNullText(buffer, fieldName); [EOL]     } else if (isFullDetail(fullDetail)) { [EOL]         appendDetail(buffer, fieldName, array); [EOL]     } else { [EOL]         appendSummary(buffer, fieldName, array); [EOL]     } [EOL]     appendFieldEnd(buffer, fieldName); [EOL] } protected ToStringStyle();  DefaultToStringStyle();  NoFieldNameToStringStyle();  ShortPrefixToStringStyle();  SimpleToStringStyle();  MultiLineToStringStyle();  static Map<Object, Object> getRegistry();  static boolean isRegistered(final Object value);  static void register(final Object value);  static void unregister(final Object value); public void appendSuper(final StringBuffer buffer, final String superToString); public void appendToString(final StringBuffer buffer, final String toString); public void appendStart(final StringBuffer buffer, final Object object); public void appendEnd(final StringBuffer buffer, final Object object); protected void removeLastFieldSeparator(final StringBuffer buffer); public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); public void append(final StringBuffer buffer, final String fieldName, final long value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); public void append(final StringBuffer buffer, final String fieldName, final int value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); public void append(final StringBuffer buffer, final String fieldName, final short value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); public void append(final StringBuffer buffer, final String fieldName, final byte value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); public void append(final StringBuffer buffer, final String fieldName, final char value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); public void append(final StringBuffer buffer, final String fieldName, final double value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); public void append(final StringBuffer buffer, final String fieldName, final float value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); public void append(final StringBuffer buffer, final String fieldName, final boolean value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendClassName(final StringBuffer buffer, final Object object); protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); protected void appendContentStart(final StringBuffer buffer); protected void appendContentEnd(final StringBuffer buffer); protected void appendNullText(final StringBuffer buffer, final String fieldName); protected void appendFieldSeparator(final StringBuffer buffer); protected void appendFieldStart(final StringBuffer buffer, final String fieldName); protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); protected boolean isFullDetail(final Boolean fullDetailRequest); protected String getShortClassName(final Class<?> cls); protected boolean isUseClassName(); protected void setUseClassName(final boolean useClassName); protected boolean isUseShortClassName(); protected void setUseShortClassName(final boolean useShortClassName); protected boolean isUseIdentityHashCode(); protected void setUseIdentityHashCode(final boolean useIdentityHashCode); protected boolean isUseFieldNames(); protected void setUseFieldNames(final boolean useFieldNames); protected boolean isDefaultFullDetail(); protected void setDefaultFullDetail(final boolean defaultFullDetail); protected boolean isArrayContentDetail(); protected void setArrayContentDetail(final boolean arrayContentDetail); protected String getArrayStart(); protected void setArrayStart(String arrayStart); protected String getArrayEnd(); protected void setArrayEnd(String arrayEnd); protected String getArraySeparator(); protected void setArraySeparator(String arraySeparator); protected String getContentStart(); protected void setContentStart(String contentStart); protected String getContentEnd(); protected void setContentEnd(String contentEnd); protected String getFieldNameValueSeparator(); protected void setFieldNameValueSeparator(String fieldNameValueSeparator); protected String getFieldSeparator(); protected void setFieldSeparator(String fieldSeparator); protected boolean isFieldSeparatorAtStart(); protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); protected boolean isFieldSeparatorAtEnd(); protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); protected String getNullText(); protected void setNullText(String nullText); protected String getSizeStartText(); protected void setSizeStartText(String sizeStartText); protected String getSizeEndText(); protected void setSizeEndText(String sizeEndText); protected String getSummaryObjectStartText(); protected void setSummaryObjectStartText(String summaryObjectStartText); protected String getSummaryObjectEndText(); protected void setSummaryObjectEndText(String summaryObjectEndText); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); long serialVersionUID=Optional[-2587890625525655916L]; ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; boolean useFieldNames=Optional[true]; boolean useClassName=Optional[true]; boolean useShortClassName=Optional[false]; boolean useIdentityHashCode=Optional[true]; String contentStart=Optional["["]; String contentEnd=Optional["]"]; String fieldNameValueSeparator=Optional["="]; boolean fieldSeparatorAtStart=Optional[false]; boolean fieldSeparatorAtEnd=Optional[false]; String fieldSeparator=Optional[","]; String arrayStart=Optional["{"]; String arraySeparator=Optional[","]; boolean arrayContentDetail=Optional[true]; String arrayEnd=Optional["}
public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail) { [EOL]     appendFieldStart(buffer, fieldName); [EOL]     if (array == null) { [EOL]         appendNullText(buffer, fieldName); [EOL]     } else if (isFullDetail(fullDetail)) { [EOL]         appendDetail(buffer, fieldName, array); [EOL]     } else { [EOL]         appendSummary(buffer, fieldName, array); [EOL]     } [EOL]     appendFieldEnd(buffer, fieldName); [EOL] } protected ToStringStyle();  DefaultToStringStyle();  NoFieldNameToStringStyle();  ShortPrefixToStringStyle();  SimpleToStringStyle();  MultiLineToStringStyle();  static Map<Object, Object> getRegistry();  static boolean isRegistered(final Object value);  static void register(final Object value);  static void unregister(final Object value); public void appendSuper(final StringBuffer buffer, final String superToString); public void appendToString(final StringBuffer buffer, final String toString); public void appendStart(final StringBuffer buffer, final Object object); public void appendEnd(final StringBuffer buffer, final Object object); protected void removeLastFieldSeparator(final StringBuffer buffer); public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); public void append(final StringBuffer buffer, final String fieldName, final long value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); public void append(final StringBuffer buffer, final String fieldName, final int value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); public void append(final StringBuffer buffer, final String fieldName, final short value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); public void append(final StringBuffer buffer, final String fieldName, final byte value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); public void append(final StringBuffer buffer, final String fieldName, final char value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); public void append(final StringBuffer buffer, final String fieldName, final double value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); public void append(final StringBuffer buffer, final String fieldName, final float value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); public void append(final StringBuffer buffer, final String fieldName, final boolean value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendClassName(final StringBuffer buffer, final Object object); protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); protected void appendContentStart(final StringBuffer buffer); protected void appendContentEnd(final StringBuffer buffer); protected void appendNullText(final StringBuffer buffer, final String fieldName); protected void appendFieldSeparator(final StringBuffer buffer); protected void appendFieldStart(final StringBuffer buffer, final String fieldName); protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); protected boolean isFullDetail(final Boolean fullDetailRequest); protected String getShortClassName(final Class<?> cls); protected boolean isUseClassName(); protected void setUseClassName(final boolean useClassName); protected boolean isUseShortClassName(); protected void setUseShortClassName(final boolean useShortClassName); protected boolean isUseIdentityHashCode(); protected void setUseIdentityHashCode(final boolean useIdentityHashCode); protected boolean isUseFieldNames(); protected void setUseFieldNames(final boolean useFieldNames); protected boolean isDefaultFullDetail(); protected void setDefaultFullDetail(final boolean defaultFullDetail); protected boolean isArrayContentDetail(); protected void setArrayContentDetail(final boolean arrayContentDetail); protected String getArrayStart(); protected void setArrayStart(String arrayStart); protected String getArrayEnd(); protected void setArrayEnd(String arrayEnd); protected String getArraySeparator(); protected void setArraySeparator(String arraySeparator); protected String getContentStart(); protected void setContentStart(String contentStart); protected String getContentEnd(); protected void setContentEnd(String contentEnd); protected String getFieldNameValueSeparator(); protected void setFieldNameValueSeparator(String fieldNameValueSeparator); protected String getFieldSeparator(); protected void setFieldSeparator(String fieldSeparator); protected boolean isFieldSeparatorAtStart(); protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); protected boolean isFieldSeparatorAtEnd(); protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); protected String getNullText(); protected void setNullText(String nullText); protected String getSizeStartText(); protected void setSizeStartText(String sizeStartText); protected String getSizeEndText(); protected void setSizeEndText(String sizeEndText); protected String getSummaryObjectStartText(); protected void setSummaryObjectStartText(String summaryObjectStartText); protected String getSummaryObjectEndText(); protected void setSummaryObjectEndText(String summaryObjectEndText); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); long serialVersionUID=Optional[-2587890625525655916L]; ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; boolean useFieldNames=Optional[true]; boolean useClassName=Optional[true]; boolean useShortClassName=Optional[false]; boolean useIdentityHashCode=Optional[true]; String contentStart=Optional["["]; String contentEnd=Optional["]"]; String fieldNameValueSeparator=Optional["="]; boolean fieldSeparatorAtStart=Optional[false]; boolean fieldSeparatorAtEnd=Optional[false]; String fieldSeparator=Optional[","]; String arrayStart=Optional["{"]; String arraySeparator=Optional[","]; boolean arrayContentDetail=Optional[true]; String arrayEnd=Optional["}
public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail) { [EOL]     appendFieldStart(buffer, fieldName); [EOL]     if (array == null) { [EOL]         appendNullText(buffer, fieldName); [EOL]     } else if (isFullDetail(fullDetail)) { [EOL]         appendDetail(buffer, fieldName, array); [EOL]     } else { [EOL]         appendSummary(buffer, fieldName, array); [EOL]     } [EOL]     appendFieldEnd(buffer, fieldName); [EOL] } protected ToStringStyle();  DefaultToStringStyle();  NoFieldNameToStringStyle();  ShortPrefixToStringStyle();  SimpleToStringStyle();  MultiLineToStringStyle();  static Map<Object, Object> getRegistry();  static boolean isRegistered(final Object value);  static void register(final Object value);  static void unregister(final Object value); public void appendSuper(final StringBuffer buffer, final String superToString); public void appendToString(final StringBuffer buffer, final String toString); public void appendStart(final StringBuffer buffer, final Object object); public void appendEnd(final StringBuffer buffer, final Object object); protected void removeLastFieldSeparator(final StringBuffer buffer); public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); public void append(final StringBuffer buffer, final String fieldName, final long value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); public void append(final StringBuffer buffer, final String fieldName, final int value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); public void append(final StringBuffer buffer, final String fieldName, final short value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); public void append(final StringBuffer buffer, final String fieldName, final byte value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); public void append(final StringBuffer buffer, final String fieldName, final char value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); public void append(final StringBuffer buffer, final String fieldName, final double value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); public void append(final StringBuffer buffer, final String fieldName, final float value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); public void append(final StringBuffer buffer, final String fieldName, final boolean value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendClassName(final StringBuffer buffer, final Object object); protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); protected void appendContentStart(final StringBuffer buffer); protected void appendContentEnd(final StringBuffer buffer); protected void appendNullText(final StringBuffer buffer, final String fieldName); protected void appendFieldSeparator(final StringBuffer buffer); protected void appendFieldStart(final StringBuffer buffer, final String fieldName); protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); protected boolean isFullDetail(final Boolean fullDetailRequest); protected String getShortClassName(final Class<?> cls); protected boolean isUseClassName(); protected void setUseClassName(final boolean useClassName); protected boolean isUseShortClassName(); protected void setUseShortClassName(final boolean useShortClassName); protected boolean isUseIdentityHashCode(); protected void setUseIdentityHashCode(final boolean useIdentityHashCode); protected boolean isUseFieldNames(); protected void setUseFieldNames(final boolean useFieldNames); protected boolean isDefaultFullDetail(); protected void setDefaultFullDetail(final boolean defaultFullDetail); protected boolean isArrayContentDetail(); protected void setArrayContentDetail(final boolean arrayContentDetail); protected String getArrayStart(); protected void setArrayStart(String arrayStart); protected String getArrayEnd(); protected void setArrayEnd(String arrayEnd); protected String getArraySeparator(); protected void setArraySeparator(String arraySeparator); protected String getContentStart(); protected void setContentStart(String contentStart); protected String getContentEnd(); protected void setContentEnd(String contentEnd); protected String getFieldNameValueSeparator(); protected void setFieldNameValueSeparator(String fieldNameValueSeparator); protected String getFieldSeparator(); protected void setFieldSeparator(String fieldSeparator); protected boolean isFieldSeparatorAtStart(); protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); protected boolean isFieldSeparatorAtEnd(); protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); protected String getNullText(); protected void setNullText(String nullText); protected String getSizeStartText(); protected void setSizeStartText(String sizeStartText); protected String getSizeEndText(); protected void setSizeEndText(String sizeEndText); protected String getSummaryObjectStartText(); protected void setSummaryObjectStartText(String summaryObjectStartText); protected String getSummaryObjectEndText(); protected void setSummaryObjectEndText(String summaryObjectEndText); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); long serialVersionUID=Optional[-2587890625525655916L]; ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; boolean useFieldNames=Optional[true]; boolean useClassName=Optional[true]; boolean useShortClassName=Optional[false]; boolean useIdentityHashCode=Optional[true]; String contentStart=Optional["["]; String contentEnd=Optional["]"]; String fieldNameValueSeparator=Optional["="]; boolean fieldSeparatorAtStart=Optional[false]; boolean fieldSeparatorAtEnd=Optional[false]; String fieldSeparator=Optional[","]; String arrayStart=Optional["{"]; String arraySeparator=Optional[","]; boolean arrayContentDetail=Optional[true]; String arrayEnd=Optional["}
public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail) { [EOL]     appendFieldStart(buffer, fieldName); [EOL]     if (array == null) { [EOL]         appendNullText(buffer, fieldName); [EOL]     } else if (isFullDetail(fullDetail)) { [EOL]         appendDetail(buffer, fieldName, array); [EOL]     } else { [EOL]         appendSummary(buffer, fieldName, array); [EOL]     } [EOL]     appendFieldEnd(buffer, fieldName); [EOL] } protected ToStringStyle();  DefaultToStringStyle();  NoFieldNameToStringStyle();  ShortPrefixToStringStyle();  SimpleToStringStyle();  MultiLineToStringStyle();  static Map<Object, Object> getRegistry();  static boolean isRegistered(final Object value);  static void register(final Object value);  static void unregister(final Object value); public void appendSuper(final StringBuffer buffer, final String superToString); public void appendToString(final StringBuffer buffer, final String toString); public void appendStart(final StringBuffer buffer, final Object object); public void appendEnd(final StringBuffer buffer, final Object object); protected void removeLastFieldSeparator(final StringBuffer buffer); public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); public void append(final StringBuffer buffer, final String fieldName, final long value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); public void append(final StringBuffer buffer, final String fieldName, final int value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); public void append(final StringBuffer buffer, final String fieldName, final short value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); public void append(final StringBuffer buffer, final String fieldName, final byte value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); public void append(final StringBuffer buffer, final String fieldName, final char value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); public void append(final StringBuffer buffer, final String fieldName, final double value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); public void append(final StringBuffer buffer, final String fieldName, final float value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); public void append(final StringBuffer buffer, final String fieldName, final boolean value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendClassName(final StringBuffer buffer, final Object object); protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); protected void appendContentStart(final StringBuffer buffer); protected void appendContentEnd(final StringBuffer buffer); protected void appendNullText(final StringBuffer buffer, final String fieldName); protected void appendFieldSeparator(final StringBuffer buffer); protected void appendFieldStart(final StringBuffer buffer, final String fieldName); protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); protected boolean isFullDetail(final Boolean fullDetailRequest); protected String getShortClassName(final Class<?> cls); protected boolean isUseClassName(); protected void setUseClassName(final boolean useClassName); protected boolean isUseShortClassName(); protected void setUseShortClassName(final boolean useShortClassName); protected boolean isUseIdentityHashCode(); protected void setUseIdentityHashCode(final boolean useIdentityHashCode); protected boolean isUseFieldNames(); protected void setUseFieldNames(final boolean useFieldNames); protected boolean isDefaultFullDetail(); protected void setDefaultFullDetail(final boolean defaultFullDetail); protected boolean isArrayContentDetail(); protected void setArrayContentDetail(final boolean arrayContentDetail); protected String getArrayStart(); protected void setArrayStart(String arrayStart); protected String getArrayEnd(); protected void setArrayEnd(String arrayEnd); protected String getArraySeparator(); protected void setArraySeparator(String arraySeparator); protected String getContentStart(); protected void setContentStart(String contentStart); protected String getContentEnd(); protected void setContentEnd(String contentEnd); protected String getFieldNameValueSeparator(); protected void setFieldNameValueSeparator(String fieldNameValueSeparator); protected String getFieldSeparator(); protected void setFieldSeparator(String fieldSeparator); protected boolean isFieldSeparatorAtStart(); protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); protected boolean isFieldSeparatorAtEnd(); protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); protected String getNullText(); protected void setNullText(String nullText); protected String getSizeStartText(); protected void setSizeStartText(String sizeStartText); protected String getSizeEndText(); protected void setSizeEndText(String sizeEndText); protected String getSummaryObjectStartText(); protected void setSummaryObjectStartText(String summaryObjectStartText); protected String getSummaryObjectEndText(); protected void setSummaryObjectEndText(String summaryObjectEndText); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); long serialVersionUID=Optional[-2587890625525655916L]; ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; boolean useFieldNames=Optional[true]; boolean useClassName=Optional[true]; boolean useShortClassName=Optional[false]; boolean useIdentityHashCode=Optional[true]; String contentStart=Optional["["]; String contentEnd=Optional["]"]; String fieldNameValueSeparator=Optional["="]; boolean fieldSeparatorAtStart=Optional[false]; boolean fieldSeparatorAtEnd=Optional[false]; String fieldSeparator=Optional[","]; String arrayStart=Optional["{"]; String arraySeparator=Optional[","]; boolean arrayContentDetail=Optional[true]; String arrayEnd=Optional["}
protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array) { [EOL]     buffer.append(arrayStart); [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         if (i > 0) { [EOL]             buffer.append(arraySeparator); [EOL]         } [EOL]         appendDetail(buffer, fieldName, array[i]); [EOL]     } [EOL]     buffer.append(arrayEnd); [EOL] } protected ToStringStyle();  DefaultToStringStyle();  NoFieldNameToStringStyle();  ShortPrefixToStringStyle();  SimpleToStringStyle();  MultiLineToStringStyle();  static Map<Object, Object> getRegistry();  static boolean isRegistered(final Object value);  static void register(final Object value);  static void unregister(final Object value); public void appendSuper(final StringBuffer buffer, final String superToString); public void appendToString(final StringBuffer buffer, final String toString); public void appendStart(final StringBuffer buffer, final Object object); public void appendEnd(final StringBuffer buffer, final Object object); protected void removeLastFieldSeparator(final StringBuffer buffer); public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); public void append(final StringBuffer buffer, final String fieldName, final long value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); public void append(final StringBuffer buffer, final String fieldName, final int value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); public void append(final StringBuffer buffer, final String fieldName, final short value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); public void append(final StringBuffer buffer, final String fieldName, final byte value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); public void append(final StringBuffer buffer, final String fieldName, final char value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); public void append(final StringBuffer buffer, final String fieldName, final double value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); public void append(final StringBuffer buffer, final String fieldName, final float value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); public void append(final StringBuffer buffer, final String fieldName, final boolean value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendClassName(final StringBuffer buffer, final Object object); protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); protected void appendContentStart(final StringBuffer buffer); protected void appendContentEnd(final StringBuffer buffer); protected void appendNullText(final StringBuffer buffer, final String fieldName); protected void appendFieldSeparator(final StringBuffer buffer); protected void appendFieldStart(final StringBuffer buffer, final String fieldName); protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); protected boolean isFullDetail(final Boolean fullDetailRequest); protected String getShortClassName(final Class<?> cls); protected boolean isUseClassName(); protected void setUseClassName(final boolean useClassName); protected boolean isUseShortClassName(); protected void setUseShortClassName(final boolean useShortClassName); protected boolean isUseIdentityHashCode(); protected void setUseIdentityHashCode(final boolean useIdentityHashCode); protected boolean isUseFieldNames(); protected void setUseFieldNames(final boolean useFieldNames); protected boolean isDefaultFullDetail(); protected void setDefaultFullDetail(final boolean defaultFullDetail); protected boolean isArrayContentDetail(); protected void setArrayContentDetail(final boolean arrayContentDetail); protected String getArrayStart(); protected void setArrayStart(String arrayStart); protected String getArrayEnd(); protected void setArrayEnd(String arrayEnd); protected String getArraySeparator(); protected void setArraySeparator(String arraySeparator); protected String getContentStart(); protected void setContentStart(String contentStart); protected String getContentEnd(); protected void setContentEnd(String contentEnd); protected String getFieldNameValueSeparator(); protected void setFieldNameValueSeparator(String fieldNameValueSeparator); protected String getFieldSeparator(); protected void setFieldSeparator(String fieldSeparator); protected boolean isFieldSeparatorAtStart(); protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); protected boolean isFieldSeparatorAtEnd(); protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); protected String getNullText(); protected void setNullText(String nullText); protected String getSizeStartText(); protected void setSizeStartText(String sizeStartText); protected String getSizeEndText(); protected void setSizeEndText(String sizeEndText); protected String getSummaryObjectStartText(); protected void setSummaryObjectStartText(String summaryObjectStartText); protected String getSummaryObjectEndText(); protected void setSummaryObjectEndText(String summaryObjectEndText); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); long serialVersionUID=Optional[-2587890625525655916L]; ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; boolean useFieldNames=Optional[true]; boolean useClassName=Optional[true]; boolean useShortClassName=Optional[false]; boolean useIdentityHashCode=Optional[true]; String contentStart=Optional["["]; String contentEnd=Optional["]"]; String fieldNameValueSeparator=Optional["="]; boolean fieldSeparatorAtStart=Optional[false]; boolean fieldSeparatorAtEnd=Optional[false]; String fieldSeparator=Optional[","]; String arrayStart=Optional["{"]; String arraySeparator=Optional[","]; boolean arrayContentDetail=Optional[true]; String arrayEnd=Optional["}
protected void setUseClassName(final boolean useClassName) { [EOL]     this.useClassName = useClassName; [EOL] } protected ToStringStyle();  DefaultToStringStyle();  NoFieldNameToStringStyle();  ShortPrefixToStringStyle();  SimpleToStringStyle();  MultiLineToStringStyle();  static Map<Object, Object> getRegistry();  static boolean isRegistered(final Object value);  static void register(final Object value);  static void unregister(final Object value); public void appendSuper(final StringBuffer buffer, final String superToString); public void appendToString(final StringBuffer buffer, final String toString); public void appendStart(final StringBuffer buffer, final Object object); public void appendEnd(final StringBuffer buffer, final Object object); protected void removeLastFieldSeparator(final StringBuffer buffer); public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); public void append(final StringBuffer buffer, final String fieldName, final long value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); public void append(final StringBuffer buffer, final String fieldName, final int value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); public void append(final StringBuffer buffer, final String fieldName, final short value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); public void append(final StringBuffer buffer, final String fieldName, final byte value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); public void append(final StringBuffer buffer, final String fieldName, final char value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); public void append(final StringBuffer buffer, final String fieldName, final double value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); public void append(final StringBuffer buffer, final String fieldName, final float value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); public void append(final StringBuffer buffer, final String fieldName, final boolean value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendClassName(final StringBuffer buffer, final Object object); protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); protected void appendContentStart(final StringBuffer buffer); protected void appendContentEnd(final StringBuffer buffer); protected void appendNullText(final StringBuffer buffer, final String fieldName); protected void appendFieldSeparator(final StringBuffer buffer); protected void appendFieldStart(final StringBuffer buffer, final String fieldName); protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); protected boolean isFullDetail(final Boolean fullDetailRequest); protected String getShortClassName(final Class<?> cls); protected boolean isUseClassName(); protected void setUseClassName(final boolean useClassName); protected boolean isUseShortClassName(); protected void setUseShortClassName(final boolean useShortClassName); protected boolean isUseIdentityHashCode(); protected void setUseIdentityHashCode(final boolean useIdentityHashCode); protected boolean isUseFieldNames(); protected void setUseFieldNames(final boolean useFieldNames); protected boolean isDefaultFullDetail(); protected void setDefaultFullDetail(final boolean defaultFullDetail); protected boolean isArrayContentDetail(); protected void setArrayContentDetail(final boolean arrayContentDetail); protected String getArrayStart(); protected void setArrayStart(String arrayStart); protected String getArrayEnd(); protected void setArrayEnd(String arrayEnd); protected String getArraySeparator(); protected void setArraySeparator(String arraySeparator); protected String getContentStart(); protected void setContentStart(String contentStart); protected String getContentEnd(); protected void setContentEnd(String contentEnd); protected String getFieldNameValueSeparator(); protected void setFieldNameValueSeparator(String fieldNameValueSeparator); protected String getFieldSeparator(); protected void setFieldSeparator(String fieldSeparator); protected boolean isFieldSeparatorAtStart(); protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); protected boolean isFieldSeparatorAtEnd(); protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); protected String getNullText(); protected void setNullText(String nullText); protected String getSizeStartText(); protected void setSizeStartText(String sizeStartText); protected String getSizeEndText(); protected void setSizeEndText(String sizeEndText); protected String getSummaryObjectStartText(); protected void setSummaryObjectStartText(String summaryObjectStartText); protected String getSummaryObjectEndText(); protected void setSummaryObjectEndText(String summaryObjectEndText); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); long serialVersionUID=Optional[-2587890625525655916L]; ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; boolean useFieldNames=Optional[true]; boolean useClassName=Optional[true]; boolean useShortClassName=Optional[false]; boolean useIdentityHashCode=Optional[true]; String contentStart=Optional["["]; String contentEnd=Optional["]"]; String fieldNameValueSeparator=Optional["="]; boolean fieldSeparatorAtStart=Optional[false]; boolean fieldSeparatorAtEnd=Optional[false]; String fieldSeparator=Optional[","]; String arrayStart=Optional["{"]; String arraySeparator=Optional[","]; boolean arrayContentDetail=Optional[true]; String arrayEnd=Optional["}
protected void setUseShortClassName(final boolean useShortClassName) { [EOL]     this.useShortClassName = useShortClassName; [EOL] } protected ToStringStyle();  DefaultToStringStyle();  NoFieldNameToStringStyle();  ShortPrefixToStringStyle();  SimpleToStringStyle();  MultiLineToStringStyle();  static Map<Object, Object> getRegistry();  static boolean isRegistered(final Object value);  static void register(final Object value);  static void unregister(final Object value); public void appendSuper(final StringBuffer buffer, final String superToString); public void appendToString(final StringBuffer buffer, final String toString); public void appendStart(final StringBuffer buffer, final Object object); public void appendEnd(final StringBuffer buffer, final Object object); protected void removeLastFieldSeparator(final StringBuffer buffer); public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); public void append(final StringBuffer buffer, final String fieldName, final long value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); public void append(final StringBuffer buffer, final String fieldName, final int value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); public void append(final StringBuffer buffer, final String fieldName, final short value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); public void append(final StringBuffer buffer, final String fieldName, final byte value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); public void append(final StringBuffer buffer, final String fieldName, final char value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); public void append(final StringBuffer buffer, final String fieldName, final double value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); public void append(final StringBuffer buffer, final String fieldName, final float value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); public void append(final StringBuffer buffer, final String fieldName, final boolean value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendClassName(final StringBuffer buffer, final Object object); protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); protected void appendContentStart(final StringBuffer buffer); protected void appendContentEnd(final StringBuffer buffer); protected void appendNullText(final StringBuffer buffer, final String fieldName); protected void appendFieldSeparator(final StringBuffer buffer); protected void appendFieldStart(final StringBuffer buffer, final String fieldName); protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); protected boolean isFullDetail(final Boolean fullDetailRequest); protected String getShortClassName(final Class<?> cls); protected boolean isUseClassName(); protected void setUseClassName(final boolean useClassName); protected boolean isUseShortClassName(); protected void setUseShortClassName(final boolean useShortClassName); protected boolean isUseIdentityHashCode(); protected void setUseIdentityHashCode(final boolean useIdentityHashCode); protected boolean isUseFieldNames(); protected void setUseFieldNames(final boolean useFieldNames); protected boolean isDefaultFullDetail(); protected void setDefaultFullDetail(final boolean defaultFullDetail); protected boolean isArrayContentDetail(); protected void setArrayContentDetail(final boolean arrayContentDetail); protected String getArrayStart(); protected void setArrayStart(String arrayStart); protected String getArrayEnd(); protected void setArrayEnd(String arrayEnd); protected String getArraySeparator(); protected void setArraySeparator(String arraySeparator); protected String getContentStart(); protected void setContentStart(String contentStart); protected String getContentEnd(); protected void setContentEnd(String contentEnd); protected String getFieldNameValueSeparator(); protected void setFieldNameValueSeparator(String fieldNameValueSeparator); protected String getFieldSeparator(); protected void setFieldSeparator(String fieldSeparator); protected boolean isFieldSeparatorAtStart(); protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); protected boolean isFieldSeparatorAtEnd(); protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); protected String getNullText(); protected void setNullText(String nullText); protected String getSizeStartText(); protected void setSizeStartText(String sizeStartText); protected String getSizeEndText(); protected void setSizeEndText(String sizeEndText); protected String getSummaryObjectStartText(); protected void setSummaryObjectStartText(String summaryObjectStartText); protected String getSummaryObjectEndText(); protected void setSummaryObjectEndText(String summaryObjectEndText); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); long serialVersionUID=Optional[-2587890625525655916L]; ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; boolean useFieldNames=Optional[true]; boolean useClassName=Optional[true]; boolean useShortClassName=Optional[false]; boolean useIdentityHashCode=Optional[true]; String contentStart=Optional["["]; String contentEnd=Optional["]"]; String fieldNameValueSeparator=Optional["="]; boolean fieldSeparatorAtStart=Optional[false]; boolean fieldSeparatorAtEnd=Optional[false]; String fieldSeparator=Optional[","]; String arrayStart=Optional["{"]; String arraySeparator=Optional[","]; boolean arrayContentDetail=Optional[true]; String arrayEnd=Optional["}
protected void setUseIdentityHashCode(final boolean useIdentityHashCode) { [EOL]     this.useIdentityHashCode = useIdentityHashCode; [EOL] } protected ToStringStyle();  DefaultToStringStyle();  NoFieldNameToStringStyle();  ShortPrefixToStringStyle();  SimpleToStringStyle();  MultiLineToStringStyle();  static Map<Object, Object> getRegistry();  static boolean isRegistered(final Object value);  static void register(final Object value);  static void unregister(final Object value); public void appendSuper(final StringBuffer buffer, final String superToString); public void appendToString(final StringBuffer buffer, final String toString); public void appendStart(final StringBuffer buffer, final Object object); public void appendEnd(final StringBuffer buffer, final Object object); protected void removeLastFieldSeparator(final StringBuffer buffer); public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); public void append(final StringBuffer buffer, final String fieldName, final long value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); public void append(final StringBuffer buffer, final String fieldName, final int value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); public void append(final StringBuffer buffer, final String fieldName, final short value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); public void append(final StringBuffer buffer, final String fieldName, final byte value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); public void append(final StringBuffer buffer, final String fieldName, final char value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); public void append(final StringBuffer buffer, final String fieldName, final double value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); public void append(final StringBuffer buffer, final String fieldName, final float value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); public void append(final StringBuffer buffer, final String fieldName, final boolean value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendClassName(final StringBuffer buffer, final Object object); protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); protected void appendContentStart(final StringBuffer buffer); protected void appendContentEnd(final StringBuffer buffer); protected void appendNullText(final StringBuffer buffer, final String fieldName); protected void appendFieldSeparator(final StringBuffer buffer); protected void appendFieldStart(final StringBuffer buffer, final String fieldName); protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); protected boolean isFullDetail(final Boolean fullDetailRequest); protected String getShortClassName(final Class<?> cls); protected boolean isUseClassName(); protected void setUseClassName(final boolean useClassName); protected boolean isUseShortClassName(); protected void setUseShortClassName(final boolean useShortClassName); protected boolean isUseIdentityHashCode(); protected void setUseIdentityHashCode(final boolean useIdentityHashCode); protected boolean isUseFieldNames(); protected void setUseFieldNames(final boolean useFieldNames); protected boolean isDefaultFullDetail(); protected void setDefaultFullDetail(final boolean defaultFullDetail); protected boolean isArrayContentDetail(); protected void setArrayContentDetail(final boolean arrayContentDetail); protected String getArrayStart(); protected void setArrayStart(String arrayStart); protected String getArrayEnd(); protected void setArrayEnd(String arrayEnd); protected String getArraySeparator(); protected void setArraySeparator(String arraySeparator); protected String getContentStart(); protected void setContentStart(String contentStart); protected String getContentEnd(); protected void setContentEnd(String contentEnd); protected String getFieldNameValueSeparator(); protected void setFieldNameValueSeparator(String fieldNameValueSeparator); protected String getFieldSeparator(); protected void setFieldSeparator(String fieldSeparator); protected boolean isFieldSeparatorAtStart(); protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); protected boolean isFieldSeparatorAtEnd(); protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); protected String getNullText(); protected void setNullText(String nullText); protected String getSizeStartText(); protected void setSizeStartText(String sizeStartText); protected String getSizeEndText(); protected void setSizeEndText(String sizeEndText); protected String getSummaryObjectStartText(); protected void setSummaryObjectStartText(String summaryObjectStartText); protected String getSummaryObjectEndText(); protected void setSummaryObjectEndText(String summaryObjectEndText); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); long serialVersionUID=Optional[-2587890625525655916L]; ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; boolean useFieldNames=Optional[true]; boolean useClassName=Optional[true]; boolean useShortClassName=Optional[false]; boolean useIdentityHashCode=Optional[true]; String contentStart=Optional["["]; String contentEnd=Optional["]"]; String fieldNameValueSeparator=Optional["="]; boolean fieldSeparatorAtStart=Optional[false]; boolean fieldSeparatorAtEnd=Optional[false]; String fieldSeparator=Optional[","]; String arrayStart=Optional["{"]; String arraySeparator=Optional[","]; boolean arrayContentDetail=Optional[true]; String arrayEnd=Optional["}
protected void setDefaultFullDetail(final boolean defaultFullDetail) { [EOL]     this.defaultFullDetail = defaultFullDetail; [EOL] } protected ToStringStyle();  DefaultToStringStyle();  NoFieldNameToStringStyle();  ShortPrefixToStringStyle();  SimpleToStringStyle();  MultiLineToStringStyle();  static Map<Object, Object> getRegistry();  static boolean isRegistered(final Object value);  static void register(final Object value);  static void unregister(final Object value); public void appendSuper(final StringBuffer buffer, final String superToString); public void appendToString(final StringBuffer buffer, final String toString); public void appendStart(final StringBuffer buffer, final Object object); public void appendEnd(final StringBuffer buffer, final Object object); protected void removeLastFieldSeparator(final StringBuffer buffer); public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); public void append(final StringBuffer buffer, final String fieldName, final long value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); public void append(final StringBuffer buffer, final String fieldName, final int value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); public void append(final StringBuffer buffer, final String fieldName, final short value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); public void append(final StringBuffer buffer, final String fieldName, final byte value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); public void append(final StringBuffer buffer, final String fieldName, final char value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); public void append(final StringBuffer buffer, final String fieldName, final double value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); public void append(final StringBuffer buffer, final String fieldName, final float value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); public void append(final StringBuffer buffer, final String fieldName, final boolean value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendClassName(final StringBuffer buffer, final Object object); protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); protected void appendContentStart(final StringBuffer buffer); protected void appendContentEnd(final StringBuffer buffer); protected void appendNullText(final StringBuffer buffer, final String fieldName); protected void appendFieldSeparator(final StringBuffer buffer); protected void appendFieldStart(final StringBuffer buffer, final String fieldName); protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); protected boolean isFullDetail(final Boolean fullDetailRequest); protected String getShortClassName(final Class<?> cls); protected boolean isUseClassName(); protected void setUseClassName(final boolean useClassName); protected boolean isUseShortClassName(); protected void setUseShortClassName(final boolean useShortClassName); protected boolean isUseIdentityHashCode(); protected void setUseIdentityHashCode(final boolean useIdentityHashCode); protected boolean isUseFieldNames(); protected void setUseFieldNames(final boolean useFieldNames); protected boolean isDefaultFullDetail(); protected void setDefaultFullDetail(final boolean defaultFullDetail); protected boolean isArrayContentDetail(); protected void setArrayContentDetail(final boolean arrayContentDetail); protected String getArrayStart(); protected void setArrayStart(String arrayStart); protected String getArrayEnd(); protected void setArrayEnd(String arrayEnd); protected String getArraySeparator(); protected void setArraySeparator(String arraySeparator); protected String getContentStart(); protected void setContentStart(String contentStart); protected String getContentEnd(); protected void setContentEnd(String contentEnd); protected String getFieldNameValueSeparator(); protected void setFieldNameValueSeparator(String fieldNameValueSeparator); protected String getFieldSeparator(); protected void setFieldSeparator(String fieldSeparator); protected boolean isFieldSeparatorAtStart(); protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); protected boolean isFieldSeparatorAtEnd(); protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); protected String getNullText(); protected void setNullText(String nullText); protected String getSizeStartText(); protected void setSizeStartText(String sizeStartText); protected String getSizeEndText(); protected void setSizeEndText(String sizeEndText); protected String getSummaryObjectStartText(); protected void setSummaryObjectStartText(String summaryObjectStartText); protected String getSummaryObjectEndText(); protected void setSummaryObjectEndText(String summaryObjectEndText); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); long serialVersionUID=Optional[-2587890625525655916L]; ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; boolean useFieldNames=Optional[true]; boolean useClassName=Optional[true]; boolean useShortClassName=Optional[false]; boolean useIdentityHashCode=Optional[true]; String contentStart=Optional["["]; String contentEnd=Optional["]"]; String fieldNameValueSeparator=Optional["="]; boolean fieldSeparatorAtStart=Optional[false]; boolean fieldSeparatorAtEnd=Optional[false]; String fieldSeparator=Optional[","]; String arrayStart=Optional["{"]; String arraySeparator=Optional[","]; boolean arrayContentDetail=Optional[true]; String arrayEnd=Optional["}
protected void setDefaultFullDetail(final boolean defaultFullDetail) { [EOL]     this.defaultFullDetail = defaultFullDetail; [EOL] } protected ToStringStyle();  DefaultToStringStyle();  NoFieldNameToStringStyle();  ShortPrefixToStringStyle();  SimpleToStringStyle();  MultiLineToStringStyle();  static Map<Object, Object> getRegistry();  static boolean isRegistered(final Object value);  static void register(final Object value);  static void unregister(final Object value); public void appendSuper(final StringBuffer buffer, final String superToString); public void appendToString(final StringBuffer buffer, final String toString); public void appendStart(final StringBuffer buffer, final Object object); public void appendEnd(final StringBuffer buffer, final Object object); protected void removeLastFieldSeparator(final StringBuffer buffer); public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); public void append(final StringBuffer buffer, final String fieldName, final long value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); public void append(final StringBuffer buffer, final String fieldName, final int value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); public void append(final StringBuffer buffer, final String fieldName, final short value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); public void append(final StringBuffer buffer, final String fieldName, final byte value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); public void append(final StringBuffer buffer, final String fieldName, final char value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); public void append(final StringBuffer buffer, final String fieldName, final double value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); public void append(final StringBuffer buffer, final String fieldName, final float value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); public void append(final StringBuffer buffer, final String fieldName, final boolean value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendClassName(final StringBuffer buffer, final Object object); protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); protected void appendContentStart(final StringBuffer buffer); protected void appendContentEnd(final StringBuffer buffer); protected void appendNullText(final StringBuffer buffer, final String fieldName); protected void appendFieldSeparator(final StringBuffer buffer); protected void appendFieldStart(final StringBuffer buffer, final String fieldName); protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); protected boolean isFullDetail(final Boolean fullDetailRequest); protected String getShortClassName(final Class<?> cls); protected boolean isUseClassName(); protected void setUseClassName(final boolean useClassName); protected boolean isUseShortClassName(); protected void setUseShortClassName(final boolean useShortClassName); protected boolean isUseIdentityHashCode(); protected void setUseIdentityHashCode(final boolean useIdentityHashCode); protected boolean isUseFieldNames(); protected void setUseFieldNames(final boolean useFieldNames); protected boolean isDefaultFullDetail(); protected void setDefaultFullDetail(final boolean defaultFullDetail); protected boolean isArrayContentDetail(); protected void setArrayContentDetail(final boolean arrayContentDetail); protected String getArrayStart(); protected void setArrayStart(String arrayStart); protected String getArrayEnd(); protected void setArrayEnd(String arrayEnd); protected String getArraySeparator(); protected void setArraySeparator(String arraySeparator); protected String getContentStart(); protected void setContentStart(String contentStart); protected String getContentEnd(); protected void setContentEnd(String contentEnd); protected String getFieldNameValueSeparator(); protected void setFieldNameValueSeparator(String fieldNameValueSeparator); protected String getFieldSeparator(); protected void setFieldSeparator(String fieldSeparator); protected boolean isFieldSeparatorAtStart(); protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); protected boolean isFieldSeparatorAtEnd(); protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); protected String getNullText(); protected void setNullText(String nullText); protected String getSizeStartText(); protected void setSizeStartText(String sizeStartText); protected String getSizeEndText(); protected void setSizeEndText(String sizeEndText); protected String getSummaryObjectStartText(); protected void setSummaryObjectStartText(String summaryObjectStartText); protected String getSummaryObjectEndText(); protected void setSummaryObjectEndText(String summaryObjectEndText); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); long serialVersionUID=Optional[-2587890625525655916L]; ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; boolean useFieldNames=Optional[true]; boolean useClassName=Optional[true]; boolean useShortClassName=Optional[false]; boolean useIdentityHashCode=Optional[true]; String contentStart=Optional["["]; String contentEnd=Optional["]"]; String fieldNameValueSeparator=Optional["="]; boolean fieldSeparatorAtStart=Optional[false]; boolean fieldSeparatorAtEnd=Optional[false]; String fieldSeparator=Optional[","]; String arrayStart=Optional["{"]; String arraySeparator=Optional[","]; boolean arrayContentDetail=Optional[true]; String arrayEnd=Optional["}
protected void setArrayContentDetail(final boolean arrayContentDetail) { [EOL]     this.arrayContentDetail = arrayContentDetail; [EOL] } protected ToStringStyle();  DefaultToStringStyle();  NoFieldNameToStringStyle();  ShortPrefixToStringStyle();  SimpleToStringStyle();  MultiLineToStringStyle();  static Map<Object, Object> getRegistry();  static boolean isRegistered(final Object value);  static void register(final Object value);  static void unregister(final Object value); public void appendSuper(final StringBuffer buffer, final String superToString); public void appendToString(final StringBuffer buffer, final String toString); public void appendStart(final StringBuffer buffer, final Object object); public void appendEnd(final StringBuffer buffer, final Object object); protected void removeLastFieldSeparator(final StringBuffer buffer); public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); public void append(final StringBuffer buffer, final String fieldName, final long value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); public void append(final StringBuffer buffer, final String fieldName, final int value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); public void append(final StringBuffer buffer, final String fieldName, final short value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); public void append(final StringBuffer buffer, final String fieldName, final byte value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); public void append(final StringBuffer buffer, final String fieldName, final char value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); public void append(final StringBuffer buffer, final String fieldName, final double value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); public void append(final StringBuffer buffer, final String fieldName, final float value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); public void append(final StringBuffer buffer, final String fieldName, final boolean value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendClassName(final StringBuffer buffer, final Object object); protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); protected void appendContentStart(final StringBuffer buffer); protected void appendContentEnd(final StringBuffer buffer); protected void appendNullText(final StringBuffer buffer, final String fieldName); protected void appendFieldSeparator(final StringBuffer buffer); protected void appendFieldStart(final StringBuffer buffer, final String fieldName); protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); protected boolean isFullDetail(final Boolean fullDetailRequest); protected String getShortClassName(final Class<?> cls); protected boolean isUseClassName(); protected void setUseClassName(final boolean useClassName); protected boolean isUseShortClassName(); protected void setUseShortClassName(final boolean useShortClassName); protected boolean isUseIdentityHashCode(); protected void setUseIdentityHashCode(final boolean useIdentityHashCode); protected boolean isUseFieldNames(); protected void setUseFieldNames(final boolean useFieldNames); protected boolean isDefaultFullDetail(); protected void setDefaultFullDetail(final boolean defaultFullDetail); protected boolean isArrayContentDetail(); protected void setArrayContentDetail(final boolean arrayContentDetail); protected String getArrayStart(); protected void setArrayStart(String arrayStart); protected String getArrayEnd(); protected void setArrayEnd(String arrayEnd); protected String getArraySeparator(); protected void setArraySeparator(String arraySeparator); protected String getContentStart(); protected void setContentStart(String contentStart); protected String getContentEnd(); protected void setContentEnd(String contentEnd); protected String getFieldNameValueSeparator(); protected void setFieldNameValueSeparator(String fieldNameValueSeparator); protected String getFieldSeparator(); protected void setFieldSeparator(String fieldSeparator); protected boolean isFieldSeparatorAtStart(); protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); protected boolean isFieldSeparatorAtEnd(); protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); protected String getNullText(); protected void setNullText(String nullText); protected String getSizeStartText(); protected void setSizeStartText(String sizeStartText); protected String getSizeEndText(); protected void setSizeEndText(String sizeEndText); protected String getSummaryObjectStartText(); protected void setSummaryObjectStartText(String summaryObjectStartText); protected String getSummaryObjectEndText(); protected void setSummaryObjectEndText(String summaryObjectEndText); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); long serialVersionUID=Optional[-2587890625525655916L]; ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; boolean useFieldNames=Optional[true]; boolean useClassName=Optional[true]; boolean useShortClassName=Optional[false]; boolean useIdentityHashCode=Optional[true]; String contentStart=Optional["["]; String contentEnd=Optional["]"]; String fieldNameValueSeparator=Optional["="]; boolean fieldSeparatorAtStart=Optional[false]; boolean fieldSeparatorAtEnd=Optional[false]; String fieldSeparator=Optional[","]; String arrayStart=Optional["{"]; String arraySeparator=Optional[","]; boolean arrayContentDetail=Optional[true]; String arrayEnd=Optional["}
protected String getArrayStart() { [EOL]     return arrayStart; [EOL] } protected ToStringStyle();  DefaultToStringStyle();  NoFieldNameToStringStyle();  ShortPrefixToStringStyle();  SimpleToStringStyle();  MultiLineToStringStyle();  static Map<Object, Object> getRegistry();  static boolean isRegistered(final Object value);  static void register(final Object value);  static void unregister(final Object value); public void appendSuper(final StringBuffer buffer, final String superToString); public void appendToString(final StringBuffer buffer, final String toString); public void appendStart(final StringBuffer buffer, final Object object); public void appendEnd(final StringBuffer buffer, final Object object); protected void removeLastFieldSeparator(final StringBuffer buffer); public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); public void append(final StringBuffer buffer, final String fieldName, final long value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); public void append(final StringBuffer buffer, final String fieldName, final int value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); public void append(final StringBuffer buffer, final String fieldName, final short value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); public void append(final StringBuffer buffer, final String fieldName, final byte value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); public void append(final StringBuffer buffer, final String fieldName, final char value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); public void append(final StringBuffer buffer, final String fieldName, final double value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); public void append(final StringBuffer buffer, final String fieldName, final float value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); public void append(final StringBuffer buffer, final String fieldName, final boolean value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendClassName(final StringBuffer buffer, final Object object); protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); protected void appendContentStart(final StringBuffer buffer); protected void appendContentEnd(final StringBuffer buffer); protected void appendNullText(final StringBuffer buffer, final String fieldName); protected void appendFieldSeparator(final StringBuffer buffer); protected void appendFieldStart(final StringBuffer buffer, final String fieldName); protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); protected boolean isFullDetail(final Boolean fullDetailRequest); protected String getShortClassName(final Class<?> cls); protected boolean isUseClassName(); protected void setUseClassName(final boolean useClassName); protected boolean isUseShortClassName(); protected void setUseShortClassName(final boolean useShortClassName); protected boolean isUseIdentityHashCode(); protected void setUseIdentityHashCode(final boolean useIdentityHashCode); protected boolean isUseFieldNames(); protected void setUseFieldNames(final boolean useFieldNames); protected boolean isDefaultFullDetail(); protected void setDefaultFullDetail(final boolean defaultFullDetail); protected boolean isArrayContentDetail(); protected void setArrayContentDetail(final boolean arrayContentDetail); protected String getArrayStart(); protected void setArrayStart(String arrayStart); protected String getArrayEnd(); protected void setArrayEnd(String arrayEnd); protected String getArraySeparator(); protected void setArraySeparator(String arraySeparator); protected String getContentStart(); protected void setContentStart(String contentStart); protected String getContentEnd(); protected void setContentEnd(String contentEnd); protected String getFieldNameValueSeparator(); protected void setFieldNameValueSeparator(String fieldNameValueSeparator); protected String getFieldSeparator(); protected void setFieldSeparator(String fieldSeparator); protected boolean isFieldSeparatorAtStart(); protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); protected boolean isFieldSeparatorAtEnd(); protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); protected String getNullText(); protected void setNullText(String nullText); protected String getSizeStartText(); protected void setSizeStartText(String sizeStartText); protected String getSizeEndText(); protected void setSizeEndText(String sizeEndText); protected String getSummaryObjectStartText(); protected void setSummaryObjectStartText(String summaryObjectStartText); protected String getSummaryObjectEndText(); protected void setSummaryObjectEndText(String summaryObjectEndText); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); long serialVersionUID=Optional[-2587890625525655916L]; ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; boolean useFieldNames=Optional[true]; boolean useClassName=Optional[true]; boolean useShortClassName=Optional[false]; boolean useIdentityHashCode=Optional[true]; String contentStart=Optional["["]; String contentEnd=Optional["]"]; String fieldNameValueSeparator=Optional["="]; boolean fieldSeparatorAtStart=Optional[false]; boolean fieldSeparatorAtEnd=Optional[false]; String fieldSeparator=Optional[","]; String arrayStart=Optional["{"]; String arraySeparator=Optional[","]; boolean arrayContentDetail=Optional[true]; String arrayEnd=Optional["}
protected void setArrayStart(String arrayStart) { [EOL]     if (arrayStart == null) { [EOL]         arrayStart = ""; [EOL]     } [EOL]     this.arrayStart = arrayStart; [EOL] } protected ToStringStyle();  DefaultToStringStyle();  NoFieldNameToStringStyle();  ShortPrefixToStringStyle();  SimpleToStringStyle();  MultiLineToStringStyle();  static Map<Object, Object> getRegistry();  static boolean isRegistered(final Object value);  static void register(final Object value);  static void unregister(final Object value); public void appendSuper(final StringBuffer buffer, final String superToString); public void appendToString(final StringBuffer buffer, final String toString); public void appendStart(final StringBuffer buffer, final Object object); public void appendEnd(final StringBuffer buffer, final Object object); protected void removeLastFieldSeparator(final StringBuffer buffer); public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); public void append(final StringBuffer buffer, final String fieldName, final long value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); public void append(final StringBuffer buffer, final String fieldName, final int value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); public void append(final StringBuffer buffer, final String fieldName, final short value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); public void append(final StringBuffer buffer, final String fieldName, final byte value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); public void append(final StringBuffer buffer, final String fieldName, final char value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); public void append(final StringBuffer buffer, final String fieldName, final double value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); public void append(final StringBuffer buffer, final String fieldName, final float value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); public void append(final StringBuffer buffer, final String fieldName, final boolean value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendClassName(final StringBuffer buffer, final Object object); protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); protected void appendContentStart(final StringBuffer buffer); protected void appendContentEnd(final StringBuffer buffer); protected void appendNullText(final StringBuffer buffer, final String fieldName); protected void appendFieldSeparator(final StringBuffer buffer); protected void appendFieldStart(final StringBuffer buffer, final String fieldName); protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); protected boolean isFullDetail(final Boolean fullDetailRequest); protected String getShortClassName(final Class<?> cls); protected boolean isUseClassName(); protected void setUseClassName(final boolean useClassName); protected boolean isUseShortClassName(); protected void setUseShortClassName(final boolean useShortClassName); protected boolean isUseIdentityHashCode(); protected void setUseIdentityHashCode(final boolean useIdentityHashCode); protected boolean isUseFieldNames(); protected void setUseFieldNames(final boolean useFieldNames); protected boolean isDefaultFullDetail(); protected void setDefaultFullDetail(final boolean defaultFullDetail); protected boolean isArrayContentDetail(); protected void setArrayContentDetail(final boolean arrayContentDetail); protected String getArrayStart(); protected void setArrayStart(String arrayStart); protected String getArrayEnd(); protected void setArrayEnd(String arrayEnd); protected String getArraySeparator(); protected void setArraySeparator(String arraySeparator); protected String getContentStart(); protected void setContentStart(String contentStart); protected String getContentEnd(); protected void setContentEnd(String contentEnd); protected String getFieldNameValueSeparator(); protected void setFieldNameValueSeparator(String fieldNameValueSeparator); protected String getFieldSeparator(); protected void setFieldSeparator(String fieldSeparator); protected boolean isFieldSeparatorAtStart(); protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); protected boolean isFieldSeparatorAtEnd(); protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); protected String getNullText(); protected void setNullText(String nullText); protected String getSizeStartText(); protected void setSizeStartText(String sizeStartText); protected String getSizeEndText(); protected void setSizeEndText(String sizeEndText); protected String getSummaryObjectStartText(); protected void setSummaryObjectStartText(String summaryObjectStartText); protected String getSummaryObjectEndText(); protected void setSummaryObjectEndText(String summaryObjectEndText); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); long serialVersionUID=Optional[-2587890625525655916L]; ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; boolean useFieldNames=Optional[true]; boolean useClassName=Optional[true]; boolean useShortClassName=Optional[false]; boolean useIdentityHashCode=Optional[true]; String contentStart=Optional["["]; String contentEnd=Optional["]"]; String fieldNameValueSeparator=Optional["="]; boolean fieldSeparatorAtStart=Optional[false]; boolean fieldSeparatorAtEnd=Optional[false]; String fieldSeparator=Optional[","]; String arrayStart=Optional["{"]; String arraySeparator=Optional[","]; boolean arrayContentDetail=Optional[true]; String arrayEnd=Optional["}
protected void setArrayStart(String arrayStart) { [EOL]     if (arrayStart == null) { [EOL]         arrayStart = ""; [EOL]     } [EOL]     this.arrayStart = arrayStart; [EOL] } protected ToStringStyle();  DefaultToStringStyle();  NoFieldNameToStringStyle();  ShortPrefixToStringStyle();  SimpleToStringStyle();  MultiLineToStringStyle();  static Map<Object, Object> getRegistry();  static boolean isRegistered(final Object value);  static void register(final Object value);  static void unregister(final Object value); public void appendSuper(final StringBuffer buffer, final String superToString); public void appendToString(final StringBuffer buffer, final String toString); public void appendStart(final StringBuffer buffer, final Object object); public void appendEnd(final StringBuffer buffer, final Object object); protected void removeLastFieldSeparator(final StringBuffer buffer); public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); public void append(final StringBuffer buffer, final String fieldName, final long value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); public void append(final StringBuffer buffer, final String fieldName, final int value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); public void append(final StringBuffer buffer, final String fieldName, final short value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); public void append(final StringBuffer buffer, final String fieldName, final byte value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); public void append(final StringBuffer buffer, final String fieldName, final char value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); public void append(final StringBuffer buffer, final String fieldName, final double value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); public void append(final StringBuffer buffer, final String fieldName, final float value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); public void append(final StringBuffer buffer, final String fieldName, final boolean value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendClassName(final StringBuffer buffer, final Object object); protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); protected void appendContentStart(final StringBuffer buffer); protected void appendContentEnd(final StringBuffer buffer); protected void appendNullText(final StringBuffer buffer, final String fieldName); protected void appendFieldSeparator(final StringBuffer buffer); protected void appendFieldStart(final StringBuffer buffer, final String fieldName); protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); protected boolean isFullDetail(final Boolean fullDetailRequest); protected String getShortClassName(final Class<?> cls); protected boolean isUseClassName(); protected void setUseClassName(final boolean useClassName); protected boolean isUseShortClassName(); protected void setUseShortClassName(final boolean useShortClassName); protected boolean isUseIdentityHashCode(); protected void setUseIdentityHashCode(final boolean useIdentityHashCode); protected boolean isUseFieldNames(); protected void setUseFieldNames(final boolean useFieldNames); protected boolean isDefaultFullDetail(); protected void setDefaultFullDetail(final boolean defaultFullDetail); protected boolean isArrayContentDetail(); protected void setArrayContentDetail(final boolean arrayContentDetail); protected String getArrayStart(); protected void setArrayStart(String arrayStart); protected String getArrayEnd(); protected void setArrayEnd(String arrayEnd); protected String getArraySeparator(); protected void setArraySeparator(String arraySeparator); protected String getContentStart(); protected void setContentStart(String contentStart); protected String getContentEnd(); protected void setContentEnd(String contentEnd); protected String getFieldNameValueSeparator(); protected void setFieldNameValueSeparator(String fieldNameValueSeparator); protected String getFieldSeparator(); protected void setFieldSeparator(String fieldSeparator); protected boolean isFieldSeparatorAtStart(); protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); protected boolean isFieldSeparatorAtEnd(); protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); protected String getNullText(); protected void setNullText(String nullText); protected String getSizeStartText(); protected void setSizeStartText(String sizeStartText); protected String getSizeEndText(); protected void setSizeEndText(String sizeEndText); protected String getSummaryObjectStartText(); protected void setSummaryObjectStartText(String summaryObjectStartText); protected String getSummaryObjectEndText(); protected void setSummaryObjectEndText(String summaryObjectEndText); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); long serialVersionUID=Optional[-2587890625525655916L]; ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; boolean useFieldNames=Optional[true]; boolean useClassName=Optional[true]; boolean useShortClassName=Optional[false]; boolean useIdentityHashCode=Optional[true]; String contentStart=Optional["["]; String contentEnd=Optional["]"]; String fieldNameValueSeparator=Optional["="]; boolean fieldSeparatorAtStart=Optional[false]; boolean fieldSeparatorAtEnd=Optional[false]; String fieldSeparator=Optional[","]; String arrayStart=Optional["{"]; String arraySeparator=Optional[","]; boolean arrayContentDetail=Optional[true]; String arrayEnd=Optional["}
protected String getContentEnd() { [EOL]     return contentEnd; [EOL] } protected ToStringStyle();  DefaultToStringStyle();  NoFieldNameToStringStyle();  ShortPrefixToStringStyle();  SimpleToStringStyle();  MultiLineToStringStyle();  static Map<Object, Object> getRegistry();  static boolean isRegistered(final Object value);  static void register(final Object value);  static void unregister(final Object value); public void appendSuper(final StringBuffer buffer, final String superToString); public void appendToString(final StringBuffer buffer, final String toString); public void appendStart(final StringBuffer buffer, final Object object); public void appendEnd(final StringBuffer buffer, final Object object); protected void removeLastFieldSeparator(final StringBuffer buffer); public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); public void append(final StringBuffer buffer, final String fieldName, final long value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); public void append(final StringBuffer buffer, final String fieldName, final int value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); public void append(final StringBuffer buffer, final String fieldName, final short value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); public void append(final StringBuffer buffer, final String fieldName, final byte value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); public void append(final StringBuffer buffer, final String fieldName, final char value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); public void append(final StringBuffer buffer, final String fieldName, final double value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); public void append(final StringBuffer buffer, final String fieldName, final float value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); public void append(final StringBuffer buffer, final String fieldName, final boolean value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendClassName(final StringBuffer buffer, final Object object); protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); protected void appendContentStart(final StringBuffer buffer); protected void appendContentEnd(final StringBuffer buffer); protected void appendNullText(final StringBuffer buffer, final String fieldName); protected void appendFieldSeparator(final StringBuffer buffer); protected void appendFieldStart(final StringBuffer buffer, final String fieldName); protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); protected boolean isFullDetail(final Boolean fullDetailRequest); protected String getShortClassName(final Class<?> cls); protected boolean isUseClassName(); protected void setUseClassName(final boolean useClassName); protected boolean isUseShortClassName(); protected void setUseShortClassName(final boolean useShortClassName); protected boolean isUseIdentityHashCode(); protected void setUseIdentityHashCode(final boolean useIdentityHashCode); protected boolean isUseFieldNames(); protected void setUseFieldNames(final boolean useFieldNames); protected boolean isDefaultFullDetail(); protected void setDefaultFullDetail(final boolean defaultFullDetail); protected boolean isArrayContentDetail(); protected void setArrayContentDetail(final boolean arrayContentDetail); protected String getArrayStart(); protected void setArrayStart(String arrayStart); protected String getArrayEnd(); protected void setArrayEnd(String arrayEnd); protected String getArraySeparator(); protected void setArraySeparator(String arraySeparator); protected String getContentStart(); protected void setContentStart(String contentStart); protected String getContentEnd(); protected void setContentEnd(String contentEnd); protected String getFieldNameValueSeparator(); protected void setFieldNameValueSeparator(String fieldNameValueSeparator); protected String getFieldSeparator(); protected void setFieldSeparator(String fieldSeparator); protected boolean isFieldSeparatorAtStart(); protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); protected boolean isFieldSeparatorAtEnd(); protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); protected String getNullText(); protected void setNullText(String nullText); protected String getSizeStartText(); protected void setSizeStartText(String sizeStartText); protected String getSizeEndText(); protected void setSizeEndText(String sizeEndText); protected String getSummaryObjectStartText(); protected void setSummaryObjectStartText(String summaryObjectStartText); protected String getSummaryObjectEndText(); protected void setSummaryObjectEndText(String summaryObjectEndText); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); long serialVersionUID=Optional[-2587890625525655916L]; ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; boolean useFieldNames=Optional[true]; boolean useClassName=Optional[true]; boolean useShortClassName=Optional[false]; boolean useIdentityHashCode=Optional[true]; String contentStart=Optional["["]; String contentEnd=Optional["]"]; String fieldNameValueSeparator=Optional["="]; boolean fieldSeparatorAtStart=Optional[false]; boolean fieldSeparatorAtEnd=Optional[false]; String fieldSeparator=Optional[","]; String arrayStart=Optional["{"]; String arraySeparator=Optional[","]; boolean arrayContentDetail=Optional[true]; String arrayEnd=Optional["}
protected void setContentEnd(String contentEnd) { [EOL]     if (contentEnd == null) { [EOL]         contentEnd = ""; [EOL]     } [EOL]     this.contentEnd = contentEnd; [EOL] } protected ToStringStyle();  DefaultToStringStyle();  NoFieldNameToStringStyle();  ShortPrefixToStringStyle();  SimpleToStringStyle();  MultiLineToStringStyle();  static Map<Object, Object> getRegistry();  static boolean isRegistered(final Object value);  static void register(final Object value);  static void unregister(final Object value); public void appendSuper(final StringBuffer buffer, final String superToString); public void appendToString(final StringBuffer buffer, final String toString); public void appendStart(final StringBuffer buffer, final Object object); public void appendEnd(final StringBuffer buffer, final Object object); protected void removeLastFieldSeparator(final StringBuffer buffer); public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); public void append(final StringBuffer buffer, final String fieldName, final long value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); public void append(final StringBuffer buffer, final String fieldName, final int value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); public void append(final StringBuffer buffer, final String fieldName, final short value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); public void append(final StringBuffer buffer, final String fieldName, final byte value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); public void append(final StringBuffer buffer, final String fieldName, final char value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); public void append(final StringBuffer buffer, final String fieldName, final double value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); public void append(final StringBuffer buffer, final String fieldName, final float value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); public void append(final StringBuffer buffer, final String fieldName, final boolean value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendClassName(final StringBuffer buffer, final Object object); protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); protected void appendContentStart(final StringBuffer buffer); protected void appendContentEnd(final StringBuffer buffer); protected void appendNullText(final StringBuffer buffer, final String fieldName); protected void appendFieldSeparator(final StringBuffer buffer); protected void appendFieldStart(final StringBuffer buffer, final String fieldName); protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); protected boolean isFullDetail(final Boolean fullDetailRequest); protected String getShortClassName(final Class<?> cls); protected boolean isUseClassName(); protected void setUseClassName(final boolean useClassName); protected boolean isUseShortClassName(); protected void setUseShortClassName(final boolean useShortClassName); protected boolean isUseIdentityHashCode(); protected void setUseIdentityHashCode(final boolean useIdentityHashCode); protected boolean isUseFieldNames(); protected void setUseFieldNames(final boolean useFieldNames); protected boolean isDefaultFullDetail(); protected void setDefaultFullDetail(final boolean defaultFullDetail); protected boolean isArrayContentDetail(); protected void setArrayContentDetail(final boolean arrayContentDetail); protected String getArrayStart(); protected void setArrayStart(String arrayStart); protected String getArrayEnd(); protected void setArrayEnd(String arrayEnd); protected String getArraySeparator(); protected void setArraySeparator(String arraySeparator); protected String getContentStart(); protected void setContentStart(String contentStart); protected String getContentEnd(); protected void setContentEnd(String contentEnd); protected String getFieldNameValueSeparator(); protected void setFieldNameValueSeparator(String fieldNameValueSeparator); protected String getFieldSeparator(); protected void setFieldSeparator(String fieldSeparator); protected boolean isFieldSeparatorAtStart(); protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); protected boolean isFieldSeparatorAtEnd(); protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); protected String getNullText(); protected void setNullText(String nullText); protected String getSizeStartText(); protected void setSizeStartText(String sizeStartText); protected String getSizeEndText(); protected void setSizeEndText(String sizeEndText); protected String getSummaryObjectStartText(); protected void setSummaryObjectStartText(String summaryObjectStartText); protected String getSummaryObjectEndText(); protected void setSummaryObjectEndText(String summaryObjectEndText); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); long serialVersionUID=Optional[-2587890625525655916L]; ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; boolean useFieldNames=Optional[true]; boolean useClassName=Optional[true]; boolean useShortClassName=Optional[false]; boolean useIdentityHashCode=Optional[true]; String contentStart=Optional["["]; String contentEnd=Optional["]"]; String fieldNameValueSeparator=Optional["="]; boolean fieldSeparatorAtStart=Optional[false]; boolean fieldSeparatorAtEnd=Optional[false]; String fieldSeparator=Optional[","]; String arrayStart=Optional["{"]; String arraySeparator=Optional[","]; boolean arrayContentDetail=Optional[true]; String arrayEnd=Optional["}
protected String getFieldNameValueSeparator() { [EOL]     return fieldNameValueSeparator; [EOL] } protected ToStringStyle();  DefaultToStringStyle();  NoFieldNameToStringStyle();  ShortPrefixToStringStyle();  SimpleToStringStyle();  MultiLineToStringStyle();  static Map<Object, Object> getRegistry();  static boolean isRegistered(final Object value);  static void register(final Object value);  static void unregister(final Object value); public void appendSuper(final StringBuffer buffer, final String superToString); public void appendToString(final StringBuffer buffer, final String toString); public void appendStart(final StringBuffer buffer, final Object object); public void appendEnd(final StringBuffer buffer, final Object object); protected void removeLastFieldSeparator(final StringBuffer buffer); public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); public void append(final StringBuffer buffer, final String fieldName, final long value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); public void append(final StringBuffer buffer, final String fieldName, final int value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); public void append(final StringBuffer buffer, final String fieldName, final short value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); public void append(final StringBuffer buffer, final String fieldName, final byte value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); public void append(final StringBuffer buffer, final String fieldName, final char value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); public void append(final StringBuffer buffer, final String fieldName, final double value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); public void append(final StringBuffer buffer, final String fieldName, final float value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); public void append(final StringBuffer buffer, final String fieldName, final boolean value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendClassName(final StringBuffer buffer, final Object object); protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); protected void appendContentStart(final StringBuffer buffer); protected void appendContentEnd(final StringBuffer buffer); protected void appendNullText(final StringBuffer buffer, final String fieldName); protected void appendFieldSeparator(final StringBuffer buffer); protected void appendFieldStart(final StringBuffer buffer, final String fieldName); protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); protected boolean isFullDetail(final Boolean fullDetailRequest); protected String getShortClassName(final Class<?> cls); protected boolean isUseClassName(); protected void setUseClassName(final boolean useClassName); protected boolean isUseShortClassName(); protected void setUseShortClassName(final boolean useShortClassName); protected boolean isUseIdentityHashCode(); protected void setUseIdentityHashCode(final boolean useIdentityHashCode); protected boolean isUseFieldNames(); protected void setUseFieldNames(final boolean useFieldNames); protected boolean isDefaultFullDetail(); protected void setDefaultFullDetail(final boolean defaultFullDetail); protected boolean isArrayContentDetail(); protected void setArrayContentDetail(final boolean arrayContentDetail); protected String getArrayStart(); protected void setArrayStart(String arrayStart); protected String getArrayEnd(); protected void setArrayEnd(String arrayEnd); protected String getArraySeparator(); protected void setArraySeparator(String arraySeparator); protected String getContentStart(); protected void setContentStart(String contentStart); protected String getContentEnd(); protected void setContentEnd(String contentEnd); protected String getFieldNameValueSeparator(); protected void setFieldNameValueSeparator(String fieldNameValueSeparator); protected String getFieldSeparator(); protected void setFieldSeparator(String fieldSeparator); protected boolean isFieldSeparatorAtStart(); protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); protected boolean isFieldSeparatorAtEnd(); protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); protected String getNullText(); protected void setNullText(String nullText); protected String getSizeStartText(); protected void setSizeStartText(String sizeStartText); protected String getSizeEndText(); protected void setSizeEndText(String sizeEndText); protected String getSummaryObjectStartText(); protected void setSummaryObjectStartText(String summaryObjectStartText); protected String getSummaryObjectEndText(); protected void setSummaryObjectEndText(String summaryObjectEndText); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); long serialVersionUID=Optional[-2587890625525655916L]; ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; boolean useFieldNames=Optional[true]; boolean useClassName=Optional[true]; boolean useShortClassName=Optional[false]; boolean useIdentityHashCode=Optional[true]; String contentStart=Optional["["]; String contentEnd=Optional["]"]; String fieldNameValueSeparator=Optional["="]; boolean fieldSeparatorAtStart=Optional[false]; boolean fieldSeparatorAtEnd=Optional[false]; String fieldSeparator=Optional[","]; String arrayStart=Optional["{"]; String arraySeparator=Optional[","]; boolean arrayContentDetail=Optional[true]; String arrayEnd=Optional["}
protected void setFieldNameValueSeparator(String fieldNameValueSeparator) { [EOL]     if (fieldNameValueSeparator == null) { [EOL]         fieldNameValueSeparator = ""; [EOL]     } [EOL]     this.fieldNameValueSeparator = fieldNameValueSeparator; [EOL] } protected ToStringStyle();  DefaultToStringStyle();  NoFieldNameToStringStyle();  ShortPrefixToStringStyle();  SimpleToStringStyle();  MultiLineToStringStyle();  static Map<Object, Object> getRegistry();  static boolean isRegistered(final Object value);  static void register(final Object value);  static void unregister(final Object value); public void appendSuper(final StringBuffer buffer, final String superToString); public void appendToString(final StringBuffer buffer, final String toString); public void appendStart(final StringBuffer buffer, final Object object); public void appendEnd(final StringBuffer buffer, final Object object); protected void removeLastFieldSeparator(final StringBuffer buffer); public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); public void append(final StringBuffer buffer, final String fieldName, final long value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); public void append(final StringBuffer buffer, final String fieldName, final int value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); public void append(final StringBuffer buffer, final String fieldName, final short value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); public void append(final StringBuffer buffer, final String fieldName, final byte value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); public void append(final StringBuffer buffer, final String fieldName, final char value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); public void append(final StringBuffer buffer, final String fieldName, final double value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); public void append(final StringBuffer buffer, final String fieldName, final float value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); public void append(final StringBuffer buffer, final String fieldName, final boolean value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendClassName(final StringBuffer buffer, final Object object); protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); protected void appendContentStart(final StringBuffer buffer); protected void appendContentEnd(final StringBuffer buffer); protected void appendNullText(final StringBuffer buffer, final String fieldName); protected void appendFieldSeparator(final StringBuffer buffer); protected void appendFieldStart(final StringBuffer buffer, final String fieldName); protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); protected boolean isFullDetail(final Boolean fullDetailRequest); protected String getShortClassName(final Class<?> cls); protected boolean isUseClassName(); protected void setUseClassName(final boolean useClassName); protected boolean isUseShortClassName(); protected void setUseShortClassName(final boolean useShortClassName); protected boolean isUseIdentityHashCode(); protected void setUseIdentityHashCode(final boolean useIdentityHashCode); protected boolean isUseFieldNames(); protected void setUseFieldNames(final boolean useFieldNames); protected boolean isDefaultFullDetail(); protected void setDefaultFullDetail(final boolean defaultFullDetail); protected boolean isArrayContentDetail(); protected void setArrayContentDetail(final boolean arrayContentDetail); protected String getArrayStart(); protected void setArrayStart(String arrayStart); protected String getArrayEnd(); protected void setArrayEnd(String arrayEnd); protected String getArraySeparator(); protected void setArraySeparator(String arraySeparator); protected String getContentStart(); protected void setContentStart(String contentStart); protected String getContentEnd(); protected void setContentEnd(String contentEnd); protected String getFieldNameValueSeparator(); protected void setFieldNameValueSeparator(String fieldNameValueSeparator); protected String getFieldSeparator(); protected void setFieldSeparator(String fieldSeparator); protected boolean isFieldSeparatorAtStart(); protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); protected boolean isFieldSeparatorAtEnd(); protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); protected String getNullText(); protected void setNullText(String nullText); protected String getSizeStartText(); protected void setSizeStartText(String sizeStartText); protected String getSizeEndText(); protected void setSizeEndText(String sizeEndText); protected String getSummaryObjectStartText(); protected void setSummaryObjectStartText(String summaryObjectStartText); protected String getSummaryObjectEndText(); protected void setSummaryObjectEndText(String summaryObjectEndText); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); long serialVersionUID=Optional[-2587890625525655916L]; ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; boolean useFieldNames=Optional[true]; boolean useClassName=Optional[true]; boolean useShortClassName=Optional[false]; boolean useIdentityHashCode=Optional[true]; String contentStart=Optional["["]; String contentEnd=Optional["]"]; String fieldNameValueSeparator=Optional["="]; boolean fieldSeparatorAtStart=Optional[false]; boolean fieldSeparatorAtEnd=Optional[false]; String fieldSeparator=Optional[","]; String arrayStart=Optional["{"]; String arraySeparator=Optional[","]; boolean arrayContentDetail=Optional[true]; String arrayEnd=Optional["}
protected void setFieldNameValueSeparator(String fieldNameValueSeparator) { [EOL]     if (fieldNameValueSeparator == null) { [EOL]         fieldNameValueSeparator = ""; [EOL]     } [EOL]     this.fieldNameValueSeparator = fieldNameValueSeparator; [EOL] } protected ToStringStyle();  DefaultToStringStyle();  NoFieldNameToStringStyle();  ShortPrefixToStringStyle();  SimpleToStringStyle();  MultiLineToStringStyle();  static Map<Object, Object> getRegistry();  static boolean isRegistered(final Object value);  static void register(final Object value);  static void unregister(final Object value); public void appendSuper(final StringBuffer buffer, final String superToString); public void appendToString(final StringBuffer buffer, final String toString); public void appendStart(final StringBuffer buffer, final Object object); public void appendEnd(final StringBuffer buffer, final Object object); protected void removeLastFieldSeparator(final StringBuffer buffer); public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); public void append(final StringBuffer buffer, final String fieldName, final long value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); public void append(final StringBuffer buffer, final String fieldName, final int value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); public void append(final StringBuffer buffer, final String fieldName, final short value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); public void append(final StringBuffer buffer, final String fieldName, final byte value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); public void append(final StringBuffer buffer, final String fieldName, final char value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); public void append(final StringBuffer buffer, final String fieldName, final double value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); public void append(final StringBuffer buffer, final String fieldName, final float value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); public void append(final StringBuffer buffer, final String fieldName, final boolean value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendClassName(final StringBuffer buffer, final Object object); protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); protected void appendContentStart(final StringBuffer buffer); protected void appendContentEnd(final StringBuffer buffer); protected void appendNullText(final StringBuffer buffer, final String fieldName); protected void appendFieldSeparator(final StringBuffer buffer); protected void appendFieldStart(final StringBuffer buffer, final String fieldName); protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); protected boolean isFullDetail(final Boolean fullDetailRequest); protected String getShortClassName(final Class<?> cls); protected boolean isUseClassName(); protected void setUseClassName(final boolean useClassName); protected boolean isUseShortClassName(); protected void setUseShortClassName(final boolean useShortClassName); protected boolean isUseIdentityHashCode(); protected void setUseIdentityHashCode(final boolean useIdentityHashCode); protected boolean isUseFieldNames(); protected void setUseFieldNames(final boolean useFieldNames); protected boolean isDefaultFullDetail(); protected void setDefaultFullDetail(final boolean defaultFullDetail); protected boolean isArrayContentDetail(); protected void setArrayContentDetail(final boolean arrayContentDetail); protected String getArrayStart(); protected void setArrayStart(String arrayStart); protected String getArrayEnd(); protected void setArrayEnd(String arrayEnd); protected String getArraySeparator(); protected void setArraySeparator(String arraySeparator); protected String getContentStart(); protected void setContentStart(String contentStart); protected String getContentEnd(); protected void setContentEnd(String contentEnd); protected String getFieldNameValueSeparator(); protected void setFieldNameValueSeparator(String fieldNameValueSeparator); protected String getFieldSeparator(); protected void setFieldSeparator(String fieldSeparator); protected boolean isFieldSeparatorAtStart(); protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); protected boolean isFieldSeparatorAtEnd(); protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); protected String getNullText(); protected void setNullText(String nullText); protected String getSizeStartText(); protected void setSizeStartText(String sizeStartText); protected String getSizeEndText(); protected void setSizeEndText(String sizeEndText); protected String getSummaryObjectStartText(); protected void setSummaryObjectStartText(String summaryObjectStartText); protected String getSummaryObjectEndText(); protected void setSummaryObjectEndText(String summaryObjectEndText); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); long serialVersionUID=Optional[-2587890625525655916L]; ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; boolean useFieldNames=Optional[true]; boolean useClassName=Optional[true]; boolean useShortClassName=Optional[false]; boolean useIdentityHashCode=Optional[true]; String contentStart=Optional["["]; String contentEnd=Optional["]"]; String fieldNameValueSeparator=Optional["="]; boolean fieldSeparatorAtStart=Optional[false]; boolean fieldSeparatorAtEnd=Optional[false]; String fieldSeparator=Optional[","]; String arrayStart=Optional["{"]; String arraySeparator=Optional[","]; boolean arrayContentDetail=Optional[true]; String arrayEnd=Optional["}
protected String getNullText() { [EOL]     return nullText; [EOL] } protected ToStringStyle();  DefaultToStringStyle();  NoFieldNameToStringStyle();  ShortPrefixToStringStyle();  SimpleToStringStyle();  MultiLineToStringStyle();  static Map<Object, Object> getRegistry();  static boolean isRegistered(final Object value);  static void register(final Object value);  static void unregister(final Object value); public void appendSuper(final StringBuffer buffer, final String superToString); public void appendToString(final StringBuffer buffer, final String toString); public void appendStart(final StringBuffer buffer, final Object object); public void appendEnd(final StringBuffer buffer, final Object object); protected void removeLastFieldSeparator(final StringBuffer buffer); public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); public void append(final StringBuffer buffer, final String fieldName, final long value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); public void append(final StringBuffer buffer, final String fieldName, final int value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); public void append(final StringBuffer buffer, final String fieldName, final short value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); public void append(final StringBuffer buffer, final String fieldName, final byte value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); public void append(final StringBuffer buffer, final String fieldName, final char value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); public void append(final StringBuffer buffer, final String fieldName, final double value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); public void append(final StringBuffer buffer, final String fieldName, final float value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); public void append(final StringBuffer buffer, final String fieldName, final boolean value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendClassName(final StringBuffer buffer, final Object object); protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); protected void appendContentStart(final StringBuffer buffer); protected void appendContentEnd(final StringBuffer buffer); protected void appendNullText(final StringBuffer buffer, final String fieldName); protected void appendFieldSeparator(final StringBuffer buffer); protected void appendFieldStart(final StringBuffer buffer, final String fieldName); protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); protected boolean isFullDetail(final Boolean fullDetailRequest); protected String getShortClassName(final Class<?> cls); protected boolean isUseClassName(); protected void setUseClassName(final boolean useClassName); protected boolean isUseShortClassName(); protected void setUseShortClassName(final boolean useShortClassName); protected boolean isUseIdentityHashCode(); protected void setUseIdentityHashCode(final boolean useIdentityHashCode); protected boolean isUseFieldNames(); protected void setUseFieldNames(final boolean useFieldNames); protected boolean isDefaultFullDetail(); protected void setDefaultFullDetail(final boolean defaultFullDetail); protected boolean isArrayContentDetail(); protected void setArrayContentDetail(final boolean arrayContentDetail); protected String getArrayStart(); protected void setArrayStart(String arrayStart); protected String getArrayEnd(); protected void setArrayEnd(String arrayEnd); protected String getArraySeparator(); protected void setArraySeparator(String arraySeparator); protected String getContentStart(); protected void setContentStart(String contentStart); protected String getContentEnd(); protected void setContentEnd(String contentEnd); protected String getFieldNameValueSeparator(); protected void setFieldNameValueSeparator(String fieldNameValueSeparator); protected String getFieldSeparator(); protected void setFieldSeparator(String fieldSeparator); protected boolean isFieldSeparatorAtStart(); protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); protected boolean isFieldSeparatorAtEnd(); protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); protected String getNullText(); protected void setNullText(String nullText); protected String getSizeStartText(); protected void setSizeStartText(String sizeStartText); protected String getSizeEndText(); protected void setSizeEndText(String sizeEndText); protected String getSummaryObjectStartText(); protected void setSummaryObjectStartText(String summaryObjectStartText); protected String getSummaryObjectEndText(); protected void setSummaryObjectEndText(String summaryObjectEndText); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); long serialVersionUID=Optional[-2587890625525655916L]; ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; boolean useFieldNames=Optional[true]; boolean useClassName=Optional[true]; boolean useShortClassName=Optional[false]; boolean useIdentityHashCode=Optional[true]; String contentStart=Optional["["]; String contentEnd=Optional["]"]; String fieldNameValueSeparator=Optional["="]; boolean fieldSeparatorAtStart=Optional[false]; boolean fieldSeparatorAtEnd=Optional[false]; String fieldSeparator=Optional[","]; String arrayStart=Optional["{"]; String arraySeparator=Optional[","]; boolean arrayContentDetail=Optional[true]; String arrayEnd=Optional["}
protected void setNullText(String nullText) { [EOL]     if (nullText == null) { [EOL]         nullText = ""; [EOL]     } [EOL]     this.nullText = nullText; [EOL] } protected ToStringStyle();  DefaultToStringStyle();  NoFieldNameToStringStyle();  ShortPrefixToStringStyle();  SimpleToStringStyle();  MultiLineToStringStyle();  static Map<Object, Object> getRegistry();  static boolean isRegistered(final Object value);  static void register(final Object value);  static void unregister(final Object value); public void appendSuper(final StringBuffer buffer, final String superToString); public void appendToString(final StringBuffer buffer, final String toString); public void appendStart(final StringBuffer buffer, final Object object); public void appendEnd(final StringBuffer buffer, final Object object); protected void removeLastFieldSeparator(final StringBuffer buffer); public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); public void append(final StringBuffer buffer, final String fieldName, final long value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); public void append(final StringBuffer buffer, final String fieldName, final int value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); public void append(final StringBuffer buffer, final String fieldName, final short value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); public void append(final StringBuffer buffer, final String fieldName, final byte value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); public void append(final StringBuffer buffer, final String fieldName, final char value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); public void append(final StringBuffer buffer, final String fieldName, final double value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); public void append(final StringBuffer buffer, final String fieldName, final float value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); public void append(final StringBuffer buffer, final String fieldName, final boolean value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendClassName(final StringBuffer buffer, final Object object); protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); protected void appendContentStart(final StringBuffer buffer); protected void appendContentEnd(final StringBuffer buffer); protected void appendNullText(final StringBuffer buffer, final String fieldName); protected void appendFieldSeparator(final StringBuffer buffer); protected void appendFieldStart(final StringBuffer buffer, final String fieldName); protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); protected boolean isFullDetail(final Boolean fullDetailRequest); protected String getShortClassName(final Class<?> cls); protected boolean isUseClassName(); protected void setUseClassName(final boolean useClassName); protected boolean isUseShortClassName(); protected void setUseShortClassName(final boolean useShortClassName); protected boolean isUseIdentityHashCode(); protected void setUseIdentityHashCode(final boolean useIdentityHashCode); protected boolean isUseFieldNames(); protected void setUseFieldNames(final boolean useFieldNames); protected boolean isDefaultFullDetail(); protected void setDefaultFullDetail(final boolean defaultFullDetail); protected boolean isArrayContentDetail(); protected void setArrayContentDetail(final boolean arrayContentDetail); protected String getArrayStart(); protected void setArrayStart(String arrayStart); protected String getArrayEnd(); protected void setArrayEnd(String arrayEnd); protected String getArraySeparator(); protected void setArraySeparator(String arraySeparator); protected String getContentStart(); protected void setContentStart(String contentStart); protected String getContentEnd(); protected void setContentEnd(String contentEnd); protected String getFieldNameValueSeparator(); protected void setFieldNameValueSeparator(String fieldNameValueSeparator); protected String getFieldSeparator(); protected void setFieldSeparator(String fieldSeparator); protected boolean isFieldSeparatorAtStart(); protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); protected boolean isFieldSeparatorAtEnd(); protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); protected String getNullText(); protected void setNullText(String nullText); protected String getSizeStartText(); protected void setSizeStartText(String sizeStartText); protected String getSizeEndText(); protected void setSizeEndText(String sizeEndText); protected String getSummaryObjectStartText(); protected void setSummaryObjectStartText(String summaryObjectStartText); protected String getSummaryObjectEndText(); protected void setSummaryObjectEndText(String summaryObjectEndText); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); long serialVersionUID=Optional[-2587890625525655916L]; ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; boolean useFieldNames=Optional[true]; boolean useClassName=Optional[true]; boolean useShortClassName=Optional[false]; boolean useIdentityHashCode=Optional[true]; String contentStart=Optional["["]; String contentEnd=Optional["]"]; String fieldNameValueSeparator=Optional["="]; boolean fieldSeparatorAtStart=Optional[false]; boolean fieldSeparatorAtEnd=Optional[false]; String fieldSeparator=Optional[","]; String arrayStart=Optional["{"]; String arraySeparator=Optional[","]; boolean arrayContentDetail=Optional[true]; String arrayEnd=Optional["}
protected String getSizeStartText() { [EOL]     return sizeStartText; [EOL] } protected ToStringStyle();  DefaultToStringStyle();  NoFieldNameToStringStyle();  ShortPrefixToStringStyle();  SimpleToStringStyle();  MultiLineToStringStyle();  static Map<Object, Object> getRegistry();  static boolean isRegistered(final Object value);  static void register(final Object value);  static void unregister(final Object value); public void appendSuper(final StringBuffer buffer, final String superToString); public void appendToString(final StringBuffer buffer, final String toString); public void appendStart(final StringBuffer buffer, final Object object); public void appendEnd(final StringBuffer buffer, final Object object); protected void removeLastFieldSeparator(final StringBuffer buffer); public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); public void append(final StringBuffer buffer, final String fieldName, final long value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); public void append(final StringBuffer buffer, final String fieldName, final int value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); public void append(final StringBuffer buffer, final String fieldName, final short value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); public void append(final StringBuffer buffer, final String fieldName, final byte value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); public void append(final StringBuffer buffer, final String fieldName, final char value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); public void append(final StringBuffer buffer, final String fieldName, final double value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); public void append(final StringBuffer buffer, final String fieldName, final float value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); public void append(final StringBuffer buffer, final String fieldName, final boolean value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendClassName(final StringBuffer buffer, final Object object); protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); protected void appendContentStart(final StringBuffer buffer); protected void appendContentEnd(final StringBuffer buffer); protected void appendNullText(final StringBuffer buffer, final String fieldName); protected void appendFieldSeparator(final StringBuffer buffer); protected void appendFieldStart(final StringBuffer buffer, final String fieldName); protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); protected boolean isFullDetail(final Boolean fullDetailRequest); protected String getShortClassName(final Class<?> cls); protected boolean isUseClassName(); protected void setUseClassName(final boolean useClassName); protected boolean isUseShortClassName(); protected void setUseShortClassName(final boolean useShortClassName); protected boolean isUseIdentityHashCode(); protected void setUseIdentityHashCode(final boolean useIdentityHashCode); protected boolean isUseFieldNames(); protected void setUseFieldNames(final boolean useFieldNames); protected boolean isDefaultFullDetail(); protected void setDefaultFullDetail(final boolean defaultFullDetail); protected boolean isArrayContentDetail(); protected void setArrayContentDetail(final boolean arrayContentDetail); protected String getArrayStart(); protected void setArrayStart(String arrayStart); protected String getArrayEnd(); protected void setArrayEnd(String arrayEnd); protected String getArraySeparator(); protected void setArraySeparator(String arraySeparator); protected String getContentStart(); protected void setContentStart(String contentStart); protected String getContentEnd(); protected void setContentEnd(String contentEnd); protected String getFieldNameValueSeparator(); protected void setFieldNameValueSeparator(String fieldNameValueSeparator); protected String getFieldSeparator(); protected void setFieldSeparator(String fieldSeparator); protected boolean isFieldSeparatorAtStart(); protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); protected boolean isFieldSeparatorAtEnd(); protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); protected String getNullText(); protected void setNullText(String nullText); protected String getSizeStartText(); protected void setSizeStartText(String sizeStartText); protected String getSizeEndText(); protected void setSizeEndText(String sizeEndText); protected String getSummaryObjectStartText(); protected void setSummaryObjectStartText(String summaryObjectStartText); protected String getSummaryObjectEndText(); protected void setSummaryObjectEndText(String summaryObjectEndText); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); long serialVersionUID=Optional[-2587890625525655916L]; ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; boolean useFieldNames=Optional[true]; boolean useClassName=Optional[true]; boolean useShortClassName=Optional[false]; boolean useIdentityHashCode=Optional[true]; String contentStart=Optional["["]; String contentEnd=Optional["]"]; String fieldNameValueSeparator=Optional["="]; boolean fieldSeparatorAtStart=Optional[false]; boolean fieldSeparatorAtEnd=Optional[false]; String fieldSeparator=Optional[","]; String arrayStart=Optional["{"]; String arraySeparator=Optional[","]; boolean arrayContentDetail=Optional[true]; String arrayEnd=Optional["}
protected void setSizeStartText(String sizeStartText) { [EOL]     if (sizeStartText == null) { [EOL]         sizeStartText = ""; [EOL]     } [EOL]     this.sizeStartText = sizeStartText; [EOL] } protected ToStringStyle();  DefaultToStringStyle();  NoFieldNameToStringStyle();  ShortPrefixToStringStyle();  SimpleToStringStyle();  MultiLineToStringStyle();  static Map<Object, Object> getRegistry();  static boolean isRegistered(final Object value);  static void register(final Object value);  static void unregister(final Object value); public void appendSuper(final StringBuffer buffer, final String superToString); public void appendToString(final StringBuffer buffer, final String toString); public void appendStart(final StringBuffer buffer, final Object object); public void appendEnd(final StringBuffer buffer, final Object object); protected void removeLastFieldSeparator(final StringBuffer buffer); public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); public void append(final StringBuffer buffer, final String fieldName, final long value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); public void append(final StringBuffer buffer, final String fieldName, final int value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); public void append(final StringBuffer buffer, final String fieldName, final short value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); public void append(final StringBuffer buffer, final String fieldName, final byte value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); public void append(final StringBuffer buffer, final String fieldName, final char value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); public void append(final StringBuffer buffer, final String fieldName, final double value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); public void append(final StringBuffer buffer, final String fieldName, final float value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); public void append(final StringBuffer buffer, final String fieldName, final boolean value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendClassName(final StringBuffer buffer, final Object object); protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); protected void appendContentStart(final StringBuffer buffer); protected void appendContentEnd(final StringBuffer buffer); protected void appendNullText(final StringBuffer buffer, final String fieldName); protected void appendFieldSeparator(final StringBuffer buffer); protected void appendFieldStart(final StringBuffer buffer, final String fieldName); protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); protected boolean isFullDetail(final Boolean fullDetailRequest); protected String getShortClassName(final Class<?> cls); protected boolean isUseClassName(); protected void setUseClassName(final boolean useClassName); protected boolean isUseShortClassName(); protected void setUseShortClassName(final boolean useShortClassName); protected boolean isUseIdentityHashCode(); protected void setUseIdentityHashCode(final boolean useIdentityHashCode); protected boolean isUseFieldNames(); protected void setUseFieldNames(final boolean useFieldNames); protected boolean isDefaultFullDetail(); protected void setDefaultFullDetail(final boolean defaultFullDetail); protected boolean isArrayContentDetail(); protected void setArrayContentDetail(final boolean arrayContentDetail); protected String getArrayStart(); protected void setArrayStart(String arrayStart); protected String getArrayEnd(); protected void setArrayEnd(String arrayEnd); protected String getArraySeparator(); protected void setArraySeparator(String arraySeparator); protected String getContentStart(); protected void setContentStart(String contentStart); protected String getContentEnd(); protected void setContentEnd(String contentEnd); protected String getFieldNameValueSeparator(); protected void setFieldNameValueSeparator(String fieldNameValueSeparator); protected String getFieldSeparator(); protected void setFieldSeparator(String fieldSeparator); protected boolean isFieldSeparatorAtStart(); protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); protected boolean isFieldSeparatorAtEnd(); protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); protected String getNullText(); protected void setNullText(String nullText); protected String getSizeStartText(); protected void setSizeStartText(String sizeStartText); protected String getSizeEndText(); protected void setSizeEndText(String sizeEndText); protected String getSummaryObjectStartText(); protected void setSummaryObjectStartText(String summaryObjectStartText); protected String getSummaryObjectEndText(); protected void setSummaryObjectEndText(String summaryObjectEndText); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); long serialVersionUID=Optional[-2587890625525655916L]; ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; boolean useFieldNames=Optional[true]; boolean useClassName=Optional[true]; boolean useShortClassName=Optional[false]; boolean useIdentityHashCode=Optional[true]; String contentStart=Optional["["]; String contentEnd=Optional["]"]; String fieldNameValueSeparator=Optional["="]; boolean fieldSeparatorAtStart=Optional[false]; boolean fieldSeparatorAtEnd=Optional[false]; String fieldSeparator=Optional[","]; String arrayStart=Optional["{"]; String arraySeparator=Optional[","]; boolean arrayContentDetail=Optional[true]; String arrayEnd=Optional["}
public static UnicodeEscaper below(final int codepoint) { [EOL]     return outsideOf(codepoint, Integer.MAX_VALUE); [EOL] }
public static UnicodeEscaper below(final int codepoint) { [EOL]     return outsideOf(codepoint, Integer.MAX_VALUE); [EOL] }
public static UnicodeEscaper below(final int codepoint) { [EOL]     return outsideOf(codepoint, Integer.MAX_VALUE); [EOL] }
public static UnicodeEscaper between(final int codepointLow, final int codepointHigh) { [EOL]     return new UnicodeEscaper(codepointLow, codepointHigh, true); [EOL] }
public static UnicodeEscaper between(final int codepointLow, final int codepointHigh) { [EOL]     return new UnicodeEscaper(codepointLow, codepointHigh, true); [EOL] }
public static UnicodeEscaper between(final int codepointLow, final int codepointHigh) { [EOL]     return new UnicodeEscaper(codepointLow, codepointHigh, true); [EOL] }
@Override [EOL] public boolean translate(final int codepoint, final Writer out) throws IOException { [EOL]     if (between) { [EOL]         if (codepoint < below || codepoint > above) { [EOL]             return false; [EOL]         } [EOL]     } else { [EOL]         if (codepoint >= below && codepoint <= above) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     if (codepoint > 0xffff) { [EOL]         out.write(toUtf16Escape(codepoint)); [EOL]     } else if (codepoint > 0xfff) { [EOL]         out.write("\\u" + hex(codepoint)); [EOL]     } else if (codepoint > 0xff) { [EOL]         out.write("\\u0" + hex(codepoint)); [EOL]     } else if (codepoint > 0xf) { [EOL]         out.write("\\u00" + hex(codepoint)); [EOL]     } else { [EOL]         out.write("\\u000" + hex(codepoint)); [EOL]     } [EOL]     return true; [EOL] }
public static char binaryToHexDigit(final boolean[] src, final int srcPos) { [EOL]     if (src.length == 0) { [EOL]         throw new IllegalArgumentException("Cannot convert an empty array."); [EOL]     } [EOL]     if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]         if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'f'; [EOL]                 } else { [EOL]                     return 'e'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return 'd'; [EOL]                 } else { [EOL]                     return 'c'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'b'; [EOL]                 } else { [EOL]                     return 'a'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '9'; [EOL]                 } else { [EOL]                     return '8'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return '7'; [EOL]                 } else { [EOL]                     return '6'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '5'; [EOL]                 } else { [EOL]                     return '4'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return '3'; [EOL]                 } else { [EOL]                     return '2'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '1'; [EOL]                 } else { [EOL]                     return '0'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
public static char binaryToHexDigit(final boolean[] src, final int srcPos) { [EOL]     if (src.length == 0) { [EOL]         throw new IllegalArgumentException("Cannot convert an empty array."); [EOL]     } [EOL]     if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]         if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'f'; [EOL]                 } else { [EOL]                     return 'e'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return 'd'; [EOL]                 } else { [EOL]                     return 'c'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'b'; [EOL]                 } else { [EOL]                     return 'a'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '9'; [EOL]                 } else { [EOL]                     return '8'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return '7'; [EOL]                 } else { [EOL]                     return '6'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '5'; [EOL]                 } else { [EOL]                     return '4'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return '3'; [EOL]                 } else { [EOL]                     return '2'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '1'; [EOL]                 } else { [EOL]                     return '0'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
public static char binaryToHexDigit(final boolean[] src, final int srcPos) { [EOL]     if (src.length == 0) { [EOL]         throw new IllegalArgumentException("Cannot convert an empty array."); [EOL]     } [EOL]     if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]         if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'f'; [EOL]                 } else { [EOL]                     return 'e'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return 'd'; [EOL]                 } else { [EOL]                     return 'c'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'b'; [EOL]                 } else { [EOL]                     return 'a'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '9'; [EOL]                 } else { [EOL]                     return '8'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return '7'; [EOL]                 } else { [EOL]                     return '6'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '5'; [EOL]                 } else { [EOL]                     return '4'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return '3'; [EOL]                 } else { [EOL]                     return '2'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '1'; [EOL]                 } else { [EOL]                     return '0'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
public static char binaryToHexDigit(final boolean[] src, final int srcPos) { [EOL]     if (src.length == 0) { [EOL]         throw new IllegalArgumentException("Cannot convert an empty array."); [EOL]     } [EOL]     if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]         if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'f'; [EOL]                 } else { [EOL]                     return 'e'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return 'd'; [EOL]                 } else { [EOL]                     return 'c'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'b'; [EOL]                 } else { [EOL]                     return 'a'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '9'; [EOL]                 } else { [EOL]                     return '8'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return '7'; [EOL]                 } else { [EOL]                     return '6'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '5'; [EOL]                 } else { [EOL]                     return '4'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return '3'; [EOL]                 } else { [EOL]                     return '2'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '1'; [EOL]                 } else { [EOL]                     return '0'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
public static char binaryToHexDigit(final boolean[] src, final int srcPos) { [EOL]     if (src.length == 0) { [EOL]         throw new IllegalArgumentException("Cannot convert an empty array."); [EOL]     } [EOL]     if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]         if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'f'; [EOL]                 } else { [EOL]                     return 'e'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return 'd'; [EOL]                 } else { [EOL]                     return 'c'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'b'; [EOL]                 } else { [EOL]                     return 'a'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '9'; [EOL]                 } else { [EOL]                     return '8'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return '7'; [EOL]                 } else { [EOL]                     return '6'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '5'; [EOL]                 } else { [EOL]                     return '4'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return '3'; [EOL]                 } else { [EOL]                     return '2'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '1'; [EOL]                 } else { [EOL]                     return '0'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
public static char binaryToHexDigit(final boolean[] src, final int srcPos) { [EOL]     if (src.length == 0) { [EOL]         throw new IllegalArgumentException("Cannot convert an empty array."); [EOL]     } [EOL]     if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]         if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'f'; [EOL]                 } else { [EOL]                     return 'e'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return 'd'; [EOL]                 } else { [EOL]                     return 'c'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'b'; [EOL]                 } else { [EOL]                     return 'a'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '9'; [EOL]                 } else { [EOL]                     return '8'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return '7'; [EOL]                 } else { [EOL]                     return '6'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '5'; [EOL]                 } else { [EOL]                     return '4'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return '3'; [EOL]                 } else { [EOL]                     return '2'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '1'; [EOL]                 } else { [EOL]                     return '0'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
public static char binaryToHexDigit(final boolean[] src, final int srcPos) { [EOL]     if (src.length == 0) { [EOL]         throw new IllegalArgumentException("Cannot convert an empty array."); [EOL]     } [EOL]     if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]         if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'f'; [EOL]                 } else { [EOL]                     return 'e'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return 'd'; [EOL]                 } else { [EOL]                     return 'c'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'b'; [EOL]                 } else { [EOL]                     return 'a'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '9'; [EOL]                 } else { [EOL]                     return '8'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return '7'; [EOL]                 } else { [EOL]                     return '6'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '5'; [EOL]                 } else { [EOL]                     return '4'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return '3'; [EOL]                 } else { [EOL]                     return '2'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '1'; [EOL]                 } else { [EOL]                     return '0'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
public static char binaryToHexDigit(final boolean[] src, final int srcPos) { [EOL]     if (src.length == 0) { [EOL]         throw new IllegalArgumentException("Cannot convert an empty array."); [EOL]     } [EOL]     if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]         if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'f'; [EOL]                 } else { [EOL]                     return 'e'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return 'd'; [EOL]                 } else { [EOL]                     return 'c'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'b'; [EOL]                 } else { [EOL]                     return 'a'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '9'; [EOL]                 } else { [EOL]                     return '8'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return '7'; [EOL]                 } else { [EOL]                     return '6'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '5'; [EOL]                 } else { [EOL]                     return '4'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return '3'; [EOL]                 } else { [EOL]                     return '2'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '1'; [EOL]                 } else { [EOL]                     return '0'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
public static char binaryToHexDigit(final boolean[] src, final int srcPos) { [EOL]     if (src.length == 0) { [EOL]         throw new IllegalArgumentException("Cannot convert an empty array."); [EOL]     } [EOL]     if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]         if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'f'; [EOL]                 } else { [EOL]                     return 'e'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return 'd'; [EOL]                 } else { [EOL]                     return 'c'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'b'; [EOL]                 } else { [EOL]                     return 'a'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '9'; [EOL]                 } else { [EOL]                     return '8'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return '7'; [EOL]                 } else { [EOL]                     return '6'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '5'; [EOL]                 } else { [EOL]                     return '4'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return '3'; [EOL]                 } else { [EOL]                     return '2'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '1'; [EOL]                 } else { [EOL]                     return '0'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
public static char binaryToHexDigit(final boolean[] src, final int srcPos) { [EOL]     if (src.length == 0) { [EOL]         throw new IllegalArgumentException("Cannot convert an empty array."); [EOL]     } [EOL]     if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]         if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'f'; [EOL]                 } else { [EOL]                     return 'e'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return 'd'; [EOL]                 } else { [EOL]                     return 'c'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'b'; [EOL]                 } else { [EOL]                     return 'a'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '9'; [EOL]                 } else { [EOL]                     return '8'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return '7'; [EOL]                 } else { [EOL]                     return '6'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '5'; [EOL]                 } else { [EOL]                     return '4'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return '3'; [EOL]                 } else { [EOL]                     return '2'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '1'; [EOL]                 } else { [EOL]                     return '0'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
public static char binaryToHexDigit(final boolean[] src, final int srcPos) { [EOL]     if (src.length == 0) { [EOL]         throw new IllegalArgumentException("Cannot convert an empty array."); [EOL]     } [EOL]     if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]         if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'f'; [EOL]                 } else { [EOL]                     return 'e'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return 'd'; [EOL]                 } else { [EOL]                     return 'c'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'b'; [EOL]                 } else { [EOL]                     return 'a'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '9'; [EOL]                 } else { [EOL]                     return '8'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return '7'; [EOL]                 } else { [EOL]                     return '6'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '5'; [EOL]                 } else { [EOL]                     return '4'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return '3'; [EOL]                 } else { [EOL]                     return '2'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '1'; [EOL]                 } else { [EOL]                     return '0'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
public static char binaryToHexDigit(final boolean[] src, final int srcPos) { [EOL]     if (src.length == 0) { [EOL]         throw new IllegalArgumentException("Cannot convert an empty array."); [EOL]     } [EOL]     if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]         if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'f'; [EOL]                 } else { [EOL]                     return 'e'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return 'd'; [EOL]                 } else { [EOL]                     return 'c'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'b'; [EOL]                 } else { [EOL]                     return 'a'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '9'; [EOL]                 } else { [EOL]                     return '8'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return '7'; [EOL]                 } else { [EOL]                     return '6'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '5'; [EOL]                 } else { [EOL]                     return '4'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return '3'; [EOL]                 } else { [EOL]                     return '2'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '1'; [EOL]                 } else { [EOL]                     return '0'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
public static char binaryToHexDigit(final boolean[] src, final int srcPos) { [EOL]     if (src.length == 0) { [EOL]         throw new IllegalArgumentException("Cannot convert an empty array."); [EOL]     } [EOL]     if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]         if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'f'; [EOL]                 } else { [EOL]                     return 'e'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return 'd'; [EOL]                 } else { [EOL]                     return 'c'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'b'; [EOL]                 } else { [EOL]                     return 'a'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '9'; [EOL]                 } else { [EOL]                     return '8'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return '7'; [EOL]                 } else { [EOL]                     return '6'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '5'; [EOL]                 } else { [EOL]                     return '4'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return '3'; [EOL]                 } else { [EOL]                     return '2'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '1'; [EOL]                 } else { [EOL]                     return '0'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
public static char binaryToHexDigit(final boolean[] src, final int srcPos) { [EOL]     if (src.length == 0) { [EOL]         throw new IllegalArgumentException("Cannot convert an empty array."); [EOL]     } [EOL]     if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]         if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'f'; [EOL]                 } else { [EOL]                     return 'e'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return 'd'; [EOL]                 } else { [EOL]                     return 'c'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'b'; [EOL]                 } else { [EOL]                     return 'a'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '9'; [EOL]                 } else { [EOL]                     return '8'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return '7'; [EOL]                 } else { [EOL]                     return '6'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '5'; [EOL]                 } else { [EOL]                     return '4'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return '3'; [EOL]                 } else { [EOL]                     return '2'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '1'; [EOL]                 } else { [EOL]                     return '0'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
public static char binaryToHexDigit(final boolean[] src, final int srcPos) { [EOL]     if (src.length == 0) { [EOL]         throw new IllegalArgumentException("Cannot convert an empty array."); [EOL]     } [EOL]     if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]         if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'f'; [EOL]                 } else { [EOL]                     return 'e'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return 'd'; [EOL]                 } else { [EOL]                     return 'c'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'b'; [EOL]                 } else { [EOL]                     return 'a'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '9'; [EOL]                 } else { [EOL]                     return '8'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return '7'; [EOL]                 } else { [EOL]                     return '6'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '5'; [EOL]                 } else { [EOL]                     return '4'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return '3'; [EOL]                 } else { [EOL]                     return '2'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '1'; [EOL]                 } else { [EOL]                     return '0'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
public static char binaryToHexDigit(final boolean[] src, final int srcPos) { [EOL]     if (src.length == 0) { [EOL]         throw new IllegalArgumentException("Cannot convert an empty array."); [EOL]     } [EOL]     if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]         if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'f'; [EOL]                 } else { [EOL]                     return 'e'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return 'd'; [EOL]                 } else { [EOL]                     return 'c'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'b'; [EOL]                 } else { [EOL]                     return 'a'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '9'; [EOL]                 } else { [EOL]                     return '8'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return '7'; [EOL]                 } else { [EOL]                     return '6'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '5'; [EOL]                 } else { [EOL]                     return '4'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return '3'; [EOL]                 } else { [EOL]                     return '2'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '1'; [EOL]                 } else { [EOL]                     return '0'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
public static char binaryToHexDigit(final boolean[] src, final int srcPos) { [EOL]     if (src.length == 0) { [EOL]         throw new IllegalArgumentException("Cannot convert an empty array."); [EOL]     } [EOL]     if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]         if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'f'; [EOL]                 } else { [EOL]                     return 'e'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return 'd'; [EOL]                 } else { [EOL]                     return 'c'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'b'; [EOL]                 } else { [EOL]                     return 'a'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '9'; [EOL]                 } else { [EOL]                     return '8'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return '7'; [EOL]                 } else { [EOL]                     return '6'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '5'; [EOL]                 } else { [EOL]                     return '4'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return '3'; [EOL]                 } else { [EOL]                     return '2'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '1'; [EOL]                 } else { [EOL]                     return '0'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
public static char intToHexDigitMsb0(final int nibble) { [EOL]     switch(nibble) { [EOL]         case 0x0: [EOL]             return '0'; [EOL]         case 0x1: [EOL]             return '8'; [EOL]         case 0x2: [EOL]             return '4'; [EOL]         case 0x3: [EOL]             return 'c'; [EOL]         case 0x4: [EOL]             return '2'; [EOL]         case 0x5: [EOL]             return 'a'; [EOL]         case 0x6: [EOL]             return '6'; [EOL]         case 0x7: [EOL]             return 'e'; [EOL]         case 0x8: [EOL]             return '1'; [EOL]         case 0x9: [EOL]             return '9'; [EOL]         case 0xA: [EOL]             return '5'; [EOL]         case 0xB: [EOL]             return 'd'; [EOL]         case 0xC: [EOL]             return '3'; [EOL]         case 0xD: [EOL]             return 'b'; [EOL]         case 0xE: [EOL]             return '7'; [EOL]         case 0xF: [EOL]             return 'f'; [EOL]         default: [EOL]             throw new IllegalArgumentException("nibble value not between 0 and 15: " + nibble); [EOL]     } [EOL] }
public static char intToHexDigitMsb0(final int nibble) { [EOL]     switch(nibble) { [EOL]         case 0x0: [EOL]             return '0'; [EOL]         case 0x1: [EOL]             return '8'; [EOL]         case 0x2: [EOL]             return '4'; [EOL]         case 0x3: [EOL]             return 'c'; [EOL]         case 0x4: [EOL]             return '2'; [EOL]         case 0x5: [EOL]             return 'a'; [EOL]         case 0x6: [EOL]             return '6'; [EOL]         case 0x7: [EOL]             return 'e'; [EOL]         case 0x8: [EOL]             return '1'; [EOL]         case 0x9: [EOL]             return '9'; [EOL]         case 0xA: [EOL]             return '5'; [EOL]         case 0xB: [EOL]             return 'd'; [EOL]         case 0xC: [EOL]             return '3'; [EOL]         case 0xD: [EOL]             return 'b'; [EOL]         case 0xE: [EOL]             return '7'; [EOL]         case 0xF: [EOL]             return 'f'; [EOL]         default: [EOL]             throw new IllegalArgumentException("nibble value not between 0 and 15: " + nibble); [EOL]     } [EOL] }
public static char intToHexDigitMsb0(final int nibble) { [EOL]     switch(nibble) { [EOL]         case 0x0: [EOL]             return '0'; [EOL]         case 0x1: [EOL]             return '8'; [EOL]         case 0x2: [EOL]             return '4'; [EOL]         case 0x3: [EOL]             return 'c'; [EOL]         case 0x4: [EOL]             return '2'; [EOL]         case 0x5: [EOL]             return 'a'; [EOL]         case 0x6: [EOL]             return '6'; [EOL]         case 0x7: [EOL]             return 'e'; [EOL]         case 0x8: [EOL]             return '1'; [EOL]         case 0x9: [EOL]             return '9'; [EOL]         case 0xA: [EOL]             return '5'; [EOL]         case 0xB: [EOL]             return 'd'; [EOL]         case 0xC: [EOL]             return '3'; [EOL]         case 0xD: [EOL]             return 'b'; [EOL]         case 0xE: [EOL]             return '7'; [EOL]         case 0xF: [EOL]             return 'f'; [EOL]         default: [EOL]             throw new IllegalArgumentException("nibble value not between 0 and 15: " + nibble); [EOL]     } [EOL] }
public static char intToHexDigitMsb0(final int nibble) { [EOL]     switch(nibble) { [EOL]         case 0x0: [EOL]             return '0'; [EOL]         case 0x1: [EOL]             return '8'; [EOL]         case 0x2: [EOL]             return '4'; [EOL]         case 0x3: [EOL]             return 'c'; [EOL]         case 0x4: [EOL]             return '2'; [EOL]         case 0x5: [EOL]             return 'a'; [EOL]         case 0x6: [EOL]             return '6'; [EOL]         case 0x7: [EOL]             return 'e'; [EOL]         case 0x8: [EOL]             return '1'; [EOL]         case 0x9: [EOL]             return '9'; [EOL]         case 0xA: [EOL]             return '5'; [EOL]         case 0xB: [EOL]             return 'd'; [EOL]         case 0xC: [EOL]             return '3'; [EOL]         case 0xD: [EOL]             return 'b'; [EOL]         case 0xE: [EOL]             return '7'; [EOL]         case 0xF: [EOL]             return 'f'; [EOL]         default: [EOL]             throw new IllegalArgumentException("nibble value not between 0 and 15: " + nibble); [EOL]     } [EOL] }
public static char intToHexDigitMsb0(final int nibble) { [EOL]     switch(nibble) { [EOL]         case 0x0: [EOL]             return '0'; [EOL]         case 0x1: [EOL]             return '8'; [EOL]         case 0x2: [EOL]             return '4'; [EOL]         case 0x3: [EOL]             return 'c'; [EOL]         case 0x4: [EOL]             return '2'; [EOL]         case 0x5: [EOL]             return 'a'; [EOL]         case 0x6: [EOL]             return '6'; [EOL]         case 0x7: [EOL]             return 'e'; [EOL]         case 0x8: [EOL]             return '1'; [EOL]         case 0x9: [EOL]             return '9'; [EOL]         case 0xA: [EOL]             return '5'; [EOL]         case 0xB: [EOL]             return 'd'; [EOL]         case 0xC: [EOL]             return '3'; [EOL]         case 0xD: [EOL]             return 'b'; [EOL]         case 0xE: [EOL]             return '7'; [EOL]         case 0xF: [EOL]             return 'f'; [EOL]         default: [EOL]             throw new IllegalArgumentException("nibble value not between 0 and 15: " + nibble); [EOL]     } [EOL] }
public static char intToHexDigitMsb0(final int nibble) { [EOL]     switch(nibble) { [EOL]         case 0x0: [EOL]             return '0'; [EOL]         case 0x1: [EOL]             return '8'; [EOL]         case 0x2: [EOL]             return '4'; [EOL]         case 0x3: [EOL]             return 'c'; [EOL]         case 0x4: [EOL]             return '2'; [EOL]         case 0x5: [EOL]             return 'a'; [EOL]         case 0x6: [EOL]             return '6'; [EOL]         case 0x7: [EOL]             return 'e'; [EOL]         case 0x8: [EOL]             return '1'; [EOL]         case 0x9: [EOL]             return '9'; [EOL]         case 0xA: [EOL]             return '5'; [EOL]         case 0xB: [EOL]             return 'd'; [EOL]         case 0xC: [EOL]             return '3'; [EOL]         case 0xD: [EOL]             return 'b'; [EOL]         case 0xE: [EOL]             return '7'; [EOL]         case 0xF: [EOL]             return 'f'; [EOL]         default: [EOL]             throw new IllegalArgumentException("nibble value not between 0 and 15: " + nibble); [EOL]     } [EOL] }
public static char intToHexDigitMsb0(final int nibble) { [EOL]     switch(nibble) { [EOL]         case 0x0: [EOL]             return '0'; [EOL]         case 0x1: [EOL]             return '8'; [EOL]         case 0x2: [EOL]             return '4'; [EOL]         case 0x3: [EOL]             return 'c'; [EOL]         case 0x4: [EOL]             return '2'; [EOL]         case 0x5: [EOL]             return 'a'; [EOL]         case 0x6: [EOL]             return '6'; [EOL]         case 0x7: [EOL]             return 'e'; [EOL]         case 0x8: [EOL]             return '1'; [EOL]         case 0x9: [EOL]             return '9'; [EOL]         case 0xA: [EOL]             return '5'; [EOL]         case 0xB: [EOL]             return 'd'; [EOL]         case 0xC: [EOL]             return '3'; [EOL]         case 0xD: [EOL]             return 'b'; [EOL]         case 0xE: [EOL]             return '7'; [EOL]         case 0xF: [EOL]             return 'f'; [EOL]         default: [EOL]             throw new IllegalArgumentException("nibble value not between 0 and 15: " + nibble); [EOL]     } [EOL] }
public static char intToHexDigitMsb0(final int nibble) { [EOL]     switch(nibble) { [EOL]         case 0x0: [EOL]             return '0'; [EOL]         case 0x1: [EOL]             return '8'; [EOL]         case 0x2: [EOL]             return '4'; [EOL]         case 0x3: [EOL]             return 'c'; [EOL]         case 0x4: [EOL]             return '2'; [EOL]         case 0x5: [EOL]             return 'a'; [EOL]         case 0x6: [EOL]             return '6'; [EOL]         case 0x7: [EOL]             return 'e'; [EOL]         case 0x8: [EOL]             return '1'; [EOL]         case 0x9: [EOL]             return '9'; [EOL]         case 0xA: [EOL]             return '5'; [EOL]         case 0xB: [EOL]             return 'd'; [EOL]         case 0xC: [EOL]             return '3'; [EOL]         case 0xD: [EOL]             return 'b'; [EOL]         case 0xE: [EOL]             return '7'; [EOL]         case 0xF: [EOL]             return 'f'; [EOL]         default: [EOL]             throw new IllegalArgumentException("nibble value not between 0 and 15: " + nibble); [EOL]     } [EOL] }
public static char intToHexDigitMsb0(final int nibble) { [EOL]     switch(nibble) { [EOL]         case 0x0: [EOL]             return '0'; [EOL]         case 0x1: [EOL]             return '8'; [EOL]         case 0x2: [EOL]             return '4'; [EOL]         case 0x3: [EOL]             return 'c'; [EOL]         case 0x4: [EOL]             return '2'; [EOL]         case 0x5: [EOL]             return 'a'; [EOL]         case 0x6: [EOL]             return '6'; [EOL]         case 0x7: [EOL]             return 'e'; [EOL]         case 0x8: [EOL]             return '1'; [EOL]         case 0x9: [EOL]             return '9'; [EOL]         case 0xA: [EOL]             return '5'; [EOL]         case 0xB: [EOL]             return 'd'; [EOL]         case 0xC: [EOL]             return '3'; [EOL]         case 0xD: [EOL]             return 'b'; [EOL]         case 0xE: [EOL]             return '7'; [EOL]         case 0xF: [EOL]             return 'f'; [EOL]         default: [EOL]             throw new IllegalArgumentException("nibble value not between 0 and 15: " + nibble); [EOL]     } [EOL] }
public static char intToHexDigitMsb0(final int nibble) { [EOL]     switch(nibble) { [EOL]         case 0x0: [EOL]             return '0'; [EOL]         case 0x1: [EOL]             return '8'; [EOL]         case 0x2: [EOL]             return '4'; [EOL]         case 0x3: [EOL]             return 'c'; [EOL]         case 0x4: [EOL]             return '2'; [EOL]         case 0x5: [EOL]             return 'a'; [EOL]         case 0x6: [EOL]             return '6'; [EOL]         case 0x7: [EOL]             return 'e'; [EOL]         case 0x8: [EOL]             return '1'; [EOL]         case 0x9: [EOL]             return '9'; [EOL]         case 0xA: [EOL]             return '5'; [EOL]         case 0xB: [EOL]             return 'd'; [EOL]         case 0xC: [EOL]             return '3'; [EOL]         case 0xD: [EOL]             return 'b'; [EOL]         case 0xE: [EOL]             return '7'; [EOL]         case 0xF: [EOL]             return 'f'; [EOL]         default: [EOL]             throw new IllegalArgumentException("nibble value not between 0 and 15: " + nibble); [EOL]     } [EOL] }
public static char intToHexDigitMsb0(final int nibble) { [EOL]     switch(nibble) { [EOL]         case 0x0: [EOL]             return '0'; [EOL]         case 0x1: [EOL]             return '8'; [EOL]         case 0x2: [EOL]             return '4'; [EOL]         case 0x3: [EOL]             return 'c'; [EOL]         case 0x4: [EOL]             return '2'; [EOL]         case 0x5: [EOL]             return 'a'; [EOL]         case 0x6: [EOL]             return '6'; [EOL]         case 0x7: [EOL]             return 'e'; [EOL]         case 0x8: [EOL]             return '1'; [EOL]         case 0x9: [EOL]             return '9'; [EOL]         case 0xA: [EOL]             return '5'; [EOL]         case 0xB: [EOL]             return 'd'; [EOL]         case 0xC: [EOL]             return '3'; [EOL]         case 0xD: [EOL]             return 'b'; [EOL]         case 0xE: [EOL]             return '7'; [EOL]         case 0xF: [EOL]             return 'f'; [EOL]         default: [EOL]             throw new IllegalArgumentException("nibble value not between 0 and 15: " + nibble); [EOL]     } [EOL] }
public static char intToHexDigitMsb0(final int nibble) { [EOL]     switch(nibble) { [EOL]         case 0x0: [EOL]             return '0'; [EOL]         case 0x1: [EOL]             return '8'; [EOL]         case 0x2: [EOL]             return '4'; [EOL]         case 0x3: [EOL]             return 'c'; [EOL]         case 0x4: [EOL]             return '2'; [EOL]         case 0x5: [EOL]             return 'a'; [EOL]         case 0x6: [EOL]             return '6'; [EOL]         case 0x7: [EOL]             return 'e'; [EOL]         case 0x8: [EOL]             return '1'; [EOL]         case 0x9: [EOL]             return '9'; [EOL]         case 0xA: [EOL]             return '5'; [EOL]         case 0xB: [EOL]             return 'd'; [EOL]         case 0xC: [EOL]             return '3'; [EOL]         case 0xD: [EOL]             return 'b'; [EOL]         case 0xE: [EOL]             return '7'; [EOL]         case 0xF: [EOL]             return 'f'; [EOL]         default: [EOL]             throw new IllegalArgumentException("nibble value not between 0 and 15: " + nibble); [EOL]     } [EOL] }
public static char intToHexDigitMsb0(final int nibble) { [EOL]     switch(nibble) { [EOL]         case 0x0: [EOL]             return '0'; [EOL]         case 0x1: [EOL]             return '8'; [EOL]         case 0x2: [EOL]             return '4'; [EOL]         case 0x3: [EOL]             return 'c'; [EOL]         case 0x4: [EOL]             return '2'; [EOL]         case 0x5: [EOL]             return 'a'; [EOL]         case 0x6: [EOL]             return '6'; [EOL]         case 0x7: [EOL]             return 'e'; [EOL]         case 0x8: [EOL]             return '1'; [EOL]         case 0x9: [EOL]             return '9'; [EOL]         case 0xA: [EOL]             return '5'; [EOL]         case 0xB: [EOL]             return 'd'; [EOL]         case 0xC: [EOL]             return '3'; [EOL]         case 0xD: [EOL]             return 'b'; [EOL]         case 0xE: [EOL]             return '7'; [EOL]         case 0xF: [EOL]             return 'f'; [EOL]         default: [EOL]             throw new IllegalArgumentException("nibble value not between 0 and 15: " + nibble); [EOL]     } [EOL] }
public static char intToHexDigitMsb0(final int nibble) { [EOL]     switch(nibble) { [EOL]         case 0x0: [EOL]             return '0'; [EOL]         case 0x1: [EOL]             return '8'; [EOL]         case 0x2: [EOL]             return '4'; [EOL]         case 0x3: [EOL]             return 'c'; [EOL]         case 0x4: [EOL]             return '2'; [EOL]         case 0x5: [EOL]             return 'a'; [EOL]         case 0x6: [EOL]             return '6'; [EOL]         case 0x7: [EOL]             return 'e'; [EOL]         case 0x8: [EOL]             return '1'; [EOL]         case 0x9: [EOL]             return '9'; [EOL]         case 0xA: [EOL]             return '5'; [EOL]         case 0xB: [EOL]             return 'd'; [EOL]         case 0xC: [EOL]             return '3'; [EOL]         case 0xD: [EOL]             return 'b'; [EOL]         case 0xE: [EOL]             return '7'; [EOL]         case 0xF: [EOL]             return 'f'; [EOL]         default: [EOL]             throw new IllegalArgumentException("nibble value not between 0 and 15: " + nibble); [EOL]     } [EOL] }
public static char intToHexDigitMsb0(final int nibble) { [EOL]     switch(nibble) { [EOL]         case 0x0: [EOL]             return '0'; [EOL]         case 0x1: [EOL]             return '8'; [EOL]         case 0x2: [EOL]             return '4'; [EOL]         case 0x3: [EOL]             return 'c'; [EOL]         case 0x4: [EOL]             return '2'; [EOL]         case 0x5: [EOL]             return 'a'; [EOL]         case 0x6: [EOL]             return '6'; [EOL]         case 0x7: [EOL]             return 'e'; [EOL]         case 0x8: [EOL]             return '1'; [EOL]         case 0x9: [EOL]             return '9'; [EOL]         case 0xA: [EOL]             return '5'; [EOL]         case 0xB: [EOL]             return 'd'; [EOL]         case 0xC: [EOL]             return '3'; [EOL]         case 0xD: [EOL]             return 'b'; [EOL]         case 0xE: [EOL]             return '7'; [EOL]         case 0xF: [EOL]             return 'f'; [EOL]         default: [EOL]             throw new IllegalArgumentException("nibble value not between 0 and 15: " + nibble); [EOL]     } [EOL] }
public static char intToHexDigitMsb0(final int nibble) { [EOL]     switch(nibble) { [EOL]         case 0x0: [EOL]             return '0'; [EOL]         case 0x1: [EOL]             return '8'; [EOL]         case 0x2: [EOL]             return '4'; [EOL]         case 0x3: [EOL]             return 'c'; [EOL]         case 0x4: [EOL]             return '2'; [EOL]         case 0x5: [EOL]             return 'a'; [EOL]         case 0x6: [EOL]             return '6'; [EOL]         case 0x7: [EOL]             return 'e'; [EOL]         case 0x8: [EOL]             return '1'; [EOL]         case 0x9: [EOL]             return '9'; [EOL]         case 0xA: [EOL]             return '5'; [EOL]         case 0xB: [EOL]             return 'd'; [EOL]         case 0xC: [EOL]             return '3'; [EOL]         case 0xD: [EOL]             return 'b'; [EOL]         case 0xE: [EOL]             return '7'; [EOL]         case 0xF: [EOL]             return 'f'; [EOL]         default: [EOL]             throw new IllegalArgumentException("nibble value not between 0 and 15: " + nibble); [EOL]     } [EOL] }
public static char intToHexDigitMsb0(final int nibble) { [EOL]     switch(nibble) { [EOL]         case 0x0: [EOL]             return '0'; [EOL]         case 0x1: [EOL]             return '8'; [EOL]         case 0x2: [EOL]             return '4'; [EOL]         case 0x3: [EOL]             return 'c'; [EOL]         case 0x4: [EOL]             return '2'; [EOL]         case 0x5: [EOL]             return 'a'; [EOL]         case 0x6: [EOL]             return '6'; [EOL]         case 0x7: [EOL]             return 'e'; [EOL]         case 0x8: [EOL]             return '1'; [EOL]         case 0x9: [EOL]             return '9'; [EOL]         case 0xA: [EOL]             return '5'; [EOL]         case 0xB: [EOL]             return 'd'; [EOL]         case 0xC: [EOL]             return '3'; [EOL]         case 0xD: [EOL]             return 'b'; [EOL]         case 0xE: [EOL]             return '7'; [EOL]         case 0xF: [EOL]             return 'f'; [EOL]         default: [EOL]             throw new IllegalArgumentException("nibble value not between 0 and 15: " + nibble); [EOL]     } [EOL] }
public static long shortArrayToLong(final short[] src, final int srcPos, final long dstInit, final int dstPos, final int nShorts) { [EOL]     if ((src.length == 0 && srcPos == 0) || 0 == nShorts) { [EOL]         return dstInit; [EOL]     } [EOL]     if ((nShorts - 1) * 16 + dstPos >= 64) { [EOL]         throw new IllegalArgumentException("(nShorts-1)*16+dstPos is greather or equal to than 64"); [EOL]     } [EOL]     long out = dstInit; [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nShorts; i++) { [EOL]         shift = i * 16 + dstPos; [EOL]         final long bits = (0xffffL & src[i + srcPos]) << shift; [EOL]         final long mask = 0xffffL << shift; [EOL]         out = (out & ~mask) | bits; [EOL]     } [EOL]     return out; [EOL] }
public static long hexToLong(final String src, final int srcPos, final long dstInit, final int dstPos, final int nHex) { [EOL]     if (0 == nHex) { [EOL]         return dstInit; [EOL]     } [EOL]     if ((nHex - 1) * 4 + dstPos >= 64) { [EOL]         throw new IllegalArgumentException("(nHexs-1)*4+dstPos is greather or equal to than 64"); [EOL]     } [EOL]     long out = dstInit; [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nHex; i++) { [EOL]         shift = i * 4 + dstPos; [EOL]         final long bits = (0xfL & hexDigitToInt(src.charAt(i + srcPos))) << shift; [EOL]         final long mask = 0xfL << shift; [EOL]         out = (out & ~mask) | bits; [EOL]     } [EOL]     return out; [EOL] }
public static long hexToLong(final String src, final int srcPos, final long dstInit, final int dstPos, final int nHex) { [EOL]     if (0 == nHex) { [EOL]         return dstInit; [EOL]     } [EOL]     if ((nHex - 1) * 4 + dstPos >= 64) { [EOL]         throw new IllegalArgumentException("(nHexs-1)*4+dstPos is greather or equal to than 64"); [EOL]     } [EOL]     long out = dstInit; [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nHex; i++) { [EOL]         shift = i * 4 + dstPos; [EOL]         final long bits = (0xfL & hexDigitToInt(src.charAt(i + srcPos))) << shift; [EOL]         final long mask = 0xfL << shift; [EOL]         out = (out & ~mask) | bits; [EOL]     } [EOL]     return out; [EOL] }
public static int hexToInt(final String src, final int srcPos, final int dstInit, final int dstPos, final int nHex) { [EOL]     if (0 == nHex) { [EOL]         return dstInit; [EOL]     } [EOL]     if ((nHex - 1) * 4 + dstPos >= 32) { [EOL]         throw new IllegalArgumentException("(nHexs-1)*4+dstPos is greather or equal to than 32"); [EOL]     } [EOL]     int out = dstInit; [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nHex; i++) { [EOL]         shift = i * 4 + dstPos; [EOL]         final int bits = (0xf & hexDigitToInt(src.charAt(i + srcPos))) << shift; [EOL]         final int mask = 0xf << shift; [EOL]         out = (out & ~mask) | bits; [EOL]     } [EOL]     return out; [EOL] }
public static short binaryToShort(final boolean[] src, final int srcPos, final short dstInit, final int dstPos, final int nBools) { [EOL]     if ((src.length == 0 && srcPos == 0) || 0 == nBools) { [EOL]         return dstInit; [EOL]     } [EOL]     if (nBools - 1 + dstPos >= 16) { [EOL]         throw new IllegalArgumentException("nBools-1+dstPos is greather or equal to than 16"); [EOL]     } [EOL]     short out = dstInit; [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nBools; i++) { [EOL]         shift = i * 1 + dstPos; [EOL]         final int bits = (src[i + srcPos] ? 1 : 0) << shift; [EOL]         final int mask = 0x1 << shift; [EOL]         out = (short) ((out & ~mask) | bits); [EOL]     } [EOL]     return out; [EOL] }
public static short binaryToShort(final boolean[] src, final int srcPos, final short dstInit, final int dstPos, final int nBools) { [EOL]     if ((src.length == 0 && srcPos == 0) || 0 == nBools) { [EOL]         return dstInit; [EOL]     } [EOL]     if (nBools - 1 + dstPos >= 16) { [EOL]         throw new IllegalArgumentException("nBools-1+dstPos is greather or equal to than 16"); [EOL]     } [EOL]     short out = dstInit; [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nBools; i++) { [EOL]         shift = i * 1 + dstPos; [EOL]         final int bits = (src[i + srcPos] ? 1 : 0) << shift; [EOL]         final int mask = 0x1 << shift; [EOL]         out = (short) ((out & ~mask) | bits); [EOL]     } [EOL]     return out; [EOL] }
public static short binaryToShort(final boolean[] src, final int srcPos, final short dstInit, final int dstPos, final int nBools) { [EOL]     if ((src.length == 0 && srcPos == 0) || 0 == nBools) { [EOL]         return dstInit; [EOL]     } [EOL]     if (nBools - 1 + dstPos >= 16) { [EOL]         throw new IllegalArgumentException("nBools-1+dstPos is greather or equal to than 16"); [EOL]     } [EOL]     short out = dstInit; [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nBools; i++) { [EOL]         shift = i * 1 + dstPos; [EOL]         final int bits = (src[i + srcPos] ? 1 : 0) << shift; [EOL]         final int mask = 0x1 << shift; [EOL]         out = (short) ((out & ~mask) | bits); [EOL]     } [EOL]     return out; [EOL] }
public static short binaryToShort(final boolean[] src, final int srcPos, final short dstInit, final int dstPos, final int nBools) { [EOL]     if ((src.length == 0 && srcPos == 0) || 0 == nBools) { [EOL]         return dstInit; [EOL]     } [EOL]     if (nBools - 1 + dstPos >= 16) { [EOL]         throw new IllegalArgumentException("nBools-1+dstPos is greather or equal to than 16"); [EOL]     } [EOL]     short out = dstInit; [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nBools; i++) { [EOL]         shift = i * 1 + dstPos; [EOL]         final int bits = (src[i + srcPos] ? 1 : 0) << shift; [EOL]         final int mask = 0x1 << shift; [EOL]         out = (short) ((out & ~mask) | bits); [EOL]     } [EOL]     return out; [EOL] }
public static byte[] longToByteArray(final long src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes) { [EOL]     if (0 == nBytes) { [EOL]         return dst; [EOL]     } [EOL]     if ((nBytes - 1) * 8 + srcPos >= 64) { [EOL]         throw new IllegalArgumentException("(nBytes-1)*8+srcPos is greather or equal to than 64"); [EOL]     } [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nBytes; i++) { [EOL]         shift = i * 8 + srcPos; [EOL]         dst[dstPos + i] = (byte) (0xff & (src >> shift)); [EOL]     } [EOL]     return dst; [EOL] }
public static byte[] longToByteArray(final long src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes) { [EOL]     if (0 == nBytes) { [EOL]         return dst; [EOL]     } [EOL]     if ((nBytes - 1) * 8 + srcPos >= 64) { [EOL]         throw new IllegalArgumentException("(nBytes-1)*8+srcPos is greather or equal to than 64"); [EOL]     } [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nBytes; i++) { [EOL]         shift = i * 8 + srcPos; [EOL]         dst[dstPos + i] = (byte) (0xff & (src >> shift)); [EOL]     } [EOL]     return dst; [EOL] }
public static byte[] shortToByteArray(final short src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes) { [EOL]     if (0 == nBytes) { [EOL]         return dst; [EOL]     } [EOL]     if ((nBytes - 1) * 8 + srcPos >= 16) { [EOL]         throw new IllegalArgumentException("(nBytes-1)*8+srcPos is greather or equal to than 16"); [EOL]     } [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nBytes; i++) { [EOL]         shift = i * 8 + srcPos; [EOL]         dst[dstPos + i] = (byte) (0xff & (src >> shift)); [EOL]     } [EOL]     return dst; [EOL] }
public static byte[] shortToByteArray(final short src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes) { [EOL]     if (0 == nBytes) { [EOL]         return dst; [EOL]     } [EOL]     if ((nBytes - 1) * 8 + srcPos >= 16) { [EOL]         throw new IllegalArgumentException("(nBytes-1)*8+srcPos is greather or equal to than 16"); [EOL]     } [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nBytes; i++) { [EOL]         shift = i * 8 + srcPos; [EOL]         dst[dstPos + i] = (byte) (0xff & (src >> shift)); [EOL]     } [EOL]     return dst; [EOL] }
public static UUID byteArrayToUuid(final byte[] src, final int srcPos) { [EOL]     if (src.length - srcPos < 16) { [EOL]         throw new IllegalArgumentException("Need at least 16 bytes for UUID"); [EOL]     } [EOL]     return new UUID(byteArrayToLong(src, srcPos, 0, 0, 8), byteArrayToLong(src, srcPos + 8, 0, 0, 8)); [EOL] }
public static final String escapeEcmaScript(final String input) { [EOL]     return ESCAPE_ECMASCRIPT.translate(input); [EOL] } public StringEscapeUtils(); public int translate(final CharSequence input, final int index, final Writer out) throws IOException; public int translate(final CharSequence input, final int index, final Writer out) throws IOException; public static final String escapeJava(final String input); public static final String escapeEcmaScript(final String input); public static final String escapeJson(final String input); public static final String unescapeJava(final String input); public static final String unescapeEcmaScript(final String input); public static final String unescapeJson(final String input); public static final String escapeHtml4(final String input); public static final String escapeHtml3(final String input); public static final String unescapeHtml4(final String input); public static final String unescapeHtml3(final String input); public static final String escapeXml(final String input); public static final String unescapeXml(final String input); public static final String escapeCsv(final String input); public static final String unescapeCsv(final String input); CharSequenceTranslator ESCAPE_JAVA=Optional[new LookupTranslator(new String[][] { { "\"", "\\\"" }, { "\\", "\\\\" } }).with(new LookupTranslator(EntityArrays.JAVA_CTRL_CHARS_ESCAPE())).with(JavaUnicodeEscaper.outsideOf(32, 0x7f))]; CharSequenceTranslator ESCAPE_ECMASCRIPT=Optional[new AggregateTranslator(new LookupTranslator(new String[][] { { "'", "\\'" }, { "\"", "\\\"" }, { "\\", "\\\\" }, { "/", "\\/" } }), new LookupTranslator(EntityArrays.JAVA_CTRL_CHARS_ESCAPE()), JavaUnicodeEscaper.outsideOf(32, 0x7f))]; CharSequenceTranslator ESCAPE_JSON=Optional[new AggregateTranslator(new LookupTranslator(new String[][] { { "\"", "\\\"" }, { "\\", "\\\\" }, { "/", "\\/" } }), new LookupTranslator(EntityArrays.JAVA_CTRL_CHARS_ESCAPE()), JavaUnicodeEscaper.outsideOf(32, 0x7f))]; CharSequenceTranslator ESCAPE_XML=Optional[new AggregateTranslator(new LookupTranslator(EntityArrays.BASIC_ESCAPE()), new LookupTranslator(EntityArrays.APOS_ESCAPE()))]; CharSequenceTranslator ESCAPE_HTML3=Optional[new AggregateTranslator(new LookupTranslator(EntityArrays.BASIC_ESCAPE()), new LookupTranslator(EntityArrays.ISO8859_1_ESCAPE()))]; CharSequenceTranslator ESCAPE_HTML4=Optional[new AggregateTranslator(new LookupTranslator(EntityArrays.BASIC_ESCAPE()), new LookupTranslator(EntityArrays.ISO8859_1_ESCAPE()), new LookupTranslator(EntityArrays.HTML40_EXTENDED_ESCAPE()))]; CharSequenceTranslator ESCAPE_CSV=Optional[new CsvEscaper()]; CharSequenceTranslator UNESCAPE_JAVA=Optional[new AggregateTranslator(// .between('\1', '\377'),; new OctalUnescaper(), new UnicodeUnescaper(), new LookupTranslator(EntityArrays.JAVA_CTRL_CHARS_UNESCAPE()), new LookupTranslator(new String[][] { { "\\\\", "\\" }, { "\\\"", "\"" }, { "\\'", "'" }, { "\\", "" } }
public static final String unescapeJava(final String input) { [EOL]     return UNESCAPE_JAVA.translate(input); [EOL] } public StringEscapeUtils(); public int translate(final CharSequence input, final int index, final Writer out) throws IOException; public int translate(final CharSequence input, final int index, final Writer out) throws IOException; public static final String escapeJava(final String input); public static final String escapeEcmaScript(final String input); public static final String escapeJson(final String input); public static final String unescapeJava(final String input); public static final String unescapeEcmaScript(final String input); public static final String unescapeJson(final String input); public static final String escapeHtml4(final String input); public static final String escapeHtml3(final String input); public static final String unescapeHtml4(final String input); public static final String unescapeHtml3(final String input); public static final String escapeXml(final String input); public static final String unescapeXml(final String input); public static final String escapeCsv(final String input); public static final String unescapeCsv(final String input); CharSequenceTranslator ESCAPE_JAVA=Optional[new LookupTranslator(new String[][] { { "\"", "\\\"" }, { "\\", "\\\\" } }).with(new LookupTranslator(EntityArrays.JAVA_CTRL_CHARS_ESCAPE())).with(JavaUnicodeEscaper.outsideOf(32, 0x7f))]; CharSequenceTranslator ESCAPE_ECMASCRIPT=Optional[new AggregateTranslator(new LookupTranslator(new String[][] { { "'", "\\'" }, { "\"", "\\\"" }, { "\\", "\\\\" }, { "/", "\\/" } }), new LookupTranslator(EntityArrays.JAVA_CTRL_CHARS_ESCAPE()), JavaUnicodeEscaper.outsideOf(32, 0x7f))]; CharSequenceTranslator ESCAPE_JSON=Optional[new AggregateTranslator(new LookupTranslator(new String[][] { { "\"", "\\\"" }, { "\\", "\\\\" }, { "/", "\\/" } }), new LookupTranslator(EntityArrays.JAVA_CTRL_CHARS_ESCAPE()), JavaUnicodeEscaper.outsideOf(32, 0x7f))]; CharSequenceTranslator ESCAPE_XML=Optional[new AggregateTranslator(new LookupTranslator(EntityArrays.BASIC_ESCAPE()), new LookupTranslator(EntityArrays.APOS_ESCAPE()))]; CharSequenceTranslator ESCAPE_HTML3=Optional[new AggregateTranslator(new LookupTranslator(EntityArrays.BASIC_ESCAPE()), new LookupTranslator(EntityArrays.ISO8859_1_ESCAPE()))]; CharSequenceTranslator ESCAPE_HTML4=Optional[new AggregateTranslator(new LookupTranslator(EntityArrays.BASIC_ESCAPE()), new LookupTranslator(EntityArrays.ISO8859_1_ESCAPE()), new LookupTranslator(EntityArrays.HTML40_EXTENDED_ESCAPE()))]; CharSequenceTranslator ESCAPE_CSV=Optional[new CsvEscaper()]; CharSequenceTranslator UNESCAPE_JAVA=Optional[new AggregateTranslator(// .between('\1', '\377'),; new OctalUnescaper(), new UnicodeUnescaper(), new LookupTranslator(EntityArrays.JAVA_CTRL_CHARS_UNESCAPE()), new LookupTranslator(new String[][] { { "\\\\", "\\" }, { "\\\"", "\"" }, { "\\'", "'" }, { "\\", "" } }
public static final String unescapeCsv(final String input) { [EOL]     return UNESCAPE_CSV.translate(input); [EOL] } public StringEscapeUtils(); public int translate(final CharSequence input, final int index, final Writer out) throws IOException; public int translate(final CharSequence input, final int index, final Writer out) throws IOException; public static final String escapeJava(final String input); public static final String escapeEcmaScript(final String input); public static final String escapeJson(final String input); public static final String unescapeJava(final String input); public static final String unescapeEcmaScript(final String input); public static final String unescapeJson(final String input); public static final String escapeHtml4(final String input); public static final String escapeHtml3(final String input); public static final String unescapeHtml4(final String input); public static final String unescapeHtml3(final String input); public static final String escapeXml(final String input); public static final String unescapeXml(final String input); public static final String escapeCsv(final String input); public static final String unescapeCsv(final String input); CharSequenceTranslator ESCAPE_JAVA=Optional[new LookupTranslator(new String[][] { { "\"", "\\\"" }, { "\\", "\\\\" } }).with(new LookupTranslator(EntityArrays.JAVA_CTRL_CHARS_ESCAPE())).with(JavaUnicodeEscaper.outsideOf(32, 0x7f))]; CharSequenceTranslator ESCAPE_ECMASCRIPT=Optional[new AggregateTranslator(new LookupTranslator(new String[][] { { "'", "\\'" }, { "\"", "\\\"" }, { "\\", "\\\\" }, { "/", "\\/" } }), new LookupTranslator(EntityArrays.JAVA_CTRL_CHARS_ESCAPE()), JavaUnicodeEscaper.outsideOf(32, 0x7f))]; CharSequenceTranslator ESCAPE_JSON=Optional[new AggregateTranslator(new LookupTranslator(new String[][] { { "\"", "\\\"" }, { "\\", "\\\\" }, { "/", "\\/" } }), new LookupTranslator(EntityArrays.JAVA_CTRL_CHARS_ESCAPE()), JavaUnicodeEscaper.outsideOf(32, 0x7f))]; CharSequenceTranslator ESCAPE_XML=Optional[new AggregateTranslator(new LookupTranslator(EntityArrays.BASIC_ESCAPE()), new LookupTranslator(EntityArrays.APOS_ESCAPE()))]; CharSequenceTranslator ESCAPE_HTML3=Optional[new AggregateTranslator(new LookupTranslator(EntityArrays.BASIC_ESCAPE()), new LookupTranslator(EntityArrays.ISO8859_1_ESCAPE()))]; CharSequenceTranslator ESCAPE_HTML4=Optional[new AggregateTranslator(new LookupTranslator(EntityArrays.BASIC_ESCAPE()), new LookupTranslator(EntityArrays.ISO8859_1_ESCAPE()), new LookupTranslator(EntityArrays.HTML40_EXTENDED_ESCAPE()))]; CharSequenceTranslator ESCAPE_CSV=Optional[new CsvEscaper()]; CharSequenceTranslator UNESCAPE_JAVA=Optional[new AggregateTranslator(// .between('\1', '\377'),; new OctalUnescaper(), new UnicodeUnescaper(), new LookupTranslator(EntityArrays.JAVA_CTRL_CHARS_UNESCAPE()), new LookupTranslator(new String[][] { { "\\\\", "\\" }, { "\\\"", "\"" }, { "\\'", "'" }, { "\\", "" } }
