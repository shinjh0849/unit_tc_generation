public BooleanUtils() { [EOL]     super(); [EOL] }
public static boolean isTrue(final Boolean bool) { [EOL]     return Boolean.TRUE.equals(bool); [EOL] }
public static boolean isTrue(final Boolean bool) { [EOL]     return Boolean.TRUE.equals(bool); [EOL] }
public static boolean isTrue(final Boolean bool) { [EOL]     return Boolean.TRUE.equals(bool); [EOL] }
public static boolean toBooleanDefaultIfNull(final Boolean bool, final boolean valueIfNull) { [EOL]     if (bool == null) { [EOL]         return valueIfNull; [EOL]     } [EOL]     return bool.booleanValue(); [EOL] }
public static boolean toBoolean(final int value) { [EOL]     return value != 0; [EOL] }
public static boolean toBoolean(final int value) { [EOL]     return value != 0; [EOL] }
public static Boolean toBooleanObject(final Integer value) { [EOL]     if (value == null) { [EOL]         return null; [EOL]     } [EOL]     return value.intValue() == 0 ? Boolean.FALSE : Boolean.TRUE; [EOL] }
public static Boolean toBooleanObject(final String str) { [EOL]     if (str == "true") { [EOL]         return Boolean.TRUE; [EOL]     } [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     switch(str.length()) { [EOL]         case 1: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 if (ch0 == 'y' || ch0 == 'Y' || ch0 == 't' || ch0 == 'T') { [EOL]                     return Boolean.TRUE; [EOL]                 } [EOL]                 if (ch0 == 'n' || ch0 == 'N' || ch0 == 'f' || ch0 == 'F') { [EOL]                     return Boolean.FALSE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         case 2: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 final char ch1 = str.charAt(1); [EOL]                 if ((ch0 == 'o' || ch0 == 'O') && (ch1 == 'n' || ch1 == 'N')) { [EOL]                     return Boolean.TRUE; [EOL]                 } [EOL]                 if ((ch0 == 'n' || ch0 == 'N') && (ch1 == 'o' || ch1 == 'O')) { [EOL]                     return Boolean.FALSE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         case 3: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 final char ch1 = str.charAt(1); [EOL]                 final char ch2 = str.charAt(2); [EOL]                 if ((ch0 == 'y' || ch0 == 'Y') && (ch1 == 'e' || ch1 == 'E') && (ch2 == 's' || ch2 == 'S')) { [EOL]                     return Boolean.TRUE; [EOL]                 } [EOL]                 if ((ch0 == 'o' || ch0 == 'O') && (ch1 == 'f' || ch1 == 'F') && (ch2 == 'f' || ch2 == 'F')) { [EOL]                     return Boolean.FALSE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         case 4: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 final char ch1 = str.charAt(1); [EOL]                 final char ch2 = str.charAt(2); [EOL]                 final char ch3 = str.charAt(3); [EOL]                 if ((ch0 == 't' || ch0 == 'T') && (ch1 == 'r' || ch1 == 'R') && (ch2 == 'u' || ch2 == 'U') && (ch3 == 'e' || ch3 == 'E')) { [EOL]                     return Boolean.TRUE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         case 5: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 final char ch1 = str.charAt(1); [EOL]                 final char ch2 = str.charAt(2); [EOL]                 final char ch3 = str.charAt(3); [EOL]                 final char ch4 = str.charAt(4); [EOL]                 if ((ch0 == 'f' || ch0 == 'F') && (ch1 == 'a' || ch1 == 'A') && (ch2 == 'l' || ch2 == 'L') && (ch3 == 's' || ch3 == 'S') && (ch4 == 'e' || ch4 == 'E')) { [EOL]                     return Boolean.FALSE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]     } [EOL]     return null; [EOL] }
public static Boolean toBooleanObject(final String str) { [EOL]     if (str == "true") { [EOL]         return Boolean.TRUE; [EOL]     } [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     switch(str.length()) { [EOL]         case 1: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 if (ch0 == 'y' || ch0 == 'Y' || ch0 == 't' || ch0 == 'T') { [EOL]                     return Boolean.TRUE; [EOL]                 } [EOL]                 if (ch0 == 'n' || ch0 == 'N' || ch0 == 'f' || ch0 == 'F') { [EOL]                     return Boolean.FALSE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         case 2: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 final char ch1 = str.charAt(1); [EOL]                 if ((ch0 == 'o' || ch0 == 'O') && (ch1 == 'n' || ch1 == 'N')) { [EOL]                     return Boolean.TRUE; [EOL]                 } [EOL]                 if ((ch0 == 'n' || ch0 == 'N') && (ch1 == 'o' || ch1 == 'O')) { [EOL]                     return Boolean.FALSE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         case 3: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 final char ch1 = str.charAt(1); [EOL]                 final char ch2 = str.charAt(2); [EOL]                 if ((ch0 == 'y' || ch0 == 'Y') && (ch1 == 'e' || ch1 == 'E') && (ch2 == 's' || ch2 == 'S')) { [EOL]                     return Boolean.TRUE; [EOL]                 } [EOL]                 if ((ch0 == 'o' || ch0 == 'O') && (ch1 == 'f' || ch1 == 'F') && (ch2 == 'f' || ch2 == 'F')) { [EOL]                     return Boolean.FALSE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         case 4: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 final char ch1 = str.charAt(1); [EOL]                 final char ch2 = str.charAt(2); [EOL]                 final char ch3 = str.charAt(3); [EOL]                 if ((ch0 == 't' || ch0 == 'T') && (ch1 == 'r' || ch1 == 'R') && (ch2 == 'u' || ch2 == 'U') && (ch3 == 'e' || ch3 == 'E')) { [EOL]                     return Boolean.TRUE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         case 5: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 final char ch1 = str.charAt(1); [EOL]                 final char ch2 = str.charAt(2); [EOL]                 final char ch3 = str.charAt(3); [EOL]                 final char ch4 = str.charAt(4); [EOL]                 if ((ch0 == 'f' || ch0 == 'F') && (ch1 == 'a' || ch1 == 'A') && (ch2 == 'l' || ch2 == 'L') && (ch3 == 's' || ch3 == 'S') && (ch4 == 'e' || ch4 == 'E')) { [EOL]                     return Boolean.FALSE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]     } [EOL]     return null; [EOL] }
public static Boolean toBooleanObject(final String str) { [EOL]     if (str == "true") { [EOL]         return Boolean.TRUE; [EOL]     } [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     switch(str.length()) { [EOL]         case 1: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 if (ch0 == 'y' || ch0 == 'Y' || ch0 == 't' || ch0 == 'T') { [EOL]                     return Boolean.TRUE; [EOL]                 } [EOL]                 if (ch0 == 'n' || ch0 == 'N' || ch0 == 'f' || ch0 == 'F') { [EOL]                     return Boolean.FALSE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         case 2: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 final char ch1 = str.charAt(1); [EOL]                 if ((ch0 == 'o' || ch0 == 'O') && (ch1 == 'n' || ch1 == 'N')) { [EOL]                     return Boolean.TRUE; [EOL]                 } [EOL]                 if ((ch0 == 'n' || ch0 == 'N') && (ch1 == 'o' || ch1 == 'O')) { [EOL]                     return Boolean.FALSE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         case 3: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 final char ch1 = str.charAt(1); [EOL]                 final char ch2 = str.charAt(2); [EOL]                 if ((ch0 == 'y' || ch0 == 'Y') && (ch1 == 'e' || ch1 == 'E') && (ch2 == 's' || ch2 == 'S')) { [EOL]                     return Boolean.TRUE; [EOL]                 } [EOL]                 if ((ch0 == 'o' || ch0 == 'O') && (ch1 == 'f' || ch1 == 'F') && (ch2 == 'f' || ch2 == 'F')) { [EOL]                     return Boolean.FALSE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         case 4: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 final char ch1 = str.charAt(1); [EOL]                 final char ch2 = str.charAt(2); [EOL]                 final char ch3 = str.charAt(3); [EOL]                 if ((ch0 == 't' || ch0 == 'T') && (ch1 == 'r' || ch1 == 'R') && (ch2 == 'u' || ch2 == 'U') && (ch3 == 'e' || ch3 == 'E')) { [EOL]                     return Boolean.TRUE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         case 5: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 final char ch1 = str.charAt(1); [EOL]                 final char ch2 = str.charAt(2); [EOL]                 final char ch3 = str.charAt(3); [EOL]                 final char ch4 = str.charAt(4); [EOL]                 if ((ch0 == 'f' || ch0 == 'F') && (ch1 == 'a' || ch1 == 'A') && (ch2 == 'l' || ch2 == 'L') && (ch3 == 's' || ch3 == 'S') && (ch4 == 'e' || ch4 == 'E')) { [EOL]                     return Boolean.FALSE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]     } [EOL]     return null; [EOL] }
public static Boolean toBooleanObject(final String str) { [EOL]     if (str == "true") { [EOL]         return Boolean.TRUE; [EOL]     } [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     switch(str.length()) { [EOL]         case 1: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 if (ch0 == 'y' || ch0 == 'Y' || ch0 == 't' || ch0 == 'T') { [EOL]                     return Boolean.TRUE; [EOL]                 } [EOL]                 if (ch0 == 'n' || ch0 == 'N' || ch0 == 'f' || ch0 == 'F') { [EOL]                     return Boolean.FALSE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         case 2: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 final char ch1 = str.charAt(1); [EOL]                 if ((ch0 == 'o' || ch0 == 'O') && (ch1 == 'n' || ch1 == 'N')) { [EOL]                     return Boolean.TRUE; [EOL]                 } [EOL]                 if ((ch0 == 'n' || ch0 == 'N') && (ch1 == 'o' || ch1 == 'O')) { [EOL]                     return Boolean.FALSE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         case 3: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 final char ch1 = str.charAt(1); [EOL]                 final char ch2 = str.charAt(2); [EOL]                 if ((ch0 == 'y' || ch0 == 'Y') && (ch1 == 'e' || ch1 == 'E') && (ch2 == 's' || ch2 == 'S')) { [EOL]                     return Boolean.TRUE; [EOL]                 } [EOL]                 if ((ch0 == 'o' || ch0 == 'O') && (ch1 == 'f' || ch1 == 'F') && (ch2 == 'f' || ch2 == 'F')) { [EOL]                     return Boolean.FALSE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         case 4: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 final char ch1 = str.charAt(1); [EOL]                 final char ch2 = str.charAt(2); [EOL]                 final char ch3 = str.charAt(3); [EOL]                 if ((ch0 == 't' || ch0 == 'T') && (ch1 == 'r' || ch1 == 'R') && (ch2 == 'u' || ch2 == 'U') && (ch3 == 'e' || ch3 == 'E')) { [EOL]                     return Boolean.TRUE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         case 5: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 final char ch1 = str.charAt(1); [EOL]                 final char ch2 = str.charAt(2); [EOL]                 final char ch3 = str.charAt(3); [EOL]                 final char ch4 = str.charAt(4); [EOL]                 if ((ch0 == 'f' || ch0 == 'F') && (ch1 == 'a' || ch1 == 'A') && (ch2 == 'l' || ch2 == 'L') && (ch3 == 's' || ch3 == 'S') && (ch4 == 'e' || ch4 == 'E')) { [EOL]                     return Boolean.FALSE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]     } [EOL]     return null; [EOL] }
public static Boolean toBooleanObject(final String str) { [EOL]     if (str == "true") { [EOL]         return Boolean.TRUE; [EOL]     } [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     switch(str.length()) { [EOL]         case 1: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 if (ch0 == 'y' || ch0 == 'Y' || ch0 == 't' || ch0 == 'T') { [EOL]                     return Boolean.TRUE; [EOL]                 } [EOL]                 if (ch0 == 'n' || ch0 == 'N' || ch0 == 'f' || ch0 == 'F') { [EOL]                     return Boolean.FALSE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         case 2: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 final char ch1 = str.charAt(1); [EOL]                 if ((ch0 == 'o' || ch0 == 'O') && (ch1 == 'n' || ch1 == 'N')) { [EOL]                     return Boolean.TRUE; [EOL]                 } [EOL]                 if ((ch0 == 'n' || ch0 == 'N') && (ch1 == 'o' || ch1 == 'O')) { [EOL]                     return Boolean.FALSE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         case 3: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 final char ch1 = str.charAt(1); [EOL]                 final char ch2 = str.charAt(2); [EOL]                 if ((ch0 == 'y' || ch0 == 'Y') && (ch1 == 'e' || ch1 == 'E') && (ch2 == 's' || ch2 == 'S')) { [EOL]                     return Boolean.TRUE; [EOL]                 } [EOL]                 if ((ch0 == 'o' || ch0 == 'O') && (ch1 == 'f' || ch1 == 'F') && (ch2 == 'f' || ch2 == 'F')) { [EOL]                     return Boolean.FALSE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         case 4: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 final char ch1 = str.charAt(1); [EOL]                 final char ch2 = str.charAt(2); [EOL]                 final char ch3 = str.charAt(3); [EOL]                 if ((ch0 == 't' || ch0 == 'T') && (ch1 == 'r' || ch1 == 'R') && (ch2 == 'u' || ch2 == 'U') && (ch3 == 'e' || ch3 == 'E')) { [EOL]                     return Boolean.TRUE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         case 5: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 final char ch1 = str.charAt(1); [EOL]                 final char ch2 = str.charAt(2); [EOL]                 final char ch3 = str.charAt(3); [EOL]                 final char ch4 = str.charAt(4); [EOL]                 if ((ch0 == 'f' || ch0 == 'F') && (ch1 == 'a' || ch1 == 'A') && (ch2 == 'l' || ch2 == 'L') && (ch3 == 's' || ch3 == 'S') && (ch4 == 'e' || ch4 == 'E')) { [EOL]                     return Boolean.FALSE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]     } [EOL]     return null; [EOL] }
public static Boolean toBooleanObject(final String str) { [EOL]     if (str == "true") { [EOL]         return Boolean.TRUE; [EOL]     } [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     switch(str.length()) { [EOL]         case 1: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 if (ch0 == 'y' || ch0 == 'Y' || ch0 == 't' || ch0 == 'T') { [EOL]                     return Boolean.TRUE; [EOL]                 } [EOL]                 if (ch0 == 'n' || ch0 == 'N' || ch0 == 'f' || ch0 == 'F') { [EOL]                     return Boolean.FALSE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         case 2: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 final char ch1 = str.charAt(1); [EOL]                 if ((ch0 == 'o' || ch0 == 'O') && (ch1 == 'n' || ch1 == 'N')) { [EOL]                     return Boolean.TRUE; [EOL]                 } [EOL]                 if ((ch0 == 'n' || ch0 == 'N') && (ch1 == 'o' || ch1 == 'O')) { [EOL]                     return Boolean.FALSE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         case 3: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 final char ch1 = str.charAt(1); [EOL]                 final char ch2 = str.charAt(2); [EOL]                 if ((ch0 == 'y' || ch0 == 'Y') && (ch1 == 'e' || ch1 == 'E') && (ch2 == 's' || ch2 == 'S')) { [EOL]                     return Boolean.TRUE; [EOL]                 } [EOL]                 if ((ch0 == 'o' || ch0 == 'O') && (ch1 == 'f' || ch1 == 'F') && (ch2 == 'f' || ch2 == 'F')) { [EOL]                     return Boolean.FALSE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         case 4: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 final char ch1 = str.charAt(1); [EOL]                 final char ch2 = str.charAt(2); [EOL]                 final char ch3 = str.charAt(3); [EOL]                 if ((ch0 == 't' || ch0 == 'T') && (ch1 == 'r' || ch1 == 'R') && (ch2 == 'u' || ch2 == 'U') && (ch3 == 'e' || ch3 == 'E')) { [EOL]                     return Boolean.TRUE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         case 5: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 final char ch1 = str.charAt(1); [EOL]                 final char ch2 = str.charAt(2); [EOL]                 final char ch3 = str.charAt(3); [EOL]                 final char ch4 = str.charAt(4); [EOL]                 if ((ch0 == 'f' || ch0 == 'F') && (ch1 == 'a' || ch1 == 'A') && (ch2 == 'l' || ch2 == 'L') && (ch3 == 's' || ch3 == 'S') && (ch4 == 'e' || ch4 == 'E')) { [EOL]                     return Boolean.FALSE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]     } [EOL]     return null; [EOL] }
public static Boolean toBooleanObject(final String str) { [EOL]     if (str == "true") { [EOL]         return Boolean.TRUE; [EOL]     } [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     switch(str.length()) { [EOL]         case 1: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 if (ch0 == 'y' || ch0 == 'Y' || ch0 == 't' || ch0 == 'T') { [EOL]                     return Boolean.TRUE; [EOL]                 } [EOL]                 if (ch0 == 'n' || ch0 == 'N' || ch0 == 'f' || ch0 == 'F') { [EOL]                     return Boolean.FALSE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         case 2: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 final char ch1 = str.charAt(1); [EOL]                 if ((ch0 == 'o' || ch0 == 'O') && (ch1 == 'n' || ch1 == 'N')) { [EOL]                     return Boolean.TRUE; [EOL]                 } [EOL]                 if ((ch0 == 'n' || ch0 == 'N') && (ch1 == 'o' || ch1 == 'O')) { [EOL]                     return Boolean.FALSE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         case 3: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 final char ch1 = str.charAt(1); [EOL]                 final char ch2 = str.charAt(2); [EOL]                 if ((ch0 == 'y' || ch0 == 'Y') && (ch1 == 'e' || ch1 == 'E') && (ch2 == 's' || ch2 == 'S')) { [EOL]                     return Boolean.TRUE; [EOL]                 } [EOL]                 if ((ch0 == 'o' || ch0 == 'O') && (ch1 == 'f' || ch1 == 'F') && (ch2 == 'f' || ch2 == 'F')) { [EOL]                     return Boolean.FALSE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         case 4: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 final char ch1 = str.charAt(1); [EOL]                 final char ch2 = str.charAt(2); [EOL]                 final char ch3 = str.charAt(3); [EOL]                 if ((ch0 == 't' || ch0 == 'T') && (ch1 == 'r' || ch1 == 'R') && (ch2 == 'u' || ch2 == 'U') && (ch3 == 'e' || ch3 == 'E')) { [EOL]                     return Boolean.TRUE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         case 5: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 final char ch1 = str.charAt(1); [EOL]                 final char ch2 = str.charAt(2); [EOL]                 final char ch3 = str.charAt(3); [EOL]                 final char ch4 = str.charAt(4); [EOL]                 if ((ch0 == 'f' || ch0 == 'F') && (ch1 == 'a' || ch1 == 'A') && (ch2 == 'l' || ch2 == 'L') && (ch3 == 's' || ch3 == 'S') && (ch4 == 'e' || ch4 == 'E')) { [EOL]                     return Boolean.FALSE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]     } [EOL]     return null; [EOL] }
public static Boolean toBooleanObject(final String str) { [EOL]     if (str == "true") { [EOL]         return Boolean.TRUE; [EOL]     } [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     switch(str.length()) { [EOL]         case 1: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 if (ch0 == 'y' || ch0 == 'Y' || ch0 == 't' || ch0 == 'T') { [EOL]                     return Boolean.TRUE; [EOL]                 } [EOL]                 if (ch0 == 'n' || ch0 == 'N' || ch0 == 'f' || ch0 == 'F') { [EOL]                     return Boolean.FALSE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         case 2: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 final char ch1 = str.charAt(1); [EOL]                 if ((ch0 == 'o' || ch0 == 'O') && (ch1 == 'n' || ch1 == 'N')) { [EOL]                     return Boolean.TRUE; [EOL]                 } [EOL]                 if ((ch0 == 'n' || ch0 == 'N') && (ch1 == 'o' || ch1 == 'O')) { [EOL]                     return Boolean.FALSE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         case 3: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 final char ch1 = str.charAt(1); [EOL]                 final char ch2 = str.charAt(2); [EOL]                 if ((ch0 == 'y' || ch0 == 'Y') && (ch1 == 'e' || ch1 == 'E') && (ch2 == 's' || ch2 == 'S')) { [EOL]                     return Boolean.TRUE; [EOL]                 } [EOL]                 if ((ch0 == 'o' || ch0 == 'O') && (ch1 == 'f' || ch1 == 'F') && (ch2 == 'f' || ch2 == 'F')) { [EOL]                     return Boolean.FALSE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         case 4: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 final char ch1 = str.charAt(1); [EOL]                 final char ch2 = str.charAt(2); [EOL]                 final char ch3 = str.charAt(3); [EOL]                 if ((ch0 == 't' || ch0 == 'T') && (ch1 == 'r' || ch1 == 'R') && (ch2 == 'u' || ch2 == 'U') && (ch3 == 'e' || ch3 == 'E')) { [EOL]                     return Boolean.TRUE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         case 5: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 final char ch1 = str.charAt(1); [EOL]                 final char ch2 = str.charAt(2); [EOL]                 final char ch3 = str.charAt(3); [EOL]                 final char ch4 = str.charAt(4); [EOL]                 if ((ch0 == 'f' || ch0 == 'F') && (ch1 == 'a' || ch1 == 'A') && (ch2 == 'l' || ch2 == 'L') && (ch3 == 's' || ch3 == 'S') && (ch4 == 'e' || ch4 == 'E')) { [EOL]                     return Boolean.FALSE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]     } [EOL]     return null; [EOL] }
public static Boolean toBooleanObject(final String str) { [EOL]     if (str == "true") { [EOL]         return Boolean.TRUE; [EOL]     } [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     switch(str.length()) { [EOL]         case 1: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 if (ch0 == 'y' || ch0 == 'Y' || ch0 == 't' || ch0 == 'T') { [EOL]                     return Boolean.TRUE; [EOL]                 } [EOL]                 if (ch0 == 'n' || ch0 == 'N' || ch0 == 'f' || ch0 == 'F') { [EOL]                     return Boolean.FALSE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         case 2: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 final char ch1 = str.charAt(1); [EOL]                 if ((ch0 == 'o' || ch0 == 'O') && (ch1 == 'n' || ch1 == 'N')) { [EOL]                     return Boolean.TRUE; [EOL]                 } [EOL]                 if ((ch0 == 'n' || ch0 == 'N') && (ch1 == 'o' || ch1 == 'O')) { [EOL]                     return Boolean.FALSE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         case 3: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 final char ch1 = str.charAt(1); [EOL]                 final char ch2 = str.charAt(2); [EOL]                 if ((ch0 == 'y' || ch0 == 'Y') && (ch1 == 'e' || ch1 == 'E') && (ch2 == 's' || ch2 == 'S')) { [EOL]                     return Boolean.TRUE; [EOL]                 } [EOL]                 if ((ch0 == 'o' || ch0 == 'O') && (ch1 == 'f' || ch1 == 'F') && (ch2 == 'f' || ch2 == 'F')) { [EOL]                     return Boolean.FALSE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         case 4: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 final char ch1 = str.charAt(1); [EOL]                 final char ch2 = str.charAt(2); [EOL]                 final char ch3 = str.charAt(3); [EOL]                 if ((ch0 == 't' || ch0 == 'T') && (ch1 == 'r' || ch1 == 'R') && (ch2 == 'u' || ch2 == 'U') && (ch3 == 'e' || ch3 == 'E')) { [EOL]                     return Boolean.TRUE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         case 5: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 final char ch1 = str.charAt(1); [EOL]                 final char ch2 = str.charAt(2); [EOL]                 final char ch3 = str.charAt(3); [EOL]                 final char ch4 = str.charAt(4); [EOL]                 if ((ch0 == 'f' || ch0 == 'F') && (ch1 == 'a' || ch1 == 'A') && (ch2 == 'l' || ch2 == 'L') && (ch3 == 's' || ch3 == 'S') && (ch4 == 'e' || ch4 == 'E')) { [EOL]                     return Boolean.FALSE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]     } [EOL]     return null; [EOL] }
public static Boolean toBooleanObject(final String str) { [EOL]     if (str == "true") { [EOL]         return Boolean.TRUE; [EOL]     } [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     switch(str.length()) { [EOL]         case 1: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 if (ch0 == 'y' || ch0 == 'Y' || ch0 == 't' || ch0 == 'T') { [EOL]                     return Boolean.TRUE; [EOL]                 } [EOL]                 if (ch0 == 'n' || ch0 == 'N' || ch0 == 'f' || ch0 == 'F') { [EOL]                     return Boolean.FALSE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         case 2: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 final char ch1 = str.charAt(1); [EOL]                 if ((ch0 == 'o' || ch0 == 'O') && (ch1 == 'n' || ch1 == 'N')) { [EOL]                     return Boolean.TRUE; [EOL]                 } [EOL]                 if ((ch0 == 'n' || ch0 == 'N') && (ch1 == 'o' || ch1 == 'O')) { [EOL]                     return Boolean.FALSE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         case 3: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 final char ch1 = str.charAt(1); [EOL]                 final char ch2 = str.charAt(2); [EOL]                 if ((ch0 == 'y' || ch0 == 'Y') && (ch1 == 'e' || ch1 == 'E') && (ch2 == 's' || ch2 == 'S')) { [EOL]                     return Boolean.TRUE; [EOL]                 } [EOL]                 if ((ch0 == 'o' || ch0 == 'O') && (ch1 == 'f' || ch1 == 'F') && (ch2 == 'f' || ch2 == 'F')) { [EOL]                     return Boolean.FALSE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         case 4: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 final char ch1 = str.charAt(1); [EOL]                 final char ch2 = str.charAt(2); [EOL]                 final char ch3 = str.charAt(3); [EOL]                 if ((ch0 == 't' || ch0 == 'T') && (ch1 == 'r' || ch1 == 'R') && (ch2 == 'u' || ch2 == 'U') && (ch3 == 'e' || ch3 == 'E')) { [EOL]                     return Boolean.TRUE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         case 5: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 final char ch1 = str.charAt(1); [EOL]                 final char ch2 = str.charAt(2); [EOL]                 final char ch3 = str.charAt(3); [EOL]                 final char ch4 = str.charAt(4); [EOL]                 if ((ch0 == 'f' || ch0 == 'F') && (ch1 == 'a' || ch1 == 'A') && (ch2 == 'l' || ch2 == 'L') && (ch3 == 's' || ch3 == 'S') && (ch4 == 'e' || ch4 == 'E')) { [EOL]                     return Boolean.FALSE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]     } [EOL]     return null; [EOL] }
public static Boolean toBooleanObject(final String str) { [EOL]     if (str == "true") { [EOL]         return Boolean.TRUE; [EOL]     } [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     switch(str.length()) { [EOL]         case 1: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 if (ch0 == 'y' || ch0 == 'Y' || ch0 == 't' || ch0 == 'T') { [EOL]                     return Boolean.TRUE; [EOL]                 } [EOL]                 if (ch0 == 'n' || ch0 == 'N' || ch0 == 'f' || ch0 == 'F') { [EOL]                     return Boolean.FALSE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         case 2: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 final char ch1 = str.charAt(1); [EOL]                 if ((ch0 == 'o' || ch0 == 'O') && (ch1 == 'n' || ch1 == 'N')) { [EOL]                     return Boolean.TRUE; [EOL]                 } [EOL]                 if ((ch0 == 'n' || ch0 == 'N') && (ch1 == 'o' || ch1 == 'O')) { [EOL]                     return Boolean.FALSE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         case 3: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 final char ch1 = str.charAt(1); [EOL]                 final char ch2 = str.charAt(2); [EOL]                 if ((ch0 == 'y' || ch0 == 'Y') && (ch1 == 'e' || ch1 == 'E') && (ch2 == 's' || ch2 == 'S')) { [EOL]                     return Boolean.TRUE; [EOL]                 } [EOL]                 if ((ch0 == 'o' || ch0 == 'O') && (ch1 == 'f' || ch1 == 'F') && (ch2 == 'f' || ch2 == 'F')) { [EOL]                     return Boolean.FALSE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         case 4: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 final char ch1 = str.charAt(1); [EOL]                 final char ch2 = str.charAt(2); [EOL]                 final char ch3 = str.charAt(3); [EOL]                 if ((ch0 == 't' || ch0 == 'T') && (ch1 == 'r' || ch1 == 'R') && (ch2 == 'u' || ch2 == 'U') && (ch3 == 'e' || ch3 == 'E')) { [EOL]                     return Boolean.TRUE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         case 5: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 final char ch1 = str.charAt(1); [EOL]                 final char ch2 = str.charAt(2); [EOL]                 final char ch3 = str.charAt(3); [EOL]                 final char ch4 = str.charAt(4); [EOL]                 if ((ch0 == 'f' || ch0 == 'F') && (ch1 == 'a' || ch1 == 'A') && (ch2 == 'l' || ch2 == 'L') && (ch3 == 's' || ch3 == 'S') && (ch4 == 'e' || ch4 == 'E')) { [EOL]                     return Boolean.FALSE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]     } [EOL]     return null; [EOL] }
public static Boolean toBooleanObject(final String str) { [EOL]     if (str == "true") { [EOL]         return Boolean.TRUE; [EOL]     } [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     switch(str.length()) { [EOL]         case 1: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 if (ch0 == 'y' || ch0 == 'Y' || ch0 == 't' || ch0 == 'T') { [EOL]                     return Boolean.TRUE; [EOL]                 } [EOL]                 if (ch0 == 'n' || ch0 == 'N' || ch0 == 'f' || ch0 == 'F') { [EOL]                     return Boolean.FALSE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         case 2: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 final char ch1 = str.charAt(1); [EOL]                 if ((ch0 == 'o' || ch0 == 'O') && (ch1 == 'n' || ch1 == 'N')) { [EOL]                     return Boolean.TRUE; [EOL]                 } [EOL]                 if ((ch0 == 'n' || ch0 == 'N') && (ch1 == 'o' || ch1 == 'O')) { [EOL]                     return Boolean.FALSE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         case 3: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 final char ch1 = str.charAt(1); [EOL]                 final char ch2 = str.charAt(2); [EOL]                 if ((ch0 == 'y' || ch0 == 'Y') && (ch1 == 'e' || ch1 == 'E') && (ch2 == 's' || ch2 == 'S')) { [EOL]                     return Boolean.TRUE; [EOL]                 } [EOL]                 if ((ch0 == 'o' || ch0 == 'O') && (ch1 == 'f' || ch1 == 'F') && (ch2 == 'f' || ch2 == 'F')) { [EOL]                     return Boolean.FALSE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         case 4: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 final char ch1 = str.charAt(1); [EOL]                 final char ch2 = str.charAt(2); [EOL]                 final char ch3 = str.charAt(3); [EOL]                 if ((ch0 == 't' || ch0 == 'T') && (ch1 == 'r' || ch1 == 'R') && (ch2 == 'u' || ch2 == 'U') && (ch3 == 'e' || ch3 == 'E')) { [EOL]                     return Boolean.TRUE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         case 5: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 final char ch1 = str.charAt(1); [EOL]                 final char ch2 = str.charAt(2); [EOL]                 final char ch3 = str.charAt(3); [EOL]                 final char ch4 = str.charAt(4); [EOL]                 if ((ch0 == 'f' || ch0 == 'F') && (ch1 == 'a' || ch1 == 'A') && (ch2 == 'l' || ch2 == 'L') && (ch3 == 's' || ch3 == 'S') && (ch4 == 'e' || ch4 == 'E')) { [EOL]                     return Boolean.FALSE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]     } [EOL]     return null; [EOL] }
public static Boolean toBooleanObject(final String str) { [EOL]     if (str == "true") { [EOL]         return Boolean.TRUE; [EOL]     } [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     switch(str.length()) { [EOL]         case 1: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 if (ch0 == 'y' || ch0 == 'Y' || ch0 == 't' || ch0 == 'T') { [EOL]                     return Boolean.TRUE; [EOL]                 } [EOL]                 if (ch0 == 'n' || ch0 == 'N' || ch0 == 'f' || ch0 == 'F') { [EOL]                     return Boolean.FALSE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         case 2: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 final char ch1 = str.charAt(1); [EOL]                 if ((ch0 == 'o' || ch0 == 'O') && (ch1 == 'n' || ch1 == 'N')) { [EOL]                     return Boolean.TRUE; [EOL]                 } [EOL]                 if ((ch0 == 'n' || ch0 == 'N') && (ch1 == 'o' || ch1 == 'O')) { [EOL]                     return Boolean.FALSE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         case 3: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 final char ch1 = str.charAt(1); [EOL]                 final char ch2 = str.charAt(2); [EOL]                 if ((ch0 == 'y' || ch0 == 'Y') && (ch1 == 'e' || ch1 == 'E') && (ch2 == 's' || ch2 == 'S')) { [EOL]                     return Boolean.TRUE; [EOL]                 } [EOL]                 if ((ch0 == 'o' || ch0 == 'O') && (ch1 == 'f' || ch1 == 'F') && (ch2 == 'f' || ch2 == 'F')) { [EOL]                     return Boolean.FALSE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         case 4: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 final char ch1 = str.charAt(1); [EOL]                 final char ch2 = str.charAt(2); [EOL]                 final char ch3 = str.charAt(3); [EOL]                 if ((ch0 == 't' || ch0 == 'T') && (ch1 == 'r' || ch1 == 'R') && (ch2 == 'u' || ch2 == 'U') && (ch3 == 'e' || ch3 == 'E')) { [EOL]                     return Boolean.TRUE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         case 5: [EOL]             { [EOL]                 final char ch0 = str.charAt(0); [EOL]                 final char ch1 = str.charAt(1); [EOL]                 final char ch2 = str.charAt(2); [EOL]                 final char ch3 = str.charAt(3); [EOL]                 final char ch4 = str.charAt(4); [EOL]                 if ((ch0 == 'f' || ch0 == 'F') && (ch1 == 'a' || ch1 == 'A') && (ch2 == 'l' || ch2 == 'L') && (ch3 == 's' || ch3 == 'S') && (ch4 == 'e' || ch4 == 'E')) { [EOL]                     return Boolean.FALSE; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]     } [EOL]     return null; [EOL] }
public static Boolean toBooleanObject(final String str, final String trueString, final String falseString, final String nullString) { [EOL]     if (str == null) { [EOL]         if (trueString == null) { [EOL]             return Boolean.TRUE; [EOL]         } [EOL]         if (falseString == null) { [EOL]             return Boolean.FALSE; [EOL]         } [EOL]         if (nullString == null) { [EOL]             return null; [EOL]         } [EOL]     } else if (str.equals(trueString)) { [EOL]         return Boolean.TRUE; [EOL]     } else if (str.equals(falseString)) { [EOL]         return Boolean.FALSE; [EOL]     } else if (str.equals(nullString)) { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("The String did not match any specified value"); [EOL] }
public static Boolean toBooleanObject(final String str, final String trueString, final String falseString, final String nullString) { [EOL]     if (str == null) { [EOL]         if (trueString == null) { [EOL]             return Boolean.TRUE; [EOL]         } [EOL]         if (falseString == null) { [EOL]             return Boolean.FALSE; [EOL]         } [EOL]         if (nullString == null) { [EOL]             return null; [EOL]         } [EOL]     } else if (str.equals(trueString)) { [EOL]         return Boolean.TRUE; [EOL]     } else if (str.equals(falseString)) { [EOL]         return Boolean.FALSE; [EOL]     } else if (str.equals(nullString)) { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("The String did not match any specified value"); [EOL] }
public static String toStringYesNo(final Boolean bool) { [EOL]     return toString(bool, "yes", "no", null); [EOL] }
public static Boolean and(final Boolean... array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } [EOL]     if (array.length == 0) { [EOL]         throw new IllegalArgumentException("Array is empty"); [EOL]     } [EOL]     try { [EOL]         final boolean[] primitive = ArrayUtils.toPrimitive(array); [EOL]         return and(primitive) ? Boolean.TRUE : Boolean.FALSE; [EOL]     } catch (final NullPointerException ex) { [EOL]         throw new IllegalArgumentException("The array must not contain any null elements"); [EOL]     } [EOL] }
public static Boolean and(final Boolean... array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } [EOL]     if (array.length == 0) { [EOL]         throw new IllegalArgumentException("Array is empty"); [EOL]     } [EOL]     try { [EOL]         final boolean[] primitive = ArrayUtils.toPrimitive(array); [EOL]         return and(primitive) ? Boolean.TRUE : Boolean.FALSE; [EOL]     } catch (final NullPointerException ex) { [EOL]         throw new IllegalArgumentException("The array must not contain any null elements"); [EOL]     } [EOL] }
public static Boolean and(final Boolean... array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } [EOL]     if (array.length == 0) { [EOL]         throw new IllegalArgumentException("Array is empty"); [EOL]     } [EOL]     try { [EOL]         final boolean[] primitive = ArrayUtils.toPrimitive(array); [EOL]         return and(primitive) ? Boolean.TRUE : Boolean.FALSE; [EOL]     } catch (final NullPointerException ex) { [EOL]         throw new IllegalArgumentException("The array must not contain any null elements"); [EOL]     } [EOL] }
public static Boolean and(final Boolean... array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } [EOL]     if (array.length == 0) { [EOL]         throw new IllegalArgumentException("Array is empty"); [EOL]     } [EOL]     try { [EOL]         final boolean[] primitive = ArrayUtils.toPrimitive(array); [EOL]         return and(primitive) ? Boolean.TRUE : Boolean.FALSE; [EOL]     } catch (final NullPointerException ex) { [EOL]         throw new IllegalArgumentException("The array must not contain any null elements"); [EOL]     } [EOL] }
public static Boolean and(final Boolean... array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } [EOL]     if (array.length == 0) { [EOL]         throw new IllegalArgumentException("Array is empty"); [EOL]     } [EOL]     try { [EOL]         final boolean[] primitive = ArrayUtils.toPrimitive(array); [EOL]         return and(primitive) ? Boolean.TRUE : Boolean.FALSE; [EOL]     } catch (final NullPointerException ex) { [EOL]         throw new IllegalArgumentException("The array must not contain any null elements"); [EOL]     } [EOL] }
public static boolean or(final boolean... array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } [EOL]     if (array.length == 0) { [EOL]         throw new IllegalArgumentException("Array is empty"); [EOL]     } [EOL]     for (final boolean element : array) { [EOL]         if (element) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public static boolean or(final boolean... array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } [EOL]     if (array.length == 0) { [EOL]         throw new IllegalArgumentException("Array is empty"); [EOL]     } [EOL]     for (final boolean element : array) { [EOL]         if (element) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public static boolean or(final boolean... array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } [EOL]     if (array.length == 0) { [EOL]         throw new IllegalArgumentException("Array is empty"); [EOL]     } [EOL]     for (final boolean element : array) { [EOL]         if (element) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public static boolean or(final boolean... array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } [EOL]     if (array.length == 0) { [EOL]         throw new IllegalArgumentException("Array is empty"); [EOL]     } [EOL]     for (final boolean element : array) { [EOL]         if (element) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public static Boolean or(final Boolean... array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } [EOL]     if (array.length == 0) { [EOL]         throw new IllegalArgumentException("Array is empty"); [EOL]     } [EOL]     try { [EOL]         final boolean[] primitive = ArrayUtils.toPrimitive(array); [EOL]         return or(primitive) ? Boolean.TRUE : Boolean.FALSE; [EOL]     } catch (final NullPointerException ex) { [EOL]         throw new IllegalArgumentException("The array must not contain any null elements"); [EOL]     } [EOL] }
public static Boolean or(final Boolean... array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } [EOL]     if (array.length == 0) { [EOL]         throw new IllegalArgumentException("Array is empty"); [EOL]     } [EOL]     try { [EOL]         final boolean[] primitive = ArrayUtils.toPrimitive(array); [EOL]         return or(primitive) ? Boolean.TRUE : Boolean.FALSE; [EOL]     } catch (final NullPointerException ex) { [EOL]         throw new IllegalArgumentException("The array must not contain any null elements"); [EOL]     } [EOL] }
public static Boolean or(final Boolean... array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } [EOL]     if (array.length == 0) { [EOL]         throw new IllegalArgumentException("Array is empty"); [EOL]     } [EOL]     try { [EOL]         final boolean[] primitive = ArrayUtils.toPrimitive(array); [EOL]         return or(primitive) ? Boolean.TRUE : Boolean.FALSE; [EOL]     } catch (final NullPointerException ex) { [EOL]         throw new IllegalArgumentException("The array must not contain any null elements"); [EOL]     } [EOL] }
public static Boolean or(final Boolean... array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } [EOL]     if (array.length == 0) { [EOL]         throw new IllegalArgumentException("Array is empty"); [EOL]     } [EOL]     try { [EOL]         final boolean[] primitive = ArrayUtils.toPrimitive(array); [EOL]         return or(primitive) ? Boolean.TRUE : Boolean.FALSE; [EOL]     } catch (final NullPointerException ex) { [EOL]         throw new IllegalArgumentException("The array must not contain any null elements"); [EOL]     } [EOL] }
public static Boolean or(final Boolean... array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } [EOL]     if (array.length == 0) { [EOL]         throw new IllegalArgumentException("Array is empty"); [EOL]     } [EOL]     try { [EOL]         final boolean[] primitive = ArrayUtils.toPrimitive(array); [EOL]         return or(primitive) ? Boolean.TRUE : Boolean.FALSE; [EOL]     } catch (final NullPointerException ex) { [EOL]         throw new IllegalArgumentException("The array must not contain any null elements"); [EOL]     } [EOL] }
public static Boolean or(final Boolean... array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } [EOL]     if (array.length == 0) { [EOL]         throw new IllegalArgumentException("Array is empty"); [EOL]     } [EOL]     try { [EOL]         final boolean[] primitive = ArrayUtils.toPrimitive(array); [EOL]         return or(primitive) ? Boolean.TRUE : Boolean.FALSE; [EOL]     } catch (final NullPointerException ex) { [EOL]         throw new IllegalArgumentException("The array must not contain any null elements"); [EOL]     } [EOL] }
public static boolean xor(final boolean... array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } [EOL]     if (array.length == 0) { [EOL]         throw new IllegalArgumentException("Array is empty"); [EOL]     } [EOL]     int trueCount = 0; [EOL]     for (final boolean element : array) { [EOL]         if (element) { [EOL]             if (trueCount < 1) { [EOL]                 trueCount++; [EOL]             } else { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]     } [EOL]     return trueCount == 1; [EOL] }
public static boolean xor(final boolean... array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } [EOL]     if (array.length == 0) { [EOL]         throw new IllegalArgumentException("Array is empty"); [EOL]     } [EOL]     int trueCount = 0; [EOL]     for (final boolean element : array) { [EOL]         if (element) { [EOL]             if (trueCount < 1) { [EOL]                 trueCount++; [EOL]             } else { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]     } [EOL]     return trueCount == 1; [EOL] }
public static boolean xor(final boolean... array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } [EOL]     if (array.length == 0) { [EOL]         throw new IllegalArgumentException("Array is empty"); [EOL]     } [EOL]     int trueCount = 0; [EOL]     for (final boolean element : array) { [EOL]         if (element) { [EOL]             if (trueCount < 1) { [EOL]                 trueCount++; [EOL]             } else { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]     } [EOL]     return trueCount == 1; [EOL] }
public static boolean xor(final boolean... array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } [EOL]     if (array.length == 0) { [EOL]         throw new IllegalArgumentException("Array is empty"); [EOL]     } [EOL]     int trueCount = 0; [EOL]     for (final boolean element : array) { [EOL]         if (element) { [EOL]             if (trueCount < 1) { [EOL]                 trueCount++; [EOL]             } else { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]     } [EOL]     return trueCount == 1; [EOL] }
public static boolean xor(final boolean... array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } [EOL]     if (array.length == 0) { [EOL]         throw new IllegalArgumentException("Array is empty"); [EOL]     } [EOL]     int trueCount = 0; [EOL]     for (final boolean element : array) { [EOL]         if (element) { [EOL]             if (trueCount < 1) { [EOL]                 trueCount++; [EOL]             } else { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]     } [EOL]     return trueCount == 1; [EOL] }
public static boolean xor(final boolean... array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } [EOL]     if (array.length == 0) { [EOL]         throw new IllegalArgumentException("Array is empty"); [EOL]     } [EOL]     int trueCount = 0; [EOL]     for (final boolean element : array) { [EOL]         if (element) { [EOL]             if (trueCount < 1) { [EOL]                 trueCount++; [EOL]             } else { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]     } [EOL]     return trueCount == 1; [EOL] }
public static boolean xor(final boolean... array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } [EOL]     if (array.length == 0) { [EOL]         throw new IllegalArgumentException("Array is empty"); [EOL]     } [EOL]     int trueCount = 0; [EOL]     for (final boolean element : array) { [EOL]         if (element) { [EOL]             if (trueCount < 1) { [EOL]                 trueCount++; [EOL]             } else { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]     } [EOL]     return trueCount == 1; [EOL] }
public static Boolean xor(final Boolean... array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } [EOL]     if (array.length == 0) { [EOL]         throw new IllegalArgumentException("Array is empty"); [EOL]     } [EOL]     try { [EOL]         final boolean[] primitive = ArrayUtils.toPrimitive(array); [EOL]         return xor(primitive) ? Boolean.TRUE : Boolean.FALSE; [EOL]     } catch (final NullPointerException ex) { [EOL]         throw new IllegalArgumentException("The array must not contain any null elements"); [EOL]     } [EOL] }
public static Boolean xor(final Boolean... array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } [EOL]     if (array.length == 0) { [EOL]         throw new IllegalArgumentException("Array is empty"); [EOL]     } [EOL]     try { [EOL]         final boolean[] primitive = ArrayUtils.toPrimitive(array); [EOL]         return xor(primitive) ? Boolean.TRUE : Boolean.FALSE; [EOL]     } catch (final NullPointerException ex) { [EOL]         throw new IllegalArgumentException("The array must not contain any null elements"); [EOL]     } [EOL] }
public static Boolean xor(final Boolean... array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } [EOL]     if (array.length == 0) { [EOL]         throw new IllegalArgumentException("Array is empty"); [EOL]     } [EOL]     try { [EOL]         final boolean[] primitive = ArrayUtils.toPrimitive(array); [EOL]         return xor(primitive) ? Boolean.TRUE : Boolean.FALSE; [EOL]     } catch (final NullPointerException ex) { [EOL]         throw new IllegalArgumentException("The array must not contain any null elements"); [EOL]     } [EOL] }
public static Boolean xor(final Boolean... array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } [EOL]     if (array.length == 0) { [EOL]         throw new IllegalArgumentException("Array is empty"); [EOL]     } [EOL]     try { [EOL]         final boolean[] primitive = ArrayUtils.toPrimitive(array); [EOL]         return xor(primitive) ? Boolean.TRUE : Boolean.FALSE; [EOL]     } catch (final NullPointerException ex) { [EOL]         throw new IllegalArgumentException("The array must not contain any null elements"); [EOL]     } [EOL] }
public static Boolean xor(final Boolean... array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } [EOL]     if (array.length == 0) { [EOL]         throw new IllegalArgumentException("Array is empty"); [EOL]     } [EOL]     try { [EOL]         final boolean[] primitive = ArrayUtils.toPrimitive(array); [EOL]         return xor(primitive) ? Boolean.TRUE : Boolean.FALSE; [EOL]     } catch (final NullPointerException ex) { [EOL]         throw new IllegalArgumentException("The array must not contain any null elements"); [EOL]     } [EOL] }
public static Boolean xor(final Boolean... array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } [EOL]     if (array.length == 0) { [EOL]         throw new IllegalArgumentException("Array is empty"); [EOL]     } [EOL]     try { [EOL]         final boolean[] primitive = ArrayUtils.toPrimitive(array); [EOL]         return xor(primitive) ? Boolean.TRUE : Boolean.FALSE; [EOL]     } catch (final NullPointerException ex) { [EOL]         throw new IllegalArgumentException("The array must not contain any null elements"); [EOL]     } [EOL] }
public NumericEntityUnescaper(final OPTION... options) { [EOL]     if (options.length > 0) { [EOL]         this.options = EnumSet.copyOf(Arrays.asList(options)); [EOL]     } else { [EOL]         this.options = EnumSet.copyOf(Arrays.asList(new OPTION[] { OPTION.semiColonRequired })); [EOL]     } [EOL] }
public NumericEntityUnescaper(final OPTION... options) { [EOL]     if (options.length > 0) { [EOL]         this.options = EnumSet.copyOf(Arrays.asList(options)); [EOL]     } else { [EOL]         this.options = EnumSet.copyOf(Arrays.asList(new OPTION[] { OPTION.semiColonRequired })); [EOL]     } [EOL] }
@Override [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL]     final int seqEnd = input.length(); [EOL]     if (input.charAt(index) == '&' && index < seqEnd - 2 && input.charAt(index + 1) == '#') { [EOL]         int start = index + 2; [EOL]         boolean isHex = false; [EOL]         final char firstChar = input.charAt(start); [EOL]         if (firstChar == 'x' || firstChar == 'X') { [EOL]             start++; [EOL]             isHex = true; [EOL]             if (start == seqEnd) { [EOL]                 return 0; [EOL]             } [EOL]         } [EOL]         int end = start; [EOL]         while (end < seqEnd && (input.charAt(end) >= '0' && input.charAt(end) <= '9' || input.charAt(end) >= 'a' && input.charAt(end) <= 'f' || input.charAt(end) >= 'A' && input.charAt(end) <= 'F')) { [EOL]             end++; [EOL]         } [EOL]         final boolean semiNext = end != seqEnd && input.charAt(end) == ';'; [EOL]         if (!semiNext) { [EOL]             if (isSet(OPTION.semiColonRequired)) { [EOL]                 return 0; [EOL]             } else if (isSet(OPTION.errorIfNoSemiColon)) { [EOL]                 throw new IllegalArgumentException("Semi-colon required at end of numeric entity"); [EOL]             } [EOL]         } [EOL]         int entityValue; [EOL]         try { [EOL]             if (isHex) { [EOL]                 entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16); [EOL]             } else { [EOL]                 entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10); [EOL]             } [EOL]         } catch (final NumberFormatException nfe) { [EOL]             return 0; [EOL]         } [EOL]         if (entityValue > 0xFFFF) { [EOL]             final char[] chrs = Character.toChars(entityValue); [EOL]             out.write(chrs[0]); [EOL]             out.write(chrs[1]); [EOL]         } else { [EOL]             out.write(entityValue); [EOL]         } [EOL]         return 2 + end - start + (isHex ? 1 : 0) + (semiNext ? 1 : 0); [EOL]     } [EOL]     return 0; [EOL] }
@Override [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL]     final int seqEnd = input.length(); [EOL]     if (input.charAt(index) == '&' && index < seqEnd - 2 && input.charAt(index + 1) == '#') { [EOL]         int start = index + 2; [EOL]         boolean isHex = false; [EOL]         final char firstChar = input.charAt(start); [EOL]         if (firstChar == 'x' || firstChar == 'X') { [EOL]             start++; [EOL]             isHex = true; [EOL]             if (start == seqEnd) { [EOL]                 return 0; [EOL]             } [EOL]         } [EOL]         int end = start; [EOL]         while (end < seqEnd && (input.charAt(end) >= '0' && input.charAt(end) <= '9' || input.charAt(end) >= 'a' && input.charAt(end) <= 'f' || input.charAt(end) >= 'A' && input.charAt(end) <= 'F')) { [EOL]             end++; [EOL]         } [EOL]         final boolean semiNext = end != seqEnd && input.charAt(end) == ';'; [EOL]         if (!semiNext) { [EOL]             if (isSet(OPTION.semiColonRequired)) { [EOL]                 return 0; [EOL]             } else if (isSet(OPTION.errorIfNoSemiColon)) { [EOL]                 throw new IllegalArgumentException("Semi-colon required at end of numeric entity"); [EOL]             } [EOL]         } [EOL]         int entityValue; [EOL]         try { [EOL]             if (isHex) { [EOL]                 entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16); [EOL]             } else { [EOL]                 entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10); [EOL]             } [EOL]         } catch (final NumberFormatException nfe) { [EOL]             return 0; [EOL]         } [EOL]         if (entityValue > 0xFFFF) { [EOL]             final char[] chrs = Character.toChars(entityValue); [EOL]             out.write(chrs[0]); [EOL]             out.write(chrs[1]); [EOL]         } else { [EOL]             out.write(entityValue); [EOL]         } [EOL]         return 2 + end - start + (isHex ? 1 : 0) + (semiNext ? 1 : 0); [EOL]     } [EOL]     return 0; [EOL] }
@Override [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL]     final int seqEnd = input.length(); [EOL]     if (input.charAt(index) == '&' && index < seqEnd - 2 && input.charAt(index + 1) == '#') { [EOL]         int start = index + 2; [EOL]         boolean isHex = false; [EOL]         final char firstChar = input.charAt(start); [EOL]         if (firstChar == 'x' || firstChar == 'X') { [EOL]             start++; [EOL]             isHex = true; [EOL]             if (start == seqEnd) { [EOL]                 return 0; [EOL]             } [EOL]         } [EOL]         int end = start; [EOL]         while (end < seqEnd && (input.charAt(end) >= '0' && input.charAt(end) <= '9' || input.charAt(end) >= 'a' && input.charAt(end) <= 'f' || input.charAt(end) >= 'A' && input.charAt(end) <= 'F')) { [EOL]             end++; [EOL]         } [EOL]         final boolean semiNext = end != seqEnd && input.charAt(end) == ';'; [EOL]         if (!semiNext) { [EOL]             if (isSet(OPTION.semiColonRequired)) { [EOL]                 return 0; [EOL]             } else if (isSet(OPTION.errorIfNoSemiColon)) { [EOL]                 throw new IllegalArgumentException("Semi-colon required at end of numeric entity"); [EOL]             } [EOL]         } [EOL]         int entityValue; [EOL]         try { [EOL]             if (isHex) { [EOL]                 entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16); [EOL]             } else { [EOL]                 entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10); [EOL]             } [EOL]         } catch (final NumberFormatException nfe) { [EOL]             return 0; [EOL]         } [EOL]         if (entityValue > 0xFFFF) { [EOL]             final char[] chrs = Character.toChars(entityValue); [EOL]             out.write(chrs[0]); [EOL]             out.write(chrs[1]); [EOL]         } else { [EOL]             out.write(entityValue); [EOL]         } [EOL]         return 2 + end - start + (isHex ? 1 : 0) + (semiNext ? 1 : 0); [EOL]     } [EOL]     return 0; [EOL] }
@Override [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL]     final int seqEnd = input.length(); [EOL]     if (input.charAt(index) == '&' && index < seqEnd - 2 && input.charAt(index + 1) == '#') { [EOL]         int start = index + 2; [EOL]         boolean isHex = false; [EOL]         final char firstChar = input.charAt(start); [EOL]         if (firstChar == 'x' || firstChar == 'X') { [EOL]             start++; [EOL]             isHex = true; [EOL]             if (start == seqEnd) { [EOL]                 return 0; [EOL]             } [EOL]         } [EOL]         int end = start; [EOL]         while (end < seqEnd && (input.charAt(end) >= '0' && input.charAt(end) <= '9' || input.charAt(end) >= 'a' && input.charAt(end) <= 'f' || input.charAt(end) >= 'A' && input.charAt(end) <= 'F')) { [EOL]             end++; [EOL]         } [EOL]         final boolean semiNext = end != seqEnd && input.charAt(end) == ';'; [EOL]         if (!semiNext) { [EOL]             if (isSet(OPTION.semiColonRequired)) { [EOL]                 return 0; [EOL]             } else if (isSet(OPTION.errorIfNoSemiColon)) { [EOL]                 throw new IllegalArgumentException("Semi-colon required at end of numeric entity"); [EOL]             } [EOL]         } [EOL]         int entityValue; [EOL]         try { [EOL]             if (isHex) { [EOL]                 entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16); [EOL]             } else { [EOL]                 entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10); [EOL]             } [EOL]         } catch (final NumberFormatException nfe) { [EOL]             return 0; [EOL]         } [EOL]         if (entityValue > 0xFFFF) { [EOL]             final char[] chrs = Character.toChars(entityValue); [EOL]             out.write(chrs[0]); [EOL]             out.write(chrs[1]); [EOL]         } else { [EOL]             out.write(entityValue); [EOL]         } [EOL]         return 2 + end - start + (isHex ? 1 : 0) + (semiNext ? 1 : 0); [EOL]     } [EOL]     return 0; [EOL] }
@Override [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL]     final int seqEnd = input.length(); [EOL]     if (input.charAt(index) == '&' && index < seqEnd - 2 && input.charAt(index + 1) == '#') { [EOL]         int start = index + 2; [EOL]         boolean isHex = false; [EOL]         final char firstChar = input.charAt(start); [EOL]         if (firstChar == 'x' || firstChar == 'X') { [EOL]             start++; [EOL]             isHex = true; [EOL]             if (start == seqEnd) { [EOL]                 return 0; [EOL]             } [EOL]         } [EOL]         int end = start; [EOL]         while (end < seqEnd && (input.charAt(end) >= '0' && input.charAt(end) <= '9' || input.charAt(end) >= 'a' && input.charAt(end) <= 'f' || input.charAt(end) >= 'A' && input.charAt(end) <= 'F')) { [EOL]             end++; [EOL]         } [EOL]         final boolean semiNext = end != seqEnd && input.charAt(end) == ';'; [EOL]         if (!semiNext) { [EOL]             if (isSet(OPTION.semiColonRequired)) { [EOL]                 return 0; [EOL]             } else if (isSet(OPTION.errorIfNoSemiColon)) { [EOL]                 throw new IllegalArgumentException("Semi-colon required at end of numeric entity"); [EOL]             } [EOL]         } [EOL]         int entityValue; [EOL]         try { [EOL]             if (isHex) { [EOL]                 entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16); [EOL]             } else { [EOL]                 entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10); [EOL]             } [EOL]         } catch (final NumberFormatException nfe) { [EOL]             return 0; [EOL]         } [EOL]         if (entityValue > 0xFFFF) { [EOL]             final char[] chrs = Character.toChars(entityValue); [EOL]             out.write(chrs[0]); [EOL]             out.write(chrs[1]); [EOL]         } else { [EOL]             out.write(entityValue); [EOL]         } [EOL]         return 2 + end - start + (isHex ? 1 : 0) + (semiNext ? 1 : 0); [EOL]     } [EOL]     return 0; [EOL] }
@Override [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL]     final int seqEnd = input.length(); [EOL]     if (input.charAt(index) == '&' && index < seqEnd - 2 && input.charAt(index + 1) == '#') { [EOL]         int start = index + 2; [EOL]         boolean isHex = false; [EOL]         final char firstChar = input.charAt(start); [EOL]         if (firstChar == 'x' || firstChar == 'X') { [EOL]             start++; [EOL]             isHex = true; [EOL]             if (start == seqEnd) { [EOL]                 return 0; [EOL]             } [EOL]         } [EOL]         int end = start; [EOL]         while (end < seqEnd && (input.charAt(end) >= '0' && input.charAt(end) <= '9' || input.charAt(end) >= 'a' && input.charAt(end) <= 'f' || input.charAt(end) >= 'A' && input.charAt(end) <= 'F')) { [EOL]             end++; [EOL]         } [EOL]         final boolean semiNext = end != seqEnd && input.charAt(end) == ';'; [EOL]         if (!semiNext) { [EOL]             if (isSet(OPTION.semiColonRequired)) { [EOL]                 return 0; [EOL]             } else if (isSet(OPTION.errorIfNoSemiColon)) { [EOL]                 throw new IllegalArgumentException("Semi-colon required at end of numeric entity"); [EOL]             } [EOL]         } [EOL]         int entityValue; [EOL]         try { [EOL]             if (isHex) { [EOL]                 entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16); [EOL]             } else { [EOL]                 entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10); [EOL]             } [EOL]         } catch (final NumberFormatException nfe) { [EOL]             return 0; [EOL]         } [EOL]         if (entityValue > 0xFFFF) { [EOL]             final char[] chrs = Character.toChars(entityValue); [EOL]             out.write(chrs[0]); [EOL]             out.write(chrs[1]); [EOL]         } else { [EOL]             out.write(entityValue); [EOL]         } [EOL]         return 2 + end - start + (isHex ? 1 : 0) + (semiNext ? 1 : 0); [EOL]     } [EOL]     return 0; [EOL] }
@Override [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL]     final int seqEnd = input.length(); [EOL]     if (input.charAt(index) == '&' && index < seqEnd - 2 && input.charAt(index + 1) == '#') { [EOL]         int start = index + 2; [EOL]         boolean isHex = false; [EOL]         final char firstChar = input.charAt(start); [EOL]         if (firstChar == 'x' || firstChar == 'X') { [EOL]             start++; [EOL]             isHex = true; [EOL]             if (start == seqEnd) { [EOL]                 return 0; [EOL]             } [EOL]         } [EOL]         int end = start; [EOL]         while (end < seqEnd && (input.charAt(end) >= '0' && input.charAt(end) <= '9' || input.charAt(end) >= 'a' && input.charAt(end) <= 'f' || input.charAt(end) >= 'A' && input.charAt(end) <= 'F')) { [EOL]             end++; [EOL]         } [EOL]         final boolean semiNext = end != seqEnd && input.charAt(end) == ';'; [EOL]         if (!semiNext) { [EOL]             if (isSet(OPTION.semiColonRequired)) { [EOL]                 return 0; [EOL]             } else if (isSet(OPTION.errorIfNoSemiColon)) { [EOL]                 throw new IllegalArgumentException("Semi-colon required at end of numeric entity"); [EOL]             } [EOL]         } [EOL]         int entityValue; [EOL]         try { [EOL]             if (isHex) { [EOL]                 entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16); [EOL]             } else { [EOL]                 entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10); [EOL]             } [EOL]         } catch (final NumberFormatException nfe) { [EOL]             return 0; [EOL]         } [EOL]         if (entityValue > 0xFFFF) { [EOL]             final char[] chrs = Character.toChars(entityValue); [EOL]             out.write(chrs[0]); [EOL]             out.write(chrs[1]); [EOL]         } else { [EOL]             out.write(entityValue); [EOL]         } [EOL]         return 2 + end - start + (isHex ? 1 : 0) + (semiNext ? 1 : 0); [EOL]     } [EOL]     return 0; [EOL] }
public static Object invokeMethod(final Object object, final String methodName, Object... args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException { [EOL]     if (args == null) { [EOL]         args = ArrayUtils.EMPTY_OBJECT_ARRAY; [EOL]     } [EOL]     final Class<?>[] parameterTypes = ClassUtils.toClass(args); [EOL]     return invokeMethod(object, methodName, args, parameterTypes); [EOL] }
public static Object invokeMethod(final Object object, final String methodName, Object... args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException { [EOL]     if (args == null) { [EOL]         args = ArrayUtils.EMPTY_OBJECT_ARRAY; [EOL]     } [EOL]     final Class<?>[] parameterTypes = ClassUtils.toClass(args); [EOL]     return invokeMethod(object, methodName, args, parameterTypes); [EOL] }
public static Object invokeMethod(final Object object, final String methodName, Object... args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException { [EOL]     if (args == null) { [EOL]         args = ArrayUtils.EMPTY_OBJECT_ARRAY; [EOL]     } [EOL]     final Class<?>[] parameterTypes = ClassUtils.toClass(args); [EOL]     return invokeMethod(object, methodName, args, parameterTypes); [EOL] }
public static Object invokeMethod(final Object object, final String methodName, Object[] args, Class<?>[] parameterTypes) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException { [EOL]     if (parameterTypes == null) { [EOL]         parameterTypes = ArrayUtils.EMPTY_CLASS_ARRAY; [EOL]     } [EOL]     if (args == null) { [EOL]         args = ArrayUtils.EMPTY_OBJECT_ARRAY; [EOL]     } [EOL]     final Method method = getMatchingAccessibleMethod(object.getClass(), methodName, parameterTypes); [EOL]     if (method == null) { [EOL]         throw new NoSuchMethodException("No such accessible method: " + methodName + "() on object: " + object.getClass().getName()); [EOL]     } [EOL]     return method.invoke(object, args); [EOL] }
public static Object invokeMethod(final Object object, final String methodName, Object[] args, Class<?>[] parameterTypes) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException { [EOL]     if (parameterTypes == null) { [EOL]         parameterTypes = ArrayUtils.EMPTY_CLASS_ARRAY; [EOL]     } [EOL]     if (args == null) { [EOL]         args = ArrayUtils.EMPTY_OBJECT_ARRAY; [EOL]     } [EOL]     final Method method = getMatchingAccessibleMethod(object.getClass(), methodName, parameterTypes); [EOL]     if (method == null) { [EOL]         throw new NoSuchMethodException("No such accessible method: " + methodName + "() on object: " + object.getClass().getName()); [EOL]     } [EOL]     return method.invoke(object, args); [EOL] }
public static Object invokeStaticMethod(final Class<?> cls, final String methodName, Object... args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException { [EOL]     if (args == null) { [EOL]         args = ArrayUtils.EMPTY_OBJECT_ARRAY; [EOL]     } [EOL]     final Class<?>[] parameterTypes = ClassUtils.toClass(args); [EOL]     return invokeStaticMethod(cls, methodName, args, parameterTypes); [EOL] }
public static Object invokeStaticMethod(final Class<?> cls, final String methodName, Object... args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException { [EOL]     if (args == null) { [EOL]         args = ArrayUtils.EMPTY_OBJECT_ARRAY; [EOL]     } [EOL]     final Class<?>[] parameterTypes = ClassUtils.toClass(args); [EOL]     return invokeStaticMethod(cls, methodName, args, parameterTypes); [EOL] }
public static Object invokeStaticMethod(final Class<?> cls, final String methodName, Object... args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException { [EOL]     if (args == null) { [EOL]         args = ArrayUtils.EMPTY_OBJECT_ARRAY; [EOL]     } [EOL]     final Class<?>[] parameterTypes = ClassUtils.toClass(args); [EOL]     return invokeStaticMethod(cls, methodName, args, parameterTypes); [EOL] }
public static Object invokeStaticMethod(final Class<?> cls, final String methodName, Object[] args, Class<?>[] parameterTypes) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException { [EOL]     if (parameterTypes == null) { [EOL]         parameterTypes = ArrayUtils.EMPTY_CLASS_ARRAY; [EOL]     } [EOL]     if (args == null) { [EOL]         args = ArrayUtils.EMPTY_OBJECT_ARRAY; [EOL]     } [EOL]     final Method method = getMatchingAccessibleMethod(cls, methodName, parameterTypes); [EOL]     if (method == null) { [EOL]         throw new NoSuchMethodException("No such accessible method: " + methodName + "() on class: " + cls.getName()); [EOL]     } [EOL]     return method.invoke(null, args); [EOL] }
public static Object invokeStaticMethod(final Class<?> cls, final String methodName, Object[] args, Class<?>[] parameterTypes) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException { [EOL]     if (parameterTypes == null) { [EOL]         parameterTypes = ArrayUtils.EMPTY_CLASS_ARRAY; [EOL]     } [EOL]     if (args == null) { [EOL]         args = ArrayUtils.EMPTY_OBJECT_ARRAY; [EOL]     } [EOL]     final Method method = getMatchingAccessibleMethod(cls, methodName, parameterTypes); [EOL]     if (method == null) { [EOL]         throw new NoSuchMethodException("No such accessible method: " + methodName + "() on class: " + cls.getName()); [EOL]     } [EOL]     return method.invoke(null, args); [EOL] }
public static Object invokeStaticMethod(final Class<?> cls, final String methodName, Object[] args, Class<?>[] parameterTypes) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException { [EOL]     if (parameterTypes == null) { [EOL]         parameterTypes = ArrayUtils.EMPTY_CLASS_ARRAY; [EOL]     } [EOL]     if (args == null) { [EOL]         args = ArrayUtils.EMPTY_OBJECT_ARRAY; [EOL]     } [EOL]     final Method method = getMatchingAccessibleMethod(cls, methodName, parameterTypes); [EOL]     if (method == null) { [EOL]         throw new NoSuchMethodException("No such accessible method: " + methodName + "() on class: " + cls.getName()); [EOL]     } [EOL]     return method.invoke(null, args); [EOL] }
public static Method getMatchingAccessibleMethod(final Class<?> cls, final String methodName, final Class<?>... parameterTypes) { [EOL]     try { [EOL]         final Method method = cls.getMethod(methodName, parameterTypes); [EOL]         MemberUtils.setAccessibleWorkaround(method); [EOL]         return method; [EOL]     } catch (final NoSuchMethodException e) { [EOL]     } [EOL]     Method bestMatch = null; [EOL]     final Method[] methods = cls.getMethods(); [EOL]     for (final Method method : methods) { [EOL]         if (method.getName().equals(methodName) && ClassUtils.isAssignable(parameterTypes, method.getParameterTypes(), true)) { [EOL]             final Method accessibleMethod = getAccessibleMethod(method); [EOL]             if (accessibleMethod != null && (bestMatch == null || MemberUtils.compareParameterTypes(accessibleMethod.getParameterTypes(), bestMatch.getParameterTypes(), parameterTypes) < 0)) { [EOL]                 bestMatch = accessibleMethod; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (bestMatch != null) { [EOL]         MemberUtils.setAccessibleWorkaround(bestMatch); [EOL]     } [EOL]     return bestMatch; [EOL] }
public NumberUtils() { [EOL]     super(); [EOL] }
public static int toInt(final String str) { [EOL]     return toInt(str, 0); [EOL] }
public static int toInt(final String str, final int defaultValue) { [EOL]     if (str == null) { [EOL]         return defaultValue; [EOL]     } [EOL]     try { [EOL]         return Integer.parseInt(str); [EOL]     } catch (final NumberFormatException nfe) { [EOL]         return defaultValue; [EOL]     } [EOL] }
public static byte toByte(final String str) { [EOL]     return toByte(str, (byte) 0); [EOL] }
public static byte toByte(final String str) { [EOL]     return toByte(str, (byte) 0); [EOL] }
public static byte toByte(final String str) { [EOL]     return toByte(str, (byte) 0); [EOL] }
public static byte toByte(final String str, final byte defaultValue) { [EOL]     if (str == null) { [EOL]         return defaultValue; [EOL]     } [EOL]     try { [EOL]         return Byte.parseByte(str); [EOL]     } catch (final NumberFormatException nfe) { [EOL]         return defaultValue; [EOL]     } [EOL] }
public static short toShort(final String str) { [EOL]     return toShort(str, (short) 0); [EOL] }
public static short toShort(final String str) { [EOL]     return toShort(str, (short) 0); [EOL] }
public static short toShort(final String str) { [EOL]     return toShort(str, (short) 0); [EOL] }
public static short toShort(final String str, final short defaultValue) { [EOL]     if (str == null) { [EOL]         return defaultValue; [EOL]     } [EOL]     try { [EOL]         return Short.parseShort(str); [EOL]     } catch (final NumberFormatException nfe) { [EOL]         return defaultValue; [EOL]     } [EOL] }
public static short toShort(final String str, final short defaultValue) { [EOL]     if (str == null) { [EOL]         return defaultValue; [EOL]     } [EOL]     try { [EOL]         return Short.parseShort(str); [EOL]     } catch (final NumberFormatException nfe) { [EOL]         return defaultValue; [EOL]     } [EOL] }
public static short toShort(final String str, final short defaultValue) { [EOL]     if (str == null) { [EOL]         return defaultValue; [EOL]     } [EOL]     try { [EOL]         return Short.parseShort(str); [EOL]     } catch (final NumberFormatException nfe) { [EOL]         return defaultValue; [EOL]     } [EOL] }
public static short toShort(final String str, final short defaultValue) { [EOL]     if (str == null) { [EOL]         return defaultValue; [EOL]     } [EOL]     try { [EOL]         return Short.parseShort(str); [EOL]     } catch (final NumberFormatException nfe) { [EOL]         return defaultValue; [EOL]     } [EOL] }
public static Number createNumber(final String str) throws NumberFormatException { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (StringUtils.isBlank(str)) { [EOL]         throw new NumberFormatException("A blank string is not a valid number"); [EOL]     } [EOL]     final String[] hex_prefixes = { "0x", "0X", "-0x", "-0X", "#", "-#" }; [EOL]     int pfxLen = 0; [EOL]     for (final String pfx : hex_prefixes) { [EOL]         if (str.startsWith(pfx)) { [EOL]             pfxLen += pfx.length(); [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (pfxLen > 0) { [EOL]         char firstSigDigit = 0; [EOL]         for (int i = pfxLen; i < str.length(); i++) { [EOL]             firstSigDigit = str.charAt(i); [EOL]             if (firstSigDigit == '0') { [EOL]                 pfxLen++; [EOL]             } else { [EOL]                 break; [EOL]             } [EOL]         } [EOL]         final int hexDigits = str.length() - pfxLen; [EOL]         if (hexDigits > 16 || (hexDigits == 16 && firstSigDigit > '7')) { [EOL]             return createBigInteger(str); [EOL]         } [EOL]         if (hexDigits > 8 || (hexDigits == 8 && firstSigDigit > '7')) { [EOL]             return createLong(str); [EOL]         } [EOL]         return createInteger(str); [EOL]     } [EOL]     final char lastChar = str.charAt(str.length() - 1); [EOL]     String mant; [EOL]     String dec; [EOL]     String exp; [EOL]     final int decPos = str.indexOf('.'); [EOL]     final int expPos = str.indexOf('e') + str.indexOf('E') + 1; [EOL]     int numDecimals = 0; [EOL]     if (decPos > -1) { [EOL]         if (expPos > -1) { [EOL]             if (expPos < decPos || expPos > str.length()) { [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]             } [EOL]             dec = str.substring(decPos + 1, expPos); [EOL]         } else { [EOL]             dec = str.substring(decPos + 1); [EOL]         } [EOL]         mant = str.substring(0, decPos); [EOL]         numDecimals = dec.length(); [EOL]     } else { [EOL]         if (expPos > -1) { [EOL]             if (expPos > str.length()) { [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]             } [EOL]             mant = str.substring(0, expPos); [EOL]         } else { [EOL]             mant = str; [EOL]         } [EOL]         dec = null; [EOL]     } [EOL]     if (!Character.isDigit(lastChar) && lastChar != '.') { [EOL]         if (expPos > -1 && expPos < str.length() - 1) { [EOL]             exp = str.substring(expPos + 1, str.length() - 1); [EOL]         } else { [EOL]             exp = null; [EOL]         } [EOL]         final String numeric = str.substring(0, str.length() - 1); [EOL]         final boolean allZeros = isAllZeros(mant) && isAllZeros(exp); [EOL]         switch(lastChar) { [EOL]             case 'l': [EOL]             case 'L': [EOL]                 if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) { [EOL]                     try { [EOL]                         return createLong(numeric); [EOL]                     } catch (final NumberFormatException nfe) { [EOL]                     } [EOL]                     return createBigInteger(numeric); [EOL]                 } [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]             case 'f': [EOL]             case 'F': [EOL]                 try { [EOL]                     final Float f = NumberUtils.createFloat(numeric); [EOL]                     if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { [EOL]                         return f; [EOL]                     } [EOL]                 } catch (final NumberFormatException nfe) { [EOL]                 } [EOL]             case 'd': [EOL]             case 'D': [EOL]                 try { [EOL]                     final Double d = NumberUtils.createDouble(numeric); [EOL]                     if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { [EOL]                         return d; [EOL]                     } [EOL]                 } catch (final NumberFormatException nfe) { [EOL]                 } [EOL]                 try { [EOL]                     return createBigDecimal(numeric); [EOL]                 } catch (final NumberFormatException e) { [EOL]                 } [EOL]             default: [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]         } [EOL]     } [EOL]     if (expPos > -1 && expPos < str.length() - 1) { [EOL]         exp = str.substring(expPos + 1, str.length()); [EOL]     } else { [EOL]         exp = null; [EOL]     } [EOL]     if (dec == null && exp == null) { [EOL]         try { [EOL]             return createInteger(str); [EOL]         } catch (final NumberFormatException nfe) { [EOL]         } [EOL]         try { [EOL]             return createLong(str); [EOL]         } catch (final NumberFormatException nfe) { [EOL]         } [EOL]         return createBigInteger(str); [EOL]     } [EOL]     final boolean allZeros = isAllZeros(mant) && isAllZeros(exp); [EOL]     try { [EOL]         if (numDecimals <= 7) { [EOL]             final Float f = createFloat(str); [EOL]             if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { [EOL]                 return f; [EOL]             } [EOL]         } [EOL]     } catch (final NumberFormatException nfe) { [EOL]     } [EOL]     try { [EOL]         if (numDecimals <= 16) { [EOL]             final Double d = createDouble(str); [EOL]             if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { [EOL]                 return d; [EOL]             } [EOL]         } [EOL]     } catch (final NumberFormatException nfe) { [EOL]     } [EOL]     return createBigDecimal(str); [EOL] }
private static boolean isAllZeros(final String str) { [EOL]     if (str == null) { [EOL]         return true; [EOL]     } [EOL]     for (int i = str.length() - 1; i >= 0; i--) { [EOL]         if (str.charAt(i) != '0') { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return str.length() > 0; [EOL] }
private static boolean isAllZeros(final String str) { [EOL]     if (str == null) { [EOL]         return true; [EOL]     } [EOL]     for (int i = str.length() - 1; i >= 0; i--) { [EOL]         if (str.charAt(i) != '0') { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return str.length() > 0; [EOL] }
private static boolean isAllZeros(final String str) { [EOL]     if (str == null) { [EOL]         return true; [EOL]     } [EOL]     for (int i = str.length() - 1; i >= 0; i--) { [EOL]         if (str.charAt(i) != '0') { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return str.length() > 0; [EOL] }
private static boolean isAllZeros(final String str) { [EOL]     if (str == null) { [EOL]         return true; [EOL]     } [EOL]     for (int i = str.length() - 1; i >= 0; i--) { [EOL]         if (str.charAt(i) != '0') { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return str.length() > 0; [EOL] }
public static Integer createInteger(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     return Integer.decode(str); [EOL] }
public static Long createLong(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     return Long.decode(str); [EOL] }
public static Long createLong(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     return Long.decode(str); [EOL] }
public static BigInteger createBigInteger(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     int pos = 0; [EOL]     int radix = 10; [EOL]     boolean negate = false; [EOL]     if (str.startsWith("-")) { [EOL]         negate = true; [EOL]         pos = 1; [EOL]     } [EOL]     if (str.startsWith("0x", pos) || str.startsWith("0x", pos)) { [EOL]         radix = 16; [EOL]         pos += 2; [EOL]     } else if (str.startsWith("#", pos)) { [EOL]         radix = 16; [EOL]         pos++; [EOL]     } else if (str.startsWith("0", pos) && str.length() > pos + 1) { [EOL]         radix = 8; [EOL]         pos++; [EOL]     } [EOL]     final BigInteger value = new BigInteger(str.substring(pos), radix); [EOL]     return negate ? value.negate() : value; [EOL] }
public static BigInteger createBigInteger(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     int pos = 0; [EOL]     int radix = 10; [EOL]     boolean negate = false; [EOL]     if (str.startsWith("-")) { [EOL]         negate = true; [EOL]         pos = 1; [EOL]     } [EOL]     if (str.startsWith("0x", pos) || str.startsWith("0x", pos)) { [EOL]         radix = 16; [EOL]         pos += 2; [EOL]     } else if (str.startsWith("#", pos)) { [EOL]         radix = 16; [EOL]         pos++; [EOL]     } else if (str.startsWith("0", pos) && str.length() > pos + 1) { [EOL]         radix = 8; [EOL]         pos++; [EOL]     } [EOL]     final BigInteger value = new BigInteger(str.substring(pos), radix); [EOL]     return negate ? value.negate() : value; [EOL] }
public static BigInteger createBigInteger(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     int pos = 0; [EOL]     int radix = 10; [EOL]     boolean negate = false; [EOL]     if (str.startsWith("-")) { [EOL]         negate = true; [EOL]         pos = 1; [EOL]     } [EOL]     if (str.startsWith("0x", pos) || str.startsWith("0x", pos)) { [EOL]         radix = 16; [EOL]         pos += 2; [EOL]     } else if (str.startsWith("#", pos)) { [EOL]         radix = 16; [EOL]         pos++; [EOL]     } else if (str.startsWith("0", pos) && str.length() > pos + 1) { [EOL]         radix = 8; [EOL]         pos++; [EOL]     } [EOL]     final BigInteger value = new BigInteger(str.substring(pos), radix); [EOL]     return negate ? value.negate() : value; [EOL] }
public static BigInteger createBigInteger(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     int pos = 0; [EOL]     int radix = 10; [EOL]     boolean negate = false; [EOL]     if (str.startsWith("-")) { [EOL]         negate = true; [EOL]         pos = 1; [EOL]     } [EOL]     if (str.startsWith("0x", pos) || str.startsWith("0x", pos)) { [EOL]         radix = 16; [EOL]         pos += 2; [EOL]     } else if (str.startsWith("#", pos)) { [EOL]         radix = 16; [EOL]         pos++; [EOL]     } else if (str.startsWith("0", pos) && str.length() > pos + 1) { [EOL]         radix = 8; [EOL]         pos++; [EOL]     } [EOL]     final BigInteger value = new BigInteger(str.substring(pos), radix); [EOL]     return negate ? value.negate() : value; [EOL] }
public static BigInteger createBigInteger(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     int pos = 0; [EOL]     int radix = 10; [EOL]     boolean negate = false; [EOL]     if (str.startsWith("-")) { [EOL]         negate = true; [EOL]         pos = 1; [EOL]     } [EOL]     if (str.startsWith("0x", pos) || str.startsWith("0x", pos)) { [EOL]         radix = 16; [EOL]         pos += 2; [EOL]     } else if (str.startsWith("#", pos)) { [EOL]         radix = 16; [EOL]         pos++; [EOL]     } else if (str.startsWith("0", pos) && str.length() > pos + 1) { [EOL]         radix = 8; [EOL]         pos++; [EOL]     } [EOL]     final BigInteger value = new BigInteger(str.substring(pos), radix); [EOL]     return negate ? value.negate() : value; [EOL] }
public static BigInteger createBigInteger(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     int pos = 0; [EOL]     int radix = 10; [EOL]     boolean negate = false; [EOL]     if (str.startsWith("-")) { [EOL]         negate = true; [EOL]         pos = 1; [EOL]     } [EOL]     if (str.startsWith("0x", pos) || str.startsWith("0x", pos)) { [EOL]         radix = 16; [EOL]         pos += 2; [EOL]     } else if (str.startsWith("#", pos)) { [EOL]         radix = 16; [EOL]         pos++; [EOL]     } else if (str.startsWith("0", pos) && str.length() > pos + 1) { [EOL]         radix = 8; [EOL]         pos++; [EOL]     } [EOL]     final BigInteger value = new BigInteger(str.substring(pos), radix); [EOL]     return negate ? value.negate() : value; [EOL] }
public static BigInteger createBigInteger(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     int pos = 0; [EOL]     int radix = 10; [EOL]     boolean negate = false; [EOL]     if (str.startsWith("-")) { [EOL]         negate = true; [EOL]         pos = 1; [EOL]     } [EOL]     if (str.startsWith("0x", pos) || str.startsWith("0x", pos)) { [EOL]         radix = 16; [EOL]         pos += 2; [EOL]     } else if (str.startsWith("#", pos)) { [EOL]         radix = 16; [EOL]         pos++; [EOL]     } else if (str.startsWith("0", pos) && str.length() > pos + 1) { [EOL]         radix = 8; [EOL]         pos++; [EOL]     } [EOL]     final BigInteger value = new BigInteger(str.substring(pos), radix); [EOL]     return negate ? value.negate() : value; [EOL] }
public static BigInteger createBigInteger(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     int pos = 0; [EOL]     int radix = 10; [EOL]     boolean negate = false; [EOL]     if (str.startsWith("-")) { [EOL]         negate = true; [EOL]         pos = 1; [EOL]     } [EOL]     if (str.startsWith("0x", pos) || str.startsWith("0x", pos)) { [EOL]         radix = 16; [EOL]         pos += 2; [EOL]     } else if (str.startsWith("#", pos)) { [EOL]         radix = 16; [EOL]         pos++; [EOL]     } else if (str.startsWith("0", pos) && str.length() > pos + 1) { [EOL]         radix = 8; [EOL]         pos++; [EOL]     } [EOL]     final BigInteger value = new BigInteger(str.substring(pos), radix); [EOL]     return negate ? value.negate() : value; [EOL] }
public static BigDecimal createBigDecimal(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (StringUtils.isBlank(str)) { [EOL]         throw new NumberFormatException("A blank string is not a valid number"); [EOL]     } [EOL]     if (str.trim().startsWith("--")) { [EOL]         throw new NumberFormatException(str + " is not a valid number."); [EOL]     } [EOL]     return new BigDecimal(str); [EOL] }
public static BigDecimal createBigDecimal(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (StringUtils.isBlank(str)) { [EOL]         throw new NumberFormatException("A blank string is not a valid number"); [EOL]     } [EOL]     if (str.trim().startsWith("--")) { [EOL]         throw new NumberFormatException(str + " is not a valid number."); [EOL]     } [EOL]     return new BigDecimal(str); [EOL] }
public static BigDecimal createBigDecimal(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (StringUtils.isBlank(str)) { [EOL]         throw new NumberFormatException("A blank string is not a valid number"); [EOL]     } [EOL]     if (str.trim().startsWith("--")) { [EOL]         throw new NumberFormatException(str + " is not a valid number."); [EOL]     } [EOL]     return new BigDecimal(str); [EOL] }
public static BigDecimal createBigDecimal(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (StringUtils.isBlank(str)) { [EOL]         throw new NumberFormatException("A blank string is not a valid number"); [EOL]     } [EOL]     if (str.trim().startsWith("--")) { [EOL]         throw new NumberFormatException(str + " is not a valid number."); [EOL]     } [EOL]     return new BigDecimal(str); [EOL] }
public static long min(final long[] array) { [EOL]     validateArray(array); [EOL]     long min = array[0]; [EOL]     for (int i = 1; i < array.length; i++) { [EOL]         if (array[i] < min) { [EOL]             min = array[i]; [EOL]         } [EOL]     } [EOL]     return min; [EOL] }
public static long min(final long[] array) { [EOL]     validateArray(array); [EOL]     long min = array[0]; [EOL]     for (int i = 1; i < array.length; i++) { [EOL]         if (array[i] < min) { [EOL]             min = array[i]; [EOL]         } [EOL]     } [EOL]     return min; [EOL] }
public static long min(final long[] array) { [EOL]     validateArray(array); [EOL]     long min = array[0]; [EOL]     for (int i = 1; i < array.length; i++) { [EOL]         if (array[i] < min) { [EOL]             min = array[i]; [EOL]         } [EOL]     } [EOL]     return min; [EOL] }
public static long min(final long[] array) { [EOL]     validateArray(array); [EOL]     long min = array[0]; [EOL]     for (int i = 1; i < array.length; i++) { [EOL]         if (array[i] < min) { [EOL]             min = array[i]; [EOL]         } [EOL]     } [EOL]     return min; [EOL] }
public static int min(final int[] array) { [EOL]     validateArray(array); [EOL]     int min = array[0]; [EOL]     for (int j = 1; j < array.length; j++) { [EOL]         if (array[j] < min) { [EOL]             min = array[j]; [EOL]         } [EOL]     } [EOL]     return min; [EOL] }
public static double min(final double[] array) { [EOL]     validateArray(array); [EOL]     double min = array[0]; [EOL]     for (int i = 1; i < array.length; i++) { [EOL]         if (Double.isNaN(array[i])) { [EOL]             return Double.NaN; [EOL]         } [EOL]         if (array[i] < min) { [EOL]             min = array[i]; [EOL]         } [EOL]     } [EOL]     return min; [EOL] }
public static double min(final double[] array) { [EOL]     validateArray(array); [EOL]     double min = array[0]; [EOL]     for (int i = 1; i < array.length; i++) { [EOL]         if (Double.isNaN(array[i])) { [EOL]             return Double.NaN; [EOL]         } [EOL]         if (array[i] < min) { [EOL]             min = array[i]; [EOL]         } [EOL]     } [EOL]     return min; [EOL] }
public static double min(final double[] array) { [EOL]     validateArray(array); [EOL]     double min = array[0]; [EOL]     for (int i = 1; i < array.length; i++) { [EOL]         if (Double.isNaN(array[i])) { [EOL]             return Double.NaN; [EOL]         } [EOL]         if (array[i] < min) { [EOL]             min = array[i]; [EOL]         } [EOL]     } [EOL]     return min; [EOL] }
public static double min(final double[] array) { [EOL]     validateArray(array); [EOL]     double min = array[0]; [EOL]     for (int i = 1; i < array.length; i++) { [EOL]         if (Double.isNaN(array[i])) { [EOL]             return Double.NaN; [EOL]         } [EOL]         if (array[i] < min) { [EOL]             min = array[i]; [EOL]         } [EOL]     } [EOL]     return min; [EOL] }
public static float min(final float[] array) { [EOL]     validateArray(array); [EOL]     float min = array[0]; [EOL]     for (int i = 1; i < array.length; i++) { [EOL]         if (Float.isNaN(array[i])) { [EOL]             return Float.NaN; [EOL]         } [EOL]         if (array[i] < min) { [EOL]             min = array[i]; [EOL]         } [EOL]     } [EOL]     return min; [EOL] }
public static float min(final float[] array) { [EOL]     validateArray(array); [EOL]     float min = array[0]; [EOL]     for (int i = 1; i < array.length; i++) { [EOL]         if (Float.isNaN(array[i])) { [EOL]             return Float.NaN; [EOL]         } [EOL]         if (array[i] < min) { [EOL]             min = array[i]; [EOL]         } [EOL]     } [EOL]     return min; [EOL] }
public static float min(final float[] array) { [EOL]     validateArray(array); [EOL]     float min = array[0]; [EOL]     for (int i = 1; i < array.length; i++) { [EOL]         if (Float.isNaN(array[i])) { [EOL]             return Float.NaN; [EOL]         } [EOL]         if (array[i] < min) { [EOL]             min = array[i]; [EOL]         } [EOL]     } [EOL]     return min; [EOL] }
public static float min(final float[] array) { [EOL]     validateArray(array); [EOL]     float min = array[0]; [EOL]     for (int i = 1; i < array.length; i++) { [EOL]         if (Float.isNaN(array[i])) { [EOL]             return Float.NaN; [EOL]         } [EOL]         if (array[i] < min) { [EOL]             min = array[i]; [EOL]         } [EOL]     } [EOL]     return min; [EOL] }
public static float min(final float[] array) { [EOL]     validateArray(array); [EOL]     float min = array[0]; [EOL]     for (int i = 1; i < array.length; i++) { [EOL]         if (Float.isNaN(array[i])) { [EOL]             return Float.NaN; [EOL]         } [EOL]         if (array[i] < min) { [EOL]             min = array[i]; [EOL]         } [EOL]     } [EOL]     return min; [EOL] }
public static long max(final long[] array) { [EOL]     validateArray(array); [EOL]     long max = array[0]; [EOL]     for (int j = 1; j < array.length; j++) { [EOL]         if (array[j] > max) { [EOL]             max = array[j]; [EOL]         } [EOL]     } [EOL]     return max; [EOL] }
public static long max(final long[] array) { [EOL]     validateArray(array); [EOL]     long max = array[0]; [EOL]     for (int j = 1; j < array.length; j++) { [EOL]         if (array[j] > max) { [EOL]             max = array[j]; [EOL]         } [EOL]     } [EOL]     return max; [EOL] }
public static long max(final long[] array) { [EOL]     validateArray(array); [EOL]     long max = array[0]; [EOL]     for (int j = 1; j < array.length; j++) { [EOL]         if (array[j] > max) { [EOL]             max = array[j]; [EOL]         } [EOL]     } [EOL]     return max; [EOL] }
public static long max(final long[] array) { [EOL]     validateArray(array); [EOL]     long max = array[0]; [EOL]     for (int j = 1; j < array.length; j++) { [EOL]         if (array[j] > max) { [EOL]             max = array[j]; [EOL]         } [EOL]     } [EOL]     return max; [EOL] }
public static long max(final long[] array) { [EOL]     validateArray(array); [EOL]     long max = array[0]; [EOL]     for (int j = 1; j < array.length; j++) { [EOL]         if (array[j] > max) { [EOL]             max = array[j]; [EOL]         } [EOL]     } [EOL]     return max; [EOL] }
public static short max(final short[] array) { [EOL]     validateArray(array); [EOL]     short max = array[0]; [EOL]     for (int i = 1; i < array.length; i++) { [EOL]         if (array[i] > max) { [EOL]             max = array[i]; [EOL]         } [EOL]     } [EOL]     return max; [EOL] }
public static short max(final short[] array) { [EOL]     validateArray(array); [EOL]     short max = array[0]; [EOL]     for (int i = 1; i < array.length; i++) { [EOL]         if (array[i] > max) { [EOL]             max = array[i]; [EOL]         } [EOL]     } [EOL]     return max; [EOL] }
public static short max(final short[] array) { [EOL]     validateArray(array); [EOL]     short max = array[0]; [EOL]     for (int i = 1; i < array.length; i++) { [EOL]         if (array[i] > max) { [EOL]             max = array[i]; [EOL]         } [EOL]     } [EOL]     return max; [EOL] }
public static short max(final short[] array) { [EOL]     validateArray(array); [EOL]     short max = array[0]; [EOL]     for (int i = 1; i < array.length; i++) { [EOL]         if (array[i] > max) { [EOL]             max = array[i]; [EOL]         } [EOL]     } [EOL]     return max; [EOL] }
public static short max(final short[] array) { [EOL]     validateArray(array); [EOL]     short max = array[0]; [EOL]     for (int i = 1; i < array.length; i++) { [EOL]         if (array[i] > max) { [EOL]             max = array[i]; [EOL]         } [EOL]     } [EOL]     return max; [EOL] }
private static void validateArray(final Object array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } else if (Array.getLength(array) == 0) { [EOL]         throw new IllegalArgumentException("Array cannot be empty."); [EOL]     } [EOL] }
private static void validateArray(final Object array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } else if (Array.getLength(array) == 0) { [EOL]         throw new IllegalArgumentException("Array cannot be empty."); [EOL]     } [EOL] }
private static void validateArray(final Object array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } else if (Array.getLength(array) == 0) { [EOL]         throw new IllegalArgumentException("Array cannot be empty."); [EOL]     } [EOL] }
public static long min(long a, final long b, final long c) { [EOL]     if (b < a) { [EOL]         a = b; [EOL]     } [EOL]     if (c < a) { [EOL]         a = c; [EOL]     } [EOL]     return a; [EOL] }
public static int min(int a, final int b, final int c) { [EOL]     if (b < a) { [EOL]         a = b; [EOL]     } [EOL]     if (c < a) { [EOL]         a = c; [EOL]     } [EOL]     return a; [EOL] }
public static int min(int a, final int b, final int c) { [EOL]     if (b < a) { [EOL]         a = b; [EOL]     } [EOL]     if (c < a) { [EOL]         a = c; [EOL]     } [EOL]     return a; [EOL] }
public static byte min(byte a, final byte b, final byte c) { [EOL]     if (b < a) { [EOL]         a = b; [EOL]     } [EOL]     if (c < a) { [EOL]         a = c; [EOL]     } [EOL]     return a; [EOL] }
public static byte min(byte a, final byte b, final byte c) { [EOL]     if (b < a) { [EOL]         a = b; [EOL]     } [EOL]     if (c < a) { [EOL]         a = c; [EOL]     } [EOL]     return a; [EOL] }
public static byte min(byte a, final byte b, final byte c) { [EOL]     if (b < a) { [EOL]         a = b; [EOL]     } [EOL]     if (c < a) { [EOL]         a = c; [EOL]     } [EOL]     return a; [EOL] }
public static short max(short a, final short b, final short c) { [EOL]     if (b > a) { [EOL]         a = b; [EOL]     } [EOL]     if (c > a) { [EOL]         a = c; [EOL]     } [EOL]     return a; [EOL] }
public static short max(short a, final short b, final short c) { [EOL]     if (b > a) { [EOL]         a = b; [EOL]     } [EOL]     if (c > a) { [EOL]         a = c; [EOL]     } [EOL]     return a; [EOL] }
public static short max(short a, final short b, final short c) { [EOL]     if (b > a) { [EOL]         a = b; [EOL]     } [EOL]     if (c > a) { [EOL]         a = c; [EOL]     } [EOL]     return a; [EOL] }
public static short max(short a, final short b, final short c) { [EOL]     if (b > a) { [EOL]         a = b; [EOL]     } [EOL]     if (c > a) { [EOL]         a = c; [EOL]     } [EOL]     return a; [EOL] }
public static boolean isNumber(final String str) { [EOL]     if (StringUtils.isEmpty(str)) { [EOL]         return false; [EOL]     } [EOL]     final char[] chars = str.toCharArray(); [EOL]     int sz = chars.length; [EOL]     boolean hasExp = false; [EOL]     boolean hasDecPoint = false; [EOL]     boolean allowSigns = false; [EOL]     boolean foundDigit = false; [EOL]     final int start = (chars[0] == '-') ? 1 : 0; [EOL]     if (sz > start + 1 && chars[start] == '0' && chars[start + 1] == 'x') { [EOL]         int i = start + 2; [EOL]         if (i == sz) { [EOL]             return false; [EOL]         } [EOL]         for (; i < chars.length; i++) { [EOL]             if ((chars[i] < '0' || chars[i] > '9') && (chars[i] < 'a' || chars[i] > 'f') && (chars[i] < 'A' || chars[i] > 'F')) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]         return true; [EOL]     } [EOL]     sz--; [EOL]     int i = start; [EOL]     while (i < sz || (i < sz + 1 && allowSigns && !foundDigit)) { [EOL]         if (chars[i] >= '0' && chars[i] <= '9') { [EOL]             foundDigit = true; [EOL]             allowSigns = false; [EOL]         } else if (chars[i] == '.') { [EOL]             if (hasDecPoint || hasExp) { [EOL]                 return false; [EOL]             } [EOL]             hasDecPoint = true; [EOL]         } else if (chars[i] == 'e' || chars[i] == 'E') { [EOL]             if (hasExp) { [EOL]                 return false; [EOL]             } [EOL]             if (!foundDigit) { [EOL]                 return false; [EOL]             } [EOL]             hasExp = true; [EOL]             allowSigns = true; [EOL]         } else if (chars[i] == '+' || chars[i] == '-') { [EOL]             if (!allowSigns) { [EOL]                 return false; [EOL]             } [EOL]             allowSigns = false; [EOL]             foundDigit = false; [EOL]         } else { [EOL]             return false; [EOL]         } [EOL]         i++; [EOL]     } [EOL]     if (i < chars.length) { [EOL]         if (chars[i] >= '0' && chars[i] <= '9') { [EOL]             return true; [EOL]         } [EOL]         if (chars[i] == 'e' || chars[i] == 'E') { [EOL]             return false; [EOL]         } [EOL]         if (chars[i] == '.') { [EOL]             if (hasDecPoint || hasExp) { [EOL]                 return false; [EOL]             } [EOL]             return foundDigit; [EOL]         } [EOL]         if (!allowSigns && (chars[i] == 'd' || chars[i] == 'D' || chars[i] == 'f' || chars[i] == 'F')) { [EOL]             return foundDigit; [EOL]         } [EOL]         if (chars[i] == 'l' || chars[i] == 'L') { [EOL]             return foundDigit && !hasExp && !hasDecPoint; [EOL]         } [EOL]         return false; [EOL]     } [EOL]     return !allowSigns && foundDigit; [EOL] }
public static boolean isNumber(final String str) { [EOL]     if (StringUtils.isEmpty(str)) { [EOL]         return false; [EOL]     } [EOL]     final char[] chars = str.toCharArray(); [EOL]     int sz = chars.length; [EOL]     boolean hasExp = false; [EOL]     boolean hasDecPoint = false; [EOL]     boolean allowSigns = false; [EOL]     boolean foundDigit = false; [EOL]     final int start = (chars[0] == '-') ? 1 : 0; [EOL]     if (sz > start + 1 && chars[start] == '0' && chars[start + 1] == 'x') { [EOL]         int i = start + 2; [EOL]         if (i == sz) { [EOL]             return false; [EOL]         } [EOL]         for (; i < chars.length; i++) { [EOL]             if ((chars[i] < '0' || chars[i] > '9') && (chars[i] < 'a' || chars[i] > 'f') && (chars[i] < 'A' || chars[i] > 'F')) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]         return true; [EOL]     } [EOL]     sz--; [EOL]     int i = start; [EOL]     while (i < sz || (i < sz + 1 && allowSigns && !foundDigit)) { [EOL]         if (chars[i] >= '0' && chars[i] <= '9') { [EOL]             foundDigit = true; [EOL]             allowSigns = false; [EOL]         } else if (chars[i] == '.') { [EOL]             if (hasDecPoint || hasExp) { [EOL]                 return false; [EOL]             } [EOL]             hasDecPoint = true; [EOL]         } else if (chars[i] == 'e' || chars[i] == 'E') { [EOL]             if (hasExp) { [EOL]                 return false; [EOL]             } [EOL]             if (!foundDigit) { [EOL]                 return false; [EOL]             } [EOL]             hasExp = true; [EOL]             allowSigns = true; [EOL]         } else if (chars[i] == '+' || chars[i] == '-') { [EOL]             if (!allowSigns) { [EOL]                 return false; [EOL]             } [EOL]             allowSigns = false; [EOL]             foundDigit = false; [EOL]         } else { [EOL]             return false; [EOL]         } [EOL]         i++; [EOL]     } [EOL]     if (i < chars.length) { [EOL]         if (chars[i] >= '0' && chars[i] <= '9') { [EOL]             return true; [EOL]         } [EOL]         if (chars[i] == 'e' || chars[i] == 'E') { [EOL]             return false; [EOL]         } [EOL]         if (chars[i] == '.') { [EOL]             if (hasDecPoint || hasExp) { [EOL]                 return false; [EOL]             } [EOL]             return foundDigit; [EOL]         } [EOL]         if (!allowSigns && (chars[i] == 'd' || chars[i] == 'D' || chars[i] == 'f' || chars[i] == 'F')) { [EOL]             return foundDigit; [EOL]         } [EOL]         if (chars[i] == 'l' || chars[i] == 'L') { [EOL]             return foundDigit && !hasExp && !hasDecPoint; [EOL]         } [EOL]         return false; [EOL]     } [EOL]     return !allowSigns && foundDigit; [EOL] }
public static boolean isNumber(final String str) { [EOL]     if (StringUtils.isEmpty(str)) { [EOL]         return false; [EOL]     } [EOL]     final char[] chars = str.toCharArray(); [EOL]     int sz = chars.length; [EOL]     boolean hasExp = false; [EOL]     boolean hasDecPoint = false; [EOL]     boolean allowSigns = false; [EOL]     boolean foundDigit = false; [EOL]     final int start = (chars[0] == '-') ? 1 : 0; [EOL]     if (sz > start + 1 && chars[start] == '0' && chars[start + 1] == 'x') { [EOL]         int i = start + 2; [EOL]         if (i == sz) { [EOL]             return false; [EOL]         } [EOL]         for (; i < chars.length; i++) { [EOL]             if ((chars[i] < '0' || chars[i] > '9') && (chars[i] < 'a' || chars[i] > 'f') && (chars[i] < 'A' || chars[i] > 'F')) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]         return true; [EOL]     } [EOL]     sz--; [EOL]     int i = start; [EOL]     while (i < sz || (i < sz + 1 && allowSigns && !foundDigit)) { [EOL]         if (chars[i] >= '0' && chars[i] <= '9') { [EOL]             foundDigit = true; [EOL]             allowSigns = false; [EOL]         } else if (chars[i] == '.') { [EOL]             if (hasDecPoint || hasExp) { [EOL]                 return false; [EOL]             } [EOL]             hasDecPoint = true; [EOL]         } else if (chars[i] == 'e' || chars[i] == 'E') { [EOL]             if (hasExp) { [EOL]                 return false; [EOL]             } [EOL]             if (!foundDigit) { [EOL]                 return false; [EOL]             } [EOL]             hasExp = true; [EOL]             allowSigns = true; [EOL]         } else if (chars[i] == '+' || chars[i] == '-') { [EOL]             if (!allowSigns) { [EOL]                 return false; [EOL]             } [EOL]             allowSigns = false; [EOL]             foundDigit = false; [EOL]         } else { [EOL]             return false; [EOL]         } [EOL]         i++; [EOL]     } [EOL]     if (i < chars.length) { [EOL]         if (chars[i] >= '0' && chars[i] <= '9') { [EOL]             return true; [EOL]         } [EOL]         if (chars[i] == 'e' || chars[i] == 'E') { [EOL]             return false; [EOL]         } [EOL]         if (chars[i] == '.') { [EOL]             if (hasDecPoint || hasExp) { [EOL]                 return false; [EOL]             } [EOL]             return foundDigit; [EOL]         } [EOL]         if (!allowSigns && (chars[i] == 'd' || chars[i] == 'D' || chars[i] == 'f' || chars[i] == 'F')) { [EOL]             return foundDigit; [EOL]         } [EOL]         if (chars[i] == 'l' || chars[i] == 'L') { [EOL]             return foundDigit && !hasExp && !hasDecPoint; [EOL]         } [EOL]         return false; [EOL]     } [EOL]     return !allowSigns && foundDigit; [EOL] }
public static boolean isNumber(final String str) { [EOL]     if (StringUtils.isEmpty(str)) { [EOL]         return false; [EOL]     } [EOL]     final char[] chars = str.toCharArray(); [EOL]     int sz = chars.length; [EOL]     boolean hasExp = false; [EOL]     boolean hasDecPoint = false; [EOL]     boolean allowSigns = false; [EOL]     boolean foundDigit = false; [EOL]     final int start = (chars[0] == '-') ? 1 : 0; [EOL]     if (sz > start + 1 && chars[start] == '0' && chars[start + 1] == 'x') { [EOL]         int i = start + 2; [EOL]         if (i == sz) { [EOL]             return false; [EOL]         } [EOL]         for (; i < chars.length; i++) { [EOL]             if ((chars[i] < '0' || chars[i] > '9') && (chars[i] < 'a' || chars[i] > 'f') && (chars[i] < 'A' || chars[i] > 'F')) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]         return true; [EOL]     } [EOL]     sz--; [EOL]     int i = start; [EOL]     while (i < sz || (i < sz + 1 && allowSigns && !foundDigit)) { [EOL]         if (chars[i] >= '0' && chars[i] <= '9') { [EOL]             foundDigit = true; [EOL]             allowSigns = false; [EOL]         } else if (chars[i] == '.') { [EOL]             if (hasDecPoint || hasExp) { [EOL]                 return false; [EOL]             } [EOL]             hasDecPoint = true; [EOL]         } else if (chars[i] == 'e' || chars[i] == 'E') { [EOL]             if (hasExp) { [EOL]                 return false; [EOL]             } [EOL]             if (!foundDigit) { [EOL]                 return false; [EOL]             } [EOL]             hasExp = true; [EOL]             allowSigns = true; [EOL]         } else if (chars[i] == '+' || chars[i] == '-') { [EOL]             if (!allowSigns) { [EOL]                 return false; [EOL]             } [EOL]             allowSigns = false; [EOL]             foundDigit = false; [EOL]         } else { [EOL]             return false; [EOL]         } [EOL]         i++; [EOL]     } [EOL]     if (i < chars.length) { [EOL]         if (chars[i] >= '0' && chars[i] <= '9') { [EOL]             return true; [EOL]         } [EOL]         if (chars[i] == 'e' || chars[i] == 'E') { [EOL]             return false; [EOL]         } [EOL]         if (chars[i] == '.') { [EOL]             if (hasDecPoint || hasExp) { [EOL]                 return false; [EOL]             } [EOL]             return foundDigit; [EOL]         } [EOL]         if (!allowSigns && (chars[i] == 'd' || chars[i] == 'D' || chars[i] == 'f' || chars[i] == 'F')) { [EOL]             return foundDigit; [EOL]         } [EOL]         if (chars[i] == 'l' || chars[i] == 'L') { [EOL]             return foundDigit && !hasExp && !hasDecPoint; [EOL]         } [EOL]         return false; [EOL]     } [EOL]     return !allowSigns && foundDigit; [EOL] }
public static boolean isNumber(final String str) { [EOL]     if (StringUtils.isEmpty(str)) { [EOL]         return false; [EOL]     } [EOL]     final char[] chars = str.toCharArray(); [EOL]     int sz = chars.length; [EOL]     boolean hasExp = false; [EOL]     boolean hasDecPoint = false; [EOL]     boolean allowSigns = false; [EOL]     boolean foundDigit = false; [EOL]     final int start = (chars[0] == '-') ? 1 : 0; [EOL]     if (sz > start + 1 && chars[start] == '0' && chars[start + 1] == 'x') { [EOL]         int i = start + 2; [EOL]         if (i == sz) { [EOL]             return false; [EOL]         } [EOL]         for (; i < chars.length; i++) { [EOL]             if ((chars[i] < '0' || chars[i] > '9') && (chars[i] < 'a' || chars[i] > 'f') && (chars[i] < 'A' || chars[i] > 'F')) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]         return true; [EOL]     } [EOL]     sz--; [EOL]     int i = start; [EOL]     while (i < sz || (i < sz + 1 && allowSigns && !foundDigit)) { [EOL]         if (chars[i] >= '0' && chars[i] <= '9') { [EOL]             foundDigit = true; [EOL]             allowSigns = false; [EOL]         } else if (chars[i] == '.') { [EOL]             if (hasDecPoint || hasExp) { [EOL]                 return false; [EOL]             } [EOL]             hasDecPoint = true; [EOL]         } else if (chars[i] == 'e' || chars[i] == 'E') { [EOL]             if (hasExp) { [EOL]                 return false; [EOL]             } [EOL]             if (!foundDigit) { [EOL]                 return false; [EOL]             } [EOL]             hasExp = true; [EOL]             allowSigns = true; [EOL]         } else if (chars[i] == '+' || chars[i] == '-') { [EOL]             if (!allowSigns) { [EOL]                 return false; [EOL]             } [EOL]             allowSigns = false; [EOL]             foundDigit = false; [EOL]         } else { [EOL]             return false; [EOL]         } [EOL]         i++; [EOL]     } [EOL]     if (i < chars.length) { [EOL]         if (chars[i] >= '0' && chars[i] <= '9') { [EOL]             return true; [EOL]         } [EOL]         if (chars[i] == 'e' || chars[i] == 'E') { [EOL]             return false; [EOL]         } [EOL]         if (chars[i] == '.') { [EOL]             if (hasDecPoint || hasExp) { [EOL]                 return false; [EOL]             } [EOL]             return foundDigit; [EOL]         } [EOL]         if (!allowSigns && (chars[i] == 'd' || chars[i] == 'D' || chars[i] == 'f' || chars[i] == 'F')) { [EOL]             return foundDigit; [EOL]         } [EOL]         if (chars[i] == 'l' || chars[i] == 'L') { [EOL]             return foundDigit && !hasExp && !hasDecPoint; [EOL]         } [EOL]         return false; [EOL]     } [EOL]     return !allowSigns && foundDigit; [EOL] }
public static boolean isNumber(final String str) { [EOL]     if (StringUtils.isEmpty(str)) { [EOL]         return false; [EOL]     } [EOL]     final char[] chars = str.toCharArray(); [EOL]     int sz = chars.length; [EOL]     boolean hasExp = false; [EOL]     boolean hasDecPoint = false; [EOL]     boolean allowSigns = false; [EOL]     boolean foundDigit = false; [EOL]     final int start = (chars[0] == '-') ? 1 : 0; [EOL]     if (sz > start + 1 && chars[start] == '0' && chars[start + 1] == 'x') { [EOL]         int i = start + 2; [EOL]         if (i == sz) { [EOL]             return false; [EOL]         } [EOL]         for (; i < chars.length; i++) { [EOL]             if ((chars[i] < '0' || chars[i] > '9') && (chars[i] < 'a' || chars[i] > 'f') && (chars[i] < 'A' || chars[i] > 'F')) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]         return true; [EOL]     } [EOL]     sz--; [EOL]     int i = start; [EOL]     while (i < sz || (i < sz + 1 && allowSigns && !foundDigit)) { [EOL]         if (chars[i] >= '0' && chars[i] <= '9') { [EOL]             foundDigit = true; [EOL]             allowSigns = false; [EOL]         } else if (chars[i] == '.') { [EOL]             if (hasDecPoint || hasExp) { [EOL]                 return false; [EOL]             } [EOL]             hasDecPoint = true; [EOL]         } else if (chars[i] == 'e' || chars[i] == 'E') { [EOL]             if (hasExp) { [EOL]                 return false; [EOL]             } [EOL]             if (!foundDigit) { [EOL]                 return false; [EOL]             } [EOL]             hasExp = true; [EOL]             allowSigns = true; [EOL]         } else if (chars[i] == '+' || chars[i] == '-') { [EOL]             if (!allowSigns) { [EOL]                 return false; [EOL]             } [EOL]             allowSigns = false; [EOL]             foundDigit = false; [EOL]         } else { [EOL]             return false; [EOL]         } [EOL]         i++; [EOL]     } [EOL]     if (i < chars.length) { [EOL]         if (chars[i] >= '0' && chars[i] <= '9') { [EOL]             return true; [EOL]         } [EOL]         if (chars[i] == 'e' || chars[i] == 'E') { [EOL]             return false; [EOL]         } [EOL]         if (chars[i] == '.') { [EOL]             if (hasDecPoint || hasExp) { [EOL]                 return false; [EOL]             } [EOL]             return foundDigit; [EOL]         } [EOL]         if (!allowSigns && (chars[i] == 'd' || chars[i] == 'D' || chars[i] == 'f' || chars[i] == 'F')) { [EOL]             return foundDigit; [EOL]         } [EOL]         if (chars[i] == 'l' || chars[i] == 'L') { [EOL]             return foundDigit && !hasExp && !hasDecPoint; [EOL]         } [EOL]         return false; [EOL]     } [EOL]     return !allowSigns && foundDigit; [EOL] }
public static boolean isNumber(final String str) { [EOL]     if (StringUtils.isEmpty(str)) { [EOL]         return false; [EOL]     } [EOL]     final char[] chars = str.toCharArray(); [EOL]     int sz = chars.length; [EOL]     boolean hasExp = false; [EOL]     boolean hasDecPoint = false; [EOL]     boolean allowSigns = false; [EOL]     boolean foundDigit = false; [EOL]     final int start = (chars[0] == '-') ? 1 : 0; [EOL]     if (sz > start + 1 && chars[start] == '0' && chars[start + 1] == 'x') { [EOL]         int i = start + 2; [EOL]         if (i == sz) { [EOL]             return false; [EOL]         } [EOL]         for (; i < chars.length; i++) { [EOL]             if ((chars[i] < '0' || chars[i] > '9') && (chars[i] < 'a' || chars[i] > 'f') && (chars[i] < 'A' || chars[i] > 'F')) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]         return true; [EOL]     } [EOL]     sz--; [EOL]     int i = start; [EOL]     while (i < sz || (i < sz + 1 && allowSigns && !foundDigit)) { [EOL]         if (chars[i] >= '0' && chars[i] <= '9') { [EOL]             foundDigit = true; [EOL]             allowSigns = false; [EOL]         } else if (chars[i] == '.') { [EOL]             if (hasDecPoint || hasExp) { [EOL]                 return false; [EOL]             } [EOL]             hasDecPoint = true; [EOL]         } else if (chars[i] == 'e' || chars[i] == 'E') { [EOL]             if (hasExp) { [EOL]                 return false; [EOL]             } [EOL]             if (!foundDigit) { [EOL]                 return false; [EOL]             } [EOL]             hasExp = true; [EOL]             allowSigns = true; [EOL]         } else if (chars[i] == '+' || chars[i] == '-') { [EOL]             if (!allowSigns) { [EOL]                 return false; [EOL]             } [EOL]             allowSigns = false; [EOL]             foundDigit = false; [EOL]         } else { [EOL]             return false; [EOL]         } [EOL]         i++; [EOL]     } [EOL]     if (i < chars.length) { [EOL]         if (chars[i] >= '0' && chars[i] <= '9') { [EOL]             return true; [EOL]         } [EOL]         if (chars[i] == 'e' || chars[i] == 'E') { [EOL]             return false; [EOL]         } [EOL]         if (chars[i] == '.') { [EOL]             if (hasDecPoint || hasExp) { [EOL]                 return false; [EOL]             } [EOL]             return foundDigit; [EOL]         } [EOL]         if (!allowSigns && (chars[i] == 'd' || chars[i] == 'D' || chars[i] == 'f' || chars[i] == 'F')) { [EOL]             return foundDigit; [EOL]         } [EOL]         if (chars[i] == 'l' || chars[i] == 'L') { [EOL]             return foundDigit && !hasExp && !hasDecPoint; [EOL]         } [EOL]         return false; [EOL]     } [EOL]     return !allowSigns && foundDigit; [EOL] }
public static boolean isNumber(final String str) { [EOL]     if (StringUtils.isEmpty(str)) { [EOL]         return false; [EOL]     } [EOL]     final char[] chars = str.toCharArray(); [EOL]     int sz = chars.length; [EOL]     boolean hasExp = false; [EOL]     boolean hasDecPoint = false; [EOL]     boolean allowSigns = false; [EOL]     boolean foundDigit = false; [EOL]     final int start = (chars[0] == '-') ? 1 : 0; [EOL]     if (sz > start + 1 && chars[start] == '0' && chars[start + 1] == 'x') { [EOL]         int i = start + 2; [EOL]         if (i == sz) { [EOL]             return false; [EOL]         } [EOL]         for (; i < chars.length; i++) { [EOL]             if ((chars[i] < '0' || chars[i] > '9') && (chars[i] < 'a' || chars[i] > 'f') && (chars[i] < 'A' || chars[i] > 'F')) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]         return true; [EOL]     } [EOL]     sz--; [EOL]     int i = start; [EOL]     while (i < sz || (i < sz + 1 && allowSigns && !foundDigit)) { [EOL]         if (chars[i] >= '0' && chars[i] <= '9') { [EOL]             foundDigit = true; [EOL]             allowSigns = false; [EOL]         } else if (chars[i] == '.') { [EOL]             if (hasDecPoint || hasExp) { [EOL]                 return false; [EOL]             } [EOL]             hasDecPoint = true; [EOL]         } else if (chars[i] == 'e' || chars[i] == 'E') { [EOL]             if (hasExp) { [EOL]                 return false; [EOL]             } [EOL]             if (!foundDigit) { [EOL]                 return false; [EOL]             } [EOL]             hasExp = true; [EOL]             allowSigns = true; [EOL]         } else if (chars[i] == '+' || chars[i] == '-') { [EOL]             if (!allowSigns) { [EOL]                 return false; [EOL]             } [EOL]             allowSigns = false; [EOL]             foundDigit = false; [EOL]         } else { [EOL]             return false; [EOL]         } [EOL]         i++; [EOL]     } [EOL]     if (i < chars.length) { [EOL]         if (chars[i] >= '0' && chars[i] <= '9') { [EOL]             return true; [EOL]         } [EOL]         if (chars[i] == 'e' || chars[i] == 'E') { [EOL]             return false; [EOL]         } [EOL]         if (chars[i] == '.') { [EOL]             if (hasDecPoint || hasExp) { [EOL]                 return false; [EOL]             } [EOL]             return foundDigit; [EOL]         } [EOL]         if (!allowSigns && (chars[i] == 'd' || chars[i] == 'D' || chars[i] == 'f' || chars[i] == 'F')) { [EOL]             return foundDigit; [EOL]         } [EOL]         if (chars[i] == 'l' || chars[i] == 'L') { [EOL]             return foundDigit && !hasExp && !hasDecPoint; [EOL]         } [EOL]         return false; [EOL]     } [EOL]     return !allowSigns && foundDigit; [EOL] }
public static boolean isNumber(final String str) { [EOL]     if (StringUtils.isEmpty(str)) { [EOL]         return false; [EOL]     } [EOL]     final char[] chars = str.toCharArray(); [EOL]     int sz = chars.length; [EOL]     boolean hasExp = false; [EOL]     boolean hasDecPoint = false; [EOL]     boolean allowSigns = false; [EOL]     boolean foundDigit = false; [EOL]     final int start = (chars[0] == '-') ? 1 : 0; [EOL]     if (sz > start + 1 && chars[start] == '0' && chars[start + 1] == 'x') { [EOL]         int i = start + 2; [EOL]         if (i == sz) { [EOL]             return false; [EOL]         } [EOL]         for (; i < chars.length; i++) { [EOL]             if ((chars[i] < '0' || chars[i] > '9') && (chars[i] < 'a' || chars[i] > 'f') && (chars[i] < 'A' || chars[i] > 'F')) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]         return true; [EOL]     } [EOL]     sz--; [EOL]     int i = start; [EOL]     while (i < sz || (i < sz + 1 && allowSigns && !foundDigit)) { [EOL]         if (chars[i] >= '0' && chars[i] <= '9') { [EOL]             foundDigit = true; [EOL]             allowSigns = false; [EOL]         } else if (chars[i] == '.') { [EOL]             if (hasDecPoint || hasExp) { [EOL]                 return false; [EOL]             } [EOL]             hasDecPoint = true; [EOL]         } else if (chars[i] == 'e' || chars[i] == 'E') { [EOL]             if (hasExp) { [EOL]                 return false; [EOL]             } [EOL]             if (!foundDigit) { [EOL]                 return false; [EOL]             } [EOL]             hasExp = true; [EOL]             allowSigns = true; [EOL]         } else if (chars[i] == '+' || chars[i] == '-') { [EOL]             if (!allowSigns) { [EOL]                 return false; [EOL]             } [EOL]             allowSigns = false; [EOL]             foundDigit = false; [EOL]         } else { [EOL]             return false; [EOL]         } [EOL]         i++; [EOL]     } [EOL]     if (i < chars.length) { [EOL]         if (chars[i] >= '0' && chars[i] <= '9') { [EOL]             return true; [EOL]         } [EOL]         if (chars[i] == 'e' || chars[i] == 'E') { [EOL]             return false; [EOL]         } [EOL]         if (chars[i] == '.') { [EOL]             if (hasDecPoint || hasExp) { [EOL]                 return false; [EOL]             } [EOL]             return foundDigit; [EOL]         } [EOL]         if (!allowSigns && (chars[i] == 'd' || chars[i] == 'D' || chars[i] == 'f' || chars[i] == 'F')) { [EOL]             return foundDigit; [EOL]         } [EOL]         if (chars[i] == 'l' || chars[i] == 'L') { [EOL]             return foundDigit && !hasExp && !hasDecPoint; [EOL]         } [EOL]         return false; [EOL]     } [EOL]     return !allowSigns && foundDigit; [EOL] }
public static boolean isNumber(final String str) { [EOL]     if (StringUtils.isEmpty(str)) { [EOL]         return false; [EOL]     } [EOL]     final char[] chars = str.toCharArray(); [EOL]     int sz = chars.length; [EOL]     boolean hasExp = false; [EOL]     boolean hasDecPoint = false; [EOL]     boolean allowSigns = false; [EOL]     boolean foundDigit = false; [EOL]     final int start = (chars[0] == '-') ? 1 : 0; [EOL]     if (sz > start + 1 && chars[start] == '0' && chars[start + 1] == 'x') { [EOL]         int i = start + 2; [EOL]         if (i == sz) { [EOL]             return false; [EOL]         } [EOL]         for (; i < chars.length; i++) { [EOL]             if ((chars[i] < '0' || chars[i] > '9') && (chars[i] < 'a' || chars[i] > 'f') && (chars[i] < 'A' || chars[i] > 'F')) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]         return true; [EOL]     } [EOL]     sz--; [EOL]     int i = start; [EOL]     while (i < sz || (i < sz + 1 && allowSigns && !foundDigit)) { [EOL]         if (chars[i] >= '0' && chars[i] <= '9') { [EOL]             foundDigit = true; [EOL]             allowSigns = false; [EOL]         } else if (chars[i] == '.') { [EOL]             if (hasDecPoint || hasExp) { [EOL]                 return false; [EOL]             } [EOL]             hasDecPoint = true; [EOL]         } else if (chars[i] == 'e' || chars[i] == 'E') { [EOL]             if (hasExp) { [EOL]                 return false; [EOL]             } [EOL]             if (!foundDigit) { [EOL]                 return false; [EOL]             } [EOL]             hasExp = true; [EOL]             allowSigns = true; [EOL]         } else if (chars[i] == '+' || chars[i] == '-') { [EOL]             if (!allowSigns) { [EOL]                 return false; [EOL]             } [EOL]             allowSigns = false; [EOL]             foundDigit = false; [EOL]         } else { [EOL]             return false; [EOL]         } [EOL]         i++; [EOL]     } [EOL]     if (i < chars.length) { [EOL]         if (chars[i] >= '0' && chars[i] <= '9') { [EOL]             return true; [EOL]         } [EOL]         if (chars[i] == 'e' || chars[i] == 'E') { [EOL]             return false; [EOL]         } [EOL]         if (chars[i] == '.') { [EOL]             if (hasDecPoint || hasExp) { [EOL]                 return false; [EOL]             } [EOL]             return foundDigit; [EOL]         } [EOL]         if (!allowSigns && (chars[i] == 'd' || chars[i] == 'D' || chars[i] == 'f' || chars[i] == 'F')) { [EOL]             return foundDigit; [EOL]         } [EOL]         if (chars[i] == 'l' || chars[i] == 'L') { [EOL]             return foundDigit && !hasExp && !hasDecPoint; [EOL]         } [EOL]         return false; [EOL]     } [EOL]     return !allowSigns && foundDigit; [EOL] }
public static boolean isNumber(final String str) { [EOL]     if (StringUtils.isEmpty(str)) { [EOL]         return false; [EOL]     } [EOL]     final char[] chars = str.toCharArray(); [EOL]     int sz = chars.length; [EOL]     boolean hasExp = false; [EOL]     boolean hasDecPoint = false; [EOL]     boolean allowSigns = false; [EOL]     boolean foundDigit = false; [EOL]     final int start = (chars[0] == '-') ? 1 : 0; [EOL]     if (sz > start + 1 && chars[start] == '0' && chars[start + 1] == 'x') { [EOL]         int i = start + 2; [EOL]         if (i == sz) { [EOL]             return false; [EOL]         } [EOL]         for (; i < chars.length; i++) { [EOL]             if ((chars[i] < '0' || chars[i] > '9') && (chars[i] < 'a' || chars[i] > 'f') && (chars[i] < 'A' || chars[i] > 'F')) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]         return true; [EOL]     } [EOL]     sz--; [EOL]     int i = start; [EOL]     while (i < sz || (i < sz + 1 && allowSigns && !foundDigit)) { [EOL]         if (chars[i] >= '0' && chars[i] <= '9') { [EOL]             foundDigit = true; [EOL]             allowSigns = false; [EOL]         } else if (chars[i] == '.') { [EOL]             if (hasDecPoint || hasExp) { [EOL]                 return false; [EOL]             } [EOL]             hasDecPoint = true; [EOL]         } else if (chars[i] == 'e' || chars[i] == 'E') { [EOL]             if (hasExp) { [EOL]                 return false; [EOL]             } [EOL]             if (!foundDigit) { [EOL]                 return false; [EOL]             } [EOL]             hasExp = true; [EOL]             allowSigns = true; [EOL]         } else if (chars[i] == '+' || chars[i] == '-') { [EOL]             if (!allowSigns) { [EOL]                 return false; [EOL]             } [EOL]             allowSigns = false; [EOL]             foundDigit = false; [EOL]         } else { [EOL]             return false; [EOL]         } [EOL]         i++; [EOL]     } [EOL]     if (i < chars.length) { [EOL]         if (chars[i] >= '0' && chars[i] <= '9') { [EOL]             return true; [EOL]         } [EOL]         if (chars[i] == 'e' || chars[i] == 'E') { [EOL]             return false; [EOL]         } [EOL]         if (chars[i] == '.') { [EOL]             if (hasDecPoint || hasExp) { [EOL]                 return false; [EOL]             } [EOL]             return foundDigit; [EOL]         } [EOL]         if (!allowSigns && (chars[i] == 'd' || chars[i] == 'D' || chars[i] == 'f' || chars[i] == 'F')) { [EOL]             return foundDigit; [EOL]         } [EOL]         if (chars[i] == 'l' || chars[i] == 'L') { [EOL]             return foundDigit && !hasExp && !hasDecPoint; [EOL]         } [EOL]         return false; [EOL]     } [EOL]     return !allowSigns && foundDigit; [EOL] }
public static boolean isNumber(final String str) { [EOL]     if (StringUtils.isEmpty(str)) { [EOL]         return false; [EOL]     } [EOL]     final char[] chars = str.toCharArray(); [EOL]     int sz = chars.length; [EOL]     boolean hasExp = false; [EOL]     boolean hasDecPoint = false; [EOL]     boolean allowSigns = false; [EOL]     boolean foundDigit = false; [EOL]     final int start = (chars[0] == '-') ? 1 : 0; [EOL]     if (sz > start + 1 && chars[start] == '0' && chars[start + 1] == 'x') { [EOL]         int i = start + 2; [EOL]         if (i == sz) { [EOL]             return false; [EOL]         } [EOL]         for (; i < chars.length; i++) { [EOL]             if ((chars[i] < '0' || chars[i] > '9') && (chars[i] < 'a' || chars[i] > 'f') && (chars[i] < 'A' || chars[i] > 'F')) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]         return true; [EOL]     } [EOL]     sz--; [EOL]     int i = start; [EOL]     while (i < sz || (i < sz + 1 && allowSigns && !foundDigit)) { [EOL]         if (chars[i] >= '0' && chars[i] <= '9') { [EOL]             foundDigit = true; [EOL]             allowSigns = false; [EOL]         } else if (chars[i] == '.') { [EOL]             if (hasDecPoint || hasExp) { [EOL]                 return false; [EOL]             } [EOL]             hasDecPoint = true; [EOL]         } else if (chars[i] == 'e' || chars[i] == 'E') { [EOL]             if (hasExp) { [EOL]                 return false; [EOL]             } [EOL]             if (!foundDigit) { [EOL]                 return false; [EOL]             } [EOL]             hasExp = true; [EOL]             allowSigns = true; [EOL]         } else if (chars[i] == '+' || chars[i] == '-') { [EOL]             if (!allowSigns) { [EOL]                 return false; [EOL]             } [EOL]             allowSigns = false; [EOL]             foundDigit = false; [EOL]         } else { [EOL]             return false; [EOL]         } [EOL]         i++; [EOL]     } [EOL]     if (i < chars.length) { [EOL]         if (chars[i] >= '0' && chars[i] <= '9') { [EOL]             return true; [EOL]         } [EOL]         if (chars[i] == 'e' || chars[i] == 'E') { [EOL]             return false; [EOL]         } [EOL]         if (chars[i] == '.') { [EOL]             if (hasDecPoint || hasExp) { [EOL]                 return false; [EOL]             } [EOL]             return foundDigit; [EOL]         } [EOL]         if (!allowSigns && (chars[i] == 'd' || chars[i] == 'D' || chars[i] == 'f' || chars[i] == 'F')) { [EOL]             return foundDigit; [EOL]         } [EOL]         if (chars[i] == 'l' || chars[i] == 'L') { [EOL]             return foundDigit && !hasExp && !hasDecPoint; [EOL]         } [EOL]         return false; [EOL]     } [EOL]     return !allowSigns && foundDigit; [EOL] }
public BitField(final int mask) { [EOL]     _mask = mask; [EOL]     int count = 0; [EOL]     int bit_pattern = mask; [EOL]     if (bit_pattern != 0) { [EOL]         while ((bit_pattern & 1) == 0) { [EOL]             count++; [EOL]             bit_pattern >>= 1; [EOL]         } [EOL]     } [EOL]     _shift_count = count; [EOL] }
public BitField(final int mask) { [EOL]     _mask = mask; [EOL]     int count = 0; [EOL]     int bit_pattern = mask; [EOL]     if (bit_pattern != 0) { [EOL]         while ((bit_pattern & 1) == 0) { [EOL]             count++; [EOL]             bit_pattern >>= 1; [EOL]         } [EOL]     } [EOL]     _shift_count = count; [EOL] }
public boolean isSet(final int holder) { [EOL]     return (holder & _mask) != 0; [EOL] }
public boolean isSet(final int holder) { [EOL]     return (holder & _mask) != 0; [EOL] }
public boolean isSet(final int holder) { [EOL]     return (holder & _mask) != 0; [EOL] }
public byte clearByte(final byte holder) { [EOL]     return (byte) clear(holder); [EOL] }
public byte clearByte(final byte holder) { [EOL]     return (byte) clear(holder); [EOL] }
public byte clearByte(final byte holder) { [EOL]     return (byte) clear(holder); [EOL] }
public byte setByte(final byte holder) { [EOL]     return (byte) set(holder); [EOL] }
public byte setByteBoolean(final byte holder, final boolean flag) { [EOL]     return flag ? setByte(holder) : clearByte(holder); [EOL] }
public byte setByteBoolean(final byte holder, final boolean flag) { [EOL]     return flag ? setByte(holder) : clearByte(holder); [EOL] }
public static <L> void addEventListener(final Object eventSource, final Class<L> listenerType, final L listener) { [EOL]     try { [EOL]         MethodUtils.invokeMethod(eventSource, "add" + listenerType.getSimpleName(), listener); [EOL]     } catch (final NoSuchMethodException e) { [EOL]         throw new IllegalArgumentException("Class " + eventSource.getClass().getName() + " does not have a public add" + listenerType.getSimpleName() + " method which takes a parameter of type " + listenerType.getName() + "."); [EOL]     } catch (final IllegalAccessException e) { [EOL]         throw new IllegalArgumentException("Class " + eventSource.getClass().getName() + " does not have an accessible add" + listenerType.getSimpleName() + " method which takes a parameter of type " + listenerType.getName() + "."); [EOL]     } catch (final InvocationTargetException e) { [EOL]         throw new RuntimeException("Unable to add listener.", e.getCause()); [EOL]     } [EOL] }
public static <L> void addEventListener(final Object eventSource, final Class<L> listenerType, final L listener) { [EOL]     try { [EOL]         MethodUtils.invokeMethod(eventSource, "add" + listenerType.getSimpleName(), listener); [EOL]     } catch (final NoSuchMethodException e) { [EOL]         throw new IllegalArgumentException("Class " + eventSource.getClass().getName() + " does not have a public add" + listenerType.getSimpleName() + " method which takes a parameter of type " + listenerType.getName() + "."); [EOL]     } catch (final IllegalAccessException e) { [EOL]         throw new IllegalArgumentException("Class " + eventSource.getClass().getName() + " does not have an accessible add" + listenerType.getSimpleName() + " method which takes a parameter of type " + listenerType.getName() + "."); [EOL]     } catch (final InvocationTargetException e) { [EOL]         throw new RuntimeException("Unable to add listener.", e.getCause()); [EOL]     } [EOL] }
public static <L> void addEventListener(final Object eventSource, final Class<L> listenerType, final L listener) { [EOL]     try { [EOL]         MethodUtils.invokeMethod(eventSource, "add" + listenerType.getSimpleName(), listener); [EOL]     } catch (final NoSuchMethodException e) { [EOL]         throw new IllegalArgumentException("Class " + eventSource.getClass().getName() + " does not have a public add" + listenerType.getSimpleName() + " method which takes a parameter of type " + listenerType.getName() + "."); [EOL]     } catch (final IllegalAccessException e) { [EOL]         throw new IllegalArgumentException("Class " + eventSource.getClass().getName() + " does not have an accessible add" + listenerType.getSimpleName() + " method which takes a parameter of type " + listenerType.getName() + "."); [EOL]     } catch (final InvocationTargetException e) { [EOL]         throw new RuntimeException("Unable to add listener.", e.getCause()); [EOL]     } [EOL] }
public static <L> void addEventListener(final Object eventSource, final Class<L> listenerType, final L listener) { [EOL]     try { [EOL]         MethodUtils.invokeMethod(eventSource, "add" + listenerType.getSimpleName(), listener); [EOL]     } catch (final NoSuchMethodException e) { [EOL]         throw new IllegalArgumentException("Class " + eventSource.getClass().getName() + " does not have a public add" + listenerType.getSimpleName() + " method which takes a parameter of type " + listenerType.getName() + "."); [EOL]     } catch (final IllegalAccessException e) { [EOL]         throw new IllegalArgumentException("Class " + eventSource.getClass().getName() + " does not have an accessible add" + listenerType.getSimpleName() + " method which takes a parameter of type " + listenerType.getName() + "."); [EOL]     } catch (final InvocationTargetException e) { [EOL]         throw new RuntimeException("Unable to add listener.", e.getCause()); [EOL]     } [EOL] }
public static <L> void addEventListener(final Object eventSource, final Class<L> listenerType, final L listener) { [EOL]     try { [EOL]         MethodUtils.invokeMethod(eventSource, "add" + listenerType.getSimpleName(), listener); [EOL]     } catch (final NoSuchMethodException e) { [EOL]         throw new IllegalArgumentException("Class " + eventSource.getClass().getName() + " does not have a public add" + listenerType.getSimpleName() + " method which takes a parameter of type " + listenerType.getName() + "."); [EOL]     } catch (final IllegalAccessException e) { [EOL]         throw new IllegalArgumentException("Class " + eventSource.getClass().getName() + " does not have an accessible add" + listenerType.getSimpleName() + " method which takes a parameter of type " + listenerType.getName() + "."); [EOL]     } catch (final InvocationTargetException e) { [EOL]         throw new RuntimeException("Unable to add listener.", e.getCause()); [EOL]     } [EOL] }
public static <L> void bindEventsToMethod(final Object target, final String methodName, final Object eventSource, final Class<L> listenerType, final String... eventTypes) { [EOL]     final L listener = listenerType.cast(Proxy.newProxyInstance(target.getClass().getClassLoader(), new Class[] { listenerType }, new EventBindingInvocationHandler(target, methodName, eventTypes))); [EOL]     addEventListener(eventSource, listenerType, listener); [EOL] }
public static <L> void bindEventsToMethod(final Object target, final String methodName, final Object eventSource, final Class<L> listenerType, final String... eventTypes) { [EOL]     final L listener = listenerType.cast(Proxy.newProxyInstance(target.getClass().getClassLoader(), new Class[] { listenerType }, new EventBindingInvocationHandler(target, methodName, eventTypes))); [EOL]     addEventListener(eventSource, listenerType, listener); [EOL] }
public static <L> void bindEventsToMethod(final Object target, final String methodName, final Object eventSource, final Class<L> listenerType, final String... eventTypes) { [EOL]     final L listener = listenerType.cast(Proxy.newProxyInstance(target.getClass().getClassLoader(), new Class[] { listenerType }, new EventBindingInvocationHandler(target, methodName, eventTypes))); [EOL]     addEventListener(eventSource, listenerType, listener); [EOL] }
public static <L> void bindEventsToMethod(final Object target, final String methodName, final Object eventSource, final Class<L> listenerType, final String... eventTypes) { [EOL]     final L listener = listenerType.cast(Proxy.newProxyInstance(target.getClass().getClassLoader(), new Class[] { listenerType }, new EventBindingInvocationHandler(target, methodName, eventTypes))); [EOL]     addEventListener(eventSource, listenerType, listener); [EOL] }
public static <L> void bindEventsToMethod(final Object target, final String methodName, final Object eventSource, final Class<L> listenerType, final String... eventTypes) { [EOL]     final L listener = listenerType.cast(Proxy.newProxyInstance(target.getClass().getClassLoader(), new Class[] { listenerType }, new EventBindingInvocationHandler(target, methodName, eventTypes))); [EOL]     addEventListener(eventSource, listenerType, listener); [EOL] }
public static <L> void bindEventsToMethod(final Object target, final String methodName, final Object eventSource, final Class<L> listenerType, final String... eventTypes) { [EOL]     final L listener = listenerType.cast(Proxy.newProxyInstance(target.getClass().getClassLoader(), new Class[] { listenerType }, new EventBindingInvocationHandler(target, methodName, eventTypes))); [EOL]     addEventListener(eventSource, listenerType, listener); [EOL] }
public static <L> void bindEventsToMethod(final Object target, final String methodName, final Object eventSource, final Class<L> listenerType, final String... eventTypes) { [EOL]     final L listener = listenerType.cast(Proxy.newProxyInstance(target.getClass().getClassLoader(), new Class[] { listenerType }, new EventBindingInvocationHandler(target, methodName, eventTypes))); [EOL]     addEventListener(eventSource, listenerType, listener); [EOL] }
EventBindingInvocationHandler(final Object target, final String methodName, final String[] eventTypes) { [EOL]     this.target = target; [EOL]     this.methodName = methodName; [EOL]     this.eventTypes = new HashSet<String>(Arrays.asList(eventTypes)); [EOL] }
EventBindingInvocationHandler(final Object target, final String methodName, final String[] eventTypes) { [EOL]     this.target = target; [EOL]     this.methodName = methodName; [EOL]     this.eventTypes = new HashSet<String>(Arrays.asList(eventTypes)); [EOL] }
EventBindingInvocationHandler(final Object target, final String methodName, final String[] eventTypes) { [EOL]     this.target = target; [EOL]     this.methodName = methodName; [EOL]     this.eventTypes = new HashSet<String>(Arrays.asList(eventTypes)); [EOL] }
EventBindingInvocationHandler(final Object target, final String methodName, final String[] eventTypes) { [EOL]     this.target = target; [EOL]     this.methodName = methodName; [EOL]     this.eventTypes = new HashSet<String>(Arrays.asList(eventTypes)); [EOL] }
EventBindingInvocationHandler(final Object target, final String methodName, final String[] eventTypes) { [EOL]     this.target = target; [EOL]     this.methodName = methodName; [EOL]     this.eventTypes = new HashSet<String>(Arrays.asList(eventTypes)); [EOL] }
@Override [EOL] public Object invoke(final Object proxy, final Method method, final Object[] parameters) throws Throwable { [EOL]     if (eventTypes.isEmpty() || eventTypes.contains(method.getName())) { [EOL]         if (hasMatchingParametersMethod(method)) { [EOL]             return MethodUtils.invokeMethod(target, methodName, parameters); [EOL]         } else { [EOL]             return MethodUtils.invokeMethod(target, methodName); [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
private boolean hasMatchingParametersMethod(final Method method) { [EOL]     return MethodUtils.getAccessibleMethod(target.getClass(), methodName, method.getParameterTypes()) != null; [EOL] }
private boolean hasMatchingParametersMethod(final Method method) { [EOL]     return MethodUtils.getAccessibleMethod(target.getClass(), methodName, method.getParameterTypes()) != null; [EOL] }
public ExtendedMessageFormat(final String pattern, final Map<String, ? extends FormatFactory> registry) { [EOL]     this(pattern, Locale.getDefault(), registry); [EOL] } public ExtendedMessageFormat(final String pattern); public ExtendedMessageFormat(final String pattern, final Locale locale); public ExtendedMessageFormat(final String pattern, final Map<String, ? extends FormatFactory> registry); public ExtendedMessageFormat(final String pattern, final Locale locale, final Map<String, ? extends FormatFactory> registry); public String toPattern(); public final void applyPattern(final String pattern); public void setFormat(final int formatElementIndex, final Format newFormat); public void setFormatByArgumentIndex(final int argumentIndex, final Format newFormat); public void setFormats(final Format[] newFormats); public void setFormatsByArgumentIndex(final Format[] newFormats); public boolean equals(final Object obj); public int hashCode(); private Format getFormat(final String desc); private int readArgumentIndex(final String pattern, final ParsePosition pos); private String parseFormatDescription(final String pattern, final ParsePosition pos); private String insertFormats(final String pattern, final ArrayList<String> customPatterns); private void seekNonWs(final String pattern, final ParsePosition pos); private ParsePosition next(final ParsePosition pos); private StringBuilder appendQuotedString(final String pattern, final ParsePosition pos, final StringBuilder appendTo, final boolean escapingOn); private void getQuotedString(final String pattern, final ParsePosition pos, final boolean escapingOn); private boolean containsElements(final Collection<?> coll); long serialVersionUID=Optional[-2362048321261811743L]; int HASH_SEED=Optional[31]; String DUMMY_PATTERN=Optional[""]; String ESCAPED_QUOTE=Optional["''"]; char START_FMT=Optional[',']; char END_FE=Optional['}
public ExtendedMessageFormat(final String pattern, final Map<String, ? extends FormatFactory> registry) { [EOL]     this(pattern, Locale.getDefault(), registry); [EOL] } public ExtendedMessageFormat(final String pattern); public ExtendedMessageFormat(final String pattern, final Locale locale); public ExtendedMessageFormat(final String pattern, final Map<String, ? extends FormatFactory> registry); public ExtendedMessageFormat(final String pattern, final Locale locale, final Map<String, ? extends FormatFactory> registry); public String toPattern(); public final void applyPattern(final String pattern); public void setFormat(final int formatElementIndex, final Format newFormat); public void setFormatByArgumentIndex(final int argumentIndex, final Format newFormat); public void setFormats(final Format[] newFormats); public void setFormatsByArgumentIndex(final Format[] newFormats); public boolean equals(final Object obj); public int hashCode(); private Format getFormat(final String desc); private int readArgumentIndex(final String pattern, final ParsePosition pos); private String parseFormatDescription(final String pattern, final ParsePosition pos); private String insertFormats(final String pattern, final ArrayList<String> customPatterns); private void seekNonWs(final String pattern, final ParsePosition pos); private ParsePosition next(final ParsePosition pos); private StringBuilder appendQuotedString(final String pattern, final ParsePosition pos, final StringBuilder appendTo, final boolean escapingOn); private void getQuotedString(final String pattern, final ParsePosition pos, final boolean escapingOn); private boolean containsElements(final Collection<?> coll); long serialVersionUID=Optional[-2362048321261811743L]; int HASH_SEED=Optional[31]; String DUMMY_PATTERN=Optional[""]; String ESCAPED_QUOTE=Optional["''"]; char START_FMT=Optional[',']; char END_FE=Optional['}
public ExtendedMessageFormat(final String pattern, final Map<String, ? extends FormatFactory> registry) { [EOL]     this(pattern, Locale.getDefault(), registry); [EOL] } public ExtendedMessageFormat(final String pattern); public ExtendedMessageFormat(final String pattern, final Locale locale); public ExtendedMessageFormat(final String pattern, final Map<String, ? extends FormatFactory> registry); public ExtendedMessageFormat(final String pattern, final Locale locale, final Map<String, ? extends FormatFactory> registry); public String toPattern(); public final void applyPattern(final String pattern); public void setFormat(final int formatElementIndex, final Format newFormat); public void setFormatByArgumentIndex(final int argumentIndex, final Format newFormat); public void setFormats(final Format[] newFormats); public void setFormatsByArgumentIndex(final Format[] newFormats); public boolean equals(final Object obj); public int hashCode(); private Format getFormat(final String desc); private int readArgumentIndex(final String pattern, final ParsePosition pos); private String parseFormatDescription(final String pattern, final ParsePosition pos); private String insertFormats(final String pattern, final ArrayList<String> customPatterns); private void seekNonWs(final String pattern, final ParsePosition pos); private ParsePosition next(final ParsePosition pos); private StringBuilder appendQuotedString(final String pattern, final ParsePosition pos, final StringBuilder appendTo, final boolean escapingOn); private void getQuotedString(final String pattern, final ParsePosition pos, final boolean escapingOn); private boolean containsElements(final Collection<?> coll); long serialVersionUID=Optional[-2362048321261811743L]; int HASH_SEED=Optional[31]; String DUMMY_PATTERN=Optional[""]; String ESCAPED_QUOTE=Optional["''"]; char START_FMT=Optional[',']; char END_FE=Optional['}
public ExtendedMessageFormat(final String pattern, final Map<String, ? extends FormatFactory> registry) { [EOL]     this(pattern, Locale.getDefault(), registry); [EOL] } public ExtendedMessageFormat(final String pattern); public ExtendedMessageFormat(final String pattern, final Locale locale); public ExtendedMessageFormat(final String pattern, final Map<String, ? extends FormatFactory> registry); public ExtendedMessageFormat(final String pattern, final Locale locale, final Map<String, ? extends FormatFactory> registry); public String toPattern(); public final void applyPattern(final String pattern); public void setFormat(final int formatElementIndex, final Format newFormat); public void setFormatByArgumentIndex(final int argumentIndex, final Format newFormat); public void setFormats(final Format[] newFormats); public void setFormatsByArgumentIndex(final Format[] newFormats); public boolean equals(final Object obj); public int hashCode(); private Format getFormat(final String desc); private int readArgumentIndex(final String pattern, final ParsePosition pos); private String parseFormatDescription(final String pattern, final ParsePosition pos); private String insertFormats(final String pattern, final ArrayList<String> customPatterns); private void seekNonWs(final String pattern, final ParsePosition pos); private ParsePosition next(final ParsePosition pos); private StringBuilder appendQuotedString(final String pattern, final ParsePosition pos, final StringBuilder appendTo, final boolean escapingOn); private void getQuotedString(final String pattern, final ParsePosition pos, final boolean escapingOn); private boolean containsElements(final Collection<?> coll); long serialVersionUID=Optional[-2362048321261811743L]; int HASH_SEED=Optional[31]; String DUMMY_PATTERN=Optional[""]; String ESCAPED_QUOTE=Optional["''"]; char START_FMT=Optional[',']; char END_FE=Optional['}
public ExtendedMessageFormat(final String pattern, final Map<String, ? extends FormatFactory> registry) { [EOL]     this(pattern, Locale.getDefault(), registry); [EOL] } public ExtendedMessageFormat(final String pattern); public ExtendedMessageFormat(final String pattern, final Locale locale); public ExtendedMessageFormat(final String pattern, final Map<String, ? extends FormatFactory> registry); public ExtendedMessageFormat(final String pattern, final Locale locale, final Map<String, ? extends FormatFactory> registry); public String toPattern(); public final void applyPattern(final String pattern); public void setFormat(final int formatElementIndex, final Format newFormat); public void setFormatByArgumentIndex(final int argumentIndex, final Format newFormat); public void setFormats(final Format[] newFormats); public void setFormatsByArgumentIndex(final Format[] newFormats); public boolean equals(final Object obj); public int hashCode(); private Format getFormat(final String desc); private int readArgumentIndex(final String pattern, final ParsePosition pos); private String parseFormatDescription(final String pattern, final ParsePosition pos); private String insertFormats(final String pattern, final ArrayList<String> customPatterns); private void seekNonWs(final String pattern, final ParsePosition pos); private ParsePosition next(final ParsePosition pos); private StringBuilder appendQuotedString(final String pattern, final ParsePosition pos, final StringBuilder appendTo, final boolean escapingOn); private void getQuotedString(final String pattern, final ParsePosition pos, final boolean escapingOn); private boolean containsElements(final Collection<?> coll); long serialVersionUID=Optional[-2362048321261811743L]; int HASH_SEED=Optional[31]; String DUMMY_PATTERN=Optional[""]; String ESCAPED_QUOTE=Optional["''"]; char START_FMT=Optional[',']; char END_FE=Optional['}
public ExtendedMessageFormat(final String pattern, final Map<String, ? extends FormatFactory> registry) { [EOL]     this(pattern, Locale.getDefault(), registry); [EOL] } public ExtendedMessageFormat(final String pattern); public ExtendedMessageFormat(final String pattern, final Locale locale); public ExtendedMessageFormat(final String pattern, final Map<String, ? extends FormatFactory> registry); public ExtendedMessageFormat(final String pattern, final Locale locale, final Map<String, ? extends FormatFactory> registry); public String toPattern(); public final void applyPattern(final String pattern); public void setFormat(final int formatElementIndex, final Format newFormat); public void setFormatByArgumentIndex(final int argumentIndex, final Format newFormat); public void setFormats(final Format[] newFormats); public void setFormatsByArgumentIndex(final Format[] newFormats); public boolean equals(final Object obj); public int hashCode(); private Format getFormat(final String desc); private int readArgumentIndex(final String pattern, final ParsePosition pos); private String parseFormatDescription(final String pattern, final ParsePosition pos); private String insertFormats(final String pattern, final ArrayList<String> customPatterns); private void seekNonWs(final String pattern, final ParsePosition pos); private ParsePosition next(final ParsePosition pos); private StringBuilder appendQuotedString(final String pattern, final ParsePosition pos, final StringBuilder appendTo, final boolean escapingOn); private void getQuotedString(final String pattern, final ParsePosition pos, final boolean escapingOn); private boolean containsElements(final Collection<?> coll); long serialVersionUID=Optional[-2362048321261811743L]; int HASH_SEED=Optional[31]; String DUMMY_PATTERN=Optional[""]; String ESCAPED_QUOTE=Optional["''"]; char START_FMT=Optional[',']; char END_FE=Optional['}
public ExtendedMessageFormat(final String pattern, final Map<String, ? extends FormatFactory> registry) { [EOL]     this(pattern, Locale.getDefault(), registry); [EOL] } public ExtendedMessageFormat(final String pattern); public ExtendedMessageFormat(final String pattern, final Locale locale); public ExtendedMessageFormat(final String pattern, final Map<String, ? extends FormatFactory> registry); public ExtendedMessageFormat(final String pattern, final Locale locale, final Map<String, ? extends FormatFactory> registry); public String toPattern(); public final void applyPattern(final String pattern); public void setFormat(final int formatElementIndex, final Format newFormat); public void setFormatByArgumentIndex(final int argumentIndex, final Format newFormat); public void setFormats(final Format[] newFormats); public void setFormatsByArgumentIndex(final Format[] newFormats); public boolean equals(final Object obj); public int hashCode(); private Format getFormat(final String desc); private int readArgumentIndex(final String pattern, final ParsePosition pos); private String parseFormatDescription(final String pattern, final ParsePosition pos); private String insertFormats(final String pattern, final ArrayList<String> customPatterns); private void seekNonWs(final String pattern, final ParsePosition pos); private ParsePosition next(final ParsePosition pos); private StringBuilder appendQuotedString(final String pattern, final ParsePosition pos, final StringBuilder appendTo, final boolean escapingOn); private void getQuotedString(final String pattern, final ParsePosition pos, final boolean escapingOn); private boolean containsElements(final Collection<?> coll); long serialVersionUID=Optional[-2362048321261811743L]; int HASH_SEED=Optional[31]; String DUMMY_PATTERN=Optional[""]; String ESCAPED_QUOTE=Optional["''"]; char START_FMT=Optional[',']; char END_FE=Optional['}
public ExtendedMessageFormat(final String pattern, final Map<String, ? extends FormatFactory> registry) { [EOL]     this(pattern, Locale.getDefault(), registry); [EOL] } public ExtendedMessageFormat(final String pattern); public ExtendedMessageFormat(final String pattern, final Locale locale); public ExtendedMessageFormat(final String pattern, final Map<String, ? extends FormatFactory> registry); public ExtendedMessageFormat(final String pattern, final Locale locale, final Map<String, ? extends FormatFactory> registry); public String toPattern(); public final void applyPattern(final String pattern); public void setFormat(final int formatElementIndex, final Format newFormat); public void setFormatByArgumentIndex(final int argumentIndex, final Format newFormat); public void setFormats(final Format[] newFormats); public void setFormatsByArgumentIndex(final Format[] newFormats); public boolean equals(final Object obj); public int hashCode(); private Format getFormat(final String desc); private int readArgumentIndex(final String pattern, final ParsePosition pos); private String parseFormatDescription(final String pattern, final ParsePosition pos); private String insertFormats(final String pattern, final ArrayList<String> customPatterns); private void seekNonWs(final String pattern, final ParsePosition pos); private ParsePosition next(final ParsePosition pos); private StringBuilder appendQuotedString(final String pattern, final ParsePosition pos, final StringBuilder appendTo, final boolean escapingOn); private void getQuotedString(final String pattern, final ParsePosition pos, final boolean escapingOn); private boolean containsElements(final Collection<?> coll); long serialVersionUID=Optional[-2362048321261811743L]; int HASH_SEED=Optional[31]; String DUMMY_PATTERN=Optional[""]; String ESCAPED_QUOTE=Optional["''"]; char START_FMT=Optional[',']; char END_FE=Optional['}
public ExtendedMessageFormat(final String pattern, final Map<String, ? extends FormatFactory> registry) { [EOL]     this(pattern, Locale.getDefault(), registry); [EOL] } public ExtendedMessageFormat(final String pattern); public ExtendedMessageFormat(final String pattern, final Locale locale); public ExtendedMessageFormat(final String pattern, final Map<String, ? extends FormatFactory> registry); public ExtendedMessageFormat(final String pattern, final Locale locale, final Map<String, ? extends FormatFactory> registry); public String toPattern(); public final void applyPattern(final String pattern); public void setFormat(final int formatElementIndex, final Format newFormat); public void setFormatByArgumentIndex(final int argumentIndex, final Format newFormat); public void setFormats(final Format[] newFormats); public void setFormatsByArgumentIndex(final Format[] newFormats); public boolean equals(final Object obj); public int hashCode(); private Format getFormat(final String desc); private int readArgumentIndex(final String pattern, final ParsePosition pos); private String parseFormatDescription(final String pattern, final ParsePosition pos); private String insertFormats(final String pattern, final ArrayList<String> customPatterns); private void seekNonWs(final String pattern, final ParsePosition pos); private ParsePosition next(final ParsePosition pos); private StringBuilder appendQuotedString(final String pattern, final ParsePosition pos, final StringBuilder appendTo, final boolean escapingOn); private void getQuotedString(final String pattern, final ParsePosition pos, final boolean escapingOn); private boolean containsElements(final Collection<?> coll); long serialVersionUID=Optional[-2362048321261811743L]; int HASH_SEED=Optional[31]; String DUMMY_PATTERN=Optional[""]; String ESCAPED_QUOTE=Optional["''"]; char START_FMT=Optional[',']; char END_FE=Optional['}
public ExtendedMessageFormat(final String pattern, final Map<String, ? extends FormatFactory> registry) { [EOL]     this(pattern, Locale.getDefault(), registry); [EOL] } public ExtendedMessageFormat(final String pattern); public ExtendedMessageFormat(final String pattern, final Locale locale); public ExtendedMessageFormat(final String pattern, final Map<String, ? extends FormatFactory> registry); public ExtendedMessageFormat(final String pattern, final Locale locale, final Map<String, ? extends FormatFactory> registry); public String toPattern(); public final void applyPattern(final String pattern); public void setFormat(final int formatElementIndex, final Format newFormat); public void setFormatByArgumentIndex(final int argumentIndex, final Format newFormat); public void setFormats(final Format[] newFormats); public void setFormatsByArgumentIndex(final Format[] newFormats); public boolean equals(final Object obj); public int hashCode(); private Format getFormat(final String desc); private int readArgumentIndex(final String pattern, final ParsePosition pos); private String parseFormatDescription(final String pattern, final ParsePosition pos); private String insertFormats(final String pattern, final ArrayList<String> customPatterns); private void seekNonWs(final String pattern, final ParsePosition pos); private ParsePosition next(final ParsePosition pos); private StringBuilder appendQuotedString(final String pattern, final ParsePosition pos, final StringBuilder appendTo, final boolean escapingOn); private void getQuotedString(final String pattern, final ParsePosition pos, final boolean escapingOn); private boolean containsElements(final Collection<?> coll); long serialVersionUID=Optional[-2362048321261811743L]; int HASH_SEED=Optional[31]; String DUMMY_PATTERN=Optional[""]; String ESCAPED_QUOTE=Optional["''"]; char START_FMT=Optional[',']; char END_FE=Optional['}
public ExtendedMessageFormat(final String pattern, final Map<String, ? extends FormatFactory> registry) { [EOL]     this(pattern, Locale.getDefault(), registry); [EOL] } public ExtendedMessageFormat(final String pattern); public ExtendedMessageFormat(final String pattern, final Locale locale); public ExtendedMessageFormat(final String pattern, final Map<String, ? extends FormatFactory> registry); public ExtendedMessageFormat(final String pattern, final Locale locale, final Map<String, ? extends FormatFactory> registry); public String toPattern(); public final void applyPattern(final String pattern); public void setFormat(final int formatElementIndex, final Format newFormat); public void setFormatByArgumentIndex(final int argumentIndex, final Format newFormat); public void setFormats(final Format[] newFormats); public void setFormatsByArgumentIndex(final Format[] newFormats); public boolean equals(final Object obj); public int hashCode(); private Format getFormat(final String desc); private int readArgumentIndex(final String pattern, final ParsePosition pos); private String parseFormatDescription(final String pattern, final ParsePosition pos); private String insertFormats(final String pattern, final ArrayList<String> customPatterns); private void seekNonWs(final String pattern, final ParsePosition pos); private ParsePosition next(final ParsePosition pos); private StringBuilder appendQuotedString(final String pattern, final ParsePosition pos, final StringBuilder appendTo, final boolean escapingOn); private void getQuotedString(final String pattern, final ParsePosition pos, final boolean escapingOn); private boolean containsElements(final Collection<?> coll); long serialVersionUID=Optional[-2362048321261811743L]; int HASH_SEED=Optional[31]; String DUMMY_PATTERN=Optional[""]; String ESCAPED_QUOTE=Optional["''"]; char START_FMT=Optional[',']; char END_FE=Optional['}
public long getThreadCount() { [EOL]     return threadCounter.get(); [EOL] }
public long getThreadCount() { [EOL]     return threadCounter.get(); [EOL] }
private void initializeThread(final Thread t) { [EOL]     if (getNamingPattern() != null) { [EOL]         final Long count = Long.valueOf(threadCounter.incrementAndGet()); [EOL]         t.setName(String.format(getNamingPattern(), count)); [EOL]     } [EOL]     if (getUncaughtExceptionHandler() != null) { [EOL]         t.setUncaughtExceptionHandler(getUncaughtExceptionHandler()); [EOL]     } [EOL]     if (getPriority() != null) { [EOL]         t.setPriority(getPriority().intValue()); [EOL]     } [EOL]     if (getDaemonFlag() != null) { [EOL]         t.setDaemon(getDaemonFlag().booleanValue()); [EOL]     } [EOL] }
private void initializeThread(final Thread t) { [EOL]     if (getNamingPattern() != null) { [EOL]         final Long count = Long.valueOf(threadCounter.incrementAndGet()); [EOL]         t.setName(String.format(getNamingPattern(), count)); [EOL]     } [EOL]     if (getUncaughtExceptionHandler() != null) { [EOL]         t.setUncaughtExceptionHandler(getUncaughtExceptionHandler()); [EOL]     } [EOL]     if (getPriority() != null) { [EOL]         t.setPriority(getPriority().intValue()); [EOL]     } [EOL]     if (getDaemonFlag() != null) { [EOL]         t.setDaemon(getDaemonFlag().booleanValue()); [EOL]     } [EOL] }
private void initializeThread(final Thread t) { [EOL]     if (getNamingPattern() != null) { [EOL]         final Long count = Long.valueOf(threadCounter.incrementAndGet()); [EOL]         t.setName(String.format(getNamingPattern(), count)); [EOL]     } [EOL]     if (getUncaughtExceptionHandler() != null) { [EOL]         t.setUncaughtExceptionHandler(getUncaughtExceptionHandler()); [EOL]     } [EOL]     if (getPriority() != null) { [EOL]         t.setPriority(getPriority().intValue()); [EOL]     } [EOL]     if (getDaemonFlag() != null) { [EOL]         t.setDaemon(getDaemonFlag().booleanValue()); [EOL]     } [EOL] }
private void initializeThread(final Thread t) { [EOL]     if (getNamingPattern() != null) { [EOL]         final Long count = Long.valueOf(threadCounter.incrementAndGet()); [EOL]         t.setName(String.format(getNamingPattern(), count)); [EOL]     } [EOL]     if (getUncaughtExceptionHandler() != null) { [EOL]         t.setUncaughtExceptionHandler(getUncaughtExceptionHandler()); [EOL]     } [EOL]     if (getPriority() != null) { [EOL]         t.setPriority(getPriority().intValue()); [EOL]     } [EOL]     if (getDaemonFlag() != null) { [EOL]         t.setDaemon(getDaemonFlag().booleanValue()); [EOL]     } [EOL] }
private void initializeThread(final Thread t) { [EOL]     if (getNamingPattern() != null) { [EOL]         final Long count = Long.valueOf(threadCounter.incrementAndGet()); [EOL]         t.setName(String.format(getNamingPattern(), count)); [EOL]     } [EOL]     if (getUncaughtExceptionHandler() != null) { [EOL]         t.setUncaughtExceptionHandler(getUncaughtExceptionHandler()); [EOL]     } [EOL]     if (getPriority() != null) { [EOL]         t.setPriority(getPriority().intValue()); [EOL]     } [EOL]     if (getDaemonFlag() != null) { [EOL]         t.setDaemon(getDaemonFlag().booleanValue()); [EOL]     } [EOL] }
public Builder namingPattern(final String pattern) { [EOL]     if (pattern == null) { [EOL]         throw new NullPointerException("Naming pattern must not be null!"); [EOL]     } [EOL]     namingPattern = pattern; [EOL]     return this; [EOL] }
public TimedSemaphore(final ScheduledExecutorService service, final long timePeriod, final TimeUnit timeUnit, final int limit) { [EOL]     if (timePeriod <= 0) { [EOL]         throw new IllegalArgumentException("Time period must be greater 0!"); [EOL]     } [EOL]     period = timePeriod; [EOL]     unit = timeUnit; [EOL]     if (service != null) { [EOL]         executorService = service; [EOL]         ownExecutor = false; [EOL]     } else { [EOL]         final ScheduledThreadPoolExecutor s = new ScheduledThreadPoolExecutor(THREAD_POOL_SIZE); [EOL]         s.setContinueExistingPeriodicTasksAfterShutdownPolicy(false); [EOL]         s.setExecuteExistingDelayedTasksAfterShutdownPolicy(false); [EOL]         executorService = s; [EOL]         ownExecutor = true; [EOL]     } [EOL]     setLimit(limit); [EOL] }
public TimedSemaphore(final ScheduledExecutorService service, final long timePeriod, final TimeUnit timeUnit, final int limit) { [EOL]     if (timePeriod <= 0) { [EOL]         throw new IllegalArgumentException("Time period must be greater 0!"); [EOL]     } [EOL]     period = timePeriod; [EOL]     unit = timeUnit; [EOL]     if (service != null) { [EOL]         executorService = service; [EOL]         ownExecutor = false; [EOL]     } else { [EOL]         final ScheduledThreadPoolExecutor s = new ScheduledThreadPoolExecutor(THREAD_POOL_SIZE); [EOL]         s.setContinueExistingPeriodicTasksAfterShutdownPolicy(false); [EOL]         s.setExecuteExistingDelayedTasksAfterShutdownPolicy(false); [EOL]         executorService = s; [EOL]         ownExecutor = true; [EOL]     } [EOL]     setLimit(limit); [EOL] }
public TimedSemaphore(final ScheduledExecutorService service, final long timePeriod, final TimeUnit timeUnit, final int limit) { [EOL]     if (timePeriod <= 0) { [EOL]         throw new IllegalArgumentException("Time period must be greater 0!"); [EOL]     } [EOL]     period = timePeriod; [EOL]     unit = timeUnit; [EOL]     if (service != null) { [EOL]         executorService = service; [EOL]         ownExecutor = false; [EOL]     } else { [EOL]         final ScheduledThreadPoolExecutor s = new ScheduledThreadPoolExecutor(THREAD_POOL_SIZE); [EOL]         s.setContinueExistingPeriodicTasksAfterShutdownPolicy(false); [EOL]         s.setExecuteExistingDelayedTasksAfterShutdownPolicy(false); [EOL]         executorService = s; [EOL]         ownExecutor = true; [EOL]     } [EOL]     setLimit(limit); [EOL] }
public final synchronized int getLimit() { [EOL]     return limit; [EOL] }
public final synchronized void setLimit(final int limit) { [EOL]     this.limit = limit; [EOL] }
public final synchronized void setLimit(final int limit) { [EOL]     this.limit = limit; [EOL] }
public final synchronized void setLimit(final int limit) { [EOL]     this.limit = limit; [EOL] }
public synchronized boolean isShutdown() { [EOL]     return shutdown; [EOL] }
public synchronized boolean isShutdown() { [EOL]     return shutdown; [EOL] }
public synchronized void acquire() throws InterruptedException { [EOL]     if (isShutdown()) { [EOL]         throw new IllegalStateException("TimedSemaphore is shut down!"); [EOL]     } [EOL]     if (task == null) { [EOL]         task = startTimer(); [EOL]     } [EOL]     boolean canPass = false; [EOL]     do { [EOL]         canPass = getLimit() <= NO_LIMIT || acquireCount < getLimit(); [EOL]         if (!canPass) { [EOL]             wait(); [EOL]         } else { [EOL]             acquireCount++; [EOL]         } [EOL]     } while (!canPass); [EOL] }
public synchronized void acquire() throws InterruptedException { [EOL]     if (isShutdown()) { [EOL]         throw new IllegalStateException("TimedSemaphore is shut down!"); [EOL]     } [EOL]     if (task == null) { [EOL]         task = startTimer(); [EOL]     } [EOL]     boolean canPass = false; [EOL]     do { [EOL]         canPass = getLimit() <= NO_LIMIT || acquireCount < getLimit(); [EOL]         if (!canPass) { [EOL]             wait(); [EOL]         } else { [EOL]             acquireCount++; [EOL]         } [EOL]     } while (!canPass); [EOL] }
public synchronized void acquire() throws InterruptedException { [EOL]     if (isShutdown()) { [EOL]         throw new IllegalStateException("TimedSemaphore is shut down!"); [EOL]     } [EOL]     if (task == null) { [EOL]         task = startTimer(); [EOL]     } [EOL]     boolean canPass = false; [EOL]     do { [EOL]         canPass = getLimit() <= NO_LIMIT || acquireCount < getLimit(); [EOL]         if (!canPass) { [EOL]             wait(); [EOL]         } else { [EOL]             acquireCount++; [EOL]         } [EOL]     } while (!canPass); [EOL] }
public synchronized void acquire() throws InterruptedException { [EOL]     if (isShutdown()) { [EOL]         throw new IllegalStateException("TimedSemaphore is shut down!"); [EOL]     } [EOL]     if (task == null) { [EOL]         task = startTimer(); [EOL]     } [EOL]     boolean canPass = false; [EOL]     do { [EOL]         canPass = getLimit() <= NO_LIMIT || acquireCount < getLimit(); [EOL]         if (!canPass) { [EOL]             wait(); [EOL]         } else { [EOL]             acquireCount++; [EOL]         } [EOL]     } while (!canPass); [EOL] }
public synchronized void acquire() throws InterruptedException { [EOL]     if (isShutdown()) { [EOL]         throw new IllegalStateException("TimedSemaphore is shut down!"); [EOL]     } [EOL]     if (task == null) { [EOL]         task = startTimer(); [EOL]     } [EOL]     boolean canPass = false; [EOL]     do { [EOL]         canPass = getLimit() <= NO_LIMIT || acquireCount < getLimit(); [EOL]         if (!canPass) { [EOL]             wait(); [EOL]         } else { [EOL]             acquireCount++; [EOL]         } [EOL]     } while (!canPass); [EOL] }
public synchronized int getLastAcquiresPerPeriod() { [EOL]     return lastCallsPerPeriod; [EOL] }
public synchronized double getAverageCallsPerPeriod() { [EOL]     return periodCount == 0 ? 0 : (double) totalAcquireCount / (double) periodCount; [EOL] }
public synchronized double getAverageCallsPerPeriod() { [EOL]     return periodCount == 0 ? 0 : (double) totalAcquireCount / (double) periodCount; [EOL] }
public long getPeriod() { [EOL]     return period; [EOL] }
public TimeUnit getUnit() { [EOL]     return unit; [EOL] }
protected ScheduledExecutorService getExecutorService() { [EOL]     return executorService; [EOL] }
public ContextedRuntimeException(final String message, final Throwable cause) { [EOL]     super(message, cause); [EOL]     exceptionContext = new DefaultExceptionContext(); [EOL] }
public ContextedRuntimeException(final String message, final Throwable cause, ExceptionContext context) { [EOL]     super(message, cause); [EOL]     if (context == null) { [EOL]         context = new DefaultExceptionContext(); [EOL]     } [EOL]     exceptionContext = context; [EOL] }
@Override [EOL] public String getMessage() { [EOL]     return getFormattedExceptionMessage(super.getMessage()); [EOL] }
@Override [EOL] public String getMessage() { [EOL]     return getFormattedExceptionMessage(super.getMessage()); [EOL] }
@Override [EOL] public String getFormattedExceptionMessage(final String baseMessage) { [EOL]     return exceptionContext.getFormattedExceptionMessage(baseMessage); [EOL] }
@Override [EOL] public String getFormattedExceptionMessage(final String baseMessage) { [EOL]     return exceptionContext.getFormattedExceptionMessage(baseMessage); [EOL] }
@Override [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL]     if (input.charAt(index) == '\\' && index + 1 < input.length() && input.charAt(index + 1) == 'u') { [EOL]         int i = 2; [EOL]         while (index + i < input.length() && input.charAt(index + i) == 'u') { [EOL]             i++; [EOL]         } [EOL]         if (index + i < input.length() && input.charAt(index + i) == '+') { [EOL]             i++; [EOL]         } [EOL]         if (index + i + 4 <= input.length()) { [EOL]             final CharSequence unicode = input.subSequence(index + i, index + i + 4); [EOL]             try { [EOL]                 final int value = Integer.parseInt(unicode.toString(), 16); [EOL]                 out.write((char) value); [EOL]             } catch (final NumberFormatException nfe) { [EOL]                 throw new IllegalArgumentException("Unable to parse unicode value: " + unicode, nfe); [EOL]             } [EOL]             return i + 4; [EOL]         } else { [EOL]             throw new IllegalArgumentException("Less than 4 hex digits in unicode value: '" + input.subSequence(index, input.length()) + "' due to end of CharSequence"); [EOL]         } [EOL]     } [EOL]     return 0; [EOL] }
@Override [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL]     if (input.charAt(index) == '\\' && index + 1 < input.length() && input.charAt(index + 1) == 'u') { [EOL]         int i = 2; [EOL]         while (index + i < input.length() && input.charAt(index + i) == 'u') { [EOL]             i++; [EOL]         } [EOL]         if (index + i < input.length() && input.charAt(index + i) == '+') { [EOL]             i++; [EOL]         } [EOL]         if (index + i + 4 <= input.length()) { [EOL]             final CharSequence unicode = input.subSequence(index + i, index + i + 4); [EOL]             try { [EOL]                 final int value = Integer.parseInt(unicode.toString(), 16); [EOL]                 out.write((char) value); [EOL]             } catch (final NumberFormatException nfe) { [EOL]                 throw new IllegalArgumentException("Unable to parse unicode value: " + unicode, nfe); [EOL]             } [EOL]             return i + 4; [EOL]         } else { [EOL]             throw new IllegalArgumentException("Less than 4 hex digits in unicode value: '" + input.subSequence(index, input.length()) + "' due to end of CharSequence"); [EOL]         } [EOL]     } [EOL]     return 0; [EOL] }
@Override [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL]     if (input.charAt(index) == '\\' && index + 1 < input.length() && input.charAt(index + 1) == 'u') { [EOL]         int i = 2; [EOL]         while (index + i < input.length() && input.charAt(index + i) == 'u') { [EOL]             i++; [EOL]         } [EOL]         if (index + i < input.length() && input.charAt(index + i) == '+') { [EOL]             i++; [EOL]         } [EOL]         if (index + i + 4 <= input.length()) { [EOL]             final CharSequence unicode = input.subSequence(index + i, index + i + 4); [EOL]             try { [EOL]                 final int value = Integer.parseInt(unicode.toString(), 16); [EOL]                 out.write((char) value); [EOL]             } catch (final NumberFormatException nfe) { [EOL]                 throw new IllegalArgumentException("Unable to parse unicode value: " + unicode, nfe); [EOL]             } [EOL]             return i + 4; [EOL]         } else { [EOL]             throw new IllegalArgumentException("Less than 4 hex digits in unicode value: '" + input.subSequence(index, input.length()) + "' due to end of CharSequence"); [EOL]         } [EOL]     } [EOL]     return 0; [EOL] }
@Override [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL]     if (input.charAt(index) == '\\' && index + 1 < input.length() && input.charAt(index + 1) == 'u') { [EOL]         int i = 2; [EOL]         while (index + i < input.length() && input.charAt(index + i) == 'u') { [EOL]             i++; [EOL]         } [EOL]         if (index + i < input.length() && input.charAt(index + i) == '+') { [EOL]             i++; [EOL]         } [EOL]         if (index + i + 4 <= input.length()) { [EOL]             final CharSequence unicode = input.subSequence(index + i, index + i + 4); [EOL]             try { [EOL]                 final int value = Integer.parseInt(unicode.toString(), 16); [EOL]                 out.write((char) value); [EOL]             } catch (final NumberFormatException nfe) { [EOL]                 throw new IllegalArgumentException("Unable to parse unicode value: " + unicode, nfe); [EOL]             } [EOL]             return i + 4; [EOL]         } else { [EOL]             throw new IllegalArgumentException("Less than 4 hex digits in unicode value: '" + input.subSequence(index, input.length()) + "' due to end of CharSequence"); [EOL]         } [EOL]     } [EOL]     return 0; [EOL] }
@Override [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL]     if (input.charAt(index) == '\\' && index + 1 < input.length() && input.charAt(index + 1) == 'u') { [EOL]         int i = 2; [EOL]         while (index + i < input.length() && input.charAt(index + i) == 'u') { [EOL]             i++; [EOL]         } [EOL]         if (index + i < input.length() && input.charAt(index + i) == '+') { [EOL]             i++; [EOL]         } [EOL]         if (index + i + 4 <= input.length()) { [EOL]             final CharSequence unicode = input.subSequence(index + i, index + i + 4); [EOL]             try { [EOL]                 final int value = Integer.parseInt(unicode.toString(), 16); [EOL]                 out.write((char) value); [EOL]             } catch (final NumberFormatException nfe) { [EOL]                 throw new IllegalArgumentException("Unable to parse unicode value: " + unicode, nfe); [EOL]             } [EOL]             return i + 4; [EOL]         } else { [EOL]             throw new IllegalArgumentException("Less than 4 hex digits in unicode value: '" + input.subSequence(index, input.length()) + "' due to end of CharSequence"); [EOL]         } [EOL]     } [EOL]     return 0; [EOL] }
@Override [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL]     if (input.charAt(index) == '\\' && index + 1 < input.length() && input.charAt(index + 1) == 'u') { [EOL]         int i = 2; [EOL]         while (index + i < input.length() && input.charAt(index + i) == 'u') { [EOL]             i++; [EOL]         } [EOL]         if (index + i < input.length() && input.charAt(index + i) == '+') { [EOL]             i++; [EOL]         } [EOL]         if (index + i + 4 <= input.length()) { [EOL]             final CharSequence unicode = input.subSequence(index + i, index + i + 4); [EOL]             try { [EOL]                 final int value = Integer.parseInt(unicode.toString(), 16); [EOL]                 out.write((char) value); [EOL]             } catch (final NumberFormatException nfe) { [EOL]                 throw new IllegalArgumentException("Unable to parse unicode value: " + unicode, nfe); [EOL]             } [EOL]             return i + 4; [EOL]         } else { [EOL]             throw new IllegalArgumentException("Less than 4 hex digits in unicode value: '" + input.subSequence(index, input.length()) + "' due to end of CharSequence"); [EOL]         } [EOL]     } [EOL]     return 0; [EOL] }
@Override [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL]     if (input.charAt(index) == '\\' && index + 1 < input.length() && input.charAt(index + 1) == 'u') { [EOL]         int i = 2; [EOL]         while (index + i < input.length() && input.charAt(index + i) == 'u') { [EOL]             i++; [EOL]         } [EOL]         if (index + i < input.length() && input.charAt(index + i) == '+') { [EOL]             i++; [EOL]         } [EOL]         if (index + i + 4 <= input.length()) { [EOL]             final CharSequence unicode = input.subSequence(index + i, index + i + 4); [EOL]             try { [EOL]                 final int value = Integer.parseInt(unicode.toString(), 16); [EOL]                 out.write((char) value); [EOL]             } catch (final NumberFormatException nfe) { [EOL]                 throw new IllegalArgumentException("Unable to parse unicode value: " + unicode, nfe); [EOL]             } [EOL]             return i + 4; [EOL]         } else { [EOL]             throw new IllegalArgumentException("Less than 4 hex digits in unicode value: '" + input.subSequence(index, input.length()) + "' due to end of CharSequence"); [EOL]         } [EOL]     } [EOL]     return 0; [EOL] }
@Override [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL]     if (input.charAt(index) == '\\' && index + 1 < input.length() && input.charAt(index + 1) == 'u') { [EOL]         int i = 2; [EOL]         while (index + i < input.length() && input.charAt(index + i) == 'u') { [EOL]             i++; [EOL]         } [EOL]         if (index + i < input.length() && input.charAt(index + i) == '+') { [EOL]             i++; [EOL]         } [EOL]         if (index + i + 4 <= input.length()) { [EOL]             final CharSequence unicode = input.subSequence(index + i, index + i + 4); [EOL]             try { [EOL]                 final int value = Integer.parseInt(unicode.toString(), 16); [EOL]                 out.write((char) value); [EOL]             } catch (final NumberFormatException nfe) { [EOL]                 throw new IllegalArgumentException("Unable to parse unicode value: " + unicode, nfe); [EOL]             } [EOL]             return i + 4; [EOL]         } else { [EOL]             throw new IllegalArgumentException("Less than 4 hex digits in unicode value: '" + input.subSequence(index, input.length()) + "' due to end of CharSequence"); [EOL]         } [EOL]     } [EOL]     return 0; [EOL] }
public void add(final Number operand) { [EOL]     this.value += operand.floatValue(); [EOL] }
public void add(final Number operand) { [EOL]     this.value += operand.floatValue(); [EOL] }
public void add(final Number operand) { [EOL]     this.value += operand.floatValue(); [EOL] }
public void add(final Number operand) { [EOL]     this.value += operand.floatValue(); [EOL] }
@Override [EOL] public int compareTo(final MutableFloat other) { [EOL]     final float anotherVal = other.value; [EOL]     return Float.compare(value, anotherVal); [EOL] }
@Override [EOL] public int compareTo(final MutableFloat other) { [EOL]     final float anotherVal = other.value; [EOL]     return Float.compare(value, anotherVal); [EOL] }
@Override [EOL] public int compareTo(final MutableFloat other) { [EOL]     final float anotherVal = other.value; [EOL]     return Float.compare(value, anotherVal); [EOL] }
@Override [EOL] public String toString() { [EOL]     return String.valueOf(value); [EOL] }
@Override [EOL] public String toString() { [EOL]     return String.valueOf(value); [EOL] }
public ClassUtils() { [EOL]     super(); [EOL] }
public static String getShortClassName(final Class<?> cls) { [EOL]     if (cls == null) { [EOL]         return StringUtils.EMPTY; [EOL]     } [EOL]     return getShortClassName(cls.getName()); [EOL] }
public static String getShortClassName(final Class<?> cls) { [EOL]     if (cls == null) { [EOL]         return StringUtils.EMPTY; [EOL]     } [EOL]     return getShortClassName(cls.getName()); [EOL] }
public static String getShortClassName(String className) { [EOL]     if (StringUtils.isEmpty(className)) { [EOL]         return StringUtils.EMPTY; [EOL]     } [EOL]     final StringBuilder arrayPrefix = new StringBuilder(); [EOL]     if (className.startsWith("[")) { [EOL]         while (className.charAt(0) == '[') { [EOL]             className = className.substring(1); [EOL]             arrayPrefix.append("[]"); [EOL]         } [EOL]         if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') { [EOL]             className = className.substring(1, className.length() - 1); [EOL]         } [EOL]         if (reverseAbbreviationMap.containsKey(className)) { [EOL]             className = reverseAbbreviationMap.get(className); [EOL]         } [EOL]     } [EOL]     final int lastDotIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); [EOL]     final int innerIdx = className.indexOf(INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1 ? 0 : lastDotIdx + 1); [EOL]     String out = className.substring(lastDotIdx + 1); [EOL]     if (innerIdx != -1) { [EOL]         out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); [EOL]     } [EOL]     return out + arrayPrefix; [EOL] }
public static String getShortClassName(String className) { [EOL]     if (StringUtils.isEmpty(className)) { [EOL]         return StringUtils.EMPTY; [EOL]     } [EOL]     final StringBuilder arrayPrefix = new StringBuilder(); [EOL]     if (className.startsWith("[")) { [EOL]         while (className.charAt(0) == '[') { [EOL]             className = className.substring(1); [EOL]             arrayPrefix.append("[]"); [EOL]         } [EOL]         if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') { [EOL]             className = className.substring(1, className.length() - 1); [EOL]         } [EOL]         if (reverseAbbreviationMap.containsKey(className)) { [EOL]             className = reverseAbbreviationMap.get(className); [EOL]         } [EOL]     } [EOL]     final int lastDotIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); [EOL]     final int innerIdx = className.indexOf(INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1 ? 0 : lastDotIdx + 1); [EOL]     String out = className.substring(lastDotIdx + 1); [EOL]     if (innerIdx != -1) { [EOL]         out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); [EOL]     } [EOL]     return out + arrayPrefix; [EOL] }
public static String getPackageName(String className) { [EOL]     if (StringUtils.isEmpty(className)) { [EOL]         return StringUtils.EMPTY; [EOL]     } [EOL]     while (className.charAt(0) == '[') { [EOL]         className = className.substring(1); [EOL]     } [EOL]     if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') { [EOL]         className = className.substring(1); [EOL]     } [EOL]     final int i = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); [EOL]     if (i == -1) { [EOL]         return StringUtils.EMPTY; [EOL]     } [EOL]     return className.substring(0, i); [EOL] }
public static String getPackageName(String className) { [EOL]     if (StringUtils.isEmpty(className)) { [EOL]         return StringUtils.EMPTY; [EOL]     } [EOL]     while (className.charAt(0) == '[') { [EOL]         className = className.substring(1); [EOL]     } [EOL]     if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') { [EOL]         className = className.substring(1); [EOL]     } [EOL]     final int i = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); [EOL]     if (i == -1) { [EOL]         return StringUtils.EMPTY; [EOL]     } [EOL]     return className.substring(0, i); [EOL] }
public static List<Class<?>> getAllSuperclasses(final Class<?> cls) { [EOL]     if (cls == null) { [EOL]         return null; [EOL]     } [EOL]     final List<Class<?>> classes = new ArrayList<Class<?>>(); [EOL]     Class<?> superclass = cls.getSuperclass(); [EOL]     while (superclass != null) { [EOL]         classes.add(superclass); [EOL]         superclass = superclass.getSuperclass(); [EOL]     } [EOL]     return classes; [EOL] }
public static List<Class<?>> getAllSuperclasses(final Class<?> cls) { [EOL]     if (cls == null) { [EOL]         return null; [EOL]     } [EOL]     final List<Class<?>> classes = new ArrayList<Class<?>>(); [EOL]     Class<?> superclass = cls.getSuperclass(); [EOL]     while (superclass != null) { [EOL]         classes.add(superclass); [EOL]         superclass = superclass.getSuperclass(); [EOL]     } [EOL]     return classes; [EOL] }
public static List<Class<?>> getAllSuperclasses(final Class<?> cls) { [EOL]     if (cls == null) { [EOL]         return null; [EOL]     } [EOL]     final List<Class<?>> classes = new ArrayList<Class<?>>(); [EOL]     Class<?> superclass = cls.getSuperclass(); [EOL]     while (superclass != null) { [EOL]         classes.add(superclass); [EOL]         superclass = superclass.getSuperclass(); [EOL]     } [EOL]     return classes; [EOL] }
public static List<String> convertClassesToClassNames(final List<Class<?>> classes) { [EOL]     if (classes == null) { [EOL]         return null; [EOL]     } [EOL]     final List<String> classNames = new ArrayList<String>(classes.size()); [EOL]     for (final Class<?> cls : classes) { [EOL]         if (cls == null) { [EOL]             classNames.add(null); [EOL]         } else { [EOL]             classNames.add(cls.getName()); [EOL]         } [EOL]     } [EOL]     return classNames; [EOL] }
public static boolean isAssignable(final Class<?>[] classArray, final Class<?>... toClassArray) { [EOL]     return isAssignable(classArray, toClassArray, SystemUtils.isJavaVersionAtLeast(JavaVersion.JAVA_1_5)); [EOL] }
public static boolean isAssignable(final Class<?>[] classArray, final Class<?>... toClassArray) { [EOL]     return isAssignable(classArray, toClassArray, SystemUtils.isJavaVersionAtLeast(JavaVersion.JAVA_1_5)); [EOL] }
public static boolean isAssignable(final Class<?>[] classArray, final Class<?>... toClassArray) { [EOL]     return isAssignable(classArray, toClassArray, SystemUtils.isJavaVersionAtLeast(JavaVersion.JAVA_1_5)); [EOL] }
public static boolean isAssignable(final Class<?>[] classArray, final Class<?>... toClassArray) { [EOL]     return isAssignable(classArray, toClassArray, SystemUtils.isJavaVersionAtLeast(JavaVersion.JAVA_1_5)); [EOL] }
public static boolean isAssignable(final Class<?>[] classArray, final Class<?>... toClassArray) { [EOL]     return isAssignable(classArray, toClassArray, SystemUtils.isJavaVersionAtLeast(JavaVersion.JAVA_1_5)); [EOL] }
public static boolean isAssignable(final Class<?>[] classArray, final Class<?>... toClassArray) { [EOL]     return isAssignable(classArray, toClassArray, SystemUtils.isJavaVersionAtLeast(JavaVersion.JAVA_1_5)); [EOL] }
public static boolean isAssignable(Class<?>[] classArray, Class<?>[] toClassArray, final boolean autoboxing) { [EOL]     if (ArrayUtils.isSameLength(classArray, toClassArray) == false) { [EOL]         return false; [EOL]     } [EOL]     if (classArray == null) { [EOL]         classArray = ArrayUtils.EMPTY_CLASS_ARRAY; [EOL]     } [EOL]     if (toClassArray == null) { [EOL]         toClassArray = ArrayUtils.EMPTY_CLASS_ARRAY; [EOL]     } [EOL]     for (int i = 0; i < classArray.length; i++) { [EOL]         if (isAssignable(classArray[i], toClassArray[i], autoboxing) == false) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public static boolean isAssignable(Class<?> cls, final Class<?> toClass, final boolean autoboxing) { [EOL]     if (toClass == null) { [EOL]         return false; [EOL]     } [EOL]     if (cls == null) { [EOL]         return !toClass.isPrimitive(); [EOL]     } [EOL]     if (autoboxing) { [EOL]         if (cls.isPrimitive() && !toClass.isPrimitive()) { [EOL]             cls = primitiveToWrapper(cls); [EOL]             if (cls == null) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]         if (toClass.isPrimitive() && !cls.isPrimitive()) { [EOL]             cls = wrapperToPrimitive(cls); [EOL]             if (cls == null) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (cls.equals(toClass)) { [EOL]         return true; [EOL]     } [EOL]     if (cls.isPrimitive()) { [EOL]         if (toClass.isPrimitive() == false) { [EOL]             return false; [EOL]         } [EOL]         if (Integer.TYPE.equals(cls)) { [EOL]             return Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Long.TYPE.equals(cls)) { [EOL]             return Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Boolean.TYPE.equals(cls)) { [EOL]             return false; [EOL]         } [EOL]         if (Double.TYPE.equals(cls)) { [EOL]             return false; [EOL]         } [EOL]         if (Float.TYPE.equals(cls)) { [EOL]             return Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Character.TYPE.equals(cls)) { [EOL]             return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Short.TYPE.equals(cls)) { [EOL]             return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Byte.TYPE.equals(cls)) { [EOL]             return Short.TYPE.equals(toClass) || Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         return false; [EOL]     } [EOL]     return toClass.isAssignableFrom(cls); [EOL] }
public static boolean isAssignable(Class<?> cls, final Class<?> toClass, final boolean autoboxing) { [EOL]     if (toClass == null) { [EOL]         return false; [EOL]     } [EOL]     if (cls == null) { [EOL]         return !toClass.isPrimitive(); [EOL]     } [EOL]     if (autoboxing) { [EOL]         if (cls.isPrimitive() && !toClass.isPrimitive()) { [EOL]             cls = primitiveToWrapper(cls); [EOL]             if (cls == null) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]         if (toClass.isPrimitive() && !cls.isPrimitive()) { [EOL]             cls = wrapperToPrimitive(cls); [EOL]             if (cls == null) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (cls.equals(toClass)) { [EOL]         return true; [EOL]     } [EOL]     if (cls.isPrimitive()) { [EOL]         if (toClass.isPrimitive() == false) { [EOL]             return false; [EOL]         } [EOL]         if (Integer.TYPE.equals(cls)) { [EOL]             return Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Long.TYPE.equals(cls)) { [EOL]             return Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Boolean.TYPE.equals(cls)) { [EOL]             return false; [EOL]         } [EOL]         if (Double.TYPE.equals(cls)) { [EOL]             return false; [EOL]         } [EOL]         if (Float.TYPE.equals(cls)) { [EOL]             return Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Character.TYPE.equals(cls)) { [EOL]             return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Short.TYPE.equals(cls)) { [EOL]             return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Byte.TYPE.equals(cls)) { [EOL]             return Short.TYPE.equals(toClass) || Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         return false; [EOL]     } [EOL]     return toClass.isAssignableFrom(cls); [EOL] }
public static Class<?> getClass(final ClassLoader classLoader, final String className, final boolean initialize) throws ClassNotFoundException { [EOL]     try { [EOL]         Class<?> clazz; [EOL]         if (abbreviationMap.containsKey(className)) { [EOL]             final String clsName = "[" + abbreviationMap.get(className); [EOL]             clazz = Class.forName(clsName, initialize, classLoader).getComponentType(); [EOL]         } else { [EOL]             clazz = Class.forName(toCanonicalName(className), initialize, classLoader); [EOL]         } [EOL]         return clazz; [EOL]     } catch (final ClassNotFoundException ex) { [EOL]         final int lastDotIndex = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); [EOL]         if (lastDotIndex != -1) { [EOL]             try { [EOL]                 return getClass(classLoader, className.substring(0, lastDotIndex) + INNER_CLASS_SEPARATOR_CHAR + className.substring(lastDotIndex + 1), initialize); [EOL]             } catch (final ClassNotFoundException ex2) { [EOL]             } [EOL]         } [EOL]         throw ex; [EOL]     } [EOL] }
public static Class<?> getClass(final String className) throws ClassNotFoundException { [EOL]     return getClass(className, true); [EOL] }
public static Class<?> getClass(final String className) throws ClassNotFoundException { [EOL]     return getClass(className, true); [EOL] }
public static Class<?> getClass(final String className, final boolean initialize) throws ClassNotFoundException { [EOL]     final ClassLoader contextCL = Thread.currentThread().getContextClassLoader(); [EOL]     final ClassLoader loader = contextCL == null ? ClassUtils.class.getClassLoader() : contextCL; [EOL]     return getClass(loader, className, initialize); [EOL] }
public static Class<?> getClass(final String className, final boolean initialize) throws ClassNotFoundException { [EOL]     final ClassLoader contextCL = Thread.currentThread().getContextClassLoader(); [EOL]     final ClassLoader loader = contextCL == null ? ClassUtils.class.getClassLoader() : contextCL; [EOL]     return getClass(loader, className, initialize); [EOL] }
private static String toCanonicalName(String className) { [EOL]     className = StringUtils.deleteWhitespace(className); [EOL]     if (className == null) { [EOL]         throw new NullPointerException("className must not be null."); [EOL]     } else if (className.endsWith("[]")) { [EOL]         final StringBuilder classNameBuffer = new StringBuilder(); [EOL]         while (className.endsWith("[]")) { [EOL]             className = className.substring(0, className.length() - 2); [EOL]             classNameBuffer.append("["); [EOL]         } [EOL]         final String abbreviation = abbreviationMap.get(className); [EOL]         if (abbreviation != null) { [EOL]             classNameBuffer.append(abbreviation); [EOL]         } else { [EOL]             classNameBuffer.append("L").append(className).append(";"); [EOL]         } [EOL]         className = classNameBuffer.toString(); [EOL]     } [EOL]     return className; [EOL] }
private static String toCanonicalName(String className) { [EOL]     className = StringUtils.deleteWhitespace(className); [EOL]     if (className == null) { [EOL]         throw new NullPointerException("className must not be null."); [EOL]     } else if (className.endsWith("[]")) { [EOL]         final StringBuilder classNameBuffer = new StringBuilder(); [EOL]         while (className.endsWith("[]")) { [EOL]             className = className.substring(0, className.length() - 2); [EOL]             classNameBuffer.append("["); [EOL]         } [EOL]         final String abbreviation = abbreviationMap.get(className); [EOL]         if (abbreviation != null) { [EOL]             classNameBuffer.append(abbreviation); [EOL]         } else { [EOL]             classNameBuffer.append("L").append(className).append(";"); [EOL]         } [EOL]         className = classNameBuffer.toString(); [EOL]     } [EOL]     return className; [EOL] }
private static String toCanonicalName(String className) { [EOL]     className = StringUtils.deleteWhitespace(className); [EOL]     if (className == null) { [EOL]         throw new NullPointerException("className must not be null."); [EOL]     } else if (className.endsWith("[]")) { [EOL]         final StringBuilder classNameBuffer = new StringBuilder(); [EOL]         while (className.endsWith("[]")) { [EOL]             className = className.substring(0, className.length() - 2); [EOL]             classNameBuffer.append("["); [EOL]         } [EOL]         final String abbreviation = abbreviationMap.get(className); [EOL]         if (abbreviation != null) { [EOL]             classNameBuffer.append(abbreviation); [EOL]         } else { [EOL]             classNameBuffer.append("L").append(className).append(";"); [EOL]         } [EOL]         className = classNameBuffer.toString(); [EOL]     } [EOL]     return className; [EOL] }
private static String toCanonicalName(String className) { [EOL]     className = StringUtils.deleteWhitespace(className); [EOL]     if (className == null) { [EOL]         throw new NullPointerException("className must not be null."); [EOL]     } else if (className.endsWith("[]")) { [EOL]         final StringBuilder classNameBuffer = new StringBuilder(); [EOL]         while (className.endsWith("[]")) { [EOL]             className = className.substring(0, className.length() - 2); [EOL]             classNameBuffer.append("["); [EOL]         } [EOL]         final String abbreviation = abbreviationMap.get(className); [EOL]         if (abbreviation != null) { [EOL]             classNameBuffer.append(abbreviation); [EOL]         } else { [EOL]             classNameBuffer.append("L").append(className).append(";"); [EOL]         } [EOL]         className = classNameBuffer.toString(); [EOL]     } [EOL]     return className; [EOL] }
private static String toCanonicalName(String className) { [EOL]     className = StringUtils.deleteWhitespace(className); [EOL]     if (className == null) { [EOL]         throw new NullPointerException("className must not be null."); [EOL]     } else if (className.endsWith("[]")) { [EOL]         final StringBuilder classNameBuffer = new StringBuilder(); [EOL]         while (className.endsWith("[]")) { [EOL]             className = className.substring(0, className.length() - 2); [EOL]             classNameBuffer.append("["); [EOL]         } [EOL]         final String abbreviation = abbreviationMap.get(className); [EOL]         if (abbreviation != null) { [EOL]             classNameBuffer.append(abbreviation); [EOL]         } else { [EOL]             classNameBuffer.append("L").append(className).append(";"); [EOL]         } [EOL]         className = classNameBuffer.toString(); [EOL]     } [EOL]     return className; [EOL] }
private static String toCanonicalName(String className) { [EOL]     className = StringUtils.deleteWhitespace(className); [EOL]     if (className == null) { [EOL]         throw new NullPointerException("className must not be null."); [EOL]     } else if (className.endsWith("[]")) { [EOL]         final StringBuilder classNameBuffer = new StringBuilder(); [EOL]         while (className.endsWith("[]")) { [EOL]             className = className.substring(0, className.length() - 2); [EOL]             classNameBuffer.append("["); [EOL]         } [EOL]         final String abbreviation = abbreviationMap.get(className); [EOL]         if (abbreviation != null) { [EOL]             classNameBuffer.append(abbreviation); [EOL]         } else { [EOL]             classNameBuffer.append("L").append(className).append(";"); [EOL]         } [EOL]         className = classNameBuffer.toString(); [EOL]     } [EOL]     return className; [EOL] }
private static String toCanonicalName(String className) { [EOL]     className = StringUtils.deleteWhitespace(className); [EOL]     if (className == null) { [EOL]         throw new NullPointerException("className must not be null."); [EOL]     } else if (className.endsWith("[]")) { [EOL]         final StringBuilder classNameBuffer = new StringBuilder(); [EOL]         while (className.endsWith("[]")) { [EOL]             className = className.substring(0, className.length() - 2); [EOL]             classNameBuffer.append("["); [EOL]         } [EOL]         final String abbreviation = abbreviationMap.get(className); [EOL]         if (abbreviation != null) { [EOL]             classNameBuffer.append(abbreviation); [EOL]         } else { [EOL]             classNameBuffer.append("L").append(className).append(";"); [EOL]         } [EOL]         className = classNameBuffer.toString(); [EOL]     } [EOL]     return className; [EOL] }
public static String getPackageCanonicalName(final Object object, final String valueIfNull) { [EOL]     if (object == null) { [EOL]         return valueIfNull; [EOL]     } [EOL]     return getPackageCanonicalName(object.getClass().getName()); [EOL] }
public static String getPackageCanonicalName(final Object object, final String valueIfNull) { [EOL]     if (object == null) { [EOL]         return valueIfNull; [EOL]     } [EOL]     return getPackageCanonicalName(object.getClass().getName()); [EOL] }
public static String getPackageCanonicalName(final String canonicalName) { [EOL]     return ClassUtils.getPackageName(getCanonicalName(canonicalName)); [EOL] }
public synchronized boolean start() { [EOL]     if (!isStarted()) { [EOL]         ExecutorService tempExec; [EOL]         executor = getExternalExecutor(); [EOL]         if (executor == null) { [EOL]             executor = tempExec = createExecutor(); [EOL]         } else { [EOL]             tempExec = null; [EOL]         } [EOL]         future = executor.submit(createTask(tempExec)); [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] }
public synchronized boolean start() { [EOL]     if (!isStarted()) { [EOL]         ExecutorService tempExec; [EOL]         executor = getExternalExecutor(); [EOL]         if (executor == null) { [EOL]             executor = tempExec = createExecutor(); [EOL]         } else { [EOL]             tempExec = null; [EOL]         } [EOL]         future = executor.submit(createTask(tempExec)); [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] }
public synchronized boolean start() { [EOL]     if (!isStarted()) { [EOL]         ExecutorService tempExec; [EOL]         executor = getExternalExecutor(); [EOL]         if (executor == null) { [EOL]             executor = tempExec = createExecutor(); [EOL]         } else { [EOL]             tempExec = null; [EOL]         } [EOL]         future = executor.submit(createTask(tempExec)); [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] }
@Override [EOL] public T get() throws ConcurrentException { [EOL]     try { [EOL]         return getFuture().get(); [EOL]     } catch (final ExecutionException execex) { [EOL]         ConcurrentUtils.handleCause(execex); [EOL]         return null; [EOL]     } catch (final InterruptedException iex) { [EOL]         Thread.currentThread().interrupt(); [EOL]         throw new ConcurrentException(iex); [EOL]     } [EOL] }
@Override [EOL] public T get() throws ConcurrentException { [EOL]     try { [EOL]         return getFuture().get(); [EOL]     } catch (final ExecutionException execex) { [EOL]         ConcurrentUtils.handleCause(execex); [EOL]         return null; [EOL]     } catch (final InterruptedException iex) { [EOL]         Thread.currentThread().interrupt(); [EOL]         throw new ConcurrentException(iex); [EOL]     } [EOL] }
@Override [EOL] public T get() throws ConcurrentException { [EOL]     try { [EOL]         return getFuture().get(); [EOL]     } catch (final ExecutionException execex) { [EOL]         ConcurrentUtils.handleCause(execex); [EOL]         return null; [EOL]     } catch (final InterruptedException iex) { [EOL]         Thread.currentThread().interrupt(); [EOL]         throw new ConcurrentException(iex); [EOL]     } [EOL] }
public synchronized Future<T> getFuture() { [EOL]     if (future == null) { [EOL]         throw new IllegalStateException("start() must be called first!"); [EOL]     } [EOL]     return future; [EOL] }
public synchronized Future<T> getFuture() { [EOL]     if (future == null) { [EOL]         throw new IllegalStateException("start() must be called first!"); [EOL]     } [EOL]     return future; [EOL] }
public ConcurrentRuntimeException(final String msg, final Throwable cause) { [EOL]     super(msg, ConcurrentUtils.checkedException(cause)); [EOL] }
public ConcurrentRuntimeException(final String msg, final Throwable cause) { [EOL]     super(msg, ConcurrentUtils.checkedException(cause)); [EOL] }
public static StrLookup<?> noneLookup() { [EOL]     return NONE_LOOKUP; [EOL] }
public static <V> StrLookup<V> mapLookup(final Map<String, V> map) { [EOL]     return new MapStrLookup<V>(map); [EOL] }
public static <V> StrLookup<V> mapLookup(final Map<String, V> map) { [EOL]     return new MapStrLookup<V>(map); [EOL] }
protected StrLookup() { [EOL]     super(); [EOL] }
MapStrLookup(final Map<String, V> map) { [EOL]     this.map = map; [EOL] }
MapStrLookup(final Map<String, V> map) { [EOL]     this.map = map; [EOL] }
MapStrLookup(final Map<String, V> map) { [EOL]     this.map = map; [EOL] }
@Override [EOL] public String lookup(final String key) { [EOL]     if (map == null) { [EOL]         return null; [EOL]     } [EOL]     final Object obj = map.get(key); [EOL]     if (obj == null) { [EOL]         return null; [EOL]     } [EOL]     return obj.toString(); [EOL] }
public static ConcurrentRuntimeException extractCauseUnchecked(final ExecutionException ex) { [EOL]     if (ex == null || ex.getCause() == null) { [EOL]         return null; [EOL]     } [EOL]     throwCause(ex); [EOL]     return new ConcurrentRuntimeException(ex.getMessage(), ex.getCause()); [EOL] }
public static ConcurrentRuntimeException extractCauseUnchecked(final ExecutionException ex) { [EOL]     if (ex == null || ex.getCause() == null) { [EOL]         return null; [EOL]     } [EOL]     throwCause(ex); [EOL]     return new ConcurrentRuntimeException(ex.getMessage(), ex.getCause()); [EOL] }
public static ConcurrentRuntimeException extractCauseUnchecked(final ExecutionException ex) { [EOL]     if (ex == null || ex.getCause() == null) { [EOL]         return null; [EOL]     } [EOL]     throwCause(ex); [EOL]     return new ConcurrentRuntimeException(ex.getMessage(), ex.getCause()); [EOL] }
public static void handleCauseUnchecked(final ExecutionException ex) { [EOL]     final ConcurrentRuntimeException crex = extractCauseUnchecked(ex); [EOL]     if (crex != null) { [EOL]         throw crex; [EOL]     } [EOL] }
public static void handleCauseUnchecked(final ExecutionException ex) { [EOL]     final ConcurrentRuntimeException crex = extractCauseUnchecked(ex); [EOL]     if (crex != null) { [EOL]         throw crex; [EOL]     } [EOL] }
public static void handleCauseUnchecked(final ExecutionException ex) { [EOL]     final ConcurrentRuntimeException crex = extractCauseUnchecked(ex); [EOL]     if (crex != null) { [EOL]         throw crex; [EOL]     } [EOL] }
private static void throwCause(final ExecutionException ex) { [EOL]     if (ex.getCause() instanceof RuntimeException) { [EOL]         throw (RuntimeException) ex.getCause(); [EOL]     } [EOL]     if (ex.getCause() instanceof Error) { [EOL]         throw (Error) ex.getCause(); [EOL]     } [EOL] }
private static void throwCause(final ExecutionException ex) { [EOL]     if (ex.getCause() instanceof RuntimeException) { [EOL]         throw (RuntimeException) ex.getCause(); [EOL]     } [EOL]     if (ex.getCause() instanceof Error) { [EOL]         throw (Error) ex.getCause(); [EOL]     } [EOL] }
private static void throwCause(final ExecutionException ex) { [EOL]     if (ex.getCause() instanceof RuntimeException) { [EOL]         throw (RuntimeException) ex.getCause(); [EOL]     } [EOL]     if (ex.getCause() instanceof Error) { [EOL]         throw (Error) ex.getCause(); [EOL]     } [EOL] }
public static <K, V> V createIfAbsent(final ConcurrentMap<K, V> map, final K key, final ConcurrentInitializer<V> init) throws ConcurrentException { [EOL]     if (map == null || init == null) { [EOL]         return null; [EOL]     } [EOL]     final V value = map.get(key); [EOL]     if (value == null) { [EOL]         return putIfAbsent(map, key, init.get()); [EOL]     } [EOL]     return value; [EOL] }
public static <K, V> V createIfAbsent(final ConcurrentMap<K, V> map, final K key, final ConcurrentInitializer<V> init) throws ConcurrentException { [EOL]     if (map == null || init == null) { [EOL]         return null; [EOL]     } [EOL]     final V value = map.get(key); [EOL]     if (value == null) { [EOL]         return putIfAbsent(map, key, init.get()); [EOL]     } [EOL]     return value; [EOL] }
public static <K, V> V createIfAbsent(final ConcurrentMap<K, V> map, final K key, final ConcurrentInitializer<V> init) throws ConcurrentException { [EOL]     if (map == null || init == null) { [EOL]         return null; [EOL]     } [EOL]     final V value = map.get(key); [EOL]     if (value == null) { [EOL]         return putIfAbsent(map, key, init.get()); [EOL]     } [EOL]     return value; [EOL] }
public static <K, V> V createIfAbsent(final ConcurrentMap<K, V> map, final K key, final ConcurrentInitializer<V> init) throws ConcurrentException { [EOL]     if (map == null || init == null) { [EOL]         return null; [EOL]     } [EOL]     final V value = map.get(key); [EOL]     if (value == null) { [EOL]         return putIfAbsent(map, key, init.get()); [EOL]     } [EOL]     return value; [EOL] }
private void init() { [EOL]     final Calendar definingCalendar = Calendar.getInstance(timeZone, locale); [EOL]     thisYear = definingCalendar.get(Calendar.YEAR); [EOL]     final StringBuilder regex = new StringBuilder(); [EOL]     final List<Strategy> collector = new ArrayList<Strategy>(); [EOL]     final Matcher patternMatcher = formatPattern.matcher(pattern); [EOL]     if (!patternMatcher.lookingAt()) { [EOL]         throw new IllegalArgumentException("Illegal pattern character '" + pattern.charAt(patternMatcher.regionStart()) + "'"); [EOL]     } [EOL]     currentFormatField = patternMatcher.group(); [EOL]     Strategy currentStrategy = getStrategy(currentFormatField, definingCalendar); [EOL]     for (; ; ) { [EOL]         patternMatcher.region(patternMatcher.end(), patternMatcher.regionEnd()); [EOL]         if (!patternMatcher.lookingAt()) { [EOL]             nextStrategy = null; [EOL]             break; [EOL]         } [EOL]         final String nextFormatField = patternMatcher.group(); [EOL]         nextStrategy = getStrategy(nextFormatField, definingCalendar); [EOL]         if (currentStrategy.addRegex(this, regex)) { [EOL]             collector.add(currentStrategy); [EOL]         } [EOL]         currentFormatField = nextFormatField; [EOL]         currentStrategy = nextStrategy; [EOL]     } [EOL]     if (patternMatcher.regionStart() != patternMatcher.regionEnd()) { [EOL]         throw new IllegalArgumentException("Failed to parse \"" + pattern + "\" ; gave up at index " + patternMatcher.regionStart()); [EOL]     } [EOL]     if (currentStrategy.addRegex(this, regex)) { [EOL]         collector.add(currentStrategy); [EOL]     } [EOL]     currentFormatField = null; [EOL]     strategies = collector.toArray(new Strategy[collector.size()]); [EOL]     parsePattern = Pattern.compile(regex.toString()); [EOL] } protected FastDateParser(final String pattern, final TimeZone timeZone, final Locale locale);  CopyQuotedStrategy(final String formatField);  TextStrategy(final int field, final Calendar definingCalendar, final Locale locale);  NumberStrategy(final int field);  TimeZoneStrategy(final Locale locale); private void init(); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale();  Pattern getParsePattern(); public boolean equals(final Object obj); public int hashCode(); public String toString(); private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException; public Object parseObject(final String source) throws ParseException; public Date parse(final String source) throws ParseException; public Object parseObject(final String source, final ParsePosition pos); public Date parse(final String source, final ParsePosition pos); private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote); private static Map<String, Integer> getDisplayNames(final int field, final Calendar definingCalendar, final Locale locale);  int adjustYear(final int twoDigitYear);  boolean isNextNumber();  int getFieldWidth();  boolean isNumber();  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  abstract boolean addRegex(FastDateParser parser, StringBuilder regex); private Strategy getStrategy(String formatField, final Calendar definingCalendar); private static ConcurrentMap<Locale, Strategy> getCache(final int field); private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  int modify(final int iValue);  int modify(final int iValue); long serialVersionUID=Optional[1L]; Locale JAPANESE_IMPERIAL=Optional[new Locale("ja", "JP", "JP")]; String pattern; TimeZone timeZone; Locale locale; Pattern parsePattern; Strategy[] strategies; int thisYear; String currentFormatField; Strategy nextStrategy; Pattern formatPattern=Optional[Pattern.compile("D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++")]; ConcurrentMap<Locale, Strategy>[] caches=Optional[new ConcurrentMap[Calendar.FIELD_COUNT]]; Strategy ABBREVIATED_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR) {; ;     /**;      * {@inheritDoc};      */;     @Override;     void setCalendar(final FastDateParser parser, final Calendar cal, final String value) {;         int iValue = Integer.parseInt(value);;         if (iValue < 100) {;             iValue = parser.adjustYear(iValue);;         };         cal.set(Calendar.YEAR, iValue);;     }; }]; Strategy NUMBER_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.MONTH) {; ;     @Override;     int modify(final int iValue) {;         return iValue - 1;;     }; }]; Strategy LITERAL_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR)]; Strategy WEEK_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_YEAR)]; Strategy WEEK_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_MONTH)]; Strategy DAY_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_YEAR)]; Strategy DAY_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_MONTH)]; Strategy DAY_OF_WEEK_IN_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_WEEK_IN_MONTH)]; Strategy HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY)]; Strategy MODULO_HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 24;;     }; }]; Strategy MODULO_HOUR_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 12;;     }; }
@Override [EOL] public String getPattern() { [EOL]     return pattern; [EOL] } protected FastDateParser(final String pattern, final TimeZone timeZone, final Locale locale);  CopyQuotedStrategy(final String formatField);  TextStrategy(final int field, final Calendar definingCalendar, final Locale locale);  NumberStrategy(final int field);  TimeZoneStrategy(final Locale locale); private void init(); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale();  Pattern getParsePattern(); public boolean equals(final Object obj); public int hashCode(); public String toString(); private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException; public Object parseObject(final String source) throws ParseException; public Date parse(final String source) throws ParseException; public Object parseObject(final String source, final ParsePosition pos); public Date parse(final String source, final ParsePosition pos); private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote); private static Map<String, Integer> getDisplayNames(final int field, final Calendar definingCalendar, final Locale locale);  int adjustYear(final int twoDigitYear);  boolean isNextNumber();  int getFieldWidth();  boolean isNumber();  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  abstract boolean addRegex(FastDateParser parser, StringBuilder regex); private Strategy getStrategy(String formatField, final Calendar definingCalendar); private static ConcurrentMap<Locale, Strategy> getCache(final int field); private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  int modify(final int iValue);  int modify(final int iValue); long serialVersionUID=Optional[1L]; Locale JAPANESE_IMPERIAL=Optional[new Locale("ja", "JP", "JP")]; String pattern; TimeZone timeZone; Locale locale; Pattern parsePattern; Strategy[] strategies; int thisYear; String currentFormatField; Strategy nextStrategy; Pattern formatPattern=Optional[Pattern.compile("D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++")]; ConcurrentMap<Locale, Strategy>[] caches=Optional[new ConcurrentMap[Calendar.FIELD_COUNT]]; Strategy ABBREVIATED_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR) {; ;     /**;      * {@inheritDoc};      */;     @Override;     void setCalendar(final FastDateParser parser, final Calendar cal, final String value) {;         int iValue = Integer.parseInt(value);;         if (iValue < 100) {;             iValue = parser.adjustYear(iValue);;         };         cal.set(Calendar.YEAR, iValue);;     }; }]; Strategy NUMBER_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.MONTH) {; ;     @Override;     int modify(final int iValue) {;         return iValue - 1;;     }; }]; Strategy LITERAL_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.YEAR)]; Strategy WEEK_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_YEAR)]; Strategy WEEK_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.WEEK_OF_MONTH)]; Strategy DAY_OF_YEAR_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_YEAR)]; Strategy DAY_OF_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_MONTH)]; Strategy DAY_OF_WEEK_IN_MONTH_STRATEGY=Optional[new NumberStrategy(Calendar.DAY_OF_WEEK_IN_MONTH)]; Strategy HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY)]; Strategy MODULO_HOUR_OF_DAY_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR_OF_DAY) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 24;;     }; }]; Strategy MODULO_HOUR_STRATEGY=Optional[new NumberStrategy(Calendar.HOUR) {; ;     @Override;     int modify(final int iValue) {;         return iValue % 12;;     }; }
public <V> StrSubstitutor(final Map<String, V> valueMap) { [EOL]     this(StrLookup.mapLookup(valueMap), DEFAULT_PREFIX, DEFAULT_SUFFIX, DEFAULT_ESCAPE); [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape) { [EOL]     this.setVariableResolver(variableResolver); [EOL]     this.setVariablePrefixMatcher(prefixMatcher); [EOL]     this.setVariableSuffixMatcher(suffixMatcher); [EOL]     this.setEscapeChar(escape); [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape) { [EOL]     this.setVariableResolver(variableResolver); [EOL]     this.setVariablePrefixMatcher(prefixMatcher); [EOL]     this.setVariableSuffixMatcher(suffixMatcher); [EOL]     this.setEscapeChar(escape); [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape) { [EOL]     this.setVariableResolver(variableResolver); [EOL]     this.setVariablePrefixMatcher(prefixMatcher); [EOL]     this.setVariableSuffixMatcher(suffixMatcher); [EOL]     this.setEscapeChar(escape); [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape) { [EOL]     this.setVariableResolver(variableResolver); [EOL]     this.setVariablePrefixMatcher(prefixMatcher); [EOL]     this.setVariableSuffixMatcher(suffixMatcher); [EOL]     this.setEscapeChar(escape); [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape) { [EOL]     this.setVariableResolver(variableResolver); [EOL]     this.setVariablePrefixMatcher(prefixMatcher); [EOL]     this.setVariableSuffixMatcher(suffixMatcher); [EOL]     this.setEscapeChar(escape); [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape) { [EOL]     this.setVariableResolver(variableResolver); [EOL]     this.setVariablePrefixMatcher(prefixMatcher); [EOL]     this.setVariableSuffixMatcher(suffixMatcher); [EOL]     this.setEscapeChar(escape); [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape) { [EOL]     this.setVariableResolver(variableResolver); [EOL]     this.setVariablePrefixMatcher(prefixMatcher); [EOL]     this.setVariableSuffixMatcher(suffixMatcher); [EOL]     this.setEscapeChar(escape); [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public String replace(final String source) { [EOL]     if (source == null) { [EOL]         return null; [EOL]     } [EOL]     final StrBuilder buf = new StrBuilder(source); [EOL]     if (substitute(buf, 0, source.length()) == false) { [EOL]         return source; [EOL]     } [EOL]     return buf.toString(); [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public String replace(final String source, final int offset, final int length) { [EOL]     if (source == null) { [EOL]         return null; [EOL]     } [EOL]     final StrBuilder buf = new StrBuilder(length).append(source, offset, length); [EOL]     if (substitute(buf, 0, length) == false) { [EOL]         return source.substring(offset, offset + length); [EOL]     } [EOL]     return buf.toString(); [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public String replace(final String source, final int offset, final int length) { [EOL]     if (source == null) { [EOL]         return null; [EOL]     } [EOL]     final StrBuilder buf = new StrBuilder(length).append(source, offset, length); [EOL]     if (substitute(buf, 0, length) == false) { [EOL]         return source.substring(offset, offset + length); [EOL]     } [EOL]     return buf.toString(); [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public String replace(final String source, final int offset, final int length) { [EOL]     if (source == null) { [EOL]         return null; [EOL]     } [EOL]     final StrBuilder buf = new StrBuilder(length).append(source, offset, length); [EOL]     if (substitute(buf, 0, length) == false) { [EOL]         return source.substring(offset, offset + length); [EOL]     } [EOL]     return buf.toString(); [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public String replace(final String source, final int offset, final int length) { [EOL]     if (source == null) { [EOL]         return null; [EOL]     } [EOL]     final StrBuilder buf = new StrBuilder(length).append(source, offset, length); [EOL]     if (substitute(buf, 0, length) == false) { [EOL]         return source.substring(offset, offset + length); [EOL]     } [EOL]     return buf.toString(); [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public String replace(final String source, final int offset, final int length) { [EOL]     if (source == null) { [EOL]         return null; [EOL]     } [EOL]     final StrBuilder buf = new StrBuilder(length).append(source, offset, length); [EOL]     if (substitute(buf, 0, length) == false) { [EOL]         return source.substring(offset, offset + length); [EOL]     } [EOL]     return buf.toString(); [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public String replace(final String source, final int offset, final int length) { [EOL]     if (source == null) { [EOL]         return null; [EOL]     } [EOL]     final StrBuilder buf = new StrBuilder(length).append(source, offset, length); [EOL]     if (substitute(buf, 0, length) == false) { [EOL]         return source.substring(offset, offset + length); [EOL]     } [EOL]     return buf.toString(); [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public String replace(final char[] source) { [EOL]     if (source == null) { [EOL]         return null; [EOL]     } [EOL]     final StrBuilder buf = new StrBuilder(source.length).append(source); [EOL]     substitute(buf, 0, source.length); [EOL]     return buf.toString(); [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public String replace(final char[] source) { [EOL]     if (source == null) { [EOL]         return null; [EOL]     } [EOL]     final StrBuilder buf = new StrBuilder(source.length).append(source); [EOL]     substitute(buf, 0, source.length); [EOL]     return buf.toString(); [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public String replace(final char[] source) { [EOL]     if (source == null) { [EOL]         return null; [EOL]     } [EOL]     final StrBuilder buf = new StrBuilder(source.length).append(source); [EOL]     substitute(buf, 0, source.length); [EOL]     return buf.toString(); [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public String replace(final StringBuffer source) { [EOL]     if (source == null) { [EOL]         return null; [EOL]     } [EOL]     final StrBuilder buf = new StrBuilder(source.length()).append(source); [EOL]     substitute(buf, 0, buf.length()); [EOL]     return buf.toString(); [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public String replace(CharSequence source) { [EOL]     if (source == null) { [EOL]         return null; [EOL]     } [EOL]     return replace(source, 0, source.length()); [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public String replace(CharSequence source, int offset, int length) { [EOL]     if (source == null) { [EOL]         return null; [EOL]     } [EOL]     StrBuilder buf = new StrBuilder(length).append(source, offset, length); [EOL]     substitute(buf, 0, length); [EOL]     return buf.toString(); [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public String replace(CharSequence source, int offset, int length) { [EOL]     if (source == null) { [EOL]         return null; [EOL]     } [EOL]     StrBuilder buf = new StrBuilder(length).append(source, offset, length); [EOL]     substitute(buf, 0, length); [EOL]     return buf.toString(); [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public String replace(CharSequence source, int offset, int length) { [EOL]     if (source == null) { [EOL]         return null; [EOL]     } [EOL]     StrBuilder buf = new StrBuilder(length).append(source, offset, length); [EOL]     substitute(buf, 0, length); [EOL]     return buf.toString(); [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public String replace(CharSequence source, int offset, int length) { [EOL]     if (source == null) { [EOL]         return null; [EOL]     } [EOL]     StrBuilder buf = new StrBuilder(length).append(source, offset, length); [EOL]     substitute(buf, 0, length); [EOL]     return buf.toString(); [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public String replace(CharSequence source, int offset, int length) { [EOL]     if (source == null) { [EOL]         return null; [EOL]     } [EOL]     StrBuilder buf = new StrBuilder(length).append(source, offset, length); [EOL]     substitute(buf, 0, length); [EOL]     return buf.toString(); [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public String replace(CharSequence source, int offset, int length) { [EOL]     if (source == null) { [EOL]         return null; [EOL]     } [EOL]     StrBuilder buf = new StrBuilder(length).append(source, offset, length); [EOL]     substitute(buf, 0, length); [EOL]     return buf.toString(); [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public String replace(CharSequence source, int offset, int length) { [EOL]     if (source == null) { [EOL]         return null; [EOL]     } [EOL]     StrBuilder buf = new StrBuilder(length).append(source, offset, length); [EOL]     substitute(buf, 0, length); [EOL]     return buf.toString(); [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public String replace(final StrBuilder source) { [EOL]     if (source == null) { [EOL]         return null; [EOL]     } [EOL]     final StrBuilder buf = new StrBuilder(source.length()).append(source); [EOL]     substitute(buf, 0, buf.length()); [EOL]     return buf.toString(); [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public String replace(final StrBuilder source) { [EOL]     if (source == null) { [EOL]         return null; [EOL]     } [EOL]     final StrBuilder buf = new StrBuilder(source.length()).append(source); [EOL]     substitute(buf, 0, buf.length()); [EOL]     return buf.toString(); [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public String replace(final Object source) { [EOL]     if (source == null) { [EOL]         return null; [EOL]     } [EOL]     final StrBuilder buf = new StrBuilder().append(source); [EOL]     substitute(buf, 0, buf.length()); [EOL]     return buf.toString(); [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public String replace(final Object source) { [EOL]     if (source == null) { [EOL]         return null; [EOL]     } [EOL]     final StrBuilder buf = new StrBuilder().append(source); [EOL]     substitute(buf, 0, buf.length()); [EOL]     return buf.toString(); [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public boolean replaceIn(final StringBuffer source) { [EOL]     if (source == null) { [EOL]         return false; [EOL]     } [EOL]     return replaceIn(source, 0, source.length()); [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public boolean replaceIn(final StringBuffer source) { [EOL]     if (source == null) { [EOL]         return false; [EOL]     } [EOL]     return replaceIn(source, 0, source.length()); [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public boolean replaceIn(final StringBuffer source) { [EOL]     if (source == null) { [EOL]         return false; [EOL]     } [EOL]     return replaceIn(source, 0, source.length()); [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public boolean replaceIn(final StringBuffer source, final int offset, final int length) { [EOL]     if (source == null) { [EOL]         return false; [EOL]     } [EOL]     final StrBuilder buf = new StrBuilder(length).append(source, offset, length); [EOL]     if (substitute(buf, 0, length) == false) { [EOL]         return false; [EOL]     } [EOL]     source.replace(offset, offset + length, buf.toString()); [EOL]     return true; [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public boolean replaceIn(StringBuilder source) { [EOL]     if (source == null) { [EOL]         return false; [EOL]     } [EOL]     return replaceIn(source, 0, source.length()); [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public boolean replaceIn(StringBuilder source) { [EOL]     if (source == null) { [EOL]         return false; [EOL]     } [EOL]     return replaceIn(source, 0, source.length()); [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public boolean replaceIn(StringBuilder source, int offset, int length) { [EOL]     if (source == null) { [EOL]         return false; [EOL]     } [EOL]     StrBuilder buf = new StrBuilder(length).append(source, offset, length); [EOL]     if (substitute(buf, 0, length) == false) { [EOL]         return false; [EOL]     } [EOL]     source.replace(offset, offset + length, buf.toString()); [EOL]     return true; [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public boolean replaceIn(StringBuilder source, int offset, int length) { [EOL]     if (source == null) { [EOL]         return false; [EOL]     } [EOL]     StrBuilder buf = new StrBuilder(length).append(source, offset, length); [EOL]     if (substitute(buf, 0, length) == false) { [EOL]         return false; [EOL]     } [EOL]     source.replace(offset, offset + length, buf.toString()); [EOL]     return true; [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public boolean replaceIn(StringBuilder source, int offset, int length) { [EOL]     if (source == null) { [EOL]         return false; [EOL]     } [EOL]     StrBuilder buf = new StrBuilder(length).append(source, offset, length); [EOL]     if (substitute(buf, 0, length) == false) { [EOL]         return false; [EOL]     } [EOL]     source.replace(offset, offset + length, buf.toString()); [EOL]     return true; [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public boolean replaceIn(StringBuilder source, int offset, int length) { [EOL]     if (source == null) { [EOL]         return false; [EOL]     } [EOL]     StrBuilder buf = new StrBuilder(length).append(source, offset, length); [EOL]     if (substitute(buf, 0, length) == false) { [EOL]         return false; [EOL]     } [EOL]     source.replace(offset, offset + length, buf.toString()); [EOL]     return true; [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public boolean replaceIn(StringBuilder source, int offset, int length) { [EOL]     if (source == null) { [EOL]         return false; [EOL]     } [EOL]     StrBuilder buf = new StrBuilder(length).append(source, offset, length); [EOL]     if (substitute(buf, 0, length) == false) { [EOL]         return false; [EOL]     } [EOL]     source.replace(offset, offset + length, buf.toString()); [EOL]     return true; [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public boolean replaceIn(StringBuilder source, int offset, int length) { [EOL]     if (source == null) { [EOL]         return false; [EOL]     } [EOL]     StrBuilder buf = new StrBuilder(length).append(source, offset, length); [EOL]     if (substitute(buf, 0, length) == false) { [EOL]         return false; [EOL]     } [EOL]     source.replace(offset, offset + length, buf.toString()); [EOL]     return true; [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public boolean replaceIn(final StrBuilder source) { [EOL]     if (source == null) { [EOL]         return false; [EOL]     } [EOL]     return substitute(source, 0, source.length()); [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public boolean replaceIn(final StrBuilder source) { [EOL]     if (source == null) { [EOL]         return false; [EOL]     } [EOL]     return substitute(source, 0, source.length()); [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
protected boolean substitute(final StrBuilder buf, final int offset, final int length) { [EOL]     return substitute(buf, offset, length, null) > 0; [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables) { [EOL]     final StrMatcher prefixMatcher = getVariablePrefixMatcher(); [EOL]     final StrMatcher suffixMatcher = getVariableSuffixMatcher(); [EOL]     final char escape = getEscapeChar(); [EOL]     final boolean top = priorVariables == null; [EOL]     boolean altered = false; [EOL]     int lengthChange = 0; [EOL]     char[] chars = buf.buffer; [EOL]     int bufEnd = offset + length; [EOL]     int pos = offset; [EOL]     while (pos < bufEnd) { [EOL]         final int startMatchLen = prefixMatcher.isMatch(chars, pos, offset, bufEnd); [EOL]         if (startMatchLen == 0) { [EOL]             pos++; [EOL]         } else { [EOL]             if (pos > offset && chars[pos - 1] == escape) { [EOL]                 buf.deleteCharAt(pos - 1); [EOL]                 chars = buf.buffer; [EOL]                 lengthChange--; [EOL]                 altered = true; [EOL]                 bufEnd--; [EOL]             } else { [EOL]                 final int startPos = pos; [EOL]                 pos += startMatchLen; [EOL]                 int endMatchLen = 0; [EOL]                 int nestedVarCount = 0; [EOL]                 while (pos < bufEnd) { [EOL]                     if (isEnableSubstitutionInVariables() && (endMatchLen = prefixMatcher.isMatch(chars, pos, offset, bufEnd)) != 0) { [EOL]                         nestedVarCount++; [EOL]                         pos += endMatchLen; [EOL]                         continue; [EOL]                     } [EOL]                     endMatchLen = suffixMatcher.isMatch(chars, pos, offset, bufEnd); [EOL]                     if (endMatchLen == 0) { [EOL]                         pos++; [EOL]                     } else { [EOL]                         if (nestedVarCount == 0) { [EOL]                             String varName = new String(chars, startPos + startMatchLen, pos - startPos - startMatchLen); [EOL]                             if (isEnableSubstitutionInVariables()) { [EOL]                                 final StrBuilder bufName = new StrBuilder(varName); [EOL]                                 substitute(bufName, 0, bufName.length()); [EOL]                                 varName = bufName.toString(); [EOL]                             } [EOL]                             pos += endMatchLen; [EOL]                             final int endPos = pos; [EOL]                             if (priorVariables == null) { [EOL]                                 priorVariables = new ArrayList<String>(); [EOL]                                 priorVariables.add(new String(chars, offset, length)); [EOL]                             } [EOL]                             checkCyclicSubstitution(varName, priorVariables); [EOL]                             priorVariables.add(varName); [EOL]                             final String varValue = resolveVariable(varName, buf, startPos, endPos); [EOL]                             if (varValue != null) { [EOL]                                 final int varLen = varValue.length(); [EOL]                                 buf.replace(startPos, endPos, varValue); [EOL]                                 altered = true; [EOL]                                 int change = substitute(buf, startPos, varLen, priorVariables); [EOL]                                 change = change + varLen - (endPos - startPos); [EOL]                                 pos += change; [EOL]                                 bufEnd += change; [EOL]                                 lengthChange += change; [EOL]                                 chars = buf.buffer; [EOL]                             } [EOL]                             priorVariables.remove(priorVariables.size() - 1); [EOL]                             break; [EOL]                         } else { [EOL]                             nestedVarCount--; [EOL]                             pos += endMatchLen; [EOL]                         } [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     if (top) { [EOL]         return altered ? 1 : 0; [EOL]     } [EOL]     return lengthChange; [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
private void checkCyclicSubstitution(final String varName, final List<String> priorVariables) { [EOL]     if (priorVariables.contains(varName) == false) { [EOL]         return; [EOL]     } [EOL]     final StrBuilder buf = new StrBuilder(256); [EOL]     buf.append("Infinite loop in property interpolation of "); [EOL]     buf.append(priorVariables.remove(0)); [EOL]     buf.append(": "); [EOL]     buf.appendWithSeparators(priorVariables, "->"); [EOL]     throw new IllegalStateException(buf.toString()); [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
private void checkCyclicSubstitution(final String varName, final List<String> priorVariables) { [EOL]     if (priorVariables.contains(varName) == false) { [EOL]         return; [EOL]     } [EOL]     final StrBuilder buf = new StrBuilder(256); [EOL]     buf.append("Infinite loop in property interpolation of "); [EOL]     buf.append(priorVariables.remove(0)); [EOL]     buf.append(": "); [EOL]     buf.appendWithSeparators(priorVariables, "->"); [EOL]     throw new IllegalStateException(buf.toString()); [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos) { [EOL]     final StrLookup<?> resolver = getVariableResolver(); [EOL]     if (resolver == null) { [EOL]         return null; [EOL]     } [EOL]     return resolver.lookup(variableName); [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public char getEscapeChar() { [EOL]     return this.escapeChar; [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public char getEscapeChar() { [EOL]     return this.escapeChar; [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public char getEscapeChar() { [EOL]     return this.escapeChar; [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public char getEscapeChar() { [EOL]     return this.escapeChar; [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public char getEscapeChar() { [EOL]     return this.escapeChar; [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public char getEscapeChar() { [EOL]     return this.escapeChar; [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public char getEscapeChar() { [EOL]     return this.escapeChar; [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public char getEscapeChar() { [EOL]     return this.escapeChar; [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public void setEscapeChar(final char escapeCharacter) { [EOL]     this.escapeChar = escapeCharacter; [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public void setEscapeChar(final char escapeCharacter) { [EOL]     this.escapeChar = escapeCharacter; [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public void setEscapeChar(final char escapeCharacter) { [EOL]     this.escapeChar = escapeCharacter; [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public void setEscapeChar(final char escapeCharacter) { [EOL]     this.escapeChar = escapeCharacter; [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public void setEscapeChar(final char escapeCharacter) { [EOL]     this.escapeChar = escapeCharacter; [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public void setEscapeChar(final char escapeCharacter) { [EOL]     this.escapeChar = escapeCharacter; [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public void setEscapeChar(final char escapeCharacter) { [EOL]     this.escapeChar = escapeCharacter; [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public void setEscapeChar(final char escapeCharacter) { [EOL]     this.escapeChar = escapeCharacter; [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public StrMatcher getVariablePrefixMatcher() { [EOL]     return prefixMatcher; [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public StrMatcher getVariablePrefixMatcher() { [EOL]     return prefixMatcher; [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher) { [EOL]     if (prefixMatcher == null) { [EOL]         throw new IllegalArgumentException("Variable prefix matcher must not be null!"); [EOL]     } [EOL]     this.prefixMatcher = prefixMatcher; [EOL]     return this; [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher) { [EOL]     if (prefixMatcher == null) { [EOL]         throw new IllegalArgumentException("Variable prefix matcher must not be null!"); [EOL]     } [EOL]     this.prefixMatcher = prefixMatcher; [EOL]     return this; [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public StrMatcher getVariableSuffixMatcher() { [EOL]     return suffixMatcher; [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher) { [EOL]     if (suffixMatcher == null) { [EOL]         throw new IllegalArgumentException("Variable suffix matcher must not be null!"); [EOL]     } [EOL]     this.suffixMatcher = suffixMatcher; [EOL]     return this; [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher) { [EOL]     if (suffixMatcher == null) { [EOL]         throw new IllegalArgumentException("Variable suffix matcher must not be null!"); [EOL]     } [EOL]     this.suffixMatcher = suffixMatcher; [EOL]     return this; [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public StrLookup<?> getVariableResolver() { [EOL]     return this.variableResolver; [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public StrLookup<?> getVariableResolver() { [EOL]     return this.variableResolver; [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public StrLookup<?> getVariableResolver() { [EOL]     return this.variableResolver; [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public StrLookup<?> getVariableResolver() { [EOL]     return this.variableResolver; [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public StrLookup<?> getVariableResolver() { [EOL]     return this.variableResolver; [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public StrLookup<?> getVariableResolver() { [EOL]     return this.variableResolver; [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public StrLookup<?> getVariableResolver() { [EOL]     return this.variableResolver; [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public void setVariableResolver(final StrLookup<?> variableResolver) { [EOL]     this.variableResolver = variableResolver; [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public boolean isEnableSubstitutionInVariables() { [EOL]     return enableSubstitutionInVariables; [EOL] } public StrSubstitutor(); public StrSubstitutor(final Map<String, V> valueMap); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver); public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); public static String replace(final Object source, final Map<String, V> valueMap); public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); public static String replace(final Object source, final Properties valueProperties); public static String replaceSystemProperties(final Object source); public String replace(final String source); public String replace(final String source, final int offset, final int length); public String replace(final char[] source); public String replace(final char[] source, final int offset, final int length); public String replace(final StringBuffer source); public String replace(final StringBuffer source, final int offset, final int length); public String replace(CharSequence source); public String replace(CharSequence source, int offset, int length); public String replace(final StrBuilder source); public String replace(final StrBuilder source, final int offset, final int length); public String replace(final Object source); public boolean replaceIn(final StringBuffer source); public boolean replaceIn(final StringBuffer source, final int offset, final int length); public boolean replaceIn(StringBuilder source); public boolean replaceIn(StringBuilder source, int offset, int length); public boolean replaceIn(final StrBuilder source); public boolean replaceIn(final StrBuilder source, final int offset, final int length); protected boolean substitute(final StrBuilder buf, final int offset, final int length); private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables); private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); public char getEscapeChar(); public void setEscapeChar(final char escapeCharacter); public StrMatcher getVariablePrefixMatcher(); public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); public StrSubstitutor setVariablePrefix(final char prefix); public StrSubstitutor setVariablePrefix(final String prefix); public StrMatcher getVariableSuffixMatcher(); public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); public StrSubstitutor setVariableSuffix(final char suffix); public StrSubstitutor setVariableSuffix(final String suffix); public StrLookup<?> getVariableResolver(); public void setVariableResolver(final StrLookup<?> variableResolver); public boolean isEnableSubstitutionInVariables(); public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); char DEFAULT_ESCAPE=Optional['$']; StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}
public static Fraction getReducedFraction(int numerator, int denominator) { [EOL]     if (denominator == 0) { [EOL]         throw new ArithmeticException("The denominator must not be zero"); [EOL]     } [EOL]     if (numerator == 0) { [EOL]         return ZERO; [EOL]     } [EOL]     if (denominator == Integer.MIN_VALUE && (numerator & 1) == 0) { [EOL]         numerator /= 2; [EOL]         denominator /= 2; [EOL]     } [EOL]     if (denominator < 0) { [EOL]         if (numerator == Integer.MIN_VALUE || denominator == Integer.MIN_VALUE) { [EOL]             throw new ArithmeticException("overflow: can't negate"); [EOL]         } [EOL]         numerator = -numerator; [EOL]         denominator = -denominator; [EOL]     } [EOL]     final int gcd = greatestCommonDivisor(numerator, denominator); [EOL]     numerator /= gcd; [EOL]     denominator /= gcd; [EOL]     return new Fraction(numerator, denominator); [EOL] }
public static Fraction getReducedFraction(int numerator, int denominator) { [EOL]     if (denominator == 0) { [EOL]         throw new ArithmeticException("The denominator must not be zero"); [EOL]     } [EOL]     if (numerator == 0) { [EOL]         return ZERO; [EOL]     } [EOL]     if (denominator == Integer.MIN_VALUE && (numerator & 1) == 0) { [EOL]         numerator /= 2; [EOL]         denominator /= 2; [EOL]     } [EOL]     if (denominator < 0) { [EOL]         if (numerator == Integer.MIN_VALUE || denominator == Integer.MIN_VALUE) { [EOL]             throw new ArithmeticException("overflow: can't negate"); [EOL]         } [EOL]         numerator = -numerator; [EOL]         denominator = -denominator; [EOL]     } [EOL]     final int gcd = greatestCommonDivisor(numerator, denominator); [EOL]     numerator /= gcd; [EOL]     denominator /= gcd; [EOL]     return new Fraction(numerator, denominator); [EOL] }
public static Fraction getReducedFraction(int numerator, int denominator) { [EOL]     if (denominator == 0) { [EOL]         throw new ArithmeticException("The denominator must not be zero"); [EOL]     } [EOL]     if (numerator == 0) { [EOL]         return ZERO; [EOL]     } [EOL]     if (denominator == Integer.MIN_VALUE && (numerator & 1) == 0) { [EOL]         numerator /= 2; [EOL]         denominator /= 2; [EOL]     } [EOL]     if (denominator < 0) { [EOL]         if (numerator == Integer.MIN_VALUE || denominator == Integer.MIN_VALUE) { [EOL]             throw new ArithmeticException("overflow: can't negate"); [EOL]         } [EOL]         numerator = -numerator; [EOL]         denominator = -denominator; [EOL]     } [EOL]     final int gcd = greatestCommonDivisor(numerator, denominator); [EOL]     numerator /= gcd; [EOL]     denominator /= gcd; [EOL]     return new Fraction(numerator, denominator); [EOL] }
public static Fraction getReducedFraction(int numerator, int denominator) { [EOL]     if (denominator == 0) { [EOL]         throw new ArithmeticException("The denominator must not be zero"); [EOL]     } [EOL]     if (numerator == 0) { [EOL]         return ZERO; [EOL]     } [EOL]     if (denominator == Integer.MIN_VALUE && (numerator & 1) == 0) { [EOL]         numerator /= 2; [EOL]         denominator /= 2; [EOL]     } [EOL]     if (denominator < 0) { [EOL]         if (numerator == Integer.MIN_VALUE || denominator == Integer.MIN_VALUE) { [EOL]             throw new ArithmeticException("overflow: can't negate"); [EOL]         } [EOL]         numerator = -numerator; [EOL]         denominator = -denominator; [EOL]     } [EOL]     final int gcd = greatestCommonDivisor(numerator, denominator); [EOL]     numerator /= gcd; [EOL]     denominator /= gcd; [EOL]     return new Fraction(numerator, denominator); [EOL] }
public static Fraction getReducedFraction(int numerator, int denominator) { [EOL]     if (denominator == 0) { [EOL]         throw new ArithmeticException("The denominator must not be zero"); [EOL]     } [EOL]     if (numerator == 0) { [EOL]         return ZERO; [EOL]     } [EOL]     if (denominator == Integer.MIN_VALUE && (numerator & 1) == 0) { [EOL]         numerator /= 2; [EOL]         denominator /= 2; [EOL]     } [EOL]     if (denominator < 0) { [EOL]         if (numerator == Integer.MIN_VALUE || denominator == Integer.MIN_VALUE) { [EOL]             throw new ArithmeticException("overflow: can't negate"); [EOL]         } [EOL]         numerator = -numerator; [EOL]         denominator = -denominator; [EOL]     } [EOL]     final int gcd = greatestCommonDivisor(numerator, denominator); [EOL]     numerator /= gcd; [EOL]     denominator /= gcd; [EOL]     return new Fraction(numerator, denominator); [EOL] }
public static Fraction getReducedFraction(int numerator, int denominator) { [EOL]     if (denominator == 0) { [EOL]         throw new ArithmeticException("The denominator must not be zero"); [EOL]     } [EOL]     if (numerator == 0) { [EOL]         return ZERO; [EOL]     } [EOL]     if (denominator == Integer.MIN_VALUE && (numerator & 1) == 0) { [EOL]         numerator /= 2; [EOL]         denominator /= 2; [EOL]     } [EOL]     if (denominator < 0) { [EOL]         if (numerator == Integer.MIN_VALUE || denominator == Integer.MIN_VALUE) { [EOL]             throw new ArithmeticException("overflow: can't negate"); [EOL]         } [EOL]         numerator = -numerator; [EOL]         denominator = -denominator; [EOL]     } [EOL]     final int gcd = greatestCommonDivisor(numerator, denominator); [EOL]     numerator /= gcd; [EOL]     denominator /= gcd; [EOL]     return new Fraction(numerator, denominator); [EOL] }
public static Fraction getReducedFraction(int numerator, int denominator) { [EOL]     if (denominator == 0) { [EOL]         throw new ArithmeticException("The denominator must not be zero"); [EOL]     } [EOL]     if (numerator == 0) { [EOL]         return ZERO; [EOL]     } [EOL]     if (denominator == Integer.MIN_VALUE && (numerator & 1) == 0) { [EOL]         numerator /= 2; [EOL]         denominator /= 2; [EOL]     } [EOL]     if (denominator < 0) { [EOL]         if (numerator == Integer.MIN_VALUE || denominator == Integer.MIN_VALUE) { [EOL]             throw new ArithmeticException("overflow: can't negate"); [EOL]         } [EOL]         numerator = -numerator; [EOL]         denominator = -denominator; [EOL]     } [EOL]     final int gcd = greatestCommonDivisor(numerator, denominator); [EOL]     numerator /= gcd; [EOL]     denominator /= gcd; [EOL]     return new Fraction(numerator, denominator); [EOL] }
public static Fraction getReducedFraction(int numerator, int denominator) { [EOL]     if (denominator == 0) { [EOL]         throw new ArithmeticException("The denominator must not be zero"); [EOL]     } [EOL]     if (numerator == 0) { [EOL]         return ZERO; [EOL]     } [EOL]     if (denominator == Integer.MIN_VALUE && (numerator & 1) == 0) { [EOL]         numerator /= 2; [EOL]         denominator /= 2; [EOL]     } [EOL]     if (denominator < 0) { [EOL]         if (numerator == Integer.MIN_VALUE || denominator == Integer.MIN_VALUE) { [EOL]             throw new ArithmeticException("overflow: can't negate"); [EOL]         } [EOL]         numerator = -numerator; [EOL]         denominator = -denominator; [EOL]     } [EOL]     final int gcd = greatestCommonDivisor(numerator, denominator); [EOL]     numerator /= gcd; [EOL]     denominator /= gcd; [EOL]     return new Fraction(numerator, denominator); [EOL] }
private static int addAndCheck(final int x, final int y) { [EOL]     final long s = (long) x + (long) y; [EOL]     if (s < Integer.MIN_VALUE || s > Integer.MAX_VALUE) { [EOL]         throw new ArithmeticException("overflow: add"); [EOL]     } [EOL]     return (int) s; [EOL] }
private static int addAndCheck(final int x, final int y) { [EOL]     final long s = (long) x + (long) y; [EOL]     if (s < Integer.MIN_VALUE || s > Integer.MAX_VALUE) { [EOL]         throw new ArithmeticException("overflow: add"); [EOL]     } [EOL]     return (int) s; [EOL] }
private static int addAndCheck(final int x, final int y) { [EOL]     final long s = (long) x + (long) y; [EOL]     if (s < Integer.MIN_VALUE || s > Integer.MAX_VALUE) { [EOL]         throw new ArithmeticException("overflow: add"); [EOL]     } [EOL]     return (int) s; [EOL] }
public Fraction add(final Fraction fraction) { [EOL]     return addSub(fraction, true); [EOL] }
public Fraction add(final Fraction fraction) { [EOL]     return addSub(fraction, true); [EOL] }
public Fraction add(final Fraction fraction) { [EOL]     return addSub(fraction, true); [EOL] }
public Fraction add(final Fraction fraction) { [EOL]     return addSub(fraction, true); [EOL] }
private Fraction addSub(final Fraction fraction, final boolean isAdd) { [EOL]     if (fraction == null) { [EOL]         throw new IllegalArgumentException("The fraction must not be null"); [EOL]     } [EOL]     if (numerator == 0) { [EOL]         return isAdd ? fraction : fraction.negate(); [EOL]     } [EOL]     if (fraction.numerator == 0) { [EOL]         return this; [EOL]     } [EOL]     final int d1 = greatestCommonDivisor(denominator, fraction.denominator); [EOL]     if (d1 == 1) { [EOL]         final int uvp = mulAndCheck(numerator, fraction.denominator); [EOL]         final int upv = mulAndCheck(fraction.numerator, denominator); [EOL]         return new Fraction(isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv), mulPosAndCheck(denominator, fraction.denominator)); [EOL]     } [EOL]     final BigInteger uvp = BigInteger.valueOf(numerator).multiply(BigInteger.valueOf(fraction.denominator / d1)); [EOL]     final BigInteger upv = BigInteger.valueOf(fraction.numerator).multiply(BigInteger.valueOf(denominator / d1)); [EOL]     final BigInteger t = isAdd ? uvp.add(upv) : uvp.subtract(upv); [EOL]     final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue(); [EOL]     final int d2 = tmodd1 == 0 ? d1 : greatestCommonDivisor(tmodd1, d1); [EOL]     final BigInteger w = t.divide(BigInteger.valueOf(d2)); [EOL]     if (w.bitLength() > 31) { [EOL]         throw new ArithmeticException("overflow: numerator too large after multiply"); [EOL]     } [EOL]     return new Fraction(w.intValue(), mulPosAndCheck(denominator / d1, fraction.denominator / d2)); [EOL] }
@Override [EOL] public String toString() { [EOL]     if (toString == null) { [EOL]         toString = new StringBuilder(32).append(getNumerator()).append('/').append(getDenominator()).toString(); [EOL]     } [EOL]     return toString; [EOL] }
public static CharSequence subSequence(final CharSequence cs, final int start) { [EOL]     return cs == null ? null : cs.subSequence(start, cs.length()); [EOL] }
public static CharSequence subSequence(final CharSequence cs, final int start) { [EOL]     return cs == null ? null : cs.subSequence(start, cs.length()); [EOL] }
public static CharSequence subSequence(final CharSequence cs, final int start) { [EOL]     return cs == null ? null : cs.subSequence(start, cs.length()); [EOL] }
public static CharSequence subSequence(final CharSequence cs, final int start) { [EOL]     return cs == null ? null : cs.subSequence(start, cs.length()); [EOL] }
public static CharSequence subSequence(final CharSequence cs, final int start) { [EOL]     return cs == null ? null : cs.subSequence(start, cs.length()); [EOL] }
public StrTokenizer() { [EOL]     super(); [EOL]     this.chars = null; [EOL] }
public StrTokenizer(final String input) { [EOL]     super(); [EOL]     if (input != null) { [EOL]         chars = input.toCharArray(); [EOL]     } else { [EOL]         chars = null; [EOL]     } [EOL] }
public StrTokenizer(final String input) { [EOL]     super(); [EOL]     if (input != null) { [EOL]         chars = input.toCharArray(); [EOL]     } else { [EOL]         chars = null; [EOL]     } [EOL] }
private void checkTokenized() { [EOL]     if (tokens == null) { [EOL]         if (chars == null) { [EOL]             final List<String> split = tokenize(null, 0, 0); [EOL]             tokens = split.toArray(new String[split.size()]); [EOL]         } else { [EOL]             final List<String> split = tokenize(chars, 0, chars.length); [EOL]             tokens = split.toArray(new String[split.size()]); [EOL]         } [EOL]     } [EOL] }
private void checkTokenized() { [EOL]     if (tokens == null) { [EOL]         if (chars == null) { [EOL]             final List<String> split = tokenize(null, 0, 0); [EOL]             tokens = split.toArray(new String[split.size()]); [EOL]         } else { [EOL]             final List<String> split = tokenize(chars, 0, chars.length); [EOL]             tokens = split.toArray(new String[split.size()]); [EOL]         } [EOL]     } [EOL] }
protected List<String> tokenize(final char[] chars, final int offset, final int count) { [EOL]     if (chars == null || count == 0) { [EOL]         return Collections.emptyList(); [EOL]     } [EOL]     final StrBuilder buf = new StrBuilder(); [EOL]     final List<String> tokens = new ArrayList<String>(); [EOL]     int pos = offset; [EOL]     while (pos >= 0 && pos < count) { [EOL]         pos = readNextToken(chars, pos, count, buf, tokens); [EOL]         if (pos >= count) { [EOL]             addToken(tokens, ""); [EOL]         } [EOL]     } [EOL]     return tokens; [EOL] }
protected List<String> tokenize(final char[] chars, final int offset, final int count) { [EOL]     if (chars == null || count == 0) { [EOL]         return Collections.emptyList(); [EOL]     } [EOL]     final StrBuilder buf = new StrBuilder(); [EOL]     final List<String> tokens = new ArrayList<String>(); [EOL]     int pos = offset; [EOL]     while (pos >= 0 && pos < count) { [EOL]         pos = readNextToken(chars, pos, count, buf, tokens); [EOL]         if (pos >= count) { [EOL]             addToken(tokens, ""); [EOL]         } [EOL]     } [EOL]     return tokens; [EOL] }
protected List<String> tokenize(final char[] chars, final int offset, final int count) { [EOL]     if (chars == null || count == 0) { [EOL]         return Collections.emptyList(); [EOL]     } [EOL]     final StrBuilder buf = new StrBuilder(); [EOL]     final List<String> tokens = new ArrayList<String>(); [EOL]     int pos = offset; [EOL]     while (pos >= 0 && pos < count) { [EOL]         pos = readNextToken(chars, pos, count, buf, tokens); [EOL]         if (pos >= count) { [EOL]             addToken(tokens, ""); [EOL]         } [EOL]     } [EOL]     return tokens; [EOL] }
protected List<String> tokenize(final char[] chars, final int offset, final int count) { [EOL]     if (chars == null || count == 0) { [EOL]         return Collections.emptyList(); [EOL]     } [EOL]     final StrBuilder buf = new StrBuilder(); [EOL]     final List<String> tokens = new ArrayList<String>(); [EOL]     int pos = offset; [EOL]     while (pos >= 0 && pos < count) { [EOL]         pos = readNextToken(chars, pos, count, buf, tokens); [EOL]         if (pos >= count) { [EOL]             addToken(tokens, ""); [EOL]         } [EOL]     } [EOL]     return tokens; [EOL] }
private int readNextToken(final char[] chars, int start, final int len, final StrBuilder workArea, final List<String> tokens) { [EOL]     while (start < len) { [EOL]         final int removeLen = Math.max(getIgnoredMatcher().isMatch(chars, start, start, len), getTrimmerMatcher().isMatch(chars, start, start, len)); [EOL]         if (removeLen == 0 || getDelimiterMatcher().isMatch(chars, start, start, len) > 0 || getQuoteMatcher().isMatch(chars, start, start, len) > 0) { [EOL]             break; [EOL]         } [EOL]         start += removeLen; [EOL]     } [EOL]     if (start >= len) { [EOL]         addToken(tokens, ""); [EOL]         return -1; [EOL]     } [EOL]     final int delimLen = getDelimiterMatcher().isMatch(chars, start, start, len); [EOL]     if (delimLen > 0) { [EOL]         addToken(tokens, ""); [EOL]         return start + delimLen; [EOL]     } [EOL]     final int quoteLen = getQuoteMatcher().isMatch(chars, start, start, len); [EOL]     if (quoteLen > 0) { [EOL]         return readWithQuotes(chars, start + quoteLen, len, workArea, tokens, start, quoteLen); [EOL]     } [EOL]     return readWithQuotes(chars, start, len, workArea, tokens, 0, 0); [EOL] }
private int readNextToken(final char[] chars, int start, final int len, final StrBuilder workArea, final List<String> tokens) { [EOL]     while (start < len) { [EOL]         final int removeLen = Math.max(getIgnoredMatcher().isMatch(chars, start, start, len), getTrimmerMatcher().isMatch(chars, start, start, len)); [EOL]         if (removeLen == 0 || getDelimiterMatcher().isMatch(chars, start, start, len) > 0 || getQuoteMatcher().isMatch(chars, start, start, len) > 0) { [EOL]             break; [EOL]         } [EOL]         start += removeLen; [EOL]     } [EOL]     if (start >= len) { [EOL]         addToken(tokens, ""); [EOL]         return -1; [EOL]     } [EOL]     final int delimLen = getDelimiterMatcher().isMatch(chars, start, start, len); [EOL]     if (delimLen > 0) { [EOL]         addToken(tokens, ""); [EOL]         return start + delimLen; [EOL]     } [EOL]     final int quoteLen = getQuoteMatcher().isMatch(chars, start, start, len); [EOL]     if (quoteLen > 0) { [EOL]         return readWithQuotes(chars, start + quoteLen, len, workArea, tokens, start, quoteLen); [EOL]     } [EOL]     return readWithQuotes(chars, start, len, workArea, tokens, 0, 0); [EOL] }
private int readNextToken(final char[] chars, int start, final int len, final StrBuilder workArea, final List<String> tokens) { [EOL]     while (start < len) { [EOL]         final int removeLen = Math.max(getIgnoredMatcher().isMatch(chars, start, start, len), getTrimmerMatcher().isMatch(chars, start, start, len)); [EOL]         if (removeLen == 0 || getDelimiterMatcher().isMatch(chars, start, start, len) > 0 || getQuoteMatcher().isMatch(chars, start, start, len) > 0) { [EOL]             break; [EOL]         } [EOL]         start += removeLen; [EOL]     } [EOL]     if (start >= len) { [EOL]         addToken(tokens, ""); [EOL]         return -1; [EOL]     } [EOL]     final int delimLen = getDelimiterMatcher().isMatch(chars, start, start, len); [EOL]     if (delimLen > 0) { [EOL]         addToken(tokens, ""); [EOL]         return start + delimLen; [EOL]     } [EOL]     final int quoteLen = getQuoteMatcher().isMatch(chars, start, start, len); [EOL]     if (quoteLen > 0) { [EOL]         return readWithQuotes(chars, start + quoteLen, len, workArea, tokens, start, quoteLen); [EOL]     } [EOL]     return readWithQuotes(chars, start, len, workArea, tokens, 0, 0); [EOL] }
private int readNextToken(final char[] chars, int start, final int len, final StrBuilder workArea, final List<String> tokens) { [EOL]     while (start < len) { [EOL]         final int removeLen = Math.max(getIgnoredMatcher().isMatch(chars, start, start, len), getTrimmerMatcher().isMatch(chars, start, start, len)); [EOL]         if (removeLen == 0 || getDelimiterMatcher().isMatch(chars, start, start, len) > 0 || getQuoteMatcher().isMatch(chars, start, start, len) > 0) { [EOL]             break; [EOL]         } [EOL]         start += removeLen; [EOL]     } [EOL]     if (start >= len) { [EOL]         addToken(tokens, ""); [EOL]         return -1; [EOL]     } [EOL]     final int delimLen = getDelimiterMatcher().isMatch(chars, start, start, len); [EOL]     if (delimLen > 0) { [EOL]         addToken(tokens, ""); [EOL]         return start + delimLen; [EOL]     } [EOL]     final int quoteLen = getQuoteMatcher().isMatch(chars, start, start, len); [EOL]     if (quoteLen > 0) { [EOL]         return readWithQuotes(chars, start + quoteLen, len, workArea, tokens, start, quoteLen); [EOL]     } [EOL]     return readWithQuotes(chars, start, len, workArea, tokens, 0, 0); [EOL] }
private int readNextToken(final char[] chars, int start, final int len, final StrBuilder workArea, final List<String> tokens) { [EOL]     while (start < len) { [EOL]         final int removeLen = Math.max(getIgnoredMatcher().isMatch(chars, start, start, len), getTrimmerMatcher().isMatch(chars, start, start, len)); [EOL]         if (removeLen == 0 || getDelimiterMatcher().isMatch(chars, start, start, len) > 0 || getQuoteMatcher().isMatch(chars, start, start, len) > 0) { [EOL]             break; [EOL]         } [EOL]         start += removeLen; [EOL]     } [EOL]     if (start >= len) { [EOL]         addToken(tokens, ""); [EOL]         return -1; [EOL]     } [EOL]     final int delimLen = getDelimiterMatcher().isMatch(chars, start, start, len); [EOL]     if (delimLen > 0) { [EOL]         addToken(tokens, ""); [EOL]         return start + delimLen; [EOL]     } [EOL]     final int quoteLen = getQuoteMatcher().isMatch(chars, start, start, len); [EOL]     if (quoteLen > 0) { [EOL]         return readWithQuotes(chars, start + quoteLen, len, workArea, tokens, start, quoteLen); [EOL]     } [EOL]     return readWithQuotes(chars, start, len, workArea, tokens, 0, 0); [EOL] }
private int readWithQuotes(final char[] chars, final int start, final int len, final StrBuilder workArea, final List<String> tokens, final int quoteStart, final int quoteLen) { [EOL]     workArea.clear(); [EOL]     int pos = start; [EOL]     boolean quoting = quoteLen > 0; [EOL]     int trimStart = 0; [EOL]     while (pos < len) { [EOL]         if (quoting) { [EOL]             if (isQuote(chars, pos, len, quoteStart, quoteLen)) { [EOL]                 if (isQuote(chars, pos + quoteLen, len, quoteStart, quoteLen)) { [EOL]                     workArea.append(chars, pos, quoteLen); [EOL]                     pos += quoteLen * 2; [EOL]                     trimStart = workArea.size(); [EOL]                     continue; [EOL]                 } [EOL]                 quoting = false; [EOL]                 pos += quoteLen; [EOL]                 continue; [EOL]             } [EOL]             workArea.append(chars[pos++]); [EOL]             trimStart = workArea.size(); [EOL]         } else { [EOL]             final int delimLen = getDelimiterMatcher().isMatch(chars, pos, start, len); [EOL]             if (delimLen > 0) { [EOL]                 addToken(tokens, workArea.substring(0, trimStart)); [EOL]                 return pos + delimLen; [EOL]             } [EOL]             if (quoteLen > 0 && isQuote(chars, pos, len, quoteStart, quoteLen)) { [EOL]                 quoting = true; [EOL]                 pos += quoteLen; [EOL]                 continue; [EOL]             } [EOL]             final int ignoredLen = getIgnoredMatcher().isMatch(chars, pos, start, len); [EOL]             if (ignoredLen > 0) { [EOL]                 pos += ignoredLen; [EOL]                 continue; [EOL]             } [EOL]             final int trimmedLen = getTrimmerMatcher().isMatch(chars, pos, start, len); [EOL]             if (trimmedLen > 0) { [EOL]                 workArea.append(chars, pos, trimmedLen); [EOL]                 pos += trimmedLen; [EOL]                 continue; [EOL]             } [EOL]             workArea.append(chars[pos++]); [EOL]             trimStart = workArea.size(); [EOL]         } [EOL]     } [EOL]     addToken(tokens, workArea.substring(0, trimStart)); [EOL]     return -1; [EOL] }
private int readWithQuotes(final char[] chars, final int start, final int len, final StrBuilder workArea, final List<String> tokens, final int quoteStart, final int quoteLen) { [EOL]     workArea.clear(); [EOL]     int pos = start; [EOL]     boolean quoting = quoteLen > 0; [EOL]     int trimStart = 0; [EOL]     while (pos < len) { [EOL]         if (quoting) { [EOL]             if (isQuote(chars, pos, len, quoteStart, quoteLen)) { [EOL]                 if (isQuote(chars, pos + quoteLen, len, quoteStart, quoteLen)) { [EOL]                     workArea.append(chars, pos, quoteLen); [EOL]                     pos += quoteLen * 2; [EOL]                     trimStart = workArea.size(); [EOL]                     continue; [EOL]                 } [EOL]                 quoting = false; [EOL]                 pos += quoteLen; [EOL]                 continue; [EOL]             } [EOL]             workArea.append(chars[pos++]); [EOL]             trimStart = workArea.size(); [EOL]         } else { [EOL]             final int delimLen = getDelimiterMatcher().isMatch(chars, pos, start, len); [EOL]             if (delimLen > 0) { [EOL]                 addToken(tokens, workArea.substring(0, trimStart)); [EOL]                 return pos + delimLen; [EOL]             } [EOL]             if (quoteLen > 0 && isQuote(chars, pos, len, quoteStart, quoteLen)) { [EOL]                 quoting = true; [EOL]                 pos += quoteLen; [EOL]                 continue; [EOL]             } [EOL]             final int ignoredLen = getIgnoredMatcher().isMatch(chars, pos, start, len); [EOL]             if (ignoredLen > 0) { [EOL]                 pos += ignoredLen; [EOL]                 continue; [EOL]             } [EOL]             final int trimmedLen = getTrimmerMatcher().isMatch(chars, pos, start, len); [EOL]             if (trimmedLen > 0) { [EOL]                 workArea.append(chars, pos, trimmedLen); [EOL]                 pos += trimmedLen; [EOL]                 continue; [EOL]             } [EOL]             workArea.append(chars[pos++]); [EOL]             trimStart = workArea.size(); [EOL]         } [EOL]     } [EOL]     addToken(tokens, workArea.substring(0, trimStart)); [EOL]     return -1; [EOL] }
private int readWithQuotes(final char[] chars, final int start, final int len, final StrBuilder workArea, final List<String> tokens, final int quoteStart, final int quoteLen) { [EOL]     workArea.clear(); [EOL]     int pos = start; [EOL]     boolean quoting = quoteLen > 0; [EOL]     int trimStart = 0; [EOL]     while (pos < len) { [EOL]         if (quoting) { [EOL]             if (isQuote(chars, pos, len, quoteStart, quoteLen)) { [EOL]                 if (isQuote(chars, pos + quoteLen, len, quoteStart, quoteLen)) { [EOL]                     workArea.append(chars, pos, quoteLen); [EOL]                     pos += quoteLen * 2; [EOL]                     trimStart = workArea.size(); [EOL]                     continue; [EOL]                 } [EOL]                 quoting = false; [EOL]                 pos += quoteLen; [EOL]                 continue; [EOL]             } [EOL]             workArea.append(chars[pos++]); [EOL]             trimStart = workArea.size(); [EOL]         } else { [EOL]             final int delimLen = getDelimiterMatcher().isMatch(chars, pos, start, len); [EOL]             if (delimLen > 0) { [EOL]                 addToken(tokens, workArea.substring(0, trimStart)); [EOL]                 return pos + delimLen; [EOL]             } [EOL]             if (quoteLen > 0 && isQuote(chars, pos, len, quoteStart, quoteLen)) { [EOL]                 quoting = true; [EOL]                 pos += quoteLen; [EOL]                 continue; [EOL]             } [EOL]             final int ignoredLen = getIgnoredMatcher().isMatch(chars, pos, start, len); [EOL]             if (ignoredLen > 0) { [EOL]                 pos += ignoredLen; [EOL]                 continue; [EOL]             } [EOL]             final int trimmedLen = getTrimmerMatcher().isMatch(chars, pos, start, len); [EOL]             if (trimmedLen > 0) { [EOL]                 workArea.append(chars, pos, trimmedLen); [EOL]                 pos += trimmedLen; [EOL]                 continue; [EOL]             } [EOL]             workArea.append(chars[pos++]); [EOL]             trimStart = workArea.size(); [EOL]         } [EOL]     } [EOL]     addToken(tokens, workArea.substring(0, trimStart)); [EOL]     return -1; [EOL] }
private int readWithQuotes(final char[] chars, final int start, final int len, final StrBuilder workArea, final List<String> tokens, final int quoteStart, final int quoteLen) { [EOL]     workArea.clear(); [EOL]     int pos = start; [EOL]     boolean quoting = quoteLen > 0; [EOL]     int trimStart = 0; [EOL]     while (pos < len) { [EOL]         if (quoting) { [EOL]             if (isQuote(chars, pos, len, quoteStart, quoteLen)) { [EOL]                 if (isQuote(chars, pos + quoteLen, len, quoteStart, quoteLen)) { [EOL]                     workArea.append(chars, pos, quoteLen); [EOL]                     pos += quoteLen * 2; [EOL]                     trimStart = workArea.size(); [EOL]                     continue; [EOL]                 } [EOL]                 quoting = false; [EOL]                 pos += quoteLen; [EOL]                 continue; [EOL]             } [EOL]             workArea.append(chars[pos++]); [EOL]             trimStart = workArea.size(); [EOL]         } else { [EOL]             final int delimLen = getDelimiterMatcher().isMatch(chars, pos, start, len); [EOL]             if (delimLen > 0) { [EOL]                 addToken(tokens, workArea.substring(0, trimStart)); [EOL]                 return pos + delimLen; [EOL]             } [EOL]             if (quoteLen > 0 && isQuote(chars, pos, len, quoteStart, quoteLen)) { [EOL]                 quoting = true; [EOL]                 pos += quoteLen; [EOL]                 continue; [EOL]             } [EOL]             final int ignoredLen = getIgnoredMatcher().isMatch(chars, pos, start, len); [EOL]             if (ignoredLen > 0) { [EOL]                 pos += ignoredLen; [EOL]                 continue; [EOL]             } [EOL]             final int trimmedLen = getTrimmerMatcher().isMatch(chars, pos, start, len); [EOL]             if (trimmedLen > 0) { [EOL]                 workArea.append(chars, pos, trimmedLen); [EOL]                 pos += trimmedLen; [EOL]                 continue; [EOL]             } [EOL]             workArea.append(chars[pos++]); [EOL]             trimStart = workArea.size(); [EOL]         } [EOL]     } [EOL]     addToken(tokens, workArea.substring(0, trimStart)); [EOL]     return -1; [EOL] }
private int readWithQuotes(final char[] chars, final int start, final int len, final StrBuilder workArea, final List<String> tokens, final int quoteStart, final int quoteLen) { [EOL]     workArea.clear(); [EOL]     int pos = start; [EOL]     boolean quoting = quoteLen > 0; [EOL]     int trimStart = 0; [EOL]     while (pos < len) { [EOL]         if (quoting) { [EOL]             if (isQuote(chars, pos, len, quoteStart, quoteLen)) { [EOL]                 if (isQuote(chars, pos + quoteLen, len, quoteStart, quoteLen)) { [EOL]                     workArea.append(chars, pos, quoteLen); [EOL]                     pos += quoteLen * 2; [EOL]                     trimStart = workArea.size(); [EOL]                     continue; [EOL]                 } [EOL]                 quoting = false; [EOL]                 pos += quoteLen; [EOL]                 continue; [EOL]             } [EOL]             workArea.append(chars[pos++]); [EOL]             trimStart = workArea.size(); [EOL]         } else { [EOL]             final int delimLen = getDelimiterMatcher().isMatch(chars, pos, start, len); [EOL]             if (delimLen > 0) { [EOL]                 addToken(tokens, workArea.substring(0, trimStart)); [EOL]                 return pos + delimLen; [EOL]             } [EOL]             if (quoteLen > 0 && isQuote(chars, pos, len, quoteStart, quoteLen)) { [EOL]                 quoting = true; [EOL]                 pos += quoteLen; [EOL]                 continue; [EOL]             } [EOL]             final int ignoredLen = getIgnoredMatcher().isMatch(chars, pos, start, len); [EOL]             if (ignoredLen > 0) { [EOL]                 pos += ignoredLen; [EOL]                 continue; [EOL]             } [EOL]             final int trimmedLen = getTrimmerMatcher().isMatch(chars, pos, start, len); [EOL]             if (trimmedLen > 0) { [EOL]                 workArea.append(chars, pos, trimmedLen); [EOL]                 pos += trimmedLen; [EOL]                 continue; [EOL]             } [EOL]             workArea.append(chars[pos++]); [EOL]             trimStart = workArea.size(); [EOL]         } [EOL]     } [EOL]     addToken(tokens, workArea.substring(0, trimStart)); [EOL]     return -1; [EOL] }
private int readWithQuotes(final char[] chars, final int start, final int len, final StrBuilder workArea, final List<String> tokens, final int quoteStart, final int quoteLen) { [EOL]     workArea.clear(); [EOL]     int pos = start; [EOL]     boolean quoting = quoteLen > 0; [EOL]     int trimStart = 0; [EOL]     while (pos < len) { [EOL]         if (quoting) { [EOL]             if (isQuote(chars, pos, len, quoteStart, quoteLen)) { [EOL]                 if (isQuote(chars, pos + quoteLen, len, quoteStart, quoteLen)) { [EOL]                     workArea.append(chars, pos, quoteLen); [EOL]                     pos += quoteLen * 2; [EOL]                     trimStart = workArea.size(); [EOL]                     continue; [EOL]                 } [EOL]                 quoting = false; [EOL]                 pos += quoteLen; [EOL]                 continue; [EOL]             } [EOL]             workArea.append(chars[pos++]); [EOL]             trimStart = workArea.size(); [EOL]         } else { [EOL]             final int delimLen = getDelimiterMatcher().isMatch(chars, pos, start, len); [EOL]             if (delimLen > 0) { [EOL]                 addToken(tokens, workArea.substring(0, trimStart)); [EOL]                 return pos + delimLen; [EOL]             } [EOL]             if (quoteLen > 0 && isQuote(chars, pos, len, quoteStart, quoteLen)) { [EOL]                 quoting = true; [EOL]                 pos += quoteLen; [EOL]                 continue; [EOL]             } [EOL]             final int ignoredLen = getIgnoredMatcher().isMatch(chars, pos, start, len); [EOL]             if (ignoredLen > 0) { [EOL]                 pos += ignoredLen; [EOL]                 continue; [EOL]             } [EOL]             final int trimmedLen = getTrimmerMatcher().isMatch(chars, pos, start, len); [EOL]             if (trimmedLen > 0) { [EOL]                 workArea.append(chars, pos, trimmedLen); [EOL]                 pos += trimmedLen; [EOL]                 continue; [EOL]             } [EOL]             workArea.append(chars[pos++]); [EOL]             trimStart = workArea.size(); [EOL]         } [EOL]     } [EOL]     addToken(tokens, workArea.substring(0, trimStart)); [EOL]     return -1; [EOL] }
public StrTokenizer setDelimiterMatcher(final StrMatcher delim) { [EOL]     if (delim == null) { [EOL]         this.delimMatcher = StrMatcher.noneMatcher(); [EOL]     } else { [EOL]         this.delimMatcher = delim; [EOL]     } [EOL]     return this; [EOL] }
public StrTokenizer setDelimiterMatcher(final StrMatcher delim) { [EOL]     if (delim == null) { [EOL]         this.delimMatcher = StrMatcher.noneMatcher(); [EOL]     } else { [EOL]         this.delimMatcher = delim; [EOL]     } [EOL]     return this; [EOL] }
public StrTokenizer setDelimiterString(final String delim) { [EOL]     return setDelimiterMatcher(StrMatcher.stringMatcher(delim)); [EOL] }
public StrTokenizer setDelimiterString(final String delim) { [EOL]     return setDelimiterMatcher(StrMatcher.stringMatcher(delim)); [EOL] }
public StrTokenizer setDelimiterString(final String delim) { [EOL]     return setDelimiterMatcher(StrMatcher.stringMatcher(delim)); [EOL] }
public StrTokenizer setIgnoredMatcher(final StrMatcher ignored) { [EOL]     if (ignored != null) { [EOL]         this.ignoredMatcher = ignored; [EOL]     } [EOL]     return this; [EOL] }
public StrTokenizer setIgnoredChar(final char ignored) { [EOL]     return setIgnoredMatcher(StrMatcher.charMatcher(ignored)); [EOL] }
public StrTokenizer setIgnoredChar(final char ignored) { [EOL]     return setIgnoredMatcher(StrMatcher.charMatcher(ignored)); [EOL] }
public String getContent() { [EOL]     if (chars == null) { [EOL]         return null; [EOL]     } [EOL]     return new String(chars); [EOL] }
public String getContent() { [EOL]     if (chars == null) { [EOL]         return null; [EOL]     } [EOL]     return new String(chars); [EOL] }
@Override [EOL] public Object clone() { [EOL]     try { [EOL]         return cloneReset(); [EOL]     } catch (final CloneNotSupportedException ex) { [EOL]         return null; [EOL]     } [EOL] }
@Override [EOL] public String toString() { [EOL]     if (tokens == null) { [EOL]         return "StrTokenizer[not tokenized yet]"; [EOL]     } [EOL]     return "StrTokenizer" + getTokenList(); [EOL] }
public static String formatUTC(final long millis, final String pattern, final Locale locale) { [EOL]     return format(new Date(millis), pattern, UTC_TIME_ZONE, locale); [EOL] }
public static String formatUTC(final long millis, final String pattern, final Locale locale) { [EOL]     return format(new Date(millis), pattern, UTC_TIME_ZONE, locale); [EOL] }
public static String formatUTC(final long millis, final String pattern, final Locale locale) { [EOL]     return format(new Date(millis), pattern, UTC_TIME_ZONE, locale); [EOL] }
public static String format(final long millis, final String pattern) { [EOL]     return format(new Date(millis), pattern, null, null); [EOL] }
public static String format(final long millis, final String pattern) { [EOL]     return format(new Date(millis), pattern, null, null); [EOL] }
public static String format(final long millis, final String pattern, final Locale locale) { [EOL]     return format(new Date(millis), pattern, null, locale); [EOL] }
public static String format(final long millis, final String pattern, final Locale locale) { [EOL]     return format(new Date(millis), pattern, null, locale); [EOL] }
public static String format(final long millis, final String pattern, final Locale locale) { [EOL]     return format(new Date(millis), pattern, null, locale); [EOL] }
public static String format(final long millis, final String pattern, final TimeZone timeZone, final Locale locale) { [EOL]     return format(new Date(millis), pattern, timeZone, locale); [EOL] }
public static String format(final long millis, final String pattern, final TimeZone timeZone, final Locale locale) { [EOL]     return format(new Date(millis), pattern, timeZone, locale); [EOL] }
public static String format(final long millis, final String pattern, final TimeZone timeZone, final Locale locale) { [EOL]     return format(new Date(millis), pattern, timeZone, locale); [EOL] }
public static String format(final long millis, final String pattern, final TimeZone timeZone, final Locale locale) { [EOL]     return format(new Date(millis), pattern, timeZone, locale); [EOL] }
@Override [EOL] public final void appendTo(final StringBuffer buffer, final int value) { [EOL]     if (value < 100) { [EOL]         for (int i = mSize; --i >= 2; ) { [EOL]             buffer.append('0'); [EOL]         } [EOL]         buffer.append((char) (value / 10 + '0')); [EOL]         buffer.append((char) (value % 10 + '0')); [EOL]     } else { [EOL]         int digits; [EOL]         if (value < 1000) { [EOL]             digits = 3; [EOL]         } else { [EOL]             Validate.isTrue(value > -1, "Negative values should not be possible", value); [EOL]             digits = Integer.toString(value).length(); [EOL]         } [EOL]         for (int i = mSize; --i >= digits; ) { [EOL]             buffer.append('0'); [EOL]         } [EOL]         buffer.append(Integer.toString(value)); [EOL]     } [EOL] }
@Override [EOL] public final void appendTo(final StringBuffer buffer, final int value) { [EOL]     if (value < 100) { [EOL]         for (int i = mSize; --i >= 2; ) { [EOL]             buffer.append('0'); [EOL]         } [EOL]         buffer.append((char) (value / 10 + '0')); [EOL]         buffer.append((char) (value % 10 + '0')); [EOL]     } else { [EOL]         int digits; [EOL]         if (value < 1000) { [EOL]             digits = 3; [EOL]         } else { [EOL]             Validate.isTrue(value > -1, "Negative values should not be possible", value); [EOL]             digits = Integer.toString(value).length(); [EOL]         } [EOL]         for (int i = mSize; --i >= digits; ) { [EOL]             buffer.append('0'); [EOL]         } [EOL]         buffer.append(Integer.toString(value)); [EOL]     } [EOL] }
@Override [EOL] public final void appendTo(final StringBuffer buffer, final int value) { [EOL]     if (value < 100) { [EOL]         for (int i = mSize; --i >= 2; ) { [EOL]             buffer.append('0'); [EOL]         } [EOL]         buffer.append((char) (value / 10 + '0')); [EOL]         buffer.append((char) (value % 10 + '0')); [EOL]     } else { [EOL]         int digits; [EOL]         if (value < 1000) { [EOL]             digits = 3; [EOL]         } else { [EOL]             Validate.isTrue(value > -1, "Negative values should not be possible", value); [EOL]             digits = Integer.toString(value).length(); [EOL]         } [EOL]         for (int i = mSize; --i >= digits; ) { [EOL]             buffer.append('0'); [EOL]         } [EOL]         buffer.append(Integer.toString(value)); [EOL]     } [EOL] }
@Override [EOL] public final void appendTo(final StringBuffer buffer, final int value) { [EOL]     if (value < 100) { [EOL]         for (int i = mSize; --i >= 2; ) { [EOL]             buffer.append('0'); [EOL]         } [EOL]         buffer.append((char) (value / 10 + '0')); [EOL]         buffer.append((char) (value % 10 + '0')); [EOL]     } else { [EOL]         int digits; [EOL]         if (value < 1000) { [EOL]             digits = 3; [EOL]         } else { [EOL]             Validate.isTrue(value > -1, "Negative values should not be possible", value); [EOL]             digits = Integer.toString(value).length(); [EOL]         } [EOL]         for (int i = mSize; --i >= digits; ) { [EOL]             buffer.append('0'); [EOL]         } [EOL]         buffer.append(Integer.toString(value)); [EOL]     } [EOL] }
@Override [EOL] public void appendTo(final StringBuffer buffer, final Calendar calendar) { [EOL]     int offset = calendar.get(Calendar.ZONE_OFFSET) + calendar.get(Calendar.DST_OFFSET); [EOL]     if (offset < 0) { [EOL]         buffer.append('-'); [EOL]         offset = -offset; [EOL]     } else { [EOL]         buffer.append('+'); [EOL]     } [EOL]     final int hours = offset / (60 * 60 * 1000); [EOL]     buffer.append((char) (hours / 10 + '0')); [EOL]     buffer.append((char) (hours % 10 + '0')); [EOL]     if (mColon) { [EOL]         buffer.append(':'); [EOL]     } [EOL]     final int minutes = offset / (60 * 1000) - 60 * hours; [EOL]     buffer.append((char) (minutes / 10 + '0')); [EOL]     buffer.append((char) (minutes % 10 + '0')); [EOL] }
@Override [EOL] public void appendTo(final StringBuffer buffer, final Calendar calendar) { [EOL]     int offset = calendar.get(Calendar.ZONE_OFFSET) + calendar.get(Calendar.DST_OFFSET); [EOL]     if (offset < 0) { [EOL]         buffer.append('-'); [EOL]         offset = -offset; [EOL]     } else { [EOL]         buffer.append('+'); [EOL]     } [EOL]     final int hours = offset / (60 * 60 * 1000); [EOL]     buffer.append((char) (hours / 10 + '0')); [EOL]     buffer.append((char) (hours % 10 + '0')); [EOL]     if (mColon) { [EOL]         buffer.append(':'); [EOL]     } [EOL]     final int minutes = offset / (60 * 1000) - 60 * hours; [EOL]     buffer.append((char) (minutes / 10 + '0')); [EOL]     buffer.append((char) (minutes % 10 + '0')); [EOL] }
@Override [EOL] public void appendTo(final StringBuffer buffer, final Calendar calendar) { [EOL]     int offset = calendar.get(Calendar.ZONE_OFFSET) + calendar.get(Calendar.DST_OFFSET); [EOL]     if (offset < 0) { [EOL]         buffer.append('-'); [EOL]         offset = -offset; [EOL]     } else { [EOL]         buffer.append('+'); [EOL]     } [EOL]     final int hours = offset / (60 * 60 * 1000); [EOL]     buffer.append((char) (hours / 10 + '0')); [EOL]     buffer.append((char) (hours % 10 + '0')); [EOL]     if (mColon) { [EOL]         buffer.append(':'); [EOL]     } [EOL]     final int minutes = offset / (60 * 1000) - 60 * hours; [EOL]     buffer.append((char) (minutes / 10 + '0')); [EOL]     buffer.append((char) (minutes % 10 + '0')); [EOL] }
@Override [EOL] public void appendTo(final StringBuffer buffer, final Calendar calendar) { [EOL]     int offset = calendar.get(Calendar.ZONE_OFFSET) + calendar.get(Calendar.DST_OFFSET); [EOL]     if (offset < 0) { [EOL]         buffer.append('-'); [EOL]         offset = -offset; [EOL]     } else { [EOL]         buffer.append('+'); [EOL]     } [EOL]     final int hours = offset / (60 * 60 * 1000); [EOL]     buffer.append((char) (hours / 10 + '0')); [EOL]     buffer.append((char) (hours % 10 + '0')); [EOL]     if (mColon) { [EOL]         buffer.append(':'); [EOL]     } [EOL]     final int minutes = offset / (60 * 1000) - 60 * hours; [EOL]     buffer.append((char) (minutes / 10 + '0')); [EOL]     buffer.append((char) (minutes % 10 + '0')); [EOL] }
public EqualsBuilder() { [EOL] }
public static boolean reflectionEquals(final Object lhs, final Object rhs, final String... excludeFields) { [EOL]     return reflectionEquals(lhs, rhs, false, null, excludeFields); [EOL] }
public static boolean reflectionEquals(final Object lhs, final Object rhs, final String... excludeFields) { [EOL]     return reflectionEquals(lhs, rhs, false, null, excludeFields); [EOL] }
public static boolean reflectionEquals(final Object lhs, final Object rhs, final String... excludeFields) { [EOL]     return reflectionEquals(lhs, rhs, false, null, excludeFields); [EOL] }
public static boolean reflectionEquals(final Object lhs, final Object rhs, final String... excludeFields) { [EOL]     return reflectionEquals(lhs, rhs, false, null, excludeFields); [EOL] }
public EqualsBuilder append(final Object lhs, final Object rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     final Class<?> lhsClass = lhs.getClass(); [EOL]     if (!lhsClass.isArray()) { [EOL]         isEquals = lhs.equals(rhs); [EOL]     } else if (lhs.getClass() != rhs.getClass()) { [EOL]         this.setEquals(false); [EOL]     } else if (lhs instanceof long[]) { [EOL]         append((long[]) lhs, (long[]) rhs); [EOL]     } else if (lhs instanceof int[]) { [EOL]         append((int[]) lhs, (int[]) rhs); [EOL]     } else if (lhs instanceof short[]) { [EOL]         append((short[]) lhs, (short[]) rhs); [EOL]     } else if (lhs instanceof char[]) { [EOL]         append((char[]) lhs, (char[]) rhs); [EOL]     } else if (lhs instanceof byte[]) { [EOL]         append((byte[]) lhs, (byte[]) rhs); [EOL]     } else if (lhs instanceof double[]) { [EOL]         append((double[]) lhs, (double[]) rhs); [EOL]     } else if (lhs instanceof float[]) { [EOL]         append((float[]) lhs, (float[]) rhs); [EOL]     } else if (lhs instanceof boolean[]) { [EOL]         append((boolean[]) lhs, (boolean[]) rhs); [EOL]     } else { [EOL]         append((Object[]) lhs, (Object[]) rhs); [EOL]     } [EOL]     return this; [EOL] }
public EqualsBuilder append(final Object lhs, final Object rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     final Class<?> lhsClass = lhs.getClass(); [EOL]     if (!lhsClass.isArray()) { [EOL]         isEquals = lhs.equals(rhs); [EOL]     } else if (lhs.getClass() != rhs.getClass()) { [EOL]         this.setEquals(false); [EOL]     } else if (lhs instanceof long[]) { [EOL]         append((long[]) lhs, (long[]) rhs); [EOL]     } else if (lhs instanceof int[]) { [EOL]         append((int[]) lhs, (int[]) rhs); [EOL]     } else if (lhs instanceof short[]) { [EOL]         append((short[]) lhs, (short[]) rhs); [EOL]     } else if (lhs instanceof char[]) { [EOL]         append((char[]) lhs, (char[]) rhs); [EOL]     } else if (lhs instanceof byte[]) { [EOL]         append((byte[]) lhs, (byte[]) rhs); [EOL]     } else if (lhs instanceof double[]) { [EOL]         append((double[]) lhs, (double[]) rhs); [EOL]     } else if (lhs instanceof float[]) { [EOL]         append((float[]) lhs, (float[]) rhs); [EOL]     } else if (lhs instanceof boolean[]) { [EOL]         append((boolean[]) lhs, (boolean[]) rhs); [EOL]     } else { [EOL]         append((Object[]) lhs, (Object[]) rhs); [EOL]     } [EOL]     return this; [EOL] }
public EqualsBuilder append(final Object lhs, final Object rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     final Class<?> lhsClass = lhs.getClass(); [EOL]     if (!lhsClass.isArray()) { [EOL]         isEquals = lhs.equals(rhs); [EOL]     } else if (lhs.getClass() != rhs.getClass()) { [EOL]         this.setEquals(false); [EOL]     } else if (lhs instanceof long[]) { [EOL]         append((long[]) lhs, (long[]) rhs); [EOL]     } else if (lhs instanceof int[]) { [EOL]         append((int[]) lhs, (int[]) rhs); [EOL]     } else if (lhs instanceof short[]) { [EOL]         append((short[]) lhs, (short[]) rhs); [EOL]     } else if (lhs instanceof char[]) { [EOL]         append((char[]) lhs, (char[]) rhs); [EOL]     } else if (lhs instanceof byte[]) { [EOL]         append((byte[]) lhs, (byte[]) rhs); [EOL]     } else if (lhs instanceof double[]) { [EOL]         append((double[]) lhs, (double[]) rhs); [EOL]     } else if (lhs instanceof float[]) { [EOL]         append((float[]) lhs, (float[]) rhs); [EOL]     } else if (lhs instanceof boolean[]) { [EOL]         append((boolean[]) lhs, (boolean[]) rhs); [EOL]     } else { [EOL]         append((Object[]) lhs, (Object[]) rhs); [EOL]     } [EOL]     return this; [EOL] }
public EqualsBuilder append(final Object lhs, final Object rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     final Class<?> lhsClass = lhs.getClass(); [EOL]     if (!lhsClass.isArray()) { [EOL]         isEquals = lhs.equals(rhs); [EOL]     } else if (lhs.getClass() != rhs.getClass()) { [EOL]         this.setEquals(false); [EOL]     } else if (lhs instanceof long[]) { [EOL]         append((long[]) lhs, (long[]) rhs); [EOL]     } else if (lhs instanceof int[]) { [EOL]         append((int[]) lhs, (int[]) rhs); [EOL]     } else if (lhs instanceof short[]) { [EOL]         append((short[]) lhs, (short[]) rhs); [EOL]     } else if (lhs instanceof char[]) { [EOL]         append((char[]) lhs, (char[]) rhs); [EOL]     } else if (lhs instanceof byte[]) { [EOL]         append((byte[]) lhs, (byte[]) rhs); [EOL]     } else if (lhs instanceof double[]) { [EOL]         append((double[]) lhs, (double[]) rhs); [EOL]     } else if (lhs instanceof float[]) { [EOL]         append((float[]) lhs, (float[]) rhs); [EOL]     } else if (lhs instanceof boolean[]) { [EOL]         append((boolean[]) lhs, (boolean[]) rhs); [EOL]     } else { [EOL]         append((Object[]) lhs, (Object[]) rhs); [EOL]     } [EOL]     return this; [EOL] }
public EqualsBuilder append(final Object lhs, final Object rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     final Class<?> lhsClass = lhs.getClass(); [EOL]     if (!lhsClass.isArray()) { [EOL]         isEquals = lhs.equals(rhs); [EOL]     } else if (lhs.getClass() != rhs.getClass()) { [EOL]         this.setEquals(false); [EOL]     } else if (lhs instanceof long[]) { [EOL]         append((long[]) lhs, (long[]) rhs); [EOL]     } else if (lhs instanceof int[]) { [EOL]         append((int[]) lhs, (int[]) rhs); [EOL]     } else if (lhs instanceof short[]) { [EOL]         append((short[]) lhs, (short[]) rhs); [EOL]     } else if (lhs instanceof char[]) { [EOL]         append((char[]) lhs, (char[]) rhs); [EOL]     } else if (lhs instanceof byte[]) { [EOL]         append((byte[]) lhs, (byte[]) rhs); [EOL]     } else if (lhs instanceof double[]) { [EOL]         append((double[]) lhs, (double[]) rhs); [EOL]     } else if (lhs instanceof float[]) { [EOL]         append((float[]) lhs, (float[]) rhs); [EOL]     } else if (lhs instanceof boolean[]) { [EOL]         append((boolean[]) lhs, (boolean[]) rhs); [EOL]     } else { [EOL]         append((Object[]) lhs, (Object[]) rhs); [EOL]     } [EOL]     return this; [EOL] }
public EqualsBuilder append(final Object lhs, final Object rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     final Class<?> lhsClass = lhs.getClass(); [EOL]     if (!lhsClass.isArray()) { [EOL]         isEquals = lhs.equals(rhs); [EOL]     } else if (lhs.getClass() != rhs.getClass()) { [EOL]         this.setEquals(false); [EOL]     } else if (lhs instanceof long[]) { [EOL]         append((long[]) lhs, (long[]) rhs); [EOL]     } else if (lhs instanceof int[]) { [EOL]         append((int[]) lhs, (int[]) rhs); [EOL]     } else if (lhs instanceof short[]) { [EOL]         append((short[]) lhs, (short[]) rhs); [EOL]     } else if (lhs instanceof char[]) { [EOL]         append((char[]) lhs, (char[]) rhs); [EOL]     } else if (lhs instanceof byte[]) { [EOL]         append((byte[]) lhs, (byte[]) rhs); [EOL]     } else if (lhs instanceof double[]) { [EOL]         append((double[]) lhs, (double[]) rhs); [EOL]     } else if (lhs instanceof float[]) { [EOL]         append((float[]) lhs, (float[]) rhs); [EOL]     } else if (lhs instanceof boolean[]) { [EOL]         append((boolean[]) lhs, (boolean[]) rhs); [EOL]     } else { [EOL]         append((Object[]) lhs, (Object[]) rhs); [EOL]     } [EOL]     return this; [EOL] }
public EqualsBuilder append(final Object lhs, final Object rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     final Class<?> lhsClass = lhs.getClass(); [EOL]     if (!lhsClass.isArray()) { [EOL]         isEquals = lhs.equals(rhs); [EOL]     } else if (lhs.getClass() != rhs.getClass()) { [EOL]         this.setEquals(false); [EOL]     } else if (lhs instanceof long[]) { [EOL]         append((long[]) lhs, (long[]) rhs); [EOL]     } else if (lhs instanceof int[]) { [EOL]         append((int[]) lhs, (int[]) rhs); [EOL]     } else if (lhs instanceof short[]) { [EOL]         append((short[]) lhs, (short[]) rhs); [EOL]     } else if (lhs instanceof char[]) { [EOL]         append((char[]) lhs, (char[]) rhs); [EOL]     } else if (lhs instanceof byte[]) { [EOL]         append((byte[]) lhs, (byte[]) rhs); [EOL]     } else if (lhs instanceof double[]) { [EOL]         append((double[]) lhs, (double[]) rhs); [EOL]     } else if (lhs instanceof float[]) { [EOL]         append((float[]) lhs, (float[]) rhs); [EOL]     } else if (lhs instanceof boolean[]) { [EOL]         append((boolean[]) lhs, (boolean[]) rhs); [EOL]     } else { [EOL]         append((Object[]) lhs, (Object[]) rhs); [EOL]     } [EOL]     return this; [EOL] }
public EqualsBuilder append(final Object lhs, final Object rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     final Class<?> lhsClass = lhs.getClass(); [EOL]     if (!lhsClass.isArray()) { [EOL]         isEquals = lhs.equals(rhs); [EOL]     } else if (lhs.getClass() != rhs.getClass()) { [EOL]         this.setEquals(false); [EOL]     } else if (lhs instanceof long[]) { [EOL]         append((long[]) lhs, (long[]) rhs); [EOL]     } else if (lhs instanceof int[]) { [EOL]         append((int[]) lhs, (int[]) rhs); [EOL]     } else if (lhs instanceof short[]) { [EOL]         append((short[]) lhs, (short[]) rhs); [EOL]     } else if (lhs instanceof char[]) { [EOL]         append((char[]) lhs, (char[]) rhs); [EOL]     } else if (lhs instanceof byte[]) { [EOL]         append((byte[]) lhs, (byte[]) rhs); [EOL]     } else if (lhs instanceof double[]) { [EOL]         append((double[]) lhs, (double[]) rhs); [EOL]     } else if (lhs instanceof float[]) { [EOL]         append((float[]) lhs, (float[]) rhs); [EOL]     } else if (lhs instanceof boolean[]) { [EOL]         append((boolean[]) lhs, (boolean[]) rhs); [EOL]     } else { [EOL]         append((Object[]) lhs, (Object[]) rhs); [EOL]     } [EOL]     return this; [EOL] }
public EqualsBuilder append(final Object lhs, final Object rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     final Class<?> lhsClass = lhs.getClass(); [EOL]     if (!lhsClass.isArray()) { [EOL]         isEquals = lhs.equals(rhs); [EOL]     } else if (lhs.getClass() != rhs.getClass()) { [EOL]         this.setEquals(false); [EOL]     } else if (lhs instanceof long[]) { [EOL]         append((long[]) lhs, (long[]) rhs); [EOL]     } else if (lhs instanceof int[]) { [EOL]         append((int[]) lhs, (int[]) rhs); [EOL]     } else if (lhs instanceof short[]) { [EOL]         append((short[]) lhs, (short[]) rhs); [EOL]     } else if (lhs instanceof char[]) { [EOL]         append((char[]) lhs, (char[]) rhs); [EOL]     } else if (lhs instanceof byte[]) { [EOL]         append((byte[]) lhs, (byte[]) rhs); [EOL]     } else if (lhs instanceof double[]) { [EOL]         append((double[]) lhs, (double[]) rhs); [EOL]     } else if (lhs instanceof float[]) { [EOL]         append((float[]) lhs, (float[]) rhs); [EOL]     } else if (lhs instanceof boolean[]) { [EOL]         append((boolean[]) lhs, (boolean[]) rhs); [EOL]     } else { [EOL]         append((Object[]) lhs, (Object[]) rhs); [EOL]     } [EOL]     return this; [EOL] }
public EqualsBuilder append(final Object lhs, final Object rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     final Class<?> lhsClass = lhs.getClass(); [EOL]     if (!lhsClass.isArray()) { [EOL]         isEquals = lhs.equals(rhs); [EOL]     } else if (lhs.getClass() != rhs.getClass()) { [EOL]         this.setEquals(false); [EOL]     } else if (lhs instanceof long[]) { [EOL]         append((long[]) lhs, (long[]) rhs); [EOL]     } else if (lhs instanceof int[]) { [EOL]         append((int[]) lhs, (int[]) rhs); [EOL]     } else if (lhs instanceof short[]) { [EOL]         append((short[]) lhs, (short[]) rhs); [EOL]     } else if (lhs instanceof char[]) { [EOL]         append((char[]) lhs, (char[]) rhs); [EOL]     } else if (lhs instanceof byte[]) { [EOL]         append((byte[]) lhs, (byte[]) rhs); [EOL]     } else if (lhs instanceof double[]) { [EOL]         append((double[]) lhs, (double[]) rhs); [EOL]     } else if (lhs instanceof float[]) { [EOL]         append((float[]) lhs, (float[]) rhs); [EOL]     } else if (lhs instanceof boolean[]) { [EOL]         append((boolean[]) lhs, (boolean[]) rhs); [EOL]     } else { [EOL]         append((Object[]) lhs, (Object[]) rhs); [EOL]     } [EOL]     return this; [EOL] }
public EqualsBuilder append(final Object lhs, final Object rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     final Class<?> lhsClass = lhs.getClass(); [EOL]     if (!lhsClass.isArray()) { [EOL]         isEquals = lhs.equals(rhs); [EOL]     } else if (lhs.getClass() != rhs.getClass()) { [EOL]         this.setEquals(false); [EOL]     } else if (lhs instanceof long[]) { [EOL]         append((long[]) lhs, (long[]) rhs); [EOL]     } else if (lhs instanceof int[]) { [EOL]         append((int[]) lhs, (int[]) rhs); [EOL]     } else if (lhs instanceof short[]) { [EOL]         append((short[]) lhs, (short[]) rhs); [EOL]     } else if (lhs instanceof char[]) { [EOL]         append((char[]) lhs, (char[]) rhs); [EOL]     } else if (lhs instanceof byte[]) { [EOL]         append((byte[]) lhs, (byte[]) rhs); [EOL]     } else if (lhs instanceof double[]) { [EOL]         append((double[]) lhs, (double[]) rhs); [EOL]     } else if (lhs instanceof float[]) { [EOL]         append((float[]) lhs, (float[]) rhs); [EOL]     } else if (lhs instanceof boolean[]) { [EOL]         append((boolean[]) lhs, (boolean[]) rhs); [EOL]     } else { [EOL]         append((Object[]) lhs, (Object[]) rhs); [EOL]     } [EOL]     return this; [EOL] }
public EqualsBuilder append(final Object lhs, final Object rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     final Class<?> lhsClass = lhs.getClass(); [EOL]     if (!lhsClass.isArray()) { [EOL]         isEquals = lhs.equals(rhs); [EOL]     } else if (lhs.getClass() != rhs.getClass()) { [EOL]         this.setEquals(false); [EOL]     } else if (lhs instanceof long[]) { [EOL]         append((long[]) lhs, (long[]) rhs); [EOL]     } else if (lhs instanceof int[]) { [EOL]         append((int[]) lhs, (int[]) rhs); [EOL]     } else if (lhs instanceof short[]) { [EOL]         append((short[]) lhs, (short[]) rhs); [EOL]     } else if (lhs instanceof char[]) { [EOL]         append((char[]) lhs, (char[]) rhs); [EOL]     } else if (lhs instanceof byte[]) { [EOL]         append((byte[]) lhs, (byte[]) rhs); [EOL]     } else if (lhs instanceof double[]) { [EOL]         append((double[]) lhs, (double[]) rhs); [EOL]     } else if (lhs instanceof float[]) { [EOL]         append((float[]) lhs, (float[]) rhs); [EOL]     } else if (lhs instanceof boolean[]) { [EOL]         append((boolean[]) lhs, (boolean[]) rhs); [EOL]     } else { [EOL]         append((Object[]) lhs, (Object[]) rhs); [EOL]     } [EOL]     return this; [EOL] }
public EqualsBuilder append(final Object lhs, final Object rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     final Class<?> lhsClass = lhs.getClass(); [EOL]     if (!lhsClass.isArray()) { [EOL]         isEquals = lhs.equals(rhs); [EOL]     } else if (lhs.getClass() != rhs.getClass()) { [EOL]         this.setEquals(false); [EOL]     } else if (lhs instanceof long[]) { [EOL]         append((long[]) lhs, (long[]) rhs); [EOL]     } else if (lhs instanceof int[]) { [EOL]         append((int[]) lhs, (int[]) rhs); [EOL]     } else if (lhs instanceof short[]) { [EOL]         append((short[]) lhs, (short[]) rhs); [EOL]     } else if (lhs instanceof char[]) { [EOL]         append((char[]) lhs, (char[]) rhs); [EOL]     } else if (lhs instanceof byte[]) { [EOL]         append((byte[]) lhs, (byte[]) rhs); [EOL]     } else if (lhs instanceof double[]) { [EOL]         append((double[]) lhs, (double[]) rhs); [EOL]     } else if (lhs instanceof float[]) { [EOL]         append((float[]) lhs, (float[]) rhs); [EOL]     } else if (lhs instanceof boolean[]) { [EOL]         append((boolean[]) lhs, (boolean[]) rhs); [EOL]     } else { [EOL]         append((Object[]) lhs, (Object[]) rhs); [EOL]     } [EOL]     return this; [EOL] }
public EqualsBuilder append(final Object lhs, final Object rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     final Class<?> lhsClass = lhs.getClass(); [EOL]     if (!lhsClass.isArray()) { [EOL]         isEquals = lhs.equals(rhs); [EOL]     } else if (lhs.getClass() != rhs.getClass()) { [EOL]         this.setEquals(false); [EOL]     } else if (lhs instanceof long[]) { [EOL]         append((long[]) lhs, (long[]) rhs); [EOL]     } else if (lhs instanceof int[]) { [EOL]         append((int[]) lhs, (int[]) rhs); [EOL]     } else if (lhs instanceof short[]) { [EOL]         append((short[]) lhs, (short[]) rhs); [EOL]     } else if (lhs instanceof char[]) { [EOL]         append((char[]) lhs, (char[]) rhs); [EOL]     } else if (lhs instanceof byte[]) { [EOL]         append((byte[]) lhs, (byte[]) rhs); [EOL]     } else if (lhs instanceof double[]) { [EOL]         append((double[]) lhs, (double[]) rhs); [EOL]     } else if (lhs instanceof float[]) { [EOL]         append((float[]) lhs, (float[]) rhs); [EOL]     } else if (lhs instanceof boolean[]) { [EOL]         append((boolean[]) lhs, (boolean[]) rhs); [EOL]     } else { [EOL]         append((Object[]) lhs, (Object[]) rhs); [EOL]     } [EOL]     return this; [EOL] }
public EqualsBuilder append(final long lhs, final long rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     isEquals = (lhs == rhs); [EOL]     return this; [EOL] }
public EqualsBuilder append(final long lhs, final long rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     isEquals = (lhs == rhs); [EOL]     return this; [EOL] }
public EqualsBuilder append(final long lhs, final long rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     isEquals = (lhs == rhs); [EOL]     return this; [EOL] }
public EqualsBuilder append(final double lhs, final double rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     return append(Double.doubleToLongBits(lhs), Double.doubleToLongBits(rhs)); [EOL] }
public EqualsBuilder append(final double lhs, final double rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     return append(Double.doubleToLongBits(lhs), Double.doubleToLongBits(rhs)); [EOL] }
public EqualsBuilder append(final float lhs, final float rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     return append(Float.floatToIntBits(lhs), Float.floatToIntBits(rhs)); [EOL] }
public EqualsBuilder append(final float lhs, final float rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     return append(Float.floatToIntBits(lhs), Float.floatToIntBits(rhs)); [EOL] }
public EqualsBuilder append(final double[] lhs, final double[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public EqualsBuilder append(final double[] lhs, final double[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public EqualsBuilder append(final double[] lhs, final double[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public EqualsBuilder append(final double[] lhs, final double[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public EqualsBuilder append(final double[] lhs, final double[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public EqualsBuilder append(final double[] lhs, final double[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public EqualsBuilder append(final double[] lhs, final double[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public EqualsBuilder append(final double[] lhs, final double[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public EqualsBuilder append(final float[] lhs, final float[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public EqualsBuilder append(final float[] lhs, final float[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public EqualsBuilder append(final float[] lhs, final float[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public EqualsBuilder append(final float[] lhs, final float[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public EqualsBuilder append(final float[] lhs, final float[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public EqualsBuilder append(final float[] lhs, final float[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public boolean isEquals() { [EOL]     return this.isEquals; [EOL] }
public boolean isEquals() { [EOL]     return this.isEquals; [EOL] }
protected void setEquals(final boolean isEquals) { [EOL]     this.isEquals = isEquals; [EOL] }
public static StrMatcher singleQuoteMatcher() { [EOL]     return SINGLE_QUOTE_MATCHER; [EOL] }
public static String randomAscii(final int count) { [EOL]     return random(count, 32, 127, false, false); [EOL] }
public static String randomAscii(final int count) { [EOL]     return random(count, 32, 127, false, false); [EOL] }
public static String randomAlphabetic(final int count) { [EOL]     return random(count, true, false); [EOL] }
public static String randomAlphabetic(final int count) { [EOL]     return random(count, true, false); [EOL] }
public static String randomAlphabetic(final int count) { [EOL]     return random(count, true, false); [EOL] }
public static String randomAlphanumeric(final int count) { [EOL]     return random(count, true, true); [EOL] }
public static String randomAlphanumeric(final int count) { [EOL]     return random(count, true, true); [EOL] }
public static String randomNumeric(final int count) { [EOL]     return random(count, false, true); [EOL] }
public static String randomNumeric(final int count) { [EOL]     return random(count, false, true); [EOL] }
public static String random(int count, int start, int end, final boolean letters, final boolean numbers, final char[] chars, final Random random) { [EOL]     if (count == 0) { [EOL]         return ""; [EOL]     } else if (count < 0) { [EOL]         throw new IllegalArgumentException("Requested random string length " + count + " is less than 0."); [EOL]     } [EOL]     if (chars != null && chars.length == 0) { [EOL]         throw new IllegalArgumentException("The chars array must not be empty"); [EOL]     } [EOL]     if (start == 0 && end == 0) { [EOL]         if (chars != null) { [EOL]             end = chars.length; [EOL]         } else { [EOL]             if (!letters && !numbers) { [EOL]                 end = Integer.MAX_VALUE; [EOL]             } else { [EOL]                 end = 'z' + 1; [EOL]                 start = ' '; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (end <= start) { [EOL]             throw new IllegalArgumentException("Parameter end (" + end + ") must be greater than start (" + start + ")"); [EOL]         } [EOL]     } [EOL]     final char[] buffer = new char[count]; [EOL]     final int gap = end - start; [EOL]     while (count-- != 0) { [EOL]         char ch; [EOL]         if (chars == null) { [EOL]             ch = (char) (random.nextInt(gap) + start); [EOL]         } else { [EOL]             ch = chars[random.nextInt(gap) + start]; [EOL]         } [EOL]         if (letters && Character.isLetter(ch) || numbers && Character.isDigit(ch) || !letters && !numbers) { [EOL]             if (ch >= 56320 && ch <= 57343) { [EOL]                 if (count == 0) { [EOL]                     count++; [EOL]                 } else { [EOL]                     buffer[count] = ch; [EOL]                     count--; [EOL]                     buffer[count] = (char) (55296 + random.nextInt(128)); [EOL]                 } [EOL]             } else if (ch >= 55296 && ch <= 56191) { [EOL]                 if (count == 0) { [EOL]                     count++; [EOL]                 } else { [EOL]                     buffer[count] = (char) (56320 + random.nextInt(128)); [EOL]                     count--; [EOL]                     buffer[count] = ch; [EOL]                 } [EOL]             } else if (ch >= 56192 && ch <= 56319) { [EOL]                 count++; [EOL]             } else { [EOL]                 buffer[count] = ch; [EOL]             } [EOL]         } else { [EOL]             count++; [EOL]         } [EOL]     } [EOL]     return new String(buffer); [EOL] }
public static String random(final int count, final char... chars) { [EOL]     if (chars == null) { [EOL]         return random(count, 0, 0, false, false, null, RANDOM); [EOL]     } [EOL]     return random(count, 0, chars.length, false, false, chars, RANDOM); [EOL] }
public static String random(final int count, final char... chars) { [EOL]     if (chars == null) { [EOL]         return random(count, 0, 0, false, false, null, RANDOM); [EOL]     } [EOL]     return random(count, 0, chars.length, false, false, chars, RANDOM); [EOL] }
public static String random(final int count, final char... chars) { [EOL]     if (chars == null) { [EOL]         return random(count, 0, 0, false, false, null, RANDOM); [EOL]     } [EOL]     return random(count, 0, chars.length, false, false, chars, RANDOM); [EOL] }
public MutableByte(final Number value) { [EOL]     super(); [EOL]     this.value = value.byteValue(); [EOL] }
public MutableByte(final Number value) { [EOL]     super(); [EOL]     this.value = value.byteValue(); [EOL] }
public MutableByte(final Number value) { [EOL]     super(); [EOL]     this.value = value.byteValue(); [EOL] }
public MutableByte(final Number value) { [EOL]     super(); [EOL]     this.value = value.byteValue(); [EOL] }
public MutableByte(final Number value) { [EOL]     super(); [EOL]     this.value = value.byteValue(); [EOL] }
public MutableByte(final Number value) { [EOL]     super(); [EOL]     this.value = value.byteValue(); [EOL] }
public MutableByte(final Number value) { [EOL]     super(); [EOL]     this.value = value.byteValue(); [EOL] }
public void add(final Number operand) { [EOL]     this.value += operand.byteValue(); [EOL] }
public void subtract(final byte operand) { [EOL]     this.value -= operand; [EOL] }
@Override [EOL] public float floatValue() { [EOL]     return value; [EOL] }
@Override [EOL] public float floatValue() { [EOL]     return value; [EOL] }
@Override [EOL] public float floatValue() { [EOL]     return value; [EOL] }
@Override [EOL] public double doubleValue() { [EOL]     return value; [EOL] }
@Override [EOL] public double doubleValue() { [EOL]     return value; [EOL] }
@Override [EOL] public double doubleValue() { [EOL]     return value; [EOL] }
public Byte toByte() { [EOL]     return Byte.valueOf(byteValue()); [EOL] }
public Byte toByte() { [EOL]     return Byte.valueOf(byteValue()); [EOL] }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj instanceof MutableByte) { [EOL]         return value == ((MutableByte) obj).byteValue(); [EOL]     } [EOL]     return false; [EOL] }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj instanceof MutableByte) { [EOL]         return value == ((MutableByte) obj).byteValue(); [EOL]     } [EOL]     return false; [EOL] }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj instanceof MutableByte) { [EOL]         return value == ((MutableByte) obj).byteValue(); [EOL]     } [EOL]     return false; [EOL] }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj instanceof MutableByte) { [EOL]         return value == ((MutableByte) obj).byteValue(); [EOL]     } [EOL]     return false; [EOL] }
public final String translate(final CharSequence input) { [EOL]     if (input == null) { [EOL]         return null; [EOL]     } [EOL]     try { [EOL]         final StringWriter writer = new StringWriter(input.length() * 2); [EOL]         translate(input, writer); [EOL]         return writer.toString(); [EOL]     } catch (final IOException ioe) { [EOL]         throw new RuntimeException(ioe); [EOL]     } [EOL] }
public final String translate(final CharSequence input) { [EOL]     if (input == null) { [EOL]         return null; [EOL]     } [EOL]     try { [EOL]         final StringWriter writer = new StringWriter(input.length() * 2); [EOL]         translate(input, writer); [EOL]         return writer.toString(); [EOL]     } catch (final IOException ioe) { [EOL]         throw new RuntimeException(ioe); [EOL]     } [EOL] }
public final String translate(final CharSequence input) { [EOL]     if (input == null) { [EOL]         return null; [EOL]     } [EOL]     try { [EOL]         final StringWriter writer = new StringWriter(input.length() * 2); [EOL]         translate(input, writer); [EOL]         return writer.toString(); [EOL]     } catch (final IOException ioe) { [EOL]         throw new RuntimeException(ioe); [EOL]     } [EOL] }
public final String translate(final CharSequence input) { [EOL]     if (input == null) { [EOL]         return null; [EOL]     } [EOL]     try { [EOL]         final StringWriter writer = new StringWriter(input.length() * 2); [EOL]         translate(input, writer); [EOL]         return writer.toString(); [EOL]     } catch (final IOException ioe) { [EOL]         throw new RuntimeException(ioe); [EOL]     } [EOL] }
public final void translate(final CharSequence input, final Writer out) throws IOException { [EOL]     if (out == null) { [EOL]         throw new IllegalArgumentException("The Writer must not be null"); [EOL]     } [EOL]     if (input == null) { [EOL]         return; [EOL]     } [EOL]     int pos = 0; [EOL]     final int len = input.length(); [EOL]     while (pos < len) { [EOL]         final int consumed = translate(input, pos, out); [EOL]         if (consumed == 0) { [EOL]             final char[] c = Character.toChars(Character.codePointAt(input, pos)); [EOL]             out.write(c); [EOL]             pos += c.length; [EOL]             continue; [EOL]         } [EOL]         for (int pt = 0; pt < consumed; pt++) { [EOL]             pos += Character.charCount(Character.codePointAt(input, pt)); [EOL]         } [EOL]     } [EOL] }
public final void translate(final CharSequence input, final Writer out) throws IOException { [EOL]     if (out == null) { [EOL]         throw new IllegalArgumentException("The Writer must not be null"); [EOL]     } [EOL]     if (input == null) { [EOL]         return; [EOL]     } [EOL]     int pos = 0; [EOL]     final int len = input.length(); [EOL]     while (pos < len) { [EOL]         final int consumed = translate(input, pos, out); [EOL]         if (consumed == 0) { [EOL]             final char[] c = Character.toChars(Character.codePointAt(input, pos)); [EOL]             out.write(c); [EOL]             pos += c.length; [EOL]             continue; [EOL]         } [EOL]         for (int pt = 0; pt < consumed; pt++) { [EOL]             pos += Character.charCount(Character.codePointAt(input, pt)); [EOL]         } [EOL]     } [EOL] }
public final void translate(final CharSequence input, final Writer out) throws IOException { [EOL]     if (out == null) { [EOL]         throw new IllegalArgumentException("The Writer must not be null"); [EOL]     } [EOL]     if (input == null) { [EOL]         return; [EOL]     } [EOL]     int pos = 0; [EOL]     final int len = input.length(); [EOL]     while (pos < len) { [EOL]         final int consumed = translate(input, pos, out); [EOL]         if (consumed == 0) { [EOL]             final char[] c = Character.toChars(Character.codePointAt(input, pos)); [EOL]             out.write(c); [EOL]             pos += c.length; [EOL]             continue; [EOL]         } [EOL]         for (int pt = 0; pt < consumed; pt++) { [EOL]             pos += Character.charCount(Character.codePointAt(input, pt)); [EOL]         } [EOL]     } [EOL] }
public final void translate(final CharSequence input, final Writer out) throws IOException { [EOL]     if (out == null) { [EOL]         throw new IllegalArgumentException("The Writer must not be null"); [EOL]     } [EOL]     if (input == null) { [EOL]         return; [EOL]     } [EOL]     int pos = 0; [EOL]     final int len = input.length(); [EOL]     while (pos < len) { [EOL]         final int consumed = translate(input, pos, out); [EOL]         if (consumed == 0) { [EOL]             final char[] c = Character.toChars(Character.codePointAt(input, pos)); [EOL]             out.write(c); [EOL]             pos += c.length; [EOL]             continue; [EOL]         } [EOL]         for (int pt = 0; pt < consumed; pt++) { [EOL]             pos += Character.charCount(Character.codePointAt(input, pt)); [EOL]         } [EOL]     } [EOL] }
public final void translate(final CharSequence input, final Writer out) throws IOException { [EOL]     if (out == null) { [EOL]         throw new IllegalArgumentException("The Writer must not be null"); [EOL]     } [EOL]     if (input == null) { [EOL]         return; [EOL]     } [EOL]     int pos = 0; [EOL]     final int len = input.length(); [EOL]     while (pos < len) { [EOL]         final int consumed = translate(input, pos, out); [EOL]         if (consumed == 0) { [EOL]             final char[] c = Character.toChars(Character.codePointAt(input, pos)); [EOL]             out.write(c); [EOL]             pos += c.length; [EOL]             continue; [EOL]         } [EOL]         for (int pt = 0; pt < consumed; pt++) { [EOL]             pos += Character.charCount(Character.codePointAt(input, pt)); [EOL]         } [EOL]     } [EOL] }
public final void translate(final CharSequence input, final Writer out) throws IOException { [EOL]     if (out == null) { [EOL]         throw new IllegalArgumentException("The Writer must not be null"); [EOL]     } [EOL]     if (input == null) { [EOL]         return; [EOL]     } [EOL]     int pos = 0; [EOL]     final int len = input.length(); [EOL]     while (pos < len) { [EOL]         final int consumed = translate(input, pos, out); [EOL]         if (consumed == 0) { [EOL]             final char[] c = Character.toChars(Character.codePointAt(input, pos)); [EOL]             out.write(c); [EOL]             pos += c.length; [EOL]             continue; [EOL]         } [EOL]         for (int pt = 0; pt < consumed; pt++) { [EOL]             pos += Character.charCount(Character.codePointAt(input, pt)); [EOL]         } [EOL]     } [EOL] }
public static Formatter append(final CharSequence seq, final Formatter formatter, final int flags, final int width, final int precision) { [EOL]     return append(seq, formatter, flags, width, precision, ' ', null); [EOL] }
public static Formatter append(final CharSequence seq, final Formatter formatter, final int flags, final int width, final int precision, final char padChar, final CharSequence ellipsis) { [EOL]     Validate.isTrue(ellipsis == null || precision < 0 || ellipsis.length() <= precision, "Specified ellipsis '%1$s' exceeds precision of %2$s", ellipsis, Integer.valueOf(precision)); [EOL]     final StringBuilder buf = new StringBuilder(seq); [EOL]     if (precision >= 0 && precision < seq.length()) { [EOL]         final CharSequence _ellipsis = ObjectUtils.defaultIfNull(ellipsis, StringUtils.EMPTY); [EOL]         buf.replace(precision - _ellipsis.length(), seq.length(), _ellipsis.toString()); [EOL]     } [EOL]     final boolean leftJustify = (flags & LEFT_JUSTIFY) == LEFT_JUSTIFY; [EOL]     for (int i = buf.length(); i < width; i++) { [EOL]         buf.insert(leftJustify ? i : 0, padChar); [EOL]     } [EOL]     formatter.format(buf.toString()); [EOL]     return formatter; [EOL] }
public static Formatter append(final CharSequence seq, final Formatter formatter, final int flags, final int width, final int precision, final char padChar, final CharSequence ellipsis) { [EOL]     Validate.isTrue(ellipsis == null || precision < 0 || ellipsis.length() <= precision, "Specified ellipsis '%1$s' exceeds precision of %2$s", ellipsis, Integer.valueOf(precision)); [EOL]     final StringBuilder buf = new StringBuilder(seq); [EOL]     if (precision >= 0 && precision < seq.length()) { [EOL]         final CharSequence _ellipsis = ObjectUtils.defaultIfNull(ellipsis, StringUtils.EMPTY); [EOL]         buf.replace(precision - _ellipsis.length(), seq.length(), _ellipsis.toString()); [EOL]     } [EOL]     final boolean leftJustify = (flags & LEFT_JUSTIFY) == LEFT_JUSTIFY; [EOL]     for (int i = buf.length(); i < width; i++) { [EOL]         buf.insert(leftJustify ? i : 0, padChar); [EOL]     } [EOL]     formatter.format(buf.toString()); [EOL]     return formatter; [EOL] }
public static Formatter append(final CharSequence seq, final Formatter formatter, final int flags, final int width, final int precision, final char padChar, final CharSequence ellipsis) { [EOL]     Validate.isTrue(ellipsis == null || precision < 0 || ellipsis.length() <= precision, "Specified ellipsis '%1$s' exceeds precision of %2$s", ellipsis, Integer.valueOf(precision)); [EOL]     final StringBuilder buf = new StringBuilder(seq); [EOL]     if (precision >= 0 && precision < seq.length()) { [EOL]         final CharSequence _ellipsis = ObjectUtils.defaultIfNull(ellipsis, StringUtils.EMPTY); [EOL]         buf.replace(precision - _ellipsis.length(), seq.length(), _ellipsis.toString()); [EOL]     } [EOL]     final boolean leftJustify = (flags & LEFT_JUSTIFY) == LEFT_JUSTIFY; [EOL]     for (int i = buf.length(); i < width; i++) { [EOL]         buf.insert(leftJustify ? i : 0, padChar); [EOL]     } [EOL]     formatter.format(buf.toString()); [EOL]     return formatter; [EOL] }
public static Formatter append(final CharSequence seq, final Formatter formatter, final int flags, final int width, final int precision, final char padChar, final CharSequence ellipsis) { [EOL]     Validate.isTrue(ellipsis == null || precision < 0 || ellipsis.length() <= precision, "Specified ellipsis '%1$s' exceeds precision of %2$s", ellipsis, Integer.valueOf(precision)); [EOL]     final StringBuilder buf = new StringBuilder(seq); [EOL]     if (precision >= 0 && precision < seq.length()) { [EOL]         final CharSequence _ellipsis = ObjectUtils.defaultIfNull(ellipsis, StringUtils.EMPTY); [EOL]         buf.replace(precision - _ellipsis.length(), seq.length(), _ellipsis.toString()); [EOL]     } [EOL]     final boolean leftJustify = (flags & LEFT_JUSTIFY) == LEFT_JUSTIFY; [EOL]     for (int i = buf.length(); i < width; i++) { [EOL]         buf.insert(leftJustify ? i : 0, padChar); [EOL]     } [EOL]     formatter.format(buf.toString()); [EOL]     return formatter; [EOL] }
public static Formatter append(final CharSequence seq, final Formatter formatter, final int flags, final int width, final int precision, final char padChar, final CharSequence ellipsis) { [EOL]     Validate.isTrue(ellipsis == null || precision < 0 || ellipsis.length() <= precision, "Specified ellipsis '%1$s' exceeds precision of %2$s", ellipsis, Integer.valueOf(precision)); [EOL]     final StringBuilder buf = new StringBuilder(seq); [EOL]     if (precision >= 0 && precision < seq.length()) { [EOL]         final CharSequence _ellipsis = ObjectUtils.defaultIfNull(ellipsis, StringUtils.EMPTY); [EOL]         buf.replace(precision - _ellipsis.length(), seq.length(), _ellipsis.toString()); [EOL]     } [EOL]     final boolean leftJustify = (flags & LEFT_JUSTIFY) == LEFT_JUSTIFY; [EOL]     for (int i = buf.length(); i < width; i++) { [EOL]         buf.insert(leftJustify ? i : 0, padChar); [EOL]     } [EOL]     formatter.format(buf.toString()); [EOL]     return formatter; [EOL] }
public static <E extends Enum<E>> E getEnum(final Class<E> enumClass, final String enumName) { [EOL]     if (enumName == null) { [EOL]         return null; [EOL]     } [EOL]     try { [EOL]         return Enum.valueOf(enumClass, enumName); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]         return null; [EOL]     } [EOL] }
public static <E extends Enum<E>> E getEnum(final Class<E> enumClass, final String enumName) { [EOL]     if (enumName == null) { [EOL]         return null; [EOL]     } [EOL]     try { [EOL]         return Enum.valueOf(enumClass, enumName); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]         return null; [EOL]     } [EOL] }
public static <E extends Enum<E>> E getEnum(final Class<E> enumClass, final String enumName) { [EOL]     if (enumName == null) { [EOL]         return null; [EOL]     } [EOL]     try { [EOL]         return Enum.valueOf(enumClass, enumName); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]         return null; [EOL]     } [EOL] }
public F getInstance(final String pattern, TimeZone timeZone, Locale locale) { [EOL]     if (pattern == null) { [EOL]         throw new NullPointerException("pattern must not be null"); [EOL]     } [EOL]     if (timeZone == null) { [EOL]         timeZone = TimeZone.getDefault(); [EOL]     } [EOL]     if (locale == null) { [EOL]         locale = Locale.getDefault(); [EOL]     } [EOL]     final MultipartKey key = new MultipartKey(pattern, timeZone, locale); [EOL]     F format = cInstanceCache.get(key); [EOL]     if (format == null) { [EOL]         format = createInstance(pattern, timeZone, locale); [EOL]         final F previousValue = cInstanceCache.putIfAbsent(key, format); [EOL]         if (previousValue != null) { [EOL]             format = previousValue; [EOL]         } [EOL]     } [EOL]     return format; [EOL] }
public F getInstance(final String pattern, TimeZone timeZone, Locale locale) { [EOL]     if (pattern == null) { [EOL]         throw new NullPointerException("pattern must not be null"); [EOL]     } [EOL]     if (timeZone == null) { [EOL]         timeZone = TimeZone.getDefault(); [EOL]     } [EOL]     if (locale == null) { [EOL]         locale = Locale.getDefault(); [EOL]     } [EOL]     final MultipartKey key = new MultipartKey(pattern, timeZone, locale); [EOL]     F format = cInstanceCache.get(key); [EOL]     if (format == null) { [EOL]         format = createInstance(pattern, timeZone, locale); [EOL]         final F previousValue = cInstanceCache.putIfAbsent(key, format); [EOL]         if (previousValue != null) { [EOL]             format = previousValue; [EOL]         } [EOL]     } [EOL]     return format; [EOL] }
public F getInstance(final String pattern, TimeZone timeZone, Locale locale) { [EOL]     if (pattern == null) { [EOL]         throw new NullPointerException("pattern must not be null"); [EOL]     } [EOL]     if (timeZone == null) { [EOL]         timeZone = TimeZone.getDefault(); [EOL]     } [EOL]     if (locale == null) { [EOL]         locale = Locale.getDefault(); [EOL]     } [EOL]     final MultipartKey key = new MultipartKey(pattern, timeZone, locale); [EOL]     F format = cInstanceCache.get(key); [EOL]     if (format == null) { [EOL]         format = createInstance(pattern, timeZone, locale); [EOL]         final F previousValue = cInstanceCache.putIfAbsent(key, format); [EOL]         if (previousValue != null) { [EOL]             format = previousValue; [EOL]         } [EOL]     } [EOL]     return format; [EOL] }
public F getInstance(final String pattern, TimeZone timeZone, Locale locale) { [EOL]     if (pattern == null) { [EOL]         throw new NullPointerException("pattern must not be null"); [EOL]     } [EOL]     if (timeZone == null) { [EOL]         timeZone = TimeZone.getDefault(); [EOL]     } [EOL]     if (locale == null) { [EOL]         locale = Locale.getDefault(); [EOL]     } [EOL]     final MultipartKey key = new MultipartKey(pattern, timeZone, locale); [EOL]     F format = cInstanceCache.get(key); [EOL]     if (format == null) { [EOL]         format = createInstance(pattern, timeZone, locale); [EOL]         final F previousValue = cInstanceCache.putIfAbsent(key, format); [EOL]         if (previousValue != null) { [EOL]             format = previousValue; [EOL]         } [EOL]     } [EOL]     return format; [EOL] }
public F getInstance(final String pattern, TimeZone timeZone, Locale locale) { [EOL]     if (pattern == null) { [EOL]         throw new NullPointerException("pattern must not be null"); [EOL]     } [EOL]     if (timeZone == null) { [EOL]         timeZone = TimeZone.getDefault(); [EOL]     } [EOL]     if (locale == null) { [EOL]         locale = Locale.getDefault(); [EOL]     } [EOL]     final MultipartKey key = new MultipartKey(pattern, timeZone, locale); [EOL]     F format = cInstanceCache.get(key); [EOL]     if (format == null) { [EOL]         format = createInstance(pattern, timeZone, locale); [EOL]         final F previousValue = cInstanceCache.putIfAbsent(key, format); [EOL]         if (previousValue != null) { [EOL]             format = previousValue; [EOL]         } [EOL]     } [EOL]     return format; [EOL] }
@Override [EOL] public int hashCode() { [EOL]     return (getLeft() == null ? 0 : getLeft().hashCode()) ^ (getMiddle() == null ? 0 : getMiddle().hashCode()) ^ (getRight() == null ? 0 : getRight().hashCode()); [EOL] }
@Override [EOL] public int hashCode() { [EOL]     return (getLeft() == null ? 0 : getLeft().hashCode()) ^ (getMiddle() == null ? 0 : getMiddle().hashCode()) ^ (getRight() == null ? 0 : getRight().hashCode()); [EOL] }
@Override [EOL] public int hashCode() { [EOL]     return (getLeft() == null ? 0 : getLeft().hashCode()) ^ (getMiddle() == null ? 0 : getMiddle().hashCode()) ^ (getRight() == null ? 0 : getRight().hashCode()); [EOL] }
@Override [EOL] public int hashCode() { [EOL]     return (getLeft() == null ? 0 : getLeft().hashCode()) ^ (getMiddle() == null ? 0 : getMiddle().hashCode()) ^ (getRight() == null ? 0 : getRight().hashCode()); [EOL] }
@Override [EOL] public int hashCode() { [EOL]     return (getLeft() == null ? 0 : getLeft().hashCode()) ^ (getMiddle() == null ? 0 : getMiddle().hashCode()) ^ (getRight() == null ? 0 : getRight().hashCode()); [EOL] }
public ToStringBuilder append(final long[] array) { [EOL]     style.append(buffer, null, array, null); [EOL]     return this; [EOL] }
public ToStringBuilder append(final long[] array) { [EOL]     style.append(buffer, null, array, null); [EOL]     return this; [EOL] }
public ToStringBuilder append(final String fieldName, final Object obj) { [EOL]     style.append(buffer, fieldName, obj, null); [EOL]     return this; [EOL] }
public ToStringBuilder append(final String fieldName, final Object obj) { [EOL]     style.append(buffer, fieldName, obj, null); [EOL]     return this; [EOL] }
public ToStringBuilder append(final String fieldName, final Object obj) { [EOL]     style.append(buffer, fieldName, obj, null); [EOL]     return this; [EOL] }
@Override [EOL] public String toString() { [EOL]     if (this.getObject() == null) { [EOL]         this.getStringBuffer().append(this.getStyle().getNullText()); [EOL]     } else { [EOL]         style.appendEnd(this.getStringBuffer(), this.getObject()); [EOL]     } [EOL]     return this.getStringBuffer().toString(); [EOL] }
@Override [EOL] public String toString() { [EOL]     if (this.getObject() == null) { [EOL]         this.getStringBuffer().append(this.getStyle().getNullText()); [EOL]     } else { [EOL]         style.appendEnd(this.getStringBuffer(), this.getObject()); [EOL]     } [EOL]     return this.getStringBuffer().toString(); [EOL] }
public static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2) { [EOL]     if (cal1 == null || cal2 == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) && cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) && cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) && cal1.get(Calendar.HOUR_OF_DAY) == cal2.get(Calendar.HOUR_OF_DAY) && cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) && cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) && cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) && cal1.getClass() == cal2.getClass()); [EOL] } public DateUtils();  DateIterator(final Calendar startFinal, final Calendar endFinal); public static boolean isSameDay(final Date date1, final Date date2); public static boolean isSameDay(final Calendar cal1, final Calendar cal2); public static boolean isSameInstant(final Date date1, final Date date2); public static boolean isSameInstant(final Calendar cal1, final Calendar cal2); public static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2); public static Date parseDate(final String str, final String... parsePatterns) throws ParseException; public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException; private static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException; public static Date addYears(final Date date, final int amount); public static Date addMonths(final Date date, final int amount); public static Date addWeeks(final Date date, final int amount); public static Date addDays(final Date date, final int amount); public static Date addHours(final Date date, final int amount); public static Date addMinutes(final Date date, final int amount); public static Date addSeconds(final Date date, final int amount); public static Date addMilliseconds(final Date date, final int amount); private static Date add(final Date date, final int calendarField, final int amount); public static Date setYears(final Date date, final int amount); public static Date setMonths(final Date date, final int amount); public static Date setDays(final Date date, final int amount); public static Date setHours(final Date date, final int amount); public static Date setMinutes(final Date date, final int amount); public static Date setSeconds(final Date date, final int amount); public static Date setMilliseconds(final Date date, final int amount); private static Date set(final Date date, final int calendarField, final int amount); public static Calendar toCalendar(final Date date); public static Date round(final Date date, final int field); public static Calendar round(final Calendar date, final int field); public static Date round(final Object date, final int field); public static Date truncate(final Date date, final int field); public static Calendar truncate(final Calendar date, final int field); public static Date truncate(final Object date, final int field); public static Date ceiling(final Date date, final int field); public static Calendar ceiling(final Calendar date, final int field); public static Date ceiling(final Object date, final int field); private static void modify(final Calendar val, final int field, final int modType); public static Iterator<Calendar> iterator(final Date focus, final int rangeStyle); public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle); public static Iterator<?> iterator(final Object focus, final int rangeStyle); public static long getFragmentInMilliseconds(final Date date, final int fragment); public static long getFragmentInSeconds(final Date date, final int fragment); public static long getFragmentInMinutes(final Date date, final int fragment); public static long getFragmentInHours(final Date date, final int fragment); public static long getFragmentInDays(final Date date, final int fragment); public static long getFragmentInMilliseconds(final Calendar calendar, final int fragment); public static long getFragmentInSeconds(final Calendar calendar, final int fragment); public static long getFragmentInMinutes(final Calendar calendar, final int fragment); public static long getFragmentInHours(final Calendar calendar, final int fragment); public static long getFragmentInDays(final Calendar calendar, final int fragment); private static long getFragment(final Date date, final int fragment, final int unit); private static long getFragment(final Calendar calendar, final int fragment, final int unit); public static boolean truncatedEquals(final Calendar cal1, final Calendar cal2, final int field); public static boolean truncatedEquals(final Date date1, final Date date2, final int field); public static int truncatedCompareTo(final Calendar cal1, final Calendar cal2, final int field); public static int truncatedCompareTo(final Date date1, final Date date2, final int field); private static long getMillisPerUnit(final int unit); public boolean hasNext(); public Calendar next(); public void remove(); long MILLIS_PER_SECOND=Optional[1000]; long MILLIS_PER_MINUTE=Optional[60 * MILLIS_PER_SECOND]; long MILLIS_PER_HOUR=Optional[60 * MILLIS_PER_MINUTE]; long MILLIS_PER_DAY=Optional[24 * MILLIS_PER_HOUR]; int SEMI_MONTH=Optional[1001]; int[][] fields=Optional[{ { Calendar.MILLISECOND }, { Calendar.SECOND }, { Calendar.MINUTE }, { Calendar.HOUR_OF_DAY, Calendar.HOUR }, { Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM /* Calendar.DAY_OF_YEAR, Calendar.DAY_OF_WEEK, Calendar.DAY_OF_WEEK_IN_MONTH */; }, { Calendar.MONTH, DateUtils.SEMI_MONTH }, { Calendar.YEAR }, { Calendar.ERA } }
private static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException { [EOL]     if (str == null || parsePatterns == null) { [EOL]         throw new IllegalArgumentException("Date and Patterns must not be null"); [EOL]     } [EOL]     SimpleDateFormat parser; [EOL]     if (locale == null) { [EOL]         parser = new SimpleDateFormat(); [EOL]     } else { [EOL]         parser = new SimpleDateFormat("", locale); [EOL]     } [EOL]     parser.setLenient(lenient); [EOL]     final ParsePosition pos = new ParsePosition(0); [EOL]     for (final String parsePattern : parsePatterns) { [EOL]         String pattern = parsePattern; [EOL]         if (parsePattern.endsWith("ZZ")) { [EOL]             pattern = pattern.substring(0, pattern.length() - 1); [EOL]         } [EOL]         parser.applyPattern(pattern); [EOL]         pos.setIndex(0); [EOL]         String str2 = str; [EOL]         if (parsePattern.endsWith("ZZ")) { [EOL]             str2 = str.replaceAll("([-+][0-9][0-9]):([0-9][0-9])$", "$1$2"); [EOL]         } [EOL]         final Date date = parser.parse(str2, pos); [EOL]         if (date != null && pos.getIndex() == str2.length()) { [EOL]             return date; [EOL]         } [EOL]     } [EOL]     throw new ParseException("Unable to parse the date: " + str, -1); [EOL] } public DateUtils();  DateIterator(final Calendar startFinal, final Calendar endFinal); public static boolean isSameDay(final Date date1, final Date date2); public static boolean isSameDay(final Calendar cal1, final Calendar cal2); public static boolean isSameInstant(final Date date1, final Date date2); public static boolean isSameInstant(final Calendar cal1, final Calendar cal2); public static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2); public static Date parseDate(final String str, final String... parsePatterns) throws ParseException; public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException; private static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException; public static Date addYears(final Date date, final int amount); public static Date addMonths(final Date date, final int amount); public static Date addWeeks(final Date date, final int amount); public static Date addDays(final Date date, final int amount); public static Date addHours(final Date date, final int amount); public static Date addMinutes(final Date date, final int amount); public static Date addSeconds(final Date date, final int amount); public static Date addMilliseconds(final Date date, final int amount); private static Date add(final Date date, final int calendarField, final int amount); public static Date setYears(final Date date, final int amount); public static Date setMonths(final Date date, final int amount); public static Date setDays(final Date date, final int amount); public static Date setHours(final Date date, final int amount); public static Date setMinutes(final Date date, final int amount); public static Date setSeconds(final Date date, final int amount); public static Date setMilliseconds(final Date date, final int amount); private static Date set(final Date date, final int calendarField, final int amount); public static Calendar toCalendar(final Date date); public static Date round(final Date date, final int field); public static Calendar round(final Calendar date, final int field); public static Date round(final Object date, final int field); public static Date truncate(final Date date, final int field); public static Calendar truncate(final Calendar date, final int field); public static Date truncate(final Object date, final int field); public static Date ceiling(final Date date, final int field); public static Calendar ceiling(final Calendar date, final int field); public static Date ceiling(final Object date, final int field); private static void modify(final Calendar val, final int field, final int modType); public static Iterator<Calendar> iterator(final Date focus, final int rangeStyle); public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle); public static Iterator<?> iterator(final Object focus, final int rangeStyle); public static long getFragmentInMilliseconds(final Date date, final int fragment); public static long getFragmentInSeconds(final Date date, final int fragment); public static long getFragmentInMinutes(final Date date, final int fragment); public static long getFragmentInHours(final Date date, final int fragment); public static long getFragmentInDays(final Date date, final int fragment); public static long getFragmentInMilliseconds(final Calendar calendar, final int fragment); public static long getFragmentInSeconds(final Calendar calendar, final int fragment); public static long getFragmentInMinutes(final Calendar calendar, final int fragment); public static long getFragmentInHours(final Calendar calendar, final int fragment); public static long getFragmentInDays(final Calendar calendar, final int fragment); private static long getFragment(final Date date, final int fragment, final int unit); private static long getFragment(final Calendar calendar, final int fragment, final int unit); public static boolean truncatedEquals(final Calendar cal1, final Calendar cal2, final int field); public static boolean truncatedEquals(final Date date1, final Date date2, final int field); public static int truncatedCompareTo(final Calendar cal1, final Calendar cal2, final int field); public static int truncatedCompareTo(final Date date1, final Date date2, final int field); private static long getMillisPerUnit(final int unit); public boolean hasNext(); public Calendar next(); public void remove(); long MILLIS_PER_SECOND=Optional[1000]; long MILLIS_PER_MINUTE=Optional[60 * MILLIS_PER_SECOND]; long MILLIS_PER_HOUR=Optional[60 * MILLIS_PER_MINUTE]; long MILLIS_PER_DAY=Optional[24 * MILLIS_PER_HOUR]; int SEMI_MONTH=Optional[1001]; int[][] fields=Optional[{ { Calendar.MILLISECOND }, { Calendar.SECOND }, { Calendar.MINUTE }, { Calendar.HOUR_OF_DAY, Calendar.HOUR }, { Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM /* Calendar.DAY_OF_YEAR, Calendar.DAY_OF_WEEK, Calendar.DAY_OF_WEEK_IN_MONTH */; }, { Calendar.MONTH, DateUtils.SEMI_MONTH }, { Calendar.YEAR }, { Calendar.ERA } }
public static Date addYears(final Date date, final int amount) { [EOL]     return add(date, Calendar.YEAR, amount); [EOL] } public DateUtils();  DateIterator(final Calendar startFinal, final Calendar endFinal); public static boolean isSameDay(final Date date1, final Date date2); public static boolean isSameDay(final Calendar cal1, final Calendar cal2); public static boolean isSameInstant(final Date date1, final Date date2); public static boolean isSameInstant(final Calendar cal1, final Calendar cal2); public static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2); public static Date parseDate(final String str, final String... parsePatterns) throws ParseException; public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException; private static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException; public static Date addYears(final Date date, final int amount); public static Date addMonths(final Date date, final int amount); public static Date addWeeks(final Date date, final int amount); public static Date addDays(final Date date, final int amount); public static Date addHours(final Date date, final int amount); public static Date addMinutes(final Date date, final int amount); public static Date addSeconds(final Date date, final int amount); public static Date addMilliseconds(final Date date, final int amount); private static Date add(final Date date, final int calendarField, final int amount); public static Date setYears(final Date date, final int amount); public static Date setMonths(final Date date, final int amount); public static Date setDays(final Date date, final int amount); public static Date setHours(final Date date, final int amount); public static Date setMinutes(final Date date, final int amount); public static Date setSeconds(final Date date, final int amount); public static Date setMilliseconds(final Date date, final int amount); private static Date set(final Date date, final int calendarField, final int amount); public static Calendar toCalendar(final Date date); public static Date round(final Date date, final int field); public static Calendar round(final Calendar date, final int field); public static Date round(final Object date, final int field); public static Date truncate(final Date date, final int field); public static Calendar truncate(final Calendar date, final int field); public static Date truncate(final Object date, final int field); public static Date ceiling(final Date date, final int field); public static Calendar ceiling(final Calendar date, final int field); public static Date ceiling(final Object date, final int field); private static void modify(final Calendar val, final int field, final int modType); public static Iterator<Calendar> iterator(final Date focus, final int rangeStyle); public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle); public static Iterator<?> iterator(final Object focus, final int rangeStyle); public static long getFragmentInMilliseconds(final Date date, final int fragment); public static long getFragmentInSeconds(final Date date, final int fragment); public static long getFragmentInMinutes(final Date date, final int fragment); public static long getFragmentInHours(final Date date, final int fragment); public static long getFragmentInDays(final Date date, final int fragment); public static long getFragmentInMilliseconds(final Calendar calendar, final int fragment); public static long getFragmentInSeconds(final Calendar calendar, final int fragment); public static long getFragmentInMinutes(final Calendar calendar, final int fragment); public static long getFragmentInHours(final Calendar calendar, final int fragment); public static long getFragmentInDays(final Calendar calendar, final int fragment); private static long getFragment(final Date date, final int fragment, final int unit); private static long getFragment(final Calendar calendar, final int fragment, final int unit); public static boolean truncatedEquals(final Calendar cal1, final Calendar cal2, final int field); public static boolean truncatedEquals(final Date date1, final Date date2, final int field); public static int truncatedCompareTo(final Calendar cal1, final Calendar cal2, final int field); public static int truncatedCompareTo(final Date date1, final Date date2, final int field); private static long getMillisPerUnit(final int unit); public boolean hasNext(); public Calendar next(); public void remove(); long MILLIS_PER_SECOND=Optional[1000]; long MILLIS_PER_MINUTE=Optional[60 * MILLIS_PER_SECOND]; long MILLIS_PER_HOUR=Optional[60 * MILLIS_PER_MINUTE]; long MILLIS_PER_DAY=Optional[24 * MILLIS_PER_HOUR]; int SEMI_MONTH=Optional[1001]; int[][] fields=Optional[{ { Calendar.MILLISECOND }, { Calendar.SECOND }, { Calendar.MINUTE }, { Calendar.HOUR_OF_DAY, Calendar.HOUR }, { Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM /* Calendar.DAY_OF_YEAR, Calendar.DAY_OF_WEEK, Calendar.DAY_OF_WEEK_IN_MONTH */; }, { Calendar.MONTH, DateUtils.SEMI_MONTH }, { Calendar.YEAR }, { Calendar.ERA } }
public static Date addMinutes(final Date date, final int amount) { [EOL]     return add(date, Calendar.MINUTE, amount); [EOL] } public DateUtils();  DateIterator(final Calendar startFinal, final Calendar endFinal); public static boolean isSameDay(final Date date1, final Date date2); public static boolean isSameDay(final Calendar cal1, final Calendar cal2); public static boolean isSameInstant(final Date date1, final Date date2); public static boolean isSameInstant(final Calendar cal1, final Calendar cal2); public static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2); public static Date parseDate(final String str, final String... parsePatterns) throws ParseException; public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException; private static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException; public static Date addYears(final Date date, final int amount); public static Date addMonths(final Date date, final int amount); public static Date addWeeks(final Date date, final int amount); public static Date addDays(final Date date, final int amount); public static Date addHours(final Date date, final int amount); public static Date addMinutes(final Date date, final int amount); public static Date addSeconds(final Date date, final int amount); public static Date addMilliseconds(final Date date, final int amount); private static Date add(final Date date, final int calendarField, final int amount); public static Date setYears(final Date date, final int amount); public static Date setMonths(final Date date, final int amount); public static Date setDays(final Date date, final int amount); public static Date setHours(final Date date, final int amount); public static Date setMinutes(final Date date, final int amount); public static Date setSeconds(final Date date, final int amount); public static Date setMilliseconds(final Date date, final int amount); private static Date set(final Date date, final int calendarField, final int amount); public static Calendar toCalendar(final Date date); public static Date round(final Date date, final int field); public static Calendar round(final Calendar date, final int field); public static Date round(final Object date, final int field); public static Date truncate(final Date date, final int field); public static Calendar truncate(final Calendar date, final int field); public static Date truncate(final Object date, final int field); public static Date ceiling(final Date date, final int field); public static Calendar ceiling(final Calendar date, final int field); public static Date ceiling(final Object date, final int field); private static void modify(final Calendar val, final int field, final int modType); public static Iterator<Calendar> iterator(final Date focus, final int rangeStyle); public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle); public static Iterator<?> iterator(final Object focus, final int rangeStyle); public static long getFragmentInMilliseconds(final Date date, final int fragment); public static long getFragmentInSeconds(final Date date, final int fragment); public static long getFragmentInMinutes(final Date date, final int fragment); public static long getFragmentInHours(final Date date, final int fragment); public static long getFragmentInDays(final Date date, final int fragment); public static long getFragmentInMilliseconds(final Calendar calendar, final int fragment); public static long getFragmentInSeconds(final Calendar calendar, final int fragment); public static long getFragmentInMinutes(final Calendar calendar, final int fragment); public static long getFragmentInHours(final Calendar calendar, final int fragment); public static long getFragmentInDays(final Calendar calendar, final int fragment); private static long getFragment(final Date date, final int fragment, final int unit); private static long getFragment(final Calendar calendar, final int fragment, final int unit); public static boolean truncatedEquals(final Calendar cal1, final Calendar cal2, final int field); public static boolean truncatedEquals(final Date date1, final Date date2, final int field); public static int truncatedCompareTo(final Calendar cal1, final Calendar cal2, final int field); public static int truncatedCompareTo(final Date date1, final Date date2, final int field); private static long getMillisPerUnit(final int unit); public boolean hasNext(); public Calendar next(); public void remove(); long MILLIS_PER_SECOND=Optional[1000]; long MILLIS_PER_MINUTE=Optional[60 * MILLIS_PER_SECOND]; long MILLIS_PER_HOUR=Optional[60 * MILLIS_PER_MINUTE]; long MILLIS_PER_DAY=Optional[24 * MILLIS_PER_HOUR]; int SEMI_MONTH=Optional[1001]; int[][] fields=Optional[{ { Calendar.MILLISECOND }, { Calendar.SECOND }, { Calendar.MINUTE }, { Calendar.HOUR_OF_DAY, Calendar.HOUR }, { Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM /* Calendar.DAY_OF_YEAR, Calendar.DAY_OF_WEEK, Calendar.DAY_OF_WEEK_IN_MONTH */; }, { Calendar.MONTH, DateUtils.SEMI_MONTH }, { Calendar.YEAR }, { Calendar.ERA } }
public static Date addSeconds(final Date date, final int amount) { [EOL]     return add(date, Calendar.SECOND, amount); [EOL] } public DateUtils();  DateIterator(final Calendar startFinal, final Calendar endFinal); public static boolean isSameDay(final Date date1, final Date date2); public static boolean isSameDay(final Calendar cal1, final Calendar cal2); public static boolean isSameInstant(final Date date1, final Date date2); public static boolean isSameInstant(final Calendar cal1, final Calendar cal2); public static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2); public static Date parseDate(final String str, final String... parsePatterns) throws ParseException; public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException; private static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException; public static Date addYears(final Date date, final int amount); public static Date addMonths(final Date date, final int amount); public static Date addWeeks(final Date date, final int amount); public static Date addDays(final Date date, final int amount); public static Date addHours(final Date date, final int amount); public static Date addMinutes(final Date date, final int amount); public static Date addSeconds(final Date date, final int amount); public static Date addMilliseconds(final Date date, final int amount); private static Date add(final Date date, final int calendarField, final int amount); public static Date setYears(final Date date, final int amount); public static Date setMonths(final Date date, final int amount); public static Date setDays(final Date date, final int amount); public static Date setHours(final Date date, final int amount); public static Date setMinutes(final Date date, final int amount); public static Date setSeconds(final Date date, final int amount); public static Date setMilliseconds(final Date date, final int amount); private static Date set(final Date date, final int calendarField, final int amount); public static Calendar toCalendar(final Date date); public static Date round(final Date date, final int field); public static Calendar round(final Calendar date, final int field); public static Date round(final Object date, final int field); public static Date truncate(final Date date, final int field); public static Calendar truncate(final Calendar date, final int field); public static Date truncate(final Object date, final int field); public static Date ceiling(final Date date, final int field); public static Calendar ceiling(final Calendar date, final int field); public static Date ceiling(final Object date, final int field); private static void modify(final Calendar val, final int field, final int modType); public static Iterator<Calendar> iterator(final Date focus, final int rangeStyle); public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle); public static Iterator<?> iterator(final Object focus, final int rangeStyle); public static long getFragmentInMilliseconds(final Date date, final int fragment); public static long getFragmentInSeconds(final Date date, final int fragment); public static long getFragmentInMinutes(final Date date, final int fragment); public static long getFragmentInHours(final Date date, final int fragment); public static long getFragmentInDays(final Date date, final int fragment); public static long getFragmentInMilliseconds(final Calendar calendar, final int fragment); public static long getFragmentInSeconds(final Calendar calendar, final int fragment); public static long getFragmentInMinutes(final Calendar calendar, final int fragment); public static long getFragmentInHours(final Calendar calendar, final int fragment); public static long getFragmentInDays(final Calendar calendar, final int fragment); private static long getFragment(final Date date, final int fragment, final int unit); private static long getFragment(final Calendar calendar, final int fragment, final int unit); public static boolean truncatedEquals(final Calendar cal1, final Calendar cal2, final int field); public static boolean truncatedEquals(final Date date1, final Date date2, final int field); public static int truncatedCompareTo(final Calendar cal1, final Calendar cal2, final int field); public static int truncatedCompareTo(final Date date1, final Date date2, final int field); private static long getMillisPerUnit(final int unit); public boolean hasNext(); public Calendar next(); public void remove(); long MILLIS_PER_SECOND=Optional[1000]; long MILLIS_PER_MINUTE=Optional[60 * MILLIS_PER_SECOND]; long MILLIS_PER_HOUR=Optional[60 * MILLIS_PER_MINUTE]; long MILLIS_PER_DAY=Optional[24 * MILLIS_PER_HOUR]; int SEMI_MONTH=Optional[1001]; int[][] fields=Optional[{ { Calendar.MILLISECOND }, { Calendar.SECOND }, { Calendar.MINUTE }, { Calendar.HOUR_OF_DAY, Calendar.HOUR }, { Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM /* Calendar.DAY_OF_YEAR, Calendar.DAY_OF_WEEK, Calendar.DAY_OF_WEEK_IN_MONTH */; }, { Calendar.MONTH, DateUtils.SEMI_MONTH }, { Calendar.YEAR }, { Calendar.ERA } }
public static Date setYears(final Date date, final int amount) { [EOL]     return set(date, Calendar.YEAR, amount); [EOL] } public DateUtils();  DateIterator(final Calendar startFinal, final Calendar endFinal); public static boolean isSameDay(final Date date1, final Date date2); public static boolean isSameDay(final Calendar cal1, final Calendar cal2); public static boolean isSameInstant(final Date date1, final Date date2); public static boolean isSameInstant(final Calendar cal1, final Calendar cal2); public static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2); public static Date parseDate(final String str, final String... parsePatterns) throws ParseException; public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException; private static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException; public static Date addYears(final Date date, final int amount); public static Date addMonths(final Date date, final int amount); public static Date addWeeks(final Date date, final int amount); public static Date addDays(final Date date, final int amount); public static Date addHours(final Date date, final int amount); public static Date addMinutes(final Date date, final int amount); public static Date addSeconds(final Date date, final int amount); public static Date addMilliseconds(final Date date, final int amount); private static Date add(final Date date, final int calendarField, final int amount); public static Date setYears(final Date date, final int amount); public static Date setMonths(final Date date, final int amount); public static Date setDays(final Date date, final int amount); public static Date setHours(final Date date, final int amount); public static Date setMinutes(final Date date, final int amount); public static Date setSeconds(final Date date, final int amount); public static Date setMilliseconds(final Date date, final int amount); private static Date set(final Date date, final int calendarField, final int amount); public static Calendar toCalendar(final Date date); public static Date round(final Date date, final int field); public static Calendar round(final Calendar date, final int field); public static Date round(final Object date, final int field); public static Date truncate(final Date date, final int field); public static Calendar truncate(final Calendar date, final int field); public static Date truncate(final Object date, final int field); public static Date ceiling(final Date date, final int field); public static Calendar ceiling(final Calendar date, final int field); public static Date ceiling(final Object date, final int field); private static void modify(final Calendar val, final int field, final int modType); public static Iterator<Calendar> iterator(final Date focus, final int rangeStyle); public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle); public static Iterator<?> iterator(final Object focus, final int rangeStyle); public static long getFragmentInMilliseconds(final Date date, final int fragment); public static long getFragmentInSeconds(final Date date, final int fragment); public static long getFragmentInMinutes(final Date date, final int fragment); public static long getFragmentInHours(final Date date, final int fragment); public static long getFragmentInDays(final Date date, final int fragment); public static long getFragmentInMilliseconds(final Calendar calendar, final int fragment); public static long getFragmentInSeconds(final Calendar calendar, final int fragment); public static long getFragmentInMinutes(final Calendar calendar, final int fragment); public static long getFragmentInHours(final Calendar calendar, final int fragment); public static long getFragmentInDays(final Calendar calendar, final int fragment); private static long getFragment(final Date date, final int fragment, final int unit); private static long getFragment(final Calendar calendar, final int fragment, final int unit); public static boolean truncatedEquals(final Calendar cal1, final Calendar cal2, final int field); public static boolean truncatedEquals(final Date date1, final Date date2, final int field); public static int truncatedCompareTo(final Calendar cal1, final Calendar cal2, final int field); public static int truncatedCompareTo(final Date date1, final Date date2, final int field); private static long getMillisPerUnit(final int unit); public boolean hasNext(); public Calendar next(); public void remove(); long MILLIS_PER_SECOND=Optional[1000]; long MILLIS_PER_MINUTE=Optional[60 * MILLIS_PER_SECOND]; long MILLIS_PER_HOUR=Optional[60 * MILLIS_PER_MINUTE]; long MILLIS_PER_DAY=Optional[24 * MILLIS_PER_HOUR]; int SEMI_MONTH=Optional[1001]; int[][] fields=Optional[{ { Calendar.MILLISECOND }, { Calendar.SECOND }, { Calendar.MINUTE }, { Calendar.HOUR_OF_DAY, Calendar.HOUR }, { Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM /* Calendar.DAY_OF_YEAR, Calendar.DAY_OF_WEEK, Calendar.DAY_OF_WEEK_IN_MONTH */; }, { Calendar.MONTH, DateUtils.SEMI_MONTH }, { Calendar.YEAR }, { Calendar.ERA } }
public static Date setHours(final Date date, final int amount) { [EOL]     return set(date, Calendar.HOUR_OF_DAY, amount); [EOL] } public DateUtils();  DateIterator(final Calendar startFinal, final Calendar endFinal); public static boolean isSameDay(final Date date1, final Date date2); public static boolean isSameDay(final Calendar cal1, final Calendar cal2); public static boolean isSameInstant(final Date date1, final Date date2); public static boolean isSameInstant(final Calendar cal1, final Calendar cal2); public static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2); public static Date parseDate(final String str, final String... parsePatterns) throws ParseException; public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException; private static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException; public static Date addYears(final Date date, final int amount); public static Date addMonths(final Date date, final int amount); public static Date addWeeks(final Date date, final int amount); public static Date addDays(final Date date, final int amount); public static Date addHours(final Date date, final int amount); public static Date addMinutes(final Date date, final int amount); public static Date addSeconds(final Date date, final int amount); public static Date addMilliseconds(final Date date, final int amount); private static Date add(final Date date, final int calendarField, final int amount); public static Date setYears(final Date date, final int amount); public static Date setMonths(final Date date, final int amount); public static Date setDays(final Date date, final int amount); public static Date setHours(final Date date, final int amount); public static Date setMinutes(final Date date, final int amount); public static Date setSeconds(final Date date, final int amount); public static Date setMilliseconds(final Date date, final int amount); private static Date set(final Date date, final int calendarField, final int amount); public static Calendar toCalendar(final Date date); public static Date round(final Date date, final int field); public static Calendar round(final Calendar date, final int field); public static Date round(final Object date, final int field); public static Date truncate(final Date date, final int field); public static Calendar truncate(final Calendar date, final int field); public static Date truncate(final Object date, final int field); public static Date ceiling(final Date date, final int field); public static Calendar ceiling(final Calendar date, final int field); public static Date ceiling(final Object date, final int field); private static void modify(final Calendar val, final int field, final int modType); public static Iterator<Calendar> iterator(final Date focus, final int rangeStyle); public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle); public static Iterator<?> iterator(final Object focus, final int rangeStyle); public static long getFragmentInMilliseconds(final Date date, final int fragment); public static long getFragmentInSeconds(final Date date, final int fragment); public static long getFragmentInMinutes(final Date date, final int fragment); public static long getFragmentInHours(final Date date, final int fragment); public static long getFragmentInDays(final Date date, final int fragment); public static long getFragmentInMilliseconds(final Calendar calendar, final int fragment); public static long getFragmentInSeconds(final Calendar calendar, final int fragment); public static long getFragmentInMinutes(final Calendar calendar, final int fragment); public static long getFragmentInHours(final Calendar calendar, final int fragment); public static long getFragmentInDays(final Calendar calendar, final int fragment); private static long getFragment(final Date date, final int fragment, final int unit); private static long getFragment(final Calendar calendar, final int fragment, final int unit); public static boolean truncatedEquals(final Calendar cal1, final Calendar cal2, final int field); public static boolean truncatedEquals(final Date date1, final Date date2, final int field); public static int truncatedCompareTo(final Calendar cal1, final Calendar cal2, final int field); public static int truncatedCompareTo(final Date date1, final Date date2, final int field); private static long getMillisPerUnit(final int unit); public boolean hasNext(); public Calendar next(); public void remove(); long MILLIS_PER_SECOND=Optional[1000]; long MILLIS_PER_MINUTE=Optional[60 * MILLIS_PER_SECOND]; long MILLIS_PER_HOUR=Optional[60 * MILLIS_PER_MINUTE]; long MILLIS_PER_DAY=Optional[24 * MILLIS_PER_HOUR]; int SEMI_MONTH=Optional[1001]; int[][] fields=Optional[{ { Calendar.MILLISECOND }, { Calendar.SECOND }, { Calendar.MINUTE }, { Calendar.HOUR_OF_DAY, Calendar.HOUR }, { Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM /* Calendar.DAY_OF_YEAR, Calendar.DAY_OF_WEEK, Calendar.DAY_OF_WEEK_IN_MONTH */; }, { Calendar.MONTH, DateUtils.SEMI_MONTH }, { Calendar.YEAR }, { Calendar.ERA } }
public static Date setMilliseconds(final Date date, final int amount) { [EOL]     return set(date, Calendar.MILLISECOND, amount); [EOL] } public DateUtils();  DateIterator(final Calendar startFinal, final Calendar endFinal); public static boolean isSameDay(final Date date1, final Date date2); public static boolean isSameDay(final Calendar cal1, final Calendar cal2); public static boolean isSameInstant(final Date date1, final Date date2); public static boolean isSameInstant(final Calendar cal1, final Calendar cal2); public static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2); public static Date parseDate(final String str, final String... parsePatterns) throws ParseException; public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException; private static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException; public static Date addYears(final Date date, final int amount); public static Date addMonths(final Date date, final int amount); public static Date addWeeks(final Date date, final int amount); public static Date addDays(final Date date, final int amount); public static Date addHours(final Date date, final int amount); public static Date addMinutes(final Date date, final int amount); public static Date addSeconds(final Date date, final int amount); public static Date addMilliseconds(final Date date, final int amount); private static Date add(final Date date, final int calendarField, final int amount); public static Date setYears(final Date date, final int amount); public static Date setMonths(final Date date, final int amount); public static Date setDays(final Date date, final int amount); public static Date setHours(final Date date, final int amount); public static Date setMinutes(final Date date, final int amount); public static Date setSeconds(final Date date, final int amount); public static Date setMilliseconds(final Date date, final int amount); private static Date set(final Date date, final int calendarField, final int amount); public static Calendar toCalendar(final Date date); public static Date round(final Date date, final int field); public static Calendar round(final Calendar date, final int field); public static Date round(final Object date, final int field); public static Date truncate(final Date date, final int field); public static Calendar truncate(final Calendar date, final int field); public static Date truncate(final Object date, final int field); public static Date ceiling(final Date date, final int field); public static Calendar ceiling(final Calendar date, final int field); public static Date ceiling(final Object date, final int field); private static void modify(final Calendar val, final int field, final int modType); public static Iterator<Calendar> iterator(final Date focus, final int rangeStyle); public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle); public static Iterator<?> iterator(final Object focus, final int rangeStyle); public static long getFragmentInMilliseconds(final Date date, final int fragment); public static long getFragmentInSeconds(final Date date, final int fragment); public static long getFragmentInMinutes(final Date date, final int fragment); public static long getFragmentInHours(final Date date, final int fragment); public static long getFragmentInDays(final Date date, final int fragment); public static long getFragmentInMilliseconds(final Calendar calendar, final int fragment); public static long getFragmentInSeconds(final Calendar calendar, final int fragment); public static long getFragmentInMinutes(final Calendar calendar, final int fragment); public static long getFragmentInHours(final Calendar calendar, final int fragment); public static long getFragmentInDays(final Calendar calendar, final int fragment); private static long getFragment(final Date date, final int fragment, final int unit); private static long getFragment(final Calendar calendar, final int fragment, final int unit); public static boolean truncatedEquals(final Calendar cal1, final Calendar cal2, final int field); public static boolean truncatedEquals(final Date date1, final Date date2, final int field); public static int truncatedCompareTo(final Calendar cal1, final Calendar cal2, final int field); public static int truncatedCompareTo(final Date date1, final Date date2, final int field); private static long getMillisPerUnit(final int unit); public boolean hasNext(); public Calendar next(); public void remove(); long MILLIS_PER_SECOND=Optional[1000]; long MILLIS_PER_MINUTE=Optional[60 * MILLIS_PER_SECOND]; long MILLIS_PER_HOUR=Optional[60 * MILLIS_PER_MINUTE]; long MILLIS_PER_DAY=Optional[24 * MILLIS_PER_HOUR]; int SEMI_MONTH=Optional[1001]; int[][] fields=Optional[{ { Calendar.MILLISECOND }, { Calendar.SECOND }, { Calendar.MINUTE }, { Calendar.HOUR_OF_DAY, Calendar.HOUR }, { Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM /* Calendar.DAY_OF_YEAR, Calendar.DAY_OF_WEEK, Calendar.DAY_OF_WEEK_IN_MONTH */; }, { Calendar.MONTH, DateUtils.SEMI_MONTH }, { Calendar.YEAR }, { Calendar.ERA } }
public static Date round(final Date date, final int field) { [EOL]     if (date == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     final Calendar gval = Calendar.getInstance(); [EOL]     gval.setTime(date); [EOL]     modify(gval, field, MODIFY_ROUND); [EOL]     return gval.getTime(); [EOL] } public DateUtils();  DateIterator(final Calendar startFinal, final Calendar endFinal); public static boolean isSameDay(final Date date1, final Date date2); public static boolean isSameDay(final Calendar cal1, final Calendar cal2); public static boolean isSameInstant(final Date date1, final Date date2); public static boolean isSameInstant(final Calendar cal1, final Calendar cal2); public static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2); public static Date parseDate(final String str, final String... parsePatterns) throws ParseException; public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException; private static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException; public static Date addYears(final Date date, final int amount); public static Date addMonths(final Date date, final int amount); public static Date addWeeks(final Date date, final int amount); public static Date addDays(final Date date, final int amount); public static Date addHours(final Date date, final int amount); public static Date addMinutes(final Date date, final int amount); public static Date addSeconds(final Date date, final int amount); public static Date addMilliseconds(final Date date, final int amount); private static Date add(final Date date, final int calendarField, final int amount); public static Date setYears(final Date date, final int amount); public static Date setMonths(final Date date, final int amount); public static Date setDays(final Date date, final int amount); public static Date setHours(final Date date, final int amount); public static Date setMinutes(final Date date, final int amount); public static Date setSeconds(final Date date, final int amount); public static Date setMilliseconds(final Date date, final int amount); private static Date set(final Date date, final int calendarField, final int amount); public static Calendar toCalendar(final Date date); public static Date round(final Date date, final int field); public static Calendar round(final Calendar date, final int field); public static Date round(final Object date, final int field); public static Date truncate(final Date date, final int field); public static Calendar truncate(final Calendar date, final int field); public static Date truncate(final Object date, final int field); public static Date ceiling(final Date date, final int field); public static Calendar ceiling(final Calendar date, final int field); public static Date ceiling(final Object date, final int field); private static void modify(final Calendar val, final int field, final int modType); public static Iterator<Calendar> iterator(final Date focus, final int rangeStyle); public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle); public static Iterator<?> iterator(final Object focus, final int rangeStyle); public static long getFragmentInMilliseconds(final Date date, final int fragment); public static long getFragmentInSeconds(final Date date, final int fragment); public static long getFragmentInMinutes(final Date date, final int fragment); public static long getFragmentInHours(final Date date, final int fragment); public static long getFragmentInDays(final Date date, final int fragment); public static long getFragmentInMilliseconds(final Calendar calendar, final int fragment); public static long getFragmentInSeconds(final Calendar calendar, final int fragment); public static long getFragmentInMinutes(final Calendar calendar, final int fragment); public static long getFragmentInHours(final Calendar calendar, final int fragment); public static long getFragmentInDays(final Calendar calendar, final int fragment); private static long getFragment(final Date date, final int fragment, final int unit); private static long getFragment(final Calendar calendar, final int fragment, final int unit); public static boolean truncatedEquals(final Calendar cal1, final Calendar cal2, final int field); public static boolean truncatedEquals(final Date date1, final Date date2, final int field); public static int truncatedCompareTo(final Calendar cal1, final Calendar cal2, final int field); public static int truncatedCompareTo(final Date date1, final Date date2, final int field); private static long getMillisPerUnit(final int unit); public boolean hasNext(); public Calendar next(); public void remove(); long MILLIS_PER_SECOND=Optional[1000]; long MILLIS_PER_MINUTE=Optional[60 * MILLIS_PER_SECOND]; long MILLIS_PER_HOUR=Optional[60 * MILLIS_PER_MINUTE]; long MILLIS_PER_DAY=Optional[24 * MILLIS_PER_HOUR]; int SEMI_MONTH=Optional[1001]; int[][] fields=Optional[{ { Calendar.MILLISECOND }, { Calendar.SECOND }, { Calendar.MINUTE }, { Calendar.HOUR_OF_DAY, Calendar.HOUR }, { Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM /* Calendar.DAY_OF_YEAR, Calendar.DAY_OF_WEEK, Calendar.DAY_OF_WEEK_IN_MONTH */; }, { Calendar.MONTH, DateUtils.SEMI_MONTH }, { Calendar.YEAR }, { Calendar.ERA } }
public static Date round(final Date date, final int field) { [EOL]     if (date == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     final Calendar gval = Calendar.getInstance(); [EOL]     gval.setTime(date); [EOL]     modify(gval, field, MODIFY_ROUND); [EOL]     return gval.getTime(); [EOL] } public DateUtils();  DateIterator(final Calendar startFinal, final Calendar endFinal); public static boolean isSameDay(final Date date1, final Date date2); public static boolean isSameDay(final Calendar cal1, final Calendar cal2); public static boolean isSameInstant(final Date date1, final Date date2); public static boolean isSameInstant(final Calendar cal1, final Calendar cal2); public static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2); public static Date parseDate(final String str, final String... parsePatterns) throws ParseException; public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException; private static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException; public static Date addYears(final Date date, final int amount); public static Date addMonths(final Date date, final int amount); public static Date addWeeks(final Date date, final int amount); public static Date addDays(final Date date, final int amount); public static Date addHours(final Date date, final int amount); public static Date addMinutes(final Date date, final int amount); public static Date addSeconds(final Date date, final int amount); public static Date addMilliseconds(final Date date, final int amount); private static Date add(final Date date, final int calendarField, final int amount); public static Date setYears(final Date date, final int amount); public static Date setMonths(final Date date, final int amount); public static Date setDays(final Date date, final int amount); public static Date setHours(final Date date, final int amount); public static Date setMinutes(final Date date, final int amount); public static Date setSeconds(final Date date, final int amount); public static Date setMilliseconds(final Date date, final int amount); private static Date set(final Date date, final int calendarField, final int amount); public static Calendar toCalendar(final Date date); public static Date round(final Date date, final int field); public static Calendar round(final Calendar date, final int field); public static Date round(final Object date, final int field); public static Date truncate(final Date date, final int field); public static Calendar truncate(final Calendar date, final int field); public static Date truncate(final Object date, final int field); public static Date ceiling(final Date date, final int field); public static Calendar ceiling(final Calendar date, final int field); public static Date ceiling(final Object date, final int field); private static void modify(final Calendar val, final int field, final int modType); public static Iterator<Calendar> iterator(final Date focus, final int rangeStyle); public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle); public static Iterator<?> iterator(final Object focus, final int rangeStyle); public static long getFragmentInMilliseconds(final Date date, final int fragment); public static long getFragmentInSeconds(final Date date, final int fragment); public static long getFragmentInMinutes(final Date date, final int fragment); public static long getFragmentInHours(final Date date, final int fragment); public static long getFragmentInDays(final Date date, final int fragment); public static long getFragmentInMilliseconds(final Calendar calendar, final int fragment); public static long getFragmentInSeconds(final Calendar calendar, final int fragment); public static long getFragmentInMinutes(final Calendar calendar, final int fragment); public static long getFragmentInHours(final Calendar calendar, final int fragment); public static long getFragmentInDays(final Calendar calendar, final int fragment); private static long getFragment(final Date date, final int fragment, final int unit); private static long getFragment(final Calendar calendar, final int fragment, final int unit); public static boolean truncatedEquals(final Calendar cal1, final Calendar cal2, final int field); public static boolean truncatedEquals(final Date date1, final Date date2, final int field); public static int truncatedCompareTo(final Calendar cal1, final Calendar cal2, final int field); public static int truncatedCompareTo(final Date date1, final Date date2, final int field); private static long getMillisPerUnit(final int unit); public boolean hasNext(); public Calendar next(); public void remove(); long MILLIS_PER_SECOND=Optional[1000]; long MILLIS_PER_MINUTE=Optional[60 * MILLIS_PER_SECOND]; long MILLIS_PER_HOUR=Optional[60 * MILLIS_PER_MINUTE]; long MILLIS_PER_DAY=Optional[24 * MILLIS_PER_HOUR]; int SEMI_MONTH=Optional[1001]; int[][] fields=Optional[{ { Calendar.MILLISECOND }, { Calendar.SECOND }, { Calendar.MINUTE }, { Calendar.HOUR_OF_DAY, Calendar.HOUR }, { Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM /* Calendar.DAY_OF_YEAR, Calendar.DAY_OF_WEEK, Calendar.DAY_OF_WEEK_IN_MONTH */; }, { Calendar.MONTH, DateUtils.SEMI_MONTH }, { Calendar.YEAR }, { Calendar.ERA } }
public static Calendar round(final Calendar date, final int field) { [EOL]     if (date == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     final Calendar rounded = (Calendar) date.clone(); [EOL]     modify(rounded, field, MODIFY_ROUND); [EOL]     return rounded; [EOL] } public DateUtils();  DateIterator(final Calendar startFinal, final Calendar endFinal); public static boolean isSameDay(final Date date1, final Date date2); public static boolean isSameDay(final Calendar cal1, final Calendar cal2); public static boolean isSameInstant(final Date date1, final Date date2); public static boolean isSameInstant(final Calendar cal1, final Calendar cal2); public static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2); public static Date parseDate(final String str, final String... parsePatterns) throws ParseException; public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException; private static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException; public static Date addYears(final Date date, final int amount); public static Date addMonths(final Date date, final int amount); public static Date addWeeks(final Date date, final int amount); public static Date addDays(final Date date, final int amount); public static Date addHours(final Date date, final int amount); public static Date addMinutes(final Date date, final int amount); public static Date addSeconds(final Date date, final int amount); public static Date addMilliseconds(final Date date, final int amount); private static Date add(final Date date, final int calendarField, final int amount); public static Date setYears(final Date date, final int amount); public static Date setMonths(final Date date, final int amount); public static Date setDays(final Date date, final int amount); public static Date setHours(final Date date, final int amount); public static Date setMinutes(final Date date, final int amount); public static Date setSeconds(final Date date, final int amount); public static Date setMilliseconds(final Date date, final int amount); private static Date set(final Date date, final int calendarField, final int amount); public static Calendar toCalendar(final Date date); public static Date round(final Date date, final int field); public static Calendar round(final Calendar date, final int field); public static Date round(final Object date, final int field); public static Date truncate(final Date date, final int field); public static Calendar truncate(final Calendar date, final int field); public static Date truncate(final Object date, final int field); public static Date ceiling(final Date date, final int field); public static Calendar ceiling(final Calendar date, final int field); public static Date ceiling(final Object date, final int field); private static void modify(final Calendar val, final int field, final int modType); public static Iterator<Calendar> iterator(final Date focus, final int rangeStyle); public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle); public static Iterator<?> iterator(final Object focus, final int rangeStyle); public static long getFragmentInMilliseconds(final Date date, final int fragment); public static long getFragmentInSeconds(final Date date, final int fragment); public static long getFragmentInMinutes(final Date date, final int fragment); public static long getFragmentInHours(final Date date, final int fragment); public static long getFragmentInDays(final Date date, final int fragment); public static long getFragmentInMilliseconds(final Calendar calendar, final int fragment); public static long getFragmentInSeconds(final Calendar calendar, final int fragment); public static long getFragmentInMinutes(final Calendar calendar, final int fragment); public static long getFragmentInHours(final Calendar calendar, final int fragment); public static long getFragmentInDays(final Calendar calendar, final int fragment); private static long getFragment(final Date date, final int fragment, final int unit); private static long getFragment(final Calendar calendar, final int fragment, final int unit); public static boolean truncatedEquals(final Calendar cal1, final Calendar cal2, final int field); public static boolean truncatedEquals(final Date date1, final Date date2, final int field); public static int truncatedCompareTo(final Calendar cal1, final Calendar cal2, final int field); public static int truncatedCompareTo(final Date date1, final Date date2, final int field); private static long getMillisPerUnit(final int unit); public boolean hasNext(); public Calendar next(); public void remove(); long MILLIS_PER_SECOND=Optional[1000]; long MILLIS_PER_MINUTE=Optional[60 * MILLIS_PER_SECOND]; long MILLIS_PER_HOUR=Optional[60 * MILLIS_PER_MINUTE]; long MILLIS_PER_DAY=Optional[24 * MILLIS_PER_HOUR]; int SEMI_MONTH=Optional[1001]; int[][] fields=Optional[{ { Calendar.MILLISECOND }, { Calendar.SECOND }, { Calendar.MINUTE }, { Calendar.HOUR_OF_DAY, Calendar.HOUR }, { Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM /* Calendar.DAY_OF_YEAR, Calendar.DAY_OF_WEEK, Calendar.DAY_OF_WEEK_IN_MONTH */; }, { Calendar.MONTH, DateUtils.SEMI_MONTH }, { Calendar.YEAR }, { Calendar.ERA } }
public static Calendar round(final Calendar date, final int field) { [EOL]     if (date == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     final Calendar rounded = (Calendar) date.clone(); [EOL]     modify(rounded, field, MODIFY_ROUND); [EOL]     return rounded; [EOL] } public DateUtils();  DateIterator(final Calendar startFinal, final Calendar endFinal); public static boolean isSameDay(final Date date1, final Date date2); public static boolean isSameDay(final Calendar cal1, final Calendar cal2); public static boolean isSameInstant(final Date date1, final Date date2); public static boolean isSameInstant(final Calendar cal1, final Calendar cal2); public static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2); public static Date parseDate(final String str, final String... parsePatterns) throws ParseException; public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException; private static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException; public static Date addYears(final Date date, final int amount); public static Date addMonths(final Date date, final int amount); public static Date addWeeks(final Date date, final int amount); public static Date addDays(final Date date, final int amount); public static Date addHours(final Date date, final int amount); public static Date addMinutes(final Date date, final int amount); public static Date addSeconds(final Date date, final int amount); public static Date addMilliseconds(final Date date, final int amount); private static Date add(final Date date, final int calendarField, final int amount); public static Date setYears(final Date date, final int amount); public static Date setMonths(final Date date, final int amount); public static Date setDays(final Date date, final int amount); public static Date setHours(final Date date, final int amount); public static Date setMinutes(final Date date, final int amount); public static Date setSeconds(final Date date, final int amount); public static Date setMilliseconds(final Date date, final int amount); private static Date set(final Date date, final int calendarField, final int amount); public static Calendar toCalendar(final Date date); public static Date round(final Date date, final int field); public static Calendar round(final Calendar date, final int field); public static Date round(final Object date, final int field); public static Date truncate(final Date date, final int field); public static Calendar truncate(final Calendar date, final int field); public static Date truncate(final Object date, final int field); public static Date ceiling(final Date date, final int field); public static Calendar ceiling(final Calendar date, final int field); public static Date ceiling(final Object date, final int field); private static void modify(final Calendar val, final int field, final int modType); public static Iterator<Calendar> iterator(final Date focus, final int rangeStyle); public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle); public static Iterator<?> iterator(final Object focus, final int rangeStyle); public static long getFragmentInMilliseconds(final Date date, final int fragment); public static long getFragmentInSeconds(final Date date, final int fragment); public static long getFragmentInMinutes(final Date date, final int fragment); public static long getFragmentInHours(final Date date, final int fragment); public static long getFragmentInDays(final Date date, final int fragment); public static long getFragmentInMilliseconds(final Calendar calendar, final int fragment); public static long getFragmentInSeconds(final Calendar calendar, final int fragment); public static long getFragmentInMinutes(final Calendar calendar, final int fragment); public static long getFragmentInHours(final Calendar calendar, final int fragment); public static long getFragmentInDays(final Calendar calendar, final int fragment); private static long getFragment(final Date date, final int fragment, final int unit); private static long getFragment(final Calendar calendar, final int fragment, final int unit); public static boolean truncatedEquals(final Calendar cal1, final Calendar cal2, final int field); public static boolean truncatedEquals(final Date date1, final Date date2, final int field); public static int truncatedCompareTo(final Calendar cal1, final Calendar cal2, final int field); public static int truncatedCompareTo(final Date date1, final Date date2, final int field); private static long getMillisPerUnit(final int unit); public boolean hasNext(); public Calendar next(); public void remove(); long MILLIS_PER_SECOND=Optional[1000]; long MILLIS_PER_MINUTE=Optional[60 * MILLIS_PER_SECOND]; long MILLIS_PER_HOUR=Optional[60 * MILLIS_PER_MINUTE]; long MILLIS_PER_DAY=Optional[24 * MILLIS_PER_HOUR]; int SEMI_MONTH=Optional[1001]; int[][] fields=Optional[{ { Calendar.MILLISECOND }, { Calendar.SECOND }, { Calendar.MINUTE }, { Calendar.HOUR_OF_DAY, Calendar.HOUR }, { Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM /* Calendar.DAY_OF_YEAR, Calendar.DAY_OF_WEEK, Calendar.DAY_OF_WEEK_IN_MONTH */; }, { Calendar.MONTH, DateUtils.SEMI_MONTH }, { Calendar.YEAR }, { Calendar.ERA } }
public static Date round(final Object date, final int field) { [EOL]     if (date == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     if (date instanceof Date) { [EOL]         return round((Date) date, field); [EOL]     } else if (date instanceof Calendar) { [EOL]         return round((Calendar) date, field).getTime(); [EOL]     } else { [EOL]         throw new ClassCastException("Could not round " + date); [EOL]     } [EOL] } public DateUtils();  DateIterator(final Calendar startFinal, final Calendar endFinal); public static boolean isSameDay(final Date date1, final Date date2); public static boolean isSameDay(final Calendar cal1, final Calendar cal2); public static boolean isSameInstant(final Date date1, final Date date2); public static boolean isSameInstant(final Calendar cal1, final Calendar cal2); public static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2); public static Date parseDate(final String str, final String... parsePatterns) throws ParseException; public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException; private static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException; public static Date addYears(final Date date, final int amount); public static Date addMonths(final Date date, final int amount); public static Date addWeeks(final Date date, final int amount); public static Date addDays(final Date date, final int amount); public static Date addHours(final Date date, final int amount); public static Date addMinutes(final Date date, final int amount); public static Date addSeconds(final Date date, final int amount); public static Date addMilliseconds(final Date date, final int amount); private static Date add(final Date date, final int calendarField, final int amount); public static Date setYears(final Date date, final int amount); public static Date setMonths(final Date date, final int amount); public static Date setDays(final Date date, final int amount); public static Date setHours(final Date date, final int amount); public static Date setMinutes(final Date date, final int amount); public static Date setSeconds(final Date date, final int amount); public static Date setMilliseconds(final Date date, final int amount); private static Date set(final Date date, final int calendarField, final int amount); public static Calendar toCalendar(final Date date); public static Date round(final Date date, final int field); public static Calendar round(final Calendar date, final int field); public static Date round(final Object date, final int field); public static Date truncate(final Date date, final int field); public static Calendar truncate(final Calendar date, final int field); public static Date truncate(final Object date, final int field); public static Date ceiling(final Date date, final int field); public static Calendar ceiling(final Calendar date, final int field); public static Date ceiling(final Object date, final int field); private static void modify(final Calendar val, final int field, final int modType); public static Iterator<Calendar> iterator(final Date focus, final int rangeStyle); public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle); public static Iterator<?> iterator(final Object focus, final int rangeStyle); public static long getFragmentInMilliseconds(final Date date, final int fragment); public static long getFragmentInSeconds(final Date date, final int fragment); public static long getFragmentInMinutes(final Date date, final int fragment); public static long getFragmentInHours(final Date date, final int fragment); public static long getFragmentInDays(final Date date, final int fragment); public static long getFragmentInMilliseconds(final Calendar calendar, final int fragment); public static long getFragmentInSeconds(final Calendar calendar, final int fragment); public static long getFragmentInMinutes(final Calendar calendar, final int fragment); public static long getFragmentInHours(final Calendar calendar, final int fragment); public static long getFragmentInDays(final Calendar calendar, final int fragment); private static long getFragment(final Date date, final int fragment, final int unit); private static long getFragment(final Calendar calendar, final int fragment, final int unit); public static boolean truncatedEquals(final Calendar cal1, final Calendar cal2, final int field); public static boolean truncatedEquals(final Date date1, final Date date2, final int field); public static int truncatedCompareTo(final Calendar cal1, final Calendar cal2, final int field); public static int truncatedCompareTo(final Date date1, final Date date2, final int field); private static long getMillisPerUnit(final int unit); public boolean hasNext(); public Calendar next(); public void remove(); long MILLIS_PER_SECOND=Optional[1000]; long MILLIS_PER_MINUTE=Optional[60 * MILLIS_PER_SECOND]; long MILLIS_PER_HOUR=Optional[60 * MILLIS_PER_MINUTE]; long MILLIS_PER_DAY=Optional[24 * MILLIS_PER_HOUR]; int SEMI_MONTH=Optional[1001]; int[][] fields=Optional[{ { Calendar.MILLISECOND }, { Calendar.SECOND }, { Calendar.MINUTE }, { Calendar.HOUR_OF_DAY, Calendar.HOUR }, { Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM /* Calendar.DAY_OF_YEAR, Calendar.DAY_OF_WEEK, Calendar.DAY_OF_WEEK_IN_MONTH */; }, { Calendar.MONTH, DateUtils.SEMI_MONTH }, { Calendar.YEAR }, { Calendar.ERA } }
private static void modify(final Calendar val, final int field, final int modType) { [EOL]     if (val.get(Calendar.YEAR) > 280000000) { [EOL]         throw new ArithmeticException("Calendar value too large for accurate calculations"); [EOL]     } [EOL]     if (field == Calendar.MILLISECOND) { [EOL]         return; [EOL]     } [EOL]     final Date date = val.getTime(); [EOL]     long time = date.getTime(); [EOL]     boolean done = false; [EOL]     final int millisecs = val.get(Calendar.MILLISECOND); [EOL]     if (MODIFY_TRUNCATE == modType || millisecs < 500) { [EOL]         time = time - millisecs; [EOL]     } [EOL]     if (field == Calendar.SECOND) { [EOL]         done = true; [EOL]     } [EOL]     final int seconds = val.get(Calendar.SECOND); [EOL]     if (!done && (MODIFY_TRUNCATE == modType || seconds < 30)) { [EOL]         time = time - (seconds * 1000L); [EOL]     } [EOL]     if (field == Calendar.MINUTE) { [EOL]         done = true; [EOL]     } [EOL]     final int minutes = val.get(Calendar.MINUTE); [EOL]     if (!done && (MODIFY_TRUNCATE == modType || minutes < 30)) { [EOL]         time = time - (minutes * 60000L); [EOL]     } [EOL]     if (date.getTime() != time) { [EOL]         date.setTime(time); [EOL]         val.setTime(date); [EOL]     } [EOL]     boolean roundUp = false; [EOL]     for (final int[] aField : fields) { [EOL]         for (final int element : aField) { [EOL]             if (element == field) { [EOL]                 if (modType == MODIFY_CEILING || (modType == MODIFY_ROUND && roundUp)) { [EOL]                     if (field == DateUtils.SEMI_MONTH) { [EOL]                         if (val.get(Calendar.DATE) == 1) { [EOL]                             val.add(Calendar.DATE, 15); [EOL]                         } else { [EOL]                             val.add(Calendar.DATE, -15); [EOL]                             val.add(Calendar.MONTH, 1); [EOL]                         } [EOL]                     } else if (field == Calendar.AM_PM) { [EOL]                         if (val.get(Calendar.HOUR_OF_DAY) == 0) { [EOL]                             val.add(Calendar.HOUR_OF_DAY, 12); [EOL]                         } else { [EOL]                             val.add(Calendar.HOUR_OF_DAY, -12); [EOL]                             val.add(Calendar.DATE, 1); [EOL]                         } [EOL]                     } else { [EOL]                         val.add(aField[0], 1); [EOL]                     } [EOL]                 } [EOL]                 return; [EOL]             } [EOL]         } [EOL]         int offset = 0; [EOL]         boolean offsetSet = false; [EOL]         switch(field) { [EOL]             case DateUtils.SEMI_MONTH: [EOL]                 if (aField[0] == Calendar.DATE) { [EOL]                     offset = val.get(Calendar.DATE) - 1; [EOL]                     if (offset >= 15) { [EOL]                         offset -= 15; [EOL]                     } [EOL]                     roundUp = offset > 7; [EOL]                     offsetSet = true; [EOL]                 } [EOL]                 break; [EOL]             case Calendar.AM_PM: [EOL]                 if (aField[0] == Calendar.HOUR_OF_DAY) { [EOL]                     offset = val.get(Calendar.HOUR_OF_DAY); [EOL]                     if (offset >= 12) { [EOL]                         offset -= 12; [EOL]                     } [EOL]                     roundUp = offset >= 6; [EOL]                     offsetSet = true; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         if (!offsetSet) { [EOL]             final int min = val.getActualMinimum(aField[0]); [EOL]             final int max = val.getActualMaximum(aField[0]); [EOL]             offset = val.get(aField[0]) - min; [EOL]             roundUp = offset > ((max - min) / 2); [EOL]         } [EOL]         if (offset != 0) { [EOL]             val.set(aField[0], val.get(aField[0]) - offset); [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("The field " + field + " is not supported"); [EOL] } public DateUtils();  DateIterator(final Calendar startFinal, final Calendar endFinal); public static boolean isSameDay(final Date date1, final Date date2); public static boolean isSameDay(final Calendar cal1, final Calendar cal2); public static boolean isSameInstant(final Date date1, final Date date2); public static boolean isSameInstant(final Calendar cal1, final Calendar cal2); public static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2); public static Date parseDate(final String str, final String... parsePatterns) throws ParseException; public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException; private static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException; public static Date addYears(final Date date, final int amount); public static Date addMonths(final Date date, final int amount); public static Date addWeeks(final Date date, final int amount); public static Date addDays(final Date date, final int amount); public static Date addHours(final Date date, final int amount); public static Date addMinutes(final Date date, final int amount); public static Date addSeconds(final Date date, final int amount); public static Date addMilliseconds(final Date date, final int amount); private static Date add(final Date date, final int calendarField, final int amount); public static Date setYears(final Date date, final int amount); public static Date setMonths(final Date date, final int amount); public static Date setDays(final Date date, final int amount); public static Date setHours(final Date date, final int amount); public static Date setMinutes(final Date date, final int amount); public static Date setSeconds(final Date date, final int amount); public static Date setMilliseconds(final Date date, final int amount); private static Date set(final Date date, final int calendarField, final int amount); public static Calendar toCalendar(final Date date); public static Date round(final Date date, final int field); public static Calendar round(final Calendar date, final int field); public static Date round(final Object date, final int field); public static Date truncate(final Date date, final int field); public static Calendar truncate(final Calendar date, final int field); public static Date truncate(final Object date, final int field); public static Date ceiling(final Date date, final int field); public static Calendar ceiling(final Calendar date, final int field); public static Date ceiling(final Object date, final int field); private static void modify(final Calendar val, final int field, final int modType); public static Iterator<Calendar> iterator(final Date focus, final int rangeStyle); public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle); public static Iterator<?> iterator(final Object focus, final int rangeStyle); public static long getFragmentInMilliseconds(final Date date, final int fragment); public static long getFragmentInSeconds(final Date date, final int fragment); public static long getFragmentInMinutes(final Date date, final int fragment); public static long getFragmentInHours(final Date date, final int fragment); public static long getFragmentInDays(final Date date, final int fragment); public static long getFragmentInMilliseconds(final Calendar calendar, final int fragment); public static long getFragmentInSeconds(final Calendar calendar, final int fragment); public static long getFragmentInMinutes(final Calendar calendar, final int fragment); public static long getFragmentInHours(final Calendar calendar, final int fragment); public static long getFragmentInDays(final Calendar calendar, final int fragment); private static long getFragment(final Date date, final int fragment, final int unit); private static long getFragment(final Calendar calendar, final int fragment, final int unit); public static boolean truncatedEquals(final Calendar cal1, final Calendar cal2, final int field); public static boolean truncatedEquals(final Date date1, final Date date2, final int field); public static int truncatedCompareTo(final Calendar cal1, final Calendar cal2, final int field); public static int truncatedCompareTo(final Date date1, final Date date2, final int field); private static long getMillisPerUnit(final int unit); public boolean hasNext(); public Calendar next(); public void remove(); long MILLIS_PER_SECOND=Optional[1000]; long MILLIS_PER_MINUTE=Optional[60 * MILLIS_PER_SECOND]; long MILLIS_PER_HOUR=Optional[60 * MILLIS_PER_MINUTE]; long MILLIS_PER_DAY=Optional[24 * MILLIS_PER_HOUR]; int SEMI_MONTH=Optional[1001]; int[][] fields=Optional[{ { Calendar.MILLISECOND }, { Calendar.SECOND }, { Calendar.MINUTE }, { Calendar.HOUR_OF_DAY, Calendar.HOUR }, { Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM /* Calendar.DAY_OF_YEAR, Calendar.DAY_OF_WEEK, Calendar.DAY_OF_WEEK_IN_MONTH */; }, { Calendar.MONTH, DateUtils.SEMI_MONTH }, { Calendar.YEAR }, { Calendar.ERA } }
public static long getFragmentInMilliseconds(final Calendar calendar, final int fragment) { [EOL]     return getFragment(calendar, fragment, Calendar.MILLISECOND); [EOL] } public DateUtils();  DateIterator(final Calendar startFinal, final Calendar endFinal); public static boolean isSameDay(final Date date1, final Date date2); public static boolean isSameDay(final Calendar cal1, final Calendar cal2); public static boolean isSameInstant(final Date date1, final Date date2); public static boolean isSameInstant(final Calendar cal1, final Calendar cal2); public static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2); public static Date parseDate(final String str, final String... parsePatterns) throws ParseException; public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException; private static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException; public static Date addYears(final Date date, final int amount); public static Date addMonths(final Date date, final int amount); public static Date addWeeks(final Date date, final int amount); public static Date addDays(final Date date, final int amount); public static Date addHours(final Date date, final int amount); public static Date addMinutes(final Date date, final int amount); public static Date addSeconds(final Date date, final int amount); public static Date addMilliseconds(final Date date, final int amount); private static Date add(final Date date, final int calendarField, final int amount); public static Date setYears(final Date date, final int amount); public static Date setMonths(final Date date, final int amount); public static Date setDays(final Date date, final int amount); public static Date setHours(final Date date, final int amount); public static Date setMinutes(final Date date, final int amount); public static Date setSeconds(final Date date, final int amount); public static Date setMilliseconds(final Date date, final int amount); private static Date set(final Date date, final int calendarField, final int amount); public static Calendar toCalendar(final Date date); public static Date round(final Date date, final int field); public static Calendar round(final Calendar date, final int field); public static Date round(final Object date, final int field); public static Date truncate(final Date date, final int field); public static Calendar truncate(final Calendar date, final int field); public static Date truncate(final Object date, final int field); public static Date ceiling(final Date date, final int field); public static Calendar ceiling(final Calendar date, final int field); public static Date ceiling(final Object date, final int field); private static void modify(final Calendar val, final int field, final int modType); public static Iterator<Calendar> iterator(final Date focus, final int rangeStyle); public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle); public static Iterator<?> iterator(final Object focus, final int rangeStyle); public static long getFragmentInMilliseconds(final Date date, final int fragment); public static long getFragmentInSeconds(final Date date, final int fragment); public static long getFragmentInMinutes(final Date date, final int fragment); public static long getFragmentInHours(final Date date, final int fragment); public static long getFragmentInDays(final Date date, final int fragment); public static long getFragmentInMilliseconds(final Calendar calendar, final int fragment); public static long getFragmentInSeconds(final Calendar calendar, final int fragment); public static long getFragmentInMinutes(final Calendar calendar, final int fragment); public static long getFragmentInHours(final Calendar calendar, final int fragment); public static long getFragmentInDays(final Calendar calendar, final int fragment); private static long getFragment(final Date date, final int fragment, final int unit); private static long getFragment(final Calendar calendar, final int fragment, final int unit); public static boolean truncatedEquals(final Calendar cal1, final Calendar cal2, final int field); public static boolean truncatedEquals(final Date date1, final Date date2, final int field); public static int truncatedCompareTo(final Calendar cal1, final Calendar cal2, final int field); public static int truncatedCompareTo(final Date date1, final Date date2, final int field); private static long getMillisPerUnit(final int unit); public boolean hasNext(); public Calendar next(); public void remove(); long MILLIS_PER_SECOND=Optional[1000]; long MILLIS_PER_MINUTE=Optional[60 * MILLIS_PER_SECOND]; long MILLIS_PER_HOUR=Optional[60 * MILLIS_PER_MINUTE]; long MILLIS_PER_DAY=Optional[24 * MILLIS_PER_HOUR]; int SEMI_MONTH=Optional[1001]; int[][] fields=Optional[{ { Calendar.MILLISECOND }, { Calendar.SECOND }, { Calendar.MINUTE }, { Calendar.HOUR_OF_DAY, Calendar.HOUR }, { Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM /* Calendar.DAY_OF_YEAR, Calendar.DAY_OF_WEEK, Calendar.DAY_OF_WEEK_IN_MONTH */; }, { Calendar.MONTH, DateUtils.SEMI_MONTH }, { Calendar.YEAR }, { Calendar.ERA } }
public static long getFragmentInMinutes(final Calendar calendar, final int fragment) { [EOL]     return getFragment(calendar, fragment, Calendar.MINUTE); [EOL] } public DateUtils();  DateIterator(final Calendar startFinal, final Calendar endFinal); public static boolean isSameDay(final Date date1, final Date date2); public static boolean isSameDay(final Calendar cal1, final Calendar cal2); public static boolean isSameInstant(final Date date1, final Date date2); public static boolean isSameInstant(final Calendar cal1, final Calendar cal2); public static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2); public static Date parseDate(final String str, final String... parsePatterns) throws ParseException; public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException; private static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException; public static Date addYears(final Date date, final int amount); public static Date addMonths(final Date date, final int amount); public static Date addWeeks(final Date date, final int amount); public static Date addDays(final Date date, final int amount); public static Date addHours(final Date date, final int amount); public static Date addMinutes(final Date date, final int amount); public static Date addSeconds(final Date date, final int amount); public static Date addMilliseconds(final Date date, final int amount); private static Date add(final Date date, final int calendarField, final int amount); public static Date setYears(final Date date, final int amount); public static Date setMonths(final Date date, final int amount); public static Date setDays(final Date date, final int amount); public static Date setHours(final Date date, final int amount); public static Date setMinutes(final Date date, final int amount); public static Date setSeconds(final Date date, final int amount); public static Date setMilliseconds(final Date date, final int amount); private static Date set(final Date date, final int calendarField, final int amount); public static Calendar toCalendar(final Date date); public static Date round(final Date date, final int field); public static Calendar round(final Calendar date, final int field); public static Date round(final Object date, final int field); public static Date truncate(final Date date, final int field); public static Calendar truncate(final Calendar date, final int field); public static Date truncate(final Object date, final int field); public static Date ceiling(final Date date, final int field); public static Calendar ceiling(final Calendar date, final int field); public static Date ceiling(final Object date, final int field); private static void modify(final Calendar val, final int field, final int modType); public static Iterator<Calendar> iterator(final Date focus, final int rangeStyle); public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle); public static Iterator<?> iterator(final Object focus, final int rangeStyle); public static long getFragmentInMilliseconds(final Date date, final int fragment); public static long getFragmentInSeconds(final Date date, final int fragment); public static long getFragmentInMinutes(final Date date, final int fragment); public static long getFragmentInHours(final Date date, final int fragment); public static long getFragmentInDays(final Date date, final int fragment); public static long getFragmentInMilliseconds(final Calendar calendar, final int fragment); public static long getFragmentInSeconds(final Calendar calendar, final int fragment); public static long getFragmentInMinutes(final Calendar calendar, final int fragment); public static long getFragmentInHours(final Calendar calendar, final int fragment); public static long getFragmentInDays(final Calendar calendar, final int fragment); private static long getFragment(final Date date, final int fragment, final int unit); private static long getFragment(final Calendar calendar, final int fragment, final int unit); public static boolean truncatedEquals(final Calendar cal1, final Calendar cal2, final int field); public static boolean truncatedEquals(final Date date1, final Date date2, final int field); public static int truncatedCompareTo(final Calendar cal1, final Calendar cal2, final int field); public static int truncatedCompareTo(final Date date1, final Date date2, final int field); private static long getMillisPerUnit(final int unit); public boolean hasNext(); public Calendar next(); public void remove(); long MILLIS_PER_SECOND=Optional[1000]; long MILLIS_PER_MINUTE=Optional[60 * MILLIS_PER_SECOND]; long MILLIS_PER_HOUR=Optional[60 * MILLIS_PER_MINUTE]; long MILLIS_PER_DAY=Optional[24 * MILLIS_PER_HOUR]; int SEMI_MONTH=Optional[1001]; int[][] fields=Optional[{ { Calendar.MILLISECOND }, { Calendar.SECOND }, { Calendar.MINUTE }, { Calendar.HOUR_OF_DAY, Calendar.HOUR }, { Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM /* Calendar.DAY_OF_YEAR, Calendar.DAY_OF_WEEK, Calendar.DAY_OF_WEEK_IN_MONTH */; }, { Calendar.MONTH, DateUtils.SEMI_MONTH }, { Calendar.YEAR }, { Calendar.ERA } }
public static long getFragmentInDays(final Calendar calendar, final int fragment) { [EOL]     return getFragment(calendar, fragment, Calendar.DAY_OF_YEAR); [EOL] } public DateUtils();  DateIterator(final Calendar startFinal, final Calendar endFinal); public static boolean isSameDay(final Date date1, final Date date2); public static boolean isSameDay(final Calendar cal1, final Calendar cal2); public static boolean isSameInstant(final Date date1, final Date date2); public static boolean isSameInstant(final Calendar cal1, final Calendar cal2); public static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2); public static Date parseDate(final String str, final String... parsePatterns) throws ParseException; public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException; private static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException; public static Date addYears(final Date date, final int amount); public static Date addMonths(final Date date, final int amount); public static Date addWeeks(final Date date, final int amount); public static Date addDays(final Date date, final int amount); public static Date addHours(final Date date, final int amount); public static Date addMinutes(final Date date, final int amount); public static Date addSeconds(final Date date, final int amount); public static Date addMilliseconds(final Date date, final int amount); private static Date add(final Date date, final int calendarField, final int amount); public static Date setYears(final Date date, final int amount); public static Date setMonths(final Date date, final int amount); public static Date setDays(final Date date, final int amount); public static Date setHours(final Date date, final int amount); public static Date setMinutes(final Date date, final int amount); public static Date setSeconds(final Date date, final int amount); public static Date setMilliseconds(final Date date, final int amount); private static Date set(final Date date, final int calendarField, final int amount); public static Calendar toCalendar(final Date date); public static Date round(final Date date, final int field); public static Calendar round(final Calendar date, final int field); public static Date round(final Object date, final int field); public static Date truncate(final Date date, final int field); public static Calendar truncate(final Calendar date, final int field); public static Date truncate(final Object date, final int field); public static Date ceiling(final Date date, final int field); public static Calendar ceiling(final Calendar date, final int field); public static Date ceiling(final Object date, final int field); private static void modify(final Calendar val, final int field, final int modType); public static Iterator<Calendar> iterator(final Date focus, final int rangeStyle); public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle); public static Iterator<?> iterator(final Object focus, final int rangeStyle); public static long getFragmentInMilliseconds(final Date date, final int fragment); public static long getFragmentInSeconds(final Date date, final int fragment); public static long getFragmentInMinutes(final Date date, final int fragment); public static long getFragmentInHours(final Date date, final int fragment); public static long getFragmentInDays(final Date date, final int fragment); public static long getFragmentInMilliseconds(final Calendar calendar, final int fragment); public static long getFragmentInSeconds(final Calendar calendar, final int fragment); public static long getFragmentInMinutes(final Calendar calendar, final int fragment); public static long getFragmentInHours(final Calendar calendar, final int fragment); public static long getFragmentInDays(final Calendar calendar, final int fragment); private static long getFragment(final Date date, final int fragment, final int unit); private static long getFragment(final Calendar calendar, final int fragment, final int unit); public static boolean truncatedEquals(final Calendar cal1, final Calendar cal2, final int field); public static boolean truncatedEquals(final Date date1, final Date date2, final int field); public static int truncatedCompareTo(final Calendar cal1, final Calendar cal2, final int field); public static int truncatedCompareTo(final Date date1, final Date date2, final int field); private static long getMillisPerUnit(final int unit); public boolean hasNext(); public Calendar next(); public void remove(); long MILLIS_PER_SECOND=Optional[1000]; long MILLIS_PER_MINUTE=Optional[60 * MILLIS_PER_SECOND]; long MILLIS_PER_HOUR=Optional[60 * MILLIS_PER_MINUTE]; long MILLIS_PER_DAY=Optional[24 * MILLIS_PER_HOUR]; int SEMI_MONTH=Optional[1001]; int[][] fields=Optional[{ { Calendar.MILLISECOND }, { Calendar.SECOND }, { Calendar.MINUTE }, { Calendar.HOUR_OF_DAY, Calendar.HOUR }, { Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM /* Calendar.DAY_OF_YEAR, Calendar.DAY_OF_WEEK, Calendar.DAY_OF_WEEK_IN_MONTH */; }, { Calendar.MONTH, DateUtils.SEMI_MONTH }, { Calendar.YEAR }, { Calendar.ERA } }
private static long getFragment(final Calendar calendar, final int fragment, final int unit) { [EOL]     if (calendar == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     final long millisPerUnit = getMillisPerUnit(unit); [EOL]     long result = 0; [EOL]     switch(fragment) { [EOL]         case Calendar.YEAR: [EOL]             result += (calendar.get(Calendar.DAY_OF_YEAR) * MILLIS_PER_DAY) / millisPerUnit; [EOL]             break; [EOL]         case Calendar.MONTH: [EOL]             result += (calendar.get(Calendar.DAY_OF_MONTH) * MILLIS_PER_DAY) / millisPerUnit; [EOL]             break; [EOL]     } [EOL]     switch(fragment) { [EOL]         case Calendar.YEAR: [EOL]         case Calendar.MONTH: [EOL]         case Calendar.DAY_OF_YEAR: [EOL]         case Calendar.DATE: [EOL]             result += (calendar.get(Calendar.HOUR_OF_DAY) * MILLIS_PER_HOUR) / millisPerUnit; [EOL]         case Calendar.HOUR_OF_DAY: [EOL]             result += (calendar.get(Calendar.MINUTE) * MILLIS_PER_MINUTE) / millisPerUnit; [EOL]         case Calendar.MINUTE: [EOL]             result += (calendar.get(Calendar.SECOND) * MILLIS_PER_SECOND) / millisPerUnit; [EOL]         case Calendar.SECOND: [EOL]             result += (calendar.get(Calendar.MILLISECOND) * 1) / millisPerUnit; [EOL]             break; [EOL]         case Calendar.MILLISECOND: [EOL]             break; [EOL]         default: [EOL]             throw new IllegalArgumentException("The fragment " + fragment + " is not supported"); [EOL]     } [EOL]     return result; [EOL] } public DateUtils();  DateIterator(final Calendar startFinal, final Calendar endFinal); public static boolean isSameDay(final Date date1, final Date date2); public static boolean isSameDay(final Calendar cal1, final Calendar cal2); public static boolean isSameInstant(final Date date1, final Date date2); public static boolean isSameInstant(final Calendar cal1, final Calendar cal2); public static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2); public static Date parseDate(final String str, final String... parsePatterns) throws ParseException; public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException; private static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException; public static Date addYears(final Date date, final int amount); public static Date addMonths(final Date date, final int amount); public static Date addWeeks(final Date date, final int amount); public static Date addDays(final Date date, final int amount); public static Date addHours(final Date date, final int amount); public static Date addMinutes(final Date date, final int amount); public static Date addSeconds(final Date date, final int amount); public static Date addMilliseconds(final Date date, final int amount); private static Date add(final Date date, final int calendarField, final int amount); public static Date setYears(final Date date, final int amount); public static Date setMonths(final Date date, final int amount); public static Date setDays(final Date date, final int amount); public static Date setHours(final Date date, final int amount); public static Date setMinutes(final Date date, final int amount); public static Date setSeconds(final Date date, final int amount); public static Date setMilliseconds(final Date date, final int amount); private static Date set(final Date date, final int calendarField, final int amount); public static Calendar toCalendar(final Date date); public static Date round(final Date date, final int field); public static Calendar round(final Calendar date, final int field); public static Date round(final Object date, final int field); public static Date truncate(final Date date, final int field); public static Calendar truncate(final Calendar date, final int field); public static Date truncate(final Object date, final int field); public static Date ceiling(final Date date, final int field); public static Calendar ceiling(final Calendar date, final int field); public static Date ceiling(final Object date, final int field); private static void modify(final Calendar val, final int field, final int modType); public static Iterator<Calendar> iterator(final Date focus, final int rangeStyle); public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle); public static Iterator<?> iterator(final Object focus, final int rangeStyle); public static long getFragmentInMilliseconds(final Date date, final int fragment); public static long getFragmentInSeconds(final Date date, final int fragment); public static long getFragmentInMinutes(final Date date, final int fragment); public static long getFragmentInHours(final Date date, final int fragment); public static long getFragmentInDays(final Date date, final int fragment); public static long getFragmentInMilliseconds(final Calendar calendar, final int fragment); public static long getFragmentInSeconds(final Calendar calendar, final int fragment); public static long getFragmentInMinutes(final Calendar calendar, final int fragment); public static long getFragmentInHours(final Calendar calendar, final int fragment); public static long getFragmentInDays(final Calendar calendar, final int fragment); private static long getFragment(final Date date, final int fragment, final int unit); private static long getFragment(final Calendar calendar, final int fragment, final int unit); public static boolean truncatedEquals(final Calendar cal1, final Calendar cal2, final int field); public static boolean truncatedEquals(final Date date1, final Date date2, final int field); public static int truncatedCompareTo(final Calendar cal1, final Calendar cal2, final int field); public static int truncatedCompareTo(final Date date1, final Date date2, final int field); private static long getMillisPerUnit(final int unit); public boolean hasNext(); public Calendar next(); public void remove(); long MILLIS_PER_SECOND=Optional[1000]; long MILLIS_PER_MINUTE=Optional[60 * MILLIS_PER_SECOND]; long MILLIS_PER_HOUR=Optional[60 * MILLIS_PER_MINUTE]; long MILLIS_PER_DAY=Optional[24 * MILLIS_PER_HOUR]; int SEMI_MONTH=Optional[1001]; int[][] fields=Optional[{ { Calendar.MILLISECOND }, { Calendar.SECOND }, { Calendar.MINUTE }, { Calendar.HOUR_OF_DAY, Calendar.HOUR }, { Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM /* Calendar.DAY_OF_YEAR, Calendar.DAY_OF_WEEK, Calendar.DAY_OF_WEEK_IN_MONTH */; }, { Calendar.MONTH, DateUtils.SEMI_MONTH }, { Calendar.YEAR }, { Calendar.ERA } }
private static long getMillisPerUnit(final int unit) { [EOL]     long result = Long.MAX_VALUE; [EOL]     switch(unit) { [EOL]         case Calendar.DAY_OF_YEAR: [EOL]         case Calendar.DATE: [EOL]             result = MILLIS_PER_DAY; [EOL]             break; [EOL]         case Calendar.HOUR_OF_DAY: [EOL]             result = MILLIS_PER_HOUR; [EOL]             break; [EOL]         case Calendar.MINUTE: [EOL]             result = MILLIS_PER_MINUTE; [EOL]             break; [EOL]         case Calendar.SECOND: [EOL]             result = MILLIS_PER_SECOND; [EOL]             break; [EOL]         case Calendar.MILLISECOND: [EOL]             result = 1; [EOL]             break; [EOL]         default: [EOL]             throw new IllegalArgumentException("The unit " + unit + " cannot be represented is milleseconds"); [EOL]     } [EOL]     return result; [EOL] } public DateUtils();  DateIterator(final Calendar startFinal, final Calendar endFinal); public static boolean isSameDay(final Date date1, final Date date2); public static boolean isSameDay(final Calendar cal1, final Calendar cal2); public static boolean isSameInstant(final Date date1, final Date date2); public static boolean isSameInstant(final Calendar cal1, final Calendar cal2); public static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2); public static Date parseDate(final String str, final String... parsePatterns) throws ParseException; public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException; private static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException; public static Date addYears(final Date date, final int amount); public static Date addMonths(final Date date, final int amount); public static Date addWeeks(final Date date, final int amount); public static Date addDays(final Date date, final int amount); public static Date addHours(final Date date, final int amount); public static Date addMinutes(final Date date, final int amount); public static Date addSeconds(final Date date, final int amount); public static Date addMilliseconds(final Date date, final int amount); private static Date add(final Date date, final int calendarField, final int amount); public static Date setYears(final Date date, final int amount); public static Date setMonths(final Date date, final int amount); public static Date setDays(final Date date, final int amount); public static Date setHours(final Date date, final int amount); public static Date setMinutes(final Date date, final int amount); public static Date setSeconds(final Date date, final int amount); public static Date setMilliseconds(final Date date, final int amount); private static Date set(final Date date, final int calendarField, final int amount); public static Calendar toCalendar(final Date date); public static Date round(final Date date, final int field); public static Calendar round(final Calendar date, final int field); public static Date round(final Object date, final int field); public static Date truncate(final Date date, final int field); public static Calendar truncate(final Calendar date, final int field); public static Date truncate(final Object date, final int field); public static Date ceiling(final Date date, final int field); public static Calendar ceiling(final Calendar date, final int field); public static Date ceiling(final Object date, final int field); private static void modify(final Calendar val, final int field, final int modType); public static Iterator<Calendar> iterator(final Date focus, final int rangeStyle); public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle); public static Iterator<?> iterator(final Object focus, final int rangeStyle); public static long getFragmentInMilliseconds(final Date date, final int fragment); public static long getFragmentInSeconds(final Date date, final int fragment); public static long getFragmentInMinutes(final Date date, final int fragment); public static long getFragmentInHours(final Date date, final int fragment); public static long getFragmentInDays(final Date date, final int fragment); public static long getFragmentInMilliseconds(final Calendar calendar, final int fragment); public static long getFragmentInSeconds(final Calendar calendar, final int fragment); public static long getFragmentInMinutes(final Calendar calendar, final int fragment); public static long getFragmentInHours(final Calendar calendar, final int fragment); public static long getFragmentInDays(final Calendar calendar, final int fragment); private static long getFragment(final Date date, final int fragment, final int unit); private static long getFragment(final Calendar calendar, final int fragment, final int unit); public static boolean truncatedEquals(final Calendar cal1, final Calendar cal2, final int field); public static boolean truncatedEquals(final Date date1, final Date date2, final int field); public static int truncatedCompareTo(final Calendar cal1, final Calendar cal2, final int field); public static int truncatedCompareTo(final Date date1, final Date date2, final int field); private static long getMillisPerUnit(final int unit); public boolean hasNext(); public Calendar next(); public void remove(); long MILLIS_PER_SECOND=Optional[1000]; long MILLIS_PER_MINUTE=Optional[60 * MILLIS_PER_SECOND]; long MILLIS_PER_HOUR=Optional[60 * MILLIS_PER_MINUTE]; long MILLIS_PER_DAY=Optional[24 * MILLIS_PER_HOUR]; int SEMI_MONTH=Optional[1001]; int[][] fields=Optional[{ { Calendar.MILLISECOND }, { Calendar.SECOND }, { Calendar.MINUTE }, { Calendar.HOUR_OF_DAY, Calendar.HOUR }, { Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM /* Calendar.DAY_OF_YEAR, Calendar.DAY_OF_WEEK, Calendar.DAY_OF_WEEK_IN_MONTH */; }, { Calendar.MONTH, DateUtils.SEMI_MONTH }, { Calendar.YEAR }, { Calendar.ERA } }
public static String initials(final String str, final char... delimiters) { [EOL]     if (StringUtils.isEmpty(str)) { [EOL]         return str; [EOL]     } [EOL]     if (delimiters != null && delimiters.length == 0) { [EOL]         return ""; [EOL]     } [EOL]     final int strLen = str.length(); [EOL]     final char[] buf = new char[strLen / 2 + 1]; [EOL]     int count = 0; [EOL]     boolean lastWasGap = true; [EOL]     for (int i = 0; i < strLen; i++) { [EOL]         final char ch = str.charAt(i); [EOL]         if (isDelimiter(ch, delimiters)) { [EOL]             lastWasGap = true; [EOL]         } else if (lastWasGap) { [EOL]             buf[count++] = ch; [EOL]             lastWasGap = false; [EOL]         } else { [EOL]             continue; [EOL]         } [EOL]     } [EOL]     return new String(buf, 0, count); [EOL] }
@Override [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL]     for (final CharSequenceTranslator translator : translators) { [EOL]         final int consumed = translator.translate(input, index, out); [EOL]         if (consumed != 0) { [EOL]             return consumed; [EOL]         } [EOL]     } [EOL]     return 0; [EOL] }
@Override [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL]     for (final CharSequenceTranslator translator : translators) { [EOL]         final int consumed = translator.translate(input, index, out); [EOL]         if (consumed != 0) { [EOL]             return consumed; [EOL]         } [EOL]     } [EOL]     return 0; [EOL] }
public LocaleUtils() { [EOL]     super(); [EOL] }
public static Map<Object, Object> toMap(final Object[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     final Map<Object, Object> map = new HashMap<Object, Object>((int) (array.length * 1.5)); [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         final Object object = array[i]; [EOL]         if (object instanceof Map.Entry<?, ?>) { [EOL]             final Map.Entry<?, ?> entry = (Map.Entry<?, ?>) object; [EOL]             map.put(entry.getKey(), entry.getValue()); [EOL]         } else if (object instanceof Object[]) { [EOL]             final Object[] entry = (Object[]) object; [EOL]             if (entry.length < 2) { [EOL]                 throw new IllegalArgumentException("Array element " + i + ", '" + object + "', has a length less than 2"); [EOL]             } [EOL]             map.put(entry[0], entry[1]); [EOL]         } else { [EOL]             throw new IllegalArgumentException("Array element " + i + ", '" + object + "', is neither of type Map.Entry nor an Array"); [EOL]         } [EOL]     } [EOL]     return map; [EOL] }
public static Map<Object, Object> toMap(final Object[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     final Map<Object, Object> map = new HashMap<Object, Object>((int) (array.length * 1.5)); [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         final Object object = array[i]; [EOL]         if (object instanceof Map.Entry<?, ?>) { [EOL]             final Map.Entry<?, ?> entry = (Map.Entry<?, ?>) object; [EOL]             map.put(entry.getKey(), entry.getValue()); [EOL]         } else if (object instanceof Object[]) { [EOL]             final Object[] entry = (Object[]) object; [EOL]             if (entry.length < 2) { [EOL]                 throw new IllegalArgumentException("Array element " + i + ", '" + object + "', has a length less than 2"); [EOL]             } [EOL]             map.put(entry[0], entry[1]); [EOL]         } else { [EOL]             throw new IllegalArgumentException("Array element " + i + ", '" + object + "', is neither of type Map.Entry nor an Array"); [EOL]         } [EOL]     } [EOL]     return map; [EOL] }
public static Map<Object, Object> toMap(final Object[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     final Map<Object, Object> map = new HashMap<Object, Object>((int) (array.length * 1.5)); [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         final Object object = array[i]; [EOL]         if (object instanceof Map.Entry<?, ?>) { [EOL]             final Map.Entry<?, ?> entry = (Map.Entry<?, ?>) object; [EOL]             map.put(entry.getKey(), entry.getValue()); [EOL]         } else if (object instanceof Object[]) { [EOL]             final Object[] entry = (Object[]) object; [EOL]             if (entry.length < 2) { [EOL]                 throw new IllegalArgumentException("Array element " + i + ", '" + object + "', has a length less than 2"); [EOL]             } [EOL]             map.put(entry[0], entry[1]); [EOL]         } else { [EOL]             throw new IllegalArgumentException("Array element " + i + ", '" + object + "', is neither of type Map.Entry nor an Array"); [EOL]         } [EOL]     } [EOL]     return map; [EOL] }
public static Map<Object, Object> toMap(final Object[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     final Map<Object, Object> map = new HashMap<Object, Object>((int) (array.length * 1.5)); [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         final Object object = array[i]; [EOL]         if (object instanceof Map.Entry<?, ?>) { [EOL]             final Map.Entry<?, ?> entry = (Map.Entry<?, ?>) object; [EOL]             map.put(entry.getKey(), entry.getValue()); [EOL]         } else if (object instanceof Object[]) { [EOL]             final Object[] entry = (Object[]) object; [EOL]             if (entry.length < 2) { [EOL]                 throw new IllegalArgumentException("Array element " + i + ", '" + object + "', has a length less than 2"); [EOL]             } [EOL]             map.put(entry[0], entry[1]); [EOL]         } else { [EOL]             throw new IllegalArgumentException("Array element " + i + ", '" + object + "', is neither of type Map.Entry nor an Array"); [EOL]         } [EOL]     } [EOL]     return map; [EOL] }
public static Map<Object, Object> toMap(final Object[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     final Map<Object, Object> map = new HashMap<Object, Object>((int) (array.length * 1.5)); [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         final Object object = array[i]; [EOL]         if (object instanceof Map.Entry<?, ?>) { [EOL]             final Map.Entry<?, ?> entry = (Map.Entry<?, ?>) object; [EOL]             map.put(entry.getKey(), entry.getValue()); [EOL]         } else if (object instanceof Object[]) { [EOL]             final Object[] entry = (Object[]) object; [EOL]             if (entry.length < 2) { [EOL]                 throw new IllegalArgumentException("Array element " + i + ", '" + object + "', has a length less than 2"); [EOL]             } [EOL]             map.put(entry[0], entry[1]); [EOL]         } else { [EOL]             throw new IllegalArgumentException("Array element " + i + ", '" + object + "', is neither of type Map.Entry nor an Array"); [EOL]         } [EOL]     } [EOL]     return map; [EOL] }
public static Map<Object, Object> toMap(final Object[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     final Map<Object, Object> map = new HashMap<Object, Object>((int) (array.length * 1.5)); [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         final Object object = array[i]; [EOL]         if (object instanceof Map.Entry<?, ?>) { [EOL]             final Map.Entry<?, ?> entry = (Map.Entry<?, ?>) object; [EOL]             map.put(entry.getKey(), entry.getValue()); [EOL]         } else if (object instanceof Object[]) { [EOL]             final Object[] entry = (Object[]) object; [EOL]             if (entry.length < 2) { [EOL]                 throw new IllegalArgumentException("Array element " + i + ", '" + object + "', has a length less than 2"); [EOL]             } [EOL]             map.put(entry[0], entry[1]); [EOL]         } else { [EOL]             throw new IllegalArgumentException("Array element " + i + ", '" + object + "', is neither of type Map.Entry nor an Array"); [EOL]         } [EOL]     } [EOL]     return map; [EOL] }
public static <T> T[] toArray(final T... items) { [EOL]     return items; [EOL] }
public static <T> T[] toArray(final T... items) { [EOL]     return items; [EOL] }
public static <T> T[] toArray(final T... items) { [EOL]     return items; [EOL] }
public static <T> T[] toArray(final T... items) { [EOL]     return items; [EOL] }
public static float[] clone(final float[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     return array.clone(); [EOL] }
public static float[] clone(final float[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     return array.clone(); [EOL] }
public static float[] clone(final float[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     return array.clone(); [EOL] }
public static short[] nullToEmpty(final short[] array) { [EOL]     if (array == null || array.length == 0) { [EOL]         return EMPTY_SHORT_ARRAY; [EOL]     } [EOL]     return array; [EOL] }
public static short[] nullToEmpty(final short[] array) { [EOL]     if (array == null || array.length == 0) { [EOL]         return EMPTY_SHORT_ARRAY; [EOL]     } [EOL]     return array; [EOL] }
public static short[] nullToEmpty(final short[] array) { [EOL]     if (array == null || array.length == 0) { [EOL]         return EMPTY_SHORT_ARRAY; [EOL]     } [EOL]     return array; [EOL] }
public static Boolean[] nullToEmpty(final Boolean[] array) { [EOL]     if (array == null || array.length == 0) { [EOL]         return EMPTY_BOOLEAN_OBJECT_ARRAY; [EOL]     } [EOL]     return array; [EOL] }
public static Boolean[] nullToEmpty(final Boolean[] array) { [EOL]     if (array == null || array.length == 0) { [EOL]         return EMPTY_BOOLEAN_OBJECT_ARRAY; [EOL]     } [EOL]     return array; [EOL] }
public static Boolean[] nullToEmpty(final Boolean[] array) { [EOL]     if (array == null || array.length == 0) { [EOL]         return EMPTY_BOOLEAN_OBJECT_ARRAY; [EOL]     } [EOL]     return array; [EOL] }
public static long[] subarray(final long[] array, int startIndexInclusive, int endIndexExclusive) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     if (startIndexInclusive < 0) { [EOL]         startIndexInclusive = 0; [EOL]     } [EOL]     if (endIndexExclusive > array.length) { [EOL]         endIndexExclusive = array.length; [EOL]     } [EOL]     final int newSize = endIndexExclusive - startIndexInclusive; [EOL]     if (newSize <= 0) { [EOL]         return EMPTY_LONG_ARRAY; [EOL]     } [EOL]     final long[] subarray = new long[newSize]; [EOL]     System.arraycopy(array, startIndexInclusive, subarray, 0, newSize); [EOL]     return subarray; [EOL] }
public static boolean isSameLength(final byte[] array1, final byte[] array2) { [EOL]     if ((array1 == null && array2 != null && array2.length > 0) || (array2 == null && array1 != null && array1.length > 0) || (array1 != null && array2 != null && array1.length != array2.length)) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
public static boolean isSameLength(final byte[] array1, final byte[] array2) { [EOL]     if ((array1 == null && array2 != null && array2.length > 0) || (array2 == null && array1 != null && array1.length > 0) || (array1 != null && array2 != null && array1.length != array2.length)) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
public static boolean isSameLength(final byte[] array1, final byte[] array2) { [EOL]     if ((array1 == null && array2 != null && array2.length > 0) || (array2 == null && array1 != null && array1.length > 0) || (array1 != null && array2 != null && array1.length != array2.length)) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
public static boolean isSameLength(final byte[] array1, final byte[] array2) { [EOL]     if ((array1 == null && array2 != null && array2.length > 0) || (array2 == null && array1 != null && array1.length > 0) || (array1 != null && array2 != null && array1.length != array2.length)) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
public static boolean isSameLength(final byte[] array1, final byte[] array2) { [EOL]     if ((array1 == null && array2 != null && array2.length > 0) || (array2 == null && array1 != null && array1.length > 0) || (array1 != null && array2 != null && array1.length != array2.length)) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
public static boolean isSameLength(final double[] array1, final double[] array2) { [EOL]     if ((array1 == null && array2 != null && array2.length > 0) || (array2 == null && array1 != null && array1.length > 0) || (array1 != null && array2 != null && array1.length != array2.length)) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
public static boolean isSameLength(final double[] array1, final double[] array2) { [EOL]     if ((array1 == null && array2 != null && array2.length > 0) || (array2 == null && array1 != null && array1.length > 0) || (array1 != null && array2 != null && array1.length != array2.length)) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
public static boolean isSameLength(final double[] array1, final double[] array2) { [EOL]     if ((array1 == null && array2 != null && array2.length > 0) || (array2 == null && array1 != null && array1.length > 0) || (array1 != null && array2 != null && array1.length != array2.length)) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
public static boolean isSameLength(final double[] array1, final double[] array2) { [EOL]     if ((array1 == null && array2 != null && array2.length > 0) || (array2 == null && array1 != null && array1.length > 0) || (array1 != null && array2 != null && array1.length != array2.length)) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
public static boolean isSameLength(final double[] array1, final double[] array2) { [EOL]     if ((array1 == null && array2 != null && array2.length > 0) || (array2 == null && array1 != null && array1.length > 0) || (array1 != null && array2 != null && array1.length != array2.length)) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
public static boolean isSameLength(final float[] array1, final float[] array2) { [EOL]     if ((array1 == null && array2 != null && array2.length > 0) || (array2 == null && array1 != null && array1.length > 0) || (array1 != null && array2 != null && array1.length != array2.length)) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
public static void reverse(final int[] array) { [EOL]     if (array == null) { [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     int j = array.length - 1; [EOL]     int tmp; [EOL]     while (j > i) { [EOL]         tmp = array[j]; [EOL]         array[j] = array[i]; [EOL]         array[i] = tmp; [EOL]         j--; [EOL]         i++; [EOL]     } [EOL] }
public static void reverse(final int[] array) { [EOL]     if (array == null) { [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     int j = array.length - 1; [EOL]     int tmp; [EOL]     while (j > i) { [EOL]         tmp = array[j]; [EOL]         array[j] = array[i]; [EOL]         array[i] = tmp; [EOL]         j--; [EOL]         i++; [EOL]     } [EOL] }
public static void reverse(final int[] array) { [EOL]     if (array == null) { [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     int j = array.length - 1; [EOL]     int tmp; [EOL]     while (j > i) { [EOL]         tmp = array[j]; [EOL]         array[j] = array[i]; [EOL]         array[i] = tmp; [EOL]         j--; [EOL]         i++; [EOL]     } [EOL] }
public static void reverse(final int[] array) { [EOL]     if (array == null) { [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     int j = array.length - 1; [EOL]     int tmp; [EOL]     while (j > i) { [EOL]         tmp = array[j]; [EOL]         array[j] = array[i]; [EOL]         array[i] = tmp; [EOL]         j--; [EOL]         i++; [EOL]     } [EOL] }
public static int indexOf(final Object[] array, final Object objectToFind) { [EOL]     return indexOf(array, objectToFind, 0); [EOL] }
public static int indexOf(final Object[] array, final Object objectToFind) { [EOL]     return indexOf(array, objectToFind, 0); [EOL] }
public static int indexOf(final Object[] array, final Object objectToFind) { [EOL]     return indexOf(array, objectToFind, 0); [EOL] }
public static int indexOf(final Object[] array, final Object objectToFind) { [EOL]     return indexOf(array, objectToFind, 0); [EOL] }
public static int indexOf(final Object[] array, final Object objectToFind, int startIndex) { [EOL]     if (array == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     if (objectToFind == null) { [EOL]         for (int i = startIndex; i < array.length; i++) { [EOL]             if (array[i] == null) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]     } else if (array.getClass().getComponentType().isInstance(objectToFind)) { [EOL]         for (int i = startIndex; i < array.length; i++) { [EOL]             if (objectToFind.equals(array[i])) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int indexOf(final Object[] array, final Object objectToFind, int startIndex) { [EOL]     if (array == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     if (objectToFind == null) { [EOL]         for (int i = startIndex; i < array.length; i++) { [EOL]             if (array[i] == null) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]     } else if (array.getClass().getComponentType().isInstance(objectToFind)) { [EOL]         for (int i = startIndex; i < array.length; i++) { [EOL]             if (objectToFind.equals(array[i])) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int indexOf(final Object[] array, final Object objectToFind, int startIndex) { [EOL]     if (array == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     if (objectToFind == null) { [EOL]         for (int i = startIndex; i < array.length; i++) { [EOL]             if (array[i] == null) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]     } else if (array.getClass().getComponentType().isInstance(objectToFind)) { [EOL]         for (int i = startIndex; i < array.length; i++) { [EOL]             if (objectToFind.equals(array[i])) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int indexOf(final Object[] array, final Object objectToFind, int startIndex) { [EOL]     if (array == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     if (objectToFind == null) { [EOL]         for (int i = startIndex; i < array.length; i++) { [EOL]             if (array[i] == null) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]     } else if (array.getClass().getComponentType().isInstance(objectToFind)) { [EOL]         for (int i = startIndex; i < array.length; i++) { [EOL]             if (objectToFind.equals(array[i])) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int indexOf(final Object[] array, final Object objectToFind, int startIndex) { [EOL]     if (array == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     if (objectToFind == null) { [EOL]         for (int i = startIndex; i < array.length; i++) { [EOL]             if (array[i] == null) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]     } else if (array.getClass().getComponentType().isInstance(objectToFind)) { [EOL]         for (int i = startIndex; i < array.length; i++) { [EOL]             if (objectToFind.equals(array[i])) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int indexOf(final Object[] array, final Object objectToFind, int startIndex) { [EOL]     if (array == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     if (objectToFind == null) { [EOL]         for (int i = startIndex; i < array.length; i++) { [EOL]             if (array[i] == null) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]     } else if (array.getClass().getComponentType().isInstance(objectToFind)) { [EOL]         for (int i = startIndex; i < array.length; i++) { [EOL]             if (objectToFind.equals(array[i])) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int indexOf(final Object[] array, final Object objectToFind, int startIndex) { [EOL]     if (array == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     if (objectToFind == null) { [EOL]         for (int i = startIndex; i < array.length; i++) { [EOL]             if (array[i] == null) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]     } else if (array.getClass().getComponentType().isInstance(objectToFind)) { [EOL]         for (int i = startIndex; i < array.length; i++) { [EOL]             if (objectToFind.equals(array[i])) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int lastIndexOf(final short[] array, final short valueToFind) { [EOL]     return lastIndexOf(array, valueToFind, Integer.MAX_VALUE); [EOL] }
public static int lastIndexOf(final short[] array, final short valueToFind) { [EOL]     return lastIndexOf(array, valueToFind, Integer.MAX_VALUE); [EOL] }
public static int lastIndexOf(final short[] array, final short valueToFind) { [EOL]     return lastIndexOf(array, valueToFind, Integer.MAX_VALUE); [EOL] }
public static int lastIndexOf(final short[] array, final short valueToFind) { [EOL]     return lastIndexOf(array, valueToFind, Integer.MAX_VALUE); [EOL] }
public static int lastIndexOf(final short[] array, final short valueToFind, int startIndex) { [EOL]     if (array == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int lastIndexOf(final short[] array, final short valueToFind, int startIndex) { [EOL]     if (array == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int lastIndexOf(final short[] array, final short valueToFind, int startIndex) { [EOL]     if (array == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int lastIndexOf(final short[] array, final short valueToFind, int startIndex) { [EOL]     if (array == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int lastIndexOf(final short[] array, final short valueToFind, int startIndex) { [EOL]     if (array == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static boolean contains(final short[] array, final short valueToFind) { [EOL]     return indexOf(array, valueToFind) != INDEX_NOT_FOUND; [EOL] }
public static boolean contains(final short[] array, final short valueToFind) { [EOL]     return indexOf(array, valueToFind) != INDEX_NOT_FOUND; [EOL] }
public static boolean contains(final short[] array, final short valueToFind) { [EOL]     return indexOf(array, valueToFind) != INDEX_NOT_FOUND; [EOL] }
public static boolean contains(final short[] array, final short valueToFind) { [EOL]     return indexOf(array, valueToFind) != INDEX_NOT_FOUND; [EOL] }
public static boolean contains(final char[] array, final char valueToFind) { [EOL]     return indexOf(array, valueToFind) != INDEX_NOT_FOUND; [EOL] }
public static boolean contains(final char[] array, final char valueToFind) { [EOL]     return indexOf(array, valueToFind) != INDEX_NOT_FOUND; [EOL] }
public static boolean contains(final char[] array, final char valueToFind) { [EOL]     return indexOf(array, valueToFind) != INDEX_NOT_FOUND; [EOL] }
public static boolean contains(final char[] array, final char valueToFind) { [EOL]     return indexOf(array, valueToFind) != INDEX_NOT_FOUND; [EOL] }
public static int indexOf(final byte[] array, final byte valueToFind, int startIndex) { [EOL]     if (array == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     for (int i = startIndex; i < array.length; i++) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int indexOf(final byte[] array, final byte valueToFind, int startIndex) { [EOL]     if (array == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     for (int i = startIndex; i < array.length; i++) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int indexOf(final byte[] array, final byte valueToFind, int startIndex) { [EOL]     if (array == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     for (int i = startIndex; i < array.length; i++) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int indexOf(final byte[] array, final byte valueToFind, int startIndex) { [EOL]     if (array == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     for (int i = startIndex; i < array.length; i++) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int indexOf(final byte[] array, final byte valueToFind, int startIndex) { [EOL]     if (array == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     for (int i = startIndex; i < array.length; i++) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int indexOf(final double[] array, final double valueToFind, final double tolerance) { [EOL]     return indexOf(array, valueToFind, 0, tolerance); [EOL] }
public static int indexOf(final double[] array, final double valueToFind, final double tolerance) { [EOL]     return indexOf(array, valueToFind, 0, tolerance); [EOL] }
public static int indexOf(final double[] array, final double valueToFind, final double tolerance) { [EOL]     return indexOf(array, valueToFind, 0, tolerance); [EOL] }
public static int indexOf(final double[] array, final double valueToFind, final double tolerance) { [EOL]     return indexOf(array, valueToFind, 0, tolerance); [EOL] }
public static int indexOf(final double[] array, final double valueToFind, final double tolerance) { [EOL]     return indexOf(array, valueToFind, 0, tolerance); [EOL] }
public static int indexOf(final double[] array, final double valueToFind, final double tolerance) { [EOL]     return indexOf(array, valueToFind, 0, tolerance); [EOL] }
public static int indexOf(final double[] array, final double valueToFind, int startIndex, final double tolerance) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     final double min = valueToFind - tolerance; [EOL]     final double max = valueToFind + tolerance; [EOL]     for (int i = startIndex; i < array.length; i++) { [EOL]         if (array[i] >= min && array[i] <= max) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int indexOf(final double[] array, final double valueToFind, int startIndex, final double tolerance) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     final double min = valueToFind - tolerance; [EOL]     final double max = valueToFind + tolerance; [EOL]     for (int i = startIndex; i < array.length; i++) { [EOL]         if (array[i] >= min && array[i] <= max) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int indexOf(final double[] array, final double valueToFind, int startIndex, final double tolerance) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     final double min = valueToFind - tolerance; [EOL]     final double max = valueToFind + tolerance; [EOL]     for (int i = startIndex; i < array.length; i++) { [EOL]         if (array[i] >= min && array[i] <= max) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int indexOf(final double[] array, final double valueToFind, int startIndex, final double tolerance) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     final double min = valueToFind - tolerance; [EOL]     final double max = valueToFind + tolerance; [EOL]     for (int i = startIndex; i < array.length; i++) { [EOL]         if (array[i] >= min && array[i] <= max) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int indexOf(final double[] array, final double valueToFind, int startIndex, final double tolerance) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     final double min = valueToFind - tolerance; [EOL]     final double max = valueToFind + tolerance; [EOL]     for (int i = startIndex; i < array.length; i++) { [EOL]         if (array[i] >= min && array[i] <= max) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int indexOf(final double[] array, final double valueToFind, int startIndex, final double tolerance) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     final double min = valueToFind - tolerance; [EOL]     final double max = valueToFind + tolerance; [EOL]     for (int i = startIndex; i < array.length; i++) { [EOL]         if (array[i] >= min && array[i] <= max) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int lastIndexOf(final boolean[] array, final boolean valueToFind) { [EOL]     return lastIndexOf(array, valueToFind, Integer.MAX_VALUE); [EOL] }
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static char[] toPrimitive(final Character[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_CHAR_ARRAY; [EOL]     } [EOL]     final char[] result = new char[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         result[i] = array[i].charValue(); [EOL]     } [EOL]     return result; [EOL] }
public static char[] toPrimitive(final Character[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_CHAR_ARRAY; [EOL]     } [EOL]     final char[] result = new char[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         result[i] = array[i].charValue(); [EOL]     } [EOL]     return result; [EOL] }
public static char[] toPrimitive(final Character[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_CHAR_ARRAY; [EOL]     } [EOL]     final char[] result = new char[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         result[i] = array[i].charValue(); [EOL]     } [EOL]     return result; [EOL] }
public static Character[] toObject(final char[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_CHARACTER_OBJECT_ARRAY; [EOL]     } [EOL]     final Character[] result = new Character[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         result[i] = Character.valueOf(array[i]); [EOL]     } [EOL]     return result; [EOL] }
public static Character[] toObject(final char[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_CHARACTER_OBJECT_ARRAY; [EOL]     } [EOL]     final Character[] result = new Character[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         result[i] = Character.valueOf(array[i]); [EOL]     } [EOL]     return result; [EOL] }
public static Character[] toObject(final char[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_CHARACTER_OBJECT_ARRAY; [EOL]     } [EOL]     final Character[] result = new Character[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         result[i] = Character.valueOf(array[i]); [EOL]     } [EOL]     return result; [EOL] }
public static byte[] toPrimitive(final Byte[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_BYTE_ARRAY; [EOL]     } [EOL]     final byte[] result = new byte[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         result[i] = array[i].byteValue(); [EOL]     } [EOL]     return result; [EOL] }
public static byte[] toPrimitive(final Byte[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_BYTE_ARRAY; [EOL]     } [EOL]     final byte[] result = new byte[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         result[i] = array[i].byteValue(); [EOL]     } [EOL]     return result; [EOL] }
public static byte[] toPrimitive(final Byte[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_BYTE_ARRAY; [EOL]     } [EOL]     final byte[] result = new byte[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         result[i] = array[i].byteValue(); [EOL]     } [EOL]     return result; [EOL] }
public static double[] toPrimitive(final Double[] array, final double valueForNull) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_DOUBLE_ARRAY; [EOL]     } [EOL]     final double[] result = new double[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         final Double b = array[i]; [EOL]         result[i] = (b == null ? valueForNull : b.doubleValue()); [EOL]     } [EOL]     return result; [EOL] }
public static double[] toPrimitive(final Double[] array, final double valueForNull) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_DOUBLE_ARRAY; [EOL]     } [EOL]     final double[] result = new double[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         final Double b = array[i]; [EOL]         result[i] = (b == null ? valueForNull : b.doubleValue()); [EOL]     } [EOL]     return result; [EOL] }
public static double[] toPrimitive(final Double[] array, final double valueForNull) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_DOUBLE_ARRAY; [EOL]     } [EOL]     final double[] result = new double[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         final Double b = array[i]; [EOL]         result[i] = (b == null ? valueForNull : b.doubleValue()); [EOL]     } [EOL]     return result; [EOL] }
public static double[] toPrimitive(final Double[] array, final double valueForNull) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_DOUBLE_ARRAY; [EOL]     } [EOL]     final double[] result = new double[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         final Double b = array[i]; [EOL]         result[i] = (b == null ? valueForNull : b.doubleValue()); [EOL]     } [EOL]     return result; [EOL] }
public static Double[] toObject(final double[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_DOUBLE_OBJECT_ARRAY; [EOL]     } [EOL]     final Double[] result = new Double[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         result[i] = Double.valueOf(array[i]); [EOL]     } [EOL]     return result; [EOL] }
public static Double[] toObject(final double[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_DOUBLE_OBJECT_ARRAY; [EOL]     } [EOL]     final Double[] result = new Double[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         result[i] = Double.valueOf(array[i]); [EOL]     } [EOL]     return result; [EOL] }
public static Double[] toObject(final double[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_DOUBLE_OBJECT_ARRAY; [EOL]     } [EOL]     final Double[] result = new Double[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         result[i] = Double.valueOf(array[i]); [EOL]     } [EOL]     return result; [EOL] }
public static Float[] toObject(final float[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_FLOAT_OBJECT_ARRAY; [EOL]     } [EOL]     final Float[] result = new Float[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         result[i] = Float.valueOf(array[i]); [EOL]     } [EOL]     return result; [EOL] }
public static Float[] toObject(final float[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_FLOAT_OBJECT_ARRAY; [EOL]     } [EOL]     final Float[] result = new Float[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         result[i] = Float.valueOf(array[i]); [EOL]     } [EOL]     return result; [EOL] }
public static Float[] toObject(final float[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_FLOAT_OBJECT_ARRAY; [EOL]     } [EOL]     final Float[] result = new Float[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         result[i] = Float.valueOf(array[i]); [EOL]     } [EOL]     return result; [EOL] }
public static boolean[] toPrimitive(final Boolean[] array, final boolean valueForNull) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_BOOLEAN_ARRAY; [EOL]     } [EOL]     final boolean[] result = new boolean[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         final Boolean b = array[i]; [EOL]         result[i] = (b == null ? valueForNull : b.booleanValue()); [EOL]     } [EOL]     return result; [EOL] }
public static boolean[] toPrimitive(final Boolean[] array, final boolean valueForNull) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_BOOLEAN_ARRAY; [EOL]     } [EOL]     final boolean[] result = new boolean[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         final Boolean b = array[i]; [EOL]         result[i] = (b == null ? valueForNull : b.booleanValue()); [EOL]     } [EOL]     return result; [EOL] }
public static boolean[] toPrimitive(final Boolean[] array, final boolean valueForNull) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_BOOLEAN_ARRAY; [EOL]     } [EOL]     final boolean[] result = new boolean[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         final Boolean b = array[i]; [EOL]         result[i] = (b == null ? valueForNull : b.booleanValue()); [EOL]     } [EOL]     return result; [EOL] }
public static boolean[] toPrimitive(final Boolean[] array, final boolean valueForNull) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_BOOLEAN_ARRAY; [EOL]     } [EOL]     final boolean[] result = new boolean[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         final Boolean b = array[i]; [EOL]         result[i] = (b == null ? valueForNull : b.booleanValue()); [EOL]     } [EOL]     return result; [EOL] }
public static boolean isNotEmpty(final long[] array) { [EOL]     return (array != null && array.length != 0); [EOL] }
public static boolean isNotEmpty(final long[] array) { [EOL]     return (array != null && array.length != 0); [EOL] }
public static boolean isNotEmpty(final long[] array) { [EOL]     return (array != null && array.length != 0); [EOL] }
public static boolean isNotEmpty(final short[] array) { [EOL]     return (array != null && array.length != 0); [EOL] }
public static boolean isNotEmpty(final short[] array) { [EOL]     return (array != null && array.length != 0); [EOL] }
public static boolean isNotEmpty(final short[] array) { [EOL]     return (array != null && array.length != 0); [EOL] }
public static boolean isNotEmpty(final char[] array) { [EOL]     return (array != null && array.length != 0); [EOL] }
public static boolean isNotEmpty(final char[] array) { [EOL]     return (array != null && array.length != 0); [EOL] }
public static boolean isNotEmpty(final char[] array) { [EOL]     return (array != null && array.length != 0); [EOL] }
public static boolean isNotEmpty(final byte[] array) { [EOL]     return (array != null && array.length != 0); [EOL] }
public static boolean isNotEmpty(final byte[] array) { [EOL]     return (array != null && array.length != 0); [EOL] }
public static boolean isNotEmpty(final byte[] array) { [EOL]     return (array != null && array.length != 0); [EOL] }
public static boolean isNotEmpty(final double[] array) { [EOL]     return (array != null && array.length != 0); [EOL] }
public static boolean isNotEmpty(final double[] array) { [EOL]     return (array != null && array.length != 0); [EOL] }
public static boolean isNotEmpty(final double[] array) { [EOL]     return (array != null && array.length != 0); [EOL] }
public static boolean isNotEmpty(final float[] array) { [EOL]     return (array != null && array.length != 0); [EOL] }
public static boolean isNotEmpty(final float[] array) { [EOL]     return (array != null && array.length != 0); [EOL] }
public static boolean isNotEmpty(final float[] array) { [EOL]     return (array != null && array.length != 0); [EOL] }
public static boolean isNotEmpty(final boolean[] array) { [EOL]     return (array != null && array.length != 0); [EOL] }
public static boolean isNotEmpty(final boolean[] array) { [EOL]     return (array != null && array.length != 0); [EOL] }
public static boolean isNotEmpty(final boolean[] array) { [EOL]     return (array != null && array.length != 0); [EOL] }
public static char[] add(final char[] array, final char element) { [EOL]     final char[] newArray = (char[]) copyArrayGrow1(array, Character.TYPE); [EOL]     newArray[newArray.length - 1] = element; [EOL]     return newArray; [EOL] }
public static char[] add(final char[] array, final char element) { [EOL]     final char[] newArray = (char[]) copyArrayGrow1(array, Character.TYPE); [EOL]     newArray[newArray.length - 1] = element; [EOL]     return newArray; [EOL] }
public static char[] add(final char[] array, final char element) { [EOL]     final char[] newArray = (char[]) copyArrayGrow1(array, Character.TYPE); [EOL]     newArray[newArray.length - 1] = element; [EOL]     return newArray; [EOL] }
public static double[] add(final double[] array, final double element) { [EOL]     final double[] newArray = (double[]) copyArrayGrow1(array, Double.TYPE); [EOL]     newArray[newArray.length - 1] = element; [EOL]     return newArray; [EOL] }
public static boolean[] remove(final boolean[] array, final int index) { [EOL]     return (boolean[]) remove((Object) array, index); [EOL] }
public static boolean[] remove(final boolean[] array, final int index) { [EOL]     return (boolean[]) remove((Object) array, index); [EOL] }
public static boolean[] remove(final boolean[] array, final int index) { [EOL]     return (boolean[]) remove((Object) array, index); [EOL] }
public static boolean[] remove(final boolean[] array, final int index) { [EOL]     return (boolean[]) remove((Object) array, index); [EOL] }
public static boolean[] remove(final boolean[] array, final int index) { [EOL]     return (boolean[]) remove((Object) array, index); [EOL] }
public static boolean[] remove(final boolean[] array, final int index) { [EOL]     return (boolean[]) remove((Object) array, index); [EOL] }
public static int[] remove(final int[] array, final int index) { [EOL]     return (int[]) remove((Object) array, index); [EOL] }
public static int[] remove(final int[] array, final int index) { [EOL]     return (int[]) remove((Object) array, index); [EOL] }
public static int[] remove(final int[] array, final int index) { [EOL]     return (int[]) remove((Object) array, index); [EOL] }
public static int[] remove(final int[] array, final int index) { [EOL]     return (int[]) remove((Object) array, index); [EOL] }
public static int[] remove(final int[] array, final int index) { [EOL]     return (int[]) remove((Object) array, index); [EOL] }
public static int[] remove(final int[] array, final int index) { [EOL]     return (int[]) remove((Object) array, index); [EOL] }
public static long[] removeElements(final long[] array, final long... values) { [EOL]     if (isEmpty(array) || isEmpty(values)) { [EOL]         return clone(array); [EOL]     } [EOL]     final HashMap<Long, MutableInt> occurrences = new HashMap<Long, MutableInt>(values.length); [EOL]     for (final long v : values) { [EOL]         final Long boxed = Long.valueOf(v); [EOL]         final MutableInt count = occurrences.get(boxed); [EOL]         if (count == null) { [EOL]             occurrences.put(boxed, new MutableInt(1)); [EOL]         } else { [EOL]             count.increment(); [EOL]         } [EOL]     } [EOL]     final BitSet toRemove = new BitSet(); [EOL]     for (final Map.Entry<Long, MutableInt> e : occurrences.entrySet()) { [EOL]         final Long v = e.getKey(); [EOL]         int found = 0; [EOL]         for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) { [EOL]             found = indexOf(array, v.longValue(), found); [EOL]             if (found < 0) { [EOL]                 break; [EOL]             } [EOL]             toRemove.set(found++); [EOL]         } [EOL]     } [EOL]     return (long[]) removeAll(array, toRemove); [EOL] }
public static long[] removeElements(final long[] array, final long... values) { [EOL]     if (isEmpty(array) || isEmpty(values)) { [EOL]         return clone(array); [EOL]     } [EOL]     final HashMap<Long, MutableInt> occurrences = new HashMap<Long, MutableInt>(values.length); [EOL]     for (final long v : values) { [EOL]         final Long boxed = Long.valueOf(v); [EOL]         final MutableInt count = occurrences.get(boxed); [EOL]         if (count == null) { [EOL]             occurrences.put(boxed, new MutableInt(1)); [EOL]         } else { [EOL]             count.increment(); [EOL]         } [EOL]     } [EOL]     final BitSet toRemove = new BitSet(); [EOL]     for (final Map.Entry<Long, MutableInt> e : occurrences.entrySet()) { [EOL]         final Long v = e.getKey(); [EOL]         int found = 0; [EOL]         for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) { [EOL]             found = indexOf(array, v.longValue(), found); [EOL]             if (found < 0) { [EOL]                 break; [EOL]             } [EOL]             toRemove.set(found++); [EOL]         } [EOL]     } [EOL]     return (long[]) removeAll(array, toRemove); [EOL] }
public static long[] removeElements(final long[] array, final long... values) { [EOL]     if (isEmpty(array) || isEmpty(values)) { [EOL]         return clone(array); [EOL]     } [EOL]     final HashMap<Long, MutableInt> occurrences = new HashMap<Long, MutableInt>(values.length); [EOL]     for (final long v : values) { [EOL]         final Long boxed = Long.valueOf(v); [EOL]         final MutableInt count = occurrences.get(boxed); [EOL]         if (count == null) { [EOL]             occurrences.put(boxed, new MutableInt(1)); [EOL]         } else { [EOL]             count.increment(); [EOL]         } [EOL]     } [EOL]     final BitSet toRemove = new BitSet(); [EOL]     for (final Map.Entry<Long, MutableInt> e : occurrences.entrySet()) { [EOL]         final Long v = e.getKey(); [EOL]         int found = 0; [EOL]         for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) { [EOL]             found = indexOf(array, v.longValue(), found); [EOL]             if (found < 0) { [EOL]                 break; [EOL]             } [EOL]             toRemove.set(found++); [EOL]         } [EOL]     } [EOL]     return (long[]) removeAll(array, toRemove); [EOL] }
public static long[] removeElements(final long[] array, final long... values) { [EOL]     if (isEmpty(array) || isEmpty(values)) { [EOL]         return clone(array); [EOL]     } [EOL]     final HashMap<Long, MutableInt> occurrences = new HashMap<Long, MutableInt>(values.length); [EOL]     for (final long v : values) { [EOL]         final Long boxed = Long.valueOf(v); [EOL]         final MutableInt count = occurrences.get(boxed); [EOL]         if (count == null) { [EOL]             occurrences.put(boxed, new MutableInt(1)); [EOL]         } else { [EOL]             count.increment(); [EOL]         } [EOL]     } [EOL]     final BitSet toRemove = new BitSet(); [EOL]     for (final Map.Entry<Long, MutableInt> e : occurrences.entrySet()) { [EOL]         final Long v = e.getKey(); [EOL]         int found = 0; [EOL]         for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) { [EOL]             found = indexOf(array, v.longValue(), found); [EOL]             if (found < 0) { [EOL]                 break; [EOL]             } [EOL]             toRemove.set(found++); [EOL]         } [EOL]     } [EOL]     return (long[]) removeAll(array, toRemove); [EOL] }
public static long[] removeElements(final long[] array, final long... values) { [EOL]     if (isEmpty(array) || isEmpty(values)) { [EOL]         return clone(array); [EOL]     } [EOL]     final HashMap<Long, MutableInt> occurrences = new HashMap<Long, MutableInt>(values.length); [EOL]     for (final long v : values) { [EOL]         final Long boxed = Long.valueOf(v); [EOL]         final MutableInt count = occurrences.get(boxed); [EOL]         if (count == null) { [EOL]             occurrences.put(boxed, new MutableInt(1)); [EOL]         } else { [EOL]             count.increment(); [EOL]         } [EOL]     } [EOL]     final BitSet toRemove = new BitSet(); [EOL]     for (final Map.Entry<Long, MutableInt> e : occurrences.entrySet()) { [EOL]         final Long v = e.getKey(); [EOL]         int found = 0; [EOL]         for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) { [EOL]             found = indexOf(array, v.longValue(), found); [EOL]             if (found < 0) { [EOL]                 break; [EOL]             } [EOL]             toRemove.set(found++); [EOL]         } [EOL]     } [EOL]     return (long[]) removeAll(array, toRemove); [EOL] }
public static long[] removeElements(final long[] array, final long... values) { [EOL]     if (isEmpty(array) || isEmpty(values)) { [EOL]         return clone(array); [EOL]     } [EOL]     final HashMap<Long, MutableInt> occurrences = new HashMap<Long, MutableInt>(values.length); [EOL]     for (final long v : values) { [EOL]         final Long boxed = Long.valueOf(v); [EOL]         final MutableInt count = occurrences.get(boxed); [EOL]         if (count == null) { [EOL]             occurrences.put(boxed, new MutableInt(1)); [EOL]         } else { [EOL]             count.increment(); [EOL]         } [EOL]     } [EOL]     final BitSet toRemove = new BitSet(); [EOL]     for (final Map.Entry<Long, MutableInt> e : occurrences.entrySet()) { [EOL]         final Long v = e.getKey(); [EOL]         int found = 0; [EOL]         for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) { [EOL]             found = indexOf(array, v.longValue(), found); [EOL]             if (found < 0) { [EOL]                 break; [EOL]             } [EOL]             toRemove.set(found++); [EOL]         } [EOL]     } [EOL]     return (long[]) removeAll(array, toRemove); [EOL] }
public static long[] removeElements(final long[] array, final long... values) { [EOL]     if (isEmpty(array) || isEmpty(values)) { [EOL]         return clone(array); [EOL]     } [EOL]     final HashMap<Long, MutableInt> occurrences = new HashMap<Long, MutableInt>(values.length); [EOL]     for (final long v : values) { [EOL]         final Long boxed = Long.valueOf(v); [EOL]         final MutableInt count = occurrences.get(boxed); [EOL]         if (count == null) { [EOL]             occurrences.put(boxed, new MutableInt(1)); [EOL]         } else { [EOL]             count.increment(); [EOL]         } [EOL]     } [EOL]     final BitSet toRemove = new BitSet(); [EOL]     for (final Map.Entry<Long, MutableInt> e : occurrences.entrySet()) { [EOL]         final Long v = e.getKey(); [EOL]         int found = 0; [EOL]         for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) { [EOL]             found = indexOf(array, v.longValue(), found); [EOL]             if (found < 0) { [EOL]                 break; [EOL]             } [EOL]             toRemove.set(found++); [EOL]         } [EOL]     } [EOL]     return (long[]) removeAll(array, toRemove); [EOL] }
public static long[] removeElements(final long[] array, final long... values) { [EOL]     if (isEmpty(array) || isEmpty(values)) { [EOL]         return clone(array); [EOL]     } [EOL]     final HashMap<Long, MutableInt> occurrences = new HashMap<Long, MutableInt>(values.length); [EOL]     for (final long v : values) { [EOL]         final Long boxed = Long.valueOf(v); [EOL]         final MutableInt count = occurrences.get(boxed); [EOL]         if (count == null) { [EOL]             occurrences.put(boxed, new MutableInt(1)); [EOL]         } else { [EOL]             count.increment(); [EOL]         } [EOL]     } [EOL]     final BitSet toRemove = new BitSet(); [EOL]     for (final Map.Entry<Long, MutableInt> e : occurrences.entrySet()) { [EOL]         final Long v = e.getKey(); [EOL]         int found = 0; [EOL]         for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) { [EOL]             found = indexOf(array, v.longValue(), found); [EOL]             if (found < 0) { [EOL]                 break; [EOL]             } [EOL]             toRemove.set(found++); [EOL]         } [EOL]     } [EOL]     return (long[]) removeAll(array, toRemove); [EOL] }
public static boolean[] removeAll(final boolean[] array, final int... indices) { [EOL]     return (boolean[]) removeAll((Object) array, clone(indices)); [EOL] }
public static boolean[] removeAll(final boolean[] array, final int... indices) { [EOL]     return (boolean[]) removeAll((Object) array, clone(indices)); [EOL] }
public static boolean[] removeAll(final boolean[] array, final int... indices) { [EOL]     return (boolean[]) removeAll((Object) array, clone(indices)); [EOL] }
public static boolean[] removeAll(final boolean[] array, final int... indices) { [EOL]     return (boolean[]) removeAll((Object) array, clone(indices)); [EOL] }
public static boolean[] removeAll(final boolean[] array, final int... indices) { [EOL]     return (boolean[]) removeAll((Object) array, clone(indices)); [EOL] }
public static boolean[] removeAll(final boolean[] array, final int... indices) { [EOL]     return (boolean[]) removeAll((Object) array, clone(indices)); [EOL] }
public static boolean[] removeAll(final boolean[] array, final int... indices) { [EOL]     return (boolean[]) removeAll((Object) array, clone(indices)); [EOL] }
public static boolean[] removeAll(final boolean[] array, final int... indices) { [EOL]     return (boolean[]) removeAll((Object) array, clone(indices)); [EOL] }
public static boolean[] removeAll(final boolean[] array, final int... indices) { [EOL]     return (boolean[]) removeAll((Object) array, clone(indices)); [EOL] }
public static Type getArrayComponentType(final Type type) { [EOL]     if (type instanceof Class<?>) { [EOL]         final Class<?> clazz = (Class<?>) type; [EOL]         return clazz.isArray() ? clazz.getComponentType() : null; [EOL]     } [EOL]     if (type instanceof GenericArrayType) { [EOL]         return ((GenericArrayType) type).getGenericComponentType(); [EOL]     } [EOL]     return null; [EOL] }
public static Type getArrayComponentType(final Type type) { [EOL]     if (type instanceof Class<?>) { [EOL]         final Class<?> clazz = (Class<?>) type; [EOL]         return clazz.isArray() ? clazz.getComponentType() : null; [EOL]     } [EOL]     if (type instanceof GenericArrayType) { [EOL]         return ((GenericArrayType) type).getGenericComponentType(); [EOL]     } [EOL]     return null; [EOL] }
public static Type getArrayComponentType(final Type type) { [EOL]     if (type instanceof Class<?>) { [EOL]         final Class<?> clazz = (Class<?>) type; [EOL]         return clazz.isArray() ? clazz.getComponentType() : null; [EOL]     } [EOL]     if (type instanceof GenericArrayType) { [EOL]         return ((GenericArrayType) type).getGenericComponentType(); [EOL]     } [EOL]     return null; [EOL] }
public static Type getArrayComponentType(final Type type) { [EOL]     if (type instanceof Class<?>) { [EOL]         final Class<?> clazz = (Class<?>) type; [EOL]         return clazz.isArray() ? clazz.getComponentType() : null; [EOL]     } [EOL]     if (type instanceof GenericArrayType) { [EOL]         return ((GenericArrayType) type).getGenericComponentType(); [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public String getFormattedExceptionMessage(final String baseMessage) { [EOL]     final StringBuilder buffer = new StringBuilder(256); [EOL]     if (baseMessage != null) { [EOL]         buffer.append(baseMessage); [EOL]     } [EOL]     if (contextValues.size() > 0) { [EOL]         if (buffer.length() > 0) { [EOL]             buffer.append('\n'); [EOL]         } [EOL]         buffer.append("Exception Context:\n"); [EOL]         int i = 0; [EOL]         for (final Pair<String, Object> pair : contextValues) { [EOL]             buffer.append("\t["); [EOL]             buffer.append(++i); [EOL]             buffer.append(':'); [EOL]             buffer.append(pair.getKey()); [EOL]             buffer.append("="); [EOL]             final Object value = pair.getValue(); [EOL]             if (value == null) { [EOL]                 buffer.append("null"); [EOL]             } else { [EOL]                 String valueStr; [EOL]                 try { [EOL]                     valueStr = value.toString(); [EOL]                 } catch (final Exception e) { [EOL]                     valueStr = "Exception thrown on toString(): " + ExceptionUtils.getStackTrace(e); [EOL]                 } [EOL]                 buffer.append(valueStr); [EOL]             } [EOL]             buffer.append("]\n"); [EOL]         } [EOL]         buffer.append("---------------------------------"); [EOL]     } [EOL]     return buffer.toString(); [EOL] }
@Override [EOL] public String getFormattedExceptionMessage(final String baseMessage) { [EOL]     final StringBuilder buffer = new StringBuilder(256); [EOL]     if (baseMessage != null) { [EOL]         buffer.append(baseMessage); [EOL]     } [EOL]     if (contextValues.size() > 0) { [EOL]         if (buffer.length() > 0) { [EOL]             buffer.append('\n'); [EOL]         } [EOL]         buffer.append("Exception Context:\n"); [EOL]         int i = 0; [EOL]         for (final Pair<String, Object> pair : contextValues) { [EOL]             buffer.append("\t["); [EOL]             buffer.append(++i); [EOL]             buffer.append(':'); [EOL]             buffer.append(pair.getKey()); [EOL]             buffer.append("="); [EOL]             final Object value = pair.getValue(); [EOL]             if (value == null) { [EOL]                 buffer.append("null"); [EOL]             } else { [EOL]                 String valueStr; [EOL]                 try { [EOL]                     valueStr = value.toString(); [EOL]                 } catch (final Exception e) { [EOL]                     valueStr = "Exception thrown on toString(): " + ExceptionUtils.getStackTrace(e); [EOL]                 } [EOL]                 buffer.append(valueStr); [EOL]             } [EOL]             buffer.append("]\n"); [EOL]         } [EOL]         buffer.append("---------------------------------"); [EOL]     } [EOL]     return buffer.toString(); [EOL] }
@Override [EOL] public String getFormattedExceptionMessage(final String baseMessage) { [EOL]     final StringBuilder buffer = new StringBuilder(256); [EOL]     if (baseMessage != null) { [EOL]         buffer.append(baseMessage); [EOL]     } [EOL]     if (contextValues.size() > 0) { [EOL]         if (buffer.length() > 0) { [EOL]             buffer.append('\n'); [EOL]         } [EOL]         buffer.append("Exception Context:\n"); [EOL]         int i = 0; [EOL]         for (final Pair<String, Object> pair : contextValues) { [EOL]             buffer.append("\t["); [EOL]             buffer.append(++i); [EOL]             buffer.append(':'); [EOL]             buffer.append(pair.getKey()); [EOL]             buffer.append("="); [EOL]             final Object value = pair.getValue(); [EOL]             if (value == null) { [EOL]                 buffer.append("null"); [EOL]             } else { [EOL]                 String valueStr; [EOL]                 try { [EOL]                     valueStr = value.toString(); [EOL]                 } catch (final Exception e) { [EOL]                     valueStr = "Exception thrown on toString(): " + ExceptionUtils.getStackTrace(e); [EOL]                 } [EOL]                 buffer.append(valueStr); [EOL]             } [EOL]             buffer.append("]\n"); [EOL]         } [EOL]         buffer.append("---------------------------------"); [EOL]     } [EOL]     return buffer.toString(); [EOL] }
@Override [EOL] public String getFormattedExceptionMessage(final String baseMessage) { [EOL]     final StringBuilder buffer = new StringBuilder(256); [EOL]     if (baseMessage != null) { [EOL]         buffer.append(baseMessage); [EOL]     } [EOL]     if (contextValues.size() > 0) { [EOL]         if (buffer.length() > 0) { [EOL]             buffer.append('\n'); [EOL]         } [EOL]         buffer.append("Exception Context:\n"); [EOL]         int i = 0; [EOL]         for (final Pair<String, Object> pair : contextValues) { [EOL]             buffer.append("\t["); [EOL]             buffer.append(++i); [EOL]             buffer.append(':'); [EOL]             buffer.append(pair.getKey()); [EOL]             buffer.append("="); [EOL]             final Object value = pair.getValue(); [EOL]             if (value == null) { [EOL]                 buffer.append("null"); [EOL]             } else { [EOL]                 String valueStr; [EOL]                 try { [EOL]                     valueStr = value.toString(); [EOL]                 } catch (final Exception e) { [EOL]                     valueStr = "Exception thrown on toString(): " + ExceptionUtils.getStackTrace(e); [EOL]                 } [EOL]                 buffer.append(valueStr); [EOL]             } [EOL]             buffer.append("]\n"); [EOL]         } [EOL]         buffer.append("---------------------------------"); [EOL]     } [EOL]     return buffer.toString(); [EOL] }
@Override [EOL] public String getFormattedExceptionMessage(final String baseMessage) { [EOL]     final StringBuilder buffer = new StringBuilder(256); [EOL]     if (baseMessage != null) { [EOL]         buffer.append(baseMessage); [EOL]     } [EOL]     if (contextValues.size() > 0) { [EOL]         if (buffer.length() > 0) { [EOL]             buffer.append('\n'); [EOL]         } [EOL]         buffer.append("Exception Context:\n"); [EOL]         int i = 0; [EOL]         for (final Pair<String, Object> pair : contextValues) { [EOL]             buffer.append("\t["); [EOL]             buffer.append(++i); [EOL]             buffer.append(':'); [EOL]             buffer.append(pair.getKey()); [EOL]             buffer.append("="); [EOL]             final Object value = pair.getValue(); [EOL]             if (value == null) { [EOL]                 buffer.append("null"); [EOL]             } else { [EOL]                 String valueStr; [EOL]                 try { [EOL]                     valueStr = value.toString(); [EOL]                 } catch (final Exception e) { [EOL]                     valueStr = "Exception thrown on toString(): " + ExceptionUtils.getStackTrace(e); [EOL]                 } [EOL]                 buffer.append(valueStr); [EOL]             } [EOL]             buffer.append("]\n"); [EOL]         } [EOL]         buffer.append("---------------------------------"); [EOL]     } [EOL]     return buffer.toString(); [EOL] }
public StrBuilder() { [EOL]     this(CAPACITY); [EOL] }
public StrBuilder(int initialCapacity) { [EOL]     super(); [EOL]     if (initialCapacity <= 0) { [EOL]         initialCapacity = CAPACITY; [EOL]     } [EOL]     buffer = new char[initialCapacity]; [EOL] }
public StrBuilder(int initialCapacity) { [EOL]     super(); [EOL]     if (initialCapacity <= 0) { [EOL]         initialCapacity = CAPACITY; [EOL]     } [EOL]     buffer = new char[initialCapacity]; [EOL] }
public StrBuilder(int initialCapacity) { [EOL]     super(); [EOL]     if (initialCapacity <= 0) { [EOL]         initialCapacity = CAPACITY; [EOL]     } [EOL]     buffer = new char[initialCapacity]; [EOL] }
public StrBuilder(final String str) { [EOL]     super(); [EOL]     if (str == null) { [EOL]         buffer = new char[CAPACITY]; [EOL]     } else { [EOL]         buffer = new char[str.length() + CAPACITY]; [EOL]         append(str); [EOL]     } [EOL] }
public StrBuilder(final String str) { [EOL]     super(); [EOL]     if (str == null) { [EOL]         buffer = new char[CAPACITY]; [EOL]     } else { [EOL]         buffer = new char[str.length() + CAPACITY]; [EOL]         append(str); [EOL]     } [EOL] }
public StrBuilder(final String str) { [EOL]     super(); [EOL]     if (str == null) { [EOL]         buffer = new char[CAPACITY]; [EOL]     } else { [EOL]         buffer = new char[str.length() + CAPACITY]; [EOL]         append(str); [EOL]     } [EOL] }
@Override [EOL] public int length() { [EOL]     return size; [EOL] }
@Override [EOL] public int length() { [EOL]     return size; [EOL] }
public int capacity() { [EOL]     return buffer.length; [EOL] }
public StrBuilder ensureCapacity(final int capacity) { [EOL]     if (capacity > buffer.length) { [EOL]         final char[] old = buffer; [EOL]         buffer = new char[capacity * 2]; [EOL]         System.arraycopy(old, 0, buffer, 0, size); [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder ensureCapacity(final int capacity) { [EOL]     if (capacity > buffer.length) { [EOL]         final char[] old = buffer; [EOL]         buffer = new char[capacity * 2]; [EOL]         System.arraycopy(old, 0, buffer, 0, size); [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public char charAt(final int index) { [EOL]     if (index < 0 || index >= length()) { [EOL]         throw new StringIndexOutOfBoundsException(index); [EOL]     } [EOL]     return buffer[index]; [EOL] }
public StrBuilder deleteCharAt(final int index) { [EOL]     if (index < 0 || index >= size) { [EOL]         throw new StringIndexOutOfBoundsException(index); [EOL]     } [EOL]     deleteImpl(index, index + 1, 1); [EOL]     return this; [EOL] }
public StrBuilder deleteCharAt(final int index) { [EOL]     if (index < 0 || index >= size) { [EOL]         throw new StringIndexOutOfBoundsException(index); [EOL]     } [EOL]     deleteImpl(index, index + 1, 1); [EOL]     return this; [EOL] }
public char[] toCharArray(final int startIndex, int endIndex) { [EOL]     endIndex = validateRange(startIndex, endIndex); [EOL]     final int len = endIndex - startIndex; [EOL]     if (len == 0) { [EOL]         return ArrayUtils.EMPTY_CHAR_ARRAY; [EOL]     } [EOL]     final char[] chars = new char[len]; [EOL]     System.arraycopy(buffer, startIndex, chars, 0, len); [EOL]     return chars; [EOL] }
public char[] toCharArray(final int startIndex, int endIndex) { [EOL]     endIndex = validateRange(startIndex, endIndex); [EOL]     final int len = endIndex - startIndex; [EOL]     if (len == 0) { [EOL]         return ArrayUtils.EMPTY_CHAR_ARRAY; [EOL]     } [EOL]     final char[] chars = new char[len]; [EOL]     System.arraycopy(buffer, startIndex, chars, 0, len); [EOL]     return chars; [EOL] }
public char[] toCharArray(final int startIndex, int endIndex) { [EOL]     endIndex = validateRange(startIndex, endIndex); [EOL]     final int len = endIndex - startIndex; [EOL]     if (len == 0) { [EOL]         return ArrayUtils.EMPTY_CHAR_ARRAY; [EOL]     } [EOL]     final char[] chars = new char[len]; [EOL]     System.arraycopy(buffer, startIndex, chars, 0, len); [EOL]     return chars; [EOL] }
public StrBuilder append(final String str) { [EOL]     if (str == null) { [EOL]         return appendNull(); [EOL]     } [EOL]     final int strLen = str.length(); [EOL]     if (strLen > 0) { [EOL]         final int len = length(); [EOL]         ensureCapacity(len + strLen); [EOL]         str.getChars(0, strLen, buffer, len); [EOL]         size += strLen; [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder append(final String str) { [EOL]     if (str == null) { [EOL]         return appendNull(); [EOL]     } [EOL]     final int strLen = str.length(); [EOL]     if (strLen > 0) { [EOL]         final int len = length(); [EOL]         ensureCapacity(len + strLen); [EOL]         str.getChars(0, strLen, buffer, len); [EOL]         size += strLen; [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder append(final String str) { [EOL]     if (str == null) { [EOL]         return appendNull(); [EOL]     } [EOL]     final int strLen = str.length(); [EOL]     if (strLen > 0) { [EOL]         final int len = length(); [EOL]         ensureCapacity(len + strLen); [EOL]         str.getChars(0, strLen, buffer, len); [EOL]         size += strLen; [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder append(final StringBuilder str) { [EOL]     if (str == null) { [EOL]         return appendNull(); [EOL]     } [EOL]     final int strLen = str.length(); [EOL]     if (strLen > 0) { [EOL]         final int len = length(); [EOL]         ensureCapacity(len + strLen); [EOL]         str.getChars(0, strLen, buffer, len); [EOL]         size += strLen; [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder append(final StringBuilder str) { [EOL]     if (str == null) { [EOL]         return appendNull(); [EOL]     } [EOL]     final int strLen = str.length(); [EOL]     if (strLen > 0) { [EOL]         final int len = length(); [EOL]         ensureCapacity(len + strLen); [EOL]         str.getChars(0, strLen, buffer, len); [EOL]         size += strLen; [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder append(final StringBuilder str) { [EOL]     if (str == null) { [EOL]         return appendNull(); [EOL]     } [EOL]     final int strLen = str.length(); [EOL]     if (strLen > 0) { [EOL]         final int len = length(); [EOL]         ensureCapacity(len + strLen); [EOL]         str.getChars(0, strLen, buffer, len); [EOL]         size += strLen; [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder append(final StringBuilder str, final int startIndex, final int length) { [EOL]     if (str == null) { [EOL]         return appendNull(); [EOL]     } [EOL]     if (startIndex < 0 || startIndex > str.length()) { [EOL]         throw new StringIndexOutOfBoundsException("startIndex must be valid"); [EOL]     } [EOL]     if (length < 0 || (startIndex + length) > str.length()) { [EOL]         throw new StringIndexOutOfBoundsException("length must be valid"); [EOL]     } [EOL]     if (length > 0) { [EOL]         final int len = length(); [EOL]         ensureCapacity(len + length); [EOL]         str.getChars(startIndex, startIndex + length, buffer, len); [EOL]         size += length; [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder append(final StringBuilder str, final int startIndex, final int length) { [EOL]     if (str == null) { [EOL]         return appendNull(); [EOL]     } [EOL]     if (startIndex < 0 || startIndex > str.length()) { [EOL]         throw new StringIndexOutOfBoundsException("startIndex must be valid"); [EOL]     } [EOL]     if (length < 0 || (startIndex + length) > str.length()) { [EOL]         throw new StringIndexOutOfBoundsException("length must be valid"); [EOL]     } [EOL]     if (length > 0) { [EOL]         final int len = length(); [EOL]         ensureCapacity(len + length); [EOL]         str.getChars(startIndex, startIndex + length, buffer, len); [EOL]         size += length; [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder append(final StringBuilder str, final int startIndex, final int length) { [EOL]     if (str == null) { [EOL]         return appendNull(); [EOL]     } [EOL]     if (startIndex < 0 || startIndex > str.length()) { [EOL]         throw new StringIndexOutOfBoundsException("startIndex must be valid"); [EOL]     } [EOL]     if (length < 0 || (startIndex + length) > str.length()) { [EOL]         throw new StringIndexOutOfBoundsException("length must be valid"); [EOL]     } [EOL]     if (length > 0) { [EOL]         final int len = length(); [EOL]         ensureCapacity(len + length); [EOL]         str.getChars(startIndex, startIndex + length, buffer, len); [EOL]         size += length; [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder append(final StrBuilder str) { [EOL]     if (str == null) { [EOL]         return appendNull(); [EOL]     } [EOL]     final int strLen = str.length(); [EOL]     if (strLen > 0) { [EOL]         final int len = length(); [EOL]         ensureCapacity(len + strLen); [EOL]         System.arraycopy(str.buffer, 0, buffer, len, strLen); [EOL]         size += strLen; [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder append(final StrBuilder str) { [EOL]     if (str == null) { [EOL]         return appendNull(); [EOL]     } [EOL]     final int strLen = str.length(); [EOL]     if (strLen > 0) { [EOL]         final int len = length(); [EOL]         ensureCapacity(len + strLen); [EOL]         System.arraycopy(str.buffer, 0, buffer, len, strLen); [EOL]         size += strLen; [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder append(final StrBuilder str) { [EOL]     if (str == null) { [EOL]         return appendNull(); [EOL]     } [EOL]     final int strLen = str.length(); [EOL]     if (strLen > 0) { [EOL]         final int len = length(); [EOL]         ensureCapacity(len + strLen); [EOL]         System.arraycopy(str.buffer, 0, buffer, len, strLen); [EOL]         size += strLen; [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder appendln(final Object obj) { [EOL]     return append(obj).appendNewLine(); [EOL] }
public StrBuilder appendln(final Object obj) { [EOL]     return append(obj).appendNewLine(); [EOL] }
public StrBuilder appendln(final StringBuilder str) { [EOL]     return append(str).appendNewLine(); [EOL] }
public StrBuilder appendln(final StringBuilder str) { [EOL]     return append(str).appendNewLine(); [EOL] }
public StrBuilder appendln(final StringBuilder str) { [EOL]     return append(str).appendNewLine(); [EOL] }
public StrBuilder appendln(final StrBuilder str) { [EOL]     return append(str).appendNewLine(); [EOL] }
public StrBuilder appendln(final StrBuilder str) { [EOL]     return append(str).appendNewLine(); [EOL] }
public StrBuilder appendln(final char[] chars, final int startIndex, final int length) { [EOL]     return append(chars, startIndex, length).appendNewLine(); [EOL] }
public StrBuilder appendln(final char[] chars, final int startIndex, final int length) { [EOL]     return append(chars, startIndex, length).appendNewLine(); [EOL] }
public StrBuilder appendln(final char[] chars, final int startIndex, final int length) { [EOL]     return append(chars, startIndex, length).appendNewLine(); [EOL] }
public StrBuilder appendln(final char[] chars, final int startIndex, final int length) { [EOL]     return append(chars, startIndex, length).appendNewLine(); [EOL] }
public StrBuilder appendln(final int value) { [EOL]     return append(value).appendNewLine(); [EOL] }
public StrBuilder appendln(final int value) { [EOL]     return append(value).appendNewLine(); [EOL] }
public StrBuilder appendln(final long value) { [EOL]     return append(value).appendNewLine(); [EOL] }
public StrBuilder appendln(final long value) { [EOL]     return append(value).appendNewLine(); [EOL] }
public StrBuilder appendln(final float value) { [EOL]     return append(value).appendNewLine(); [EOL] }
public StrBuilder appendln(final float value) { [EOL]     return append(value).appendNewLine(); [EOL] }
public StrBuilder appendln(final double value) { [EOL]     return append(value).appendNewLine(); [EOL] }
public StrBuilder appendSeparator(final char separator, final int loopIndex) { [EOL]     if (loopIndex > 0) { [EOL]         append(separator); [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder appendSeparator(final char separator, final int loopIndex) { [EOL]     if (loopIndex > 0) { [EOL]         append(separator); [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder appendSeparator(final char separator, final int loopIndex) { [EOL]     if (loopIndex > 0) { [EOL]         append(separator); [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder appendFixedWidthPadLeft(final Object obj, final int width, final char padChar) { [EOL]     if (width > 0) { [EOL]         ensureCapacity(size + width); [EOL]         String str = (obj == null ? getNullText() : obj.toString()); [EOL]         if (str == null) { [EOL]             str = ""; [EOL]         } [EOL]         final int strLen = str.length(); [EOL]         if (strLen >= width) { [EOL]             str.getChars(strLen - width, strLen, buffer, size); [EOL]         } else { [EOL]             final int padLen = width - strLen; [EOL]             for (int i = 0; i < padLen; i++) { [EOL]                 buffer[size + i] = padChar; [EOL]             } [EOL]             str.getChars(0, strLen, buffer, size + padLen); [EOL]         } [EOL]         size += width; [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder appendFixedWidthPadLeft(final Object obj, final int width, final char padChar) { [EOL]     if (width > 0) { [EOL]         ensureCapacity(size + width); [EOL]         String str = (obj == null ? getNullText() : obj.toString()); [EOL]         if (str == null) { [EOL]             str = ""; [EOL]         } [EOL]         final int strLen = str.length(); [EOL]         if (strLen >= width) { [EOL]             str.getChars(strLen - width, strLen, buffer, size); [EOL]         } else { [EOL]             final int padLen = width - strLen; [EOL]             for (int i = 0; i < padLen; i++) { [EOL]                 buffer[size + i] = padChar; [EOL]             } [EOL]             str.getChars(0, strLen, buffer, size + padLen); [EOL]         } [EOL]         size += width; [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder appendFixedWidthPadLeft(final Object obj, final int width, final char padChar) { [EOL]     if (width > 0) { [EOL]         ensureCapacity(size + width); [EOL]         String str = (obj == null ? getNullText() : obj.toString()); [EOL]         if (str == null) { [EOL]             str = ""; [EOL]         } [EOL]         final int strLen = str.length(); [EOL]         if (strLen >= width) { [EOL]             str.getChars(strLen - width, strLen, buffer, size); [EOL]         } else { [EOL]             final int padLen = width - strLen; [EOL]             for (int i = 0; i < padLen; i++) { [EOL]                 buffer[size + i] = padChar; [EOL]             } [EOL]             str.getChars(0, strLen, buffer, size + padLen); [EOL]         } [EOL]         size += width; [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder appendFixedWidthPadLeft(final Object obj, final int width, final char padChar) { [EOL]     if (width > 0) { [EOL]         ensureCapacity(size + width); [EOL]         String str = (obj == null ? getNullText() : obj.toString()); [EOL]         if (str == null) { [EOL]             str = ""; [EOL]         } [EOL]         final int strLen = str.length(); [EOL]         if (strLen >= width) { [EOL]             str.getChars(strLen - width, strLen, buffer, size); [EOL]         } else { [EOL]             final int padLen = width - strLen; [EOL]             for (int i = 0; i < padLen; i++) { [EOL]                 buffer[size + i] = padChar; [EOL]             } [EOL]             str.getChars(0, strLen, buffer, size + padLen); [EOL]         } [EOL]         size += width; [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder appendFixedWidthPadLeft(final Object obj, final int width, final char padChar) { [EOL]     if (width > 0) { [EOL]         ensureCapacity(size + width); [EOL]         String str = (obj == null ? getNullText() : obj.toString()); [EOL]         if (str == null) { [EOL]             str = ""; [EOL]         } [EOL]         final int strLen = str.length(); [EOL]         if (strLen >= width) { [EOL]             str.getChars(strLen - width, strLen, buffer, size); [EOL]         } else { [EOL]             final int padLen = width - strLen; [EOL]             for (int i = 0; i < padLen; i++) { [EOL]                 buffer[size + i] = padChar; [EOL]             } [EOL]             str.getChars(0, strLen, buffer, size + padLen); [EOL]         } [EOL]         size += width; [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder appendFixedWidthPadLeft(final Object obj, final int width, final char padChar) { [EOL]     if (width > 0) { [EOL]         ensureCapacity(size + width); [EOL]         String str = (obj == null ? getNullText() : obj.toString()); [EOL]         if (str == null) { [EOL]             str = ""; [EOL]         } [EOL]         final int strLen = str.length(); [EOL]         if (strLen >= width) { [EOL]             str.getChars(strLen - width, strLen, buffer, size); [EOL]         } else { [EOL]             final int padLen = width - strLen; [EOL]             for (int i = 0; i < padLen; i++) { [EOL]                 buffer[size + i] = padChar; [EOL]             } [EOL]             str.getChars(0, strLen, buffer, size + padLen); [EOL]         } [EOL]         size += width; [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder appendFixedWidthPadLeft(final int value, final int width, final char padChar) { [EOL]     return appendFixedWidthPadLeft(String.valueOf(value), width, padChar); [EOL] }
public StrBuilder appendFixedWidthPadLeft(final int value, final int width, final char padChar) { [EOL]     return appendFixedWidthPadLeft(String.valueOf(value), width, padChar); [EOL] }
public StrBuilder appendFixedWidthPadLeft(final int value, final int width, final char padChar) { [EOL]     return appendFixedWidthPadLeft(String.valueOf(value), width, padChar); [EOL] }
public StrBuilder appendFixedWidthPadLeft(final int value, final int width, final char padChar) { [EOL]     return appendFixedWidthPadLeft(String.valueOf(value), width, padChar); [EOL] }
public StrBuilder appendFixedWidthPadLeft(final int value, final int width, final char padChar) { [EOL]     return appendFixedWidthPadLeft(String.valueOf(value), width, padChar); [EOL] }
private void deleteImpl(final int startIndex, final int endIndex, final int len) { [EOL]     System.arraycopy(buffer, endIndex, buffer, startIndex, size - endIndex); [EOL]     size -= len; [EOL] }
private void deleteImpl(final int startIndex, final int endIndex, final int len) { [EOL]     System.arraycopy(buffer, endIndex, buffer, startIndex, size - endIndex); [EOL]     size -= len; [EOL] }
private void deleteImpl(final int startIndex, final int endIndex, final int len) { [EOL]     System.arraycopy(buffer, endIndex, buffer, startIndex, size - endIndex); [EOL]     size -= len; [EOL] }
public StrBuilder deleteAll(final String str) { [EOL]     final int len = (str == null ? 0 : str.length()); [EOL]     if (len > 0) { [EOL]         int index = indexOf(str, 0); [EOL]         while (index >= 0) { [EOL]             deleteImpl(index, index + len, len); [EOL]             index = indexOf(str, index); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder deleteAll(final String str) { [EOL]     final int len = (str == null ? 0 : str.length()); [EOL]     if (len > 0) { [EOL]         int index = indexOf(str, 0); [EOL]         while (index >= 0) { [EOL]             deleteImpl(index, index + len, len); [EOL]             index = indexOf(str, index); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder deleteAll(final String str) { [EOL]     final int len = (str == null ? 0 : str.length()); [EOL]     if (len > 0) { [EOL]         int index = indexOf(str, 0); [EOL]         while (index >= 0) { [EOL]             deleteImpl(index, index + len, len); [EOL]             index = indexOf(str, index); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder deleteAll(final String str) { [EOL]     final int len = (str == null ? 0 : str.length()); [EOL]     if (len > 0) { [EOL]         int index = indexOf(str, 0); [EOL]         while (index >= 0) { [EOL]             deleteImpl(index, index + len, len); [EOL]             index = indexOf(str, index); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder deleteAll(final String str) { [EOL]     final int len = (str == null ? 0 : str.length()); [EOL]     if (len > 0) { [EOL]         int index = indexOf(str, 0); [EOL]         while (index >= 0) { [EOL]             deleteImpl(index, index + len, len); [EOL]             index = indexOf(str, index); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder replace(final int startIndex, int endIndex, final String replaceStr) { [EOL]     endIndex = validateRange(startIndex, endIndex); [EOL]     final int insertLen = (replaceStr == null ? 0 : replaceStr.length()); [EOL]     replaceImpl(startIndex, endIndex, endIndex - startIndex, replaceStr, insertLen); [EOL]     return this; [EOL] }
public StrBuilder replace(final int startIndex, int endIndex, final String replaceStr) { [EOL]     endIndex = validateRange(startIndex, endIndex); [EOL]     final int insertLen = (replaceStr == null ? 0 : replaceStr.length()); [EOL]     replaceImpl(startIndex, endIndex, endIndex - startIndex, replaceStr, insertLen); [EOL]     return this; [EOL] }
public StrBuilder replace(final int startIndex, int endIndex, final String replaceStr) { [EOL]     endIndex = validateRange(startIndex, endIndex); [EOL]     final int insertLen = (replaceStr == null ? 0 : replaceStr.length()); [EOL]     replaceImpl(startIndex, endIndex, endIndex - startIndex, replaceStr, insertLen); [EOL]     return this; [EOL] }
public StrBuilder replace(final int startIndex, int endIndex, final String replaceStr) { [EOL]     endIndex = validateRange(startIndex, endIndex); [EOL]     final int insertLen = (replaceStr == null ? 0 : replaceStr.length()); [EOL]     replaceImpl(startIndex, endIndex, endIndex - startIndex, replaceStr, insertLen); [EOL]     return this; [EOL] }
public StrBuilder replace(final int startIndex, int endIndex, final String replaceStr) { [EOL]     endIndex = validateRange(startIndex, endIndex); [EOL]     final int insertLen = (replaceStr == null ? 0 : replaceStr.length()); [EOL]     replaceImpl(startIndex, endIndex, endIndex - startIndex, replaceStr, insertLen); [EOL]     return this; [EOL] }
public StrBuilder replace(final int startIndex, int endIndex, final String replaceStr) { [EOL]     endIndex = validateRange(startIndex, endIndex); [EOL]     final int insertLen = (replaceStr == null ? 0 : replaceStr.length()); [EOL]     replaceImpl(startIndex, endIndex, endIndex - startIndex, replaceStr, insertLen); [EOL]     return this; [EOL] }
public StrBuilder replace(final int startIndex, int endIndex, final String replaceStr) { [EOL]     endIndex = validateRange(startIndex, endIndex); [EOL]     final int insertLen = (replaceStr == null ? 0 : replaceStr.length()); [EOL]     replaceImpl(startIndex, endIndex, endIndex - startIndex, replaceStr, insertLen); [EOL]     return this; [EOL] }
public StrBuilder replace(final int startIndex, int endIndex, final String replaceStr) { [EOL]     endIndex = validateRange(startIndex, endIndex); [EOL]     final int insertLen = (replaceStr == null ? 0 : replaceStr.length()); [EOL]     replaceImpl(startIndex, endIndex, endIndex - startIndex, replaceStr, insertLen); [EOL]     return this; [EOL] }
public StrBuilder replace(final int startIndex, int endIndex, final String replaceStr) { [EOL]     endIndex = validateRange(startIndex, endIndex); [EOL]     final int insertLen = (replaceStr == null ? 0 : replaceStr.length()); [EOL]     replaceImpl(startIndex, endIndex, endIndex - startIndex, replaceStr, insertLen); [EOL]     return this; [EOL] }
public StrBuilder replaceAll(final char search, final char replace) { [EOL]     if (search != replace) { [EOL]         for (int i = 0; i < size; i++) { [EOL]             if (buffer[i] == search) { [EOL]                 buffer[i] = replace; [EOL]             } [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder replaceAll(final char search, final char replace) { [EOL]     if (search != replace) { [EOL]         for (int i = 0; i < size; i++) { [EOL]             if (buffer[i] == search) { [EOL]                 buffer[i] = replace; [EOL]             } [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder replaceAll(final char search, final char replace) { [EOL]     if (search != replace) { [EOL]         for (int i = 0; i < size; i++) { [EOL]             if (buffer[i] == search) { [EOL]                 buffer[i] = replace; [EOL]             } [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder replaceFirst(final char search, final char replace) { [EOL]     if (search != replace) { [EOL]         for (int i = 0; i < size; i++) { [EOL]             if (buffer[i] == search) { [EOL]                 buffer[i] = replace; [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder replaceFirst(final char search, final char replace) { [EOL]     if (search != replace) { [EOL]         for (int i = 0; i < size; i++) { [EOL]             if (buffer[i] == search) { [EOL]                 buffer[i] = replace; [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder replaceFirst(final char search, final char replace) { [EOL]     if (search != replace) { [EOL]         for (int i = 0; i < size; i++) { [EOL]             if (buffer[i] == search) { [EOL]                 buffer[i] = replace; [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder reverse() { [EOL]     if (size == 0) { [EOL]         return this; [EOL]     } [EOL]     final int half = size / 2; [EOL]     final char[] buf = buffer; [EOL]     for (int leftIdx = 0, rightIdx = size - 1; leftIdx < half; leftIdx++, rightIdx--) { [EOL]         final char swap = buf[leftIdx]; [EOL]         buf[leftIdx] = buf[rightIdx]; [EOL]         buf[rightIdx] = swap; [EOL]     } [EOL]     return this; [EOL] }
public StrBuilder reverse() { [EOL]     if (size == 0) { [EOL]         return this; [EOL]     } [EOL]     final int half = size / 2; [EOL]     final char[] buf = buffer; [EOL]     for (int leftIdx = 0, rightIdx = size - 1; leftIdx < half; leftIdx++, rightIdx--) { [EOL]         final char swap = buf[leftIdx]; [EOL]         buf[leftIdx] = buf[rightIdx]; [EOL]         buf[rightIdx] = swap; [EOL]     } [EOL]     return this; [EOL] }
public boolean endsWith(final String str) { [EOL]     if (str == null) { [EOL]         return false; [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len == 0) { [EOL]         return true; [EOL]     } [EOL]     if (len > size) { [EOL]         return false; [EOL]     } [EOL]     int pos = size - len; [EOL]     for (int i = 0; i < len; i++, pos++) { [EOL]         if (buffer[pos] != str.charAt(i)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public boolean endsWith(final String str) { [EOL]     if (str == null) { [EOL]         return false; [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len == 0) { [EOL]         return true; [EOL]     } [EOL]     if (len > size) { [EOL]         return false; [EOL]     } [EOL]     int pos = size - len; [EOL]     for (int i = 0; i < len; i++, pos++) { [EOL]         if (buffer[pos] != str.charAt(i)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public boolean endsWith(final String str) { [EOL]     if (str == null) { [EOL]         return false; [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len == 0) { [EOL]         return true; [EOL]     } [EOL]     if (len > size) { [EOL]         return false; [EOL]     } [EOL]     int pos = size - len; [EOL]     for (int i = 0; i < len; i++, pos++) { [EOL]         if (buffer[pos] != str.charAt(i)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public boolean endsWith(final String str) { [EOL]     if (str == null) { [EOL]         return false; [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len == 0) { [EOL]         return true; [EOL]     } [EOL]     if (len > size) { [EOL]         return false; [EOL]     } [EOL]     int pos = size - len; [EOL]     for (int i = 0; i < len; i++, pos++) { [EOL]         if (buffer[pos] != str.charAt(i)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public boolean endsWith(final String str) { [EOL]     if (str == null) { [EOL]         return false; [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len == 0) { [EOL]         return true; [EOL]     } [EOL]     if (len > size) { [EOL]         return false; [EOL]     } [EOL]     int pos = size - len; [EOL]     for (int i = 0; i < len; i++, pos++) { [EOL]         if (buffer[pos] != str.charAt(i)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public boolean endsWith(final String str) { [EOL]     if (str == null) { [EOL]         return false; [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len == 0) { [EOL]         return true; [EOL]     } [EOL]     if (len > size) { [EOL]         return false; [EOL]     } [EOL]     int pos = size - len; [EOL]     for (int i = 0; i < len; i++, pos++) { [EOL]         if (buffer[pos] != str.charAt(i)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public int indexOf(final String str, int startIndex) { [EOL]     startIndex = (startIndex < 0 ? 0 : startIndex); [EOL]     if (str == null || startIndex >= size) { [EOL]         return -1; [EOL]     } [EOL]     final int strLen = str.length(); [EOL]     if (strLen == 1) { [EOL]         return indexOf(str.charAt(0), startIndex); [EOL]     } [EOL]     if (strLen == 0) { [EOL]         return startIndex; [EOL]     } [EOL]     if (strLen > size) { [EOL]         return -1; [EOL]     } [EOL]     final char[] thisBuf = buffer; [EOL]     final int len = size - strLen + 1; [EOL]     outer: for (int i = startIndex; i < len; i++) { [EOL]         for (int j = 0; j < strLen; j++) { [EOL]             if (str.charAt(j) != thisBuf[i + j]) { [EOL]                 continue outer; [EOL]             } [EOL]         } [EOL]         return i; [EOL]     } [EOL]     return -1; [EOL] }
public int indexOf(final String str, int startIndex) { [EOL]     startIndex = (startIndex < 0 ? 0 : startIndex); [EOL]     if (str == null || startIndex >= size) { [EOL]         return -1; [EOL]     } [EOL]     final int strLen = str.length(); [EOL]     if (strLen == 1) { [EOL]         return indexOf(str.charAt(0), startIndex); [EOL]     } [EOL]     if (strLen == 0) { [EOL]         return startIndex; [EOL]     } [EOL]     if (strLen > size) { [EOL]         return -1; [EOL]     } [EOL]     final char[] thisBuf = buffer; [EOL]     final int len = size - strLen + 1; [EOL]     outer: for (int i = startIndex; i < len; i++) { [EOL]         for (int j = 0; j < strLen; j++) { [EOL]             if (str.charAt(j) != thisBuf[i + j]) { [EOL]                 continue outer; [EOL]             } [EOL]         } [EOL]         return i; [EOL]     } [EOL]     return -1; [EOL] }
public int indexOf(final String str, int startIndex) { [EOL]     startIndex = (startIndex < 0 ? 0 : startIndex); [EOL]     if (str == null || startIndex >= size) { [EOL]         return -1; [EOL]     } [EOL]     final int strLen = str.length(); [EOL]     if (strLen == 1) { [EOL]         return indexOf(str.charAt(0), startIndex); [EOL]     } [EOL]     if (strLen == 0) { [EOL]         return startIndex; [EOL]     } [EOL]     if (strLen > size) { [EOL]         return -1; [EOL]     } [EOL]     final char[] thisBuf = buffer; [EOL]     final int len = size - strLen + 1; [EOL]     outer: for (int i = startIndex; i < len; i++) { [EOL]         for (int j = 0; j < strLen; j++) { [EOL]             if (str.charAt(j) != thisBuf[i + j]) { [EOL]                 continue outer; [EOL]             } [EOL]         } [EOL]         return i; [EOL]     } [EOL]     return -1; [EOL] }
public int indexOf(final String str, int startIndex) { [EOL]     startIndex = (startIndex < 0 ? 0 : startIndex); [EOL]     if (str == null || startIndex >= size) { [EOL]         return -1; [EOL]     } [EOL]     final int strLen = str.length(); [EOL]     if (strLen == 1) { [EOL]         return indexOf(str.charAt(0), startIndex); [EOL]     } [EOL]     if (strLen == 0) { [EOL]         return startIndex; [EOL]     } [EOL]     if (strLen > size) { [EOL]         return -1; [EOL]     } [EOL]     final char[] thisBuf = buffer; [EOL]     final int len = size - strLen + 1; [EOL]     outer: for (int i = startIndex; i < len; i++) { [EOL]         for (int j = 0; j < strLen; j++) { [EOL]             if (str.charAt(j) != thisBuf[i + j]) { [EOL]                 continue outer; [EOL]             } [EOL]         } [EOL]         return i; [EOL]     } [EOL]     return -1; [EOL] }
public int indexOf(final String str, int startIndex) { [EOL]     startIndex = (startIndex < 0 ? 0 : startIndex); [EOL]     if (str == null || startIndex >= size) { [EOL]         return -1; [EOL]     } [EOL]     final int strLen = str.length(); [EOL]     if (strLen == 1) { [EOL]         return indexOf(str.charAt(0), startIndex); [EOL]     } [EOL]     if (strLen == 0) { [EOL]         return startIndex; [EOL]     } [EOL]     if (strLen > size) { [EOL]         return -1; [EOL]     } [EOL]     final char[] thisBuf = buffer; [EOL]     final int len = size - strLen + 1; [EOL]     outer: for (int i = startIndex; i < len; i++) { [EOL]         for (int j = 0; j < strLen; j++) { [EOL]             if (str.charAt(j) != thisBuf[i + j]) { [EOL]                 continue outer; [EOL]             } [EOL]         } [EOL]         return i; [EOL]     } [EOL]     return -1; [EOL] }
public int indexOf(final String str, int startIndex) { [EOL]     startIndex = (startIndex < 0 ? 0 : startIndex); [EOL]     if (str == null || startIndex >= size) { [EOL]         return -1; [EOL]     } [EOL]     final int strLen = str.length(); [EOL]     if (strLen == 1) { [EOL]         return indexOf(str.charAt(0), startIndex); [EOL]     } [EOL]     if (strLen == 0) { [EOL]         return startIndex; [EOL]     } [EOL]     if (strLen > size) { [EOL]         return -1; [EOL]     } [EOL]     final char[] thisBuf = buffer; [EOL]     final int len = size - strLen + 1; [EOL]     outer: for (int i = startIndex; i < len; i++) { [EOL]         for (int j = 0; j < strLen; j++) { [EOL]             if (str.charAt(j) != thisBuf[i + j]) { [EOL]                 continue outer; [EOL]             } [EOL]         } [EOL]         return i; [EOL]     } [EOL]     return -1; [EOL] }
public int indexOf(final String str, int startIndex) { [EOL]     startIndex = (startIndex < 0 ? 0 : startIndex); [EOL]     if (str == null || startIndex >= size) { [EOL]         return -1; [EOL]     } [EOL]     final int strLen = str.length(); [EOL]     if (strLen == 1) { [EOL]         return indexOf(str.charAt(0), startIndex); [EOL]     } [EOL]     if (strLen == 0) { [EOL]         return startIndex; [EOL]     } [EOL]     if (strLen > size) { [EOL]         return -1; [EOL]     } [EOL]     final char[] thisBuf = buffer; [EOL]     final int len = size - strLen + 1; [EOL]     outer: for (int i = startIndex; i < len; i++) { [EOL]         for (int j = 0; j < strLen; j++) { [EOL]             if (str.charAt(j) != thisBuf[i + j]) { [EOL]                 continue outer; [EOL]             } [EOL]         } [EOL]         return i; [EOL]     } [EOL]     return -1; [EOL] }
public int indexOf(final String str, int startIndex) { [EOL]     startIndex = (startIndex < 0 ? 0 : startIndex); [EOL]     if (str == null || startIndex >= size) { [EOL]         return -1; [EOL]     } [EOL]     final int strLen = str.length(); [EOL]     if (strLen == 1) { [EOL]         return indexOf(str.charAt(0), startIndex); [EOL]     } [EOL]     if (strLen == 0) { [EOL]         return startIndex; [EOL]     } [EOL]     if (strLen > size) { [EOL]         return -1; [EOL]     } [EOL]     final char[] thisBuf = buffer; [EOL]     final int len = size - strLen + 1; [EOL]     outer: for (int i = startIndex; i < len; i++) { [EOL]         for (int j = 0; j < strLen; j++) { [EOL]             if (str.charAt(j) != thisBuf[i + j]) { [EOL]                 continue outer; [EOL]             } [EOL]         } [EOL]         return i; [EOL]     } [EOL]     return -1; [EOL] }
public int lastIndexOf(final char ch, int startIndex) { [EOL]     startIndex = (startIndex >= size ? size - 1 : startIndex); [EOL]     if (startIndex < 0) { [EOL]         return -1; [EOL]     } [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (buffer[i] == ch) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return -1; [EOL] }
public StrTokenizer asTokenizer() { [EOL]     return new StrBuilderTokenizer(); [EOL] }
public boolean equals(final StrBuilder other) { [EOL]     if (this == other) { [EOL]         return true; [EOL]     } [EOL]     if (this.size != other.size) { [EOL]         return false; [EOL]     } [EOL]     final char[] thisBuf = this.buffer; [EOL]     final char[] otherBuf = other.buffer; [EOL]     for (int i = size - 1; i >= 0; i--) { [EOL]         if (thisBuf[i] != otherBuf[i]) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj instanceof StrBuilder) { [EOL]         return equals((StrBuilder) obj); [EOL]     } [EOL]     return false; [EOL] }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj instanceof StrBuilder) { [EOL]         return equals((StrBuilder) obj); [EOL]     } [EOL]     return false; [EOL] }
@Override [EOL] public int hashCode() { [EOL]     final char[] buf = buffer; [EOL]     int hash = 0; [EOL]     for (int i = size - 1; i >= 0; i--) { [EOL]         hash = 31 * hash + buf[i]; [EOL]     } [EOL]     return hash; [EOL] }
@Override [EOL] public int hashCode() { [EOL]     final char[] buf = buffer; [EOL]     int hash = 0; [EOL]     for (int i = size - 1; i >= 0; i--) { [EOL]         hash = 31 * hash + buf[i]; [EOL]     } [EOL]     return hash; [EOL] }
@Override [EOL] public int hashCode() { [EOL]     final char[] buf = buffer; [EOL]     int hash = 0; [EOL]     for (int i = size - 1; i >= 0; i--) { [EOL]         hash = 31 * hash + buf[i]; [EOL]     } [EOL]     return hash; [EOL] }
@Override [EOL] public String toString() { [EOL]     return new String(buffer, 0, size); [EOL] }
@Override [EOL] public String toString() { [EOL]     return new String(buffer, 0, size); [EOL] }
StrBuilderTokenizer() { [EOL]     super(); [EOL] }
@Override [EOL] protected List<String> tokenize(final char[] chars, final int offset, final int count) { [EOL]     if (chars == null) { [EOL]         return super.tokenize(StrBuilder.this.buffer, 0, StrBuilder.this.size()); [EOL]     } [EOL]     return super.tokenize(chars, offset, count); [EOL] }
@Override [EOL] protected List<String> tokenize(final char[] chars, final int offset, final int count) { [EOL]     if (chars == null) { [EOL]         return super.tokenize(StrBuilder.this.buffer, 0, StrBuilder.this.size()); [EOL]     } [EOL]     return super.tokenize(chars, offset, count); [EOL] }
@Override [EOL] public String getContent() { [EOL]     final String str = super.getContent(); [EOL]     if (str == null) { [EOL]         return StrBuilder.this.toString(); [EOL]     } [EOL]     return str; [EOL] }
@Override [EOL] public String getContent() { [EOL]     final String str = super.getContent(); [EOL]     if (str == null) { [EOL]         return StrBuilder.this.toString(); [EOL]     } [EOL]     return str; [EOL] }
@Override [EOL] protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) { [EOL]     return new FastDateFormat(pattern, timeZone, locale); [EOL] } protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale); protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getInstance(); public static FastDateFormat getInstance(final String pattern); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone); public static FastDateFormat getInstance(final String pattern, final Locale locale); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateInstance(final int style); public static FastDateFormat getDateInstance(final int style, final Locale locale); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getTimeInstance(final int style); public static FastDateFormat getTimeInstance(final int style, final Locale locale); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale); public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos); public String format(final long millis); public String format(final Date date); public String format(final Calendar calendar); public StringBuffer format(final long millis, final StringBuffer buf); public StringBuffer format(final Date date, final StringBuffer buf); public StringBuffer format(final Calendar calendar, final StringBuffer buf); public Date parse(final String source) throws ParseException; public Date parse(final String source, final ParsePosition pos); public Object parseObject(final String source, final ParsePosition pos); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale(); public int getMaxLengthEstimate(); public boolean equals(final Object obj); public int hashCode(); public String toString(); protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf); long serialVersionUID=Optional[2L]; int FULL=Optional[DateFormat.FULL]; int LONG=Optional[DateFormat.LONG]; int MEDIUM=Optional[DateFormat.MEDIUM]; int SHORT=Optional[DateFormat.SHORT]; FormatCache<FastDateFormat> cache=Optional[new FormatCache<FastDateFormat>() {; ;     @Override;     protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) {;         return new FastDateFormat(pattern, timeZone, locale);;     }; }
@Override [EOL] protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) { [EOL]     return new FastDateFormat(pattern, timeZone, locale); [EOL] } protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale); protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getInstance(); public static FastDateFormat getInstance(final String pattern); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone); public static FastDateFormat getInstance(final String pattern, final Locale locale); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateInstance(final int style); public static FastDateFormat getDateInstance(final int style, final Locale locale); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getTimeInstance(final int style); public static FastDateFormat getTimeInstance(final int style, final Locale locale); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale); public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos); public String format(final long millis); public String format(final Date date); public String format(final Calendar calendar); public StringBuffer format(final long millis, final StringBuffer buf); public StringBuffer format(final Date date, final StringBuffer buf); public StringBuffer format(final Calendar calendar, final StringBuffer buf); public Date parse(final String source) throws ParseException; public Date parse(final String source, final ParsePosition pos); public Object parseObject(final String source, final ParsePosition pos); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale(); public int getMaxLengthEstimate(); public boolean equals(final Object obj); public int hashCode(); public String toString(); protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf); long serialVersionUID=Optional[2L]; int FULL=Optional[DateFormat.FULL]; int LONG=Optional[DateFormat.LONG]; int MEDIUM=Optional[DateFormat.MEDIUM]; int SHORT=Optional[DateFormat.SHORT]; FormatCache<FastDateFormat> cache=Optional[new FormatCache<FastDateFormat>() {; ;     @Override;     protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) {;         return new FastDateFormat(pattern, timeZone, locale);;     }; }
@Override [EOL] protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) { [EOL]     return new FastDateFormat(pattern, timeZone, locale); [EOL] } protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale); protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getInstance(); public static FastDateFormat getInstance(final String pattern); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone); public static FastDateFormat getInstance(final String pattern, final Locale locale); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateInstance(final int style); public static FastDateFormat getDateInstance(final int style, final Locale locale); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getTimeInstance(final int style); public static FastDateFormat getTimeInstance(final int style, final Locale locale); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale); public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos); public String format(final long millis); public String format(final Date date); public String format(final Calendar calendar); public StringBuffer format(final long millis, final StringBuffer buf); public StringBuffer format(final Date date, final StringBuffer buf); public StringBuffer format(final Calendar calendar, final StringBuffer buf); public Date parse(final String source) throws ParseException; public Date parse(final String source, final ParsePosition pos); public Object parseObject(final String source, final ParsePosition pos); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale(); public int getMaxLengthEstimate(); public boolean equals(final Object obj); public int hashCode(); public String toString(); protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf); long serialVersionUID=Optional[2L]; int FULL=Optional[DateFormat.FULL]; int LONG=Optional[DateFormat.LONG]; int MEDIUM=Optional[DateFormat.MEDIUM]; int SHORT=Optional[DateFormat.SHORT]; FormatCache<FastDateFormat> cache=Optional[new FormatCache<FastDateFormat>() {; ;     @Override;     protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) {;         return new FastDateFormat(pattern, timeZone, locale);;     }; }
@Override [EOL] protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) { [EOL]     return new FastDateFormat(pattern, timeZone, locale); [EOL] } protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale); protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getInstance(); public static FastDateFormat getInstance(final String pattern); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone); public static FastDateFormat getInstance(final String pattern, final Locale locale); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateInstance(final int style); public static FastDateFormat getDateInstance(final int style, final Locale locale); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getTimeInstance(final int style); public static FastDateFormat getTimeInstance(final int style, final Locale locale); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale); public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos); public String format(final long millis); public String format(final Date date); public String format(final Calendar calendar); public StringBuffer format(final long millis, final StringBuffer buf); public StringBuffer format(final Date date, final StringBuffer buf); public StringBuffer format(final Calendar calendar, final StringBuffer buf); public Date parse(final String source) throws ParseException; public Date parse(final String source, final ParsePosition pos); public Object parseObject(final String source, final ParsePosition pos); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale(); public int getMaxLengthEstimate(); public boolean equals(final Object obj); public int hashCode(); public String toString(); protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf); long serialVersionUID=Optional[2L]; int FULL=Optional[DateFormat.FULL]; int LONG=Optional[DateFormat.LONG]; int MEDIUM=Optional[DateFormat.MEDIUM]; int SHORT=Optional[DateFormat.SHORT]; FormatCache<FastDateFormat> cache=Optional[new FormatCache<FastDateFormat>() {; ;     @Override;     protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) {;         return new FastDateFormat(pattern, timeZone, locale);;     }; }
@Override [EOL] protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) { [EOL]     return new FastDateFormat(pattern, timeZone, locale); [EOL] } protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale); protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getInstance(); public static FastDateFormat getInstance(final String pattern); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone); public static FastDateFormat getInstance(final String pattern, final Locale locale); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateInstance(final int style); public static FastDateFormat getDateInstance(final int style, final Locale locale); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getTimeInstance(final int style); public static FastDateFormat getTimeInstance(final int style, final Locale locale); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale); public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos); public String format(final long millis); public String format(final Date date); public String format(final Calendar calendar); public StringBuffer format(final long millis, final StringBuffer buf); public StringBuffer format(final Date date, final StringBuffer buf); public StringBuffer format(final Calendar calendar, final StringBuffer buf); public Date parse(final String source) throws ParseException; public Date parse(final String source, final ParsePosition pos); public Object parseObject(final String source, final ParsePosition pos); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale(); public int getMaxLengthEstimate(); public boolean equals(final Object obj); public int hashCode(); public String toString(); protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf); long serialVersionUID=Optional[2L]; int FULL=Optional[DateFormat.FULL]; int LONG=Optional[DateFormat.LONG]; int MEDIUM=Optional[DateFormat.MEDIUM]; int SHORT=Optional[DateFormat.SHORT]; FormatCache<FastDateFormat> cache=Optional[new FormatCache<FastDateFormat>() {; ;     @Override;     protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) {;         return new FastDateFormat(pattern, timeZone, locale);;     }; }
@Override [EOL] protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) { [EOL]     return new FastDateFormat(pattern, timeZone, locale); [EOL] } protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale); protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getInstance(); public static FastDateFormat getInstance(final String pattern); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone); public static FastDateFormat getInstance(final String pattern, final Locale locale); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateInstance(final int style); public static FastDateFormat getDateInstance(final int style, final Locale locale); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getTimeInstance(final int style); public static FastDateFormat getTimeInstance(final int style, final Locale locale); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale); public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos); public String format(final long millis); public String format(final Date date); public String format(final Calendar calendar); public StringBuffer format(final long millis, final StringBuffer buf); public StringBuffer format(final Date date, final StringBuffer buf); public StringBuffer format(final Calendar calendar, final StringBuffer buf); public Date parse(final String source) throws ParseException; public Date parse(final String source, final ParsePosition pos); public Object parseObject(final String source, final ParsePosition pos); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale(); public int getMaxLengthEstimate(); public boolean equals(final Object obj); public int hashCode(); public String toString(); protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf); long serialVersionUID=Optional[2L]; int FULL=Optional[DateFormat.FULL]; int LONG=Optional[DateFormat.LONG]; int MEDIUM=Optional[DateFormat.MEDIUM]; int SHORT=Optional[DateFormat.SHORT]; FormatCache<FastDateFormat> cache=Optional[new FormatCache<FastDateFormat>() {; ;     @Override;     protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) {;         return new FastDateFormat(pattern, timeZone, locale);;     }; }
@Override [EOL] protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) { [EOL]     return new FastDateFormat(pattern, timeZone, locale); [EOL] } protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale); protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getInstance(); public static FastDateFormat getInstance(final String pattern); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone); public static FastDateFormat getInstance(final String pattern, final Locale locale); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateInstance(final int style); public static FastDateFormat getDateInstance(final int style, final Locale locale); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getTimeInstance(final int style); public static FastDateFormat getTimeInstance(final int style, final Locale locale); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale); public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos); public String format(final long millis); public String format(final Date date); public String format(final Calendar calendar); public StringBuffer format(final long millis, final StringBuffer buf); public StringBuffer format(final Date date, final StringBuffer buf); public StringBuffer format(final Calendar calendar, final StringBuffer buf); public Date parse(final String source) throws ParseException; public Date parse(final String source, final ParsePosition pos); public Object parseObject(final String source, final ParsePosition pos); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale(); public int getMaxLengthEstimate(); public boolean equals(final Object obj); public int hashCode(); public String toString(); protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf); long serialVersionUID=Optional[2L]; int FULL=Optional[DateFormat.FULL]; int LONG=Optional[DateFormat.LONG]; int MEDIUM=Optional[DateFormat.MEDIUM]; int SHORT=Optional[DateFormat.SHORT]; FormatCache<FastDateFormat> cache=Optional[new FormatCache<FastDateFormat>() {; ;     @Override;     protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) {;         return new FastDateFormat(pattern, timeZone, locale);;     }; }
@Override [EOL] protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) { [EOL]     return new FastDateFormat(pattern, timeZone, locale); [EOL] } protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale); protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getInstance(); public static FastDateFormat getInstance(final String pattern); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone); public static FastDateFormat getInstance(final String pattern, final Locale locale); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateInstance(final int style); public static FastDateFormat getDateInstance(final int style, final Locale locale); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getTimeInstance(final int style); public static FastDateFormat getTimeInstance(final int style, final Locale locale); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale); public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos); public String format(final long millis); public String format(final Date date); public String format(final Calendar calendar); public StringBuffer format(final long millis, final StringBuffer buf); public StringBuffer format(final Date date, final StringBuffer buf); public StringBuffer format(final Calendar calendar, final StringBuffer buf); public Date parse(final String source) throws ParseException; public Date parse(final String source, final ParsePosition pos); public Object parseObject(final String source, final ParsePosition pos); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale(); public int getMaxLengthEstimate(); public boolean equals(final Object obj); public int hashCode(); public String toString(); protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf); long serialVersionUID=Optional[2L]; int FULL=Optional[DateFormat.FULL]; int LONG=Optional[DateFormat.LONG]; int MEDIUM=Optional[DateFormat.MEDIUM]; int SHORT=Optional[DateFormat.SHORT]; FormatCache<FastDateFormat> cache=Optional[new FormatCache<FastDateFormat>() {; ;     @Override;     protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) {;         return new FastDateFormat(pattern, timeZone, locale);;     }; }
@Override [EOL] protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) { [EOL]     return new FastDateFormat(pattern, timeZone, locale); [EOL] } protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale); protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getInstance(); public static FastDateFormat getInstance(final String pattern); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone); public static FastDateFormat getInstance(final String pattern, final Locale locale); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateInstance(final int style); public static FastDateFormat getDateInstance(final int style, final Locale locale); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getTimeInstance(final int style); public static FastDateFormat getTimeInstance(final int style, final Locale locale); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale); public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos); public String format(final long millis); public String format(final Date date); public String format(final Calendar calendar); public StringBuffer format(final long millis, final StringBuffer buf); public StringBuffer format(final Date date, final StringBuffer buf); public StringBuffer format(final Calendar calendar, final StringBuffer buf); public Date parse(final String source) throws ParseException; public Date parse(final String source, final ParsePosition pos); public Object parseObject(final String source, final ParsePosition pos); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale(); public int getMaxLengthEstimate(); public boolean equals(final Object obj); public int hashCode(); public String toString(); protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf); long serialVersionUID=Optional[2L]; int FULL=Optional[DateFormat.FULL]; int LONG=Optional[DateFormat.LONG]; int MEDIUM=Optional[DateFormat.MEDIUM]; int SHORT=Optional[DateFormat.SHORT]; FormatCache<FastDateFormat> cache=Optional[new FormatCache<FastDateFormat>() {; ;     @Override;     protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) {;         return new FastDateFormat(pattern, timeZone, locale);;     }; }
@Override [EOL] protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) { [EOL]     return new FastDateFormat(pattern, timeZone, locale); [EOL] } protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale); protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getInstance(); public static FastDateFormat getInstance(final String pattern); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone); public static FastDateFormat getInstance(final String pattern, final Locale locale); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateInstance(final int style); public static FastDateFormat getDateInstance(final int style, final Locale locale); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getTimeInstance(final int style); public static FastDateFormat getTimeInstance(final int style, final Locale locale); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale); public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos); public String format(final long millis); public String format(final Date date); public String format(final Calendar calendar); public StringBuffer format(final long millis, final StringBuffer buf); public StringBuffer format(final Date date, final StringBuffer buf); public StringBuffer format(final Calendar calendar, final StringBuffer buf); public Date parse(final String source) throws ParseException; public Date parse(final String source, final ParsePosition pos); public Object parseObject(final String source, final ParsePosition pos); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale(); public int getMaxLengthEstimate(); public boolean equals(final Object obj); public int hashCode(); public String toString(); protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf); long serialVersionUID=Optional[2L]; int FULL=Optional[DateFormat.FULL]; int LONG=Optional[DateFormat.LONG]; int MEDIUM=Optional[DateFormat.MEDIUM]; int SHORT=Optional[DateFormat.SHORT]; FormatCache<FastDateFormat> cache=Optional[new FormatCache<FastDateFormat>() {; ;     @Override;     protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) {;         return new FastDateFormat(pattern, timeZone, locale);;     }; }
@Override [EOL] protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) { [EOL]     return new FastDateFormat(pattern, timeZone, locale); [EOL] } protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale); protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getInstance(); public static FastDateFormat getInstance(final String pattern); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone); public static FastDateFormat getInstance(final String pattern, final Locale locale); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateInstance(final int style); public static FastDateFormat getDateInstance(final int style, final Locale locale); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getTimeInstance(final int style); public static FastDateFormat getTimeInstance(final int style, final Locale locale); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale); public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos); public String format(final long millis); public String format(final Date date); public String format(final Calendar calendar); public StringBuffer format(final long millis, final StringBuffer buf); public StringBuffer format(final Date date, final StringBuffer buf); public StringBuffer format(final Calendar calendar, final StringBuffer buf); public Date parse(final String source) throws ParseException; public Date parse(final String source, final ParsePosition pos); public Object parseObject(final String source, final ParsePosition pos); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale(); public int getMaxLengthEstimate(); public boolean equals(final Object obj); public int hashCode(); public String toString(); protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf); long serialVersionUID=Optional[2L]; int FULL=Optional[DateFormat.FULL]; int LONG=Optional[DateFormat.LONG]; int MEDIUM=Optional[DateFormat.MEDIUM]; int SHORT=Optional[DateFormat.SHORT]; FormatCache<FastDateFormat> cache=Optional[new FormatCache<FastDateFormat>() {; ;     @Override;     protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) {;         return new FastDateFormat(pattern, timeZone, locale);;     }; }
@Override [EOL] protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) { [EOL]     return new FastDateFormat(pattern, timeZone, locale); [EOL] } protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale); protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getInstance(); public static FastDateFormat getInstance(final String pattern); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone); public static FastDateFormat getInstance(final String pattern, final Locale locale); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateInstance(final int style); public static FastDateFormat getDateInstance(final int style, final Locale locale); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getTimeInstance(final int style); public static FastDateFormat getTimeInstance(final int style, final Locale locale); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale); public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos); public String format(final long millis); public String format(final Date date); public String format(final Calendar calendar); public StringBuffer format(final long millis, final StringBuffer buf); public StringBuffer format(final Date date, final StringBuffer buf); public StringBuffer format(final Calendar calendar, final StringBuffer buf); public Date parse(final String source) throws ParseException; public Date parse(final String source, final ParsePosition pos); public Object parseObject(final String source, final ParsePosition pos); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale(); public int getMaxLengthEstimate(); public boolean equals(final Object obj); public int hashCode(); public String toString(); protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf); long serialVersionUID=Optional[2L]; int FULL=Optional[DateFormat.FULL]; int LONG=Optional[DateFormat.LONG]; int MEDIUM=Optional[DateFormat.MEDIUM]; int SHORT=Optional[DateFormat.SHORT]; FormatCache<FastDateFormat> cache=Optional[new FormatCache<FastDateFormat>() {; ;     @Override;     protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) {;         return new FastDateFormat(pattern, timeZone, locale);;     }; }
@Override [EOL] protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) { [EOL]     return new FastDateFormat(pattern, timeZone, locale); [EOL] } protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale); protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getInstance(); public static FastDateFormat getInstance(final String pattern); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone); public static FastDateFormat getInstance(final String pattern, final Locale locale); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateInstance(final int style); public static FastDateFormat getDateInstance(final int style, final Locale locale); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getTimeInstance(final int style); public static FastDateFormat getTimeInstance(final int style, final Locale locale); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale); public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos); public String format(final long millis); public String format(final Date date); public String format(final Calendar calendar); public StringBuffer format(final long millis, final StringBuffer buf); public StringBuffer format(final Date date, final StringBuffer buf); public StringBuffer format(final Calendar calendar, final StringBuffer buf); public Date parse(final String source) throws ParseException; public Date parse(final String source, final ParsePosition pos); public Object parseObject(final String source, final ParsePosition pos); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale(); public int getMaxLengthEstimate(); public boolean equals(final Object obj); public int hashCode(); public String toString(); protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf); long serialVersionUID=Optional[2L]; int FULL=Optional[DateFormat.FULL]; int LONG=Optional[DateFormat.LONG]; int MEDIUM=Optional[DateFormat.MEDIUM]; int SHORT=Optional[DateFormat.SHORT]; FormatCache<FastDateFormat> cache=Optional[new FormatCache<FastDateFormat>() {; ;     @Override;     protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) {;         return new FastDateFormat(pattern, timeZone, locale);;     }; }
@Override [EOL] protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) { [EOL]     return new FastDateFormat(pattern, timeZone, locale); [EOL] } protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale); protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getInstance(); public static FastDateFormat getInstance(final String pattern); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone); public static FastDateFormat getInstance(final String pattern, final Locale locale); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateInstance(final int style); public static FastDateFormat getDateInstance(final int style, final Locale locale); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getTimeInstance(final int style); public static FastDateFormat getTimeInstance(final int style, final Locale locale); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale); public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos); public String format(final long millis); public String format(final Date date); public String format(final Calendar calendar); public StringBuffer format(final long millis, final StringBuffer buf); public StringBuffer format(final Date date, final StringBuffer buf); public StringBuffer format(final Calendar calendar, final StringBuffer buf); public Date parse(final String source) throws ParseException; public Date parse(final String source, final ParsePosition pos); public Object parseObject(final String source, final ParsePosition pos); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale(); public int getMaxLengthEstimate(); public boolean equals(final Object obj); public int hashCode(); public String toString(); protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf); long serialVersionUID=Optional[2L]; int FULL=Optional[DateFormat.FULL]; int LONG=Optional[DateFormat.LONG]; int MEDIUM=Optional[DateFormat.MEDIUM]; int SHORT=Optional[DateFormat.SHORT]; FormatCache<FastDateFormat> cache=Optional[new FormatCache<FastDateFormat>() {; ;     @Override;     protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) {;         return new FastDateFormat(pattern, timeZone, locale);;     }; }
@Override [EOL] protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) { [EOL]     return new FastDateFormat(pattern, timeZone, locale); [EOL] } protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale); protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getInstance(); public static FastDateFormat getInstance(final String pattern); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone); public static FastDateFormat getInstance(final String pattern, final Locale locale); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateInstance(final int style); public static FastDateFormat getDateInstance(final int style, final Locale locale); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getTimeInstance(final int style); public static FastDateFormat getTimeInstance(final int style, final Locale locale); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale); public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos); public String format(final long millis); public String format(final Date date); public String format(final Calendar calendar); public StringBuffer format(final long millis, final StringBuffer buf); public StringBuffer format(final Date date, final StringBuffer buf); public StringBuffer format(final Calendar calendar, final StringBuffer buf); public Date parse(final String source) throws ParseException; public Date parse(final String source, final ParsePosition pos); public Object parseObject(final String source, final ParsePosition pos); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale(); public int getMaxLengthEstimate(); public boolean equals(final Object obj); public int hashCode(); public String toString(); protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf); long serialVersionUID=Optional[2L]; int FULL=Optional[DateFormat.FULL]; int LONG=Optional[DateFormat.LONG]; int MEDIUM=Optional[DateFormat.MEDIUM]; int SHORT=Optional[DateFormat.SHORT]; FormatCache<FastDateFormat> cache=Optional[new FormatCache<FastDateFormat>() {; ;     @Override;     protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) {;         return new FastDateFormat(pattern, timeZone, locale);;     }; }
@Override [EOL] protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) { [EOL]     return new FastDateFormat(pattern, timeZone, locale); [EOL] } protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale); protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getInstance(); public static FastDateFormat getInstance(final String pattern); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone); public static FastDateFormat getInstance(final String pattern, final Locale locale); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateInstance(final int style); public static FastDateFormat getDateInstance(final int style, final Locale locale); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getTimeInstance(final int style); public static FastDateFormat getTimeInstance(final int style, final Locale locale); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale); public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos); public String format(final long millis); public String format(final Date date); public String format(final Calendar calendar); public StringBuffer format(final long millis, final StringBuffer buf); public StringBuffer format(final Date date, final StringBuffer buf); public StringBuffer format(final Calendar calendar, final StringBuffer buf); public Date parse(final String source) throws ParseException; public Date parse(final String source, final ParsePosition pos); public Object parseObject(final String source, final ParsePosition pos); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale(); public int getMaxLengthEstimate(); public boolean equals(final Object obj); public int hashCode(); public String toString(); protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf); long serialVersionUID=Optional[2L]; int FULL=Optional[DateFormat.FULL]; int LONG=Optional[DateFormat.LONG]; int MEDIUM=Optional[DateFormat.MEDIUM]; int SHORT=Optional[DateFormat.SHORT]; FormatCache<FastDateFormat> cache=Optional[new FormatCache<FastDateFormat>() {; ;     @Override;     protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) {;         return new FastDateFormat(pattern, timeZone, locale);;     }; }
@Override [EOL] protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) { [EOL]     return new FastDateFormat(pattern, timeZone, locale); [EOL] } protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale); protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getInstance(); public static FastDateFormat getInstance(final String pattern); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone); public static FastDateFormat getInstance(final String pattern, final Locale locale); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateInstance(final int style); public static FastDateFormat getDateInstance(final int style, final Locale locale); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getTimeInstance(final int style); public static FastDateFormat getTimeInstance(final int style, final Locale locale); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale); public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos); public String format(final long millis); public String format(final Date date); public String format(final Calendar calendar); public StringBuffer format(final long millis, final StringBuffer buf); public StringBuffer format(final Date date, final StringBuffer buf); public StringBuffer format(final Calendar calendar, final StringBuffer buf); public Date parse(final String source) throws ParseException; public Date parse(final String source, final ParsePosition pos); public Object parseObject(final String source, final ParsePosition pos); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale(); public int getMaxLengthEstimate(); public boolean equals(final Object obj); public int hashCode(); public String toString(); protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf); long serialVersionUID=Optional[2L]; int FULL=Optional[DateFormat.FULL]; int LONG=Optional[DateFormat.LONG]; int MEDIUM=Optional[DateFormat.MEDIUM]; int SHORT=Optional[DateFormat.SHORT]; FormatCache<FastDateFormat> cache=Optional[new FormatCache<FastDateFormat>() {; ;     @Override;     protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) {;         return new FastDateFormat(pattern, timeZone, locale);;     }; }
@Override [EOL] protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) { [EOL]     return new FastDateFormat(pattern, timeZone, locale); [EOL] } protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale); protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getInstance(); public static FastDateFormat getInstance(final String pattern); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone); public static FastDateFormat getInstance(final String pattern, final Locale locale); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateInstance(final int style); public static FastDateFormat getDateInstance(final int style, final Locale locale); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getTimeInstance(final int style); public static FastDateFormat getTimeInstance(final int style, final Locale locale); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale); public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos); public String format(final long millis); public String format(final Date date); public String format(final Calendar calendar); public StringBuffer format(final long millis, final StringBuffer buf); public StringBuffer format(final Date date, final StringBuffer buf); public StringBuffer format(final Calendar calendar, final StringBuffer buf); public Date parse(final String source) throws ParseException; public Date parse(final String source, final ParsePosition pos); public Object parseObject(final String source, final ParsePosition pos); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale(); public int getMaxLengthEstimate(); public boolean equals(final Object obj); public int hashCode(); public String toString(); protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf); long serialVersionUID=Optional[2L]; int FULL=Optional[DateFormat.FULL]; int LONG=Optional[DateFormat.LONG]; int MEDIUM=Optional[DateFormat.MEDIUM]; int SHORT=Optional[DateFormat.SHORT]; FormatCache<FastDateFormat> cache=Optional[new FormatCache<FastDateFormat>() {; ;     @Override;     protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) {;         return new FastDateFormat(pattern, timeZone, locale);;     }; }
public static FastDateFormat getInstance(final String pattern) { [EOL]     return cache.getInstance(pattern, null, null); [EOL] } protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale); protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getInstance(); public static FastDateFormat getInstance(final String pattern); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone); public static FastDateFormat getInstance(final String pattern, final Locale locale); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateInstance(final int style); public static FastDateFormat getDateInstance(final int style, final Locale locale); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getTimeInstance(final int style); public static FastDateFormat getTimeInstance(final int style, final Locale locale); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale); public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos); public String format(final long millis); public String format(final Date date); public String format(final Calendar calendar); public StringBuffer format(final long millis, final StringBuffer buf); public StringBuffer format(final Date date, final StringBuffer buf); public StringBuffer format(final Calendar calendar, final StringBuffer buf); public Date parse(final String source) throws ParseException; public Date parse(final String source, final ParsePosition pos); public Object parseObject(final String source, final ParsePosition pos); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale(); public int getMaxLengthEstimate(); public boolean equals(final Object obj); public int hashCode(); public String toString(); protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf); long serialVersionUID=Optional[2L]; int FULL=Optional[DateFormat.FULL]; int LONG=Optional[DateFormat.LONG]; int MEDIUM=Optional[DateFormat.MEDIUM]; int SHORT=Optional[DateFormat.SHORT]; FormatCache<FastDateFormat> cache=Optional[new FormatCache<FastDateFormat>() {; ;     @Override;     protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) {;         return new FastDateFormat(pattern, timeZone, locale);;     }; }
public static FastDateFormat getInstance(final String pattern, final Locale locale) { [EOL]     return cache.getInstance(pattern, null, locale); [EOL] } protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale); protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getInstance(); public static FastDateFormat getInstance(final String pattern); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone); public static FastDateFormat getInstance(final String pattern, final Locale locale); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateInstance(final int style); public static FastDateFormat getDateInstance(final int style, final Locale locale); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getTimeInstance(final int style); public static FastDateFormat getTimeInstance(final int style, final Locale locale); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale); public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos); public String format(final long millis); public String format(final Date date); public String format(final Calendar calendar); public StringBuffer format(final long millis, final StringBuffer buf); public StringBuffer format(final Date date, final StringBuffer buf); public StringBuffer format(final Calendar calendar, final StringBuffer buf); public Date parse(final String source) throws ParseException; public Date parse(final String source, final ParsePosition pos); public Object parseObject(final String source, final ParsePosition pos); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale(); public int getMaxLengthEstimate(); public boolean equals(final Object obj); public int hashCode(); public String toString(); protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf); long serialVersionUID=Optional[2L]; int FULL=Optional[DateFormat.FULL]; int LONG=Optional[DateFormat.LONG]; int MEDIUM=Optional[DateFormat.MEDIUM]; int SHORT=Optional[DateFormat.SHORT]; FormatCache<FastDateFormat> cache=Optional[new FormatCache<FastDateFormat>() {; ;     @Override;     protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) {;         return new FastDateFormat(pattern, timeZone, locale);;     }; }
protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale) { [EOL]     printer = new FastDatePrinter(pattern, timeZone, locale); [EOL]     parser = new FastDateParser(pattern, timeZone, locale); [EOL] } protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale); protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getInstance(); public static FastDateFormat getInstance(final String pattern); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone); public static FastDateFormat getInstance(final String pattern, final Locale locale); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateInstance(final int style); public static FastDateFormat getDateInstance(final int style, final Locale locale); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getTimeInstance(final int style); public static FastDateFormat getTimeInstance(final int style, final Locale locale); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale); public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos); public String format(final long millis); public String format(final Date date); public String format(final Calendar calendar); public StringBuffer format(final long millis, final StringBuffer buf); public StringBuffer format(final Date date, final StringBuffer buf); public StringBuffer format(final Calendar calendar, final StringBuffer buf); public Date parse(final String source) throws ParseException; public Date parse(final String source, final ParsePosition pos); public Object parseObject(final String source, final ParsePosition pos); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale(); public int getMaxLengthEstimate(); public boolean equals(final Object obj); public int hashCode(); public String toString(); protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf); long serialVersionUID=Optional[2L]; int FULL=Optional[DateFormat.FULL]; int LONG=Optional[DateFormat.LONG]; int MEDIUM=Optional[DateFormat.MEDIUM]; int SHORT=Optional[DateFormat.SHORT]; FormatCache<FastDateFormat> cache=Optional[new FormatCache<FastDateFormat>() {; ;     @Override;     protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) {;         return new FastDateFormat(pattern, timeZone, locale);;     }; }
protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale) { [EOL]     printer = new FastDatePrinter(pattern, timeZone, locale); [EOL]     parser = new FastDateParser(pattern, timeZone, locale); [EOL] } protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale); protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getInstance(); public static FastDateFormat getInstance(final String pattern); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone); public static FastDateFormat getInstance(final String pattern, final Locale locale); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateInstance(final int style); public static FastDateFormat getDateInstance(final int style, final Locale locale); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getTimeInstance(final int style); public static FastDateFormat getTimeInstance(final int style, final Locale locale); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale); public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos); public String format(final long millis); public String format(final Date date); public String format(final Calendar calendar); public StringBuffer format(final long millis, final StringBuffer buf); public StringBuffer format(final Date date, final StringBuffer buf); public StringBuffer format(final Calendar calendar, final StringBuffer buf); public Date parse(final String source) throws ParseException; public Date parse(final String source, final ParsePosition pos); public Object parseObject(final String source, final ParsePosition pos); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale(); public int getMaxLengthEstimate(); public boolean equals(final Object obj); public int hashCode(); public String toString(); protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf); long serialVersionUID=Optional[2L]; int FULL=Optional[DateFormat.FULL]; int LONG=Optional[DateFormat.LONG]; int MEDIUM=Optional[DateFormat.MEDIUM]; int SHORT=Optional[DateFormat.SHORT]; FormatCache<FastDateFormat> cache=Optional[new FormatCache<FastDateFormat>() {; ;     @Override;     protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) {;         return new FastDateFormat(pattern, timeZone, locale);;     }; }
protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale) { [EOL]     printer = new FastDatePrinter(pattern, timeZone, locale); [EOL]     parser = new FastDateParser(pattern, timeZone, locale); [EOL] } protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale); protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getInstance(); public static FastDateFormat getInstance(final String pattern); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone); public static FastDateFormat getInstance(final String pattern, final Locale locale); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateInstance(final int style); public static FastDateFormat getDateInstance(final int style, final Locale locale); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getTimeInstance(final int style); public static FastDateFormat getTimeInstance(final int style, final Locale locale); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale); public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos); public String format(final long millis); public String format(final Date date); public String format(final Calendar calendar); public StringBuffer format(final long millis, final StringBuffer buf); public StringBuffer format(final Date date, final StringBuffer buf); public StringBuffer format(final Calendar calendar, final StringBuffer buf); public Date parse(final String source) throws ParseException; public Date parse(final String source, final ParsePosition pos); public Object parseObject(final String source, final ParsePosition pos); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale(); public int getMaxLengthEstimate(); public boolean equals(final Object obj); public int hashCode(); public String toString(); protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf); long serialVersionUID=Optional[2L]; int FULL=Optional[DateFormat.FULL]; int LONG=Optional[DateFormat.LONG]; int MEDIUM=Optional[DateFormat.MEDIUM]; int SHORT=Optional[DateFormat.SHORT]; FormatCache<FastDateFormat> cache=Optional[new FormatCache<FastDateFormat>() {; ;     @Override;     protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) {;         return new FastDateFormat(pattern, timeZone, locale);;     }; }
protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale) { [EOL]     printer = new FastDatePrinter(pattern, timeZone, locale); [EOL]     parser = new FastDateParser(pattern, timeZone, locale); [EOL] } protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale); protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getInstance(); public static FastDateFormat getInstance(final String pattern); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone); public static FastDateFormat getInstance(final String pattern, final Locale locale); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateInstance(final int style); public static FastDateFormat getDateInstance(final int style, final Locale locale); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getTimeInstance(final int style); public static FastDateFormat getTimeInstance(final int style, final Locale locale); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale); public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos); public String format(final long millis); public String format(final Date date); public String format(final Calendar calendar); public StringBuffer format(final long millis, final StringBuffer buf); public StringBuffer format(final Date date, final StringBuffer buf); public StringBuffer format(final Calendar calendar, final StringBuffer buf); public Date parse(final String source) throws ParseException; public Date parse(final String source, final ParsePosition pos); public Object parseObject(final String source, final ParsePosition pos); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale(); public int getMaxLengthEstimate(); public boolean equals(final Object obj); public int hashCode(); public String toString(); protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf); long serialVersionUID=Optional[2L]; int FULL=Optional[DateFormat.FULL]; int LONG=Optional[DateFormat.LONG]; int MEDIUM=Optional[DateFormat.MEDIUM]; int SHORT=Optional[DateFormat.SHORT]; FormatCache<FastDateFormat> cache=Optional[new FormatCache<FastDateFormat>() {; ;     @Override;     protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) {;         return new FastDateFormat(pattern, timeZone, locale);;     }; }
protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale) { [EOL]     printer = new FastDatePrinter(pattern, timeZone, locale); [EOL]     parser = new FastDateParser(pattern, timeZone, locale); [EOL] } protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale); protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getInstance(); public static FastDateFormat getInstance(final String pattern); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone); public static FastDateFormat getInstance(final String pattern, final Locale locale); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateInstance(final int style); public static FastDateFormat getDateInstance(final int style, final Locale locale); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getTimeInstance(final int style); public static FastDateFormat getTimeInstance(final int style, final Locale locale); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale); public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos); public String format(final long millis); public String format(final Date date); public String format(final Calendar calendar); public StringBuffer format(final long millis, final StringBuffer buf); public StringBuffer format(final Date date, final StringBuffer buf); public StringBuffer format(final Calendar calendar, final StringBuffer buf); public Date parse(final String source) throws ParseException; public Date parse(final String source, final ParsePosition pos); public Object parseObject(final String source, final ParsePosition pos); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale(); public int getMaxLengthEstimate(); public boolean equals(final Object obj); public int hashCode(); public String toString(); protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf); long serialVersionUID=Optional[2L]; int FULL=Optional[DateFormat.FULL]; int LONG=Optional[DateFormat.LONG]; int MEDIUM=Optional[DateFormat.MEDIUM]; int SHORT=Optional[DateFormat.SHORT]; FormatCache<FastDateFormat> cache=Optional[new FormatCache<FastDateFormat>() {; ;     @Override;     protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) {;         return new FastDateFormat(pattern, timeZone, locale);;     }; }
protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale) { [EOL]     printer = new FastDatePrinter(pattern, timeZone, locale); [EOL]     parser = new FastDateParser(pattern, timeZone, locale); [EOL] } protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale); protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getInstance(); public static FastDateFormat getInstance(final String pattern); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone); public static FastDateFormat getInstance(final String pattern, final Locale locale); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateInstance(final int style); public static FastDateFormat getDateInstance(final int style, final Locale locale); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getTimeInstance(final int style); public static FastDateFormat getTimeInstance(final int style, final Locale locale); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale); public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos); public String format(final long millis); public String format(final Date date); public String format(final Calendar calendar); public StringBuffer format(final long millis, final StringBuffer buf); public StringBuffer format(final Date date, final StringBuffer buf); public StringBuffer format(final Calendar calendar, final StringBuffer buf); public Date parse(final String source) throws ParseException; public Date parse(final String source, final ParsePosition pos); public Object parseObject(final String source, final ParsePosition pos); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale(); public int getMaxLengthEstimate(); public boolean equals(final Object obj); public int hashCode(); public String toString(); protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf); long serialVersionUID=Optional[2L]; int FULL=Optional[DateFormat.FULL]; int LONG=Optional[DateFormat.LONG]; int MEDIUM=Optional[DateFormat.MEDIUM]; int SHORT=Optional[DateFormat.SHORT]; FormatCache<FastDateFormat> cache=Optional[new FormatCache<FastDateFormat>() {; ;     @Override;     protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) {;         return new FastDateFormat(pattern, timeZone, locale);;     }; }
protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale) { [EOL]     printer = new FastDatePrinter(pattern, timeZone, locale); [EOL]     parser = new FastDateParser(pattern, timeZone, locale); [EOL] } protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale); protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getInstance(); public static FastDateFormat getInstance(final String pattern); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone); public static FastDateFormat getInstance(final String pattern, final Locale locale); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateInstance(final int style); public static FastDateFormat getDateInstance(final int style, final Locale locale); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getTimeInstance(final int style); public static FastDateFormat getTimeInstance(final int style, final Locale locale); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale); public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos); public String format(final long millis); public String format(final Date date); public String format(final Calendar calendar); public StringBuffer format(final long millis, final StringBuffer buf); public StringBuffer format(final Date date, final StringBuffer buf); public StringBuffer format(final Calendar calendar, final StringBuffer buf); public Date parse(final String source) throws ParseException; public Date parse(final String source, final ParsePosition pos); public Object parseObject(final String source, final ParsePosition pos); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale(); public int getMaxLengthEstimate(); public boolean equals(final Object obj); public int hashCode(); public String toString(); protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf); long serialVersionUID=Optional[2L]; int FULL=Optional[DateFormat.FULL]; int LONG=Optional[DateFormat.LONG]; int MEDIUM=Optional[DateFormat.MEDIUM]; int SHORT=Optional[DateFormat.SHORT]; FormatCache<FastDateFormat> cache=Optional[new FormatCache<FastDateFormat>() {; ;     @Override;     protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) {;         return new FastDateFormat(pattern, timeZone, locale);;     }; }
protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale) { [EOL]     printer = new FastDatePrinter(pattern, timeZone, locale); [EOL]     parser = new FastDateParser(pattern, timeZone, locale); [EOL] } protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale); protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getInstance(); public static FastDateFormat getInstance(final String pattern); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone); public static FastDateFormat getInstance(final String pattern, final Locale locale); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateInstance(final int style); public static FastDateFormat getDateInstance(final int style, final Locale locale); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getTimeInstance(final int style); public static FastDateFormat getTimeInstance(final int style, final Locale locale); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale); public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos); public String format(final long millis); public String format(final Date date); public String format(final Calendar calendar); public StringBuffer format(final long millis, final StringBuffer buf); public StringBuffer format(final Date date, final StringBuffer buf); public StringBuffer format(final Calendar calendar, final StringBuffer buf); public Date parse(final String source) throws ParseException; public Date parse(final String source, final ParsePosition pos); public Object parseObject(final String source, final ParsePosition pos); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale(); public int getMaxLengthEstimate(); public boolean equals(final Object obj); public int hashCode(); public String toString(); protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf); long serialVersionUID=Optional[2L]; int FULL=Optional[DateFormat.FULL]; int LONG=Optional[DateFormat.LONG]; int MEDIUM=Optional[DateFormat.MEDIUM]; int SHORT=Optional[DateFormat.SHORT]; FormatCache<FastDateFormat> cache=Optional[new FormatCache<FastDateFormat>() {; ;     @Override;     protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) {;         return new FastDateFormat(pattern, timeZone, locale);;     }; }
protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale) { [EOL]     printer = new FastDatePrinter(pattern, timeZone, locale); [EOL]     parser = new FastDateParser(pattern, timeZone, locale); [EOL] } protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale); protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getInstance(); public static FastDateFormat getInstance(final String pattern); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone); public static FastDateFormat getInstance(final String pattern, final Locale locale); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateInstance(final int style); public static FastDateFormat getDateInstance(final int style, final Locale locale); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getTimeInstance(final int style); public static FastDateFormat getTimeInstance(final int style, final Locale locale); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale); public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos); public String format(final long millis); public String format(final Date date); public String format(final Calendar calendar); public StringBuffer format(final long millis, final StringBuffer buf); public StringBuffer format(final Date date, final StringBuffer buf); public StringBuffer format(final Calendar calendar, final StringBuffer buf); public Date parse(final String source) throws ParseException; public Date parse(final String source, final ParsePosition pos); public Object parseObject(final String source, final ParsePosition pos); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale(); public int getMaxLengthEstimate(); public boolean equals(final Object obj); public int hashCode(); public String toString(); protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf); long serialVersionUID=Optional[2L]; int FULL=Optional[DateFormat.FULL]; int LONG=Optional[DateFormat.LONG]; int MEDIUM=Optional[DateFormat.MEDIUM]; int SHORT=Optional[DateFormat.SHORT]; FormatCache<FastDateFormat> cache=Optional[new FormatCache<FastDateFormat>() {; ;     @Override;     protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) {;         return new FastDateFormat(pattern, timeZone, locale);;     }; }
protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale) { [EOL]     printer = new FastDatePrinter(pattern, timeZone, locale); [EOL]     parser = new FastDateParser(pattern, timeZone, locale); [EOL] } protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale); protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getInstance(); public static FastDateFormat getInstance(final String pattern); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone); public static FastDateFormat getInstance(final String pattern, final Locale locale); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateInstance(final int style); public static FastDateFormat getDateInstance(final int style, final Locale locale); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getTimeInstance(final int style); public static FastDateFormat getTimeInstance(final int style, final Locale locale); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale); public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos); public String format(final long millis); public String format(final Date date); public String format(final Calendar calendar); public StringBuffer format(final long millis, final StringBuffer buf); public StringBuffer format(final Date date, final StringBuffer buf); public StringBuffer format(final Calendar calendar, final StringBuffer buf); public Date parse(final String source) throws ParseException; public Date parse(final String source, final ParsePosition pos); public Object parseObject(final String source, final ParsePosition pos); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale(); public int getMaxLengthEstimate(); public boolean equals(final Object obj); public int hashCode(); public String toString(); protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf); long serialVersionUID=Optional[2L]; int FULL=Optional[DateFormat.FULL]; int LONG=Optional[DateFormat.LONG]; int MEDIUM=Optional[DateFormat.MEDIUM]; int SHORT=Optional[DateFormat.SHORT]; FormatCache<FastDateFormat> cache=Optional[new FormatCache<FastDateFormat>() {; ;     @Override;     protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) {;         return new FastDateFormat(pattern, timeZone, locale);;     }; }
protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale) { [EOL]     printer = new FastDatePrinter(pattern, timeZone, locale); [EOL]     parser = new FastDateParser(pattern, timeZone, locale); [EOL] } protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale); protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getInstance(); public static FastDateFormat getInstance(final String pattern); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone); public static FastDateFormat getInstance(final String pattern, final Locale locale); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateInstance(final int style); public static FastDateFormat getDateInstance(final int style, final Locale locale); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getTimeInstance(final int style); public static FastDateFormat getTimeInstance(final int style, final Locale locale); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale); public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos); public String format(final long millis); public String format(final Date date); public String format(final Calendar calendar); public StringBuffer format(final long millis, final StringBuffer buf); public StringBuffer format(final Date date, final StringBuffer buf); public StringBuffer format(final Calendar calendar, final StringBuffer buf); public Date parse(final String source) throws ParseException; public Date parse(final String source, final ParsePosition pos); public Object parseObject(final String source, final ParsePosition pos); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale(); public int getMaxLengthEstimate(); public boolean equals(final Object obj); public int hashCode(); public String toString(); protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf); long serialVersionUID=Optional[2L]; int FULL=Optional[DateFormat.FULL]; int LONG=Optional[DateFormat.LONG]; int MEDIUM=Optional[DateFormat.MEDIUM]; int SHORT=Optional[DateFormat.SHORT]; FormatCache<FastDateFormat> cache=Optional[new FormatCache<FastDateFormat>() {; ;     @Override;     protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) {;         return new FastDateFormat(pattern, timeZone, locale);;     }; }
protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale) { [EOL]     printer = new FastDatePrinter(pattern, timeZone, locale); [EOL]     parser = new FastDateParser(pattern, timeZone, locale); [EOL] } protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale); protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getInstance(); public static FastDateFormat getInstance(final String pattern); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone); public static FastDateFormat getInstance(final String pattern, final Locale locale); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateInstance(final int style); public static FastDateFormat getDateInstance(final int style, final Locale locale); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getTimeInstance(final int style); public static FastDateFormat getTimeInstance(final int style, final Locale locale); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale); public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos); public String format(final long millis); public String format(final Date date); public String format(final Calendar calendar); public StringBuffer format(final long millis, final StringBuffer buf); public StringBuffer format(final Date date, final StringBuffer buf); public StringBuffer format(final Calendar calendar, final StringBuffer buf); public Date parse(final String source) throws ParseException; public Date parse(final String source, final ParsePosition pos); public Object parseObject(final String source, final ParsePosition pos); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale(); public int getMaxLengthEstimate(); public boolean equals(final Object obj); public int hashCode(); public String toString(); protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf); long serialVersionUID=Optional[2L]; int FULL=Optional[DateFormat.FULL]; int LONG=Optional[DateFormat.LONG]; int MEDIUM=Optional[DateFormat.MEDIUM]; int SHORT=Optional[DateFormat.SHORT]; FormatCache<FastDateFormat> cache=Optional[new FormatCache<FastDateFormat>() {; ;     @Override;     protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) {;         return new FastDateFormat(pattern, timeZone, locale);;     }; }
protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale) { [EOL]     printer = new FastDatePrinter(pattern, timeZone, locale); [EOL]     parser = new FastDateParser(pattern, timeZone, locale); [EOL] } protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale); protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getInstance(); public static FastDateFormat getInstance(final String pattern); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone); public static FastDateFormat getInstance(final String pattern, final Locale locale); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateInstance(final int style); public static FastDateFormat getDateInstance(final int style, final Locale locale); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getTimeInstance(final int style); public static FastDateFormat getTimeInstance(final int style, final Locale locale); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale); public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos); public String format(final long millis); public String format(final Date date); public String format(final Calendar calendar); public StringBuffer format(final long millis, final StringBuffer buf); public StringBuffer format(final Date date, final StringBuffer buf); public StringBuffer format(final Calendar calendar, final StringBuffer buf); public Date parse(final String source) throws ParseException; public Date parse(final String source, final ParsePosition pos); public Object parseObject(final String source, final ParsePosition pos); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale(); public int getMaxLengthEstimate(); public boolean equals(final Object obj); public int hashCode(); public String toString(); protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf); long serialVersionUID=Optional[2L]; int FULL=Optional[DateFormat.FULL]; int LONG=Optional[DateFormat.LONG]; int MEDIUM=Optional[DateFormat.MEDIUM]; int SHORT=Optional[DateFormat.SHORT]; FormatCache<FastDateFormat> cache=Optional[new FormatCache<FastDateFormat>() {; ;     @Override;     protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) {;         return new FastDateFormat(pattern, timeZone, locale);;     }; }
protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale) { [EOL]     printer = new FastDatePrinter(pattern, timeZone, locale); [EOL]     parser = new FastDateParser(pattern, timeZone, locale); [EOL] } protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale); protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getInstance(); public static FastDateFormat getInstance(final String pattern); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone); public static FastDateFormat getInstance(final String pattern, final Locale locale); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateInstance(final int style); public static FastDateFormat getDateInstance(final int style, final Locale locale); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getTimeInstance(final int style); public static FastDateFormat getTimeInstance(final int style, final Locale locale); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale); public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos); public String format(final long millis); public String format(final Date date); public String format(final Calendar calendar); public StringBuffer format(final long millis, final StringBuffer buf); public StringBuffer format(final Date date, final StringBuffer buf); public StringBuffer format(final Calendar calendar, final StringBuffer buf); public Date parse(final String source) throws ParseException; public Date parse(final String source, final ParsePosition pos); public Object parseObject(final String source, final ParsePosition pos); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale(); public int getMaxLengthEstimate(); public boolean equals(final Object obj); public int hashCode(); public String toString(); protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf); long serialVersionUID=Optional[2L]; int FULL=Optional[DateFormat.FULL]; int LONG=Optional[DateFormat.LONG]; int MEDIUM=Optional[DateFormat.MEDIUM]; int SHORT=Optional[DateFormat.SHORT]; FormatCache<FastDateFormat> cache=Optional[new FormatCache<FastDateFormat>() {; ;     @Override;     protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) {;         return new FastDateFormat(pattern, timeZone, locale);;     }; }
protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale) { [EOL]     printer = new FastDatePrinter(pattern, timeZone, locale); [EOL]     parser = new FastDateParser(pattern, timeZone, locale); [EOL] } protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale); protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getInstance(); public static FastDateFormat getInstance(final String pattern); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone); public static FastDateFormat getInstance(final String pattern, final Locale locale); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateInstance(final int style); public static FastDateFormat getDateInstance(final int style, final Locale locale); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getTimeInstance(final int style); public static FastDateFormat getTimeInstance(final int style, final Locale locale); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale); public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos); public String format(final long millis); public String format(final Date date); public String format(final Calendar calendar); public StringBuffer format(final long millis, final StringBuffer buf); public StringBuffer format(final Date date, final StringBuffer buf); public StringBuffer format(final Calendar calendar, final StringBuffer buf); public Date parse(final String source) throws ParseException; public Date parse(final String source, final ParsePosition pos); public Object parseObject(final String source, final ParsePosition pos); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale(); public int getMaxLengthEstimate(); public boolean equals(final Object obj); public int hashCode(); public String toString(); protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf); long serialVersionUID=Optional[2L]; int FULL=Optional[DateFormat.FULL]; int LONG=Optional[DateFormat.LONG]; int MEDIUM=Optional[DateFormat.MEDIUM]; int SHORT=Optional[DateFormat.SHORT]; FormatCache<FastDateFormat> cache=Optional[new FormatCache<FastDateFormat>() {; ;     @Override;     protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) {;         return new FastDateFormat(pattern, timeZone, locale);;     }; }
protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale) { [EOL]     printer = new FastDatePrinter(pattern, timeZone, locale); [EOL]     parser = new FastDateParser(pattern, timeZone, locale); [EOL] } protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale); protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getInstance(); public static FastDateFormat getInstance(final String pattern); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone); public static FastDateFormat getInstance(final String pattern, final Locale locale); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateInstance(final int style); public static FastDateFormat getDateInstance(final int style, final Locale locale); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getTimeInstance(final int style); public static FastDateFormat getTimeInstance(final int style, final Locale locale); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale); public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos); public String format(final long millis); public String format(final Date date); public String format(final Calendar calendar); public StringBuffer format(final long millis, final StringBuffer buf); public StringBuffer format(final Date date, final StringBuffer buf); public StringBuffer format(final Calendar calendar, final StringBuffer buf); public Date parse(final String source) throws ParseException; public Date parse(final String source, final ParsePosition pos); public Object parseObject(final String source, final ParsePosition pos); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale(); public int getMaxLengthEstimate(); public boolean equals(final Object obj); public int hashCode(); public String toString(); protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf); long serialVersionUID=Optional[2L]; int FULL=Optional[DateFormat.FULL]; int LONG=Optional[DateFormat.LONG]; int MEDIUM=Optional[DateFormat.MEDIUM]; int SHORT=Optional[DateFormat.SHORT]; FormatCache<FastDateFormat> cache=Optional[new FormatCache<FastDateFormat>() {; ;     @Override;     protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) {;         return new FastDateFormat(pattern, timeZone, locale);;     }; }
protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale) { [EOL]     printer = new FastDatePrinter(pattern, timeZone, locale); [EOL]     parser = new FastDateParser(pattern, timeZone, locale); [EOL] } protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale); protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getInstance(); public static FastDateFormat getInstance(final String pattern); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone); public static FastDateFormat getInstance(final String pattern, final Locale locale); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateInstance(final int style); public static FastDateFormat getDateInstance(final int style, final Locale locale); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getTimeInstance(final int style); public static FastDateFormat getTimeInstance(final int style, final Locale locale); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale); public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos); public String format(final long millis); public String format(final Date date); public String format(final Calendar calendar); public StringBuffer format(final long millis, final StringBuffer buf); public StringBuffer format(final Date date, final StringBuffer buf); public StringBuffer format(final Calendar calendar, final StringBuffer buf); public Date parse(final String source) throws ParseException; public Date parse(final String source, final ParsePosition pos); public Object parseObject(final String source, final ParsePosition pos); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale(); public int getMaxLengthEstimate(); public boolean equals(final Object obj); public int hashCode(); public String toString(); protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf); long serialVersionUID=Optional[2L]; int FULL=Optional[DateFormat.FULL]; int LONG=Optional[DateFormat.LONG]; int MEDIUM=Optional[DateFormat.MEDIUM]; int SHORT=Optional[DateFormat.SHORT]; FormatCache<FastDateFormat> cache=Optional[new FormatCache<FastDateFormat>() {; ;     @Override;     protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) {;         return new FastDateFormat(pattern, timeZone, locale);;     }; }
protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale) { [EOL]     printer = new FastDatePrinter(pattern, timeZone, locale); [EOL]     parser = new FastDateParser(pattern, timeZone, locale); [EOL] } protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale); protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getInstance(); public static FastDateFormat getInstance(final String pattern); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone); public static FastDateFormat getInstance(final String pattern, final Locale locale); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateInstance(final int style); public static FastDateFormat getDateInstance(final int style, final Locale locale); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getTimeInstance(final int style); public static FastDateFormat getTimeInstance(final int style, final Locale locale); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale); public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos); public String format(final long millis); public String format(final Date date); public String format(final Calendar calendar); public StringBuffer format(final long millis, final StringBuffer buf); public StringBuffer format(final Date date, final StringBuffer buf); public StringBuffer format(final Calendar calendar, final StringBuffer buf); public Date parse(final String source) throws ParseException; public Date parse(final String source, final ParsePosition pos); public Object parseObject(final String source, final ParsePosition pos); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale(); public int getMaxLengthEstimate(); public boolean equals(final Object obj); public int hashCode(); public String toString(); protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf); long serialVersionUID=Optional[2L]; int FULL=Optional[DateFormat.FULL]; int LONG=Optional[DateFormat.LONG]; int MEDIUM=Optional[DateFormat.MEDIUM]; int SHORT=Optional[DateFormat.SHORT]; FormatCache<FastDateFormat> cache=Optional[new FormatCache<FastDateFormat>() {; ;     @Override;     protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) {;         return new FastDateFormat(pattern, timeZone, locale);;     }; }
@Override [EOL] public Locale getLocale() { [EOL]     return printer.getLocale(); [EOL] } protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale); protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getInstance(); public static FastDateFormat getInstance(final String pattern); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone); public static FastDateFormat getInstance(final String pattern, final Locale locale); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateInstance(final int style); public static FastDateFormat getDateInstance(final int style, final Locale locale); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getTimeInstance(final int style); public static FastDateFormat getTimeInstance(final int style, final Locale locale); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale); public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos); public String format(final long millis); public String format(final Date date); public String format(final Calendar calendar); public StringBuffer format(final long millis, final StringBuffer buf); public StringBuffer format(final Date date, final StringBuffer buf); public StringBuffer format(final Calendar calendar, final StringBuffer buf); public Date parse(final String source) throws ParseException; public Date parse(final String source, final ParsePosition pos); public Object parseObject(final String source, final ParsePosition pos); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale(); public int getMaxLengthEstimate(); public boolean equals(final Object obj); public int hashCode(); public String toString(); protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf); long serialVersionUID=Optional[2L]; int FULL=Optional[DateFormat.FULL]; int LONG=Optional[DateFormat.LONG]; int MEDIUM=Optional[DateFormat.MEDIUM]; int SHORT=Optional[DateFormat.SHORT]; FormatCache<FastDateFormat> cache=Optional[new FormatCache<FastDateFormat>() {; ;     @Override;     protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) {;         return new FastDateFormat(pattern, timeZone, locale);;     }; }
public static File getJavaHome() { [EOL]     return new File(System.getProperty(JAVA_HOME_KEY)); [EOL] }
static boolean isOSMatch(final String osName, final String osVersion, final String osNamePrefix, final String osVersionPrefix) { [EOL]     if (osName == null || osVersion == null) { [EOL]         return false; [EOL]     } [EOL]     return osName.startsWith(osNamePrefix) && osVersion.startsWith(osVersionPrefix); [EOL] }
static boolean isOSMatch(final String osName, final String osVersion, final String osNamePrefix, final String osVersionPrefix) { [EOL]     if (osName == null || osVersion == null) { [EOL]         return false; [EOL]     } [EOL]     return osName.startsWith(osNamePrefix) && osVersion.startsWith(osVersionPrefix); [EOL] }
static boolean isOSNameMatch(final String osName, final String osNamePrefix) { [EOL]     if (osName == null) { [EOL]         return false; [EOL]     } [EOL]     return osName.startsWith(osNamePrefix); [EOL] }
public static <L, M, R> MutableTriple<L, M, R> of(final L left, final M middle, final R right) { [EOL]     return new MutableTriple<L, M, R>(left, middle, right); [EOL] }
public static <L, M, R> MutableTriple<L, M, R> of(final L left, final M middle, final R right) { [EOL]     return new MutableTriple<L, M, R>(left, middle, right); [EOL] }
public MutableTriple(final L left, final M middle, final R right) { [EOL]     super(); [EOL]     this.left = left; [EOL]     this.middle = middle; [EOL]     this.right = right; [EOL] }
@Override [EOL] public L getLeft() { [EOL]     return left; [EOL] }
public void setLeft(final L left) { [EOL]     this.left = left; [EOL] }
@Override [EOL] public M getMiddle() { [EOL]     return middle; [EOL] }
public void setMiddle(final M middle) { [EOL]     this.middle = middle; [EOL] }
@Override [EOL] public R getRight() { [EOL]     return right; [EOL] }
public void setRight(final R right) { [EOL]     this.right = right; [EOL] }
public static Field getField(final Class<?> cls, final String fieldName, final boolean forceAccess) { [EOL]     if (cls == null) { [EOL]         throw new IllegalArgumentException("The class must not be null"); [EOL]     } [EOL]     if (fieldName == null) { [EOL]         throw new IllegalArgumentException("The field name must not be null"); [EOL]     } [EOL]     for (Class<?> acls = cls; acls != null; acls = acls.getSuperclass()) { [EOL]         try { [EOL]             final Field field = acls.getDeclaredField(fieldName); [EOL]             if (!Modifier.isPublic(field.getModifiers())) { [EOL]                 if (forceAccess) { [EOL]                     field.setAccessible(true); [EOL]                 } else { [EOL]                     continue; [EOL]                 } [EOL]             } [EOL]             return field; [EOL]         } catch (final NoSuchFieldException ex) { [EOL]         } [EOL]     } [EOL]     Field match = null; [EOL]     for (final Class<?> class1 : ClassUtils.getAllInterfaces(cls)) { [EOL]         try { [EOL]             final Field test = ((Class<?>) class1).getField(fieldName); [EOL]             if (match != null) { [EOL]                 throw new IllegalArgumentException("Reference to field " + fieldName + " is ambiguous relative to " + cls + "; a matching field exists on two or more implemented interfaces."); [EOL]             } [EOL]             match = test; [EOL]         } catch (final NoSuchFieldException ex) { [EOL]         } [EOL]     } [EOL]     return match; [EOL] }
public static Field getField(final Class<?> cls, final String fieldName, final boolean forceAccess) { [EOL]     if (cls == null) { [EOL]         throw new IllegalArgumentException("The class must not be null"); [EOL]     } [EOL]     if (fieldName == null) { [EOL]         throw new IllegalArgumentException("The field name must not be null"); [EOL]     } [EOL]     for (Class<?> acls = cls; acls != null; acls = acls.getSuperclass()) { [EOL]         try { [EOL]             final Field field = acls.getDeclaredField(fieldName); [EOL]             if (!Modifier.isPublic(field.getModifiers())) { [EOL]                 if (forceAccess) { [EOL]                     field.setAccessible(true); [EOL]                 } else { [EOL]                     continue; [EOL]                 } [EOL]             } [EOL]             return field; [EOL]         } catch (final NoSuchFieldException ex) { [EOL]         } [EOL]     } [EOL]     Field match = null; [EOL]     for (final Class<?> class1 : ClassUtils.getAllInterfaces(cls)) { [EOL]         try { [EOL]             final Field test = ((Class<?>) class1).getField(fieldName); [EOL]             if (match != null) { [EOL]                 throw new IllegalArgumentException("Reference to field " + fieldName + " is ambiguous relative to " + cls + "; a matching field exists on two or more implemented interfaces."); [EOL]             } [EOL]             match = test; [EOL]         } catch (final NoSuchFieldException ex) { [EOL]         } [EOL]     } [EOL]     return match; [EOL] }
public static Field getField(final Class<?> cls, final String fieldName, final boolean forceAccess) { [EOL]     if (cls == null) { [EOL]         throw new IllegalArgumentException("The class must not be null"); [EOL]     } [EOL]     if (fieldName == null) { [EOL]         throw new IllegalArgumentException("The field name must not be null"); [EOL]     } [EOL]     for (Class<?> acls = cls; acls != null; acls = acls.getSuperclass()) { [EOL]         try { [EOL]             final Field field = acls.getDeclaredField(fieldName); [EOL]             if (!Modifier.isPublic(field.getModifiers())) { [EOL]                 if (forceAccess) { [EOL]                     field.setAccessible(true); [EOL]                 } else { [EOL]                     continue; [EOL]                 } [EOL]             } [EOL]             return field; [EOL]         } catch (final NoSuchFieldException ex) { [EOL]         } [EOL]     } [EOL]     Field match = null; [EOL]     for (final Class<?> class1 : ClassUtils.getAllInterfaces(cls)) { [EOL]         try { [EOL]             final Field test = ((Class<?>) class1).getField(fieldName); [EOL]             if (match != null) { [EOL]                 throw new IllegalArgumentException("Reference to field " + fieldName + " is ambiguous relative to " + cls + "; a matching field exists on two or more implemented interfaces."); [EOL]             } [EOL]             match = test; [EOL]         } catch (final NoSuchFieldException ex) { [EOL]         } [EOL]     } [EOL]     return match; [EOL] }
public static Field getField(final Class<?> cls, final String fieldName, final boolean forceAccess) { [EOL]     if (cls == null) { [EOL]         throw new IllegalArgumentException("The class must not be null"); [EOL]     } [EOL]     if (fieldName == null) { [EOL]         throw new IllegalArgumentException("The field name must not be null"); [EOL]     } [EOL]     for (Class<?> acls = cls; acls != null; acls = acls.getSuperclass()) { [EOL]         try { [EOL]             final Field field = acls.getDeclaredField(fieldName); [EOL]             if (!Modifier.isPublic(field.getModifiers())) { [EOL]                 if (forceAccess) { [EOL]                     field.setAccessible(true); [EOL]                 } else { [EOL]                     continue; [EOL]                 } [EOL]             } [EOL]             return field; [EOL]         } catch (final NoSuchFieldException ex) { [EOL]         } [EOL]     } [EOL]     Field match = null; [EOL]     for (final Class<?> class1 : ClassUtils.getAllInterfaces(cls)) { [EOL]         try { [EOL]             final Field test = ((Class<?>) class1).getField(fieldName); [EOL]             if (match != null) { [EOL]                 throw new IllegalArgumentException("Reference to field " + fieldName + " is ambiguous relative to " + cls + "; a matching field exists on two or more implemented interfaces."); [EOL]             } [EOL]             match = test; [EOL]         } catch (final NoSuchFieldException ex) { [EOL]         } [EOL]     } [EOL]     return match; [EOL] }
public static Field getField(final Class<?> cls, final String fieldName, final boolean forceAccess) { [EOL]     if (cls == null) { [EOL]         throw new IllegalArgumentException("The class must not be null"); [EOL]     } [EOL]     if (fieldName == null) { [EOL]         throw new IllegalArgumentException("The field name must not be null"); [EOL]     } [EOL]     for (Class<?> acls = cls; acls != null; acls = acls.getSuperclass()) { [EOL]         try { [EOL]             final Field field = acls.getDeclaredField(fieldName); [EOL]             if (!Modifier.isPublic(field.getModifiers())) { [EOL]                 if (forceAccess) { [EOL]                     field.setAccessible(true); [EOL]                 } else { [EOL]                     continue; [EOL]                 } [EOL]             } [EOL]             return field; [EOL]         } catch (final NoSuchFieldException ex) { [EOL]         } [EOL]     } [EOL]     Field match = null; [EOL]     for (final Class<?> class1 : ClassUtils.getAllInterfaces(cls)) { [EOL]         try { [EOL]             final Field test = ((Class<?>) class1).getField(fieldName); [EOL]             if (match != null) { [EOL]                 throw new IllegalArgumentException("Reference to field " + fieldName + " is ambiguous relative to " + cls + "; a matching field exists on two or more implemented interfaces."); [EOL]             } [EOL]             match = test; [EOL]         } catch (final NoSuchFieldException ex) { [EOL]         } [EOL]     } [EOL]     return match; [EOL] }
public static Field getField(final Class<?> cls, final String fieldName, final boolean forceAccess) { [EOL]     if (cls == null) { [EOL]         throw new IllegalArgumentException("The class must not be null"); [EOL]     } [EOL]     if (fieldName == null) { [EOL]         throw new IllegalArgumentException("The field name must not be null"); [EOL]     } [EOL]     for (Class<?> acls = cls; acls != null; acls = acls.getSuperclass()) { [EOL]         try { [EOL]             final Field field = acls.getDeclaredField(fieldName); [EOL]             if (!Modifier.isPublic(field.getModifiers())) { [EOL]                 if (forceAccess) { [EOL]                     field.setAccessible(true); [EOL]                 } else { [EOL]                     continue; [EOL]                 } [EOL]             } [EOL]             return field; [EOL]         } catch (final NoSuchFieldException ex) { [EOL]         } [EOL]     } [EOL]     Field match = null; [EOL]     for (final Class<?> class1 : ClassUtils.getAllInterfaces(cls)) { [EOL]         try { [EOL]             final Field test = ((Class<?>) class1).getField(fieldName); [EOL]             if (match != null) { [EOL]                 throw new IllegalArgumentException("Reference to field " + fieldName + " is ambiguous relative to " + cls + "; a matching field exists on two or more implemented interfaces."); [EOL]             } [EOL]             match = test; [EOL]         } catch (final NoSuchFieldException ex) { [EOL]         } [EOL]     } [EOL]     return match; [EOL] }
public static Field getField(final Class<?> cls, final String fieldName, final boolean forceAccess) { [EOL]     if (cls == null) { [EOL]         throw new IllegalArgumentException("The class must not be null"); [EOL]     } [EOL]     if (fieldName == null) { [EOL]         throw new IllegalArgumentException("The field name must not be null"); [EOL]     } [EOL]     for (Class<?> acls = cls; acls != null; acls = acls.getSuperclass()) { [EOL]         try { [EOL]             final Field field = acls.getDeclaredField(fieldName); [EOL]             if (!Modifier.isPublic(field.getModifiers())) { [EOL]                 if (forceAccess) { [EOL]                     field.setAccessible(true); [EOL]                 } else { [EOL]                     continue; [EOL]                 } [EOL]             } [EOL]             return field; [EOL]         } catch (final NoSuchFieldException ex) { [EOL]         } [EOL]     } [EOL]     Field match = null; [EOL]     for (final Class<?> class1 : ClassUtils.getAllInterfaces(cls)) { [EOL]         try { [EOL]             final Field test = ((Class<?>) class1).getField(fieldName); [EOL]             if (match != null) { [EOL]                 throw new IllegalArgumentException("Reference to field " + fieldName + " is ambiguous relative to " + cls + "; a matching field exists on two or more implemented interfaces."); [EOL]             } [EOL]             match = test; [EOL]         } catch (final NoSuchFieldException ex) { [EOL]         } [EOL]     } [EOL]     return match; [EOL] }
public static Field getDeclaredField(final Class<?> cls, final String fieldName, final boolean forceAccess) { [EOL]     if (cls == null) { [EOL]         throw new IllegalArgumentException("The class must not be null"); [EOL]     } [EOL]     if (fieldName == null) { [EOL]         throw new IllegalArgumentException("The field name must not be null"); [EOL]     } [EOL]     try { [EOL]         final Field field = cls.getDeclaredField(fieldName); [EOL]         if (!MemberUtils.isAccessible(field)) { [EOL]             if (forceAccess) { [EOL]                 field.setAccessible(true); [EOL]             } else { [EOL]                 return null; [EOL]             } [EOL]         } [EOL]         return field; [EOL]     } catch (final NoSuchFieldException e) { [EOL]     } [EOL]     return null; [EOL] }
public static Field getDeclaredField(final Class<?> cls, final String fieldName, final boolean forceAccess) { [EOL]     if (cls == null) { [EOL]         throw new IllegalArgumentException("The class must not be null"); [EOL]     } [EOL]     if (fieldName == null) { [EOL]         throw new IllegalArgumentException("The field name must not be null"); [EOL]     } [EOL]     try { [EOL]         final Field field = cls.getDeclaredField(fieldName); [EOL]         if (!MemberUtils.isAccessible(field)) { [EOL]             if (forceAccess) { [EOL]                 field.setAccessible(true); [EOL]             } else { [EOL]                 return null; [EOL]             } [EOL]         } [EOL]         return field; [EOL]     } catch (final NoSuchFieldException e) { [EOL]     } [EOL]     return null; [EOL] }
public static Field getDeclaredField(final Class<?> cls, final String fieldName, final boolean forceAccess) { [EOL]     if (cls == null) { [EOL]         throw new IllegalArgumentException("The class must not be null"); [EOL]     } [EOL]     if (fieldName == null) { [EOL]         throw new IllegalArgumentException("The field name must not be null"); [EOL]     } [EOL]     try { [EOL]         final Field field = cls.getDeclaredField(fieldName); [EOL]         if (!MemberUtils.isAccessible(field)) { [EOL]             if (forceAccess) { [EOL]                 field.setAccessible(true); [EOL]             } else { [EOL]                 return null; [EOL]             } [EOL]         } [EOL]         return field; [EOL]     } catch (final NoSuchFieldException e) { [EOL]     } [EOL]     return null; [EOL] }
public static Field getDeclaredField(final Class<?> cls, final String fieldName, final boolean forceAccess) { [EOL]     if (cls == null) { [EOL]         throw new IllegalArgumentException("The class must not be null"); [EOL]     } [EOL]     if (fieldName == null) { [EOL]         throw new IllegalArgumentException("The field name must not be null"); [EOL]     } [EOL]     try { [EOL]         final Field field = cls.getDeclaredField(fieldName); [EOL]         if (!MemberUtils.isAccessible(field)) { [EOL]             if (forceAccess) { [EOL]                 field.setAccessible(true); [EOL]             } else { [EOL]                 return null; [EOL]             } [EOL]         } [EOL]         return field; [EOL]     } catch (final NoSuchFieldException e) { [EOL]     } [EOL]     return null; [EOL] }
public static Field getDeclaredField(final Class<?> cls, final String fieldName, final boolean forceAccess) { [EOL]     if (cls == null) { [EOL]         throw new IllegalArgumentException("The class must not be null"); [EOL]     } [EOL]     if (fieldName == null) { [EOL]         throw new IllegalArgumentException("The field name must not be null"); [EOL]     } [EOL]     try { [EOL]         final Field field = cls.getDeclaredField(fieldName); [EOL]         if (!MemberUtils.isAccessible(field)) { [EOL]             if (forceAccess) { [EOL]                 field.setAccessible(true); [EOL]             } else { [EOL]                 return null; [EOL]             } [EOL]         } [EOL]         return field; [EOL]     } catch (final NoSuchFieldException e) { [EOL]     } [EOL]     return null; [EOL] }
public static void writeDeclaredStaticField(final Class<?> cls, final String fieldName, final Object value, final boolean forceAccess) throws IllegalAccessException { [EOL]     final Field field = getDeclaredField(cls, fieldName, forceAccess); [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("Cannot locate declared field " + cls.getName() + "." + fieldName); [EOL]     } [EOL]     writeField(field, (Object) null, value); [EOL] }
public static void writeDeclaredStaticField(final Class<?> cls, final String fieldName, final Object value, final boolean forceAccess) throws IllegalAccessException { [EOL]     final Field field = getDeclaredField(cls, fieldName, forceAccess); [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("Cannot locate declared field " + cls.getName() + "." + fieldName); [EOL]     } [EOL]     writeField(field, (Object) null, value); [EOL] }
public static void writeField(final Field field, final Object target, final Object value) throws IllegalAccessException { [EOL]     writeField(field, target, value, false); [EOL] }
public static void writeField(final Field field, final Object target, final Object value) throws IllegalAccessException { [EOL]     writeField(field, target, value, false); [EOL] }
public static void writeField(final Field field, final Object target, final Object value) throws IllegalAccessException { [EOL]     writeField(field, target, value, false); [EOL] }
protected void add(final String str) { [EOL]     if (str == null) { [EOL]         return; [EOL]     } [EOL]     final int len = str.length(); [EOL]     int pos = 0; [EOL]     while (pos < len) { [EOL]         final int remainder = len - pos; [EOL]         if (remainder >= 4 && str.charAt(pos) == '^' && str.charAt(pos + 2) == '-') { [EOL]             set.add(CharRange.isNotIn(str.charAt(pos + 1), str.charAt(pos + 3))); [EOL]             pos += 4; [EOL]         } else if (remainder >= 3 && str.charAt(pos + 1) == '-') { [EOL]             set.add(CharRange.isIn(str.charAt(pos), str.charAt(pos + 2))); [EOL]             pos += 3; [EOL]         } else if (remainder >= 2 && str.charAt(pos) == '^') { [EOL]             set.add(CharRange.isNot(str.charAt(pos + 1))); [EOL]             pos += 2; [EOL]         } else { [EOL]             set.add(CharRange.is(str.charAt(pos))); [EOL]             pos += 1; [EOL]         } [EOL]     } [EOL] }
protected void add(final String str) { [EOL]     if (str == null) { [EOL]         return; [EOL]     } [EOL]     final int len = str.length(); [EOL]     int pos = 0; [EOL]     while (pos < len) { [EOL]         final int remainder = len - pos; [EOL]         if (remainder >= 4 && str.charAt(pos) == '^' && str.charAt(pos + 2) == '-') { [EOL]             set.add(CharRange.isNotIn(str.charAt(pos + 1), str.charAt(pos + 3))); [EOL]             pos += 4; [EOL]         } else if (remainder >= 3 && str.charAt(pos + 1) == '-') { [EOL]             set.add(CharRange.isIn(str.charAt(pos), str.charAt(pos + 2))); [EOL]             pos += 3; [EOL]         } else if (remainder >= 2 && str.charAt(pos) == '^') { [EOL]             set.add(CharRange.isNot(str.charAt(pos + 1))); [EOL]             pos += 2; [EOL]         } else { [EOL]             set.add(CharRange.is(str.charAt(pos))); [EOL]             pos += 1; [EOL]         } [EOL]     } [EOL] }
protected void add(final String str) { [EOL]     if (str == null) { [EOL]         return; [EOL]     } [EOL]     final int len = str.length(); [EOL]     int pos = 0; [EOL]     while (pos < len) { [EOL]         final int remainder = len - pos; [EOL]         if (remainder >= 4 && str.charAt(pos) == '^' && str.charAt(pos + 2) == '-') { [EOL]             set.add(CharRange.isNotIn(str.charAt(pos + 1), str.charAt(pos + 3))); [EOL]             pos += 4; [EOL]         } else if (remainder >= 3 && str.charAt(pos + 1) == '-') { [EOL]             set.add(CharRange.isIn(str.charAt(pos), str.charAt(pos + 2))); [EOL]             pos += 3; [EOL]         } else if (remainder >= 2 && str.charAt(pos) == '^') { [EOL]             set.add(CharRange.isNot(str.charAt(pos + 1))); [EOL]             pos += 2; [EOL]         } else { [EOL]             set.add(CharRange.is(str.charAt(pos))); [EOL]             pos += 1; [EOL]         } [EOL]     } [EOL] }
protected void add(final String str) { [EOL]     if (str == null) { [EOL]         return; [EOL]     } [EOL]     final int len = str.length(); [EOL]     int pos = 0; [EOL]     while (pos < len) { [EOL]         final int remainder = len - pos; [EOL]         if (remainder >= 4 && str.charAt(pos) == '^' && str.charAt(pos + 2) == '-') { [EOL]             set.add(CharRange.isNotIn(str.charAt(pos + 1), str.charAt(pos + 3))); [EOL]             pos += 4; [EOL]         } else if (remainder >= 3 && str.charAt(pos + 1) == '-') { [EOL]             set.add(CharRange.isIn(str.charAt(pos), str.charAt(pos + 2))); [EOL]             pos += 3; [EOL]         } else if (remainder >= 2 && str.charAt(pos) == '^') { [EOL]             set.add(CharRange.isNot(str.charAt(pos + 1))); [EOL]             pos += 2; [EOL]         } else { [EOL]             set.add(CharRange.is(str.charAt(pos))); [EOL]             pos += 1; [EOL]         } [EOL]     } [EOL] }
protected void add(final String str) { [EOL]     if (str == null) { [EOL]         return; [EOL]     } [EOL]     final int len = str.length(); [EOL]     int pos = 0; [EOL]     while (pos < len) { [EOL]         final int remainder = len - pos; [EOL]         if (remainder >= 4 && str.charAt(pos) == '^' && str.charAt(pos + 2) == '-') { [EOL]             set.add(CharRange.isNotIn(str.charAt(pos + 1), str.charAt(pos + 3))); [EOL]             pos += 4; [EOL]         } else if (remainder >= 3 && str.charAt(pos + 1) == '-') { [EOL]             set.add(CharRange.isIn(str.charAt(pos), str.charAt(pos + 2))); [EOL]             pos += 3; [EOL]         } else if (remainder >= 2 && str.charAt(pos) == '^') { [EOL]             set.add(CharRange.isNot(str.charAt(pos + 1))); [EOL]             pos += 2; [EOL]         } else { [EOL]             set.add(CharRange.is(str.charAt(pos))); [EOL]             pos += 1; [EOL]         } [EOL]     } [EOL] }
protected void add(final String str) { [EOL]     if (str == null) { [EOL]         return; [EOL]     } [EOL]     final int len = str.length(); [EOL]     int pos = 0; [EOL]     while (pos < len) { [EOL]         final int remainder = len - pos; [EOL]         if (remainder >= 4 && str.charAt(pos) == '^' && str.charAt(pos + 2) == '-') { [EOL]             set.add(CharRange.isNotIn(str.charAt(pos + 1), str.charAt(pos + 3))); [EOL]             pos += 4; [EOL]         } else if (remainder >= 3 && str.charAt(pos + 1) == '-') { [EOL]             set.add(CharRange.isIn(str.charAt(pos), str.charAt(pos + 2))); [EOL]             pos += 3; [EOL]         } else if (remainder >= 2 && str.charAt(pos) == '^') { [EOL]             set.add(CharRange.isNot(str.charAt(pos + 1))); [EOL]             pos += 2; [EOL]         } else { [EOL]             set.add(CharRange.is(str.charAt(pos))); [EOL]             pos += 1; [EOL]         } [EOL]     } [EOL] }
protected void add(final String str) { [EOL]     if (str == null) { [EOL]         return; [EOL]     } [EOL]     final int len = str.length(); [EOL]     int pos = 0; [EOL]     while (pos < len) { [EOL]         final int remainder = len - pos; [EOL]         if (remainder >= 4 && str.charAt(pos) == '^' && str.charAt(pos + 2) == '-') { [EOL]             set.add(CharRange.isNotIn(str.charAt(pos + 1), str.charAt(pos + 3))); [EOL]             pos += 4; [EOL]         } else if (remainder >= 3 && str.charAt(pos + 1) == '-') { [EOL]             set.add(CharRange.isIn(str.charAt(pos), str.charAt(pos + 2))); [EOL]             pos += 3; [EOL]         } else if (remainder >= 2 && str.charAt(pos) == '^') { [EOL]             set.add(CharRange.isNot(str.charAt(pos + 1))); [EOL]             pos += 2; [EOL]         } else { [EOL]             set.add(CharRange.is(str.charAt(pos))); [EOL]             pos += 1; [EOL]         } [EOL]     } [EOL] }
protected void add(final String str) { [EOL]     if (str == null) { [EOL]         return; [EOL]     } [EOL]     final int len = str.length(); [EOL]     int pos = 0; [EOL]     while (pos < len) { [EOL]         final int remainder = len - pos; [EOL]         if (remainder >= 4 && str.charAt(pos) == '^' && str.charAt(pos + 2) == '-') { [EOL]             set.add(CharRange.isNotIn(str.charAt(pos + 1), str.charAt(pos + 3))); [EOL]             pos += 4; [EOL]         } else if (remainder >= 3 && str.charAt(pos + 1) == '-') { [EOL]             set.add(CharRange.isIn(str.charAt(pos), str.charAt(pos + 2))); [EOL]             pos += 3; [EOL]         } else if (remainder >= 2 && str.charAt(pos) == '^') { [EOL]             set.add(CharRange.isNot(str.charAt(pos + 1))); [EOL]             pos += 2; [EOL]         } else { [EOL]             set.add(CharRange.is(str.charAt(pos))); [EOL]             pos += 1; [EOL]         } [EOL]     } [EOL] }
public ContextedException(final String message, final Throwable cause) { [EOL]     super(message, cause); [EOL]     exceptionContext = new DefaultExceptionContext(); [EOL] }
public ContextedException(final String message, final Throwable cause) { [EOL]     super(message, cause); [EOL]     exceptionContext = new DefaultExceptionContext(); [EOL] }
public ContextedException(final String message, final Throwable cause, ExceptionContext context) { [EOL]     super(message, cause); [EOL]     if (context == null) { [EOL]         context = new DefaultExceptionContext(); [EOL]     } [EOL]     exceptionContext = context; [EOL] }
public ContextedException(final String message, final Throwable cause, ExceptionContext context) { [EOL]     super(message, cause); [EOL]     if (context == null) { [EOL]         context = new DefaultExceptionContext(); [EOL]     } [EOL]     exceptionContext = context; [EOL] }
@Override [EOL] public ContextedException addContextValue(final String label, final Object value) { [EOL]     exceptionContext.addContextValue(label, value); [EOL]     return this; [EOL] }
@Override [EOL] public ContextedException addContextValue(final String label, final Object value) { [EOL]     exceptionContext.addContextValue(label, value); [EOL]     return this; [EOL] }
@Override [EOL] public ContextedException addContextValue(final String label, final Object value) { [EOL]     exceptionContext.addContextValue(label, value); [EOL]     return this; [EOL] }
public MutablePair() { [EOL]     super(); [EOL] }
private CharRange(char start, char end, final boolean negated) { [EOL]     super(); [EOL]     if (start > end) { [EOL]         final char temp = start; [EOL]         start = end; [EOL]         end = temp; [EOL]     } [EOL]     this.start = start; [EOL]     this.end = end; [EOL]     this.negated = negated; [EOL] }
private CharRange(char start, char end, final boolean negated) { [EOL]     super(); [EOL]     if (start > end) { [EOL]         final char temp = start; [EOL]         start = end; [EOL]         end = temp; [EOL]     } [EOL]     this.start = start; [EOL]     this.end = end; [EOL]     this.negated = negated; [EOL] }
public static CharRange is(final char ch) { [EOL]     return new CharRange(ch, ch, false); [EOL] }
public static CharRange isNot(final char ch) { [EOL]     return new CharRange(ch, ch, true); [EOL] }
public static CharRange isNot(final char ch) { [EOL]     return new CharRange(ch, ch, true); [EOL] }
public static CharRange isNot(final char ch) { [EOL]     return new CharRange(ch, ch, true); [EOL] }
public static CharRange isIn(final char start, final char end) { [EOL]     return new CharRange(start, end, false); [EOL] }
public static CharRange isIn(final char start, final char end) { [EOL]     return new CharRange(start, end, false); [EOL] }
public static CharRange isIn(final char start, final char end) { [EOL]     return new CharRange(start, end, false); [EOL] }
public static CharRange isNotIn(final char start, final char end) { [EOL]     return new CharRange(start, end, true); [EOL] }
public static CharRange isNotIn(final char start, final char end) { [EOL]     return new CharRange(start, end, true); [EOL] }
public static CharRange isNotIn(final char start, final char end) { [EOL]     return new CharRange(start, end, true); [EOL] }
public char getStart() { [EOL]     return this.start; [EOL] }
public char getEnd() { [EOL]     return this.end; [EOL] }
public boolean isNegated() { [EOL]     return negated; [EOL] }
public boolean isNegated() { [EOL]     return negated; [EOL] }
public boolean contains(final CharRange range) { [EOL]     if (range == null) { [EOL]         throw new IllegalArgumentException("The Range must not be null"); [EOL]     } [EOL]     if (negated) { [EOL]         if (range.negated) { [EOL]             return start >= range.start && end <= range.end; [EOL]         } [EOL]         return range.end < start || range.start > end; [EOL]     } [EOL]     if (range.negated) { [EOL]         return start == 0 && end == Character.MAX_VALUE; [EOL]     } [EOL]     return start <= range.start && end >= range.end; [EOL] }
public boolean contains(final CharRange range) { [EOL]     if (range == null) { [EOL]         throw new IllegalArgumentException("The Range must not be null"); [EOL]     } [EOL]     if (negated) { [EOL]         if (range.negated) { [EOL]             return start >= range.start && end <= range.end; [EOL]         } [EOL]         return range.end < start || range.start > end; [EOL]     } [EOL]     if (range.negated) { [EOL]         return start == 0 && end == Character.MAX_VALUE; [EOL]     } [EOL]     return start <= range.start && end >= range.end; [EOL] }
public boolean contains(final CharRange range) { [EOL]     if (range == null) { [EOL]         throw new IllegalArgumentException("The Range must not be null"); [EOL]     } [EOL]     if (negated) { [EOL]         if (range.negated) { [EOL]             return start >= range.start && end <= range.end; [EOL]         } [EOL]         return range.end < start || range.start > end; [EOL]     } [EOL]     if (range.negated) { [EOL]         return start == 0 && end == Character.MAX_VALUE; [EOL]     } [EOL]     return start <= range.start && end >= range.end; [EOL] }
public boolean contains(final CharRange range) { [EOL]     if (range == null) { [EOL]         throw new IllegalArgumentException("The Range must not be null"); [EOL]     } [EOL]     if (negated) { [EOL]         if (range.negated) { [EOL]             return start >= range.start && end <= range.end; [EOL]         } [EOL]         return range.end < start || range.start > end; [EOL]     } [EOL]     if (range.negated) { [EOL]         return start == 0 && end == Character.MAX_VALUE; [EOL]     } [EOL]     return start <= range.start && end >= range.end; [EOL] }
public boolean contains(final CharRange range) { [EOL]     if (range == null) { [EOL]         throw new IllegalArgumentException("The Range must not be null"); [EOL]     } [EOL]     if (negated) { [EOL]         if (range.negated) { [EOL]             return start >= range.start && end <= range.end; [EOL]         } [EOL]         return range.end < start || range.start > end; [EOL]     } [EOL]     if (range.negated) { [EOL]         return start == 0 && end == Character.MAX_VALUE; [EOL]     } [EOL]     return start <= range.start && end >= range.end; [EOL] }
public boolean contains(final CharRange range) { [EOL]     if (range == null) { [EOL]         throw new IllegalArgumentException("The Range must not be null"); [EOL]     } [EOL]     if (negated) { [EOL]         if (range.negated) { [EOL]             return start >= range.start && end <= range.end; [EOL]         } [EOL]         return range.end < start || range.start > end; [EOL]     } [EOL]     if (range.negated) { [EOL]         return start == 0 && end == Character.MAX_VALUE; [EOL]     } [EOL]     return start <= range.start && end >= range.end; [EOL] }
public boolean contains(final CharRange range) { [EOL]     if (range == null) { [EOL]         throw new IllegalArgumentException("The Range must not be null"); [EOL]     } [EOL]     if (negated) { [EOL]         if (range.negated) { [EOL]             return start >= range.start && end <= range.end; [EOL]         } [EOL]         return range.end < start || range.start > end; [EOL]     } [EOL]     if (range.negated) { [EOL]         return start == 0 && end == Character.MAX_VALUE; [EOL]     } [EOL]     return start <= range.start && end >= range.end; [EOL] }
@Override [EOL] public String toString() { [EOL]     if (iToString == null) { [EOL]         final StringBuilder buf = new StringBuilder(4); [EOL]         if (isNegated()) { [EOL]             buf.append('^'); [EOL]         } [EOL]         buf.append(start); [EOL]         if (start != end) { [EOL]             buf.append('-'); [EOL]             buf.append(end); [EOL]         } [EOL]         iToString = buf.toString(); [EOL]     } [EOL]     return iToString; [EOL] }
@Override [EOL] public String toString() { [EOL]     if (iToString == null) { [EOL]         final StringBuilder buf = new StringBuilder(4); [EOL]         if (isNegated()) { [EOL]             buf.append('^'); [EOL]         } [EOL]         buf.append(start); [EOL]         if (start != end) { [EOL]             buf.append('-'); [EOL]             buf.append(end); [EOL]         } [EOL]         iToString = buf.toString(); [EOL]     } [EOL]     return iToString; [EOL] }
@Override [EOL] public String toString() { [EOL]     if (iToString == null) { [EOL]         final StringBuilder buf = new StringBuilder(4); [EOL]         if (isNegated()) { [EOL]             buf.append('^'); [EOL]         } [EOL]         buf.append(start); [EOL]         if (start != end) { [EOL]             buf.append('-'); [EOL]             buf.append(end); [EOL]         } [EOL]         iToString = buf.toString(); [EOL]     } [EOL]     return iToString; [EOL] }
@Override [EOL] public Iterator<Character> iterator() { [EOL]     return new CharacterIterator(this); [EOL] }
private CharacterIterator(final CharRange r) { [EOL]     range = r; [EOL]     hasNext = true; [EOL]     if (range.negated) { [EOL]         if (range.start == 0) { [EOL]             if (range.end == Character.MAX_VALUE) { [EOL]                 hasNext = false; [EOL]             } else { [EOL]                 current = (char) (range.end + 1); [EOL]             } [EOL]         } else { [EOL]             current = 0; [EOL]         } [EOL]     } else { [EOL]         current = range.start; [EOL]     } [EOL] }
private CharacterIterator(final CharRange r) { [EOL]     range = r; [EOL]     hasNext = true; [EOL]     if (range.negated) { [EOL]         if (range.start == 0) { [EOL]             if (range.end == Character.MAX_VALUE) { [EOL]                 hasNext = false; [EOL]             } else { [EOL]                 current = (char) (range.end + 1); [EOL]             } [EOL]         } else { [EOL]             current = 0; [EOL]         } [EOL]     } else { [EOL]         current = range.start; [EOL]     } [EOL] }
private CharacterIterator(final CharRange r) { [EOL]     range = r; [EOL]     hasNext = true; [EOL]     if (range.negated) { [EOL]         if (range.start == 0) { [EOL]             if (range.end == Character.MAX_VALUE) { [EOL]                 hasNext = false; [EOL]             } else { [EOL]                 current = (char) (range.end + 1); [EOL]             } [EOL]         } else { [EOL]             current = 0; [EOL]         } [EOL]     } else { [EOL]         current = range.start; [EOL]     } [EOL] }
private CharacterIterator(final CharRange r) { [EOL]     range = r; [EOL]     hasNext = true; [EOL]     if (range.negated) { [EOL]         if (range.start == 0) { [EOL]             if (range.end == Character.MAX_VALUE) { [EOL]                 hasNext = false; [EOL]             } else { [EOL]                 current = (char) (range.end + 1); [EOL]             } [EOL]         } else { [EOL]             current = 0; [EOL]         } [EOL]     } else { [EOL]         current = range.start; [EOL]     } [EOL] }
private void prepareNext() { [EOL]     if (range.negated) { [EOL]         if (current == Character.MAX_VALUE) { [EOL]             hasNext = false; [EOL]         } else if (current + 1 == range.start) { [EOL]             if (range.end == Character.MAX_VALUE) { [EOL]                 hasNext = false; [EOL]             } else { [EOL]                 current = (char) (range.end + 1); [EOL]             } [EOL]         } else { [EOL]             current = (char) (current + 1); [EOL]         } [EOL]     } else if (current < range.end) { [EOL]         current = (char) (current + 1); [EOL]     } else { [EOL]         hasNext = false; [EOL]     } [EOL] }
private void prepareNext() { [EOL]     if (range.negated) { [EOL]         if (current == Character.MAX_VALUE) { [EOL]             hasNext = false; [EOL]         } else if (current + 1 == range.start) { [EOL]             if (range.end == Character.MAX_VALUE) { [EOL]                 hasNext = false; [EOL]             } else { [EOL]                 current = (char) (range.end + 1); [EOL]             } [EOL]         } else { [EOL]             current = (char) (current + 1); [EOL]         } [EOL]     } else if (current < range.end) { [EOL]         current = (char) (current + 1); [EOL]     } else { [EOL]         hasNext = false; [EOL]     } [EOL] }
private void prepareNext() { [EOL]     if (range.negated) { [EOL]         if (current == Character.MAX_VALUE) { [EOL]             hasNext = false; [EOL]         } else if (current + 1 == range.start) { [EOL]             if (range.end == Character.MAX_VALUE) { [EOL]                 hasNext = false; [EOL]             } else { [EOL]                 current = (char) (range.end + 1); [EOL]             } [EOL]         } else { [EOL]             current = (char) (current + 1); [EOL]         } [EOL]     } else if (current < range.end) { [EOL]         current = (char) (current + 1); [EOL]     } else { [EOL]         hasNext = false; [EOL]     } [EOL] }
private void prepareNext() { [EOL]     if (range.negated) { [EOL]         if (current == Character.MAX_VALUE) { [EOL]             hasNext = false; [EOL]         } else if (current + 1 == range.start) { [EOL]             if (range.end == Character.MAX_VALUE) { [EOL]                 hasNext = false; [EOL]             } else { [EOL]                 current = (char) (range.end + 1); [EOL]             } [EOL]         } else { [EOL]             current = (char) (current + 1); [EOL]         } [EOL]     } else if (current < range.end) { [EOL]         current = (char) (current + 1); [EOL]     } else { [EOL]         hasNext = false; [EOL]     } [EOL] }
private void prepareNext() { [EOL]     if (range.negated) { [EOL]         if (current == Character.MAX_VALUE) { [EOL]             hasNext = false; [EOL]         } else if (current + 1 == range.start) { [EOL]             if (range.end == Character.MAX_VALUE) { [EOL]                 hasNext = false; [EOL]             } else { [EOL]                 current = (char) (range.end + 1); [EOL]             } [EOL]         } else { [EOL]             current = (char) (current + 1); [EOL]         } [EOL]     } else if (current < range.end) { [EOL]         current = (char) (current + 1); [EOL]     } else { [EOL]         hasNext = false; [EOL]     } [EOL] }
private void prepareNext() { [EOL]     if (range.negated) { [EOL]         if (current == Character.MAX_VALUE) { [EOL]             hasNext = false; [EOL]         } else if (current + 1 == range.start) { [EOL]             if (range.end == Character.MAX_VALUE) { [EOL]                 hasNext = false; [EOL]             } else { [EOL]                 current = (char) (range.end + 1); [EOL]             } [EOL]         } else { [EOL]             current = (char) (current + 1); [EOL]         } [EOL]     } else if (current < range.end) { [EOL]         current = (char) (current + 1); [EOL]     } else { [EOL]         hasNext = false; [EOL]     } [EOL] }
@Override [EOL] public boolean hasNext() { [EOL]     return hasNext; [EOL] }
@Override [EOL] public Character next() { [EOL]     if (hasNext == false) { [EOL]         throw new NoSuchElementException(); [EOL]     } [EOL]     final char cur = current; [EOL]     prepareNext(); [EOL]     return Character.valueOf(cur); [EOL] }
public CallableBackgroundInitializer(final Callable<T> call) { [EOL]     checkCallable(call); [EOL]     callable = call; [EOL] }
public CallableBackgroundInitializer(final Callable<T> call) { [EOL]     checkCallable(call); [EOL]     callable = call; [EOL] }
@Override [EOL] protected T initialize() throws Exception { [EOL]     return callable.call(); [EOL] }
public static int reflectionHashCode(final int initialNonZeroOddNumber, final int multiplierNonZeroOddNumber, final Object object, final boolean testTransients) { [EOL]     return reflectionHashCode(initialNonZeroOddNumber, multiplierNonZeroOddNumber, object, testTransients, null); [EOL] }
public static int reflectionHashCode(final int initialNonZeroOddNumber, final int multiplierNonZeroOddNumber, final Object object, final boolean testTransients) { [EOL]     return reflectionHashCode(initialNonZeroOddNumber, multiplierNonZeroOddNumber, object, testTransients, null); [EOL] }
public static int reflectionHashCode(final int initialNonZeroOddNumber, final int multiplierNonZeroOddNumber, final Object object, final boolean testTransients) { [EOL]     return reflectionHashCode(initialNonZeroOddNumber, multiplierNonZeroOddNumber, object, testTransients, null); [EOL] }
public static <T> int reflectionHashCode(final int initialNonZeroOddNumber, final int multiplierNonZeroOddNumber, final T object, final boolean testTransients, final Class<? super T> reflectUpToClass, final String... excludeFields) { [EOL]     if (object == null) { [EOL]         throw new IllegalArgumentException("The object to build a hash code for must not be null"); [EOL]     } [EOL]     final HashCodeBuilder builder = new HashCodeBuilder(initialNonZeroOddNumber, multiplierNonZeroOddNumber); [EOL]     Class<?> clazz = object.getClass(); [EOL]     reflectionAppend(object, clazz, builder, testTransients, excludeFields); [EOL]     while (clazz.getSuperclass() != null && clazz != reflectUpToClass) { [EOL]         clazz = clazz.getSuperclass(); [EOL]         reflectionAppend(object, clazz, builder, testTransients, excludeFields); [EOL]     } [EOL]     return builder.toHashCode(); [EOL] }
public static <T> int reflectionHashCode(final int initialNonZeroOddNumber, final int multiplierNonZeroOddNumber, final T object, final boolean testTransients, final Class<? super T> reflectUpToClass, final String... excludeFields) { [EOL]     if (object == null) { [EOL]         throw new IllegalArgumentException("The object to build a hash code for must not be null"); [EOL]     } [EOL]     final HashCodeBuilder builder = new HashCodeBuilder(initialNonZeroOddNumber, multiplierNonZeroOddNumber); [EOL]     Class<?> clazz = object.getClass(); [EOL]     reflectionAppend(object, clazz, builder, testTransients, excludeFields); [EOL]     while (clazz.getSuperclass() != null && clazz != reflectUpToClass) { [EOL]         clazz = clazz.getSuperclass(); [EOL]         reflectionAppend(object, clazz, builder, testTransients, excludeFields); [EOL]     } [EOL]     return builder.toHashCode(); [EOL] }
public static <T> int reflectionHashCode(final int initialNonZeroOddNumber, final int multiplierNonZeroOddNumber, final T object, final boolean testTransients, final Class<? super T> reflectUpToClass, final String... excludeFields) { [EOL]     if (object == null) { [EOL]         throw new IllegalArgumentException("The object to build a hash code for must not be null"); [EOL]     } [EOL]     final HashCodeBuilder builder = new HashCodeBuilder(initialNonZeroOddNumber, multiplierNonZeroOddNumber); [EOL]     Class<?> clazz = object.getClass(); [EOL]     reflectionAppend(object, clazz, builder, testTransients, excludeFields); [EOL]     while (clazz.getSuperclass() != null && clazz != reflectUpToClass) { [EOL]         clazz = clazz.getSuperclass(); [EOL]         reflectionAppend(object, clazz, builder, testTransients, excludeFields); [EOL]     } [EOL]     return builder.toHashCode(); [EOL] }
public static <T> int reflectionHashCode(final int initialNonZeroOddNumber, final int multiplierNonZeroOddNumber, final T object, final boolean testTransients, final Class<? super T> reflectUpToClass, final String... excludeFields) { [EOL]     if (object == null) { [EOL]         throw new IllegalArgumentException("The object to build a hash code for must not be null"); [EOL]     } [EOL]     final HashCodeBuilder builder = new HashCodeBuilder(initialNonZeroOddNumber, multiplierNonZeroOddNumber); [EOL]     Class<?> clazz = object.getClass(); [EOL]     reflectionAppend(object, clazz, builder, testTransients, excludeFields); [EOL]     while (clazz.getSuperclass() != null && clazz != reflectUpToClass) { [EOL]         clazz = clazz.getSuperclass(); [EOL]         reflectionAppend(object, clazz, builder, testTransients, excludeFields); [EOL]     } [EOL]     return builder.toHashCode(); [EOL] }
public static <T> int reflectionHashCode(final int initialNonZeroOddNumber, final int multiplierNonZeroOddNumber, final T object, final boolean testTransients, final Class<? super T> reflectUpToClass, final String... excludeFields) { [EOL]     if (object == null) { [EOL]         throw new IllegalArgumentException("The object to build a hash code for must not be null"); [EOL]     } [EOL]     final HashCodeBuilder builder = new HashCodeBuilder(initialNonZeroOddNumber, multiplierNonZeroOddNumber); [EOL]     Class<?> clazz = object.getClass(); [EOL]     reflectionAppend(object, clazz, builder, testTransients, excludeFields); [EOL]     while (clazz.getSuperclass() != null && clazz != reflectUpToClass) { [EOL]         clazz = clazz.getSuperclass(); [EOL]         reflectionAppend(object, clazz, builder, testTransients, excludeFields); [EOL]     } [EOL]     return builder.toHashCode(); [EOL] }
public HashCodeBuilder append(final Object object) { [EOL]     if (object == null) { [EOL]         iTotal = iTotal * iConstant; [EOL]     } else { [EOL]         if (object.getClass().isArray()) { [EOL]             if (object instanceof long[]) { [EOL]                 append((long[]) object); [EOL]             } else if (object instanceof int[]) { [EOL]                 append((int[]) object); [EOL]             } else if (object instanceof short[]) { [EOL]                 append((short[]) object); [EOL]             } else if (object instanceof char[]) { [EOL]                 append((char[]) object); [EOL]             } else if (object instanceof byte[]) { [EOL]                 append((byte[]) object); [EOL]             } else if (object instanceof double[]) { [EOL]                 append((double[]) object); [EOL]             } else if (object instanceof float[]) { [EOL]                 append((float[]) object); [EOL]             } else if (object instanceof boolean[]) { [EOL]                 append((boolean[]) object); [EOL]             } else { [EOL]                 append((Object[]) object); [EOL]             } [EOL]         } else { [EOL]             iTotal = iTotal * iConstant + object.hashCode(); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public HashCodeBuilder append(final Object object) { [EOL]     if (object == null) { [EOL]         iTotal = iTotal * iConstant; [EOL]     } else { [EOL]         if (object.getClass().isArray()) { [EOL]             if (object instanceof long[]) { [EOL]                 append((long[]) object); [EOL]             } else if (object instanceof int[]) { [EOL]                 append((int[]) object); [EOL]             } else if (object instanceof short[]) { [EOL]                 append((short[]) object); [EOL]             } else if (object instanceof char[]) { [EOL]                 append((char[]) object); [EOL]             } else if (object instanceof byte[]) { [EOL]                 append((byte[]) object); [EOL]             } else if (object instanceof double[]) { [EOL]                 append((double[]) object); [EOL]             } else if (object instanceof float[]) { [EOL]                 append((float[]) object); [EOL]             } else if (object instanceof boolean[]) { [EOL]                 append((boolean[]) object); [EOL]             } else { [EOL]                 append((Object[]) object); [EOL]             } [EOL]         } else { [EOL]             iTotal = iTotal * iConstant + object.hashCode(); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public HashCodeBuilder append(final Object object) { [EOL]     if (object == null) { [EOL]         iTotal = iTotal * iConstant; [EOL]     } else { [EOL]         if (object.getClass().isArray()) { [EOL]             if (object instanceof long[]) { [EOL]                 append((long[]) object); [EOL]             } else if (object instanceof int[]) { [EOL]                 append((int[]) object); [EOL]             } else if (object instanceof short[]) { [EOL]                 append((short[]) object); [EOL]             } else if (object instanceof char[]) { [EOL]                 append((char[]) object); [EOL]             } else if (object instanceof byte[]) { [EOL]                 append((byte[]) object); [EOL]             } else if (object instanceof double[]) { [EOL]                 append((double[]) object); [EOL]             } else if (object instanceof float[]) { [EOL]                 append((float[]) object); [EOL]             } else if (object instanceof boolean[]) { [EOL]                 append((boolean[]) object); [EOL]             } else { [EOL]                 append((Object[]) object); [EOL]             } [EOL]         } else { [EOL]             iTotal = iTotal * iConstant + object.hashCode(); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public HashCodeBuilder append(final Object object) { [EOL]     if (object == null) { [EOL]         iTotal = iTotal * iConstant; [EOL]     } else { [EOL]         if (object.getClass().isArray()) { [EOL]             if (object instanceof long[]) { [EOL]                 append((long[]) object); [EOL]             } else if (object instanceof int[]) { [EOL]                 append((int[]) object); [EOL]             } else if (object instanceof short[]) { [EOL]                 append((short[]) object); [EOL]             } else if (object instanceof char[]) { [EOL]                 append((char[]) object); [EOL]             } else if (object instanceof byte[]) { [EOL]                 append((byte[]) object); [EOL]             } else if (object instanceof double[]) { [EOL]                 append((double[]) object); [EOL]             } else if (object instanceof float[]) { [EOL]                 append((float[]) object); [EOL]             } else if (object instanceof boolean[]) { [EOL]                 append((boolean[]) object); [EOL]             } else { [EOL]                 append((Object[]) object); [EOL]             } [EOL]         } else { [EOL]             iTotal = iTotal * iConstant + object.hashCode(); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public HashCodeBuilder append(final Object object) { [EOL]     if (object == null) { [EOL]         iTotal = iTotal * iConstant; [EOL]     } else { [EOL]         if (object.getClass().isArray()) { [EOL]             if (object instanceof long[]) { [EOL]                 append((long[]) object); [EOL]             } else if (object instanceof int[]) { [EOL]                 append((int[]) object); [EOL]             } else if (object instanceof short[]) { [EOL]                 append((short[]) object); [EOL]             } else if (object instanceof char[]) { [EOL]                 append((char[]) object); [EOL]             } else if (object instanceof byte[]) { [EOL]                 append((byte[]) object); [EOL]             } else if (object instanceof double[]) { [EOL]                 append((double[]) object); [EOL]             } else if (object instanceof float[]) { [EOL]                 append((float[]) object); [EOL]             } else if (object instanceof boolean[]) { [EOL]                 append((boolean[]) object); [EOL]             } else { [EOL]                 append((Object[]) object); [EOL]             } [EOL]         } else { [EOL]             iTotal = iTotal * iConstant + object.hashCode(); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public HashCodeBuilder append(final Object object) { [EOL]     if (object == null) { [EOL]         iTotal = iTotal * iConstant; [EOL]     } else { [EOL]         if (object.getClass().isArray()) { [EOL]             if (object instanceof long[]) { [EOL]                 append((long[]) object); [EOL]             } else if (object instanceof int[]) { [EOL]                 append((int[]) object); [EOL]             } else if (object instanceof short[]) { [EOL]                 append((short[]) object); [EOL]             } else if (object instanceof char[]) { [EOL]                 append((char[]) object); [EOL]             } else if (object instanceof byte[]) { [EOL]                 append((byte[]) object); [EOL]             } else if (object instanceof double[]) { [EOL]                 append((double[]) object); [EOL]             } else if (object instanceof float[]) { [EOL]                 append((float[]) object); [EOL]             } else if (object instanceof boolean[]) { [EOL]                 append((boolean[]) object); [EOL]             } else { [EOL]                 append((Object[]) object); [EOL]             } [EOL]         } else { [EOL]             iTotal = iTotal * iConstant + object.hashCode(); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public HashCodeBuilder append(final Object object) { [EOL]     if (object == null) { [EOL]         iTotal = iTotal * iConstant; [EOL]     } else { [EOL]         if (object.getClass().isArray()) { [EOL]             if (object instanceof long[]) { [EOL]                 append((long[]) object); [EOL]             } else if (object instanceof int[]) { [EOL]                 append((int[]) object); [EOL]             } else if (object instanceof short[]) { [EOL]                 append((short[]) object); [EOL]             } else if (object instanceof char[]) { [EOL]                 append((char[]) object); [EOL]             } else if (object instanceof byte[]) { [EOL]                 append((byte[]) object); [EOL]             } else if (object instanceof double[]) { [EOL]                 append((double[]) object); [EOL]             } else if (object instanceof float[]) { [EOL]                 append((float[]) object); [EOL]             } else if (object instanceof boolean[]) { [EOL]                 append((boolean[]) object); [EOL]             } else { [EOL]                 append((Object[]) object); [EOL]             } [EOL]         } else { [EOL]             iTotal = iTotal * iConstant + object.hashCode(); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public HashCodeBuilder append(final Object object) { [EOL]     if (object == null) { [EOL]         iTotal = iTotal * iConstant; [EOL]     } else { [EOL]         if (object.getClass().isArray()) { [EOL]             if (object instanceof long[]) { [EOL]                 append((long[]) object); [EOL]             } else if (object instanceof int[]) { [EOL]                 append((int[]) object); [EOL]             } else if (object instanceof short[]) { [EOL]                 append((short[]) object); [EOL]             } else if (object instanceof char[]) { [EOL]                 append((char[]) object); [EOL]             } else if (object instanceof byte[]) { [EOL]                 append((byte[]) object); [EOL]             } else if (object instanceof double[]) { [EOL]                 append((double[]) object); [EOL]             } else if (object instanceof float[]) { [EOL]                 append((float[]) object); [EOL]             } else if (object instanceof boolean[]) { [EOL]                 append((boolean[]) object); [EOL]             } else { [EOL]                 append((Object[]) object); [EOL]             } [EOL]         } else { [EOL]             iTotal = iTotal * iConstant + object.hashCode(); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public HashCodeBuilder append(final Object object) { [EOL]     if (object == null) { [EOL]         iTotal = iTotal * iConstant; [EOL]     } else { [EOL]         if (object.getClass().isArray()) { [EOL]             if (object instanceof long[]) { [EOL]                 append((long[]) object); [EOL]             } else if (object instanceof int[]) { [EOL]                 append((int[]) object); [EOL]             } else if (object instanceof short[]) { [EOL]                 append((short[]) object); [EOL]             } else if (object instanceof char[]) { [EOL]                 append((char[]) object); [EOL]             } else if (object instanceof byte[]) { [EOL]                 append((byte[]) object); [EOL]             } else if (object instanceof double[]) { [EOL]                 append((double[]) object); [EOL]             } else if (object instanceof float[]) { [EOL]                 append((float[]) object); [EOL]             } else if (object instanceof boolean[]) { [EOL]                 append((boolean[]) object); [EOL]             } else { [EOL]                 append((Object[]) object); [EOL]             } [EOL]         } else { [EOL]             iTotal = iTotal * iConstant + object.hashCode(); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public HashCodeBuilder append(final Object object) { [EOL]     if (object == null) { [EOL]         iTotal = iTotal * iConstant; [EOL]     } else { [EOL]         if (object.getClass().isArray()) { [EOL]             if (object instanceof long[]) { [EOL]                 append((long[]) object); [EOL]             } else if (object instanceof int[]) { [EOL]                 append((int[]) object); [EOL]             } else if (object instanceof short[]) { [EOL]                 append((short[]) object); [EOL]             } else if (object instanceof char[]) { [EOL]                 append((char[]) object); [EOL]             } else if (object instanceof byte[]) { [EOL]                 append((byte[]) object); [EOL]             } else if (object instanceof double[]) { [EOL]                 append((double[]) object); [EOL]             } else if (object instanceof float[]) { [EOL]                 append((float[]) object); [EOL]             } else if (object instanceof boolean[]) { [EOL]                 append((boolean[]) object); [EOL]             } else { [EOL]                 append((Object[]) object); [EOL]             } [EOL]         } else { [EOL]             iTotal = iTotal * iConstant + object.hashCode(); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public HashCodeBuilder append(final Object object) { [EOL]     if (object == null) { [EOL]         iTotal = iTotal * iConstant; [EOL]     } else { [EOL]         if (object.getClass().isArray()) { [EOL]             if (object instanceof long[]) { [EOL]                 append((long[]) object); [EOL]             } else if (object instanceof int[]) { [EOL]                 append((int[]) object); [EOL]             } else if (object instanceof short[]) { [EOL]                 append((short[]) object); [EOL]             } else if (object instanceof char[]) { [EOL]                 append((char[]) object); [EOL]             } else if (object instanceof byte[]) { [EOL]                 append((byte[]) object); [EOL]             } else if (object instanceof double[]) { [EOL]                 append((double[]) object); [EOL]             } else if (object instanceof float[]) { [EOL]                 append((float[]) object); [EOL]             } else if (object instanceof boolean[]) { [EOL]                 append((boolean[]) object); [EOL]             } else { [EOL]                 append((Object[]) object); [EOL]             } [EOL]         } else { [EOL]             iTotal = iTotal * iConstant + object.hashCode(); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public HashCodeBuilder append(final Object[] array) { [EOL]     if (array == null) { [EOL]         iTotal = iTotal * iConstant; [EOL]     } else { [EOL]         for (final Object element : array) { [EOL]             append(element); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public HashCodeBuilder append(final Object[] array) { [EOL]     if (array == null) { [EOL]         iTotal = iTotal * iConstant; [EOL]     } else { [EOL]         for (final Object element : array) { [EOL]             append(element); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public HashCodeBuilder append(final Object[] array) { [EOL]     if (array == null) { [EOL]         iTotal = iTotal * iConstant; [EOL]     } else { [EOL]         for (final Object element : array) { [EOL]             append(element); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public HashCodeBuilder appendSuper(final int superHashCode) { [EOL]     iTotal = iTotal * iConstant + superHashCode; [EOL]     return this; [EOL] }
public HashCodeBuilder appendSuper(final int superHashCode) { [EOL]     iTotal = iTotal * iConstant + superHashCode; [EOL]     return this; [EOL] }
public HashCodeBuilder appendSuper(final int superHashCode) { [EOL]     iTotal = iTotal * iConstant + superHashCode; [EOL]     return this; [EOL] }
public SerializationUtils() { [EOL]     super(); [EOL] }
public static <T extends Serializable> T clone(final T object) { [EOL]     if (object == null) { [EOL]         return null; [EOL]     } [EOL]     final byte[] objectData = serialize(object); [EOL]     final ByteArrayInputStream bais = new ByteArrayInputStream(objectData); [EOL]     ClassLoaderAwareObjectInputStream in = null; [EOL]     try { [EOL]         in = new ClassLoaderAwareObjectInputStream(bais, object.getClass().getClassLoader()); [EOL]         @SuppressWarnings("unchecked") [EOL]         final T readObject = (T) in.readObject(); [EOL]         return readObject; [EOL]     } catch (final ClassNotFoundException ex) { [EOL]         throw new SerializationException("ClassNotFoundException while reading cloned object data", ex); [EOL]     } catch (final IOException ex) { [EOL]         throw new SerializationException("IOException while reading cloned object data", ex); [EOL]     } finally { [EOL]         try { [EOL]             if (in != null) { [EOL]                 in.close(); [EOL]             } [EOL]         } catch (final IOException ex) { [EOL]             throw new SerializationException("IOException on closing cloned object data InputStream.", ex); [EOL]         } [EOL]     } [EOL] }
public static <T extends Serializable> T clone(final T object) { [EOL]     if (object == null) { [EOL]         return null; [EOL]     } [EOL]     final byte[] objectData = serialize(object); [EOL]     final ByteArrayInputStream bais = new ByteArrayInputStream(objectData); [EOL]     ClassLoaderAwareObjectInputStream in = null; [EOL]     try { [EOL]         in = new ClassLoaderAwareObjectInputStream(bais, object.getClass().getClassLoader()); [EOL]         @SuppressWarnings("unchecked") [EOL]         final T readObject = (T) in.readObject(); [EOL]         return readObject; [EOL]     } catch (final ClassNotFoundException ex) { [EOL]         throw new SerializationException("ClassNotFoundException while reading cloned object data", ex); [EOL]     } catch (final IOException ex) { [EOL]         throw new SerializationException("IOException while reading cloned object data", ex); [EOL]     } finally { [EOL]         try { [EOL]             if (in != null) { [EOL]                 in.close(); [EOL]             } [EOL]         } catch (final IOException ex) { [EOL]             throw new SerializationException("IOException on closing cloned object data InputStream.", ex); [EOL]         } [EOL]     } [EOL] }
public static <T extends Serializable> T clone(final T object) { [EOL]     if (object == null) { [EOL]         return null; [EOL]     } [EOL]     final byte[] objectData = serialize(object); [EOL]     final ByteArrayInputStream bais = new ByteArrayInputStream(objectData); [EOL]     ClassLoaderAwareObjectInputStream in = null; [EOL]     try { [EOL]         in = new ClassLoaderAwareObjectInputStream(bais, object.getClass().getClassLoader()); [EOL]         @SuppressWarnings("unchecked") [EOL]         final T readObject = (T) in.readObject(); [EOL]         return readObject; [EOL]     } catch (final ClassNotFoundException ex) { [EOL]         throw new SerializationException("ClassNotFoundException while reading cloned object data", ex); [EOL]     } catch (final IOException ex) { [EOL]         throw new SerializationException("IOException while reading cloned object data", ex); [EOL]     } finally { [EOL]         try { [EOL]             if (in != null) { [EOL]                 in.close(); [EOL]             } [EOL]         } catch (final IOException ex) { [EOL]             throw new SerializationException("IOException on closing cloned object data InputStream.", ex); [EOL]         } [EOL]     } [EOL] }
public static <T extends Serializable> T clone(final T object) { [EOL]     if (object == null) { [EOL]         return null; [EOL]     } [EOL]     final byte[] objectData = serialize(object); [EOL]     final ByteArrayInputStream bais = new ByteArrayInputStream(objectData); [EOL]     ClassLoaderAwareObjectInputStream in = null; [EOL]     try { [EOL]         in = new ClassLoaderAwareObjectInputStream(bais, object.getClass().getClassLoader()); [EOL]         @SuppressWarnings("unchecked") [EOL]         final T readObject = (T) in.readObject(); [EOL]         return readObject; [EOL]     } catch (final ClassNotFoundException ex) { [EOL]         throw new SerializationException("ClassNotFoundException while reading cloned object data", ex); [EOL]     } catch (final IOException ex) { [EOL]         throw new SerializationException("IOException while reading cloned object data", ex); [EOL]     } finally { [EOL]         try { [EOL]             if (in != null) { [EOL]                 in.close(); [EOL]             } [EOL]         } catch (final IOException ex) { [EOL]             throw new SerializationException("IOException on closing cloned object data InputStream.", ex); [EOL]         } [EOL]     } [EOL] }
public static byte[] serialize(final Serializable obj) { [EOL]     final ByteArrayOutputStream baos = new ByteArrayOutputStream(512); [EOL]     serialize(obj, baos); [EOL]     return baos.toByteArray(); [EOL] }
public static byte[] serialize(final Serializable obj) { [EOL]     final ByteArrayOutputStream baos = new ByteArrayOutputStream(512); [EOL]     serialize(obj, baos); [EOL]     return baos.toByteArray(); [EOL] }
public static <T> T deserialize(final byte[] objectData) { [EOL]     if (objectData == null) { [EOL]         throw new IllegalArgumentException("The byte[] must not be null"); [EOL]     } [EOL]     return SerializationUtils.<T>deserialize(new ByteArrayInputStream(objectData)); [EOL] }
public static <T> T deserialize(final byte[] objectData) { [EOL]     if (objectData == null) { [EOL]         throw new IllegalArgumentException("The byte[] must not be null"); [EOL]     } [EOL]     return SerializationUtils.<T>deserialize(new ByteArrayInputStream(objectData)); [EOL] }
public ClassLoaderAwareObjectInputStream(final InputStream in, final ClassLoader classLoader) throws IOException { [EOL]     super(in); [EOL]     this.classLoader = classLoader; [EOL]     primitiveTypes.put("byte", byte.class); [EOL]     primitiveTypes.put("short", short.class); [EOL]     primitiveTypes.put("int", int.class); [EOL]     primitiveTypes.put("long", long.class); [EOL]     primitiveTypes.put("float", float.class); [EOL]     primitiveTypes.put("double", double.class); [EOL]     primitiveTypes.put("boolean", boolean.class); [EOL]     primitiveTypes.put("char", char.class); [EOL]     primitiveTypes.put("void", void.class); [EOL] }
public ClassLoaderAwareObjectInputStream(final InputStream in, final ClassLoader classLoader) throws IOException { [EOL]     super(in); [EOL]     this.classLoader = classLoader; [EOL]     primitiveTypes.put("byte", byte.class); [EOL]     primitiveTypes.put("short", short.class); [EOL]     primitiveTypes.put("int", int.class); [EOL]     primitiveTypes.put("long", long.class); [EOL]     primitiveTypes.put("float", float.class); [EOL]     primitiveTypes.put("double", double.class); [EOL]     primitiveTypes.put("boolean", boolean.class); [EOL]     primitiveTypes.put("char", char.class); [EOL]     primitiveTypes.put("void", void.class); [EOL] }
@Override [EOL] protected Class<?> resolveClass(final ObjectStreamClass desc) throws IOException, ClassNotFoundException { [EOL]     final String name = desc.getName(); [EOL]     try { [EOL]         return Class.forName(name, false, classLoader); [EOL]     } catch (final ClassNotFoundException ex) { [EOL]         try { [EOL]             return Class.forName(name, false, Thread.currentThread().getContextClassLoader()); [EOL]         } catch (final ClassNotFoundException cnfe) { [EOL]             final Class<?> cls = primitiveTypes.get(name); [EOL]             if (cls != null) { [EOL]                 return cls; [EOL]             } else { [EOL]                 throw cnfe; [EOL]             } [EOL]         } [EOL]     } [EOL] }
public CharUtils() { [EOL]     super(); [EOL] }
@Deprecated [EOL] public static Character toCharacterObject(final char ch) { [EOL]     return Character.valueOf(ch); [EOL] }
@Deprecated [EOL] public static Character toCharacterObject(final char ch) { [EOL]     return Character.valueOf(ch); [EOL] }
@Deprecated [EOL] public static Character toCharacterObject(final char ch) { [EOL]     return Character.valueOf(ch); [EOL] }
public static Character toCharacterObject(final String str) { [EOL]     if (StringUtils.isEmpty(str)) { [EOL]         return null; [EOL]     } [EOL]     return Character.valueOf(str.charAt(0)); [EOL] }
public static char toChar(final Character ch) { [EOL]     if (ch == null) { [EOL]         throw new IllegalArgumentException("The Character must not be null"); [EOL]     } [EOL]     return ch.charValue(); [EOL] }
public static char toChar(final Character ch) { [EOL]     if (ch == null) { [EOL]         throw new IllegalArgumentException("The Character must not be null"); [EOL]     } [EOL]     return ch.charValue(); [EOL] }
public static char toChar(final String str) { [EOL]     if (StringUtils.isEmpty(str)) { [EOL]         throw new IllegalArgumentException("The String must not be empty"); [EOL]     } [EOL]     return str.charAt(0); [EOL] }
public boolean contains(final T element) { [EOL]     if (element == null) { [EOL]         return false; [EOL]     } [EOL]     return comparator.compare(element, minimum) > -1 && comparator.compare(element, maximum) < 1; [EOL] }
public boolean isBefore(final T element) { [EOL]     if (element == null) { [EOL]         return false; [EOL]     } [EOL]     return comparator.compare(element, maximum) > 0; [EOL] }
public boolean isBefore(final T element) { [EOL]     if (element == null) { [EOL]         return false; [EOL]     } [EOL]     return comparator.compare(element, maximum) > 0; [EOL] }
public boolean isBefore(final T element) { [EOL]     if (element == null) { [EOL]         return false; [EOL]     } [EOL]     return comparator.compare(element, maximum) > 0; [EOL] }
public boolean containsRange(final Range<T> otherRange) { [EOL]     if (otherRange == null) { [EOL]         return false; [EOL]     } [EOL]     return contains(otherRange.minimum) && contains(otherRange.maximum); [EOL] }
public String toString(final String format) { [EOL]     return String.format(format, minimum, maximum, comparator); [EOL] }
public String toString(final String format) { [EOL]     return String.format(format, minimum, maximum, comparator); [EOL] }
public ReflectionToStringBuilder setExcludeFieldNames(final String... excludeFieldNamesParam) { [EOL]     if (excludeFieldNamesParam == null) { [EOL]         this.excludeFieldNames = null; [EOL]     } else { [EOL]         this.excludeFieldNames = toNoNullStringArray(excludeFieldNamesParam); [EOL]         Arrays.sort(this.excludeFieldNames); [EOL]     } [EOL]     return this; [EOL] }
public ReflectionToStringBuilder setExcludeFieldNames(final String... excludeFieldNamesParam) { [EOL]     if (excludeFieldNamesParam == null) { [EOL]         this.excludeFieldNames = null; [EOL]     } else { [EOL]         this.excludeFieldNames = toNoNullStringArray(excludeFieldNamesParam); [EOL]         Arrays.sort(this.excludeFieldNames); [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public Long getValue() { [EOL]     return Long.valueOf(this.value); [EOL] }
@Override [EOL] public Long getValue() { [EOL]     return Long.valueOf(this.value); [EOL] }
@Override [EOL] public Long getValue() { [EOL]     return Long.valueOf(this.value); [EOL] }
public void setValue(final long value) { [EOL]     this.value = value; [EOL] }
@Override [EOL] public void setValue(final Number value) { [EOL]     this.value = value.longValue(); [EOL] }
@Override [EOL] public void setValue(final Number value) { [EOL]     this.value = value.longValue(); [EOL] }
@Override [EOL] public void setValue(final Number value) { [EOL]     this.value = value.longValue(); [EOL] }
@Override [EOL] public int hashCode() { [EOL]     return (int) (value ^ (value >>> 32)); [EOL] }
public void subtract(final int operand) { [EOL]     this.value -= operand; [EOL] }
public void subtract(final int operand) { [EOL]     this.value -= operand; [EOL] }
public void subtract(final int operand) { [EOL]     this.value -= operand; [EOL] }
public void subtract(final Number operand) { [EOL]     this.value -= operand.intValue(); [EOL] }
public void subtract(final Number operand) { [EOL]     this.value -= operand.intValue(); [EOL] }
public void subtract(final Number operand) { [EOL]     this.value -= operand.intValue(); [EOL] }
public static <T> T defaultIfNull(final T object, final T defaultValue) { [EOL]     return object != null ? object : defaultValue; [EOL] }
public static <T> T defaultIfNull(final T object, final T defaultValue) { [EOL]     return object != null ? object : defaultValue; [EOL] }
public static <T> T firstNonNull(final T... values) { [EOL]     if (values != null) { [EOL]         for (final T val : values) { [EOL]             if (val != null) { [EOL]                 return val; [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public static <T> T firstNonNull(final T... values) { [EOL]     if (values != null) { [EOL]         for (final T val : values) { [EOL]             if (val != null) { [EOL]                 return val; [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public static <T> T firstNonNull(final T... values) { [EOL]     if (values != null) { [EOL]         for (final T val : values) { [EOL]             if (val != null) { [EOL]                 return val; [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public static <T> T firstNonNull(final T... values) { [EOL]     if (values != null) { [EOL]         for (final T val : values) { [EOL]             if (val != null) { [EOL]                 return val; [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public static <T> T firstNonNull(final T... values) { [EOL]     if (values != null) { [EOL]         for (final T val : values) { [EOL]             if (val != null) { [EOL]                 return val; [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public static <T> T firstNonNull(final T... values) { [EOL]     if (values != null) { [EOL]         for (final T val : values) { [EOL]             if (val != null) { [EOL]                 return val; [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public static <T> T firstNonNull(final T... values) { [EOL]     if (values != null) { [EOL]         for (final T val : values) { [EOL]             if (val != null) { [EOL]                 return val; [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public static boolean notEqual(final Object object1, final Object object2) { [EOL]     return ObjectUtils.equals(object1, object2) == false; [EOL] }
public static void identityToString(final Appendable appendable, final Object object) throws IOException { [EOL]     if (object == null) { [EOL]         throw new NullPointerException("Cannot get the toString of a null identity"); [EOL]     } [EOL]     appendable.append(object.getClass().getName()).append('@').append(Integer.toHexString(System.identityHashCode(object))); [EOL] }
public static String toString(final Object obj) { [EOL]     return obj == null ? "" : obj.toString(); [EOL] }
public static String toString(final Object obj) { [EOL]     return obj == null ? "" : obj.toString(); [EOL] }
public static <T extends Comparable<? super T>> int compare(final T c1, final T c2) { [EOL]     return compare(c1, c2, false); [EOL] }
public static <T extends Comparable<? super T>> int compare(final T c1, final T c2) { [EOL]     return compare(c1, c2, false); [EOL] }
public static <T extends Comparable<? super T>> T median(final T... items) { [EOL]     Validate.notEmpty(items); [EOL]     Validate.noNullElements(items); [EOL]     final TreeSet<T> sort = new TreeSet<T>(); [EOL]     Collections.addAll(sort, items); [EOL]     @SuppressWarnings("unchecked") [EOL]     final T result = (T) sort.toArray()[(sort.size() - 1) / 2]; [EOL]     return result; [EOL] }
public static <T extends Comparable<? super T>> T median(final T... items) { [EOL]     Validate.notEmpty(items); [EOL]     Validate.noNullElements(items); [EOL]     final TreeSet<T> sort = new TreeSet<T>(); [EOL]     Collections.addAll(sort, items); [EOL]     @SuppressWarnings("unchecked") [EOL]     final T result = (T) sort.toArray()[(sort.size() - 1) / 2]; [EOL]     return result; [EOL] }
public static <T extends Comparable<? super T>> T median(final T... items) { [EOL]     Validate.notEmpty(items); [EOL]     Validate.noNullElements(items); [EOL]     final TreeSet<T> sort = new TreeSet<T>(); [EOL]     Collections.addAll(sort, items); [EOL]     @SuppressWarnings("unchecked") [EOL]     final T result = (T) sort.toArray()[(sort.size() - 1) / 2]; [EOL]     return result; [EOL] }
public static <T extends Comparable<? super T>> T median(final T... items) { [EOL]     Validate.notEmpty(items); [EOL]     Validate.noNullElements(items); [EOL]     final TreeSet<T> sort = new TreeSet<T>(); [EOL]     Collections.addAll(sort, items); [EOL]     @SuppressWarnings("unchecked") [EOL]     final T result = (T) sort.toArray()[(sort.size() - 1) / 2]; [EOL]     return result; [EOL] }
public static <T extends Comparable<? super T>> T median(final T... items) { [EOL]     Validate.notEmpty(items); [EOL]     Validate.noNullElements(items); [EOL]     final TreeSet<T> sort = new TreeSet<T>(); [EOL]     Collections.addAll(sort, items); [EOL]     @SuppressWarnings("unchecked") [EOL]     final T result = (T) sort.toArray()[(sort.size() - 1) / 2]; [EOL]     return result; [EOL] }
public static <T extends Comparable<? super T>> T median(final T... items) { [EOL]     Validate.notEmpty(items); [EOL]     Validate.noNullElements(items); [EOL]     final TreeSet<T> sort = new TreeSet<T>(); [EOL]     Collections.addAll(sort, items); [EOL]     @SuppressWarnings("unchecked") [EOL]     final T result = (T) sort.toArray()[(sort.size() - 1) / 2]; [EOL]     return result; [EOL] }
public static <T> T clone(final T obj) { [EOL]     if (obj instanceof Cloneable) { [EOL]         final Object result; [EOL]         if (obj.getClass().isArray()) { [EOL]             final Class<?> componentType = obj.getClass().getComponentType(); [EOL]             if (!componentType.isPrimitive()) { [EOL]                 result = ((Object[]) obj).clone(); [EOL]             } else { [EOL]                 int length = Array.getLength(obj); [EOL]                 result = Array.newInstance(componentType, length); [EOL]                 while (length-- > 0) { [EOL]                     Array.set(result, length, Array.get(obj, length)); [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             try { [EOL]                 final Method clone = obj.getClass().getMethod("clone"); [EOL]                 result = clone.invoke(obj); [EOL]             } catch (final NoSuchMethodException e) { [EOL]                 throw new CloneFailedException("Cloneable type " + obj.getClass().getName() + " has no clone method", e); [EOL]             } catch (final IllegalAccessException e) { [EOL]                 throw new CloneFailedException("Cannot clone Cloneable type " + obj.getClass().getName(), e); [EOL]             } catch (final InvocationTargetException e) { [EOL]                 throw new CloneFailedException("Exception cloning Cloneable type " + obj.getClass().getName(), e.getCause()); [EOL]             } [EOL]         } [EOL]         @SuppressWarnings("unchecked") [EOL]         final T checked = (T) result; [EOL]         return checked; [EOL]     } [EOL]     return null; [EOL] }
public static <T> T clone(final T obj) { [EOL]     if (obj instanceof Cloneable) { [EOL]         final Object result; [EOL]         if (obj.getClass().isArray()) { [EOL]             final Class<?> componentType = obj.getClass().getComponentType(); [EOL]             if (!componentType.isPrimitive()) { [EOL]                 result = ((Object[]) obj).clone(); [EOL]             } else { [EOL]                 int length = Array.getLength(obj); [EOL]                 result = Array.newInstance(componentType, length); [EOL]                 while (length-- > 0) { [EOL]                     Array.set(result, length, Array.get(obj, length)); [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             try { [EOL]                 final Method clone = obj.getClass().getMethod("clone"); [EOL]                 result = clone.invoke(obj); [EOL]             } catch (final NoSuchMethodException e) { [EOL]                 throw new CloneFailedException("Cloneable type " + obj.getClass().getName() + " has no clone method", e); [EOL]             } catch (final IllegalAccessException e) { [EOL]                 throw new CloneFailedException("Cannot clone Cloneable type " + obj.getClass().getName(), e); [EOL]             } catch (final InvocationTargetException e) { [EOL]                 throw new CloneFailedException("Exception cloning Cloneable type " + obj.getClass().getName(), e.getCause()); [EOL]             } [EOL]         } [EOL]         @SuppressWarnings("unchecked") [EOL]         final T checked = (T) result; [EOL]         return checked; [EOL]     } [EOL]     return null; [EOL] }
public static <T> T clone(final T obj) { [EOL]     if (obj instanceof Cloneable) { [EOL]         final Object result; [EOL]         if (obj.getClass().isArray()) { [EOL]             final Class<?> componentType = obj.getClass().getComponentType(); [EOL]             if (!componentType.isPrimitive()) { [EOL]                 result = ((Object[]) obj).clone(); [EOL]             } else { [EOL]                 int length = Array.getLength(obj); [EOL]                 result = Array.newInstance(componentType, length); [EOL]                 while (length-- > 0) { [EOL]                     Array.set(result, length, Array.get(obj, length)); [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             try { [EOL]                 final Method clone = obj.getClass().getMethod("clone"); [EOL]                 result = clone.invoke(obj); [EOL]             } catch (final NoSuchMethodException e) { [EOL]                 throw new CloneFailedException("Cloneable type " + obj.getClass().getName() + " has no clone method", e); [EOL]             } catch (final IllegalAccessException e) { [EOL]                 throw new CloneFailedException("Cannot clone Cloneable type " + obj.getClass().getName(), e); [EOL]             } catch (final InvocationTargetException e) { [EOL]                 throw new CloneFailedException("Exception cloning Cloneable type " + obj.getClass().getName(), e.getCause()); [EOL]             } [EOL]         } [EOL]         @SuppressWarnings("unchecked") [EOL]         final T checked = (T) result; [EOL]         return checked; [EOL]     } [EOL]     return null; [EOL] }
public static <T> T clone(final T obj) { [EOL]     if (obj instanceof Cloneable) { [EOL]         final Object result; [EOL]         if (obj.getClass().isArray()) { [EOL]             final Class<?> componentType = obj.getClass().getComponentType(); [EOL]             if (!componentType.isPrimitive()) { [EOL]                 result = ((Object[]) obj).clone(); [EOL]             } else { [EOL]                 int length = Array.getLength(obj); [EOL]                 result = Array.newInstance(componentType, length); [EOL]                 while (length-- > 0) { [EOL]                     Array.set(result, length, Array.get(obj, length)); [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             try { [EOL]                 final Method clone = obj.getClass().getMethod("clone"); [EOL]                 result = clone.invoke(obj); [EOL]             } catch (final NoSuchMethodException e) { [EOL]                 throw new CloneFailedException("Cloneable type " + obj.getClass().getName() + " has no clone method", e); [EOL]             } catch (final IllegalAccessException e) { [EOL]                 throw new CloneFailedException("Cannot clone Cloneable type " + obj.getClass().getName(), e); [EOL]             } catch (final InvocationTargetException e) { [EOL]                 throw new CloneFailedException("Exception cloning Cloneable type " + obj.getClass().getName(), e.getCause()); [EOL]             } [EOL]         } [EOL]         @SuppressWarnings("unchecked") [EOL]         final T checked = (T) result; [EOL]         return checked; [EOL]     } [EOL]     return null; [EOL] }
public static <T> T clone(final T obj) { [EOL]     if (obj instanceof Cloneable) { [EOL]         final Object result; [EOL]         if (obj.getClass().isArray()) { [EOL]             final Class<?> componentType = obj.getClass().getComponentType(); [EOL]             if (!componentType.isPrimitive()) { [EOL]                 result = ((Object[]) obj).clone(); [EOL]             } else { [EOL]                 int length = Array.getLength(obj); [EOL]                 result = Array.newInstance(componentType, length); [EOL]                 while (length-- > 0) { [EOL]                     Array.set(result, length, Array.get(obj, length)); [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             try { [EOL]                 final Method clone = obj.getClass().getMethod("clone"); [EOL]                 result = clone.invoke(obj); [EOL]             } catch (final NoSuchMethodException e) { [EOL]                 throw new CloneFailedException("Cloneable type " + obj.getClass().getName() + " has no clone method", e); [EOL]             } catch (final IllegalAccessException e) { [EOL]                 throw new CloneFailedException("Cannot clone Cloneable type " + obj.getClass().getName(), e); [EOL]             } catch (final InvocationTargetException e) { [EOL]                 throw new CloneFailedException("Exception cloning Cloneable type " + obj.getClass().getName(), e.getCause()); [EOL]             } [EOL]         } [EOL]         @SuppressWarnings("unchecked") [EOL]         final T checked = (T) result; [EOL]         return checked; [EOL]     } [EOL]     return null; [EOL] }
public static boolean CONST(final boolean v) { [EOL]     return v; [EOL] }
public static boolean CONST(final boolean v) { [EOL]     return v; [EOL] }
public static byte CONST(final byte v) { [EOL]     return v; [EOL] }
public static byte CONST_BYTE(final int v) throws IllegalArgumentException { [EOL]     if (v < Byte.MIN_VALUE || v > Byte.MAX_VALUE) { [EOL]         throw new IllegalArgumentException("Supplied value must be a valid byte literal between -128 and 127: [" + v + "]"); [EOL]     } [EOL]     return (byte) v; [EOL] }
public static byte CONST_BYTE(final int v) throws IllegalArgumentException { [EOL]     if (v < Byte.MIN_VALUE || v > Byte.MAX_VALUE) { [EOL]         throw new IllegalArgumentException("Supplied value must be a valid byte literal between -128 and 127: [" + v + "]"); [EOL]     } [EOL]     return (byte) v; [EOL] }
public static char CONST(final char v) { [EOL]     return v; [EOL] }
public static short CONST(final short v) { [EOL]     return v; [EOL] }
public static short CONST_SHORT(final int v) throws IllegalArgumentException { [EOL]     if (v < Short.MIN_VALUE || v > Short.MAX_VALUE) { [EOL]         throw new IllegalArgumentException("Supplied value must be a valid byte literal between -32768 and 32767: [" + v + "]"); [EOL]     } [EOL]     return (short) v; [EOL] }
public static int CONST(final int v) { [EOL]     return v; [EOL] }
public static long CONST(final long v) { [EOL]     return v; [EOL] }
public static float CONST(final float v) { [EOL]     return v; [EOL] }
public static double CONST(final double v) { [EOL]     return v; [EOL] }
public static double CONST(final double v) { [EOL]     return v; [EOL] }
public static double CONST(final double v) { [EOL]     return v; [EOL] }
public static <T> T CONST(final T v) { [EOL]     return v; [EOL] }
public static <T> T CONST(final T v) { [EOL]     return v; [EOL] }
@Override [EOL] public T get() throws ConcurrentException { [EOL]     T result = object; [EOL]     if (result == null) { [EOL]         synchronized (this) { [EOL]             result = object; [EOL]             if (result == null) { [EOL]                 object = result = initialize(); [EOL]             } [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
@Override [EOL] public T get() throws ConcurrentException { [EOL]     T result = object; [EOL]     if (result == null) { [EOL]         synchronized (this) { [EOL]             result = object; [EOL]             if (result == null) { [EOL]                 object = result = initialize(); [EOL]             } [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
public Validate() { [EOL]     super(); [EOL] }
public static void isTrue(final boolean expression, final String message, final double value) { [EOL]     if (expression == false) { [EOL]         throw new IllegalArgumentException(String.format(message, Double.valueOf(value))); [EOL]     } [EOL] }
public static void isTrue(final boolean expression, final String message, final double value) { [EOL]     if (expression == false) { [EOL]         throw new IllegalArgumentException(String.format(message, Double.valueOf(value))); [EOL]     } [EOL] }
public static <T> T[] notEmpty(final T[] array, final String message, final Object... values) { [EOL]     if (array == null) { [EOL]         throw new NullPointerException(String.format(message, values)); [EOL]     } [EOL]     if (array.length == 0) { [EOL]         throw new IllegalArgumentException(String.format(message, values)); [EOL]     } [EOL]     return array; [EOL] }
public static <T> T[] notEmpty(final T[] array, final String message, final Object... values) { [EOL]     if (array == null) { [EOL]         throw new NullPointerException(String.format(message, values)); [EOL]     } [EOL]     if (array.length == 0) { [EOL]         throw new IllegalArgumentException(String.format(message, values)); [EOL]     } [EOL]     return array; [EOL] }
public static <T> T[] notEmpty(final T[] array, final String message, final Object... values) { [EOL]     if (array == null) { [EOL]         throw new NullPointerException(String.format(message, values)); [EOL]     } [EOL]     if (array.length == 0) { [EOL]         throw new IllegalArgumentException(String.format(message, values)); [EOL]     } [EOL]     return array; [EOL] }
public static <T> T[] notEmpty(final T[] array) { [EOL]     return notEmpty(array, DEFAULT_NOT_EMPTY_ARRAY_EX_MESSAGE); [EOL] }
public static <T> T[] notEmpty(final T[] array) { [EOL]     return notEmpty(array, DEFAULT_NOT_EMPTY_ARRAY_EX_MESSAGE); [EOL] }
public static <T> T[] notEmpty(final T[] array) { [EOL]     return notEmpty(array, DEFAULT_NOT_EMPTY_ARRAY_EX_MESSAGE); [EOL] }
public static <T extends CharSequence> T notEmpty(final T chars, final String message, final Object... values) { [EOL]     if (chars == null) { [EOL]         throw new NullPointerException(String.format(message, values)); [EOL]     } [EOL]     if (chars.length() == 0) { [EOL]         throw new IllegalArgumentException(String.format(message, values)); [EOL]     } [EOL]     return chars; [EOL] }
public static <T extends CharSequence> T notEmpty(final T chars, final String message, final Object... values) { [EOL]     if (chars == null) { [EOL]         throw new NullPointerException(String.format(message, values)); [EOL]     } [EOL]     if (chars.length() == 0) { [EOL]         throw new IllegalArgumentException(String.format(message, values)); [EOL]     } [EOL]     return chars; [EOL] }
public static <T extends CharSequence> T validIndex(final T chars, final int index, final String message, final Object... values) { [EOL]     Validate.notNull(chars); [EOL]     if (index < 0 || index >= chars.length()) { [EOL]         throw new IndexOutOfBoundsException(String.format(message, values)); [EOL]     } [EOL]     return chars; [EOL] }
public static <T extends CharSequence> T validIndex(final T chars, final int index, final String message, final Object... values) { [EOL]     Validate.notNull(chars); [EOL]     if (index < 0 || index >= chars.length()) { [EOL]         throw new IndexOutOfBoundsException(String.format(message, values)); [EOL]     } [EOL]     return chars; [EOL] }
public static <T extends CharSequence> T validIndex(final T chars, final int index, final String message, final Object... values) { [EOL]     Validate.notNull(chars); [EOL]     if (index < 0 || index >= chars.length()) { [EOL]         throw new IndexOutOfBoundsException(String.format(message, values)); [EOL]     } [EOL]     return chars; [EOL] }
public static <T extends CharSequence> T validIndex(final T chars, final int index, final String message, final Object... values) { [EOL]     Validate.notNull(chars); [EOL]     if (index < 0 || index >= chars.length()) { [EOL]         throw new IndexOutOfBoundsException(String.format(message, values)); [EOL]     } [EOL]     return chars; [EOL] }
public static <T extends CharSequence> T validIndex(final T chars, final int index) { [EOL]     return validIndex(chars, index, DEFAULT_VALID_INDEX_CHAR_SEQUENCE_EX_MESSAGE, Integer.valueOf(index)); [EOL] }
public static <T> void exclusiveBetween(final T start, final T end, final Comparable<T> value) { [EOL]     if (value.compareTo(start) <= 0 || value.compareTo(end) >= 0) { [EOL]         throw new IllegalArgumentException(String.format(DEFAULT_EXCLUSIVE_BETWEEN_EX_MESSAGE, value, start, end)); [EOL]     } [EOL] }
public static <T> void exclusiveBetween(final T start, final T end, final Comparable<T> value) { [EOL]     if (value.compareTo(start) <= 0 || value.compareTo(end) >= 0) { [EOL]         throw new IllegalArgumentException(String.format(DEFAULT_EXCLUSIVE_BETWEEN_EX_MESSAGE, value, start, end)); [EOL]     } [EOL] }
public static void isAssignableFrom(final Class<?> superType, final Class<?> type) { [EOL]     if (superType.isAssignableFrom(type) == false) { [EOL]         throw new IllegalArgumentException(String.format(DEFAULT_IS_ASSIGNABLE_EX_MESSAGE, type == null ? "null" : type.getName(), superType.getName())); [EOL]     } [EOL] }
public static String squeeze(final String str, final String... set) { [EOL]     if (StringUtils.isEmpty(str) || deepEmpty(set)) { [EOL]         return str; [EOL]     } [EOL]     final CharSet chars = CharSet.getInstance(set); [EOL]     final StringBuilder buffer = new StringBuilder(str.length()); [EOL]     final char[] chrs = str.toCharArray(); [EOL]     final int sz = chrs.length; [EOL]     char lastChar = ' '; [EOL]     char ch = ' '; [EOL]     for (int i = 0; i < sz; i++) { [EOL]         ch = chrs[i]; [EOL]         if (ch == lastChar && i != 0 && chars.contains(ch)) { [EOL]             continue; [EOL]         } [EOL]         buffer.append(ch); [EOL]         lastChar = ch; [EOL]     } [EOL]     return buffer.toString(); [EOL] }
public static void printRootCauseStackTrace(final Throwable throwable) { [EOL]     printRootCauseStackTrace(throwable, System.err); [EOL] } public ExceptionUtils(); public static String[] getDefaultCauseMethodNames(); public static Throwable getCause(final Throwable throwable); public static Throwable getCause(final Throwable throwable, String[] methodNames); public static Throwable getRootCause(final Throwable throwable); private static Throwable getCauseUsingMethodName(final Throwable throwable, final String methodName); public static int getThrowableCount(final Throwable throwable); public static Throwable[] getThrowables(final Throwable throwable); public static List<Throwable> getThrowableList(Throwable throwable); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz, final int fromIndex); public static int indexOfType(final Throwable throwable, final Class<?> type); public static int indexOfType(final Throwable throwable, final Class<?> type, final int fromIndex); private static int indexOf(final Throwable throwable, final Class<?> type, int fromIndex, final boolean subclass); public static void printRootCauseStackTrace(final Throwable throwable); public static void printRootCauseStackTrace(final Throwable throwable, final PrintStream stream); public static void printRootCauseStackTrace(final Throwable throwable, final PrintWriter writer); public static String[] getRootCauseStackTrace(final Throwable throwable); public static void removeCommonFrames(final List<String> causeFrames, final List<String> wrapperFrames); public static String getStackTrace(final Throwable throwable); public static String[] getStackFrames(final Throwable throwable);  static String[] getStackFrames(final String stackTrace);  static List<String> getStackFrameList(final Throwable t); public static String getMessage(final Throwable th); public static String getRootCauseMessage(final Throwable th); String WRAPPED_MARKER=Optional[" [wrapped] "]; String[] CAUSE_METHOD_NAMES=Optional[{ "getCause", "getNextException", "getTargetException", "getException", "getSourceException", "getRootCause", "getCausedByException", "getNested", "getLinkedException", "getNestedException", "getLinkedCause", "getThrowable" }
public static String getMessage(final Throwable th) { [EOL]     if (th == null) { [EOL]         return ""; [EOL]     } [EOL]     final String clsName = ClassUtils.getShortClassName(th, null); [EOL]     final String msg = th.getMessage(); [EOL]     return clsName + ": " + StringUtils.defaultString(msg); [EOL] } public ExceptionUtils(); public static String[] getDefaultCauseMethodNames(); public static Throwable getCause(final Throwable throwable); public static Throwable getCause(final Throwable throwable, String[] methodNames); public static Throwable getRootCause(final Throwable throwable); private static Throwable getCauseUsingMethodName(final Throwable throwable, final String methodName); public static int getThrowableCount(final Throwable throwable); public static Throwable[] getThrowables(final Throwable throwable); public static List<Throwable> getThrowableList(Throwable throwable); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz, final int fromIndex); public static int indexOfType(final Throwable throwable, final Class<?> type); public static int indexOfType(final Throwable throwable, final Class<?> type, final int fromIndex); private static int indexOf(final Throwable throwable, final Class<?> type, int fromIndex, final boolean subclass); public static void printRootCauseStackTrace(final Throwable throwable); public static void printRootCauseStackTrace(final Throwable throwable, final PrintStream stream); public static void printRootCauseStackTrace(final Throwable throwable, final PrintWriter writer); public static String[] getRootCauseStackTrace(final Throwable throwable); public static void removeCommonFrames(final List<String> causeFrames, final List<String> wrapperFrames); public static String getStackTrace(final Throwable throwable); public static String[] getStackFrames(final Throwable throwable);  static String[] getStackFrames(final String stackTrace);  static List<String> getStackFrameList(final Throwable t); public static String getMessage(final Throwable th); public static String getRootCauseMessage(final Throwable th); String WRAPPED_MARKER=Optional[" [wrapped] "]; String[] CAUSE_METHOD_NAMES=Optional[{ "getCause", "getNextException", "getTargetException", "getException", "getSourceException", "getRootCause", "getCausedByException", "getNested", "getLinkedException", "getNestedException", "getLinkedCause", "getThrowable" }
public static String getMessage(final Throwable th) { [EOL]     if (th == null) { [EOL]         return ""; [EOL]     } [EOL]     final String clsName = ClassUtils.getShortClassName(th, null); [EOL]     final String msg = th.getMessage(); [EOL]     return clsName + ": " + StringUtils.defaultString(msg); [EOL] } public ExceptionUtils(); public static String[] getDefaultCauseMethodNames(); public static Throwable getCause(final Throwable throwable); public static Throwable getCause(final Throwable throwable, String[] methodNames); public static Throwable getRootCause(final Throwable throwable); private static Throwable getCauseUsingMethodName(final Throwable throwable, final String methodName); public static int getThrowableCount(final Throwable throwable); public static Throwable[] getThrowables(final Throwable throwable); public static List<Throwable> getThrowableList(Throwable throwable); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz, final int fromIndex); public static int indexOfType(final Throwable throwable, final Class<?> type); public static int indexOfType(final Throwable throwable, final Class<?> type, final int fromIndex); private static int indexOf(final Throwable throwable, final Class<?> type, int fromIndex, final boolean subclass); public static void printRootCauseStackTrace(final Throwable throwable); public static void printRootCauseStackTrace(final Throwable throwable, final PrintStream stream); public static void printRootCauseStackTrace(final Throwable throwable, final PrintWriter writer); public static String[] getRootCauseStackTrace(final Throwable throwable); public static void removeCommonFrames(final List<String> causeFrames, final List<String> wrapperFrames); public static String getStackTrace(final Throwable throwable); public static String[] getStackFrames(final Throwable throwable);  static String[] getStackFrames(final String stackTrace);  static List<String> getStackFrameList(final Throwable t); public static String getMessage(final Throwable th); public static String getRootCauseMessage(final Throwable th); String WRAPPED_MARKER=Optional[" [wrapped] "]; String[] CAUSE_METHOD_NAMES=Optional[{ "getCause", "getNextException", "getTargetException", "getException", "getSourceException", "getRootCause", "getCausedByException", "getNested", "getLinkedException", "getNestedException", "getLinkedCause", "getThrowable" }
public static String getMessage(final Throwable th) { [EOL]     if (th == null) { [EOL]         return ""; [EOL]     } [EOL]     final String clsName = ClassUtils.getShortClassName(th, null); [EOL]     final String msg = th.getMessage(); [EOL]     return clsName + ": " + StringUtils.defaultString(msg); [EOL] } public ExceptionUtils(); public static String[] getDefaultCauseMethodNames(); public static Throwable getCause(final Throwable throwable); public static Throwable getCause(final Throwable throwable, String[] methodNames); public static Throwable getRootCause(final Throwable throwable); private static Throwable getCauseUsingMethodName(final Throwable throwable, final String methodName); public static int getThrowableCount(final Throwable throwable); public static Throwable[] getThrowables(final Throwable throwable); public static List<Throwable> getThrowableList(Throwable throwable); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz, final int fromIndex); public static int indexOfType(final Throwable throwable, final Class<?> type); public static int indexOfType(final Throwable throwable, final Class<?> type, final int fromIndex); private static int indexOf(final Throwable throwable, final Class<?> type, int fromIndex, final boolean subclass); public static void printRootCauseStackTrace(final Throwable throwable); public static void printRootCauseStackTrace(final Throwable throwable, final PrintStream stream); public static void printRootCauseStackTrace(final Throwable throwable, final PrintWriter writer); public static String[] getRootCauseStackTrace(final Throwable throwable); public static void removeCommonFrames(final List<String> causeFrames, final List<String> wrapperFrames); public static String getStackTrace(final Throwable throwable); public static String[] getStackFrames(final Throwable throwable);  static String[] getStackFrames(final String stackTrace);  static List<String> getStackFrameList(final Throwable t); public static String getMessage(final Throwable th); public static String getRootCauseMessage(final Throwable th); String WRAPPED_MARKER=Optional[" [wrapped] "]; String[] CAUSE_METHOD_NAMES=Optional[{ "getCause", "getNextException", "getTargetException", "getException", "getSourceException", "getRootCause", "getCausedByException", "getNested", "getLinkedException", "getNestedException", "getLinkedCause", "getThrowable" }
public static String getRootCauseMessage(final Throwable th) { [EOL]     Throwable root = ExceptionUtils.getRootCause(th); [EOL]     root = root == null ? th : root; [EOL]     return getMessage(root); [EOL] } public ExceptionUtils(); public static String[] getDefaultCauseMethodNames(); public static Throwable getCause(final Throwable throwable); public static Throwable getCause(final Throwable throwable, String[] methodNames); public static Throwable getRootCause(final Throwable throwable); private static Throwable getCauseUsingMethodName(final Throwable throwable, final String methodName); public static int getThrowableCount(final Throwable throwable); public static Throwable[] getThrowables(final Throwable throwable); public static List<Throwable> getThrowableList(Throwable throwable); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz, final int fromIndex); public static int indexOfType(final Throwable throwable, final Class<?> type); public static int indexOfType(final Throwable throwable, final Class<?> type, final int fromIndex); private static int indexOf(final Throwable throwable, final Class<?> type, int fromIndex, final boolean subclass); public static void printRootCauseStackTrace(final Throwable throwable); public static void printRootCauseStackTrace(final Throwable throwable, final PrintStream stream); public static void printRootCauseStackTrace(final Throwable throwable, final PrintWriter writer); public static String[] getRootCauseStackTrace(final Throwable throwable); public static void removeCommonFrames(final List<String> causeFrames, final List<String> wrapperFrames); public static String getStackTrace(final Throwable throwable); public static String[] getStackFrames(final Throwable throwable);  static String[] getStackFrames(final String stackTrace);  static List<String> getStackFrameList(final Throwable t); public static String getMessage(final Throwable th); public static String getRootCauseMessage(final Throwable th); String WRAPPED_MARKER=Optional[" [wrapped] "]; String[] CAUSE_METHOD_NAMES=Optional[{ "getCause", "getNextException", "getTargetException", "getException", "getSourceException", "getRootCause", "getCausedByException", "getNested", "getLinkedException", "getNestedException", "getLinkedCause", "getThrowable" }
public static String getRootCauseMessage(final Throwable th) { [EOL]     Throwable root = ExceptionUtils.getRootCause(th); [EOL]     root = root == null ? th : root; [EOL]     return getMessage(root); [EOL] } public ExceptionUtils(); public static String[] getDefaultCauseMethodNames(); public static Throwable getCause(final Throwable throwable); public static Throwable getCause(final Throwable throwable, String[] methodNames); public static Throwable getRootCause(final Throwable throwable); private static Throwable getCauseUsingMethodName(final Throwable throwable, final String methodName); public static int getThrowableCount(final Throwable throwable); public static Throwable[] getThrowables(final Throwable throwable); public static List<Throwable> getThrowableList(Throwable throwable); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz, final int fromIndex); public static int indexOfType(final Throwable throwable, final Class<?> type); public static int indexOfType(final Throwable throwable, final Class<?> type, final int fromIndex); private static int indexOf(final Throwable throwable, final Class<?> type, int fromIndex, final boolean subclass); public static void printRootCauseStackTrace(final Throwable throwable); public static void printRootCauseStackTrace(final Throwable throwable, final PrintStream stream); public static void printRootCauseStackTrace(final Throwable throwable, final PrintWriter writer); public static String[] getRootCauseStackTrace(final Throwable throwable); public static void removeCommonFrames(final List<String> causeFrames, final List<String> wrapperFrames); public static String getStackTrace(final Throwable throwable); public static String[] getStackFrames(final Throwable throwable);  static String[] getStackFrames(final String stackTrace);  static List<String> getStackFrameList(final Throwable t); public static String getMessage(final Throwable th); public static String getRootCauseMessage(final Throwable th); String WRAPPED_MARKER=Optional[" [wrapped] "]; String[] CAUSE_METHOD_NAMES=Optional[{ "getCause", "getNextException", "getTargetException", "getException", "getSourceException", "getRootCause", "getCausedByException", "getNested", "getLinkedException", "getNestedException", "getLinkedCause", "getThrowable" }
public static String getRootCauseMessage(final Throwable th) { [EOL]     Throwable root = ExceptionUtils.getRootCause(th); [EOL]     root = root == null ? th : root; [EOL]     return getMessage(root); [EOL] } public ExceptionUtils(); public static String[] getDefaultCauseMethodNames(); public static Throwable getCause(final Throwable throwable); public static Throwable getCause(final Throwable throwable, String[] methodNames); public static Throwable getRootCause(final Throwable throwable); private static Throwable getCauseUsingMethodName(final Throwable throwable, final String methodName); public static int getThrowableCount(final Throwable throwable); public static Throwable[] getThrowables(final Throwable throwable); public static List<Throwable> getThrowableList(Throwable throwable); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz); public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz, final int fromIndex); public static int indexOfType(final Throwable throwable, final Class<?> type); public static int indexOfType(final Throwable throwable, final Class<?> type, final int fromIndex); private static int indexOf(final Throwable throwable, final Class<?> type, int fromIndex, final boolean subclass); public static void printRootCauseStackTrace(final Throwable throwable); public static void printRootCauseStackTrace(final Throwable throwable, final PrintStream stream); public static void printRootCauseStackTrace(final Throwable throwable, final PrintWriter writer); public static String[] getRootCauseStackTrace(final Throwable throwable); public static void removeCommonFrames(final List<String> causeFrames, final List<String> wrapperFrames); public static String getStackTrace(final Throwable throwable); public static String[] getStackFrames(final Throwable throwable);  static String[] getStackFrames(final String stackTrace);  static List<String> getStackFrameList(final Throwable t); public static String getMessage(final Throwable th); public static String getRootCauseMessage(final Throwable th); String WRAPPED_MARKER=Optional[" [wrapped] "]; String[] CAUSE_METHOD_NAMES=Optional[{ "getCause", "getNextException", "getTargetException", "getException", "getSourceException", "getRootCause", "getCausedByException", "getNested", "getLinkedException", "getNestedException", "getLinkedCause", "getThrowable" }
public MutableShort() { [EOL]     super(); [EOL] }
@Override [EOL] public Short getValue() { [EOL]     return Short.valueOf(this.value); [EOL] }
@Override [EOL] public Short getValue() { [EOL]     return Short.valueOf(this.value); [EOL] }
@Override [EOL] public Short getValue() { [EOL]     return Short.valueOf(this.value); [EOL] }
public void setValue(final short value) { [EOL]     this.value = value; [EOL] }
@Override [EOL] public void setValue(final Number value) { [EOL]     this.value = value.shortValue(); [EOL] }
@Override [EOL] public void setValue(final Number value) { [EOL]     this.value = value.shortValue(); [EOL] }
@Override [EOL] public void setValue(final Number value) { [EOL]     this.value = value.shortValue(); [EOL] }
@Override [EOL] public void setValue(final Number value) { [EOL]     this.value = value.shortValue(); [EOL] }
@Override [EOL] public void setValue(final Number value) { [EOL]     this.value = value.shortValue(); [EOL] }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj instanceof MutableShort) { [EOL]         return value == ((MutableShort) obj).shortValue(); [EOL]     } [EOL]     return false; [EOL] }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj instanceof MutableShort) { [EOL]         return value == ((MutableShort) obj).shortValue(); [EOL]     } [EOL]     return false; [EOL] }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj instanceof MutableShort) { [EOL]         return value == ((MutableShort) obj).shortValue(); [EOL]     } [EOL]     return false; [EOL] }
@Override [EOL] public int hashCode() { [EOL]     return value; [EOL] }
public StopWatch() { [EOL]     super(); [EOL] }
public void start() { [EOL]     if (this.runningState == STATE_STOPPED) { [EOL]         throw new IllegalStateException("Stopwatch must be reset before being restarted. "); [EOL]     } [EOL]     if (this.runningState != STATE_UNSTARTED) { [EOL]         throw new IllegalStateException("Stopwatch already started. "); [EOL]     } [EOL]     this.startTime = System.nanoTime(); [EOL]     this.startTimeMillis = System.currentTimeMillis(); [EOL]     this.runningState = STATE_RUNNING; [EOL] }
public void start() { [EOL]     if (this.runningState == STATE_STOPPED) { [EOL]         throw new IllegalStateException("Stopwatch must be reset before being restarted. "); [EOL]     } [EOL]     if (this.runningState != STATE_UNSTARTED) { [EOL]         throw new IllegalStateException("Stopwatch already started. "); [EOL]     } [EOL]     this.startTime = System.nanoTime(); [EOL]     this.startTimeMillis = System.currentTimeMillis(); [EOL]     this.runningState = STATE_RUNNING; [EOL] }
public void start() { [EOL]     if (this.runningState == STATE_STOPPED) { [EOL]         throw new IllegalStateException("Stopwatch must be reset before being restarted. "); [EOL]     } [EOL]     if (this.runningState != STATE_UNSTARTED) { [EOL]         throw new IllegalStateException("Stopwatch already started. "); [EOL]     } [EOL]     this.startTime = System.nanoTime(); [EOL]     this.startTimeMillis = System.currentTimeMillis(); [EOL]     this.runningState = STATE_RUNNING; [EOL] }
public void stop() { [EOL]     if (this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) { [EOL]         throw new IllegalStateException("Stopwatch is not running. "); [EOL]     } [EOL]     if (this.runningState == STATE_RUNNING) { [EOL]         this.stopTime = System.nanoTime(); [EOL]     } [EOL]     this.runningState = STATE_STOPPED; [EOL] }
public void suspend() { [EOL]     if (this.runningState != STATE_RUNNING) { [EOL]         throw new IllegalStateException("Stopwatch must be running to suspend. "); [EOL]     } [EOL]     this.stopTime = System.nanoTime(); [EOL]     this.runningState = STATE_SUSPENDED; [EOL] }
public void suspend() { [EOL]     if (this.runningState != STATE_RUNNING) { [EOL]         throw new IllegalStateException("Stopwatch must be running to suspend. "); [EOL]     } [EOL]     this.stopTime = System.nanoTime(); [EOL]     this.runningState = STATE_SUSPENDED; [EOL] }
public long getTime() { [EOL]     return getNanoTime() / NANO_2_MILLIS; [EOL] }
public long getTime() { [EOL]     return getNanoTime() / NANO_2_MILLIS; [EOL] }
public long getTime() { [EOL]     return getNanoTime() / NANO_2_MILLIS; [EOL] }
public long getNanoTime() { [EOL]     if (this.runningState == STATE_STOPPED || this.runningState == STATE_SUSPENDED) { [EOL]         return this.stopTime - this.startTime; [EOL]     } else if (this.runningState == STATE_UNSTARTED) { [EOL]         return 0; [EOL]     } else if (this.runningState == STATE_RUNNING) { [EOL]         return System.nanoTime() - this.startTime; [EOL]     } [EOL]     throw new RuntimeException("Illegal running state has occurred."); [EOL] }
public long getNanoTime() { [EOL]     if (this.runningState == STATE_STOPPED || this.runningState == STATE_SUSPENDED) { [EOL]         return this.stopTime - this.startTime; [EOL]     } else if (this.runningState == STATE_UNSTARTED) { [EOL]         return 0; [EOL]     } else if (this.runningState == STATE_RUNNING) { [EOL]         return System.nanoTime() - this.startTime; [EOL]     } [EOL]     throw new RuntimeException("Illegal running state has occurred."); [EOL] }
public long getNanoTime() { [EOL]     if (this.runningState == STATE_STOPPED || this.runningState == STATE_SUSPENDED) { [EOL]         return this.stopTime - this.startTime; [EOL]     } else if (this.runningState == STATE_UNSTARTED) { [EOL]         return 0; [EOL]     } else if (this.runningState == STATE_RUNNING) { [EOL]         return System.nanoTime() - this.startTime; [EOL]     } [EOL]     throw new RuntimeException("Illegal running state has occurred."); [EOL] }
public long getNanoTime() { [EOL]     if (this.runningState == STATE_STOPPED || this.runningState == STATE_SUSPENDED) { [EOL]         return this.stopTime - this.startTime; [EOL]     } else if (this.runningState == STATE_UNSTARTED) { [EOL]         return 0; [EOL]     } else if (this.runningState == STATE_RUNNING) { [EOL]         return System.nanoTime() - this.startTime; [EOL]     } [EOL]     throw new RuntimeException("Illegal running state has occurred."); [EOL] }
@Override [EOL] public final T get() throws ConcurrentException { [EOL]     T result; [EOL]     while ((result = reference.get()) == null) { [EOL]         if (factory.compareAndSet(null, this)) { [EOL]             reference.set(initialize()); [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
@Override [EOL] public final T get() throws ConcurrentException { [EOL]     T result; [EOL]     while ((result = reference.get()) == null) { [EOL]         if (factory.compareAndSet(null, this)) { [EOL]             reference.set(initialize()); [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
public static int reflectionCompare(final Object lhs, final Object rhs) { [EOL]     return reflectionCompare(lhs, rhs, false, null); [EOL] }
public static int reflectionCompare(final Object lhs, final Object rhs) { [EOL]     return reflectionCompare(lhs, rhs, false, null); [EOL] }
public static int reflectionCompare(final Object lhs, final Object rhs) { [EOL]     return reflectionCompare(lhs, rhs, false, null); [EOL] }
public static int reflectionCompare(final Object lhs, final Object rhs) { [EOL]     return reflectionCompare(lhs, rhs, false, null); [EOL] }
public static int reflectionCompare(final Object lhs, final Object rhs, final boolean compareTransients, final Class<?> reflectUpToClass, final String... excludeFields) { [EOL]     if (lhs == rhs) { [EOL]         return 0; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         throw new NullPointerException(); [EOL]     } [EOL]     Class<?> lhsClazz = lhs.getClass(); [EOL]     if (!lhsClazz.isInstance(rhs)) { [EOL]         throw new ClassCastException(); [EOL]     } [EOL]     final CompareToBuilder compareToBuilder = new CompareToBuilder(); [EOL]     reflectionAppend(lhs, rhs, lhsClazz, compareToBuilder, compareTransients, excludeFields); [EOL]     while (lhsClazz.getSuperclass() != null && lhsClazz != reflectUpToClass) { [EOL]         lhsClazz = lhsClazz.getSuperclass(); [EOL]         reflectionAppend(lhs, rhs, lhsClazz, compareToBuilder, compareTransients, excludeFields); [EOL]     } [EOL]     return compareToBuilder.toComparison(); [EOL] }
public static int reflectionCompare(final Object lhs, final Object rhs, final boolean compareTransients, final Class<?> reflectUpToClass, final String... excludeFields) { [EOL]     if (lhs == rhs) { [EOL]         return 0; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         throw new NullPointerException(); [EOL]     } [EOL]     Class<?> lhsClazz = lhs.getClass(); [EOL]     if (!lhsClazz.isInstance(rhs)) { [EOL]         throw new ClassCastException(); [EOL]     } [EOL]     final CompareToBuilder compareToBuilder = new CompareToBuilder(); [EOL]     reflectionAppend(lhs, rhs, lhsClazz, compareToBuilder, compareTransients, excludeFields); [EOL]     while (lhsClazz.getSuperclass() != null && lhsClazz != reflectUpToClass) { [EOL]         lhsClazz = lhsClazz.getSuperclass(); [EOL]         reflectionAppend(lhs, rhs, lhsClazz, compareToBuilder, compareTransients, excludeFields); [EOL]     } [EOL]     return compareToBuilder.toComparison(); [EOL] }
public CompareToBuilder appendSuper(final int superCompareTo) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     comparison = superCompareTo; [EOL]     return this; [EOL] }
public CompareToBuilder appendSuper(final int superCompareTo) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     comparison = superCompareTo; [EOL]     return this; [EOL] }
public CompareToBuilder append(final Object lhs, final Object rhs, final Comparator<?> comparator) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.getClass().isArray()) { [EOL]         if (lhs instanceof long[]) { [EOL]             append((long[]) lhs, (long[]) rhs); [EOL]         } else if (lhs instanceof int[]) { [EOL]             append((int[]) lhs, (int[]) rhs); [EOL]         } else if (lhs instanceof short[]) { [EOL]             append((short[]) lhs, (short[]) rhs); [EOL]         } else if (lhs instanceof char[]) { [EOL]             append((char[]) lhs, (char[]) rhs); [EOL]         } else if (lhs instanceof byte[]) { [EOL]             append((byte[]) lhs, (byte[]) rhs); [EOL]         } else if (lhs instanceof double[]) { [EOL]             append((double[]) lhs, (double[]) rhs); [EOL]         } else if (lhs instanceof float[]) { [EOL]             append((float[]) lhs, (float[]) rhs); [EOL]         } else if (lhs instanceof boolean[]) { [EOL]             append((boolean[]) lhs, (boolean[]) rhs); [EOL]         } else { [EOL]             append((Object[]) lhs, (Object[]) rhs, comparator); [EOL]         } [EOL]     } else { [EOL]         if (comparator == null) { [EOL]             @SuppressWarnings("unchecked") [EOL]             final Comparable<Object> comparable = (Comparable<Object>) lhs; [EOL]             comparison = comparable.compareTo(rhs); [EOL]         } else { [EOL]             @SuppressWarnings("unchecked") [EOL]             final Comparator<Object> comparator2 = (Comparator<Object>) comparator; [EOL]             comparison = comparator2.compare(lhs, rhs); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public CompareToBuilder append(final Object lhs, final Object rhs, final Comparator<?> comparator) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.getClass().isArray()) { [EOL]         if (lhs instanceof long[]) { [EOL]             append((long[]) lhs, (long[]) rhs); [EOL]         } else if (lhs instanceof int[]) { [EOL]             append((int[]) lhs, (int[]) rhs); [EOL]         } else if (lhs instanceof short[]) { [EOL]             append((short[]) lhs, (short[]) rhs); [EOL]         } else if (lhs instanceof char[]) { [EOL]             append((char[]) lhs, (char[]) rhs); [EOL]         } else if (lhs instanceof byte[]) { [EOL]             append((byte[]) lhs, (byte[]) rhs); [EOL]         } else if (lhs instanceof double[]) { [EOL]             append((double[]) lhs, (double[]) rhs); [EOL]         } else if (lhs instanceof float[]) { [EOL]             append((float[]) lhs, (float[]) rhs); [EOL]         } else if (lhs instanceof boolean[]) { [EOL]             append((boolean[]) lhs, (boolean[]) rhs); [EOL]         } else { [EOL]             append((Object[]) lhs, (Object[]) rhs, comparator); [EOL]         } [EOL]     } else { [EOL]         if (comparator == null) { [EOL]             @SuppressWarnings("unchecked") [EOL]             final Comparable<Object> comparable = (Comparable<Object>) lhs; [EOL]             comparison = comparable.compareTo(rhs); [EOL]         } else { [EOL]             @SuppressWarnings("unchecked") [EOL]             final Comparator<Object> comparator2 = (Comparator<Object>) comparator; [EOL]             comparison = comparator2.compare(lhs, rhs); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public CompareToBuilder append(final Object lhs, final Object rhs, final Comparator<?> comparator) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.getClass().isArray()) { [EOL]         if (lhs instanceof long[]) { [EOL]             append((long[]) lhs, (long[]) rhs); [EOL]         } else if (lhs instanceof int[]) { [EOL]             append((int[]) lhs, (int[]) rhs); [EOL]         } else if (lhs instanceof short[]) { [EOL]             append((short[]) lhs, (short[]) rhs); [EOL]         } else if (lhs instanceof char[]) { [EOL]             append((char[]) lhs, (char[]) rhs); [EOL]         } else if (lhs instanceof byte[]) { [EOL]             append((byte[]) lhs, (byte[]) rhs); [EOL]         } else if (lhs instanceof double[]) { [EOL]             append((double[]) lhs, (double[]) rhs); [EOL]         } else if (lhs instanceof float[]) { [EOL]             append((float[]) lhs, (float[]) rhs); [EOL]         } else if (lhs instanceof boolean[]) { [EOL]             append((boolean[]) lhs, (boolean[]) rhs); [EOL]         } else { [EOL]             append((Object[]) lhs, (Object[]) rhs, comparator); [EOL]         } [EOL]     } else { [EOL]         if (comparator == null) { [EOL]             @SuppressWarnings("unchecked") [EOL]             final Comparable<Object> comparable = (Comparable<Object>) lhs; [EOL]             comparison = comparable.compareTo(rhs); [EOL]         } else { [EOL]             @SuppressWarnings("unchecked") [EOL]             final Comparator<Object> comparator2 = (Comparator<Object>) comparator; [EOL]             comparison = comparator2.compare(lhs, rhs); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public CompareToBuilder append(final Object lhs, final Object rhs, final Comparator<?> comparator) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.getClass().isArray()) { [EOL]         if (lhs instanceof long[]) { [EOL]             append((long[]) lhs, (long[]) rhs); [EOL]         } else if (lhs instanceof int[]) { [EOL]             append((int[]) lhs, (int[]) rhs); [EOL]         } else if (lhs instanceof short[]) { [EOL]             append((short[]) lhs, (short[]) rhs); [EOL]         } else if (lhs instanceof char[]) { [EOL]             append((char[]) lhs, (char[]) rhs); [EOL]         } else if (lhs instanceof byte[]) { [EOL]             append((byte[]) lhs, (byte[]) rhs); [EOL]         } else if (lhs instanceof double[]) { [EOL]             append((double[]) lhs, (double[]) rhs); [EOL]         } else if (lhs instanceof float[]) { [EOL]             append((float[]) lhs, (float[]) rhs); [EOL]         } else if (lhs instanceof boolean[]) { [EOL]             append((boolean[]) lhs, (boolean[]) rhs); [EOL]         } else { [EOL]             append((Object[]) lhs, (Object[]) rhs, comparator); [EOL]         } [EOL]     } else { [EOL]         if (comparator == null) { [EOL]             @SuppressWarnings("unchecked") [EOL]             final Comparable<Object> comparable = (Comparable<Object>) lhs; [EOL]             comparison = comparable.compareTo(rhs); [EOL]         } else { [EOL]             @SuppressWarnings("unchecked") [EOL]             final Comparator<Object> comparator2 = (Comparator<Object>) comparator; [EOL]             comparison = comparator2.compare(lhs, rhs); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public CompareToBuilder append(final byte lhs, final byte rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     comparison = ((lhs < rhs) ? -1 : ((lhs > rhs) ? 1 : 0)); [EOL]     return this; [EOL] }
public CompareToBuilder append(final byte lhs, final byte rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     comparison = ((lhs < rhs) ? -1 : ((lhs > rhs) ? 1 : 0)); [EOL]     return this; [EOL] }
public CompareToBuilder append(final byte lhs, final byte rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     comparison = ((lhs < rhs) ? -1 : ((lhs > rhs) ? 1 : 0)); [EOL]     return this; [EOL] }
public CompareToBuilder append(final byte lhs, final byte rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     comparison = ((lhs < rhs) ? -1 : ((lhs > rhs) ? 1 : 0)); [EOL]     return this; [EOL] }
public CompareToBuilder append(final byte[] lhs, final byte[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public static String trimToEmpty(final String str) { [EOL]     return str == null ? EMPTY : str.trim(); [EOL] }
public static String trimToEmpty(final String str) { [EOL]     return str == null ? EMPTY : str.trim(); [EOL] }
public static String trimToEmpty(final String str) { [EOL]     return str == null ? EMPTY : str.trim(); [EOL] }
public static String trimToEmpty(final String str) { [EOL]     return str == null ? EMPTY : str.trim(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
private static int ordinalIndexOf(final CharSequence str, final CharSequence searchStr, final int ordinal, final boolean lastIndex) { [EOL]     if (str == null || searchStr == null || ordinal <= 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (searchStr.length() == 0) { [EOL]         return lastIndex ? str.length() : 0; [EOL]     } [EOL]     int found = 0; [EOL]     int index = lastIndex ? str.length() : INDEX_NOT_FOUND; [EOL]     do { [EOL]         if (lastIndex) { [EOL]             index = CharSequenceUtils.lastIndexOf(str, searchStr, index - 1); [EOL]         } else { [EOL]             index = CharSequenceUtils.indexOf(str, searchStr, index + 1); [EOL]         } [EOL]         if (index < 0) { [EOL]             return index; [EOL]         } [EOL]         found++; [EOL]     } while (found < ordinal); [EOL]     return index; [EOL] }
private static int ordinalIndexOf(final CharSequence str, final CharSequence searchStr, final int ordinal, final boolean lastIndex) { [EOL]     if (str == null || searchStr == null || ordinal <= 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (searchStr.length() == 0) { [EOL]         return lastIndex ? str.length() : 0; [EOL]     } [EOL]     int found = 0; [EOL]     int index = lastIndex ? str.length() : INDEX_NOT_FOUND; [EOL]     do { [EOL]         if (lastIndex) { [EOL]             index = CharSequenceUtils.lastIndexOf(str, searchStr, index - 1); [EOL]         } else { [EOL]             index = CharSequenceUtils.indexOf(str, searchStr, index + 1); [EOL]         } [EOL]         if (index < 0) { [EOL]             return index; [EOL]         } [EOL]         found++; [EOL]     } while (found < ordinal); [EOL]     return index; [EOL] }
private static int ordinalIndexOf(final CharSequence str, final CharSequence searchStr, final int ordinal, final boolean lastIndex) { [EOL]     if (str == null || searchStr == null || ordinal <= 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (searchStr.length() == 0) { [EOL]         return lastIndex ? str.length() : 0; [EOL]     } [EOL]     int found = 0; [EOL]     int index = lastIndex ? str.length() : INDEX_NOT_FOUND; [EOL]     do { [EOL]         if (lastIndex) { [EOL]             index = CharSequenceUtils.lastIndexOf(str, searchStr, index - 1); [EOL]         } else { [EOL]             index = CharSequenceUtils.indexOf(str, searchStr, index + 1); [EOL]         } [EOL]         if (index < 0) { [EOL]             return index; [EOL]         } [EOL]         found++; [EOL]     } while (found < ordinal); [EOL]     return index; [EOL] }
private static int ordinalIndexOf(final CharSequence str, final CharSequence searchStr, final int ordinal, final boolean lastIndex) { [EOL]     if (str == null || searchStr == null || ordinal <= 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (searchStr.length() == 0) { [EOL]         return lastIndex ? str.length() : 0; [EOL]     } [EOL]     int found = 0; [EOL]     int index = lastIndex ? str.length() : INDEX_NOT_FOUND; [EOL]     do { [EOL]         if (lastIndex) { [EOL]             index = CharSequenceUtils.lastIndexOf(str, searchStr, index - 1); [EOL]         } else { [EOL]             index = CharSequenceUtils.indexOf(str, searchStr, index + 1); [EOL]         } [EOL]         if (index < 0) { [EOL]             return index; [EOL]         } [EOL]         found++; [EOL]     } while (found < ordinal); [EOL]     return index; [EOL] }
private static int ordinalIndexOf(final CharSequence str, final CharSequence searchStr, final int ordinal, final boolean lastIndex) { [EOL]     if (str == null || searchStr == null || ordinal <= 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (searchStr.length() == 0) { [EOL]         return lastIndex ? str.length() : 0; [EOL]     } [EOL]     int found = 0; [EOL]     int index = lastIndex ? str.length() : INDEX_NOT_FOUND; [EOL]     do { [EOL]         if (lastIndex) { [EOL]             index = CharSequenceUtils.lastIndexOf(str, searchStr, index - 1); [EOL]         } else { [EOL]             index = CharSequenceUtils.indexOf(str, searchStr, index + 1); [EOL]         } [EOL]         if (index < 0) { [EOL]             return index; [EOL]         } [EOL]         found++; [EOL]     } while (found < ordinal); [EOL]     return index; [EOL] }
private static int ordinalIndexOf(final CharSequence str, final CharSequence searchStr, final int ordinal, final boolean lastIndex) { [EOL]     if (str == null || searchStr == null || ordinal <= 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (searchStr.length() == 0) { [EOL]         return lastIndex ? str.length() : 0; [EOL]     } [EOL]     int found = 0; [EOL]     int index = lastIndex ? str.length() : INDEX_NOT_FOUND; [EOL]     do { [EOL]         if (lastIndex) { [EOL]             index = CharSequenceUtils.lastIndexOf(str, searchStr, index - 1); [EOL]         } else { [EOL]             index = CharSequenceUtils.indexOf(str, searchStr, index + 1); [EOL]         } [EOL]         if (index < 0) { [EOL]             return index; [EOL]         } [EOL]         found++; [EOL]     } while (found < ordinal); [EOL]     return index; [EOL] }
private static int ordinalIndexOf(final CharSequence str, final CharSequence searchStr, final int ordinal, final boolean lastIndex) { [EOL]     if (str == null || searchStr == null || ordinal <= 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (searchStr.length() == 0) { [EOL]         return lastIndex ? str.length() : 0; [EOL]     } [EOL]     int found = 0; [EOL]     int index = lastIndex ? str.length() : INDEX_NOT_FOUND; [EOL]     do { [EOL]         if (lastIndex) { [EOL]             index = CharSequenceUtils.lastIndexOf(str, searchStr, index - 1); [EOL]         } else { [EOL]             index = CharSequenceUtils.indexOf(str, searchStr, index + 1); [EOL]         } [EOL]         if (index < 0) { [EOL]             return index; [EOL]         } [EOL]         found++; [EOL]     } while (found < ordinal); [EOL]     return index; [EOL] }
private static int ordinalIndexOf(final CharSequence str, final CharSequence searchStr, final int ordinal, final boolean lastIndex) { [EOL]     if (str == null || searchStr == null || ordinal <= 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (searchStr.length() == 0) { [EOL]         return lastIndex ? str.length() : 0; [EOL]     } [EOL]     int found = 0; [EOL]     int index = lastIndex ? str.length() : INDEX_NOT_FOUND; [EOL]     do { [EOL]         if (lastIndex) { [EOL]             index = CharSequenceUtils.lastIndexOf(str, searchStr, index - 1); [EOL]         } else { [EOL]             index = CharSequenceUtils.indexOf(str, searchStr, index + 1); [EOL]         } [EOL]         if (index < 0) { [EOL]             return index; [EOL]         } [EOL]         found++; [EOL]     } while (found < ordinal); [EOL]     return index; [EOL] }
private static int ordinalIndexOf(final CharSequence str, final CharSequence searchStr, final int ordinal, final boolean lastIndex) { [EOL]     if (str == null || searchStr == null || ordinal <= 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (searchStr.length() == 0) { [EOL]         return lastIndex ? str.length() : 0; [EOL]     } [EOL]     int found = 0; [EOL]     int index = lastIndex ? str.length() : INDEX_NOT_FOUND; [EOL]     do { [EOL]         if (lastIndex) { [EOL]             index = CharSequenceUtils.lastIndexOf(str, searchStr, index - 1); [EOL]         } else { [EOL]             index = CharSequenceUtils.indexOf(str, searchStr, index + 1); [EOL]         } [EOL]         if (index < 0) { [EOL]             return index; [EOL]         } [EOL]         found++; [EOL]     } while (found < ordinal); [EOL]     return index; [EOL] }
public static int lastOrdinalIndexOf(final CharSequence str, final CharSequence searchStr, final int ordinal) { [EOL]     return ordinalIndexOf(str, searchStr, ordinal, true); [EOL] }
public static int lastOrdinalIndexOf(final CharSequence str, final CharSequence searchStr, final int ordinal) { [EOL]     return ordinalIndexOf(str, searchStr, ordinal, true); [EOL] }
public static int lastOrdinalIndexOf(final CharSequence str, final CharSequence searchStr, final int ordinal) { [EOL]     return ordinalIndexOf(str, searchStr, ordinal, true); [EOL] }
public static int lastOrdinalIndexOf(final CharSequence str, final CharSequence searchStr, final int ordinal) { [EOL]     return ordinalIndexOf(str, searchStr, ordinal, true); [EOL] }
public static int lastOrdinalIndexOf(final CharSequence str, final CharSequence searchStr, final int ordinal) { [EOL]     return ordinalIndexOf(str, searchStr, ordinal, true); [EOL] }
public static int lastOrdinalIndexOf(final CharSequence str, final CharSequence searchStr, final int ordinal) { [EOL]     return ordinalIndexOf(str, searchStr, ordinal, true); [EOL] }
public static int lastOrdinalIndexOf(final CharSequence str, final CharSequence searchStr, final int ordinal) { [EOL]     return ordinalIndexOf(str, searchStr, ordinal, true); [EOL] }
public static int lastIndexOfIgnoreCase(final CharSequence str, final CharSequence searchStr, int startPos) { [EOL]     if (str == null || searchStr == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startPos > str.length() - searchStr.length()) { [EOL]         startPos = str.length() - searchStr.length(); [EOL]     } [EOL]     if (startPos < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (searchStr.length() == 0) { [EOL]         return startPos; [EOL]     } [EOL]     for (int i = startPos; i >= 0; i--) { [EOL]         if (CharSequenceUtils.regionMatches(str, true, i, searchStr, 0, searchStr.length())) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) { [EOL]     if (seq == null || searchSeq == null) { [EOL]         return false; [EOL]     } [EOL]     return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0; [EOL] }
public static boolean containsWhitespace(final CharSequence seq) { [EOL]     if (isEmpty(seq)) { [EOL]         return false; [EOL]     } [EOL]     final int strLen = seq.length(); [EOL]     for (int i = 0; i < strLen; i++) { [EOL]         if (Character.isWhitespace(seq.charAt(i))) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public static boolean containsWhitespace(final CharSequence seq) { [EOL]     if (isEmpty(seq)) { [EOL]         return false; [EOL]     } [EOL]     final int strLen = seq.length(); [EOL]     for (int i = 0; i < strLen; i++) { [EOL]         if (Character.isWhitespace(seq.charAt(i))) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public static boolean containsWhitespace(final CharSequence seq) { [EOL]     if (isEmpty(seq)) { [EOL]         return false; [EOL]     } [EOL]     final int strLen = seq.length(); [EOL]     for (int i = 0; i < strLen; i++) { [EOL]         if (Character.isWhitespace(seq.charAt(i))) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public static boolean containsWhitespace(final CharSequence seq) { [EOL]     if (isEmpty(seq)) { [EOL]         return false; [EOL]     } [EOL]     final int strLen = seq.length(); [EOL]     for (int i = 0; i < strLen; i++) { [EOL]         if (Character.isWhitespace(seq.charAt(i))) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public static int indexOfAnyBut(final CharSequence cs, final char... searchChars) { [EOL]     if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     final int csLen = cs.length(); [EOL]     final int csLast = csLen - 1; [EOL]     final int searchLen = searchChars.length; [EOL]     final int searchLast = searchLen - 1; [EOL]     outer: for (int i = 0; i < csLen; i++) { [EOL]         final char ch = cs.charAt(i); [EOL]         for (int j = 0; j < searchLen; j++) { [EOL]             if (searchChars[j] == ch) { [EOL]                 if (i < csLast && j < searchLast && Character.isHighSurrogate(ch)) { [EOL]                     if (searchChars[j + 1] == cs.charAt(i + 1)) { [EOL]                         continue outer; [EOL]                     } [EOL]                 } else { [EOL]                     continue outer; [EOL]                 } [EOL]             } [EOL]         } [EOL]         return i; [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int indexOfAnyBut(final CharSequence cs, final char... searchChars) { [EOL]     if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     final int csLen = cs.length(); [EOL]     final int csLast = csLen - 1; [EOL]     final int searchLen = searchChars.length; [EOL]     final int searchLast = searchLen - 1; [EOL]     outer: for (int i = 0; i < csLen; i++) { [EOL]         final char ch = cs.charAt(i); [EOL]         for (int j = 0; j < searchLen; j++) { [EOL]             if (searchChars[j] == ch) { [EOL]                 if (i < csLast && j < searchLast && Character.isHighSurrogate(ch)) { [EOL]                     if (searchChars[j + 1] == cs.charAt(i + 1)) { [EOL]                         continue outer; [EOL]                     } [EOL]                 } else { [EOL]                     continue outer; [EOL]                 } [EOL]             } [EOL]         } [EOL]         return i; [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int lastIndexOfAny(final CharSequence str, final CharSequence... searchStrs) { [EOL]     if (str == null || searchStrs == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     final int sz = searchStrs.length; [EOL]     int ret = INDEX_NOT_FOUND; [EOL]     int tmp = 0; [EOL]     for (int i = 0; i < sz; i++) { [EOL]         final CharSequence search = searchStrs[i]; [EOL]         if (search == null) { [EOL]             continue; [EOL]         } [EOL]         tmp = CharSequenceUtils.lastIndexOf(str, search, str.length()); [EOL]         if (tmp > ret) { [EOL]             ret = tmp; [EOL]         } [EOL]     } [EOL]     return ret; [EOL] }
public static String mid(final String str, int pos, final int len) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (len < 0 || pos > str.length()) { [EOL]         return EMPTY; [EOL]     } [EOL]     if (pos < 0) { [EOL]         pos = 0; [EOL]     } [EOL]     if (str.length() <= pos + len) { [EOL]         return str.substring(pos); [EOL]     } [EOL]     return str.substring(pos, pos + len); [EOL] }
public static String mid(final String str, int pos, final int len) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (len < 0 || pos > str.length()) { [EOL]         return EMPTY; [EOL]     } [EOL]     if (pos < 0) { [EOL]         pos = 0; [EOL]     } [EOL]     if (str.length() <= pos + len) { [EOL]         return str.substring(pos); [EOL]     } [EOL]     return str.substring(pos, pos + len); [EOL] }
public static String mid(final String str, int pos, final int len) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (len < 0 || pos > str.length()) { [EOL]         return EMPTY; [EOL]     } [EOL]     if (pos < 0) { [EOL]         pos = 0; [EOL]     } [EOL]     if (str.length() <= pos + len) { [EOL]         return str.substring(pos); [EOL]     } [EOL]     return str.substring(pos, pos + len); [EOL] }
public static String mid(final String str, int pos, final int len) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (len < 0 || pos > str.length()) { [EOL]         return EMPTY; [EOL]     } [EOL]     if (pos < 0) { [EOL]         pos = 0; [EOL]     } [EOL]     if (str.length() <= pos + len) { [EOL]         return str.substring(pos); [EOL]     } [EOL]     return str.substring(pos, pos + len); [EOL] }
public static String mid(final String str, int pos, final int len) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (len < 0 || pos > str.length()) { [EOL]         return EMPTY; [EOL]     } [EOL]     if (pos < 0) { [EOL]         pos = 0; [EOL]     } [EOL]     if (str.length() <= pos + len) { [EOL]         return str.substring(pos); [EOL]     } [EOL]     return str.substring(pos, pos + len); [EOL] }
public static String mid(final String str, int pos, final int len) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (len < 0 || pos > str.length()) { [EOL]         return EMPTY; [EOL]     } [EOL]     if (pos < 0) { [EOL]         pos = 0; [EOL]     } [EOL]     if (str.length() <= pos + len) { [EOL]         return str.substring(pos); [EOL]     } [EOL]     return str.substring(pos, pos + len); [EOL] }
public static String substringBefore(final String str, final String separator) { [EOL]     if (isEmpty(str) || separator == null) { [EOL]         return str; [EOL]     } [EOL]     if (separator.isEmpty()) { [EOL]         return EMPTY; [EOL]     } [EOL]     final int pos = str.indexOf(separator); [EOL]     if (pos == INDEX_NOT_FOUND) { [EOL]         return str; [EOL]     } [EOL]     return str.substring(0, pos); [EOL] }
public static String substringBefore(final String str, final String separator) { [EOL]     if (isEmpty(str) || separator == null) { [EOL]         return str; [EOL]     } [EOL]     if (separator.isEmpty()) { [EOL]         return EMPTY; [EOL]     } [EOL]     final int pos = str.indexOf(separator); [EOL]     if (pos == INDEX_NOT_FOUND) { [EOL]         return str; [EOL]     } [EOL]     return str.substring(0, pos); [EOL] }
public static String substringBefore(final String str, final String separator) { [EOL]     if (isEmpty(str) || separator == null) { [EOL]         return str; [EOL]     } [EOL]     if (separator.isEmpty()) { [EOL]         return EMPTY; [EOL]     } [EOL]     final int pos = str.indexOf(separator); [EOL]     if (pos == INDEX_NOT_FOUND) { [EOL]         return str; [EOL]     } [EOL]     return str.substring(0, pos); [EOL] }
public static String substringBefore(final String str, final String separator) { [EOL]     if (isEmpty(str) || separator == null) { [EOL]         return str; [EOL]     } [EOL]     if (separator.isEmpty()) { [EOL]         return EMPTY; [EOL]     } [EOL]     final int pos = str.indexOf(separator); [EOL]     if (pos == INDEX_NOT_FOUND) { [EOL]         return str; [EOL]     } [EOL]     return str.substring(0, pos); [EOL] }
public static String substringBefore(final String str, final String separator) { [EOL]     if (isEmpty(str) || separator == null) { [EOL]         return str; [EOL]     } [EOL]     if (separator.isEmpty()) { [EOL]         return EMPTY; [EOL]     } [EOL]     final int pos = str.indexOf(separator); [EOL]     if (pos == INDEX_NOT_FOUND) { [EOL]         return str; [EOL]     } [EOL]     return str.substring(0, pos); [EOL] }
public static String[] split(final String str, final String separatorChars) { [EOL]     return splitWorker(str, separatorChars, -1, false); [EOL] }
public static String[] split(final String str, final String separatorChars) { [EOL]     return splitWorker(str, separatorChars, -1, false); [EOL] }
public static String[] split(final String str, final String separatorChars) { [EOL]     return splitWorker(str, separatorChars, -1, false); [EOL] }
public static String[] split(final String str, final String separatorChars) { [EOL]     return splitWorker(str, separatorChars, -1, false); [EOL] }
public static String[] split(final String str, final String separatorChars) { [EOL]     return splitWorker(str, separatorChars, -1, false); [EOL] }
public static String[] split(final String str, final String separatorChars) { [EOL]     return splitWorker(str, separatorChars, -1, false); [EOL] }
public static String[] split(final String str, final String separatorChars, final int max) { [EOL]     return splitWorker(str, separatorChars, max, false); [EOL] }
public static String[] split(final String str, final String separatorChars, final int max) { [EOL]     return splitWorker(str, separatorChars, max, false); [EOL] }
public static String[] split(final String str, final String separatorChars, final int max) { [EOL]     return splitWorker(str, separatorChars, max, false); [EOL] }
public static String[] split(final String str, final String separatorChars, final int max) { [EOL]     return splitWorker(str, separatorChars, max, false); [EOL] }
public static String[] split(final String str, final String separatorChars, final int max) { [EOL]     return splitWorker(str, separatorChars, max, false); [EOL] }
public static String[] split(final String str, final String separatorChars, final int max) { [EOL]     return splitWorker(str, separatorChars, max, false); [EOL] }
public static String[] splitByWholeSeparator(final String str, final String separator, final int max) { [EOL]     return splitByWholeSeparatorWorker(str, separator, max, false); [EOL] }
public static String[] splitByWholeSeparator(final String str, final String separator, final int max) { [EOL]     return splitByWholeSeparatorWorker(str, separator, max, false); [EOL] }
public static String[] splitByWholeSeparator(final String str, final String separator, final int max) { [EOL]     return splitByWholeSeparatorWorker(str, separator, max, false); [EOL] }
public static String[] splitByWholeSeparator(final String str, final String separator, final int max) { [EOL]     return splitByWholeSeparatorWorker(str, separator, max, false); [EOL] }
public static String[] splitByWholeSeparator(final String str, final String separator, final int max) { [EOL]     return splitByWholeSeparatorWorker(str, separator, max, false); [EOL] }
public static String[] splitByWholeSeparator(final String str, final String separator, final int max) { [EOL]     return splitByWholeSeparatorWorker(str, separator, max, false); [EOL] }
private static String[] splitByWholeSeparatorWorker(final String str, final String separator, final int max, final boolean preserveAllTokens) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len == 0) { [EOL]         return ArrayUtils.EMPTY_STRING_ARRAY; [EOL]     } [EOL]     if (separator == null || EMPTY.equals(separator)) { [EOL]         return splitWorker(str, null, max, preserveAllTokens); [EOL]     } [EOL]     final int separatorLength = separator.length(); [EOL]     final ArrayList<String> substrings = new ArrayList<String>(); [EOL]     int numberOfSubstrings = 0; [EOL]     int beg = 0; [EOL]     int end = 0; [EOL]     while (end < len) { [EOL]         end = str.indexOf(separator, beg); [EOL]         if (end > -1) { [EOL]             if (end > beg) { [EOL]                 numberOfSubstrings += 1; [EOL]                 if (numberOfSubstrings == max) { [EOL]                     end = len; [EOL]                     substrings.add(str.substring(beg)); [EOL]                 } else { [EOL]                     substrings.add(str.substring(beg, end)); [EOL]                     beg = end + separatorLength; [EOL]                 } [EOL]             } else { [EOL]                 if (preserveAllTokens) { [EOL]                     numberOfSubstrings += 1; [EOL]                     if (numberOfSubstrings == max) { [EOL]                         end = len; [EOL]                         substrings.add(str.substring(beg)); [EOL]                     } else { [EOL]                         substrings.add(EMPTY); [EOL]                     } [EOL]                 } [EOL]                 beg = end + separatorLength; [EOL]             } [EOL]         } else { [EOL]             substrings.add(str.substring(beg)); [EOL]             end = len; [EOL]         } [EOL]     } [EOL]     return substrings.toArray(new String[substrings.size()]); [EOL] }
public static String[] splitPreserveAllTokens(final String str, final String separatorChars) { [EOL]     return splitWorker(str, separatorChars, -1, true); [EOL] }
public static String[] splitPreserveAllTokens(final String str, final String separatorChars) { [EOL]     return splitWorker(str, separatorChars, -1, true); [EOL] }
public static String[] splitPreserveAllTokens(final String str, final String separatorChars) { [EOL]     return splitWorker(str, separatorChars, -1, true); [EOL] }
public static String[] splitPreserveAllTokens(final String str, final String separatorChars) { [EOL]     return splitWorker(str, separatorChars, -1, true); [EOL] }
public static String[] splitPreserveAllTokens(final String str, final String separatorChars) { [EOL]     return splitWorker(str, separatorChars, -1, true); [EOL] }
public static String[] splitPreserveAllTokens(final String str, final String separatorChars) { [EOL]     return splitWorker(str, separatorChars, -1, true); [EOL] }
public static String[] splitPreserveAllTokens(final String str, final String separatorChars, final int max) { [EOL]     return splitWorker(str, separatorChars, max, true); [EOL] }
public static String[] splitPreserveAllTokens(final String str, final String separatorChars, final int max) { [EOL]     return splitWorker(str, separatorChars, max, true); [EOL] }
public static String[] splitPreserveAllTokens(final String str, final String separatorChars, final int max) { [EOL]     return splitWorker(str, separatorChars, max, true); [EOL] }
public static String[] splitPreserveAllTokens(final String str, final String separatorChars, final int max) { [EOL]     return splitWorker(str, separatorChars, max, true); [EOL] }
public static String[] splitPreserveAllTokens(final String str, final String separatorChars, final int max) { [EOL]     return splitWorker(str, separatorChars, max, true); [EOL] }
public static String[] splitPreserveAllTokens(final String str, final String separatorChars, final int max) { [EOL]     return splitWorker(str, separatorChars, max, true); [EOL] }
public static String[] splitPreserveAllTokens(final String str, final String separatorChars, final int max) { [EOL]     return splitWorker(str, separatorChars, max, true); [EOL] }
public static String[] splitPreserveAllTokens(final String str, final String separatorChars, final int max) { [EOL]     return splitWorker(str, separatorChars, max, true); [EOL] }
private static String[] splitWorker(final String str, final String separatorChars, final int max, final boolean preserveAllTokens) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len == 0) { [EOL]         return ArrayUtils.EMPTY_STRING_ARRAY; [EOL]     } [EOL]     final List<String> list = new ArrayList<String>(); [EOL]     int sizePlus1 = 1; [EOL]     int i = 0, start = 0; [EOL]     boolean match = false; [EOL]     boolean lastMatch = false; [EOL]     if (separatorChars == null) { [EOL]         while (i < len) { [EOL]             if (Character.isWhitespace(str.charAt(i))) { [EOL]                 if (match || preserveAllTokens) { [EOL]                     lastMatch = true; [EOL]                     if (sizePlus1++ == max) { [EOL]                         i = len; [EOL]                         lastMatch = false; [EOL]                     } [EOL]                     list.add(str.substring(start, i)); [EOL]                     match = false; [EOL]                 } [EOL]                 start = ++i; [EOL]                 continue; [EOL]             } [EOL]             lastMatch = false; [EOL]             match = true; [EOL]             i++; [EOL]         } [EOL]     } else if (separatorChars.length() == 1) { [EOL]         final char sep = separatorChars.charAt(0); [EOL]         while (i < len) { [EOL]             if (str.charAt(i) == sep) { [EOL]                 if (match || preserveAllTokens) { [EOL]                     lastMatch = true; [EOL]                     if (sizePlus1++ == max) { [EOL]                         i = len; [EOL]                         lastMatch = false; [EOL]                     } [EOL]                     list.add(str.substring(start, i)); [EOL]                     match = false; [EOL]                 } [EOL]                 start = ++i; [EOL]                 continue; [EOL]             } [EOL]             lastMatch = false; [EOL]             match = true; [EOL]             i++; [EOL]         } [EOL]     } else { [EOL]         while (i < len) { [EOL]             if (separatorChars.indexOf(str.charAt(i)) >= 0) { [EOL]                 if (match || preserveAllTokens) { [EOL]                     lastMatch = true; [EOL]                     if (sizePlus1++ == max) { [EOL]                         i = len; [EOL]                         lastMatch = false; [EOL]                     } [EOL]                     list.add(str.substring(start, i)); [EOL]                     match = false; [EOL]                 } [EOL]                 start = ++i; [EOL]                 continue; [EOL]             } [EOL]             lastMatch = false; [EOL]             match = true; [EOL]             i++; [EOL]         } [EOL]     } [EOL]     if (match || preserveAllTokens && lastMatch) { [EOL]         list.add(str.substring(start, i)); [EOL]     } [EOL]     return list.toArray(new String[list.size()]); [EOL] }
private static String[] splitWorker(final String str, final String separatorChars, final int max, final boolean preserveAllTokens) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len == 0) { [EOL]         return ArrayUtils.EMPTY_STRING_ARRAY; [EOL]     } [EOL]     final List<String> list = new ArrayList<String>(); [EOL]     int sizePlus1 = 1; [EOL]     int i = 0, start = 0; [EOL]     boolean match = false; [EOL]     boolean lastMatch = false; [EOL]     if (separatorChars == null) { [EOL]         while (i < len) { [EOL]             if (Character.isWhitespace(str.charAt(i))) { [EOL]                 if (match || preserveAllTokens) { [EOL]                     lastMatch = true; [EOL]                     if (sizePlus1++ == max) { [EOL]                         i = len; [EOL]                         lastMatch = false; [EOL]                     } [EOL]                     list.add(str.substring(start, i)); [EOL]                     match = false; [EOL]                 } [EOL]                 start = ++i; [EOL]                 continue; [EOL]             } [EOL]             lastMatch = false; [EOL]             match = true; [EOL]             i++; [EOL]         } [EOL]     } else if (separatorChars.length() == 1) { [EOL]         final char sep = separatorChars.charAt(0); [EOL]         while (i < len) { [EOL]             if (str.charAt(i) == sep) { [EOL]                 if (match || preserveAllTokens) { [EOL]                     lastMatch = true; [EOL]                     if (sizePlus1++ == max) { [EOL]                         i = len; [EOL]                         lastMatch = false; [EOL]                     } [EOL]                     list.add(str.substring(start, i)); [EOL]                     match = false; [EOL]                 } [EOL]                 start = ++i; [EOL]                 continue; [EOL]             } [EOL]             lastMatch = false; [EOL]             match = true; [EOL]             i++; [EOL]         } [EOL]     } else { [EOL]         while (i < len) { [EOL]             if (separatorChars.indexOf(str.charAt(i)) >= 0) { [EOL]                 if (match || preserveAllTokens) { [EOL]                     lastMatch = true; [EOL]                     if (sizePlus1++ == max) { [EOL]                         i = len; [EOL]                         lastMatch = false; [EOL]                     } [EOL]                     list.add(str.substring(start, i)); [EOL]                     match = false; [EOL]                 } [EOL]                 start = ++i; [EOL]                 continue; [EOL]             } [EOL]             lastMatch = false; [EOL]             match = true; [EOL]             i++; [EOL]         } [EOL]     } [EOL]     if (match || preserveAllTokens && lastMatch) { [EOL]         list.add(str.substring(start, i)); [EOL]     } [EOL]     return list.toArray(new String[list.size()]); [EOL] }
private static String[] splitWorker(final String str, final String separatorChars, final int max, final boolean preserveAllTokens) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len == 0) { [EOL]         return ArrayUtils.EMPTY_STRING_ARRAY; [EOL]     } [EOL]     final List<String> list = new ArrayList<String>(); [EOL]     int sizePlus1 = 1; [EOL]     int i = 0, start = 0; [EOL]     boolean match = false; [EOL]     boolean lastMatch = false; [EOL]     if (separatorChars == null) { [EOL]         while (i < len) { [EOL]             if (Character.isWhitespace(str.charAt(i))) { [EOL]                 if (match || preserveAllTokens) { [EOL]                     lastMatch = true; [EOL]                     if (sizePlus1++ == max) { [EOL]                         i = len; [EOL]                         lastMatch = false; [EOL]                     } [EOL]                     list.add(str.substring(start, i)); [EOL]                     match = false; [EOL]                 } [EOL]                 start = ++i; [EOL]                 continue; [EOL]             } [EOL]             lastMatch = false; [EOL]             match = true; [EOL]             i++; [EOL]         } [EOL]     } else if (separatorChars.length() == 1) { [EOL]         final char sep = separatorChars.charAt(0); [EOL]         while (i < len) { [EOL]             if (str.charAt(i) == sep) { [EOL]                 if (match || preserveAllTokens) { [EOL]                     lastMatch = true; [EOL]                     if (sizePlus1++ == max) { [EOL]                         i = len; [EOL]                         lastMatch = false; [EOL]                     } [EOL]                     list.add(str.substring(start, i)); [EOL]                     match = false; [EOL]                 } [EOL]                 start = ++i; [EOL]                 continue; [EOL]             } [EOL]             lastMatch = false; [EOL]             match = true; [EOL]             i++; [EOL]         } [EOL]     } else { [EOL]         while (i < len) { [EOL]             if (separatorChars.indexOf(str.charAt(i)) >= 0) { [EOL]                 if (match || preserveAllTokens) { [EOL]                     lastMatch = true; [EOL]                     if (sizePlus1++ == max) { [EOL]                         i = len; [EOL]                         lastMatch = false; [EOL]                     } [EOL]                     list.add(str.substring(start, i)); [EOL]                     match = false; [EOL]                 } [EOL]                 start = ++i; [EOL]                 continue; [EOL]             } [EOL]             lastMatch = false; [EOL]             match = true; [EOL]             i++; [EOL]         } [EOL]     } [EOL]     if (match || preserveAllTokens && lastMatch) { [EOL]         list.add(str.substring(start, i)); [EOL]     } [EOL]     return list.toArray(new String[list.size()]); [EOL] }
private static String[] splitWorker(final String str, final String separatorChars, final int max, final boolean preserveAllTokens) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len == 0) { [EOL]         return ArrayUtils.EMPTY_STRING_ARRAY; [EOL]     } [EOL]     final List<String> list = new ArrayList<String>(); [EOL]     int sizePlus1 = 1; [EOL]     int i = 0, start = 0; [EOL]     boolean match = false; [EOL]     boolean lastMatch = false; [EOL]     if (separatorChars == null) { [EOL]         while (i < len) { [EOL]             if (Character.isWhitespace(str.charAt(i))) { [EOL]                 if (match || preserveAllTokens) { [EOL]                     lastMatch = true; [EOL]                     if (sizePlus1++ == max) { [EOL]                         i = len; [EOL]                         lastMatch = false; [EOL]                     } [EOL]                     list.add(str.substring(start, i)); [EOL]                     match = false; [EOL]                 } [EOL]                 start = ++i; [EOL]                 continue; [EOL]             } [EOL]             lastMatch = false; [EOL]             match = true; [EOL]             i++; [EOL]         } [EOL]     } else if (separatorChars.length() == 1) { [EOL]         final char sep = separatorChars.charAt(0); [EOL]         while (i < len) { [EOL]             if (str.charAt(i) == sep) { [EOL]                 if (match || preserveAllTokens) { [EOL]                     lastMatch = true; [EOL]                     if (sizePlus1++ == max) { [EOL]                         i = len; [EOL]                         lastMatch = false; [EOL]                     } [EOL]                     list.add(str.substring(start, i)); [EOL]                     match = false; [EOL]                 } [EOL]                 start = ++i; [EOL]                 continue; [EOL]             } [EOL]             lastMatch = false; [EOL]             match = true; [EOL]             i++; [EOL]         } [EOL]     } else { [EOL]         while (i < len) { [EOL]             if (separatorChars.indexOf(str.charAt(i)) >= 0) { [EOL]                 if (match || preserveAllTokens) { [EOL]                     lastMatch = true; [EOL]                     if (sizePlus1++ == max) { [EOL]                         i = len; [EOL]                         lastMatch = false; [EOL]                     } [EOL]                     list.add(str.substring(start, i)); [EOL]                     match = false; [EOL]                 } [EOL]                 start = ++i; [EOL]                 continue; [EOL]             } [EOL]             lastMatch = false; [EOL]             match = true; [EOL]             i++; [EOL]         } [EOL]     } [EOL]     if (match || preserveAllTokens && lastMatch) { [EOL]         list.add(str.substring(start, i)); [EOL]     } [EOL]     return list.toArray(new String[list.size()]); [EOL] }
private static String[] splitWorker(final String str, final String separatorChars, final int max, final boolean preserveAllTokens) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len == 0) { [EOL]         return ArrayUtils.EMPTY_STRING_ARRAY; [EOL]     } [EOL]     final List<String> list = new ArrayList<String>(); [EOL]     int sizePlus1 = 1; [EOL]     int i = 0, start = 0; [EOL]     boolean match = false; [EOL]     boolean lastMatch = false; [EOL]     if (separatorChars == null) { [EOL]         while (i < len) { [EOL]             if (Character.isWhitespace(str.charAt(i))) { [EOL]                 if (match || preserveAllTokens) { [EOL]                     lastMatch = true; [EOL]                     if (sizePlus1++ == max) { [EOL]                         i = len; [EOL]                         lastMatch = false; [EOL]                     } [EOL]                     list.add(str.substring(start, i)); [EOL]                     match = false; [EOL]                 } [EOL]                 start = ++i; [EOL]                 continue; [EOL]             } [EOL]             lastMatch = false; [EOL]             match = true; [EOL]             i++; [EOL]         } [EOL]     } else if (separatorChars.length() == 1) { [EOL]         final char sep = separatorChars.charAt(0); [EOL]         while (i < len) { [EOL]             if (str.charAt(i) == sep) { [EOL]                 if (match || preserveAllTokens) { [EOL]                     lastMatch = true; [EOL]                     if (sizePlus1++ == max) { [EOL]                         i = len; [EOL]                         lastMatch = false; [EOL]                     } [EOL]                     list.add(str.substring(start, i)); [EOL]                     match = false; [EOL]                 } [EOL]                 start = ++i; [EOL]                 continue; [EOL]             } [EOL]             lastMatch = false; [EOL]             match = true; [EOL]             i++; [EOL]         } [EOL]     } else { [EOL]         while (i < len) { [EOL]             if (separatorChars.indexOf(str.charAt(i)) >= 0) { [EOL]                 if (match || preserveAllTokens) { [EOL]                     lastMatch = true; [EOL]                     if (sizePlus1++ == max) { [EOL]                         i = len; [EOL]                         lastMatch = false; [EOL]                     } [EOL]                     list.add(str.substring(start, i)); [EOL]                     match = false; [EOL]                 } [EOL]                 start = ++i; [EOL]                 continue; [EOL]             } [EOL]             lastMatch = false; [EOL]             match = true; [EOL]             i++; [EOL]         } [EOL]     } [EOL]     if (match || preserveAllTokens && lastMatch) { [EOL]         list.add(str.substring(start, i)); [EOL]     } [EOL]     return list.toArray(new String[list.size()]); [EOL] }
private static String[] splitWorker(final String str, final String separatorChars, final int max, final boolean preserveAllTokens) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len == 0) { [EOL]         return ArrayUtils.EMPTY_STRING_ARRAY; [EOL]     } [EOL]     final List<String> list = new ArrayList<String>(); [EOL]     int sizePlus1 = 1; [EOL]     int i = 0, start = 0; [EOL]     boolean match = false; [EOL]     boolean lastMatch = false; [EOL]     if (separatorChars == null) { [EOL]         while (i < len) { [EOL]             if (Character.isWhitespace(str.charAt(i))) { [EOL]                 if (match || preserveAllTokens) { [EOL]                     lastMatch = true; [EOL]                     if (sizePlus1++ == max) { [EOL]                         i = len; [EOL]                         lastMatch = false; [EOL]                     } [EOL]                     list.add(str.substring(start, i)); [EOL]                     match = false; [EOL]                 } [EOL]                 start = ++i; [EOL]                 continue; [EOL]             } [EOL]             lastMatch = false; [EOL]             match = true; [EOL]             i++; [EOL]         } [EOL]     } else if (separatorChars.length() == 1) { [EOL]         final char sep = separatorChars.charAt(0); [EOL]         while (i < len) { [EOL]             if (str.charAt(i) == sep) { [EOL]                 if (match || preserveAllTokens) { [EOL]                     lastMatch = true; [EOL]                     if (sizePlus1++ == max) { [EOL]                         i = len; [EOL]                         lastMatch = false; [EOL]                     } [EOL]                     list.add(str.substring(start, i)); [EOL]                     match = false; [EOL]                 } [EOL]                 start = ++i; [EOL]                 continue; [EOL]             } [EOL]             lastMatch = false; [EOL]             match = true; [EOL]             i++; [EOL]         } [EOL]     } else { [EOL]         while (i < len) { [EOL]             if (separatorChars.indexOf(str.charAt(i)) >= 0) { [EOL]                 if (match || preserveAllTokens) { [EOL]                     lastMatch = true; [EOL]                     if (sizePlus1++ == max) { [EOL]                         i = len; [EOL]                         lastMatch = false; [EOL]                     } [EOL]                     list.add(str.substring(start, i)); [EOL]                     match = false; [EOL]                 } [EOL]                 start = ++i; [EOL]                 continue; [EOL]             } [EOL]             lastMatch = false; [EOL]             match = true; [EOL]             i++; [EOL]         } [EOL]     } [EOL]     if (match || preserveAllTokens && lastMatch) { [EOL]         list.add(str.substring(start, i)); [EOL]     } [EOL]     return list.toArray(new String[list.size()]); [EOL] }
private static String[] splitWorker(final String str, final String separatorChars, final int max, final boolean preserveAllTokens) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len == 0) { [EOL]         return ArrayUtils.EMPTY_STRING_ARRAY; [EOL]     } [EOL]     final List<String> list = new ArrayList<String>(); [EOL]     int sizePlus1 = 1; [EOL]     int i = 0, start = 0; [EOL]     boolean match = false; [EOL]     boolean lastMatch = false; [EOL]     if (separatorChars == null) { [EOL]         while (i < len) { [EOL]             if (Character.isWhitespace(str.charAt(i))) { [EOL]                 if (match || preserveAllTokens) { [EOL]                     lastMatch = true; [EOL]                     if (sizePlus1++ == max) { [EOL]                         i = len; [EOL]                         lastMatch = false; [EOL]                     } [EOL]                     list.add(str.substring(start, i)); [EOL]                     match = false; [EOL]                 } [EOL]                 start = ++i; [EOL]                 continue; [EOL]             } [EOL]             lastMatch = false; [EOL]             match = true; [EOL]             i++; [EOL]         } [EOL]     } else if (separatorChars.length() == 1) { [EOL]         final char sep = separatorChars.charAt(0); [EOL]         while (i < len) { [EOL]             if (str.charAt(i) == sep) { [EOL]                 if (match || preserveAllTokens) { [EOL]                     lastMatch = true; [EOL]                     if (sizePlus1++ == max) { [EOL]                         i = len; [EOL]                         lastMatch = false; [EOL]                     } [EOL]                     list.add(str.substring(start, i)); [EOL]                     match = false; [EOL]                 } [EOL]                 start = ++i; [EOL]                 continue; [EOL]             } [EOL]             lastMatch = false; [EOL]             match = true; [EOL]             i++; [EOL]         } [EOL]     } else { [EOL]         while (i < len) { [EOL]             if (separatorChars.indexOf(str.charAt(i)) >= 0) { [EOL]                 if (match || preserveAllTokens) { [EOL]                     lastMatch = true; [EOL]                     if (sizePlus1++ == max) { [EOL]                         i = len; [EOL]                         lastMatch = false; [EOL]                     } [EOL]                     list.add(str.substring(start, i)); [EOL]                     match = false; [EOL]                 } [EOL]                 start = ++i; [EOL]                 continue; [EOL]             } [EOL]             lastMatch = false; [EOL]             match = true; [EOL]             i++; [EOL]         } [EOL]     } [EOL]     if (match || preserveAllTokens && lastMatch) { [EOL]         list.add(str.substring(start, i)); [EOL]     } [EOL]     return list.toArray(new String[list.size()]); [EOL] }
private static String[] splitWorker(final String str, final String separatorChars, final int max, final boolean preserveAllTokens) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len == 0) { [EOL]         return ArrayUtils.EMPTY_STRING_ARRAY; [EOL]     } [EOL]     final List<String> list = new ArrayList<String>(); [EOL]     int sizePlus1 = 1; [EOL]     int i = 0, start = 0; [EOL]     boolean match = false; [EOL]     boolean lastMatch = false; [EOL]     if (separatorChars == null) { [EOL]         while (i < len) { [EOL]             if (Character.isWhitespace(str.charAt(i))) { [EOL]                 if (match || preserveAllTokens) { [EOL]                     lastMatch = true; [EOL]                     if (sizePlus1++ == max) { [EOL]                         i = len; [EOL]                         lastMatch = false; [EOL]                     } [EOL]                     list.add(str.substring(start, i)); [EOL]                     match = false; [EOL]                 } [EOL]                 start = ++i; [EOL]                 continue; [EOL]             } [EOL]             lastMatch = false; [EOL]             match = true; [EOL]             i++; [EOL]         } [EOL]     } else if (separatorChars.length() == 1) { [EOL]         final char sep = separatorChars.charAt(0); [EOL]         while (i < len) { [EOL]             if (str.charAt(i) == sep) { [EOL]                 if (match || preserveAllTokens) { [EOL]                     lastMatch = true; [EOL]                     if (sizePlus1++ == max) { [EOL]                         i = len; [EOL]                         lastMatch = false; [EOL]                     } [EOL]                     list.add(str.substring(start, i)); [EOL]                     match = false; [EOL]                 } [EOL]                 start = ++i; [EOL]                 continue; [EOL]             } [EOL]             lastMatch = false; [EOL]             match = true; [EOL]             i++; [EOL]         } [EOL]     } else { [EOL]         while (i < len) { [EOL]             if (separatorChars.indexOf(str.charAt(i)) >= 0) { [EOL]                 if (match || preserveAllTokens) { [EOL]                     lastMatch = true; [EOL]                     if (sizePlus1++ == max) { [EOL]                         i = len; [EOL]                         lastMatch = false; [EOL]                     } [EOL]                     list.add(str.substring(start, i)); [EOL]                     match = false; [EOL]                 } [EOL]                 start = ++i; [EOL]                 continue; [EOL]             } [EOL]             lastMatch = false; [EOL]             match = true; [EOL]             i++; [EOL]         } [EOL]     } [EOL]     if (match || preserveAllTokens && lastMatch) { [EOL]         list.add(str.substring(start, i)); [EOL]     } [EOL]     return list.toArray(new String[list.size()]); [EOL] }
private static String[] splitWorker(final String str, final String separatorChars, final int max, final boolean preserveAllTokens) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len == 0) { [EOL]         return ArrayUtils.EMPTY_STRING_ARRAY; [EOL]     } [EOL]     final List<String> list = new ArrayList<String>(); [EOL]     int sizePlus1 = 1; [EOL]     int i = 0, start = 0; [EOL]     boolean match = false; [EOL]     boolean lastMatch = false; [EOL]     if (separatorChars == null) { [EOL]         while (i < len) { [EOL]             if (Character.isWhitespace(str.charAt(i))) { [EOL]                 if (match || preserveAllTokens) { [EOL]                     lastMatch = true; [EOL]                     if (sizePlus1++ == max) { [EOL]                         i = len; [EOL]                         lastMatch = false; [EOL]                     } [EOL]                     list.add(str.substring(start, i)); [EOL]                     match = false; [EOL]                 } [EOL]                 start = ++i; [EOL]                 continue; [EOL]             } [EOL]             lastMatch = false; [EOL]             match = true; [EOL]             i++; [EOL]         } [EOL]     } else if (separatorChars.length() == 1) { [EOL]         final char sep = separatorChars.charAt(0); [EOL]         while (i < len) { [EOL]             if (str.charAt(i) == sep) { [EOL]                 if (match || preserveAllTokens) { [EOL]                     lastMatch = true; [EOL]                     if (sizePlus1++ == max) { [EOL]                         i = len; [EOL]                         lastMatch = false; [EOL]                     } [EOL]                     list.add(str.substring(start, i)); [EOL]                     match = false; [EOL]                 } [EOL]                 start = ++i; [EOL]                 continue; [EOL]             } [EOL]             lastMatch = false; [EOL]             match = true; [EOL]             i++; [EOL]         } [EOL]     } else { [EOL]         while (i < len) { [EOL]             if (separatorChars.indexOf(str.charAt(i)) >= 0) { [EOL]                 if (match || preserveAllTokens) { [EOL]                     lastMatch = true; [EOL]                     if (sizePlus1++ == max) { [EOL]                         i = len; [EOL]                         lastMatch = false; [EOL]                     } [EOL]                     list.add(str.substring(start, i)); [EOL]                     match = false; [EOL]                 } [EOL]                 start = ++i; [EOL]                 continue; [EOL]             } [EOL]             lastMatch = false; [EOL]             match = true; [EOL]             i++; [EOL]         } [EOL]     } [EOL]     if (match || preserveAllTokens && lastMatch) { [EOL]         list.add(str.substring(start, i)); [EOL]     } [EOL]     return list.toArray(new String[list.size()]); [EOL] }
private static String[] splitWorker(final String str, final String separatorChars, final int max, final boolean preserveAllTokens) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len == 0) { [EOL]         return ArrayUtils.EMPTY_STRING_ARRAY; [EOL]     } [EOL]     final List<String> list = new ArrayList<String>(); [EOL]     int sizePlus1 = 1; [EOL]     int i = 0, start = 0; [EOL]     boolean match = false; [EOL]     boolean lastMatch = false; [EOL]     if (separatorChars == null) { [EOL]         while (i < len) { [EOL]             if (Character.isWhitespace(str.charAt(i))) { [EOL]                 if (match || preserveAllTokens) { [EOL]                     lastMatch = true; [EOL]                     if (sizePlus1++ == max) { [EOL]                         i = len; [EOL]                         lastMatch = false; [EOL]                     } [EOL]                     list.add(str.substring(start, i)); [EOL]                     match = false; [EOL]                 } [EOL]                 start = ++i; [EOL]                 continue; [EOL]             } [EOL]             lastMatch = false; [EOL]             match = true; [EOL]             i++; [EOL]         } [EOL]     } else if (separatorChars.length() == 1) { [EOL]         final char sep = separatorChars.charAt(0); [EOL]         while (i < len) { [EOL]             if (str.charAt(i) == sep) { [EOL]                 if (match || preserveAllTokens) { [EOL]                     lastMatch = true; [EOL]                     if (sizePlus1++ == max) { [EOL]                         i = len; [EOL]                         lastMatch = false; [EOL]                     } [EOL]                     list.add(str.substring(start, i)); [EOL]                     match = false; [EOL]                 } [EOL]                 start = ++i; [EOL]                 continue; [EOL]             } [EOL]             lastMatch = false; [EOL]             match = true; [EOL]             i++; [EOL]         } [EOL]     } else { [EOL]         while (i < len) { [EOL]             if (separatorChars.indexOf(str.charAt(i)) >= 0) { [EOL]                 if (match || preserveAllTokens) { [EOL]                     lastMatch = true; [EOL]                     if (sizePlus1++ == max) { [EOL]                         i = len; [EOL]                         lastMatch = false; [EOL]                     } [EOL]                     list.add(str.substring(start, i)); [EOL]                     match = false; [EOL]                 } [EOL]                 start = ++i; [EOL]                 continue; [EOL]             } [EOL]             lastMatch = false; [EOL]             match = true; [EOL]             i++; [EOL]         } [EOL]     } [EOL]     if (match || preserveAllTokens && lastMatch) { [EOL]         list.add(str.substring(start, i)); [EOL]     } [EOL]     return list.toArray(new String[list.size()]); [EOL] }
private static String[] splitWorker(final String str, final String separatorChars, final int max, final boolean preserveAllTokens) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len == 0) { [EOL]         return ArrayUtils.EMPTY_STRING_ARRAY; [EOL]     } [EOL]     final List<String> list = new ArrayList<String>(); [EOL]     int sizePlus1 = 1; [EOL]     int i = 0, start = 0; [EOL]     boolean match = false; [EOL]     boolean lastMatch = false; [EOL]     if (separatorChars == null) { [EOL]         while (i < len) { [EOL]             if (Character.isWhitespace(str.charAt(i))) { [EOL]                 if (match || preserveAllTokens) { [EOL]                     lastMatch = true; [EOL]                     if (sizePlus1++ == max) { [EOL]                         i = len; [EOL]                         lastMatch = false; [EOL]                     } [EOL]                     list.add(str.substring(start, i)); [EOL]                     match = false; [EOL]                 } [EOL]                 start = ++i; [EOL]                 continue; [EOL]             } [EOL]             lastMatch = false; [EOL]             match = true; [EOL]             i++; [EOL]         } [EOL]     } else if (separatorChars.length() == 1) { [EOL]         final char sep = separatorChars.charAt(0); [EOL]         while (i < len) { [EOL]             if (str.charAt(i) == sep) { [EOL]                 if (match || preserveAllTokens) { [EOL]                     lastMatch = true; [EOL]                     if (sizePlus1++ == max) { [EOL]                         i = len; [EOL]                         lastMatch = false; [EOL]                     } [EOL]                     list.add(str.substring(start, i)); [EOL]                     match = false; [EOL]                 } [EOL]                 start = ++i; [EOL]                 continue; [EOL]             } [EOL]             lastMatch = false; [EOL]             match = true; [EOL]             i++; [EOL]         } [EOL]     } else { [EOL]         while (i < len) { [EOL]             if (separatorChars.indexOf(str.charAt(i)) >= 0) { [EOL]                 if (match || preserveAllTokens) { [EOL]                     lastMatch = true; [EOL]                     if (sizePlus1++ == max) { [EOL]                         i = len; [EOL]                         lastMatch = false; [EOL]                     } [EOL]                     list.add(str.substring(start, i)); [EOL]                     match = false; [EOL]                 } [EOL]                 start = ++i; [EOL]                 continue; [EOL]             } [EOL]             lastMatch = false; [EOL]             match = true; [EOL]             i++; [EOL]         } [EOL]     } [EOL]     if (match || preserveAllTokens && lastMatch) { [EOL]         list.add(str.substring(start, i)); [EOL]     } [EOL]     return list.toArray(new String[list.size()]); [EOL] }
public static String join(final byte[] array, final char separator) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     return join(array, separator, 0, array.length); [EOL] }
public static String join(final byte[] array, final char separator) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     return join(array, separator, 0, array.length); [EOL] }
public static String join(final byte[] array, final char separator) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     return join(array, separator, 0, array.length); [EOL] }
public static String join(final byte[] array, final char separator) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     return join(array, separator, 0, array.length); [EOL] }
public static String join(final char[] array, final char separator) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     return join(array, separator, 0, array.length); [EOL] }
public static String join(final char[] array, final char separator) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     return join(array, separator, 0, array.length); [EOL] }
public static String join(final char[] array, final char separator) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     return join(array, separator, 0, array.length); [EOL] }
public static String join(final char[] array, final char separator) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     return join(array, separator, 0, array.length); [EOL] }
public static String join(final byte[] array, final char separator, final int startIndex, final int endIndex) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     final int noOfItems = endIndex - startIndex; [EOL]     if (noOfItems <= 0) { [EOL]         return EMPTY; [EOL]     } [EOL]     final StringBuilder buf = new StringBuilder(noOfItems * 16); [EOL]     for (int i = startIndex; i < endIndex; i++) { [EOL]         if (i > startIndex) { [EOL]             buf.append(separator); [EOL]         } [EOL]         buf.append(array[i]); [EOL]     } [EOL]     return buf.toString(); [EOL] }
public static String join(final char[] array, final char separator, final int startIndex, final int endIndex) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     final int noOfItems = endIndex - startIndex; [EOL]     if (noOfItems <= 0) { [EOL]         return EMPTY; [EOL]     } [EOL]     final StringBuilder buf = new StringBuilder(noOfItems * 16); [EOL]     for (int i = startIndex; i < endIndex; i++) { [EOL]         if (i > startIndex) { [EOL]             buf.append(separator); [EOL]         } [EOL]         buf.append(array[i]); [EOL]     } [EOL]     return buf.toString(); [EOL] }
public static String join(final Iterable<?> iterable, final String separator) { [EOL]     if (iterable == null) { [EOL]         return null; [EOL]     } [EOL]     return join(iterable.iterator(), separator); [EOL] }
public static String join(final Iterable<?> iterable, final String separator) { [EOL]     if (iterable == null) { [EOL]         return null; [EOL]     } [EOL]     return join(iterable.iterator(), separator); [EOL] }
public static String remove(final String str, final String remove) { [EOL]     if (isEmpty(str) || isEmpty(remove)) { [EOL]         return str; [EOL]     } [EOL]     return replace(str, remove, EMPTY, -1); [EOL] }
public static String remove(final String str, final String remove) { [EOL]     if (isEmpty(str) || isEmpty(remove)) { [EOL]         return str; [EOL]     } [EOL]     return replace(str, remove, EMPTY, -1); [EOL] }
public static String replace(final String text, final String searchString, final String replacement) { [EOL]     return replace(text, searchString, replacement, -1); [EOL] }
public static String replace(final String text, final String searchString, final String replacement) { [EOL]     return replace(text, searchString, replacement, -1); [EOL] }
public static String replace(final String text, final String searchString, final String replacement) { [EOL]     return replace(text, searchString, replacement, -1); [EOL] }
public static String replace(final String text, final String searchString, final String replacement) { [EOL]     return replace(text, searchString, replacement, -1); [EOL] }
public static String replace(final String text, final String searchString, final String replacement) { [EOL]     return replace(text, searchString, replacement, -1); [EOL] }
public static String replace(final String text, final String searchString, final String replacement) { [EOL]     return replace(text, searchString, replacement, -1); [EOL] }
public static String replace(final String text, final String searchString, final String replacement, int max) { [EOL]     if (isEmpty(text) || isEmpty(searchString) || replacement == null || max == 0) { [EOL]         return text; [EOL]     } [EOL]     int start = 0; [EOL]     int end = text.indexOf(searchString, start); [EOL]     if (end == INDEX_NOT_FOUND) { [EOL]         return text; [EOL]     } [EOL]     final int replLength = searchString.length(); [EOL]     int increase = replacement.length() - replLength; [EOL]     increase = increase < 0 ? 0 : increase; [EOL]     increase *= max < 0 ? 16 : max > 64 ? 64 : max; [EOL]     final StringBuilder buf = new StringBuilder(text.length() + increase); [EOL]     while (end != INDEX_NOT_FOUND) { [EOL]         buf.append(text.substring(start, end)).append(replacement); [EOL]         start = end + replLength; [EOL]         if (--max == 0) { [EOL]             break; [EOL]         } [EOL]         end = text.indexOf(searchString, start); [EOL]     } [EOL]     buf.append(text.substring(start)); [EOL]     return buf.toString(); [EOL] }
public static String replaceEach(final String text, final String[] searchList, final String[] replacementList) { [EOL]     return replaceEach(text, searchList, replacementList, false, 0); [EOL] }
public static String replaceEach(final String text, final String[] searchList, final String[] replacementList) { [EOL]     return replaceEach(text, searchList, replacementList, false, 0); [EOL] }
public static String replaceEach(final String text, final String[] searchList, final String[] replacementList) { [EOL]     return replaceEach(text, searchList, replacementList, false, 0); [EOL] }
public static String replaceEach(final String text, final String[] searchList, final String[] replacementList) { [EOL]     return replaceEach(text, searchList, replacementList, false, 0); [EOL] }
public static String replaceEach(final String text, final String[] searchList, final String[] replacementList) { [EOL]     return replaceEach(text, searchList, replacementList, false, 0); [EOL] }
public static String replaceEach(final String text, final String[] searchList, final String[] replacementList) { [EOL]     return replaceEach(text, searchList, replacementList, false, 0); [EOL] }
public static String replaceEach(final String text, final String[] searchList, final String[] replacementList) { [EOL]     return replaceEach(text, searchList, replacementList, false, 0); [EOL] }
public static String replaceEach(final String text, final String[] searchList, final String[] replacementList) { [EOL]     return replaceEach(text, searchList, replacementList, false, 0); [EOL] }
private static String replaceEach(final String text, final String[] searchList, final String[] replacementList, final boolean repeat, final int timeToLive) { [EOL]     if (text == null || text.isEmpty() || searchList == null || searchList.length == 0 || replacementList == null || replacementList.length == 0) { [EOL]         return text; [EOL]     } [EOL]     if (timeToLive < 0) { [EOL]         throw new IllegalStateException("Aborting to protect against StackOverflowError - " + "output of one loop is the input of another"); [EOL]     } [EOL]     final int searchLength = searchList.length; [EOL]     final int replacementLength = replacementList.length; [EOL]     if (searchLength != replacementLength) { [EOL]         throw new IllegalArgumentException("Search and Replace array lengths don't match: " + searchLength + " vs " + replacementLength); [EOL]     } [EOL]     final boolean[] noMoreMatchesForReplIndex = new boolean[searchLength]; [EOL]     int textIndex = -1; [EOL]     int replaceIndex = -1; [EOL]     int tempIndex = -1; [EOL]     for (int i = 0; i < searchLength; i++) { [EOL]         if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].isEmpty() || replacementList[i] == null) { [EOL]             continue; [EOL]         } [EOL]         tempIndex = text.indexOf(searchList[i]); [EOL]         if (tempIndex == -1) { [EOL]             noMoreMatchesForReplIndex[i] = true; [EOL]         } else { [EOL]             if (textIndex == -1 || tempIndex < textIndex) { [EOL]                 textIndex = tempIndex; [EOL]                 replaceIndex = i; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (textIndex == -1) { [EOL]         return text; [EOL]     } [EOL]     int start = 0; [EOL]     int increase = 0; [EOL]     for (int i = 0; i < searchList.length; i++) { [EOL]         if (searchList[i] == null || replacementList[i] == null) { [EOL]             continue; [EOL]         } [EOL]         final int greater = replacementList[i].length() - searchList[i].length(); [EOL]         if (greater > 0) { [EOL]             increase += 3 * greater; [EOL]         } [EOL]     } [EOL]     increase = Math.min(increase, text.length() / 5); [EOL]     final StringBuilder buf = new StringBuilder(text.length() + increase); [EOL]     while (textIndex != -1) { [EOL]         for (int i = start; i < textIndex; i++) { [EOL]             buf.append(text.charAt(i)); [EOL]         } [EOL]         buf.append(replacementList[replaceIndex]); [EOL]         start = textIndex + searchList[replaceIndex].length(); [EOL]         textIndex = -1; [EOL]         replaceIndex = -1; [EOL]         tempIndex = -1; [EOL]         for (int i = 0; i < searchLength; i++) { [EOL]             if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].isEmpty() || replacementList[i] == null) { [EOL]                 continue; [EOL]             } [EOL]             tempIndex = text.indexOf(searchList[i], start); [EOL]             if (tempIndex == -1) { [EOL]                 noMoreMatchesForReplIndex[i] = true; [EOL]             } else { [EOL]                 if (textIndex == -1 || tempIndex < textIndex) { [EOL]                     textIndex = tempIndex; [EOL]                     replaceIndex = i; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     final int textLength = text.length(); [EOL]     for (int i = start; i < textLength; i++) { [EOL]         buf.append(text.charAt(i)); [EOL]     } [EOL]     final String result = buf.toString(); [EOL]     if (!repeat) { [EOL]         return result; [EOL]     } [EOL]     return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1); [EOL] }
public static String replaceChars(final String str, final char searchChar, final char replaceChar) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     return str.replace(searchChar, replaceChar); [EOL] }
public static String replaceChars(final String str, final char searchChar, final char replaceChar) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     return str.replace(searchChar, replaceChar); [EOL] }
public static String replaceChars(final String str, final char searchChar, final char replaceChar) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     return str.replace(searchChar, replaceChar); [EOL] }
public static String replaceChars(final String str, final String searchChars, String replaceChars) { [EOL]     if (isEmpty(str) || isEmpty(searchChars)) { [EOL]         return str; [EOL]     } [EOL]     if (replaceChars == null) { [EOL]         replaceChars = EMPTY; [EOL]     } [EOL]     boolean modified = false; [EOL]     final int replaceCharsLength = replaceChars.length(); [EOL]     final int strLength = str.length(); [EOL]     final StringBuilder buf = new StringBuilder(strLength); [EOL]     for (int i = 0; i < strLength; i++) { [EOL]         final char ch = str.charAt(i); [EOL]         final int index = searchChars.indexOf(ch); [EOL]         if (index >= 0) { [EOL]             modified = true; [EOL]             if (index < replaceCharsLength) { [EOL]                 buf.append(replaceChars.charAt(index)); [EOL]             } [EOL]         } else { [EOL]             buf.append(ch); [EOL]         } [EOL]     } [EOL]     if (modified) { [EOL]         return buf.toString(); [EOL]     } [EOL]     return str; [EOL] }
public static String replaceChars(final String str, final String searchChars, String replaceChars) { [EOL]     if (isEmpty(str) || isEmpty(searchChars)) { [EOL]         return str; [EOL]     } [EOL]     if (replaceChars == null) { [EOL]         replaceChars = EMPTY; [EOL]     } [EOL]     boolean modified = false; [EOL]     final int replaceCharsLength = replaceChars.length(); [EOL]     final int strLength = str.length(); [EOL]     final StringBuilder buf = new StringBuilder(strLength); [EOL]     for (int i = 0; i < strLength; i++) { [EOL]         final char ch = str.charAt(i); [EOL]         final int index = searchChars.indexOf(ch); [EOL]         if (index >= 0) { [EOL]             modified = true; [EOL]             if (index < replaceCharsLength) { [EOL]                 buf.append(replaceChars.charAt(index)); [EOL]             } [EOL]         } else { [EOL]             buf.append(ch); [EOL]         } [EOL]     } [EOL]     if (modified) { [EOL]         return buf.toString(); [EOL]     } [EOL]     return str; [EOL] }
public static String repeat(final String str, final int repeat) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (repeat <= 0) { [EOL]         return EMPTY; [EOL]     } [EOL]     final int inputLength = str.length(); [EOL]     if (repeat == 1 || inputLength == 0) { [EOL]         return str; [EOL]     } [EOL]     if (inputLength == 1 && repeat <= PAD_LIMIT) { [EOL]         return repeat(str.charAt(0), repeat); [EOL]     } [EOL]     final int outputLength = inputLength * repeat; [EOL]     switch(inputLength) { [EOL]         case 1: [EOL]             return repeat(str.charAt(0), repeat); [EOL]         case 2: [EOL]             final char ch0 = str.charAt(0); [EOL]             final char ch1 = str.charAt(1); [EOL]             final char[] output2 = new char[outputLength]; [EOL]             for (int i = repeat * 2 - 2; i >= 0; i--, i--) { [EOL]                 output2[i] = ch0; [EOL]                 output2[i + 1] = ch1; [EOL]             } [EOL]             return new String(output2); [EOL]         default: [EOL]             final StringBuilder buf = new StringBuilder(outputLength); [EOL]             for (int i = 0; i < repeat; i++) { [EOL]                 buf.append(str); [EOL]             } [EOL]             return buf.toString(); [EOL]     } [EOL] }
public static String repeat(final String str, final int repeat) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (repeat <= 0) { [EOL]         return EMPTY; [EOL]     } [EOL]     final int inputLength = str.length(); [EOL]     if (repeat == 1 || inputLength == 0) { [EOL]         return str; [EOL]     } [EOL]     if (inputLength == 1 && repeat <= PAD_LIMIT) { [EOL]         return repeat(str.charAt(0), repeat); [EOL]     } [EOL]     final int outputLength = inputLength * repeat; [EOL]     switch(inputLength) { [EOL]         case 1: [EOL]             return repeat(str.charAt(0), repeat); [EOL]         case 2: [EOL]             final char ch0 = str.charAt(0); [EOL]             final char ch1 = str.charAt(1); [EOL]             final char[] output2 = new char[outputLength]; [EOL]             for (int i = repeat * 2 - 2; i >= 0; i--, i--) { [EOL]                 output2[i] = ch0; [EOL]                 output2[i + 1] = ch1; [EOL]             } [EOL]             return new String(output2); [EOL]         default: [EOL]             final StringBuilder buf = new StringBuilder(outputLength); [EOL]             for (int i = 0; i < repeat; i++) { [EOL]                 buf.append(str); [EOL]             } [EOL]             return buf.toString(); [EOL]     } [EOL] }
public static String repeat(final String str, final int repeat) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (repeat <= 0) { [EOL]         return EMPTY; [EOL]     } [EOL]     final int inputLength = str.length(); [EOL]     if (repeat == 1 || inputLength == 0) { [EOL]         return str; [EOL]     } [EOL]     if (inputLength == 1 && repeat <= PAD_LIMIT) { [EOL]         return repeat(str.charAt(0), repeat); [EOL]     } [EOL]     final int outputLength = inputLength * repeat; [EOL]     switch(inputLength) { [EOL]         case 1: [EOL]             return repeat(str.charAt(0), repeat); [EOL]         case 2: [EOL]             final char ch0 = str.charAt(0); [EOL]             final char ch1 = str.charAt(1); [EOL]             final char[] output2 = new char[outputLength]; [EOL]             for (int i = repeat * 2 - 2; i >= 0; i--, i--) { [EOL]                 output2[i] = ch0; [EOL]                 output2[i + 1] = ch1; [EOL]             } [EOL]             return new String(output2); [EOL]         default: [EOL]             final StringBuilder buf = new StringBuilder(outputLength); [EOL]             for (int i = 0; i < repeat; i++) { [EOL]                 buf.append(str); [EOL]             } [EOL]             return buf.toString(); [EOL]     } [EOL] }
public static String repeat(final String str, final int repeat) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (repeat <= 0) { [EOL]         return EMPTY; [EOL]     } [EOL]     final int inputLength = str.length(); [EOL]     if (repeat == 1 || inputLength == 0) { [EOL]         return str; [EOL]     } [EOL]     if (inputLength == 1 && repeat <= PAD_LIMIT) { [EOL]         return repeat(str.charAt(0), repeat); [EOL]     } [EOL]     final int outputLength = inputLength * repeat; [EOL]     switch(inputLength) { [EOL]         case 1: [EOL]             return repeat(str.charAt(0), repeat); [EOL]         case 2: [EOL]             final char ch0 = str.charAt(0); [EOL]             final char ch1 = str.charAt(1); [EOL]             final char[] output2 = new char[outputLength]; [EOL]             for (int i = repeat * 2 - 2; i >= 0; i--, i--) { [EOL]                 output2[i] = ch0; [EOL]                 output2[i + 1] = ch1; [EOL]             } [EOL]             return new String(output2); [EOL]         default: [EOL]             final StringBuilder buf = new StringBuilder(outputLength); [EOL]             for (int i = 0; i < repeat; i++) { [EOL]                 buf.append(str); [EOL]             } [EOL]             return buf.toString(); [EOL]     } [EOL] }
public static String repeat(final String str, final int repeat) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (repeat <= 0) { [EOL]         return EMPTY; [EOL]     } [EOL]     final int inputLength = str.length(); [EOL]     if (repeat == 1 || inputLength == 0) { [EOL]         return str; [EOL]     } [EOL]     if (inputLength == 1 && repeat <= PAD_LIMIT) { [EOL]         return repeat(str.charAt(0), repeat); [EOL]     } [EOL]     final int outputLength = inputLength * repeat; [EOL]     switch(inputLength) { [EOL]         case 1: [EOL]             return repeat(str.charAt(0), repeat); [EOL]         case 2: [EOL]             final char ch0 = str.charAt(0); [EOL]             final char ch1 = str.charAt(1); [EOL]             final char[] output2 = new char[outputLength]; [EOL]             for (int i = repeat * 2 - 2; i >= 0; i--, i--) { [EOL]                 output2[i] = ch0; [EOL]                 output2[i + 1] = ch1; [EOL]             } [EOL]             return new String(output2); [EOL]         default: [EOL]             final StringBuilder buf = new StringBuilder(outputLength); [EOL]             for (int i = 0; i < repeat; i++) { [EOL]                 buf.append(str); [EOL]             } [EOL]             return buf.toString(); [EOL]     } [EOL] }
public static String repeat(final String str, final int repeat) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (repeat <= 0) { [EOL]         return EMPTY; [EOL]     } [EOL]     final int inputLength = str.length(); [EOL]     if (repeat == 1 || inputLength == 0) { [EOL]         return str; [EOL]     } [EOL]     if (inputLength == 1 && repeat <= PAD_LIMIT) { [EOL]         return repeat(str.charAt(0), repeat); [EOL]     } [EOL]     final int outputLength = inputLength * repeat; [EOL]     switch(inputLength) { [EOL]         case 1: [EOL]             return repeat(str.charAt(0), repeat); [EOL]         case 2: [EOL]             final char ch0 = str.charAt(0); [EOL]             final char ch1 = str.charAt(1); [EOL]             final char[] output2 = new char[outputLength]; [EOL]             for (int i = repeat * 2 - 2; i >= 0; i--, i--) { [EOL]                 output2[i] = ch0; [EOL]                 output2[i + 1] = ch1; [EOL]             } [EOL]             return new String(output2); [EOL]         default: [EOL]             final StringBuilder buf = new StringBuilder(outputLength); [EOL]             for (int i = 0; i < repeat; i++) { [EOL]                 buf.append(str); [EOL]             } [EOL]             return buf.toString(); [EOL]     } [EOL] }
public static String repeat(final String str, final int repeat) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (repeat <= 0) { [EOL]         return EMPTY; [EOL]     } [EOL]     final int inputLength = str.length(); [EOL]     if (repeat == 1 || inputLength == 0) { [EOL]         return str; [EOL]     } [EOL]     if (inputLength == 1 && repeat <= PAD_LIMIT) { [EOL]         return repeat(str.charAt(0), repeat); [EOL]     } [EOL]     final int outputLength = inputLength * repeat; [EOL]     switch(inputLength) { [EOL]         case 1: [EOL]             return repeat(str.charAt(0), repeat); [EOL]         case 2: [EOL]             final char ch0 = str.charAt(0); [EOL]             final char ch1 = str.charAt(1); [EOL]             final char[] output2 = new char[outputLength]; [EOL]             for (int i = repeat * 2 - 2; i >= 0; i--, i--) { [EOL]                 output2[i] = ch0; [EOL]                 output2[i + 1] = ch1; [EOL]             } [EOL]             return new String(output2); [EOL]         default: [EOL]             final StringBuilder buf = new StringBuilder(outputLength); [EOL]             for (int i = 0; i < repeat; i++) { [EOL]                 buf.append(str); [EOL]             } [EOL]             return buf.toString(); [EOL]     } [EOL] }
public static String repeat(final String str, final int repeat) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (repeat <= 0) { [EOL]         return EMPTY; [EOL]     } [EOL]     final int inputLength = str.length(); [EOL]     if (repeat == 1 || inputLength == 0) { [EOL]         return str; [EOL]     } [EOL]     if (inputLength == 1 && repeat <= PAD_LIMIT) { [EOL]         return repeat(str.charAt(0), repeat); [EOL]     } [EOL]     final int outputLength = inputLength * repeat; [EOL]     switch(inputLength) { [EOL]         case 1: [EOL]             return repeat(str.charAt(0), repeat); [EOL]         case 2: [EOL]             final char ch0 = str.charAt(0); [EOL]             final char ch1 = str.charAt(1); [EOL]             final char[] output2 = new char[outputLength]; [EOL]             for (int i = repeat * 2 - 2; i >= 0; i--, i--) { [EOL]                 output2[i] = ch0; [EOL]                 output2[i + 1] = ch1; [EOL]             } [EOL]             return new String(output2); [EOL]         default: [EOL]             final StringBuilder buf = new StringBuilder(outputLength); [EOL]             for (int i = 0; i < repeat; i++) { [EOL]                 buf.append(str); [EOL]             } [EOL]             return buf.toString(); [EOL]     } [EOL] }
public static String rightPad(final String str, final int size) { [EOL]     return rightPad(str, size, ' '); [EOL] }
public static String rightPad(final String str, final int size) { [EOL]     return rightPad(str, size, ' '); [EOL] }
public static String rightPad(final String str, final int size) { [EOL]     return rightPad(str, size, ' '); [EOL] }
public static String rightPad(final String str, final int size) { [EOL]     return rightPad(str, size, ' '); [EOL] }
public static String rightPad(final String str, final int size) { [EOL]     return rightPad(str, size, ' '); [EOL] }
public static String rightPad(final String str, final int size, final char padChar) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     final int pads = size - str.length(); [EOL]     if (pads <= 0) { [EOL]         return str; [EOL]     } [EOL]     if (pads > PAD_LIMIT) { [EOL]         return rightPad(str, size, String.valueOf(padChar)); [EOL]     } [EOL]     return str.concat(repeat(padChar, pads)); [EOL] }
public static String rightPad(final String str, final int size, final char padChar) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     final int pads = size - str.length(); [EOL]     if (pads <= 0) { [EOL]         return str; [EOL]     } [EOL]     if (pads > PAD_LIMIT) { [EOL]         return rightPad(str, size, String.valueOf(padChar)); [EOL]     } [EOL]     return str.concat(repeat(padChar, pads)); [EOL] }
public static String rightPad(final String str, final int size, final char padChar) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     final int pads = size - str.length(); [EOL]     if (pads <= 0) { [EOL]         return str; [EOL]     } [EOL]     if (pads > PAD_LIMIT) { [EOL]         return rightPad(str, size, String.valueOf(padChar)); [EOL]     } [EOL]     return str.concat(repeat(padChar, pads)); [EOL] }
public static String rightPad(final String str, final int size, final char padChar) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     final int pads = size - str.length(); [EOL]     if (pads <= 0) { [EOL]         return str; [EOL]     } [EOL]     if (pads > PAD_LIMIT) { [EOL]         return rightPad(str, size, String.valueOf(padChar)); [EOL]     } [EOL]     return str.concat(repeat(padChar, pads)); [EOL] }
public static String rightPad(final String str, final int size, String padStr) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (isEmpty(padStr)) { [EOL]         padStr = SPACE; [EOL]     } [EOL]     final int padLen = padStr.length(); [EOL]     final int strLen = str.length(); [EOL]     final int pads = size - strLen; [EOL]     if (pads <= 0) { [EOL]         return str; [EOL]     } [EOL]     if (padLen == 1 && pads <= PAD_LIMIT) { [EOL]         return rightPad(str, size, padStr.charAt(0)); [EOL]     } [EOL]     if (pads == padLen) { [EOL]         return str.concat(padStr); [EOL]     } else if (pads < padLen) { [EOL]         return str.concat(padStr.substring(0, pads)); [EOL]     } else { [EOL]         final char[] padding = new char[pads]; [EOL]         final char[] padChars = padStr.toCharArray(); [EOL]         for (int i = 0; i < pads; i++) { [EOL]             padding[i] = padChars[i % padLen]; [EOL]         } [EOL]         return str.concat(new String(padding)); [EOL]     } [EOL] }
public static String rightPad(final String str, final int size, String padStr) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (isEmpty(padStr)) { [EOL]         padStr = SPACE; [EOL]     } [EOL]     final int padLen = padStr.length(); [EOL]     final int strLen = str.length(); [EOL]     final int pads = size - strLen; [EOL]     if (pads <= 0) { [EOL]         return str; [EOL]     } [EOL]     if (padLen == 1 && pads <= PAD_LIMIT) { [EOL]         return rightPad(str, size, padStr.charAt(0)); [EOL]     } [EOL]     if (pads == padLen) { [EOL]         return str.concat(padStr); [EOL]     } else if (pads < padLen) { [EOL]         return str.concat(padStr.substring(0, pads)); [EOL]     } else { [EOL]         final char[] padding = new char[pads]; [EOL]         final char[] padChars = padStr.toCharArray(); [EOL]         for (int i = 0; i < pads; i++) { [EOL]             padding[i] = padChars[i % padLen]; [EOL]         } [EOL]         return str.concat(new String(padding)); [EOL]     } [EOL] }
public static String leftPad(final String str, final int size, String padStr) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (isEmpty(padStr)) { [EOL]         padStr = SPACE; [EOL]     } [EOL]     final int padLen = padStr.length(); [EOL]     final int strLen = str.length(); [EOL]     final int pads = size - strLen; [EOL]     if (pads <= 0) { [EOL]         return str; [EOL]     } [EOL]     if (padLen == 1 && pads <= PAD_LIMIT) { [EOL]         return leftPad(str, size, padStr.charAt(0)); [EOL]     } [EOL]     if (pads == padLen) { [EOL]         return padStr.concat(str); [EOL]     } else if (pads < padLen) { [EOL]         return padStr.substring(0, pads).concat(str); [EOL]     } else { [EOL]         final char[] padding = new char[pads]; [EOL]         final char[] padChars = padStr.toCharArray(); [EOL]         for (int i = 0; i < pads; i++) { [EOL]             padding[i] = padChars[i % padLen]; [EOL]         } [EOL]         return new String(padding).concat(str); [EOL]     } [EOL] }
public static String leftPad(final String str, final int size, String padStr) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (isEmpty(padStr)) { [EOL]         padStr = SPACE; [EOL]     } [EOL]     final int padLen = padStr.length(); [EOL]     final int strLen = str.length(); [EOL]     final int pads = size - strLen; [EOL]     if (pads <= 0) { [EOL]         return str; [EOL]     } [EOL]     if (padLen == 1 && pads <= PAD_LIMIT) { [EOL]         return leftPad(str, size, padStr.charAt(0)); [EOL]     } [EOL]     if (pads == padLen) { [EOL]         return padStr.concat(str); [EOL]     } else if (pads < padLen) { [EOL]         return padStr.substring(0, pads).concat(str); [EOL]     } else { [EOL]         final char[] padding = new char[pads]; [EOL]         final char[] padChars = padStr.toCharArray(); [EOL]         for (int i = 0; i < pads; i++) { [EOL]             padding[i] = padChars[i % padLen]; [EOL]         } [EOL]         return new String(padding).concat(str); [EOL]     } [EOL] }
public static String leftPad(final String str, final int size, String padStr) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (isEmpty(padStr)) { [EOL]         padStr = SPACE; [EOL]     } [EOL]     final int padLen = padStr.length(); [EOL]     final int strLen = str.length(); [EOL]     final int pads = size - strLen; [EOL]     if (pads <= 0) { [EOL]         return str; [EOL]     } [EOL]     if (padLen == 1 && pads <= PAD_LIMIT) { [EOL]         return leftPad(str, size, padStr.charAt(0)); [EOL]     } [EOL]     if (pads == padLen) { [EOL]         return padStr.concat(str); [EOL]     } else if (pads < padLen) { [EOL]         return padStr.substring(0, pads).concat(str); [EOL]     } else { [EOL]         final char[] padding = new char[pads]; [EOL]         final char[] padChars = padStr.toCharArray(); [EOL]         for (int i = 0; i < pads; i++) { [EOL]             padding[i] = padChars[i % padLen]; [EOL]         } [EOL]         return new String(padding).concat(str); [EOL]     } [EOL] }
public static String leftPad(final String str, final int size, String padStr) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (isEmpty(padStr)) { [EOL]         padStr = SPACE; [EOL]     } [EOL]     final int padLen = padStr.length(); [EOL]     final int strLen = str.length(); [EOL]     final int pads = size - strLen; [EOL]     if (pads <= 0) { [EOL]         return str; [EOL]     } [EOL]     if (padLen == 1 && pads <= PAD_LIMIT) { [EOL]         return leftPad(str, size, padStr.charAt(0)); [EOL]     } [EOL]     if (pads == padLen) { [EOL]         return padStr.concat(str); [EOL]     } else if (pads < padLen) { [EOL]         return padStr.substring(0, pads).concat(str); [EOL]     } else { [EOL]         final char[] padding = new char[pads]; [EOL]         final char[] padChars = padStr.toCharArray(); [EOL]         for (int i = 0; i < pads; i++) { [EOL]             padding[i] = padChars[i % padLen]; [EOL]         } [EOL]         return new String(padding).concat(str); [EOL]     } [EOL] }
public static String leftPad(final String str, final int size, String padStr) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (isEmpty(padStr)) { [EOL]         padStr = SPACE; [EOL]     } [EOL]     final int padLen = padStr.length(); [EOL]     final int strLen = str.length(); [EOL]     final int pads = size - strLen; [EOL]     if (pads <= 0) { [EOL]         return str; [EOL]     } [EOL]     if (padLen == 1 && pads <= PAD_LIMIT) { [EOL]         return leftPad(str, size, padStr.charAt(0)); [EOL]     } [EOL]     if (pads == padLen) { [EOL]         return padStr.concat(str); [EOL]     } else if (pads < padLen) { [EOL]         return padStr.substring(0, pads).concat(str); [EOL]     } else { [EOL]         final char[] padding = new char[pads]; [EOL]         final char[] padChars = padStr.toCharArray(); [EOL]         for (int i = 0; i < pads; i++) { [EOL]             padding[i] = padChars[i % padLen]; [EOL]         } [EOL]         return new String(padding).concat(str); [EOL]     } [EOL] }
public static String leftPad(final String str, final int size, String padStr) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (isEmpty(padStr)) { [EOL]         padStr = SPACE; [EOL]     } [EOL]     final int padLen = padStr.length(); [EOL]     final int strLen = str.length(); [EOL]     final int pads = size - strLen; [EOL]     if (pads <= 0) { [EOL]         return str; [EOL]     } [EOL]     if (padLen == 1 && pads <= PAD_LIMIT) { [EOL]         return leftPad(str, size, padStr.charAt(0)); [EOL]     } [EOL]     if (pads == padLen) { [EOL]         return padStr.concat(str); [EOL]     } else if (pads < padLen) { [EOL]         return padStr.substring(0, pads).concat(str); [EOL]     } else { [EOL]         final char[] padding = new char[pads]; [EOL]         final char[] padChars = padStr.toCharArray(); [EOL]         for (int i = 0; i < pads; i++) { [EOL]             padding[i] = padChars[i % padLen]; [EOL]         } [EOL]         return new String(padding).concat(str); [EOL]     } [EOL] }
public static String leftPad(final String str, final int size, String padStr) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (isEmpty(padStr)) { [EOL]         padStr = SPACE; [EOL]     } [EOL]     final int padLen = padStr.length(); [EOL]     final int strLen = str.length(); [EOL]     final int pads = size - strLen; [EOL]     if (pads <= 0) { [EOL]         return str; [EOL]     } [EOL]     if (padLen == 1 && pads <= PAD_LIMIT) { [EOL]         return leftPad(str, size, padStr.charAt(0)); [EOL]     } [EOL]     if (pads == padLen) { [EOL]         return padStr.concat(str); [EOL]     } else if (pads < padLen) { [EOL]         return padStr.substring(0, pads).concat(str); [EOL]     } else { [EOL]         final char[] padding = new char[pads]; [EOL]         final char[] padChars = padStr.toCharArray(); [EOL]         for (int i = 0; i < pads; i++) { [EOL]             padding[i] = padChars[i % padLen]; [EOL]         } [EOL]         return new String(padding).concat(str); [EOL]     } [EOL] }
public static String leftPad(final String str, final int size, String padStr) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (isEmpty(padStr)) { [EOL]         padStr = SPACE; [EOL]     } [EOL]     final int padLen = padStr.length(); [EOL]     final int strLen = str.length(); [EOL]     final int pads = size - strLen; [EOL]     if (pads <= 0) { [EOL]         return str; [EOL]     } [EOL]     if (padLen == 1 && pads <= PAD_LIMIT) { [EOL]         return leftPad(str, size, padStr.charAt(0)); [EOL]     } [EOL]     if (pads == padLen) { [EOL]         return padStr.concat(str); [EOL]     } else if (pads < padLen) { [EOL]         return padStr.substring(0, pads).concat(str); [EOL]     } else { [EOL]         final char[] padding = new char[pads]; [EOL]         final char[] padChars = padStr.toCharArray(); [EOL]         for (int i = 0; i < pads; i++) { [EOL]             padding[i] = padChars[i % padLen]; [EOL]         } [EOL]         return new String(padding).concat(str); [EOL]     } [EOL] }
public static String center(String str, final int size, String padStr) { [EOL]     if (str == null || size <= 0) { [EOL]         return str; [EOL]     } [EOL]     if (isEmpty(padStr)) { [EOL]         padStr = SPACE; [EOL]     } [EOL]     final int strLen = str.length(); [EOL]     final int pads = size - strLen; [EOL]     if (pads <= 0) { [EOL]         return str; [EOL]     } [EOL]     str = leftPad(str, strLen + pads / 2, padStr); [EOL]     str = rightPad(str, size, padStr); [EOL]     return str; [EOL] }
public static String center(String str, final int size, String padStr) { [EOL]     if (str == null || size <= 0) { [EOL]         return str; [EOL]     } [EOL]     if (isEmpty(padStr)) { [EOL]         padStr = SPACE; [EOL]     } [EOL]     final int strLen = str.length(); [EOL]     final int pads = size - strLen; [EOL]     if (pads <= 0) { [EOL]         return str; [EOL]     } [EOL]     str = leftPad(str, strLen + pads / 2, padStr); [EOL]     str = rightPad(str, size, padStr); [EOL]     return str; [EOL] }
public static String center(String str, final int size, String padStr) { [EOL]     if (str == null || size <= 0) { [EOL]         return str; [EOL]     } [EOL]     if (isEmpty(padStr)) { [EOL]         padStr = SPACE; [EOL]     } [EOL]     final int strLen = str.length(); [EOL]     final int pads = size - strLen; [EOL]     if (pads <= 0) { [EOL]         return str; [EOL]     } [EOL]     str = leftPad(str, strLen + pads / 2, padStr); [EOL]     str = rightPad(str, size, padStr); [EOL]     return str; [EOL] }
public static String center(String str, final int size, String padStr) { [EOL]     if (str == null || size <= 0) { [EOL]         return str; [EOL]     } [EOL]     if (isEmpty(padStr)) { [EOL]         padStr = SPACE; [EOL]     } [EOL]     final int strLen = str.length(); [EOL]     final int pads = size - strLen; [EOL]     if (pads <= 0) { [EOL]         return str; [EOL]     } [EOL]     str = leftPad(str, strLen + pads / 2, padStr); [EOL]     str = rightPad(str, size, padStr); [EOL]     return str; [EOL] }
public static String center(String str, final int size, String padStr) { [EOL]     if (str == null || size <= 0) { [EOL]         return str; [EOL]     } [EOL]     if (isEmpty(padStr)) { [EOL]         padStr = SPACE; [EOL]     } [EOL]     final int strLen = str.length(); [EOL]     final int pads = size - strLen; [EOL]     if (pads <= 0) { [EOL]         return str; [EOL]     } [EOL]     str = leftPad(str, strLen + pads / 2, padStr); [EOL]     str = rightPad(str, size, padStr); [EOL]     return str; [EOL] }
public static String center(String str, final int size, String padStr) { [EOL]     if (str == null || size <= 0) { [EOL]         return str; [EOL]     } [EOL]     if (isEmpty(padStr)) { [EOL]         padStr = SPACE; [EOL]     } [EOL]     final int strLen = str.length(); [EOL]     final int pads = size - strLen; [EOL]     if (pads <= 0) { [EOL]         return str; [EOL]     } [EOL]     str = leftPad(str, strLen + pads / 2, padStr); [EOL]     str = rightPad(str, size, padStr); [EOL]     return str; [EOL] }
public static String center(String str, final int size, String padStr) { [EOL]     if (str == null || size <= 0) { [EOL]         return str; [EOL]     } [EOL]     if (isEmpty(padStr)) { [EOL]         padStr = SPACE; [EOL]     } [EOL]     final int strLen = str.length(); [EOL]     final int pads = size - strLen; [EOL]     if (pads <= 0) { [EOL]         return str; [EOL]     } [EOL]     str = leftPad(str, strLen + pads / 2, padStr); [EOL]     str = rightPad(str, size, padStr); [EOL]     return str; [EOL] }
public static String center(String str, final int size, String padStr) { [EOL]     if (str == null || size <= 0) { [EOL]         return str; [EOL]     } [EOL]     if (isEmpty(padStr)) { [EOL]         padStr = SPACE; [EOL]     } [EOL]     final int strLen = str.length(); [EOL]     final int pads = size - strLen; [EOL]     if (pads <= 0) { [EOL]         return str; [EOL]     } [EOL]     str = leftPad(str, strLen + pads / 2, padStr); [EOL]     str = rightPad(str, size, padStr); [EOL]     return str; [EOL] }
public static boolean isAlpha(final CharSequence cs) { [EOL]     if (cs == null || cs.length() == 0) { [EOL]         return false; [EOL]     } [EOL]     final int sz = cs.length(); [EOL]     for (int i = 0; i < sz; i++) { [EOL]         if (Character.isLetter(cs.charAt(i)) == false) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public static boolean isAlpha(final CharSequence cs) { [EOL]     if (cs == null || cs.length() == 0) { [EOL]         return false; [EOL]     } [EOL]     final int sz = cs.length(); [EOL]     for (int i = 0; i < sz; i++) { [EOL]         if (Character.isLetter(cs.charAt(i)) == false) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public static boolean isAlpha(final CharSequence cs) { [EOL]     if (cs == null || cs.length() == 0) { [EOL]         return false; [EOL]     } [EOL]     final int sz = cs.length(); [EOL]     for (int i = 0; i < sz; i++) { [EOL]         if (Character.isLetter(cs.charAt(i)) == false) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public static boolean isAlpha(final CharSequence cs) { [EOL]     if (cs == null || cs.length() == 0) { [EOL]         return false; [EOL]     } [EOL]     final int sz = cs.length(); [EOL]     for (int i = 0; i < sz; i++) { [EOL]         if (Character.isLetter(cs.charAt(i)) == false) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public static boolean isAlpha(final CharSequence cs) { [EOL]     if (cs == null || cs.length() == 0) { [EOL]         return false; [EOL]     } [EOL]     final int sz = cs.length(); [EOL]     for (int i = 0; i < sz; i++) { [EOL]         if (Character.isLetter(cs.charAt(i)) == false) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public static boolean isAsciiPrintable(final CharSequence cs) { [EOL]     if (cs == null) { [EOL]         return false; [EOL]     } [EOL]     final int sz = cs.length(); [EOL]     for (int i = 0; i < sz; i++) { [EOL]         if (CharUtils.isAsciiPrintable(cs.charAt(i)) == false) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public static boolean isAsciiPrintable(final CharSequence cs) { [EOL]     if (cs == null) { [EOL]         return false; [EOL]     } [EOL]     final int sz = cs.length(); [EOL]     for (int i = 0; i < sz; i++) { [EOL]         if (CharUtils.isAsciiPrintable(cs.charAt(i)) == false) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public static boolean isAsciiPrintable(final CharSequence cs) { [EOL]     if (cs == null) { [EOL]         return false; [EOL]     } [EOL]     final int sz = cs.length(); [EOL]     for (int i = 0; i < sz; i++) { [EOL]         if (CharUtils.isAsciiPrintable(cs.charAt(i)) == false) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public static boolean isAsciiPrintable(final CharSequence cs) { [EOL]     if (cs == null) { [EOL]         return false; [EOL]     } [EOL]     final int sz = cs.length(); [EOL]     for (int i = 0; i < sz; i++) { [EOL]         if (CharUtils.isAsciiPrintable(cs.charAt(i)) == false) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public static String defaultString(final String str) { [EOL]     return str == null ? EMPTY : str; [EOL] }
public static String defaultString(final String str) { [EOL]     return str == null ? EMPTY : str; [EOL] }
public static String reverse(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     return new StringBuilder(str).reverse().toString(); [EOL] }
public static String reverse(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     return new StringBuilder(str).reverse().toString(); [EOL] }
public static String reverse(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     return new StringBuilder(str).reverse().toString(); [EOL] }
public static String reverse(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     return new StringBuilder(str).reverse().toString(); [EOL] }
public static String difference(final String str1, final String str2) { [EOL]     if (str1 == null) { [EOL]         return str2; [EOL]     } [EOL]     if (str2 == null) { [EOL]         return str1; [EOL]     } [EOL]     final int at = indexOfDifference(str1, str2); [EOL]     if (at == INDEX_NOT_FOUND) { [EOL]         return EMPTY; [EOL]     } [EOL]     return str2.substring(at); [EOL] }
public static String difference(final String str1, final String str2) { [EOL]     if (str1 == null) { [EOL]         return str2; [EOL]     } [EOL]     if (str2 == null) { [EOL]         return str1; [EOL]     } [EOL]     final int at = indexOfDifference(str1, str2); [EOL]     if (at == INDEX_NOT_FOUND) { [EOL]         return EMPTY; [EOL]     } [EOL]     return str2.substring(at); [EOL] }
public static String difference(final String str1, final String str2) { [EOL]     if (str1 == null) { [EOL]         return str2; [EOL]     } [EOL]     if (str2 == null) { [EOL]         return str1; [EOL]     } [EOL]     final int at = indexOfDifference(str1, str2); [EOL]     if (at == INDEX_NOT_FOUND) { [EOL]         return EMPTY; [EOL]     } [EOL]     return str2.substring(at); [EOL] }
public static String difference(final String str1, final String str2) { [EOL]     if (str1 == null) { [EOL]         return str2; [EOL]     } [EOL]     if (str2 == null) { [EOL]         return str1; [EOL]     } [EOL]     final int at = indexOfDifference(str1, str2); [EOL]     if (at == INDEX_NOT_FOUND) { [EOL]         return EMPTY; [EOL]     } [EOL]     return str2.substring(at); [EOL] }
public static String difference(final String str1, final String str2) { [EOL]     if (str1 == null) { [EOL]         return str2; [EOL]     } [EOL]     if (str2 == null) { [EOL]         return str1; [EOL]     } [EOL]     final int at = indexOfDifference(str1, str2); [EOL]     if (at == INDEX_NOT_FOUND) { [EOL]         return EMPTY; [EOL]     } [EOL]     return str2.substring(at); [EOL] }
public static String difference(final String str1, final String str2) { [EOL]     if (str1 == null) { [EOL]         return str2; [EOL]     } [EOL]     if (str2 == null) { [EOL]         return str1; [EOL]     } [EOL]     final int at = indexOfDifference(str1, str2); [EOL]     if (at == INDEX_NOT_FOUND) { [EOL]         return EMPTY; [EOL]     } [EOL]     return str2.substring(at); [EOL] }
public static String difference(final String str1, final String str2) { [EOL]     if (str1 == null) { [EOL]         return str2; [EOL]     } [EOL]     if (str2 == null) { [EOL]         return str1; [EOL]     } [EOL]     final int at = indexOfDifference(str1, str2); [EOL]     if (at == INDEX_NOT_FOUND) { [EOL]         return EMPTY; [EOL]     } [EOL]     return str2.substring(at); [EOL] }
public static int indexOfDifference(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return 0; [EOL]     } [EOL]     int i; [EOL]     for (i = 0; i < cs1.length() && i < cs2.length(); ++i) { [EOL]         if (cs1.charAt(i) != cs2.charAt(i)) { [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (i < cs2.length() || i < cs1.length()) { [EOL]         return i; [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int indexOfDifference(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return 0; [EOL]     } [EOL]     int i; [EOL]     for (i = 0; i < cs1.length() && i < cs2.length(); ++i) { [EOL]         if (cs1.charAt(i) != cs2.charAt(i)) { [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (i < cs2.length() || i < cs1.length()) { [EOL]         return i; [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int indexOfDifference(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return 0; [EOL]     } [EOL]     int i; [EOL]     for (i = 0; i < cs1.length() && i < cs2.length(); ++i) { [EOL]         if (cs1.charAt(i) != cs2.charAt(i)) { [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (i < cs2.length() || i < cs1.length()) { [EOL]         return i; [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int indexOfDifference(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return 0; [EOL]     } [EOL]     int i; [EOL]     for (i = 0; i < cs1.length() && i < cs2.length(); ++i) { [EOL]         if (cs1.charAt(i) != cs2.charAt(i)) { [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (i < cs2.length() || i < cs1.length()) { [EOL]         return i; [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int indexOfDifference(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return 0; [EOL]     } [EOL]     int i; [EOL]     for (i = 0; i < cs1.length() && i < cs2.length(); ++i) { [EOL]         if (cs1.charAt(i) != cs2.charAt(i)) { [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (i < cs2.length() || i < cs1.length()) { [EOL]         return i; [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int indexOfDifference(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return 0; [EOL]     } [EOL]     int i; [EOL]     for (i = 0; i < cs1.length() && i < cs2.length(); ++i) { [EOL]         if (cs1.charAt(i) != cs2.charAt(i)) { [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (i < cs2.length() || i < cs1.length()) { [EOL]         return i; [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int indexOfDifference(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return 0; [EOL]     } [EOL]     int i; [EOL]     for (i = 0; i < cs1.length() && i < cs2.length(); ++i) { [EOL]         if (cs1.charAt(i) != cs2.charAt(i)) { [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (i < cs2.length() || i < cs1.length()) { [EOL]         return i; [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int indexOfDifference(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return 0; [EOL]     } [EOL]     int i; [EOL]     for (i = 0; i < cs1.length() && i < cs2.length(); ++i) { [EOL]         if (cs1.charAt(i) != cs2.charAt(i)) { [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (i < cs2.length() || i < cs1.length()) { [EOL]         return i; [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static String prependIfMissing(final String str, final CharSequence prefix, final CharSequence... prefixes) { [EOL]     return prependIfMissing(str, prefix, false, prefixes); [EOL] }
public static String prependIfMissing(final String str, final CharSequence prefix, final CharSequence... prefixes) { [EOL]     return prependIfMissing(str, prefix, false, prefixes); [EOL] }
public static String prependIfMissing(final String str, final CharSequence prefix, final CharSequence... prefixes) { [EOL]     return prependIfMissing(str, prefix, false, prefixes); [EOL] }
public static String prependIfMissing(final String str, final CharSequence prefix, final CharSequence... prefixes) { [EOL]     return prependIfMissing(str, prefix, false, prefixes); [EOL] }
public static String prependIfMissing(final String str, final CharSequence prefix, final CharSequence... prefixes) { [EOL]     return prependIfMissing(str, prefix, false, prefixes); [EOL] }
public static String prependIfMissing(final String str, final CharSequence prefix, final CharSequence... prefixes) { [EOL]     return prependIfMissing(str, prefix, false, prefixes); [EOL] }
public static String prependIfMissing(final String str, final CharSequence prefix, final CharSequence... prefixes) { [EOL]     return prependIfMissing(str, prefix, false, prefixes); [EOL] }
public MutableDouble() { [EOL]     super(); [EOL] }
public MutableDouble(final double value) { [EOL]     super(); [EOL]     this.value = value; [EOL] }
public MutableDouble(final Number value) { [EOL]     super(); [EOL]     this.value = value.doubleValue(); [EOL] }
public MutableDouble(final Number value) { [EOL]     super(); [EOL]     this.value = value.doubleValue(); [EOL] }
public MutableDouble(final Number value) { [EOL]     super(); [EOL]     this.value = value.doubleValue(); [EOL] }
public MutableDouble(final String value) throws NumberFormatException { [EOL]     super(); [EOL]     this.value = Double.parseDouble(value); [EOL] }
public MutableDouble(final String value) throws NumberFormatException { [EOL]     super(); [EOL]     this.value = Double.parseDouble(value); [EOL] }
@Override [EOL] public Double getValue() { [EOL]     return Double.valueOf(this.value); [EOL] }
public void setValue(final double value) { [EOL]     this.value = value; [EOL] }
@Override [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL]     int max = longest; [EOL]     if (index + longest > input.length()) { [EOL]         max = input.length() - index; [EOL]     } [EOL]     for (int i = max; i >= shortest; i--) { [EOL]         final CharSequence subSeq = input.subSequence(index, index + i); [EOL]         final CharSequence result = lookupMap.get(subSeq.toString()); [EOL]         if (result != null) { [EOL]             out.write(result.toString()); [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return 0; [EOL] }
static Map<Object, Object> getRegistry() { [EOL]     return REGISTRY.get(); [EOL] } protected ToStringStyle();  DefaultToStringStyle();  NoFieldNameToStringStyle();  ShortPrefixToStringStyle();  SimpleToStringStyle();  MultiLineToStringStyle();  static Map<Object, Object> getRegistry();  static boolean isRegistered(final Object value);  static void register(final Object value);  static void unregister(final Object value); public void appendSuper(final StringBuffer buffer, final String superToString); public void appendToString(final StringBuffer buffer, final String toString); public void appendStart(final StringBuffer buffer, final Object object); public void appendEnd(final StringBuffer buffer, final Object object); protected void removeLastFieldSeparator(final StringBuffer buffer); public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); public void append(final StringBuffer buffer, final String fieldName, final long value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); public void append(final StringBuffer buffer, final String fieldName, final int value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); public void append(final StringBuffer buffer, final String fieldName, final short value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); public void append(final StringBuffer buffer, final String fieldName, final byte value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); public void append(final StringBuffer buffer, final String fieldName, final char value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); public void append(final StringBuffer buffer, final String fieldName, final double value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); public void append(final StringBuffer buffer, final String fieldName, final float value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); public void append(final StringBuffer buffer, final String fieldName, final boolean value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendClassName(final StringBuffer buffer, final Object object); protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); protected void appendContentStart(final StringBuffer buffer); protected void appendContentEnd(final StringBuffer buffer); protected void appendNullText(final StringBuffer buffer, final String fieldName); protected void appendFieldSeparator(final StringBuffer buffer); protected void appendFieldStart(final StringBuffer buffer, final String fieldName); protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); protected boolean isFullDetail(final Boolean fullDetailRequest); protected String getShortClassName(final Class<?> cls); protected boolean isUseClassName(); protected void setUseClassName(final boolean useClassName); protected boolean isUseShortClassName(); protected void setUseShortClassName(final boolean useShortClassName); protected boolean isUseIdentityHashCode(); protected void setUseIdentityHashCode(final boolean useIdentityHashCode); protected boolean isUseFieldNames(); protected void setUseFieldNames(final boolean useFieldNames); protected boolean isDefaultFullDetail(); protected void setDefaultFullDetail(final boolean defaultFullDetail); protected boolean isArrayContentDetail(); protected void setArrayContentDetail(final boolean arrayContentDetail); protected String getArrayStart(); protected void setArrayStart(String arrayStart); protected String getArrayEnd(); protected void setArrayEnd(String arrayEnd); protected String getArraySeparator(); protected void setArraySeparator(String arraySeparator); protected String getContentStart(); protected void setContentStart(String contentStart); protected String getContentEnd(); protected void setContentEnd(String contentEnd); protected String getFieldNameValueSeparator(); protected void setFieldNameValueSeparator(String fieldNameValueSeparator); protected String getFieldSeparator(); protected void setFieldSeparator(String fieldSeparator); protected boolean isFieldSeparatorAtStart(); protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); protected boolean isFieldSeparatorAtEnd(); protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); protected String getNullText(); protected void setNullText(String nullText); protected String getSizeStartText(); protected void setSizeStartText(String sizeStartText); protected String getSizeEndText(); protected void setSizeEndText(String sizeEndText); protected String getSummaryObjectStartText(); protected void setSummaryObjectStartText(String summaryObjectStartText); protected String getSummaryObjectEndText(); protected void setSummaryObjectEndText(String summaryObjectEndText); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); long serialVersionUID=Optional[-2587890625525655916L]; ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; boolean useFieldNames=Optional[true]; boolean useClassName=Optional[true]; boolean useShortClassName=Optional[false]; boolean useIdentityHashCode=Optional[true]; String contentStart=Optional["["]; String contentEnd=Optional["]"]; String fieldNameValueSeparator=Optional["="]; boolean fieldSeparatorAtStart=Optional[false]; boolean fieldSeparatorAtEnd=Optional[false]; String fieldSeparator=Optional[","]; String arrayStart=Optional["{"]; String arraySeparator=Optional[","]; boolean arrayContentDetail=Optional[true]; String arrayEnd=Optional["}
static boolean isRegistered(final Object value) { [EOL]     final Map<Object, Object> m = getRegistry(); [EOL]     return m != null && m.containsKey(value); [EOL] } protected ToStringStyle();  DefaultToStringStyle();  NoFieldNameToStringStyle();  ShortPrefixToStringStyle();  SimpleToStringStyle();  MultiLineToStringStyle();  static Map<Object, Object> getRegistry();  static boolean isRegistered(final Object value);  static void register(final Object value);  static void unregister(final Object value); public void appendSuper(final StringBuffer buffer, final String superToString); public void appendToString(final StringBuffer buffer, final String toString); public void appendStart(final StringBuffer buffer, final Object object); public void appendEnd(final StringBuffer buffer, final Object object); protected void removeLastFieldSeparator(final StringBuffer buffer); public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); public void append(final StringBuffer buffer, final String fieldName, final long value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); public void append(final StringBuffer buffer, final String fieldName, final int value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); public void append(final StringBuffer buffer, final String fieldName, final short value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); public void append(final StringBuffer buffer, final String fieldName, final byte value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); public void append(final StringBuffer buffer, final String fieldName, final char value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); public void append(final StringBuffer buffer, final String fieldName, final double value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); public void append(final StringBuffer buffer, final String fieldName, final float value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); public void append(final StringBuffer buffer, final String fieldName, final boolean value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendClassName(final StringBuffer buffer, final Object object); protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); protected void appendContentStart(final StringBuffer buffer); protected void appendContentEnd(final StringBuffer buffer); protected void appendNullText(final StringBuffer buffer, final String fieldName); protected void appendFieldSeparator(final StringBuffer buffer); protected void appendFieldStart(final StringBuffer buffer, final String fieldName); protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); protected boolean isFullDetail(final Boolean fullDetailRequest); protected String getShortClassName(final Class<?> cls); protected boolean isUseClassName(); protected void setUseClassName(final boolean useClassName); protected boolean isUseShortClassName(); protected void setUseShortClassName(final boolean useShortClassName); protected boolean isUseIdentityHashCode(); protected void setUseIdentityHashCode(final boolean useIdentityHashCode); protected boolean isUseFieldNames(); protected void setUseFieldNames(final boolean useFieldNames); protected boolean isDefaultFullDetail(); protected void setDefaultFullDetail(final boolean defaultFullDetail); protected boolean isArrayContentDetail(); protected void setArrayContentDetail(final boolean arrayContentDetail); protected String getArrayStart(); protected void setArrayStart(String arrayStart); protected String getArrayEnd(); protected void setArrayEnd(String arrayEnd); protected String getArraySeparator(); protected void setArraySeparator(String arraySeparator); protected String getContentStart(); protected void setContentStart(String contentStart); protected String getContentEnd(); protected void setContentEnd(String contentEnd); protected String getFieldNameValueSeparator(); protected void setFieldNameValueSeparator(String fieldNameValueSeparator); protected String getFieldSeparator(); protected void setFieldSeparator(String fieldSeparator); protected boolean isFieldSeparatorAtStart(); protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); protected boolean isFieldSeparatorAtEnd(); protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); protected String getNullText(); protected void setNullText(String nullText); protected String getSizeStartText(); protected void setSizeStartText(String sizeStartText); protected String getSizeEndText(); protected void setSizeEndText(String sizeEndText); protected String getSummaryObjectStartText(); protected void setSummaryObjectStartText(String summaryObjectStartText); protected String getSummaryObjectEndText(); protected void setSummaryObjectEndText(String summaryObjectEndText); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); long serialVersionUID=Optional[-2587890625525655916L]; ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; boolean useFieldNames=Optional[true]; boolean useClassName=Optional[true]; boolean useShortClassName=Optional[false]; boolean useIdentityHashCode=Optional[true]; String contentStart=Optional["["]; String contentEnd=Optional["]"]; String fieldNameValueSeparator=Optional["="]; boolean fieldSeparatorAtStart=Optional[false]; boolean fieldSeparatorAtEnd=Optional[false]; String fieldSeparator=Optional[","]; String arrayStart=Optional["{"]; String arraySeparator=Optional[","]; boolean arrayContentDetail=Optional[true]; String arrayEnd=Optional["}
static boolean isRegistered(final Object value) { [EOL]     final Map<Object, Object> m = getRegistry(); [EOL]     return m != null && m.containsKey(value); [EOL] } protected ToStringStyle();  DefaultToStringStyle();  NoFieldNameToStringStyle();  ShortPrefixToStringStyle();  SimpleToStringStyle();  MultiLineToStringStyle();  static Map<Object, Object> getRegistry();  static boolean isRegistered(final Object value);  static void register(final Object value);  static void unregister(final Object value); public void appendSuper(final StringBuffer buffer, final String superToString); public void appendToString(final StringBuffer buffer, final String toString); public void appendStart(final StringBuffer buffer, final Object object); public void appendEnd(final StringBuffer buffer, final Object object); protected void removeLastFieldSeparator(final StringBuffer buffer); public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); public void append(final StringBuffer buffer, final String fieldName, final long value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); public void append(final StringBuffer buffer, final String fieldName, final int value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); public void append(final StringBuffer buffer, final String fieldName, final short value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); public void append(final StringBuffer buffer, final String fieldName, final byte value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); public void append(final StringBuffer buffer, final String fieldName, final char value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); public void append(final StringBuffer buffer, final String fieldName, final double value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); public void append(final StringBuffer buffer, final String fieldName, final float value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); public void append(final StringBuffer buffer, final String fieldName, final boolean value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendClassName(final StringBuffer buffer, final Object object); protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); protected void appendContentStart(final StringBuffer buffer); protected void appendContentEnd(final StringBuffer buffer); protected void appendNullText(final StringBuffer buffer, final String fieldName); protected void appendFieldSeparator(final StringBuffer buffer); protected void appendFieldStart(final StringBuffer buffer, final String fieldName); protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); protected boolean isFullDetail(final Boolean fullDetailRequest); protected String getShortClassName(final Class<?> cls); protected boolean isUseClassName(); protected void setUseClassName(final boolean useClassName); protected boolean isUseShortClassName(); protected void setUseShortClassName(final boolean useShortClassName); protected boolean isUseIdentityHashCode(); protected void setUseIdentityHashCode(final boolean useIdentityHashCode); protected boolean isUseFieldNames(); protected void setUseFieldNames(final boolean useFieldNames); protected boolean isDefaultFullDetail(); protected void setDefaultFullDetail(final boolean defaultFullDetail); protected boolean isArrayContentDetail(); protected void setArrayContentDetail(final boolean arrayContentDetail); protected String getArrayStart(); protected void setArrayStart(String arrayStart); protected String getArrayEnd(); protected void setArrayEnd(String arrayEnd); protected String getArraySeparator(); protected void setArraySeparator(String arraySeparator); protected String getContentStart(); protected void setContentStart(String contentStart); protected String getContentEnd(); protected void setContentEnd(String contentEnd); protected String getFieldNameValueSeparator(); protected void setFieldNameValueSeparator(String fieldNameValueSeparator); protected String getFieldSeparator(); protected void setFieldSeparator(String fieldSeparator); protected boolean isFieldSeparatorAtStart(); protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); protected boolean isFieldSeparatorAtEnd(); protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); protected String getNullText(); protected void setNullText(String nullText); protected String getSizeStartText(); protected void setSizeStartText(String sizeStartText); protected String getSizeEndText(); protected void setSizeEndText(String sizeEndText); protected String getSummaryObjectStartText(); protected void setSummaryObjectStartText(String summaryObjectStartText); protected String getSummaryObjectEndText(); protected void setSummaryObjectEndText(String summaryObjectEndText); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); long serialVersionUID=Optional[-2587890625525655916L]; ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; boolean useFieldNames=Optional[true]; boolean useClassName=Optional[true]; boolean useShortClassName=Optional[false]; boolean useIdentityHashCode=Optional[true]; String contentStart=Optional["["]; String contentEnd=Optional["]"]; String fieldNameValueSeparator=Optional["="]; boolean fieldSeparatorAtStart=Optional[false]; boolean fieldSeparatorAtEnd=Optional[false]; String fieldSeparator=Optional[","]; String arrayStart=Optional["{"]; String arraySeparator=Optional[","]; boolean arrayContentDetail=Optional[true]; String arrayEnd=Optional["}
static boolean isRegistered(final Object value) { [EOL]     final Map<Object, Object> m = getRegistry(); [EOL]     return m != null && m.containsKey(value); [EOL] } protected ToStringStyle();  DefaultToStringStyle();  NoFieldNameToStringStyle();  ShortPrefixToStringStyle();  SimpleToStringStyle();  MultiLineToStringStyle();  static Map<Object, Object> getRegistry();  static boolean isRegistered(final Object value);  static void register(final Object value);  static void unregister(final Object value); public void appendSuper(final StringBuffer buffer, final String superToString); public void appendToString(final StringBuffer buffer, final String toString); public void appendStart(final StringBuffer buffer, final Object object); public void appendEnd(final StringBuffer buffer, final Object object); protected void removeLastFieldSeparator(final StringBuffer buffer); public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); public void append(final StringBuffer buffer, final String fieldName, final long value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); public void append(final StringBuffer buffer, final String fieldName, final int value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); public void append(final StringBuffer buffer, final String fieldName, final short value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); public void append(final StringBuffer buffer, final String fieldName, final byte value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); public void append(final StringBuffer buffer, final String fieldName, final char value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); public void append(final StringBuffer buffer, final String fieldName, final double value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); public void append(final StringBuffer buffer, final String fieldName, final float value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); public void append(final StringBuffer buffer, final String fieldName, final boolean value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendClassName(final StringBuffer buffer, final Object object); protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); protected void appendContentStart(final StringBuffer buffer); protected void appendContentEnd(final StringBuffer buffer); protected void appendNullText(final StringBuffer buffer, final String fieldName); protected void appendFieldSeparator(final StringBuffer buffer); protected void appendFieldStart(final StringBuffer buffer, final String fieldName); protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); protected boolean isFullDetail(final Boolean fullDetailRequest); protected String getShortClassName(final Class<?> cls); protected boolean isUseClassName(); protected void setUseClassName(final boolean useClassName); protected boolean isUseShortClassName(); protected void setUseShortClassName(final boolean useShortClassName); protected boolean isUseIdentityHashCode(); protected void setUseIdentityHashCode(final boolean useIdentityHashCode); protected boolean isUseFieldNames(); protected void setUseFieldNames(final boolean useFieldNames); protected boolean isDefaultFullDetail(); protected void setDefaultFullDetail(final boolean defaultFullDetail); protected boolean isArrayContentDetail(); protected void setArrayContentDetail(final boolean arrayContentDetail); protected String getArrayStart(); protected void setArrayStart(String arrayStart); protected String getArrayEnd(); protected void setArrayEnd(String arrayEnd); protected String getArraySeparator(); protected void setArraySeparator(String arraySeparator); protected String getContentStart(); protected void setContentStart(String contentStart); protected String getContentEnd(); protected void setContentEnd(String contentEnd); protected String getFieldNameValueSeparator(); protected void setFieldNameValueSeparator(String fieldNameValueSeparator); protected String getFieldSeparator(); protected void setFieldSeparator(String fieldSeparator); protected boolean isFieldSeparatorAtStart(); protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); protected boolean isFieldSeparatorAtEnd(); protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); protected String getNullText(); protected void setNullText(String nullText); protected String getSizeStartText(); protected void setSizeStartText(String sizeStartText); protected String getSizeEndText(); protected void setSizeEndText(String sizeEndText); protected String getSummaryObjectStartText(); protected void setSummaryObjectStartText(String summaryObjectStartText); protected String getSummaryObjectEndText(); protected void setSummaryObjectEndText(String summaryObjectEndText); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); long serialVersionUID=Optional[-2587890625525655916L]; ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; boolean useFieldNames=Optional[true]; boolean useClassName=Optional[true]; boolean useShortClassName=Optional[false]; boolean useIdentityHashCode=Optional[true]; String contentStart=Optional["["]; String contentEnd=Optional["]"]; String fieldNameValueSeparator=Optional["="]; boolean fieldSeparatorAtStart=Optional[false]; boolean fieldSeparatorAtEnd=Optional[false]; String fieldSeparator=Optional[","]; String arrayStart=Optional["{"]; String arraySeparator=Optional[","]; boolean arrayContentDetail=Optional[true]; String arrayEnd=Optional["}
static void register(final Object value) { [EOL]     if (value != null) { [EOL]         final Map<Object, Object> m = getRegistry(); [EOL]         if (m == null) { [EOL]             REGISTRY.set(new WeakHashMap<Object, Object>()); [EOL]         } [EOL]         getRegistry().put(value, null); [EOL]     } [EOL] } protected ToStringStyle();  DefaultToStringStyle();  NoFieldNameToStringStyle();  ShortPrefixToStringStyle();  SimpleToStringStyle();  MultiLineToStringStyle();  static Map<Object, Object> getRegistry();  static boolean isRegistered(final Object value);  static void register(final Object value);  static void unregister(final Object value); public void appendSuper(final StringBuffer buffer, final String superToString); public void appendToString(final StringBuffer buffer, final String toString); public void appendStart(final StringBuffer buffer, final Object object); public void appendEnd(final StringBuffer buffer, final Object object); protected void removeLastFieldSeparator(final StringBuffer buffer); public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); public void append(final StringBuffer buffer, final String fieldName, final long value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); public void append(final StringBuffer buffer, final String fieldName, final int value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); public void append(final StringBuffer buffer, final String fieldName, final short value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); public void append(final StringBuffer buffer, final String fieldName, final byte value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); public void append(final StringBuffer buffer, final String fieldName, final char value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); public void append(final StringBuffer buffer, final String fieldName, final double value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); public void append(final StringBuffer buffer, final String fieldName, final float value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); public void append(final StringBuffer buffer, final String fieldName, final boolean value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendClassName(final StringBuffer buffer, final Object object); protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); protected void appendContentStart(final StringBuffer buffer); protected void appendContentEnd(final StringBuffer buffer); protected void appendNullText(final StringBuffer buffer, final String fieldName); protected void appendFieldSeparator(final StringBuffer buffer); protected void appendFieldStart(final StringBuffer buffer, final String fieldName); protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); protected boolean isFullDetail(final Boolean fullDetailRequest); protected String getShortClassName(final Class<?> cls); protected boolean isUseClassName(); protected void setUseClassName(final boolean useClassName); protected boolean isUseShortClassName(); protected void setUseShortClassName(final boolean useShortClassName); protected boolean isUseIdentityHashCode(); protected void setUseIdentityHashCode(final boolean useIdentityHashCode); protected boolean isUseFieldNames(); protected void setUseFieldNames(final boolean useFieldNames); protected boolean isDefaultFullDetail(); protected void setDefaultFullDetail(final boolean defaultFullDetail); protected boolean isArrayContentDetail(); protected void setArrayContentDetail(final boolean arrayContentDetail); protected String getArrayStart(); protected void setArrayStart(String arrayStart); protected String getArrayEnd(); protected void setArrayEnd(String arrayEnd); protected String getArraySeparator(); protected void setArraySeparator(String arraySeparator); protected String getContentStart(); protected void setContentStart(String contentStart); protected String getContentEnd(); protected void setContentEnd(String contentEnd); protected String getFieldNameValueSeparator(); protected void setFieldNameValueSeparator(String fieldNameValueSeparator); protected String getFieldSeparator(); protected void setFieldSeparator(String fieldSeparator); protected boolean isFieldSeparatorAtStart(); protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); protected boolean isFieldSeparatorAtEnd(); protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); protected String getNullText(); protected void setNullText(String nullText); protected String getSizeStartText(); protected void setSizeStartText(String sizeStartText); protected String getSizeEndText(); protected void setSizeEndText(String sizeEndText); protected String getSummaryObjectStartText(); protected void setSummaryObjectStartText(String summaryObjectStartText); protected String getSummaryObjectEndText(); protected void setSummaryObjectEndText(String summaryObjectEndText); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); long serialVersionUID=Optional[-2587890625525655916L]; ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; boolean useFieldNames=Optional[true]; boolean useClassName=Optional[true]; boolean useShortClassName=Optional[false]; boolean useIdentityHashCode=Optional[true]; String contentStart=Optional["["]; String contentEnd=Optional["]"]; String fieldNameValueSeparator=Optional["="]; boolean fieldSeparatorAtStart=Optional[false]; boolean fieldSeparatorAtEnd=Optional[false]; String fieldSeparator=Optional[","]; String arrayStart=Optional["{"]; String arraySeparator=Optional[","]; boolean arrayContentDetail=Optional[true]; String arrayEnd=Optional["}
static void unregister(final Object value) { [EOL]     if (value != null) { [EOL]         final Map<Object, Object> m = getRegistry(); [EOL]         if (m != null) { [EOL]             m.remove(value); [EOL]             if (m.isEmpty()) { [EOL]                 REGISTRY.remove(); [EOL]             } [EOL]         } [EOL]     } [EOL] } protected ToStringStyle();  DefaultToStringStyle();  NoFieldNameToStringStyle();  ShortPrefixToStringStyle();  SimpleToStringStyle();  MultiLineToStringStyle();  static Map<Object, Object> getRegistry();  static boolean isRegistered(final Object value);  static void register(final Object value);  static void unregister(final Object value); public void appendSuper(final StringBuffer buffer, final String superToString); public void appendToString(final StringBuffer buffer, final String toString); public void appendStart(final StringBuffer buffer, final Object object); public void appendEnd(final StringBuffer buffer, final Object object); protected void removeLastFieldSeparator(final StringBuffer buffer); public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); public void append(final StringBuffer buffer, final String fieldName, final long value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); public void append(final StringBuffer buffer, final String fieldName, final int value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); public void append(final StringBuffer buffer, final String fieldName, final short value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); public void append(final StringBuffer buffer, final String fieldName, final byte value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); public void append(final StringBuffer buffer, final String fieldName, final char value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); public void append(final StringBuffer buffer, final String fieldName, final double value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); public void append(final StringBuffer buffer, final String fieldName, final float value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); public void append(final StringBuffer buffer, final String fieldName, final boolean value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendClassName(final StringBuffer buffer, final Object object); protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); protected void appendContentStart(final StringBuffer buffer); protected void appendContentEnd(final StringBuffer buffer); protected void appendNullText(final StringBuffer buffer, final String fieldName); protected void appendFieldSeparator(final StringBuffer buffer); protected void appendFieldStart(final StringBuffer buffer, final String fieldName); protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); protected boolean isFullDetail(final Boolean fullDetailRequest); protected String getShortClassName(final Class<?> cls); protected boolean isUseClassName(); protected void setUseClassName(final boolean useClassName); protected boolean isUseShortClassName(); protected void setUseShortClassName(final boolean useShortClassName); protected boolean isUseIdentityHashCode(); protected void setUseIdentityHashCode(final boolean useIdentityHashCode); protected boolean isUseFieldNames(); protected void setUseFieldNames(final boolean useFieldNames); protected boolean isDefaultFullDetail(); protected void setDefaultFullDetail(final boolean defaultFullDetail); protected boolean isArrayContentDetail(); protected void setArrayContentDetail(final boolean arrayContentDetail); protected String getArrayStart(); protected void setArrayStart(String arrayStart); protected String getArrayEnd(); protected void setArrayEnd(String arrayEnd); protected String getArraySeparator(); protected void setArraySeparator(String arraySeparator); protected String getContentStart(); protected void setContentStart(String contentStart); protected String getContentEnd(); protected void setContentEnd(String contentEnd); protected String getFieldNameValueSeparator(); protected void setFieldNameValueSeparator(String fieldNameValueSeparator); protected String getFieldSeparator(); protected void setFieldSeparator(String fieldSeparator); protected boolean isFieldSeparatorAtStart(); protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); protected boolean isFieldSeparatorAtEnd(); protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); protected String getNullText(); protected void setNullText(String nullText); protected String getSizeStartText(); protected void setSizeStartText(String sizeStartText); protected String getSizeEndText(); protected void setSizeEndText(String sizeEndText); protected String getSummaryObjectStartText(); protected void setSummaryObjectStartText(String summaryObjectStartText); protected String getSummaryObjectEndText(); protected void setSummaryObjectEndText(String summaryObjectEndText); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); long serialVersionUID=Optional[-2587890625525655916L]; ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; boolean useFieldNames=Optional[true]; boolean useClassName=Optional[true]; boolean useShortClassName=Optional[false]; boolean useIdentityHashCode=Optional[true]; String contentStart=Optional["["]; String contentEnd=Optional["]"]; String fieldNameValueSeparator=Optional["="]; boolean fieldSeparatorAtStart=Optional[false]; boolean fieldSeparatorAtEnd=Optional[false]; String fieldSeparator=Optional[","]; String arrayStart=Optional["{"]; String arraySeparator=Optional[","]; boolean arrayContentDetail=Optional[true]; String arrayEnd=Optional["}
protected ToStringStyle() { [EOL]     super(); [EOL] } protected ToStringStyle();  DefaultToStringStyle();  NoFieldNameToStringStyle();  ShortPrefixToStringStyle();  SimpleToStringStyle();  MultiLineToStringStyle();  static Map<Object, Object> getRegistry();  static boolean isRegistered(final Object value);  static void register(final Object value);  static void unregister(final Object value); public void appendSuper(final StringBuffer buffer, final String superToString); public void appendToString(final StringBuffer buffer, final String toString); public void appendStart(final StringBuffer buffer, final Object object); public void appendEnd(final StringBuffer buffer, final Object object); protected void removeLastFieldSeparator(final StringBuffer buffer); public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); public void append(final StringBuffer buffer, final String fieldName, final long value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); public void append(final StringBuffer buffer, final String fieldName, final int value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); public void append(final StringBuffer buffer, final String fieldName, final short value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); public void append(final StringBuffer buffer, final String fieldName, final byte value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); public void append(final StringBuffer buffer, final String fieldName, final char value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); public void append(final StringBuffer buffer, final String fieldName, final double value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); public void append(final StringBuffer buffer, final String fieldName, final float value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); public void append(final StringBuffer buffer, final String fieldName, final boolean value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendClassName(final StringBuffer buffer, final Object object); protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); protected void appendContentStart(final StringBuffer buffer); protected void appendContentEnd(final StringBuffer buffer); protected void appendNullText(final StringBuffer buffer, final String fieldName); protected void appendFieldSeparator(final StringBuffer buffer); protected void appendFieldStart(final StringBuffer buffer, final String fieldName); protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); protected boolean isFullDetail(final Boolean fullDetailRequest); protected String getShortClassName(final Class<?> cls); protected boolean isUseClassName(); protected void setUseClassName(final boolean useClassName); protected boolean isUseShortClassName(); protected void setUseShortClassName(final boolean useShortClassName); protected boolean isUseIdentityHashCode(); protected void setUseIdentityHashCode(final boolean useIdentityHashCode); protected boolean isUseFieldNames(); protected void setUseFieldNames(final boolean useFieldNames); protected boolean isDefaultFullDetail(); protected void setDefaultFullDetail(final boolean defaultFullDetail); protected boolean isArrayContentDetail(); protected void setArrayContentDetail(final boolean arrayContentDetail); protected String getArrayStart(); protected void setArrayStart(String arrayStart); protected String getArrayEnd(); protected void setArrayEnd(String arrayEnd); protected String getArraySeparator(); protected void setArraySeparator(String arraySeparator); protected String getContentStart(); protected void setContentStart(String contentStart); protected String getContentEnd(); protected void setContentEnd(String contentEnd); protected String getFieldNameValueSeparator(); protected void setFieldNameValueSeparator(String fieldNameValueSeparator); protected String getFieldSeparator(); protected void setFieldSeparator(String fieldSeparator); protected boolean isFieldSeparatorAtStart(); protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); protected boolean isFieldSeparatorAtEnd(); protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); protected String getNullText(); protected void setNullText(String nullText); protected String getSizeStartText(); protected void setSizeStartText(String sizeStartText); protected String getSizeEndText(); protected void setSizeEndText(String sizeEndText); protected String getSummaryObjectStartText(); protected void setSummaryObjectStartText(String summaryObjectStartText); protected String getSummaryObjectEndText(); protected void setSummaryObjectEndText(String summaryObjectEndText); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); long serialVersionUID=Optional[-2587890625525655916L]; ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; boolean useFieldNames=Optional[true]; boolean useClassName=Optional[true]; boolean useShortClassName=Optional[false]; boolean useIdentityHashCode=Optional[true]; String contentStart=Optional["["]; String contentEnd=Optional["]"]; String fieldNameValueSeparator=Optional["="]; boolean fieldSeparatorAtStart=Optional[false]; boolean fieldSeparatorAtEnd=Optional[false]; String fieldSeparator=Optional[","]; String arrayStart=Optional["{"]; String arraySeparator=Optional[","]; boolean arrayContentDetail=Optional[true]; String arrayEnd=Optional["}
public void appendStart(final StringBuffer buffer, final Object object) { [EOL]     if (object != null) { [EOL]         appendClassName(buffer, object); [EOL]         appendIdentityHashCode(buffer, object); [EOL]         appendContentStart(buffer); [EOL]         if (fieldSeparatorAtStart) { [EOL]             appendFieldSeparator(buffer); [EOL]         } [EOL]     } [EOL] } protected ToStringStyle();  DefaultToStringStyle();  NoFieldNameToStringStyle();  ShortPrefixToStringStyle();  SimpleToStringStyle();  MultiLineToStringStyle();  static Map<Object, Object> getRegistry();  static boolean isRegistered(final Object value);  static void register(final Object value);  static void unregister(final Object value); public void appendSuper(final StringBuffer buffer, final String superToString); public void appendToString(final StringBuffer buffer, final String toString); public void appendStart(final StringBuffer buffer, final Object object); public void appendEnd(final StringBuffer buffer, final Object object); protected void removeLastFieldSeparator(final StringBuffer buffer); public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); public void append(final StringBuffer buffer, final String fieldName, final long value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); public void append(final StringBuffer buffer, final String fieldName, final int value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); public void append(final StringBuffer buffer, final String fieldName, final short value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); public void append(final StringBuffer buffer, final String fieldName, final byte value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); public void append(final StringBuffer buffer, final String fieldName, final char value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); public void append(final StringBuffer buffer, final String fieldName, final double value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); public void append(final StringBuffer buffer, final String fieldName, final float value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); public void append(final StringBuffer buffer, final String fieldName, final boolean value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendClassName(final StringBuffer buffer, final Object object); protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); protected void appendContentStart(final StringBuffer buffer); protected void appendContentEnd(final StringBuffer buffer); protected void appendNullText(final StringBuffer buffer, final String fieldName); protected void appendFieldSeparator(final StringBuffer buffer); protected void appendFieldStart(final StringBuffer buffer, final String fieldName); protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); protected boolean isFullDetail(final Boolean fullDetailRequest); protected String getShortClassName(final Class<?> cls); protected boolean isUseClassName(); protected void setUseClassName(final boolean useClassName); protected boolean isUseShortClassName(); protected void setUseShortClassName(final boolean useShortClassName); protected boolean isUseIdentityHashCode(); protected void setUseIdentityHashCode(final boolean useIdentityHashCode); protected boolean isUseFieldNames(); protected void setUseFieldNames(final boolean useFieldNames); protected boolean isDefaultFullDetail(); protected void setDefaultFullDetail(final boolean defaultFullDetail); protected boolean isArrayContentDetail(); protected void setArrayContentDetail(final boolean arrayContentDetail); protected String getArrayStart(); protected void setArrayStart(String arrayStart); protected String getArrayEnd(); protected void setArrayEnd(String arrayEnd); protected String getArraySeparator(); protected void setArraySeparator(String arraySeparator); protected String getContentStart(); protected void setContentStart(String contentStart); protected String getContentEnd(); protected void setContentEnd(String contentEnd); protected String getFieldNameValueSeparator(); protected void setFieldNameValueSeparator(String fieldNameValueSeparator); protected String getFieldSeparator(); protected void setFieldSeparator(String fieldSeparator); protected boolean isFieldSeparatorAtStart(); protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); protected boolean isFieldSeparatorAtEnd(); protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); protected String getNullText(); protected void setNullText(String nullText); protected String getSizeStartText(); protected void setSizeStartText(String sizeStartText); protected String getSizeEndText(); protected void setSizeEndText(String sizeEndText); protected String getSummaryObjectStartText(); protected void setSummaryObjectStartText(String summaryObjectStartText); protected String getSummaryObjectEndText(); protected void setSummaryObjectEndText(String summaryObjectEndText); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); long serialVersionUID=Optional[-2587890625525655916L]; ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; boolean useFieldNames=Optional[true]; boolean useClassName=Optional[true]; boolean useShortClassName=Optional[false]; boolean useIdentityHashCode=Optional[true]; String contentStart=Optional["["]; String contentEnd=Optional["]"]; String fieldNameValueSeparator=Optional["="]; boolean fieldSeparatorAtStart=Optional[false]; boolean fieldSeparatorAtEnd=Optional[false]; String fieldSeparator=Optional[","]; String arrayStart=Optional["{"]; String arraySeparator=Optional[","]; boolean arrayContentDetail=Optional[true]; String arrayEnd=Optional["}
public void appendStart(final StringBuffer buffer, final Object object) { [EOL]     if (object != null) { [EOL]         appendClassName(buffer, object); [EOL]         appendIdentityHashCode(buffer, object); [EOL]         appendContentStart(buffer); [EOL]         if (fieldSeparatorAtStart) { [EOL]             appendFieldSeparator(buffer); [EOL]         } [EOL]     } [EOL] } protected ToStringStyle();  DefaultToStringStyle();  NoFieldNameToStringStyle();  ShortPrefixToStringStyle();  SimpleToStringStyle();  MultiLineToStringStyle();  static Map<Object, Object> getRegistry();  static boolean isRegistered(final Object value);  static void register(final Object value);  static void unregister(final Object value); public void appendSuper(final StringBuffer buffer, final String superToString); public void appendToString(final StringBuffer buffer, final String toString); public void appendStart(final StringBuffer buffer, final Object object); public void appendEnd(final StringBuffer buffer, final Object object); protected void removeLastFieldSeparator(final StringBuffer buffer); public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); public void append(final StringBuffer buffer, final String fieldName, final long value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); public void append(final StringBuffer buffer, final String fieldName, final int value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); public void append(final StringBuffer buffer, final String fieldName, final short value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); public void append(final StringBuffer buffer, final String fieldName, final byte value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); public void append(final StringBuffer buffer, final String fieldName, final char value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); public void append(final StringBuffer buffer, final String fieldName, final double value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); public void append(final StringBuffer buffer, final String fieldName, final float value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); public void append(final StringBuffer buffer, final String fieldName, final boolean value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendClassName(final StringBuffer buffer, final Object object); protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); protected void appendContentStart(final StringBuffer buffer); protected void appendContentEnd(final StringBuffer buffer); protected void appendNullText(final StringBuffer buffer, final String fieldName); protected void appendFieldSeparator(final StringBuffer buffer); protected void appendFieldStart(final StringBuffer buffer, final String fieldName); protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); protected boolean isFullDetail(final Boolean fullDetailRequest); protected String getShortClassName(final Class<?> cls); protected boolean isUseClassName(); protected void setUseClassName(final boolean useClassName); protected boolean isUseShortClassName(); protected void setUseShortClassName(final boolean useShortClassName); protected boolean isUseIdentityHashCode(); protected void setUseIdentityHashCode(final boolean useIdentityHashCode); protected boolean isUseFieldNames(); protected void setUseFieldNames(final boolean useFieldNames); protected boolean isDefaultFullDetail(); protected void setDefaultFullDetail(final boolean defaultFullDetail); protected boolean isArrayContentDetail(); protected void setArrayContentDetail(final boolean arrayContentDetail); protected String getArrayStart(); protected void setArrayStart(String arrayStart); protected String getArrayEnd(); protected void setArrayEnd(String arrayEnd); protected String getArraySeparator(); protected void setArraySeparator(String arraySeparator); protected String getContentStart(); protected void setContentStart(String contentStart); protected String getContentEnd(); protected void setContentEnd(String contentEnd); protected String getFieldNameValueSeparator(); protected void setFieldNameValueSeparator(String fieldNameValueSeparator); protected String getFieldSeparator(); protected void setFieldSeparator(String fieldSeparator); protected boolean isFieldSeparatorAtStart(); protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); protected boolean isFieldSeparatorAtEnd(); protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); protected String getNullText(); protected void setNullText(String nullText); protected String getSizeStartText(); protected void setSizeStartText(String sizeStartText); protected String getSizeEndText(); protected void setSizeEndText(String sizeEndText); protected String getSummaryObjectStartText(); protected void setSummaryObjectStartText(String summaryObjectStartText); protected String getSummaryObjectEndText(); protected void setSummaryObjectEndText(String summaryObjectEndText); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); long serialVersionUID=Optional[-2587890625525655916L]; ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; boolean useFieldNames=Optional[true]; boolean useClassName=Optional[true]; boolean useShortClassName=Optional[false]; boolean useIdentityHashCode=Optional[true]; String contentStart=Optional["["]; String contentEnd=Optional["]"]; String fieldNameValueSeparator=Optional["="]; boolean fieldSeparatorAtStart=Optional[false]; boolean fieldSeparatorAtEnd=Optional[false]; String fieldSeparator=Optional[","]; String arrayStart=Optional["{"]; String arraySeparator=Optional[","]; boolean arrayContentDetail=Optional[true]; String arrayEnd=Optional["}
public void appendStart(final StringBuffer buffer, final Object object) { [EOL]     if (object != null) { [EOL]         appendClassName(buffer, object); [EOL]         appendIdentityHashCode(buffer, object); [EOL]         appendContentStart(buffer); [EOL]         if (fieldSeparatorAtStart) { [EOL]             appendFieldSeparator(buffer); [EOL]         } [EOL]     } [EOL] } protected ToStringStyle();  DefaultToStringStyle();  NoFieldNameToStringStyle();  ShortPrefixToStringStyle();  SimpleToStringStyle();  MultiLineToStringStyle();  static Map<Object, Object> getRegistry();  static boolean isRegistered(final Object value);  static void register(final Object value);  static void unregister(final Object value); public void appendSuper(final StringBuffer buffer, final String superToString); public void appendToString(final StringBuffer buffer, final String toString); public void appendStart(final StringBuffer buffer, final Object object); public void appendEnd(final StringBuffer buffer, final Object object); protected void removeLastFieldSeparator(final StringBuffer buffer); public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); public void append(final StringBuffer buffer, final String fieldName, final long value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); public void append(final StringBuffer buffer, final String fieldName, final int value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); public void append(final StringBuffer buffer, final String fieldName, final short value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); public void append(final StringBuffer buffer, final String fieldName, final byte value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); public void append(final StringBuffer buffer, final String fieldName, final char value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); public void append(final StringBuffer buffer, final String fieldName, final double value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); public void append(final StringBuffer buffer, final String fieldName, final float value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); public void append(final StringBuffer buffer, final String fieldName, final boolean value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendClassName(final StringBuffer buffer, final Object object); protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); protected void appendContentStart(final StringBuffer buffer); protected void appendContentEnd(final StringBuffer buffer); protected void appendNullText(final StringBuffer buffer, final String fieldName); protected void appendFieldSeparator(final StringBuffer buffer); protected void appendFieldStart(final StringBuffer buffer, final String fieldName); protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); protected boolean isFullDetail(final Boolean fullDetailRequest); protected String getShortClassName(final Class<?> cls); protected boolean isUseClassName(); protected void setUseClassName(final boolean useClassName); protected boolean isUseShortClassName(); protected void setUseShortClassName(final boolean useShortClassName); protected boolean isUseIdentityHashCode(); protected void setUseIdentityHashCode(final boolean useIdentityHashCode); protected boolean isUseFieldNames(); protected void setUseFieldNames(final boolean useFieldNames); protected boolean isDefaultFullDetail(); protected void setDefaultFullDetail(final boolean defaultFullDetail); protected boolean isArrayContentDetail(); protected void setArrayContentDetail(final boolean arrayContentDetail); protected String getArrayStart(); protected void setArrayStart(String arrayStart); protected String getArrayEnd(); protected void setArrayEnd(String arrayEnd); protected String getArraySeparator(); protected void setArraySeparator(String arraySeparator); protected String getContentStart(); protected void setContentStart(String contentStart); protected String getContentEnd(); protected void setContentEnd(String contentEnd); protected String getFieldNameValueSeparator(); protected void setFieldNameValueSeparator(String fieldNameValueSeparator); protected String getFieldSeparator(); protected void setFieldSeparator(String fieldSeparator); protected boolean isFieldSeparatorAtStart(); protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); protected boolean isFieldSeparatorAtEnd(); protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); protected String getNullText(); protected void setNullText(String nullText); protected String getSizeStartText(); protected void setSizeStartText(String sizeStartText); protected String getSizeEndText(); protected void setSizeEndText(String sizeEndText); protected String getSummaryObjectStartText(); protected void setSummaryObjectStartText(String summaryObjectStartText); protected String getSummaryObjectEndText(); protected void setSummaryObjectEndText(String summaryObjectEndText); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); long serialVersionUID=Optional[-2587890625525655916L]; ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; boolean useFieldNames=Optional[true]; boolean useClassName=Optional[true]; boolean useShortClassName=Optional[false]; boolean useIdentityHashCode=Optional[true]; String contentStart=Optional["["]; String contentEnd=Optional["]"]; String fieldNameValueSeparator=Optional["="]; boolean fieldSeparatorAtStart=Optional[false]; boolean fieldSeparatorAtEnd=Optional[false]; String fieldSeparator=Optional[","]; String arrayStart=Optional["{"]; String arraySeparator=Optional[","]; boolean arrayContentDetail=Optional[true]; String arrayEnd=Optional["}
public void appendEnd(final StringBuffer buffer, final Object object) { [EOL]     if (this.fieldSeparatorAtEnd == false) { [EOL]         removeLastFieldSeparator(buffer); [EOL]     } [EOL]     appendContentEnd(buffer); [EOL]     unregister(object); [EOL] } protected ToStringStyle();  DefaultToStringStyle();  NoFieldNameToStringStyle();  ShortPrefixToStringStyle();  SimpleToStringStyle();  MultiLineToStringStyle();  static Map<Object, Object> getRegistry();  static boolean isRegistered(final Object value);  static void register(final Object value);  static void unregister(final Object value); public void appendSuper(final StringBuffer buffer, final String superToString); public void appendToString(final StringBuffer buffer, final String toString); public void appendStart(final StringBuffer buffer, final Object object); public void appendEnd(final StringBuffer buffer, final Object object); protected void removeLastFieldSeparator(final StringBuffer buffer); public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); public void append(final StringBuffer buffer, final String fieldName, final long value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); public void append(final StringBuffer buffer, final String fieldName, final int value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); public void append(final StringBuffer buffer, final String fieldName, final short value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); public void append(final StringBuffer buffer, final String fieldName, final byte value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); public void append(final StringBuffer buffer, final String fieldName, final char value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); public void append(final StringBuffer buffer, final String fieldName, final double value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); public void append(final StringBuffer buffer, final String fieldName, final float value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); public void append(final StringBuffer buffer, final String fieldName, final boolean value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendClassName(final StringBuffer buffer, final Object object); protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); protected void appendContentStart(final StringBuffer buffer); protected void appendContentEnd(final StringBuffer buffer); protected void appendNullText(final StringBuffer buffer, final String fieldName); protected void appendFieldSeparator(final StringBuffer buffer); protected void appendFieldStart(final StringBuffer buffer, final String fieldName); protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); protected boolean isFullDetail(final Boolean fullDetailRequest); protected String getShortClassName(final Class<?> cls); protected boolean isUseClassName(); protected void setUseClassName(final boolean useClassName); protected boolean isUseShortClassName(); protected void setUseShortClassName(final boolean useShortClassName); protected boolean isUseIdentityHashCode(); protected void setUseIdentityHashCode(final boolean useIdentityHashCode); protected boolean isUseFieldNames(); protected void setUseFieldNames(final boolean useFieldNames); protected boolean isDefaultFullDetail(); protected void setDefaultFullDetail(final boolean defaultFullDetail); protected boolean isArrayContentDetail(); protected void setArrayContentDetail(final boolean arrayContentDetail); protected String getArrayStart(); protected void setArrayStart(String arrayStart); protected String getArrayEnd(); protected void setArrayEnd(String arrayEnd); protected String getArraySeparator(); protected void setArraySeparator(String arraySeparator); protected String getContentStart(); protected void setContentStart(String contentStart); protected String getContentEnd(); protected void setContentEnd(String contentEnd); protected String getFieldNameValueSeparator(); protected void setFieldNameValueSeparator(String fieldNameValueSeparator); protected String getFieldSeparator(); protected void setFieldSeparator(String fieldSeparator); protected boolean isFieldSeparatorAtStart(); protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); protected boolean isFieldSeparatorAtEnd(); protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); protected String getNullText(); protected void setNullText(String nullText); protected String getSizeStartText(); protected void setSizeStartText(String sizeStartText); protected String getSizeEndText(); protected void setSizeEndText(String sizeEndText); protected String getSummaryObjectStartText(); protected void setSummaryObjectStartText(String summaryObjectStartText); protected String getSummaryObjectEndText(); protected void setSummaryObjectEndText(String summaryObjectEndText); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); long serialVersionUID=Optional[-2587890625525655916L]; ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; boolean useFieldNames=Optional[true]; boolean useClassName=Optional[true]; boolean useShortClassName=Optional[false]; boolean useIdentityHashCode=Optional[true]; String contentStart=Optional["["]; String contentEnd=Optional["]"]; String fieldNameValueSeparator=Optional["="]; boolean fieldSeparatorAtStart=Optional[false]; boolean fieldSeparatorAtEnd=Optional[false]; String fieldSeparator=Optional[","]; String arrayStart=Optional["{"]; String arraySeparator=Optional[","]; boolean arrayContentDetail=Optional[true]; String arrayEnd=Optional["}
public void appendEnd(final StringBuffer buffer, final Object object) { [EOL]     if (this.fieldSeparatorAtEnd == false) { [EOL]         removeLastFieldSeparator(buffer); [EOL]     } [EOL]     appendContentEnd(buffer); [EOL]     unregister(object); [EOL] } protected ToStringStyle();  DefaultToStringStyle();  NoFieldNameToStringStyle();  ShortPrefixToStringStyle();  SimpleToStringStyle();  MultiLineToStringStyle();  static Map<Object, Object> getRegistry();  static boolean isRegistered(final Object value);  static void register(final Object value);  static void unregister(final Object value); public void appendSuper(final StringBuffer buffer, final String superToString); public void appendToString(final StringBuffer buffer, final String toString); public void appendStart(final StringBuffer buffer, final Object object); public void appendEnd(final StringBuffer buffer, final Object object); protected void removeLastFieldSeparator(final StringBuffer buffer); public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); public void append(final StringBuffer buffer, final String fieldName, final long value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); public void append(final StringBuffer buffer, final String fieldName, final int value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); public void append(final StringBuffer buffer, final String fieldName, final short value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); public void append(final StringBuffer buffer, final String fieldName, final byte value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); public void append(final StringBuffer buffer, final String fieldName, final char value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); public void append(final StringBuffer buffer, final String fieldName, final double value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); public void append(final StringBuffer buffer, final String fieldName, final float value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); public void append(final StringBuffer buffer, final String fieldName, final boolean value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendClassName(final StringBuffer buffer, final Object object); protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); protected void appendContentStart(final StringBuffer buffer); protected void appendContentEnd(final StringBuffer buffer); protected void appendNullText(final StringBuffer buffer, final String fieldName); protected void appendFieldSeparator(final StringBuffer buffer); protected void appendFieldStart(final StringBuffer buffer, final String fieldName); protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); protected boolean isFullDetail(final Boolean fullDetailRequest); protected String getShortClassName(final Class<?> cls); protected boolean isUseClassName(); protected void setUseClassName(final boolean useClassName); protected boolean isUseShortClassName(); protected void setUseShortClassName(final boolean useShortClassName); protected boolean isUseIdentityHashCode(); protected void setUseIdentityHashCode(final boolean useIdentityHashCode); protected boolean isUseFieldNames(); protected void setUseFieldNames(final boolean useFieldNames); protected boolean isDefaultFullDetail(); protected void setDefaultFullDetail(final boolean defaultFullDetail); protected boolean isArrayContentDetail(); protected void setArrayContentDetail(final boolean arrayContentDetail); protected String getArrayStart(); protected void setArrayStart(String arrayStart); protected String getArrayEnd(); protected void setArrayEnd(String arrayEnd); protected String getArraySeparator(); protected void setArraySeparator(String arraySeparator); protected String getContentStart(); protected void setContentStart(String contentStart); protected String getContentEnd(); protected void setContentEnd(String contentEnd); protected String getFieldNameValueSeparator(); protected void setFieldNameValueSeparator(String fieldNameValueSeparator); protected String getFieldSeparator(); protected void setFieldSeparator(String fieldSeparator); protected boolean isFieldSeparatorAtStart(); protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); protected boolean isFieldSeparatorAtEnd(); protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); protected String getNullText(); protected void setNullText(String nullText); protected String getSizeStartText(); protected void setSizeStartText(String sizeStartText); protected String getSizeEndText(); protected void setSizeEndText(String sizeEndText); protected String getSummaryObjectStartText(); protected void setSummaryObjectStartText(String summaryObjectStartText); protected String getSummaryObjectEndText(); protected void setSummaryObjectEndText(String summaryObjectEndText); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); long serialVersionUID=Optional[-2587890625525655916L]; ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; boolean useFieldNames=Optional[true]; boolean useClassName=Optional[true]; boolean useShortClassName=Optional[false]; boolean useIdentityHashCode=Optional[true]; String contentStart=Optional["["]; String contentEnd=Optional["]"]; String fieldNameValueSeparator=Optional["="]; boolean fieldSeparatorAtStart=Optional[false]; boolean fieldSeparatorAtEnd=Optional[false]; String fieldSeparator=Optional[","]; String arrayStart=Optional["{"]; String arraySeparator=Optional[","]; boolean arrayContentDetail=Optional[true]; String arrayEnd=Optional["}
protected void removeLastFieldSeparator(final StringBuffer buffer) { [EOL]     final int len = buffer.length(); [EOL]     final int sepLen = fieldSeparator.length(); [EOL]     if (len > 0 && sepLen > 0 && len >= sepLen) { [EOL]         boolean match = true; [EOL]         for (int i = 0; i < sepLen; i++) { [EOL]             if (buffer.charAt(len - 1 - i) != fieldSeparator.charAt(sepLen - 1 - i)) { [EOL]                 match = false; [EOL]                 break; [EOL]             } [EOL]         } [EOL]         if (match) { [EOL]             buffer.setLength(len - sepLen); [EOL]         } [EOL]     } [EOL] } protected ToStringStyle();  DefaultToStringStyle();  NoFieldNameToStringStyle();  ShortPrefixToStringStyle();  SimpleToStringStyle();  MultiLineToStringStyle();  static Map<Object, Object> getRegistry();  static boolean isRegistered(final Object value);  static void register(final Object value);  static void unregister(final Object value); public void appendSuper(final StringBuffer buffer, final String superToString); public void appendToString(final StringBuffer buffer, final String toString); public void appendStart(final StringBuffer buffer, final Object object); public void appendEnd(final StringBuffer buffer, final Object object); protected void removeLastFieldSeparator(final StringBuffer buffer); public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); public void append(final StringBuffer buffer, final String fieldName, final long value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); public void append(final StringBuffer buffer, final String fieldName, final int value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); public void append(final StringBuffer buffer, final String fieldName, final short value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); public void append(final StringBuffer buffer, final String fieldName, final byte value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); public void append(final StringBuffer buffer, final String fieldName, final char value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); public void append(final StringBuffer buffer, final String fieldName, final double value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); public void append(final StringBuffer buffer, final String fieldName, final float value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); public void append(final StringBuffer buffer, final String fieldName, final boolean value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendClassName(final StringBuffer buffer, final Object object); protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); protected void appendContentStart(final StringBuffer buffer); protected void appendContentEnd(final StringBuffer buffer); protected void appendNullText(final StringBuffer buffer, final String fieldName); protected void appendFieldSeparator(final StringBuffer buffer); protected void appendFieldStart(final StringBuffer buffer, final String fieldName); protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); protected boolean isFullDetail(final Boolean fullDetailRequest); protected String getShortClassName(final Class<?> cls); protected boolean isUseClassName(); protected void setUseClassName(final boolean useClassName); protected boolean isUseShortClassName(); protected void setUseShortClassName(final boolean useShortClassName); protected boolean isUseIdentityHashCode(); protected void setUseIdentityHashCode(final boolean useIdentityHashCode); protected boolean isUseFieldNames(); protected void setUseFieldNames(final boolean useFieldNames); protected boolean isDefaultFullDetail(); protected void setDefaultFullDetail(final boolean defaultFullDetail); protected boolean isArrayContentDetail(); protected void setArrayContentDetail(final boolean arrayContentDetail); protected String getArrayStart(); protected void setArrayStart(String arrayStart); protected String getArrayEnd(); protected void setArrayEnd(String arrayEnd); protected String getArraySeparator(); protected void setArraySeparator(String arraySeparator); protected String getContentStart(); protected void setContentStart(String contentStart); protected String getContentEnd(); protected void setContentEnd(String contentEnd); protected String getFieldNameValueSeparator(); protected void setFieldNameValueSeparator(String fieldNameValueSeparator); protected String getFieldSeparator(); protected void setFieldSeparator(String fieldSeparator); protected boolean isFieldSeparatorAtStart(); protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); protected boolean isFieldSeparatorAtEnd(); protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); protected String getNullText(); protected void setNullText(String nullText); protected String getSizeStartText(); protected void setSizeStartText(String sizeStartText); protected String getSizeEndText(); protected void setSizeEndText(String sizeEndText); protected String getSummaryObjectStartText(); protected void setSummaryObjectStartText(String summaryObjectStartText); protected String getSummaryObjectEndText(); protected void setSummaryObjectEndText(String summaryObjectEndText); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); long serialVersionUID=Optional[-2587890625525655916L]; ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; boolean useFieldNames=Optional[true]; boolean useClassName=Optional[true]; boolean useShortClassName=Optional[false]; boolean useIdentityHashCode=Optional[true]; String contentStart=Optional["["]; String contentEnd=Optional["]"]; String fieldNameValueSeparator=Optional["="]; boolean fieldSeparatorAtStart=Optional[false]; boolean fieldSeparatorAtEnd=Optional[false]; String fieldSeparator=Optional[","]; String arrayStart=Optional["{"]; String arraySeparator=Optional[","]; boolean arrayContentDetail=Optional[true]; String arrayEnd=Optional["}
public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail) { [EOL]     appendFieldStart(buffer, fieldName); [EOL]     if (value == null) { [EOL]         appendNullText(buffer, fieldName); [EOL]     } else { [EOL]         appendInternal(buffer, fieldName, value, isFullDetail(fullDetail)); [EOL]     } [EOL]     appendFieldEnd(buffer, fieldName); [EOL] } protected ToStringStyle();  DefaultToStringStyle();  NoFieldNameToStringStyle();  ShortPrefixToStringStyle();  SimpleToStringStyle();  MultiLineToStringStyle();  static Map<Object, Object> getRegistry();  static boolean isRegistered(final Object value);  static void register(final Object value);  static void unregister(final Object value); public void appendSuper(final StringBuffer buffer, final String superToString); public void appendToString(final StringBuffer buffer, final String toString); public void appendStart(final StringBuffer buffer, final Object object); public void appendEnd(final StringBuffer buffer, final Object object); protected void removeLastFieldSeparator(final StringBuffer buffer); public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); public void append(final StringBuffer buffer, final String fieldName, final long value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); public void append(final StringBuffer buffer, final String fieldName, final int value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); public void append(final StringBuffer buffer, final String fieldName, final short value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); public void append(final StringBuffer buffer, final String fieldName, final byte value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); public void append(final StringBuffer buffer, final String fieldName, final char value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); public void append(final StringBuffer buffer, final String fieldName, final double value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); public void append(final StringBuffer buffer, final String fieldName, final float value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); public void append(final StringBuffer buffer, final String fieldName, final boolean value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendClassName(final StringBuffer buffer, final Object object); protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); protected void appendContentStart(final StringBuffer buffer); protected void appendContentEnd(final StringBuffer buffer); protected void appendNullText(final StringBuffer buffer, final String fieldName); protected void appendFieldSeparator(final StringBuffer buffer); protected void appendFieldStart(final StringBuffer buffer, final String fieldName); protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); protected boolean isFullDetail(final Boolean fullDetailRequest); protected String getShortClassName(final Class<?> cls); protected boolean isUseClassName(); protected void setUseClassName(final boolean useClassName); protected boolean isUseShortClassName(); protected void setUseShortClassName(final boolean useShortClassName); protected boolean isUseIdentityHashCode(); protected void setUseIdentityHashCode(final boolean useIdentityHashCode); protected boolean isUseFieldNames(); protected void setUseFieldNames(final boolean useFieldNames); protected boolean isDefaultFullDetail(); protected void setDefaultFullDetail(final boolean defaultFullDetail); protected boolean isArrayContentDetail(); protected void setArrayContentDetail(final boolean arrayContentDetail); protected String getArrayStart(); protected void setArrayStart(String arrayStart); protected String getArrayEnd(); protected void setArrayEnd(String arrayEnd); protected String getArraySeparator(); protected void setArraySeparator(String arraySeparator); protected String getContentStart(); protected void setContentStart(String contentStart); protected String getContentEnd(); protected void setContentEnd(String contentEnd); protected String getFieldNameValueSeparator(); protected void setFieldNameValueSeparator(String fieldNameValueSeparator); protected String getFieldSeparator(); protected void setFieldSeparator(String fieldSeparator); protected boolean isFieldSeparatorAtStart(); protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); protected boolean isFieldSeparatorAtEnd(); protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); protected String getNullText(); protected void setNullText(String nullText); protected String getSizeStartText(); protected void setSizeStartText(String sizeStartText); protected String getSizeEndText(); protected void setSizeEndText(String sizeEndText); protected String getSummaryObjectStartText(); protected void setSummaryObjectStartText(String summaryObjectStartText); protected String getSummaryObjectEndText(); protected void setSummaryObjectEndText(String summaryObjectEndText); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); long serialVersionUID=Optional[-2587890625525655916L]; ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; boolean useFieldNames=Optional[true]; boolean useClassName=Optional[true]; boolean useShortClassName=Optional[false]; boolean useIdentityHashCode=Optional[true]; String contentStart=Optional["["]; String contentEnd=Optional["]"]; String fieldNameValueSeparator=Optional["="]; boolean fieldSeparatorAtStart=Optional[false]; boolean fieldSeparatorAtEnd=Optional[false]; String fieldSeparator=Optional[","]; String arrayStart=Optional["{"]; String arraySeparator=Optional[","]; boolean arrayContentDetail=Optional[true]; String arrayEnd=Optional["}
protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail) { [EOL]     if (isRegistered(value) && !(value instanceof Number || value instanceof Boolean || value instanceof Character)) { [EOL]         appendCyclicObject(buffer, fieldName, value); [EOL]         return; [EOL]     } [EOL]     register(value); [EOL]     try { [EOL]         if (value instanceof Collection<?>) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (Collection<?>) value); [EOL]             } else { [EOL]                 appendSummarySize(buffer, fieldName, ((Collection<?>) value).size()); [EOL]             } [EOL]         } else if (value instanceof Map<?, ?>) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (Map<?, ?>) value); [EOL]             } else { [EOL]                 appendSummarySize(buffer, fieldName, ((Map<?, ?>) value).size()); [EOL]             } [EOL]         } else if (value instanceof long[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (long[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (long[]) value); [EOL]             } [EOL]         } else if (value instanceof int[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (int[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (int[]) value); [EOL]             } [EOL]         } else if (value instanceof short[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (short[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (short[]) value); [EOL]             } [EOL]         } else if (value instanceof byte[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (byte[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (byte[]) value); [EOL]             } [EOL]         } else if (value instanceof char[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (char[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (char[]) value); [EOL]             } [EOL]         } else if (value instanceof double[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (double[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (double[]) value); [EOL]             } [EOL]         } else if (value instanceof float[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (float[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (float[]) value); [EOL]             } [EOL]         } else if (value instanceof boolean[]) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (boolean[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (boolean[]) value); [EOL]             } [EOL]         } else if (value.getClass().isArray()) { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, (Object[]) value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, (Object[]) value); [EOL]             } [EOL]         } else { [EOL]             if (detail) { [EOL]                 appendDetail(buffer, fieldName, value); [EOL]             } else { [EOL]                 appendSummary(buffer, fieldName, value); [EOL]             } [EOL]         } [EOL]     } finally { [EOL]         unregister(value); [EOL]     } [EOL] } protected ToStringStyle();  DefaultToStringStyle();  NoFieldNameToStringStyle();  ShortPrefixToStringStyle();  SimpleToStringStyle();  MultiLineToStringStyle();  static Map<Object, Object> getRegistry();  static boolean isRegistered(final Object value);  static void register(final Object value);  static void unregister(final Object value); public void appendSuper(final StringBuffer buffer, final String superToString); public void appendToString(final StringBuffer buffer, final String toString); public void appendStart(final StringBuffer buffer, final Object object); public void appendEnd(final StringBuffer buffer, final Object object); protected void removeLastFieldSeparator(final StringBuffer buffer); public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); public void append(final StringBuffer buffer, final String fieldName, final long value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); public void append(final StringBuffer buffer, final String fieldName, final int value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); public void append(final StringBuffer buffer, final String fieldName, final short value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); public void append(final StringBuffer buffer, final String fieldName, final byte value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); public void append(final StringBuffer buffer, final String fieldName, final char value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); public void append(final StringBuffer buffer, final String fieldName, final double value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); public void append(final StringBuffer buffer, final String fieldName, final float value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); public void append(final StringBuffer buffer, final String fieldName, final boolean value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendClassName(final StringBuffer buffer, final Object object); protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); protected void appendContentStart(final StringBuffer buffer); protected void appendContentEnd(final StringBuffer buffer); protected void appendNullText(final StringBuffer buffer, final String fieldName); protected void appendFieldSeparator(final StringBuffer buffer); protected void appendFieldStart(final StringBuffer buffer, final String fieldName); protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); protected boolean isFullDetail(final Boolean fullDetailRequest); protected String getShortClassName(final Class<?> cls); protected boolean isUseClassName(); protected void setUseClassName(final boolean useClassName); protected boolean isUseShortClassName(); protected void setUseShortClassName(final boolean useShortClassName); protected boolean isUseIdentityHashCode(); protected void setUseIdentityHashCode(final boolean useIdentityHashCode); protected boolean isUseFieldNames(); protected void setUseFieldNames(final boolean useFieldNames); protected boolean isDefaultFullDetail(); protected void setDefaultFullDetail(final boolean defaultFullDetail); protected boolean isArrayContentDetail(); protected void setArrayContentDetail(final boolean arrayContentDetail); protected String getArrayStart(); protected void setArrayStart(String arrayStart); protected String getArrayEnd(); protected void setArrayEnd(String arrayEnd); protected String getArraySeparator(); protected void setArraySeparator(String arraySeparator); protected String getContentStart(); protected void setContentStart(String contentStart); protected String getContentEnd(); protected void setContentEnd(String contentEnd); protected String getFieldNameValueSeparator(); protected void setFieldNameValueSeparator(String fieldNameValueSeparator); protected String getFieldSeparator(); protected void setFieldSeparator(String fieldSeparator); protected boolean isFieldSeparatorAtStart(); protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); protected boolean isFieldSeparatorAtEnd(); protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); protected String getNullText(); protected void setNullText(String nullText); protected String getSizeStartText(); protected void setSizeStartText(String sizeStartText); protected String getSizeEndText(); protected void setSizeEndText(String sizeEndText); protected String getSummaryObjectStartText(); protected void setSummaryObjectStartText(String summaryObjectStartText); protected String getSummaryObjectEndText(); protected void setSummaryObjectEndText(String summaryObjectEndText); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); long serialVersionUID=Optional[-2587890625525655916L]; ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; boolean useFieldNames=Optional[true]; boolean useClassName=Optional[true]; boolean useShortClassName=Optional[false]; boolean useIdentityHashCode=Optional[true]; String contentStart=Optional["["]; String contentEnd=Optional["]"]; String fieldNameValueSeparator=Optional["="]; boolean fieldSeparatorAtStart=Optional[false]; boolean fieldSeparatorAtEnd=Optional[false]; String fieldSeparator=Optional[","]; String arrayStart=Optional["{"]; String arraySeparator=Optional[","]; boolean arrayContentDetail=Optional[true]; String arrayEnd=Optional["}
protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll) { [EOL]     buffer.append(coll); [EOL] } protected ToStringStyle();  DefaultToStringStyle();  NoFieldNameToStringStyle();  ShortPrefixToStringStyle();  SimpleToStringStyle();  MultiLineToStringStyle();  static Map<Object, Object> getRegistry();  static boolean isRegistered(final Object value);  static void register(final Object value);  static void unregister(final Object value); public void appendSuper(final StringBuffer buffer, final String superToString); public void appendToString(final StringBuffer buffer, final String toString); public void appendStart(final StringBuffer buffer, final Object object); public void appendEnd(final StringBuffer buffer, final Object object); protected void removeLastFieldSeparator(final StringBuffer buffer); public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); public void append(final StringBuffer buffer, final String fieldName, final long value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); public void append(final StringBuffer buffer, final String fieldName, final int value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); public void append(final StringBuffer buffer, final String fieldName, final short value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); public void append(final StringBuffer buffer, final String fieldName, final byte value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); public void append(final StringBuffer buffer, final String fieldName, final char value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); public void append(final StringBuffer buffer, final String fieldName, final double value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); public void append(final StringBuffer buffer, final String fieldName, final float value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); public void append(final StringBuffer buffer, final String fieldName, final boolean value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendClassName(final StringBuffer buffer, final Object object); protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); protected void appendContentStart(final StringBuffer buffer); protected void appendContentEnd(final StringBuffer buffer); protected void appendNullText(final StringBuffer buffer, final String fieldName); protected void appendFieldSeparator(final StringBuffer buffer); protected void appendFieldStart(final StringBuffer buffer, final String fieldName); protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); protected boolean isFullDetail(final Boolean fullDetailRequest); protected String getShortClassName(final Class<?> cls); protected boolean isUseClassName(); protected void setUseClassName(final boolean useClassName); protected boolean isUseShortClassName(); protected void setUseShortClassName(final boolean useShortClassName); protected boolean isUseIdentityHashCode(); protected void setUseIdentityHashCode(final boolean useIdentityHashCode); protected boolean isUseFieldNames(); protected void setUseFieldNames(final boolean useFieldNames); protected boolean isDefaultFullDetail(); protected void setDefaultFullDetail(final boolean defaultFullDetail); protected boolean isArrayContentDetail(); protected void setArrayContentDetail(final boolean arrayContentDetail); protected String getArrayStart(); protected void setArrayStart(String arrayStart); protected String getArrayEnd(); protected void setArrayEnd(String arrayEnd); protected String getArraySeparator(); protected void setArraySeparator(String arraySeparator); protected String getContentStart(); protected void setContentStart(String contentStart); protected String getContentEnd(); protected void setContentEnd(String contentEnd); protected String getFieldNameValueSeparator(); protected void setFieldNameValueSeparator(String fieldNameValueSeparator); protected String getFieldSeparator(); protected void setFieldSeparator(String fieldSeparator); protected boolean isFieldSeparatorAtStart(); protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); protected boolean isFieldSeparatorAtEnd(); protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); protected String getNullText(); protected void setNullText(String nullText); protected String getSizeStartText(); protected void setSizeStartText(String sizeStartText); protected String getSizeEndText(); protected void setSizeEndText(String sizeEndText); protected String getSummaryObjectStartText(); protected void setSummaryObjectStartText(String summaryObjectStartText); protected String getSummaryObjectEndText(); protected void setSummaryObjectEndText(String summaryObjectEndText); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); long serialVersionUID=Optional[-2587890625525655916L]; ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; boolean useFieldNames=Optional[true]; boolean useClassName=Optional[true]; boolean useShortClassName=Optional[false]; boolean useIdentityHashCode=Optional[true]; String contentStart=Optional["["]; String contentEnd=Optional["]"]; String fieldNameValueSeparator=Optional["="]; boolean fieldSeparatorAtStart=Optional[false]; boolean fieldSeparatorAtEnd=Optional[false]; String fieldSeparator=Optional[","]; String arrayStart=Optional["{"]; String arraySeparator=Optional[","]; boolean arrayContentDetail=Optional[true]; String arrayEnd=Optional["}
protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map) { [EOL]     buffer.append(map); [EOL] } protected ToStringStyle();  DefaultToStringStyle();  NoFieldNameToStringStyle();  ShortPrefixToStringStyle();  SimpleToStringStyle();  MultiLineToStringStyle();  static Map<Object, Object> getRegistry();  static boolean isRegistered(final Object value);  static void register(final Object value);  static void unregister(final Object value); public void appendSuper(final StringBuffer buffer, final String superToString); public void appendToString(final StringBuffer buffer, final String toString); public void appendStart(final StringBuffer buffer, final Object object); public void appendEnd(final StringBuffer buffer, final Object object); protected void removeLastFieldSeparator(final StringBuffer buffer); public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); public void append(final StringBuffer buffer, final String fieldName, final long value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); public void append(final StringBuffer buffer, final String fieldName, final int value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); public void append(final StringBuffer buffer, final String fieldName, final short value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); public void append(final StringBuffer buffer, final String fieldName, final byte value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); public void append(final StringBuffer buffer, final String fieldName, final char value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); public void append(final StringBuffer buffer, final String fieldName, final double value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); public void append(final StringBuffer buffer, final String fieldName, final float value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); public void append(final StringBuffer buffer, final String fieldName, final boolean value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendClassName(final StringBuffer buffer, final Object object); protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); protected void appendContentStart(final StringBuffer buffer); protected void appendContentEnd(final StringBuffer buffer); protected void appendNullText(final StringBuffer buffer, final String fieldName); protected void appendFieldSeparator(final StringBuffer buffer); protected void appendFieldStart(final StringBuffer buffer, final String fieldName); protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); protected boolean isFullDetail(final Boolean fullDetailRequest); protected String getShortClassName(final Class<?> cls); protected boolean isUseClassName(); protected void setUseClassName(final boolean useClassName); protected boolean isUseShortClassName(); protected void setUseShortClassName(final boolean useShortClassName); protected boolean isUseIdentityHashCode(); protected void setUseIdentityHashCode(final boolean useIdentityHashCode); protected boolean isUseFieldNames(); protected void setUseFieldNames(final boolean useFieldNames); protected boolean isDefaultFullDetail(); protected void setDefaultFullDetail(final boolean defaultFullDetail); protected boolean isArrayContentDetail(); protected void setArrayContentDetail(final boolean arrayContentDetail); protected String getArrayStart(); protected void setArrayStart(String arrayStart); protected String getArrayEnd(); protected void setArrayEnd(String arrayEnd); protected String getArraySeparator(); protected void setArraySeparator(String arraySeparator); protected String getContentStart(); protected void setContentStart(String contentStart); protected String getContentEnd(); protected void setContentEnd(String contentEnd); protected String getFieldNameValueSeparator(); protected void setFieldNameValueSeparator(String fieldNameValueSeparator); protected String getFieldSeparator(); protected void setFieldSeparator(String fieldSeparator); protected boolean isFieldSeparatorAtStart(); protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); protected boolean isFieldSeparatorAtEnd(); protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); protected String getNullText(); protected void setNullText(String nullText); protected String getSizeStartText(); protected void setSizeStartText(String sizeStartText); protected String getSizeEndText(); protected void setSizeEndText(String sizeEndText); protected String getSummaryObjectStartText(); protected void setSummaryObjectStartText(String summaryObjectStartText); protected String getSummaryObjectEndText(); protected void setSummaryObjectEndText(String summaryObjectEndText); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); long serialVersionUID=Optional[-2587890625525655916L]; ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; boolean useFieldNames=Optional[true]; boolean useClassName=Optional[true]; boolean useShortClassName=Optional[false]; boolean useIdentityHashCode=Optional[true]; String contentStart=Optional["["]; String contentEnd=Optional["]"]; String fieldNameValueSeparator=Optional["="]; boolean fieldSeparatorAtStart=Optional[false]; boolean fieldSeparatorAtEnd=Optional[false]; String fieldSeparator=Optional[","]; String arrayStart=Optional["{"]; String arraySeparator=Optional[","]; boolean arrayContentDetail=Optional[true]; String arrayEnd=Optional["}
protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value) { [EOL]     buffer.append(summaryObjectStartText); [EOL]     buffer.append(getShortClassName(value.getClass())); [EOL]     buffer.append(summaryObjectEndText); [EOL] } protected ToStringStyle();  DefaultToStringStyle();  NoFieldNameToStringStyle();  ShortPrefixToStringStyle();  SimpleToStringStyle();  MultiLineToStringStyle();  static Map<Object, Object> getRegistry();  static boolean isRegistered(final Object value);  static void register(final Object value);  static void unregister(final Object value); public void appendSuper(final StringBuffer buffer, final String superToString); public void appendToString(final StringBuffer buffer, final String toString); public void appendStart(final StringBuffer buffer, final Object object); public void appendEnd(final StringBuffer buffer, final Object object); protected void removeLastFieldSeparator(final StringBuffer buffer); public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); public void append(final StringBuffer buffer, final String fieldName, final long value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); public void append(final StringBuffer buffer, final String fieldName, final int value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); public void append(final StringBuffer buffer, final String fieldName, final short value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); public void append(final StringBuffer buffer, final String fieldName, final byte value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); public void append(final StringBuffer buffer, final String fieldName, final char value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); public void append(final StringBuffer buffer, final String fieldName, final double value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); public void append(final StringBuffer buffer, final String fieldName, final float value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); public void append(final StringBuffer buffer, final String fieldName, final boolean value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendClassName(final StringBuffer buffer, final Object object); protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); protected void appendContentStart(final StringBuffer buffer); protected void appendContentEnd(final StringBuffer buffer); protected void appendNullText(final StringBuffer buffer, final String fieldName); protected void appendFieldSeparator(final StringBuffer buffer); protected void appendFieldStart(final StringBuffer buffer, final String fieldName); protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); protected boolean isFullDetail(final Boolean fullDetailRequest); protected String getShortClassName(final Class<?> cls); protected boolean isUseClassName(); protected void setUseClassName(final boolean useClassName); protected boolean isUseShortClassName(); protected void setUseShortClassName(final boolean useShortClassName); protected boolean isUseIdentityHashCode(); protected void setUseIdentityHashCode(final boolean useIdentityHashCode); protected boolean isUseFieldNames(); protected void setUseFieldNames(final boolean useFieldNames); protected boolean isDefaultFullDetail(); protected void setDefaultFullDetail(final boolean defaultFullDetail); protected boolean isArrayContentDetail(); protected void setArrayContentDetail(final boolean arrayContentDetail); protected String getArrayStart(); protected void setArrayStart(String arrayStart); protected String getArrayEnd(); protected void setArrayEnd(String arrayEnd); protected String getArraySeparator(); protected void setArraySeparator(String arraySeparator); protected String getContentStart(); protected void setContentStart(String contentStart); protected String getContentEnd(); protected void setContentEnd(String contentEnd); protected String getFieldNameValueSeparator(); protected void setFieldNameValueSeparator(String fieldNameValueSeparator); protected String getFieldSeparator(); protected void setFieldSeparator(String fieldSeparator); protected boolean isFieldSeparatorAtStart(); protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); protected boolean isFieldSeparatorAtEnd(); protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); protected String getNullText(); protected void setNullText(String nullText); protected String getSizeStartText(); protected void setSizeStartText(String sizeStartText); protected String getSizeEndText(); protected void setSizeEndText(String sizeEndText); protected String getSummaryObjectStartText(); protected void setSummaryObjectStartText(String summaryObjectStartText); protected String getSummaryObjectEndText(); protected void setSummaryObjectEndText(String summaryObjectEndText); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); long serialVersionUID=Optional[-2587890625525655916L]; ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; boolean useFieldNames=Optional[true]; boolean useClassName=Optional[true]; boolean useShortClassName=Optional[false]; boolean useIdentityHashCode=Optional[true]; String contentStart=Optional["["]; String contentEnd=Optional["]"]; String fieldNameValueSeparator=Optional["="]; boolean fieldSeparatorAtStart=Optional[false]; boolean fieldSeparatorAtEnd=Optional[false]; String fieldSeparator=Optional[","]; String arrayStart=Optional["{"]; String arraySeparator=Optional[","]; boolean arrayContentDetail=Optional[true]; String arrayEnd=Optional["}
protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value) { [EOL]     buffer.append(value); [EOL] } protected ToStringStyle();  DefaultToStringStyle();  NoFieldNameToStringStyle();  ShortPrefixToStringStyle();  SimpleToStringStyle();  MultiLineToStringStyle();  static Map<Object, Object> getRegistry();  static boolean isRegistered(final Object value);  static void register(final Object value);  static void unregister(final Object value); public void appendSuper(final StringBuffer buffer, final String superToString); public void appendToString(final StringBuffer buffer, final String toString); public void appendStart(final StringBuffer buffer, final Object object); public void appendEnd(final StringBuffer buffer, final Object object); protected void removeLastFieldSeparator(final StringBuffer buffer); public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); public void append(final StringBuffer buffer, final String fieldName, final long value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); public void append(final StringBuffer buffer, final String fieldName, final int value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); public void append(final StringBuffer buffer, final String fieldName, final short value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); public void append(final StringBuffer buffer, final String fieldName, final byte value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); public void append(final StringBuffer buffer, final String fieldName, final char value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); public void append(final StringBuffer buffer, final String fieldName, final double value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); public void append(final StringBuffer buffer, final String fieldName, final float value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); public void append(final StringBuffer buffer, final String fieldName, final boolean value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendClassName(final StringBuffer buffer, final Object object); protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); protected void appendContentStart(final StringBuffer buffer); protected void appendContentEnd(final StringBuffer buffer); protected void appendNullText(final StringBuffer buffer, final String fieldName); protected void appendFieldSeparator(final StringBuffer buffer); protected void appendFieldStart(final StringBuffer buffer, final String fieldName); protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); protected boolean isFullDetail(final Boolean fullDetailRequest); protected String getShortClassName(final Class<?> cls); protected boolean isUseClassName(); protected void setUseClassName(final boolean useClassName); protected boolean isUseShortClassName(); protected void setUseShortClassName(final boolean useShortClassName); protected boolean isUseIdentityHashCode(); protected void setUseIdentityHashCode(final boolean useIdentityHashCode); protected boolean isUseFieldNames(); protected void setUseFieldNames(final boolean useFieldNames); protected boolean isDefaultFullDetail(); protected void setDefaultFullDetail(final boolean defaultFullDetail); protected boolean isArrayContentDetail(); protected void setArrayContentDetail(final boolean arrayContentDetail); protected String getArrayStart(); protected void setArrayStart(String arrayStart); protected String getArrayEnd(); protected void setArrayEnd(String arrayEnd); protected String getArraySeparator(); protected void setArraySeparator(String arraySeparator); protected String getContentStart(); protected void setContentStart(String contentStart); protected String getContentEnd(); protected void setContentEnd(String contentEnd); protected String getFieldNameValueSeparator(); protected void setFieldNameValueSeparator(String fieldNameValueSeparator); protected String getFieldSeparator(); protected void setFieldSeparator(String fieldSeparator); protected boolean isFieldSeparatorAtStart(); protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); protected boolean isFieldSeparatorAtEnd(); protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); protected String getNullText(); protected void setNullText(String nullText); protected String getSizeStartText(); protected void setSizeStartText(String sizeStartText); protected String getSizeEndText(); protected void setSizeEndText(String sizeEndText); protected String getSummaryObjectStartText(); protected void setSummaryObjectStartText(String summaryObjectStartText); protected String getSummaryObjectEndText(); protected void setSummaryObjectEndText(String summaryObjectEndText); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); long serialVersionUID=Optional[-2587890625525655916L]; ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; boolean useFieldNames=Optional[true]; boolean useClassName=Optional[true]; boolean useShortClassName=Optional[false]; boolean useIdentityHashCode=Optional[true]; String contentStart=Optional["["]; String contentEnd=Optional["]"]; String fieldNameValueSeparator=Optional["="]; boolean fieldSeparatorAtStart=Optional[false]; boolean fieldSeparatorAtEnd=Optional[false]; String fieldSeparator=Optional[","]; String arrayStart=Optional["{"]; String arraySeparator=Optional[","]; boolean arrayContentDetail=Optional[true]; String arrayEnd=Optional["}
protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array) { [EOL]     appendSummarySize(buffer, fieldName, array.length); [EOL] } protected ToStringStyle();  DefaultToStringStyle();  NoFieldNameToStringStyle();  ShortPrefixToStringStyle();  SimpleToStringStyle();  MultiLineToStringStyle();  static Map<Object, Object> getRegistry();  static boolean isRegistered(final Object value);  static void register(final Object value);  static void unregister(final Object value); public void appendSuper(final StringBuffer buffer, final String superToString); public void appendToString(final StringBuffer buffer, final String toString); public void appendStart(final StringBuffer buffer, final Object object); public void appendEnd(final StringBuffer buffer, final Object object); protected void removeLastFieldSeparator(final StringBuffer buffer); public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); public void append(final StringBuffer buffer, final String fieldName, final long value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); public void append(final StringBuffer buffer, final String fieldName, final int value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); public void append(final StringBuffer buffer, final String fieldName, final short value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); public void append(final StringBuffer buffer, final String fieldName, final byte value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); public void append(final StringBuffer buffer, final String fieldName, final char value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); public void append(final StringBuffer buffer, final String fieldName, final double value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); public void append(final StringBuffer buffer, final String fieldName, final float value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); public void append(final StringBuffer buffer, final String fieldName, final boolean value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendClassName(final StringBuffer buffer, final Object object); protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); protected void appendContentStart(final StringBuffer buffer); protected void appendContentEnd(final StringBuffer buffer); protected void appendNullText(final StringBuffer buffer, final String fieldName); protected void appendFieldSeparator(final StringBuffer buffer); protected void appendFieldStart(final StringBuffer buffer, final String fieldName); protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); protected boolean isFullDetail(final Boolean fullDetailRequest); protected String getShortClassName(final Class<?> cls); protected boolean isUseClassName(); protected void setUseClassName(final boolean useClassName); protected boolean isUseShortClassName(); protected void setUseShortClassName(final boolean useShortClassName); protected boolean isUseIdentityHashCode(); protected void setUseIdentityHashCode(final boolean useIdentityHashCode); protected boolean isUseFieldNames(); protected void setUseFieldNames(final boolean useFieldNames); protected boolean isDefaultFullDetail(); protected void setDefaultFullDetail(final boolean defaultFullDetail); protected boolean isArrayContentDetail(); protected void setArrayContentDetail(final boolean arrayContentDetail); protected String getArrayStart(); protected void setArrayStart(String arrayStart); protected String getArrayEnd(); protected void setArrayEnd(String arrayEnd); protected String getArraySeparator(); protected void setArraySeparator(String arraySeparator); protected String getContentStart(); protected void setContentStart(String contentStart); protected String getContentEnd(); protected void setContentEnd(String contentEnd); protected String getFieldNameValueSeparator(); protected void setFieldNameValueSeparator(String fieldNameValueSeparator); protected String getFieldSeparator(); protected void setFieldSeparator(String fieldSeparator); protected boolean isFieldSeparatorAtStart(); protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); protected boolean isFieldSeparatorAtEnd(); protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); protected String getNullText(); protected void setNullText(String nullText); protected String getSizeStartText(); protected void setSizeStartText(String sizeStartText); protected String getSizeEndText(); protected void setSizeEndText(String sizeEndText); protected String getSummaryObjectStartText(); protected void setSummaryObjectStartText(String summaryObjectStartText); protected String getSummaryObjectEndText(); protected void setSummaryObjectEndText(String summaryObjectEndText); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); long serialVersionUID=Optional[-2587890625525655916L]; ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; boolean useFieldNames=Optional[true]; boolean useClassName=Optional[true]; boolean useShortClassName=Optional[false]; boolean useIdentityHashCode=Optional[true]; String contentStart=Optional["["]; String contentEnd=Optional["]"]; String fieldNameValueSeparator=Optional["="]; boolean fieldSeparatorAtStart=Optional[false]; boolean fieldSeparatorAtEnd=Optional[false]; String fieldSeparator=Optional[","]; String arrayStart=Optional["{"]; String arraySeparator=Optional[","]; boolean arrayContentDetail=Optional[true]; String arrayEnd=Optional["}
public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail) { [EOL]     appendFieldStart(buffer, fieldName); [EOL]     if (array == null) { [EOL]         appendNullText(buffer, fieldName); [EOL]     } else if (isFullDetail(fullDetail)) { [EOL]         appendDetail(buffer, fieldName, array); [EOL]     } else { [EOL]         appendSummary(buffer, fieldName, array); [EOL]     } [EOL]     appendFieldEnd(buffer, fieldName); [EOL] } protected ToStringStyle();  DefaultToStringStyle();  NoFieldNameToStringStyle();  ShortPrefixToStringStyle();  SimpleToStringStyle();  MultiLineToStringStyle();  static Map<Object, Object> getRegistry();  static boolean isRegistered(final Object value);  static void register(final Object value);  static void unregister(final Object value); public void appendSuper(final StringBuffer buffer, final String superToString); public void appendToString(final StringBuffer buffer, final String toString); public void appendStart(final StringBuffer buffer, final Object object); public void appendEnd(final StringBuffer buffer, final Object object); protected void removeLastFieldSeparator(final StringBuffer buffer); public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); public void append(final StringBuffer buffer, final String fieldName, final long value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); public void append(final StringBuffer buffer, final String fieldName, final int value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); public void append(final StringBuffer buffer, final String fieldName, final short value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); public void append(final StringBuffer buffer, final String fieldName, final byte value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); public void append(final StringBuffer buffer, final String fieldName, final char value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); public void append(final StringBuffer buffer, final String fieldName, final double value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); public void append(final StringBuffer buffer, final String fieldName, final float value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); public void append(final StringBuffer buffer, final String fieldName, final boolean value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendClassName(final StringBuffer buffer, final Object object); protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); protected void appendContentStart(final StringBuffer buffer); protected void appendContentEnd(final StringBuffer buffer); protected void appendNullText(final StringBuffer buffer, final String fieldName); protected void appendFieldSeparator(final StringBuffer buffer); protected void appendFieldStart(final StringBuffer buffer, final String fieldName); protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); protected boolean isFullDetail(final Boolean fullDetailRequest); protected String getShortClassName(final Class<?> cls); protected boolean isUseClassName(); protected void setUseClassName(final boolean useClassName); protected boolean isUseShortClassName(); protected void setUseShortClassName(final boolean useShortClassName); protected boolean isUseIdentityHashCode(); protected void setUseIdentityHashCode(final boolean useIdentityHashCode); protected boolean isUseFieldNames(); protected void setUseFieldNames(final boolean useFieldNames); protected boolean isDefaultFullDetail(); protected void setDefaultFullDetail(final boolean defaultFullDetail); protected boolean isArrayContentDetail(); protected void setArrayContentDetail(final boolean arrayContentDetail); protected String getArrayStart(); protected void setArrayStart(String arrayStart); protected String getArrayEnd(); protected void setArrayEnd(String arrayEnd); protected String getArraySeparator(); protected void setArraySeparator(String arraySeparator); protected String getContentStart(); protected void setContentStart(String contentStart); protected String getContentEnd(); protected void setContentEnd(String contentEnd); protected String getFieldNameValueSeparator(); protected void setFieldNameValueSeparator(String fieldNameValueSeparator); protected String getFieldSeparator(); protected void setFieldSeparator(String fieldSeparator); protected boolean isFieldSeparatorAtStart(); protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); protected boolean isFieldSeparatorAtEnd(); protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); protected String getNullText(); protected void setNullText(String nullText); protected String getSizeStartText(); protected void setSizeStartText(String sizeStartText); protected String getSizeEndText(); protected void setSizeEndText(String sizeEndText); protected String getSummaryObjectStartText(); protected void setSummaryObjectStartText(String summaryObjectStartText); protected String getSummaryObjectEndText(); protected void setSummaryObjectEndText(String summaryObjectEndText); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); long serialVersionUID=Optional[-2587890625525655916L]; ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; boolean useFieldNames=Optional[true]; boolean useClassName=Optional[true]; boolean useShortClassName=Optional[false]; boolean useIdentityHashCode=Optional[true]; String contentStart=Optional["["]; String contentEnd=Optional["]"]; String fieldNameValueSeparator=Optional["="]; boolean fieldSeparatorAtStart=Optional[false]; boolean fieldSeparatorAtEnd=Optional[false]; String fieldSeparator=Optional[","]; String arrayStart=Optional["{"]; String arraySeparator=Optional[","]; boolean arrayContentDetail=Optional[true]; String arrayEnd=Optional["}
protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array) { [EOL]     buffer.append(arrayStart); [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         if (i > 0) { [EOL]             buffer.append(arraySeparator); [EOL]         } [EOL]         appendDetail(buffer, fieldName, array[i]); [EOL]     } [EOL]     buffer.append(arrayEnd); [EOL] } protected ToStringStyle();  DefaultToStringStyle();  NoFieldNameToStringStyle();  ShortPrefixToStringStyle();  SimpleToStringStyle();  MultiLineToStringStyle();  static Map<Object, Object> getRegistry();  static boolean isRegistered(final Object value);  static void register(final Object value);  static void unregister(final Object value); public void appendSuper(final StringBuffer buffer, final String superToString); public void appendToString(final StringBuffer buffer, final String toString); public void appendStart(final StringBuffer buffer, final Object object); public void appendEnd(final StringBuffer buffer, final Object object); protected void removeLastFieldSeparator(final StringBuffer buffer); public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); public void append(final StringBuffer buffer, final String fieldName, final long value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); public void append(final StringBuffer buffer, final String fieldName, final int value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); public void append(final StringBuffer buffer, final String fieldName, final short value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); public void append(final StringBuffer buffer, final String fieldName, final byte value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); public void append(final StringBuffer buffer, final String fieldName, final char value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); public void append(final StringBuffer buffer, final String fieldName, final double value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); public void append(final StringBuffer buffer, final String fieldName, final float value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); public void append(final StringBuffer buffer, final String fieldName, final boolean value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendClassName(final StringBuffer buffer, final Object object); protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); protected void appendContentStart(final StringBuffer buffer); protected void appendContentEnd(final StringBuffer buffer); protected void appendNullText(final StringBuffer buffer, final String fieldName); protected void appendFieldSeparator(final StringBuffer buffer); protected void appendFieldStart(final StringBuffer buffer, final String fieldName); protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); protected boolean isFullDetail(final Boolean fullDetailRequest); protected String getShortClassName(final Class<?> cls); protected boolean isUseClassName(); protected void setUseClassName(final boolean useClassName); protected boolean isUseShortClassName(); protected void setUseShortClassName(final boolean useShortClassName); protected boolean isUseIdentityHashCode(); protected void setUseIdentityHashCode(final boolean useIdentityHashCode); protected boolean isUseFieldNames(); protected void setUseFieldNames(final boolean useFieldNames); protected boolean isDefaultFullDetail(); protected void setDefaultFullDetail(final boolean defaultFullDetail); protected boolean isArrayContentDetail(); protected void setArrayContentDetail(final boolean arrayContentDetail); protected String getArrayStart(); protected void setArrayStart(String arrayStart); protected String getArrayEnd(); protected void setArrayEnd(String arrayEnd); protected String getArraySeparator(); protected void setArraySeparator(String arraySeparator); protected String getContentStart(); protected void setContentStart(String contentStart); protected String getContentEnd(); protected void setContentEnd(String contentEnd); protected String getFieldNameValueSeparator(); protected void setFieldNameValueSeparator(String fieldNameValueSeparator); protected String getFieldSeparator(); protected void setFieldSeparator(String fieldSeparator); protected boolean isFieldSeparatorAtStart(); protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); protected boolean isFieldSeparatorAtEnd(); protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); protected String getNullText(); protected void setNullText(String nullText); protected String getSizeStartText(); protected void setSizeStartText(String sizeStartText); protected String getSizeEndText(); protected void setSizeEndText(String sizeEndText); protected String getSummaryObjectStartText(); protected void setSummaryObjectStartText(String summaryObjectStartText); protected String getSummaryObjectEndText(); protected void setSummaryObjectEndText(String summaryObjectEndText); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); long serialVersionUID=Optional[-2587890625525655916L]; ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; boolean useFieldNames=Optional[true]; boolean useClassName=Optional[true]; boolean useShortClassName=Optional[false]; boolean useIdentityHashCode=Optional[true]; String contentStart=Optional["["]; String contentEnd=Optional["]"]; String fieldNameValueSeparator=Optional["="]; boolean fieldSeparatorAtStart=Optional[false]; boolean fieldSeparatorAtEnd=Optional[false]; String fieldSeparator=Optional[","]; String arrayStart=Optional["{"]; String arraySeparator=Optional[","]; boolean arrayContentDetail=Optional[true]; String arrayEnd=Optional["}
protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array) { [EOL]     buffer.append(arrayStart); [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         if (i > 0) { [EOL]             buffer.append(arraySeparator); [EOL]         } [EOL]         appendDetail(buffer, fieldName, array[i]); [EOL]     } [EOL]     buffer.append(arrayEnd); [EOL] } protected ToStringStyle();  DefaultToStringStyle();  NoFieldNameToStringStyle();  ShortPrefixToStringStyle();  SimpleToStringStyle();  MultiLineToStringStyle();  static Map<Object, Object> getRegistry();  static boolean isRegistered(final Object value);  static void register(final Object value);  static void unregister(final Object value); public void appendSuper(final StringBuffer buffer, final String superToString); public void appendToString(final StringBuffer buffer, final String toString); public void appendStart(final StringBuffer buffer, final Object object); public void appendEnd(final StringBuffer buffer, final Object object); protected void removeLastFieldSeparator(final StringBuffer buffer); public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); public void append(final StringBuffer buffer, final String fieldName, final long value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); public void append(final StringBuffer buffer, final String fieldName, final int value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); public void append(final StringBuffer buffer, final String fieldName, final short value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); public void append(final StringBuffer buffer, final String fieldName, final byte value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); public void append(final StringBuffer buffer, final String fieldName, final char value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); public void append(final StringBuffer buffer, final String fieldName, final double value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); public void append(final StringBuffer buffer, final String fieldName, final float value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); public void append(final StringBuffer buffer, final String fieldName, final boolean value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendClassName(final StringBuffer buffer, final Object object); protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); protected void appendContentStart(final StringBuffer buffer); protected void appendContentEnd(final StringBuffer buffer); protected void appendNullText(final StringBuffer buffer, final String fieldName); protected void appendFieldSeparator(final StringBuffer buffer); protected void appendFieldStart(final StringBuffer buffer, final String fieldName); protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); protected boolean isFullDetail(final Boolean fullDetailRequest); protected String getShortClassName(final Class<?> cls); protected boolean isUseClassName(); protected void setUseClassName(final boolean useClassName); protected boolean isUseShortClassName(); protected void setUseShortClassName(final boolean useShortClassName); protected boolean isUseIdentityHashCode(); protected void setUseIdentityHashCode(final boolean useIdentityHashCode); protected boolean isUseFieldNames(); protected void setUseFieldNames(final boolean useFieldNames); protected boolean isDefaultFullDetail(); protected void setDefaultFullDetail(final boolean defaultFullDetail); protected boolean isArrayContentDetail(); protected void setArrayContentDetail(final boolean arrayContentDetail); protected String getArrayStart(); protected void setArrayStart(String arrayStart); protected String getArrayEnd(); protected void setArrayEnd(String arrayEnd); protected String getArraySeparator(); protected void setArraySeparator(String arraySeparator); protected String getContentStart(); protected void setContentStart(String contentStart); protected String getContentEnd(); protected void setContentEnd(String contentEnd); protected String getFieldNameValueSeparator(); protected void setFieldNameValueSeparator(String fieldNameValueSeparator); protected String getFieldSeparator(); protected void setFieldSeparator(String fieldSeparator); protected boolean isFieldSeparatorAtStart(); protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); protected boolean isFieldSeparatorAtEnd(); protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); protected String getNullText(); protected void setNullText(String nullText); protected String getSizeStartText(); protected void setSizeStartText(String sizeStartText); protected String getSizeEndText(); protected void setSizeEndText(String sizeEndText); protected String getSummaryObjectStartText(); protected void setSummaryObjectStartText(String summaryObjectStartText); protected String getSummaryObjectEndText(); protected void setSummaryObjectEndText(String summaryObjectEndText); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); long serialVersionUID=Optional[-2587890625525655916L]; ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; boolean useFieldNames=Optional[true]; boolean useClassName=Optional[true]; boolean useShortClassName=Optional[false]; boolean useIdentityHashCode=Optional[true]; String contentStart=Optional["["]; String contentEnd=Optional["]"]; String fieldNameValueSeparator=Optional["="]; boolean fieldSeparatorAtStart=Optional[false]; boolean fieldSeparatorAtEnd=Optional[false]; String fieldSeparator=Optional[","]; String arrayStart=Optional["{"]; String arraySeparator=Optional[","]; boolean arrayContentDetail=Optional[true]; String arrayEnd=Optional["}
protected void appendClassName(final StringBuffer buffer, final Object object) { [EOL]     if (useClassName && object != null) { [EOL]         register(object); [EOL]         if (useShortClassName) { [EOL]             buffer.append(getShortClassName(object.getClass())); [EOL]         } else { [EOL]             buffer.append(object.getClass().getName()); [EOL]         } [EOL]     } [EOL] } protected ToStringStyle();  DefaultToStringStyle();  NoFieldNameToStringStyle();  ShortPrefixToStringStyle();  SimpleToStringStyle();  MultiLineToStringStyle();  static Map<Object, Object> getRegistry();  static boolean isRegistered(final Object value);  static void register(final Object value);  static void unregister(final Object value); public void appendSuper(final StringBuffer buffer, final String superToString); public void appendToString(final StringBuffer buffer, final String toString); public void appendStart(final StringBuffer buffer, final Object object); public void appendEnd(final StringBuffer buffer, final Object object); protected void removeLastFieldSeparator(final StringBuffer buffer); public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); public void append(final StringBuffer buffer, final String fieldName, final long value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); public void append(final StringBuffer buffer, final String fieldName, final int value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); public void append(final StringBuffer buffer, final String fieldName, final short value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); public void append(final StringBuffer buffer, final String fieldName, final byte value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); public void append(final StringBuffer buffer, final String fieldName, final char value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); public void append(final StringBuffer buffer, final String fieldName, final double value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); public void append(final StringBuffer buffer, final String fieldName, final float value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); public void append(final StringBuffer buffer, final String fieldName, final boolean value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendClassName(final StringBuffer buffer, final Object object); protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); protected void appendContentStart(final StringBuffer buffer); protected void appendContentEnd(final StringBuffer buffer); protected void appendNullText(final StringBuffer buffer, final String fieldName); protected void appendFieldSeparator(final StringBuffer buffer); protected void appendFieldStart(final StringBuffer buffer, final String fieldName); protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); protected boolean isFullDetail(final Boolean fullDetailRequest); protected String getShortClassName(final Class<?> cls); protected boolean isUseClassName(); protected void setUseClassName(final boolean useClassName); protected boolean isUseShortClassName(); protected void setUseShortClassName(final boolean useShortClassName); protected boolean isUseIdentityHashCode(); protected void setUseIdentityHashCode(final boolean useIdentityHashCode); protected boolean isUseFieldNames(); protected void setUseFieldNames(final boolean useFieldNames); protected boolean isDefaultFullDetail(); protected void setDefaultFullDetail(final boolean defaultFullDetail); protected boolean isArrayContentDetail(); protected void setArrayContentDetail(final boolean arrayContentDetail); protected String getArrayStart(); protected void setArrayStart(String arrayStart); protected String getArrayEnd(); protected void setArrayEnd(String arrayEnd); protected String getArraySeparator(); protected void setArraySeparator(String arraySeparator); protected String getContentStart(); protected void setContentStart(String contentStart); protected String getContentEnd(); protected void setContentEnd(String contentEnd); protected String getFieldNameValueSeparator(); protected void setFieldNameValueSeparator(String fieldNameValueSeparator); protected String getFieldSeparator(); protected void setFieldSeparator(String fieldSeparator); protected boolean isFieldSeparatorAtStart(); protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); protected boolean isFieldSeparatorAtEnd(); protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); protected String getNullText(); protected void setNullText(String nullText); protected String getSizeStartText(); protected void setSizeStartText(String sizeStartText); protected String getSizeEndText(); protected void setSizeEndText(String sizeEndText); protected String getSummaryObjectStartText(); protected void setSummaryObjectStartText(String summaryObjectStartText); protected String getSummaryObjectEndText(); protected void setSummaryObjectEndText(String summaryObjectEndText); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); long serialVersionUID=Optional[-2587890625525655916L]; ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; boolean useFieldNames=Optional[true]; boolean useClassName=Optional[true]; boolean useShortClassName=Optional[false]; boolean useIdentityHashCode=Optional[true]; String contentStart=Optional["["]; String contentEnd=Optional["]"]; String fieldNameValueSeparator=Optional["="]; boolean fieldSeparatorAtStart=Optional[false]; boolean fieldSeparatorAtEnd=Optional[false]; String fieldSeparator=Optional[","]; String arrayStart=Optional["{"]; String arraySeparator=Optional[","]; boolean arrayContentDetail=Optional[true]; String arrayEnd=Optional["}
protected void appendClassName(final StringBuffer buffer, final Object object) { [EOL]     if (useClassName && object != null) { [EOL]         register(object); [EOL]         if (useShortClassName) { [EOL]             buffer.append(getShortClassName(object.getClass())); [EOL]         } else { [EOL]             buffer.append(object.getClass().getName()); [EOL]         } [EOL]     } [EOL] } protected ToStringStyle();  DefaultToStringStyle();  NoFieldNameToStringStyle();  ShortPrefixToStringStyle();  SimpleToStringStyle();  MultiLineToStringStyle();  static Map<Object, Object> getRegistry();  static boolean isRegistered(final Object value);  static void register(final Object value);  static void unregister(final Object value); public void appendSuper(final StringBuffer buffer, final String superToString); public void appendToString(final StringBuffer buffer, final String toString); public void appendStart(final StringBuffer buffer, final Object object); public void appendEnd(final StringBuffer buffer, final Object object); protected void removeLastFieldSeparator(final StringBuffer buffer); public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); public void append(final StringBuffer buffer, final String fieldName, final long value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); public void append(final StringBuffer buffer, final String fieldName, final int value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); public void append(final StringBuffer buffer, final String fieldName, final short value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); public void append(final StringBuffer buffer, final String fieldName, final byte value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); public void append(final StringBuffer buffer, final String fieldName, final char value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); public void append(final StringBuffer buffer, final String fieldName, final double value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); public void append(final StringBuffer buffer, final String fieldName, final float value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); public void append(final StringBuffer buffer, final String fieldName, final boolean value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendClassName(final StringBuffer buffer, final Object object); protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); protected void appendContentStart(final StringBuffer buffer); protected void appendContentEnd(final StringBuffer buffer); protected void appendNullText(final StringBuffer buffer, final String fieldName); protected void appendFieldSeparator(final StringBuffer buffer); protected void appendFieldStart(final StringBuffer buffer, final String fieldName); protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); protected boolean isFullDetail(final Boolean fullDetailRequest); protected String getShortClassName(final Class<?> cls); protected boolean isUseClassName(); protected void setUseClassName(final boolean useClassName); protected boolean isUseShortClassName(); protected void setUseShortClassName(final boolean useShortClassName); protected boolean isUseIdentityHashCode(); protected void setUseIdentityHashCode(final boolean useIdentityHashCode); protected boolean isUseFieldNames(); protected void setUseFieldNames(final boolean useFieldNames); protected boolean isDefaultFullDetail(); protected void setDefaultFullDetail(final boolean defaultFullDetail); protected boolean isArrayContentDetail(); protected void setArrayContentDetail(final boolean arrayContentDetail); protected String getArrayStart(); protected void setArrayStart(String arrayStart); protected String getArrayEnd(); protected void setArrayEnd(String arrayEnd); protected String getArraySeparator(); protected void setArraySeparator(String arraySeparator); protected String getContentStart(); protected void setContentStart(String contentStart); protected String getContentEnd(); protected void setContentEnd(String contentEnd); protected String getFieldNameValueSeparator(); protected void setFieldNameValueSeparator(String fieldNameValueSeparator); protected String getFieldSeparator(); protected void setFieldSeparator(String fieldSeparator); protected boolean isFieldSeparatorAtStart(); protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); protected boolean isFieldSeparatorAtEnd(); protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); protected String getNullText(); protected void setNullText(String nullText); protected String getSizeStartText(); protected void setSizeStartText(String sizeStartText); protected String getSizeEndText(); protected void setSizeEndText(String sizeEndText); protected String getSummaryObjectStartText(); protected void setSummaryObjectStartText(String summaryObjectStartText); protected String getSummaryObjectEndText(); protected void setSummaryObjectEndText(String summaryObjectEndText); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); long serialVersionUID=Optional[-2587890625525655916L]; ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; boolean useFieldNames=Optional[true]; boolean useClassName=Optional[true]; boolean useShortClassName=Optional[false]; boolean useIdentityHashCode=Optional[true]; String contentStart=Optional["["]; String contentEnd=Optional["]"]; String fieldNameValueSeparator=Optional["="]; boolean fieldSeparatorAtStart=Optional[false]; boolean fieldSeparatorAtEnd=Optional[false]; String fieldSeparator=Optional[","]; String arrayStart=Optional["{"]; String arraySeparator=Optional[","]; boolean arrayContentDetail=Optional[true]; String arrayEnd=Optional["}
protected void appendIdentityHashCode(final StringBuffer buffer, final Object object) { [EOL]     if (this.isUseIdentityHashCode() && object != null) { [EOL]         register(object); [EOL]         buffer.append('@'); [EOL]         buffer.append(Integer.toHexString(System.identityHashCode(object))); [EOL]     } [EOL] } protected ToStringStyle();  DefaultToStringStyle();  NoFieldNameToStringStyle();  ShortPrefixToStringStyle();  SimpleToStringStyle();  MultiLineToStringStyle();  static Map<Object, Object> getRegistry();  static boolean isRegistered(final Object value);  static void register(final Object value);  static void unregister(final Object value); public void appendSuper(final StringBuffer buffer, final String superToString); public void appendToString(final StringBuffer buffer, final String toString); public void appendStart(final StringBuffer buffer, final Object object); public void appendEnd(final StringBuffer buffer, final Object object); protected void removeLastFieldSeparator(final StringBuffer buffer); public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); public void append(final StringBuffer buffer, final String fieldName, final long value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); public void append(final StringBuffer buffer, final String fieldName, final int value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); public void append(final StringBuffer buffer, final String fieldName, final short value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); public void append(final StringBuffer buffer, final String fieldName, final byte value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); public void append(final StringBuffer buffer, final String fieldName, final char value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); public void append(final StringBuffer buffer, final String fieldName, final double value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); public void append(final StringBuffer buffer, final String fieldName, final float value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); public void append(final StringBuffer buffer, final String fieldName, final boolean value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendClassName(final StringBuffer buffer, final Object object); protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); protected void appendContentStart(final StringBuffer buffer); protected void appendContentEnd(final StringBuffer buffer); protected void appendNullText(final StringBuffer buffer, final String fieldName); protected void appendFieldSeparator(final StringBuffer buffer); protected void appendFieldStart(final StringBuffer buffer, final String fieldName); protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); protected boolean isFullDetail(final Boolean fullDetailRequest); protected String getShortClassName(final Class<?> cls); protected boolean isUseClassName(); protected void setUseClassName(final boolean useClassName); protected boolean isUseShortClassName(); protected void setUseShortClassName(final boolean useShortClassName); protected boolean isUseIdentityHashCode(); protected void setUseIdentityHashCode(final boolean useIdentityHashCode); protected boolean isUseFieldNames(); protected void setUseFieldNames(final boolean useFieldNames); protected boolean isDefaultFullDetail(); protected void setDefaultFullDetail(final boolean defaultFullDetail); protected boolean isArrayContentDetail(); protected void setArrayContentDetail(final boolean arrayContentDetail); protected String getArrayStart(); protected void setArrayStart(String arrayStart); protected String getArrayEnd(); protected void setArrayEnd(String arrayEnd); protected String getArraySeparator(); protected void setArraySeparator(String arraySeparator); protected String getContentStart(); protected void setContentStart(String contentStart); protected String getContentEnd(); protected void setContentEnd(String contentEnd); protected String getFieldNameValueSeparator(); protected void setFieldNameValueSeparator(String fieldNameValueSeparator); protected String getFieldSeparator(); protected void setFieldSeparator(String fieldSeparator); protected boolean isFieldSeparatorAtStart(); protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); protected boolean isFieldSeparatorAtEnd(); protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); protected String getNullText(); protected void setNullText(String nullText); protected String getSizeStartText(); protected void setSizeStartText(String sizeStartText); protected String getSizeEndText(); protected void setSizeEndText(String sizeEndText); protected String getSummaryObjectStartText(); protected void setSummaryObjectStartText(String summaryObjectStartText); protected String getSummaryObjectEndText(); protected void setSummaryObjectEndText(String summaryObjectEndText); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); long serialVersionUID=Optional[-2587890625525655916L]; ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; boolean useFieldNames=Optional[true]; boolean useClassName=Optional[true]; boolean useShortClassName=Optional[false]; boolean useIdentityHashCode=Optional[true]; String contentStart=Optional["["]; String contentEnd=Optional["]"]; String fieldNameValueSeparator=Optional["="]; boolean fieldSeparatorAtStart=Optional[false]; boolean fieldSeparatorAtEnd=Optional[false]; String fieldSeparator=Optional[","]; String arrayStart=Optional["{"]; String arraySeparator=Optional[","]; boolean arrayContentDetail=Optional[true]; String arrayEnd=Optional["}
protected void appendContentStart(final StringBuffer buffer) { [EOL]     buffer.append(contentStart); [EOL] } protected ToStringStyle();  DefaultToStringStyle();  NoFieldNameToStringStyle();  ShortPrefixToStringStyle();  SimpleToStringStyle();  MultiLineToStringStyle();  static Map<Object, Object> getRegistry();  static boolean isRegistered(final Object value);  static void register(final Object value);  static void unregister(final Object value); public void appendSuper(final StringBuffer buffer, final String superToString); public void appendToString(final StringBuffer buffer, final String toString); public void appendStart(final StringBuffer buffer, final Object object); public void appendEnd(final StringBuffer buffer, final Object object); protected void removeLastFieldSeparator(final StringBuffer buffer); public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); public void append(final StringBuffer buffer, final String fieldName, final long value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); public void append(final StringBuffer buffer, final String fieldName, final int value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); public void append(final StringBuffer buffer, final String fieldName, final short value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); public void append(final StringBuffer buffer, final String fieldName, final byte value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); public void append(final StringBuffer buffer, final String fieldName, final char value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); public void append(final StringBuffer buffer, final String fieldName, final double value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); public void append(final StringBuffer buffer, final String fieldName, final float value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); public void append(final StringBuffer buffer, final String fieldName, final boolean value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendClassName(final StringBuffer buffer, final Object object); protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); protected void appendContentStart(final StringBuffer buffer); protected void appendContentEnd(final StringBuffer buffer); protected void appendNullText(final StringBuffer buffer, final String fieldName); protected void appendFieldSeparator(final StringBuffer buffer); protected void appendFieldStart(final StringBuffer buffer, final String fieldName); protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); protected boolean isFullDetail(final Boolean fullDetailRequest); protected String getShortClassName(final Class<?> cls); protected boolean isUseClassName(); protected void setUseClassName(final boolean useClassName); protected boolean isUseShortClassName(); protected void setUseShortClassName(final boolean useShortClassName); protected boolean isUseIdentityHashCode(); protected void setUseIdentityHashCode(final boolean useIdentityHashCode); protected boolean isUseFieldNames(); protected void setUseFieldNames(final boolean useFieldNames); protected boolean isDefaultFullDetail(); protected void setDefaultFullDetail(final boolean defaultFullDetail); protected boolean isArrayContentDetail(); protected void setArrayContentDetail(final boolean arrayContentDetail); protected String getArrayStart(); protected void setArrayStart(String arrayStart); protected String getArrayEnd(); protected void setArrayEnd(String arrayEnd); protected String getArraySeparator(); protected void setArraySeparator(String arraySeparator); protected String getContentStart(); protected void setContentStart(String contentStart); protected String getContentEnd(); protected void setContentEnd(String contentEnd); protected String getFieldNameValueSeparator(); protected void setFieldNameValueSeparator(String fieldNameValueSeparator); protected String getFieldSeparator(); protected void setFieldSeparator(String fieldSeparator); protected boolean isFieldSeparatorAtStart(); protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); protected boolean isFieldSeparatorAtEnd(); protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); protected String getNullText(); protected void setNullText(String nullText); protected String getSizeStartText(); protected void setSizeStartText(String sizeStartText); protected String getSizeEndText(); protected void setSizeEndText(String sizeEndText); protected String getSummaryObjectStartText(); protected void setSummaryObjectStartText(String summaryObjectStartText); protected String getSummaryObjectEndText(); protected void setSummaryObjectEndText(String summaryObjectEndText); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); long serialVersionUID=Optional[-2587890625525655916L]; ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; boolean useFieldNames=Optional[true]; boolean useClassName=Optional[true]; boolean useShortClassName=Optional[false]; boolean useIdentityHashCode=Optional[true]; String contentStart=Optional["["]; String contentEnd=Optional["]"]; String fieldNameValueSeparator=Optional["="]; boolean fieldSeparatorAtStart=Optional[false]; boolean fieldSeparatorAtEnd=Optional[false]; String fieldSeparator=Optional[","]; String arrayStart=Optional["{"]; String arraySeparator=Optional[","]; boolean arrayContentDetail=Optional[true]; String arrayEnd=Optional["}
protected void appendContentEnd(final StringBuffer buffer) { [EOL]     buffer.append(contentEnd); [EOL] } protected ToStringStyle();  DefaultToStringStyle();  NoFieldNameToStringStyle();  ShortPrefixToStringStyle();  SimpleToStringStyle();  MultiLineToStringStyle();  static Map<Object, Object> getRegistry();  static boolean isRegistered(final Object value);  static void register(final Object value);  static void unregister(final Object value); public void appendSuper(final StringBuffer buffer, final String superToString); public void appendToString(final StringBuffer buffer, final String toString); public void appendStart(final StringBuffer buffer, final Object object); public void appendEnd(final StringBuffer buffer, final Object object); protected void removeLastFieldSeparator(final StringBuffer buffer); public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); public void append(final StringBuffer buffer, final String fieldName, final long value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); public void append(final StringBuffer buffer, final String fieldName, final int value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); public void append(final StringBuffer buffer, final String fieldName, final short value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); public void append(final StringBuffer buffer, final String fieldName, final byte value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); public void append(final StringBuffer buffer, final String fieldName, final char value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); public void append(final StringBuffer buffer, final String fieldName, final double value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); public void append(final StringBuffer buffer, final String fieldName, final float value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); public void append(final StringBuffer buffer, final String fieldName, final boolean value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendClassName(final StringBuffer buffer, final Object object); protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); protected void appendContentStart(final StringBuffer buffer); protected void appendContentEnd(final StringBuffer buffer); protected void appendNullText(final StringBuffer buffer, final String fieldName); protected void appendFieldSeparator(final StringBuffer buffer); protected void appendFieldStart(final StringBuffer buffer, final String fieldName); protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); protected boolean isFullDetail(final Boolean fullDetailRequest); protected String getShortClassName(final Class<?> cls); protected boolean isUseClassName(); protected void setUseClassName(final boolean useClassName); protected boolean isUseShortClassName(); protected void setUseShortClassName(final boolean useShortClassName); protected boolean isUseIdentityHashCode(); protected void setUseIdentityHashCode(final boolean useIdentityHashCode); protected boolean isUseFieldNames(); protected void setUseFieldNames(final boolean useFieldNames); protected boolean isDefaultFullDetail(); protected void setDefaultFullDetail(final boolean defaultFullDetail); protected boolean isArrayContentDetail(); protected void setArrayContentDetail(final boolean arrayContentDetail); protected String getArrayStart(); protected void setArrayStart(String arrayStart); protected String getArrayEnd(); protected void setArrayEnd(String arrayEnd); protected String getArraySeparator(); protected void setArraySeparator(String arraySeparator); protected String getContentStart(); protected void setContentStart(String contentStart); protected String getContentEnd(); protected void setContentEnd(String contentEnd); protected String getFieldNameValueSeparator(); protected void setFieldNameValueSeparator(String fieldNameValueSeparator); protected String getFieldSeparator(); protected void setFieldSeparator(String fieldSeparator); protected boolean isFieldSeparatorAtStart(); protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); protected boolean isFieldSeparatorAtEnd(); protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); protected String getNullText(); protected void setNullText(String nullText); protected String getSizeStartText(); protected void setSizeStartText(String sizeStartText); protected String getSizeEndText(); protected void setSizeEndText(String sizeEndText); protected String getSummaryObjectStartText(); protected void setSummaryObjectStartText(String summaryObjectStartText); protected String getSummaryObjectEndText(); protected void setSummaryObjectEndText(String summaryObjectEndText); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); long serialVersionUID=Optional[-2587890625525655916L]; ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; boolean useFieldNames=Optional[true]; boolean useClassName=Optional[true]; boolean useShortClassName=Optional[false]; boolean useIdentityHashCode=Optional[true]; String contentStart=Optional["["]; String contentEnd=Optional["]"]; String fieldNameValueSeparator=Optional["="]; boolean fieldSeparatorAtStart=Optional[false]; boolean fieldSeparatorAtEnd=Optional[false]; String fieldSeparator=Optional[","]; String arrayStart=Optional["{"]; String arraySeparator=Optional[","]; boolean arrayContentDetail=Optional[true]; String arrayEnd=Optional["}
protected void appendNullText(final StringBuffer buffer, final String fieldName) { [EOL]     buffer.append(nullText); [EOL] } protected ToStringStyle();  DefaultToStringStyle();  NoFieldNameToStringStyle();  ShortPrefixToStringStyle();  SimpleToStringStyle();  MultiLineToStringStyle();  static Map<Object, Object> getRegistry();  static boolean isRegistered(final Object value);  static void register(final Object value);  static void unregister(final Object value); public void appendSuper(final StringBuffer buffer, final String superToString); public void appendToString(final StringBuffer buffer, final String toString); public void appendStart(final StringBuffer buffer, final Object object); public void appendEnd(final StringBuffer buffer, final Object object); protected void removeLastFieldSeparator(final StringBuffer buffer); public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); public void append(final StringBuffer buffer, final String fieldName, final long value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); public void append(final StringBuffer buffer, final String fieldName, final int value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); public void append(final StringBuffer buffer, final String fieldName, final short value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); public void append(final StringBuffer buffer, final String fieldName, final byte value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); public void append(final StringBuffer buffer, final String fieldName, final char value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); public void append(final StringBuffer buffer, final String fieldName, final double value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); public void append(final StringBuffer buffer, final String fieldName, final float value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); public void append(final StringBuffer buffer, final String fieldName, final boolean value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendClassName(final StringBuffer buffer, final Object object); protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); protected void appendContentStart(final StringBuffer buffer); protected void appendContentEnd(final StringBuffer buffer); protected void appendNullText(final StringBuffer buffer, final String fieldName); protected void appendFieldSeparator(final StringBuffer buffer); protected void appendFieldStart(final StringBuffer buffer, final String fieldName); protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); protected boolean isFullDetail(final Boolean fullDetailRequest); protected String getShortClassName(final Class<?> cls); protected boolean isUseClassName(); protected void setUseClassName(final boolean useClassName); protected boolean isUseShortClassName(); protected void setUseShortClassName(final boolean useShortClassName); protected boolean isUseIdentityHashCode(); protected void setUseIdentityHashCode(final boolean useIdentityHashCode); protected boolean isUseFieldNames(); protected void setUseFieldNames(final boolean useFieldNames); protected boolean isDefaultFullDetail(); protected void setDefaultFullDetail(final boolean defaultFullDetail); protected boolean isArrayContentDetail(); protected void setArrayContentDetail(final boolean arrayContentDetail); protected String getArrayStart(); protected void setArrayStart(String arrayStart); protected String getArrayEnd(); protected void setArrayEnd(String arrayEnd); protected String getArraySeparator(); protected void setArraySeparator(String arraySeparator); protected String getContentStart(); protected void setContentStart(String contentStart); protected String getContentEnd(); protected void setContentEnd(String contentEnd); protected String getFieldNameValueSeparator(); protected void setFieldNameValueSeparator(String fieldNameValueSeparator); protected String getFieldSeparator(); protected void setFieldSeparator(String fieldSeparator); protected boolean isFieldSeparatorAtStart(); protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); protected boolean isFieldSeparatorAtEnd(); protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); protected String getNullText(); protected void setNullText(String nullText); protected String getSizeStartText(); protected void setSizeStartText(String sizeStartText); protected String getSizeEndText(); protected void setSizeEndText(String sizeEndText); protected String getSummaryObjectStartText(); protected void setSummaryObjectStartText(String summaryObjectStartText); protected String getSummaryObjectEndText(); protected void setSummaryObjectEndText(String summaryObjectEndText); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); long serialVersionUID=Optional[-2587890625525655916L]; ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; boolean useFieldNames=Optional[true]; boolean useClassName=Optional[true]; boolean useShortClassName=Optional[false]; boolean useIdentityHashCode=Optional[true]; String contentStart=Optional["["]; String contentEnd=Optional["]"]; String fieldNameValueSeparator=Optional["="]; boolean fieldSeparatorAtStart=Optional[false]; boolean fieldSeparatorAtEnd=Optional[false]; String fieldSeparator=Optional[","]; String arrayStart=Optional["{"]; String arraySeparator=Optional[","]; boolean arrayContentDetail=Optional[true]; String arrayEnd=Optional["}
protected void appendFieldSeparator(final StringBuffer buffer) { [EOL]     buffer.append(fieldSeparator); [EOL] } protected ToStringStyle();  DefaultToStringStyle();  NoFieldNameToStringStyle();  ShortPrefixToStringStyle();  SimpleToStringStyle();  MultiLineToStringStyle();  static Map<Object, Object> getRegistry();  static boolean isRegistered(final Object value);  static void register(final Object value);  static void unregister(final Object value); public void appendSuper(final StringBuffer buffer, final String superToString); public void appendToString(final StringBuffer buffer, final String toString); public void appendStart(final StringBuffer buffer, final Object object); public void appendEnd(final StringBuffer buffer, final Object object); protected void removeLastFieldSeparator(final StringBuffer buffer); public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); public void append(final StringBuffer buffer, final String fieldName, final long value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); public void append(final StringBuffer buffer, final String fieldName, final int value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); public void append(final StringBuffer buffer, final String fieldName, final short value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); public void append(final StringBuffer buffer, final String fieldName, final byte value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); public void append(final StringBuffer buffer, final String fieldName, final char value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); public void append(final StringBuffer buffer, final String fieldName, final double value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); public void append(final StringBuffer buffer, final String fieldName, final float value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); public void append(final StringBuffer buffer, final String fieldName, final boolean value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendClassName(final StringBuffer buffer, final Object object); protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); protected void appendContentStart(final StringBuffer buffer); protected void appendContentEnd(final StringBuffer buffer); protected void appendNullText(final StringBuffer buffer, final String fieldName); protected void appendFieldSeparator(final StringBuffer buffer); protected void appendFieldStart(final StringBuffer buffer, final String fieldName); protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); protected boolean isFullDetail(final Boolean fullDetailRequest); protected String getShortClassName(final Class<?> cls); protected boolean isUseClassName(); protected void setUseClassName(final boolean useClassName); protected boolean isUseShortClassName(); protected void setUseShortClassName(final boolean useShortClassName); protected boolean isUseIdentityHashCode(); protected void setUseIdentityHashCode(final boolean useIdentityHashCode); protected boolean isUseFieldNames(); protected void setUseFieldNames(final boolean useFieldNames); protected boolean isDefaultFullDetail(); protected void setDefaultFullDetail(final boolean defaultFullDetail); protected boolean isArrayContentDetail(); protected void setArrayContentDetail(final boolean arrayContentDetail); protected String getArrayStart(); protected void setArrayStart(String arrayStart); protected String getArrayEnd(); protected void setArrayEnd(String arrayEnd); protected String getArraySeparator(); protected void setArraySeparator(String arraySeparator); protected String getContentStart(); protected void setContentStart(String contentStart); protected String getContentEnd(); protected void setContentEnd(String contentEnd); protected String getFieldNameValueSeparator(); protected void setFieldNameValueSeparator(String fieldNameValueSeparator); protected String getFieldSeparator(); protected void setFieldSeparator(String fieldSeparator); protected boolean isFieldSeparatorAtStart(); protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); protected boolean isFieldSeparatorAtEnd(); protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); protected String getNullText(); protected void setNullText(String nullText); protected String getSizeStartText(); protected void setSizeStartText(String sizeStartText); protected String getSizeEndText(); protected void setSizeEndText(String sizeEndText); protected String getSummaryObjectStartText(); protected void setSummaryObjectStartText(String summaryObjectStartText); protected String getSummaryObjectEndText(); protected void setSummaryObjectEndText(String summaryObjectEndText); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); long serialVersionUID=Optional[-2587890625525655916L]; ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; boolean useFieldNames=Optional[true]; boolean useClassName=Optional[true]; boolean useShortClassName=Optional[false]; boolean useIdentityHashCode=Optional[true]; String contentStart=Optional["["]; String contentEnd=Optional["]"]; String fieldNameValueSeparator=Optional["="]; boolean fieldSeparatorAtStart=Optional[false]; boolean fieldSeparatorAtEnd=Optional[false]; String fieldSeparator=Optional[","]; String arrayStart=Optional["{"]; String arraySeparator=Optional[","]; boolean arrayContentDetail=Optional[true]; String arrayEnd=Optional["}
protected void appendFieldStart(final StringBuffer buffer, final String fieldName) { [EOL]     if (useFieldNames && fieldName != null) { [EOL]         buffer.append(fieldName); [EOL]         buffer.append(fieldNameValueSeparator); [EOL]     } [EOL] } protected ToStringStyle();  DefaultToStringStyle();  NoFieldNameToStringStyle();  ShortPrefixToStringStyle();  SimpleToStringStyle();  MultiLineToStringStyle();  static Map<Object, Object> getRegistry();  static boolean isRegistered(final Object value);  static void register(final Object value);  static void unregister(final Object value); public void appendSuper(final StringBuffer buffer, final String superToString); public void appendToString(final StringBuffer buffer, final String toString); public void appendStart(final StringBuffer buffer, final Object object); public void appendEnd(final StringBuffer buffer, final Object object); protected void removeLastFieldSeparator(final StringBuffer buffer); public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); public void append(final StringBuffer buffer, final String fieldName, final long value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); public void append(final StringBuffer buffer, final String fieldName, final int value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); public void append(final StringBuffer buffer, final String fieldName, final short value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); public void append(final StringBuffer buffer, final String fieldName, final byte value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); public void append(final StringBuffer buffer, final String fieldName, final char value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); public void append(final StringBuffer buffer, final String fieldName, final double value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); public void append(final StringBuffer buffer, final String fieldName, final float value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); public void append(final StringBuffer buffer, final String fieldName, final boolean value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendClassName(final StringBuffer buffer, final Object object); protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); protected void appendContentStart(final StringBuffer buffer); protected void appendContentEnd(final StringBuffer buffer); protected void appendNullText(final StringBuffer buffer, final String fieldName); protected void appendFieldSeparator(final StringBuffer buffer); protected void appendFieldStart(final StringBuffer buffer, final String fieldName); protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); protected boolean isFullDetail(final Boolean fullDetailRequest); protected String getShortClassName(final Class<?> cls); protected boolean isUseClassName(); protected void setUseClassName(final boolean useClassName); protected boolean isUseShortClassName(); protected void setUseShortClassName(final boolean useShortClassName); protected boolean isUseIdentityHashCode(); protected void setUseIdentityHashCode(final boolean useIdentityHashCode); protected boolean isUseFieldNames(); protected void setUseFieldNames(final boolean useFieldNames); protected boolean isDefaultFullDetail(); protected void setDefaultFullDetail(final boolean defaultFullDetail); protected boolean isArrayContentDetail(); protected void setArrayContentDetail(final boolean arrayContentDetail); protected String getArrayStart(); protected void setArrayStart(String arrayStart); protected String getArrayEnd(); protected void setArrayEnd(String arrayEnd); protected String getArraySeparator(); protected void setArraySeparator(String arraySeparator); protected String getContentStart(); protected void setContentStart(String contentStart); protected String getContentEnd(); protected void setContentEnd(String contentEnd); protected String getFieldNameValueSeparator(); protected void setFieldNameValueSeparator(String fieldNameValueSeparator); protected String getFieldSeparator(); protected void setFieldSeparator(String fieldSeparator); protected boolean isFieldSeparatorAtStart(); protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); protected boolean isFieldSeparatorAtEnd(); protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); protected String getNullText(); protected void setNullText(String nullText); protected String getSizeStartText(); protected void setSizeStartText(String sizeStartText); protected String getSizeEndText(); protected void setSizeEndText(String sizeEndText); protected String getSummaryObjectStartText(); protected void setSummaryObjectStartText(String summaryObjectStartText); protected String getSummaryObjectEndText(); protected void setSummaryObjectEndText(String summaryObjectEndText); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); long serialVersionUID=Optional[-2587890625525655916L]; ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; boolean useFieldNames=Optional[true]; boolean useClassName=Optional[true]; boolean useShortClassName=Optional[false]; boolean useIdentityHashCode=Optional[true]; String contentStart=Optional["["]; String contentEnd=Optional["]"]; String fieldNameValueSeparator=Optional["="]; boolean fieldSeparatorAtStart=Optional[false]; boolean fieldSeparatorAtEnd=Optional[false]; String fieldSeparator=Optional[","]; String arrayStart=Optional["{"]; String arraySeparator=Optional[","]; boolean arrayContentDetail=Optional[true]; String arrayEnd=Optional["}
protected void appendFieldEnd(final StringBuffer buffer, final String fieldName) { [EOL]     appendFieldSeparator(buffer); [EOL] } protected ToStringStyle();  DefaultToStringStyle();  NoFieldNameToStringStyle();  ShortPrefixToStringStyle();  SimpleToStringStyle();  MultiLineToStringStyle();  static Map<Object, Object> getRegistry();  static boolean isRegistered(final Object value);  static void register(final Object value);  static void unregister(final Object value); public void appendSuper(final StringBuffer buffer, final String superToString); public void appendToString(final StringBuffer buffer, final String toString); public void appendStart(final StringBuffer buffer, final Object object); public void appendEnd(final StringBuffer buffer, final Object object); protected void removeLastFieldSeparator(final StringBuffer buffer); public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); public void append(final StringBuffer buffer, final String fieldName, final long value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); public void append(final StringBuffer buffer, final String fieldName, final int value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); public void append(final StringBuffer buffer, final String fieldName, final short value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); public void append(final StringBuffer buffer, final String fieldName, final byte value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); public void append(final StringBuffer buffer, final String fieldName, final char value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); public void append(final StringBuffer buffer, final String fieldName, final double value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); public void append(final StringBuffer buffer, final String fieldName, final float value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); public void append(final StringBuffer buffer, final String fieldName, final boolean value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendClassName(final StringBuffer buffer, final Object object); protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); protected void appendContentStart(final StringBuffer buffer); protected void appendContentEnd(final StringBuffer buffer); protected void appendNullText(final StringBuffer buffer, final String fieldName); protected void appendFieldSeparator(final StringBuffer buffer); protected void appendFieldStart(final StringBuffer buffer, final String fieldName); protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); protected boolean isFullDetail(final Boolean fullDetailRequest); protected String getShortClassName(final Class<?> cls); protected boolean isUseClassName(); protected void setUseClassName(final boolean useClassName); protected boolean isUseShortClassName(); protected void setUseShortClassName(final boolean useShortClassName); protected boolean isUseIdentityHashCode(); protected void setUseIdentityHashCode(final boolean useIdentityHashCode); protected boolean isUseFieldNames(); protected void setUseFieldNames(final boolean useFieldNames); protected boolean isDefaultFullDetail(); protected void setDefaultFullDetail(final boolean defaultFullDetail); protected boolean isArrayContentDetail(); protected void setArrayContentDetail(final boolean arrayContentDetail); protected String getArrayStart(); protected void setArrayStart(String arrayStart); protected String getArrayEnd(); protected void setArrayEnd(String arrayEnd); protected String getArraySeparator(); protected void setArraySeparator(String arraySeparator); protected String getContentStart(); protected void setContentStart(String contentStart); protected String getContentEnd(); protected void setContentEnd(String contentEnd); protected String getFieldNameValueSeparator(); protected void setFieldNameValueSeparator(String fieldNameValueSeparator); protected String getFieldSeparator(); protected void setFieldSeparator(String fieldSeparator); protected boolean isFieldSeparatorAtStart(); protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); protected boolean isFieldSeparatorAtEnd(); protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); protected String getNullText(); protected void setNullText(String nullText); protected String getSizeStartText(); protected void setSizeStartText(String sizeStartText); protected String getSizeEndText(); protected void setSizeEndText(String sizeEndText); protected String getSummaryObjectStartText(); protected void setSummaryObjectStartText(String summaryObjectStartText); protected String getSummaryObjectEndText(); protected void setSummaryObjectEndText(String summaryObjectEndText); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); long serialVersionUID=Optional[-2587890625525655916L]; ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; boolean useFieldNames=Optional[true]; boolean useClassName=Optional[true]; boolean useShortClassName=Optional[false]; boolean useIdentityHashCode=Optional[true]; String contentStart=Optional["["]; String contentEnd=Optional["]"]; String fieldNameValueSeparator=Optional["="]; boolean fieldSeparatorAtStart=Optional[false]; boolean fieldSeparatorAtEnd=Optional[false]; String fieldSeparator=Optional[","]; String arrayStart=Optional["{"]; String arraySeparator=Optional[","]; boolean arrayContentDetail=Optional[true]; String arrayEnd=Optional["}
protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size) { [EOL]     buffer.append(sizeStartText); [EOL]     buffer.append(size); [EOL]     buffer.append(sizeEndText); [EOL] } protected ToStringStyle();  DefaultToStringStyle();  NoFieldNameToStringStyle();  ShortPrefixToStringStyle();  SimpleToStringStyle();  MultiLineToStringStyle();  static Map<Object, Object> getRegistry();  static boolean isRegistered(final Object value);  static void register(final Object value);  static void unregister(final Object value); public void appendSuper(final StringBuffer buffer, final String superToString); public void appendToString(final StringBuffer buffer, final String toString); public void appendStart(final StringBuffer buffer, final Object object); public void appendEnd(final StringBuffer buffer, final Object object); protected void removeLastFieldSeparator(final StringBuffer buffer); public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); public void append(final StringBuffer buffer, final String fieldName, final long value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); public void append(final StringBuffer buffer, final String fieldName, final int value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); public void append(final StringBuffer buffer, final String fieldName, final short value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); public void append(final StringBuffer buffer, final String fieldName, final byte value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); public void append(final StringBuffer buffer, final String fieldName, final char value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); public void append(final StringBuffer buffer, final String fieldName, final double value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); public void append(final StringBuffer buffer, final String fieldName, final float value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); public void append(final StringBuffer buffer, final String fieldName, final boolean value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendClassName(final StringBuffer buffer, final Object object); protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); protected void appendContentStart(final StringBuffer buffer); protected void appendContentEnd(final StringBuffer buffer); protected void appendNullText(final StringBuffer buffer, final String fieldName); protected void appendFieldSeparator(final StringBuffer buffer); protected void appendFieldStart(final StringBuffer buffer, final String fieldName); protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); protected boolean isFullDetail(final Boolean fullDetailRequest); protected String getShortClassName(final Class<?> cls); protected boolean isUseClassName(); protected void setUseClassName(final boolean useClassName); protected boolean isUseShortClassName(); protected void setUseShortClassName(final boolean useShortClassName); protected boolean isUseIdentityHashCode(); protected void setUseIdentityHashCode(final boolean useIdentityHashCode); protected boolean isUseFieldNames(); protected void setUseFieldNames(final boolean useFieldNames); protected boolean isDefaultFullDetail(); protected void setDefaultFullDetail(final boolean defaultFullDetail); protected boolean isArrayContentDetail(); protected void setArrayContentDetail(final boolean arrayContentDetail); protected String getArrayStart(); protected void setArrayStart(String arrayStart); protected String getArrayEnd(); protected void setArrayEnd(String arrayEnd); protected String getArraySeparator(); protected void setArraySeparator(String arraySeparator); protected String getContentStart(); protected void setContentStart(String contentStart); protected String getContentEnd(); protected void setContentEnd(String contentEnd); protected String getFieldNameValueSeparator(); protected void setFieldNameValueSeparator(String fieldNameValueSeparator); protected String getFieldSeparator(); protected void setFieldSeparator(String fieldSeparator); protected boolean isFieldSeparatorAtStart(); protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); protected boolean isFieldSeparatorAtEnd(); protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); protected String getNullText(); protected void setNullText(String nullText); protected String getSizeStartText(); protected void setSizeStartText(String sizeStartText); protected String getSizeEndText(); protected void setSizeEndText(String sizeEndText); protected String getSummaryObjectStartText(); protected void setSummaryObjectStartText(String summaryObjectStartText); protected String getSummaryObjectEndText(); protected void setSummaryObjectEndText(String summaryObjectEndText); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); long serialVersionUID=Optional[-2587890625525655916L]; ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; boolean useFieldNames=Optional[true]; boolean useClassName=Optional[true]; boolean useShortClassName=Optional[false]; boolean useIdentityHashCode=Optional[true]; String contentStart=Optional["["]; String contentEnd=Optional["]"]; String fieldNameValueSeparator=Optional["="]; boolean fieldSeparatorAtStart=Optional[false]; boolean fieldSeparatorAtEnd=Optional[false]; String fieldSeparator=Optional[","]; String arrayStart=Optional["{"]; String arraySeparator=Optional[","]; boolean arrayContentDetail=Optional[true]; String arrayEnd=Optional["}
protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size) { [EOL]     buffer.append(sizeStartText); [EOL]     buffer.append(size); [EOL]     buffer.append(sizeEndText); [EOL] } protected ToStringStyle();  DefaultToStringStyle();  NoFieldNameToStringStyle();  ShortPrefixToStringStyle();  SimpleToStringStyle();  MultiLineToStringStyle();  static Map<Object, Object> getRegistry();  static boolean isRegistered(final Object value);  static void register(final Object value);  static void unregister(final Object value); public void appendSuper(final StringBuffer buffer, final String superToString); public void appendToString(final StringBuffer buffer, final String toString); public void appendStart(final StringBuffer buffer, final Object object); public void appendEnd(final StringBuffer buffer, final Object object); protected void removeLastFieldSeparator(final StringBuffer buffer); public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); public void append(final StringBuffer buffer, final String fieldName, final long value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); public void append(final StringBuffer buffer, final String fieldName, final int value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); public void append(final StringBuffer buffer, final String fieldName, final short value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); public void append(final StringBuffer buffer, final String fieldName, final byte value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); public void append(final StringBuffer buffer, final String fieldName, final char value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); public void append(final StringBuffer buffer, final String fieldName, final double value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); public void append(final StringBuffer buffer, final String fieldName, final float value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); public void append(final StringBuffer buffer, final String fieldName, final boolean value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendClassName(final StringBuffer buffer, final Object object); protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); protected void appendContentStart(final StringBuffer buffer); protected void appendContentEnd(final StringBuffer buffer); protected void appendNullText(final StringBuffer buffer, final String fieldName); protected void appendFieldSeparator(final StringBuffer buffer); protected void appendFieldStart(final StringBuffer buffer, final String fieldName); protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); protected boolean isFullDetail(final Boolean fullDetailRequest); protected String getShortClassName(final Class<?> cls); protected boolean isUseClassName(); protected void setUseClassName(final boolean useClassName); protected boolean isUseShortClassName(); protected void setUseShortClassName(final boolean useShortClassName); protected boolean isUseIdentityHashCode(); protected void setUseIdentityHashCode(final boolean useIdentityHashCode); protected boolean isUseFieldNames(); protected void setUseFieldNames(final boolean useFieldNames); protected boolean isDefaultFullDetail(); protected void setDefaultFullDetail(final boolean defaultFullDetail); protected boolean isArrayContentDetail(); protected void setArrayContentDetail(final boolean arrayContentDetail); protected String getArrayStart(); protected void setArrayStart(String arrayStart); protected String getArrayEnd(); protected void setArrayEnd(String arrayEnd); protected String getArraySeparator(); protected void setArraySeparator(String arraySeparator); protected String getContentStart(); protected void setContentStart(String contentStart); protected String getContentEnd(); protected void setContentEnd(String contentEnd); protected String getFieldNameValueSeparator(); protected void setFieldNameValueSeparator(String fieldNameValueSeparator); protected String getFieldSeparator(); protected void setFieldSeparator(String fieldSeparator); protected boolean isFieldSeparatorAtStart(); protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); protected boolean isFieldSeparatorAtEnd(); protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); protected String getNullText(); protected void setNullText(String nullText); protected String getSizeStartText(); protected void setSizeStartText(String sizeStartText); protected String getSizeEndText(); protected void setSizeEndText(String sizeEndText); protected String getSummaryObjectStartText(); protected void setSummaryObjectStartText(String summaryObjectStartText); protected String getSummaryObjectEndText(); protected void setSummaryObjectEndText(String summaryObjectEndText); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); long serialVersionUID=Optional[-2587890625525655916L]; ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; boolean useFieldNames=Optional[true]; boolean useClassName=Optional[true]; boolean useShortClassName=Optional[false]; boolean useIdentityHashCode=Optional[true]; String contentStart=Optional["["]; String contentEnd=Optional["]"]; String fieldNameValueSeparator=Optional["="]; boolean fieldSeparatorAtStart=Optional[false]; boolean fieldSeparatorAtEnd=Optional[false]; String fieldSeparator=Optional[","]; String arrayStart=Optional["{"]; String arraySeparator=Optional[","]; boolean arrayContentDetail=Optional[true]; String arrayEnd=Optional["}
protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size) { [EOL]     buffer.append(sizeStartText); [EOL]     buffer.append(size); [EOL]     buffer.append(sizeEndText); [EOL] } protected ToStringStyle();  DefaultToStringStyle();  NoFieldNameToStringStyle();  ShortPrefixToStringStyle();  SimpleToStringStyle();  MultiLineToStringStyle();  static Map<Object, Object> getRegistry();  static boolean isRegistered(final Object value);  static void register(final Object value);  static void unregister(final Object value); public void appendSuper(final StringBuffer buffer, final String superToString); public void appendToString(final StringBuffer buffer, final String toString); public void appendStart(final StringBuffer buffer, final Object object); public void appendEnd(final StringBuffer buffer, final Object object); protected void removeLastFieldSeparator(final StringBuffer buffer); public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); public void append(final StringBuffer buffer, final String fieldName, final long value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); public void append(final StringBuffer buffer, final String fieldName, final int value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); public void append(final StringBuffer buffer, final String fieldName, final short value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); public void append(final StringBuffer buffer, final String fieldName, final byte value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); public void append(final StringBuffer buffer, final String fieldName, final char value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); public void append(final StringBuffer buffer, final String fieldName, final double value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); public void append(final StringBuffer buffer, final String fieldName, final float value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); public void append(final StringBuffer buffer, final String fieldName, final boolean value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendClassName(final StringBuffer buffer, final Object object); protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); protected void appendContentStart(final StringBuffer buffer); protected void appendContentEnd(final StringBuffer buffer); protected void appendNullText(final StringBuffer buffer, final String fieldName); protected void appendFieldSeparator(final StringBuffer buffer); protected void appendFieldStart(final StringBuffer buffer, final String fieldName); protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); protected boolean isFullDetail(final Boolean fullDetailRequest); protected String getShortClassName(final Class<?> cls); protected boolean isUseClassName(); protected void setUseClassName(final boolean useClassName); protected boolean isUseShortClassName(); protected void setUseShortClassName(final boolean useShortClassName); protected boolean isUseIdentityHashCode(); protected void setUseIdentityHashCode(final boolean useIdentityHashCode); protected boolean isUseFieldNames(); protected void setUseFieldNames(final boolean useFieldNames); protected boolean isDefaultFullDetail(); protected void setDefaultFullDetail(final boolean defaultFullDetail); protected boolean isArrayContentDetail(); protected void setArrayContentDetail(final boolean arrayContentDetail); protected String getArrayStart(); protected void setArrayStart(String arrayStart); protected String getArrayEnd(); protected void setArrayEnd(String arrayEnd); protected String getArraySeparator(); protected void setArraySeparator(String arraySeparator); protected String getContentStart(); protected void setContentStart(String contentStart); protected String getContentEnd(); protected void setContentEnd(String contentEnd); protected String getFieldNameValueSeparator(); protected void setFieldNameValueSeparator(String fieldNameValueSeparator); protected String getFieldSeparator(); protected void setFieldSeparator(String fieldSeparator); protected boolean isFieldSeparatorAtStart(); protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); protected boolean isFieldSeparatorAtEnd(); protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); protected String getNullText(); protected void setNullText(String nullText); protected String getSizeStartText(); protected void setSizeStartText(String sizeStartText); protected String getSizeEndText(); protected void setSizeEndText(String sizeEndText); protected String getSummaryObjectStartText(); protected void setSummaryObjectStartText(String summaryObjectStartText); protected String getSummaryObjectEndText(); protected void setSummaryObjectEndText(String summaryObjectEndText); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); long serialVersionUID=Optional[-2587890625525655916L]; ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; boolean useFieldNames=Optional[true]; boolean useClassName=Optional[true]; boolean useShortClassName=Optional[false]; boolean useIdentityHashCode=Optional[true]; String contentStart=Optional["["]; String contentEnd=Optional["]"]; String fieldNameValueSeparator=Optional["="]; boolean fieldSeparatorAtStart=Optional[false]; boolean fieldSeparatorAtEnd=Optional[false]; String fieldSeparator=Optional[","]; String arrayStart=Optional["{"]; String arraySeparator=Optional[","]; boolean arrayContentDetail=Optional[true]; String arrayEnd=Optional["}
protected boolean isFullDetail(final Boolean fullDetailRequest) { [EOL]     if (fullDetailRequest == null) { [EOL]         return defaultFullDetail; [EOL]     } [EOL]     return fullDetailRequest.booleanValue(); [EOL] } protected ToStringStyle();  DefaultToStringStyle();  NoFieldNameToStringStyle();  ShortPrefixToStringStyle();  SimpleToStringStyle();  MultiLineToStringStyle();  static Map<Object, Object> getRegistry();  static boolean isRegistered(final Object value);  static void register(final Object value);  static void unregister(final Object value); public void appendSuper(final StringBuffer buffer, final String superToString); public void appendToString(final StringBuffer buffer, final String toString); public void appendStart(final StringBuffer buffer, final Object object); public void appendEnd(final StringBuffer buffer, final Object object); protected void removeLastFieldSeparator(final StringBuffer buffer); public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); public void append(final StringBuffer buffer, final String fieldName, final long value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); public void append(final StringBuffer buffer, final String fieldName, final int value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); public void append(final StringBuffer buffer, final String fieldName, final short value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); public void append(final StringBuffer buffer, final String fieldName, final byte value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); public void append(final StringBuffer buffer, final String fieldName, final char value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); public void append(final StringBuffer buffer, final String fieldName, final double value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); public void append(final StringBuffer buffer, final String fieldName, final float value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); public void append(final StringBuffer buffer, final String fieldName, final boolean value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendClassName(final StringBuffer buffer, final Object object); protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); protected void appendContentStart(final StringBuffer buffer); protected void appendContentEnd(final StringBuffer buffer); protected void appendNullText(final StringBuffer buffer, final String fieldName); protected void appendFieldSeparator(final StringBuffer buffer); protected void appendFieldStart(final StringBuffer buffer, final String fieldName); protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); protected boolean isFullDetail(final Boolean fullDetailRequest); protected String getShortClassName(final Class<?> cls); protected boolean isUseClassName(); protected void setUseClassName(final boolean useClassName); protected boolean isUseShortClassName(); protected void setUseShortClassName(final boolean useShortClassName); protected boolean isUseIdentityHashCode(); protected void setUseIdentityHashCode(final boolean useIdentityHashCode); protected boolean isUseFieldNames(); protected void setUseFieldNames(final boolean useFieldNames); protected boolean isDefaultFullDetail(); protected void setDefaultFullDetail(final boolean defaultFullDetail); protected boolean isArrayContentDetail(); protected void setArrayContentDetail(final boolean arrayContentDetail); protected String getArrayStart(); protected void setArrayStart(String arrayStart); protected String getArrayEnd(); protected void setArrayEnd(String arrayEnd); protected String getArraySeparator(); protected void setArraySeparator(String arraySeparator); protected String getContentStart(); protected void setContentStart(String contentStart); protected String getContentEnd(); protected void setContentEnd(String contentEnd); protected String getFieldNameValueSeparator(); protected void setFieldNameValueSeparator(String fieldNameValueSeparator); protected String getFieldSeparator(); protected void setFieldSeparator(String fieldSeparator); protected boolean isFieldSeparatorAtStart(); protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); protected boolean isFieldSeparatorAtEnd(); protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); protected String getNullText(); protected void setNullText(String nullText); protected String getSizeStartText(); protected void setSizeStartText(String sizeStartText); protected String getSizeEndText(); protected void setSizeEndText(String sizeEndText); protected String getSummaryObjectStartText(); protected void setSummaryObjectStartText(String summaryObjectStartText); protected String getSummaryObjectEndText(); protected void setSummaryObjectEndText(String summaryObjectEndText); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); long serialVersionUID=Optional[-2587890625525655916L]; ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; boolean useFieldNames=Optional[true]; boolean useClassName=Optional[true]; boolean useShortClassName=Optional[false]; boolean useIdentityHashCode=Optional[true]; String contentStart=Optional["["]; String contentEnd=Optional["]"]; String fieldNameValueSeparator=Optional["="]; boolean fieldSeparatorAtStart=Optional[false]; boolean fieldSeparatorAtEnd=Optional[false]; String fieldSeparator=Optional[","]; String arrayStart=Optional["{"]; String arraySeparator=Optional[","]; boolean arrayContentDetail=Optional[true]; String arrayEnd=Optional["}
protected String getShortClassName(final Class<?> cls) { [EOL]     return ClassUtils.getShortClassName(cls); [EOL] } protected ToStringStyle();  DefaultToStringStyle();  NoFieldNameToStringStyle();  ShortPrefixToStringStyle();  SimpleToStringStyle();  MultiLineToStringStyle();  static Map<Object, Object> getRegistry();  static boolean isRegistered(final Object value);  static void register(final Object value);  static void unregister(final Object value); public void appendSuper(final StringBuffer buffer, final String superToString); public void appendToString(final StringBuffer buffer, final String toString); public void appendStart(final StringBuffer buffer, final Object object); public void appendEnd(final StringBuffer buffer, final Object object); protected void removeLastFieldSeparator(final StringBuffer buffer); public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); public void append(final StringBuffer buffer, final String fieldName, final long value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); public void append(final StringBuffer buffer, final String fieldName, final int value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); public void append(final StringBuffer buffer, final String fieldName, final short value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); public void append(final StringBuffer buffer, final String fieldName, final byte value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); public void append(final StringBuffer buffer, final String fieldName, final char value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); public void append(final StringBuffer buffer, final String fieldName, final double value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); public void append(final StringBuffer buffer, final String fieldName, final float value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); public void append(final StringBuffer buffer, final String fieldName, final boolean value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendClassName(final StringBuffer buffer, final Object object); protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); protected void appendContentStart(final StringBuffer buffer); protected void appendContentEnd(final StringBuffer buffer); protected void appendNullText(final StringBuffer buffer, final String fieldName); protected void appendFieldSeparator(final StringBuffer buffer); protected void appendFieldStart(final StringBuffer buffer, final String fieldName); protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); protected boolean isFullDetail(final Boolean fullDetailRequest); protected String getShortClassName(final Class<?> cls); protected boolean isUseClassName(); protected void setUseClassName(final boolean useClassName); protected boolean isUseShortClassName(); protected void setUseShortClassName(final boolean useShortClassName); protected boolean isUseIdentityHashCode(); protected void setUseIdentityHashCode(final boolean useIdentityHashCode); protected boolean isUseFieldNames(); protected void setUseFieldNames(final boolean useFieldNames); protected boolean isDefaultFullDetail(); protected void setDefaultFullDetail(final boolean defaultFullDetail); protected boolean isArrayContentDetail(); protected void setArrayContentDetail(final boolean arrayContentDetail); protected String getArrayStart(); protected void setArrayStart(String arrayStart); protected String getArrayEnd(); protected void setArrayEnd(String arrayEnd); protected String getArraySeparator(); protected void setArraySeparator(String arraySeparator); protected String getContentStart(); protected void setContentStart(String contentStart); protected String getContentEnd(); protected void setContentEnd(String contentEnd); protected String getFieldNameValueSeparator(); protected void setFieldNameValueSeparator(String fieldNameValueSeparator); protected String getFieldSeparator(); protected void setFieldSeparator(String fieldSeparator); protected boolean isFieldSeparatorAtStart(); protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); protected boolean isFieldSeparatorAtEnd(); protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); protected String getNullText(); protected void setNullText(String nullText); protected String getSizeStartText(); protected void setSizeStartText(String sizeStartText); protected String getSizeEndText(); protected void setSizeEndText(String sizeEndText); protected String getSummaryObjectStartText(); protected void setSummaryObjectStartText(String summaryObjectStartText); protected String getSummaryObjectEndText(); protected void setSummaryObjectEndText(String summaryObjectEndText); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); long serialVersionUID=Optional[-2587890625525655916L]; ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; boolean useFieldNames=Optional[true]; boolean useClassName=Optional[true]; boolean useShortClassName=Optional[false]; boolean useIdentityHashCode=Optional[true]; String contentStart=Optional["["]; String contentEnd=Optional["]"]; String fieldNameValueSeparator=Optional["="]; boolean fieldSeparatorAtStart=Optional[false]; boolean fieldSeparatorAtEnd=Optional[false]; String fieldSeparator=Optional[","]; String arrayStart=Optional["{"]; String arraySeparator=Optional[","]; boolean arrayContentDetail=Optional[true]; String arrayEnd=Optional["}
protected boolean isUseIdentityHashCode() { [EOL]     return useIdentityHashCode; [EOL] } protected ToStringStyle();  DefaultToStringStyle();  NoFieldNameToStringStyle();  ShortPrefixToStringStyle();  SimpleToStringStyle();  MultiLineToStringStyle();  static Map<Object, Object> getRegistry();  static boolean isRegistered(final Object value);  static void register(final Object value);  static void unregister(final Object value); public void appendSuper(final StringBuffer buffer, final String superToString); public void appendToString(final StringBuffer buffer, final String toString); public void appendStart(final StringBuffer buffer, final Object object); public void appendEnd(final StringBuffer buffer, final Object object); protected void removeLastFieldSeparator(final StringBuffer buffer); public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); public void append(final StringBuffer buffer, final String fieldName, final long value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); public void append(final StringBuffer buffer, final String fieldName, final int value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); public void append(final StringBuffer buffer, final String fieldName, final short value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); public void append(final StringBuffer buffer, final String fieldName, final byte value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); public void append(final StringBuffer buffer, final String fieldName, final char value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); public void append(final StringBuffer buffer, final String fieldName, final double value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); public void append(final StringBuffer buffer, final String fieldName, final float value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); public void append(final StringBuffer buffer, final String fieldName, final boolean value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendClassName(final StringBuffer buffer, final Object object); protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); protected void appendContentStart(final StringBuffer buffer); protected void appendContentEnd(final StringBuffer buffer); protected void appendNullText(final StringBuffer buffer, final String fieldName); protected void appendFieldSeparator(final StringBuffer buffer); protected void appendFieldStart(final StringBuffer buffer, final String fieldName); protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); protected boolean isFullDetail(final Boolean fullDetailRequest); protected String getShortClassName(final Class<?> cls); protected boolean isUseClassName(); protected void setUseClassName(final boolean useClassName); protected boolean isUseShortClassName(); protected void setUseShortClassName(final boolean useShortClassName); protected boolean isUseIdentityHashCode(); protected void setUseIdentityHashCode(final boolean useIdentityHashCode); protected boolean isUseFieldNames(); protected void setUseFieldNames(final boolean useFieldNames); protected boolean isDefaultFullDetail(); protected void setDefaultFullDetail(final boolean defaultFullDetail); protected boolean isArrayContentDetail(); protected void setArrayContentDetail(final boolean arrayContentDetail); protected String getArrayStart(); protected void setArrayStart(String arrayStart); protected String getArrayEnd(); protected void setArrayEnd(String arrayEnd); protected String getArraySeparator(); protected void setArraySeparator(String arraySeparator); protected String getContentStart(); protected void setContentStart(String contentStart); protected String getContentEnd(); protected void setContentEnd(String contentEnd); protected String getFieldNameValueSeparator(); protected void setFieldNameValueSeparator(String fieldNameValueSeparator); protected String getFieldSeparator(); protected void setFieldSeparator(String fieldSeparator); protected boolean isFieldSeparatorAtStart(); protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); protected boolean isFieldSeparatorAtEnd(); protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); protected String getNullText(); protected void setNullText(String nullText); protected String getSizeStartText(); protected void setSizeStartText(String sizeStartText); protected String getSizeEndText(); protected void setSizeEndText(String sizeEndText); protected String getSummaryObjectStartText(); protected void setSummaryObjectStartText(String summaryObjectStartText); protected String getSummaryObjectEndText(); protected void setSummaryObjectEndText(String summaryObjectEndText); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); long serialVersionUID=Optional[-2587890625525655916L]; ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; boolean useFieldNames=Optional[true]; boolean useClassName=Optional[true]; boolean useShortClassName=Optional[false]; boolean useIdentityHashCode=Optional[true]; String contentStart=Optional["["]; String contentEnd=Optional["]"]; String fieldNameValueSeparator=Optional["="]; boolean fieldSeparatorAtStart=Optional[false]; boolean fieldSeparatorAtEnd=Optional[false]; String fieldSeparator=Optional[","]; String arrayStart=Optional["{"]; String arraySeparator=Optional[","]; boolean arrayContentDetail=Optional[true]; String arrayEnd=Optional["}
protected String getSummaryObjectEndText() { [EOL]     return summaryObjectEndText; [EOL] } protected ToStringStyle();  DefaultToStringStyle();  NoFieldNameToStringStyle();  ShortPrefixToStringStyle();  SimpleToStringStyle();  MultiLineToStringStyle();  static Map<Object, Object> getRegistry();  static boolean isRegistered(final Object value);  static void register(final Object value);  static void unregister(final Object value); public void appendSuper(final StringBuffer buffer, final String superToString); public void appendToString(final StringBuffer buffer, final String toString); public void appendStart(final StringBuffer buffer, final Object object); public void appendEnd(final StringBuffer buffer, final Object object); protected void removeLastFieldSeparator(final StringBuffer buffer); public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); public void append(final StringBuffer buffer, final String fieldName, final long value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); public void append(final StringBuffer buffer, final String fieldName, final int value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); public void append(final StringBuffer buffer, final String fieldName, final short value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); public void append(final StringBuffer buffer, final String fieldName, final byte value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); public void append(final StringBuffer buffer, final String fieldName, final char value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); public void append(final StringBuffer buffer, final String fieldName, final double value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); public void append(final StringBuffer buffer, final String fieldName, final float value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); public void append(final StringBuffer buffer, final String fieldName, final boolean value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendClassName(final StringBuffer buffer, final Object object); protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); protected void appendContentStart(final StringBuffer buffer); protected void appendContentEnd(final StringBuffer buffer); protected void appendNullText(final StringBuffer buffer, final String fieldName); protected void appendFieldSeparator(final StringBuffer buffer); protected void appendFieldStart(final StringBuffer buffer, final String fieldName); protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); protected boolean isFullDetail(final Boolean fullDetailRequest); protected String getShortClassName(final Class<?> cls); protected boolean isUseClassName(); protected void setUseClassName(final boolean useClassName); protected boolean isUseShortClassName(); protected void setUseShortClassName(final boolean useShortClassName); protected boolean isUseIdentityHashCode(); protected void setUseIdentityHashCode(final boolean useIdentityHashCode); protected boolean isUseFieldNames(); protected void setUseFieldNames(final boolean useFieldNames); protected boolean isDefaultFullDetail(); protected void setDefaultFullDetail(final boolean defaultFullDetail); protected boolean isArrayContentDetail(); protected void setArrayContentDetail(final boolean arrayContentDetail); protected String getArrayStart(); protected void setArrayStart(String arrayStart); protected String getArrayEnd(); protected void setArrayEnd(String arrayEnd); protected String getArraySeparator(); protected void setArraySeparator(String arraySeparator); protected String getContentStart(); protected void setContentStart(String contentStart); protected String getContentEnd(); protected void setContentEnd(String contentEnd); protected String getFieldNameValueSeparator(); protected void setFieldNameValueSeparator(String fieldNameValueSeparator); protected String getFieldSeparator(); protected void setFieldSeparator(String fieldSeparator); protected boolean isFieldSeparatorAtStart(); protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); protected boolean isFieldSeparatorAtEnd(); protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); protected String getNullText(); protected void setNullText(String nullText); protected String getSizeStartText(); protected void setSizeStartText(String sizeStartText); protected String getSizeEndText(); protected void setSizeEndText(String sizeEndText); protected String getSummaryObjectStartText(); protected void setSummaryObjectStartText(String summaryObjectStartText); protected String getSummaryObjectEndText(); protected void setSummaryObjectEndText(String summaryObjectEndText); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); long serialVersionUID=Optional[-2587890625525655916L]; ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; boolean useFieldNames=Optional[true]; boolean useClassName=Optional[true]; boolean useShortClassName=Optional[false]; boolean useIdentityHashCode=Optional[true]; String contentStart=Optional["["]; String contentEnd=Optional["]"]; String fieldNameValueSeparator=Optional["="]; boolean fieldSeparatorAtStart=Optional[false]; boolean fieldSeparatorAtEnd=Optional[false]; String fieldSeparator=Optional[","]; String arrayStart=Optional["{"]; String arraySeparator=Optional[","]; boolean arrayContentDetail=Optional[true]; String arrayEnd=Optional["}
protected void setSummaryObjectEndText(String summaryObjectEndText) { [EOL]     if (summaryObjectEndText == null) { [EOL]         summaryObjectEndText = ""; [EOL]     } [EOL]     this.summaryObjectEndText = summaryObjectEndText; [EOL] } protected ToStringStyle();  DefaultToStringStyle();  NoFieldNameToStringStyle();  ShortPrefixToStringStyle();  SimpleToStringStyle();  MultiLineToStringStyle();  static Map<Object, Object> getRegistry();  static boolean isRegistered(final Object value);  static void register(final Object value);  static void unregister(final Object value); public void appendSuper(final StringBuffer buffer, final String superToString); public void appendToString(final StringBuffer buffer, final String toString); public void appendStart(final StringBuffer buffer, final Object object); public void appendEnd(final StringBuffer buffer, final Object object); protected void removeLastFieldSeparator(final StringBuffer buffer); public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); public void append(final StringBuffer buffer, final String fieldName, final long value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); public void append(final StringBuffer buffer, final String fieldName, final int value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); public void append(final StringBuffer buffer, final String fieldName, final short value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); public void append(final StringBuffer buffer, final String fieldName, final byte value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); public void append(final StringBuffer buffer, final String fieldName, final char value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); public void append(final StringBuffer buffer, final String fieldName, final double value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); public void append(final StringBuffer buffer, final String fieldName, final float value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); public void append(final StringBuffer buffer, final String fieldName, final boolean value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendClassName(final StringBuffer buffer, final Object object); protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); protected void appendContentStart(final StringBuffer buffer); protected void appendContentEnd(final StringBuffer buffer); protected void appendNullText(final StringBuffer buffer, final String fieldName); protected void appendFieldSeparator(final StringBuffer buffer); protected void appendFieldStart(final StringBuffer buffer, final String fieldName); protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); protected boolean isFullDetail(final Boolean fullDetailRequest); protected String getShortClassName(final Class<?> cls); protected boolean isUseClassName(); protected void setUseClassName(final boolean useClassName); protected boolean isUseShortClassName(); protected void setUseShortClassName(final boolean useShortClassName); protected boolean isUseIdentityHashCode(); protected void setUseIdentityHashCode(final boolean useIdentityHashCode); protected boolean isUseFieldNames(); protected void setUseFieldNames(final boolean useFieldNames); protected boolean isDefaultFullDetail(); protected void setDefaultFullDetail(final boolean defaultFullDetail); protected boolean isArrayContentDetail(); protected void setArrayContentDetail(final boolean arrayContentDetail); protected String getArrayStart(); protected void setArrayStart(String arrayStart); protected String getArrayEnd(); protected void setArrayEnd(String arrayEnd); protected String getArraySeparator(); protected void setArraySeparator(String arraySeparator); protected String getContentStart(); protected void setContentStart(String contentStart); protected String getContentEnd(); protected void setContentEnd(String contentEnd); protected String getFieldNameValueSeparator(); protected void setFieldNameValueSeparator(String fieldNameValueSeparator); protected String getFieldSeparator(); protected void setFieldSeparator(String fieldSeparator); protected boolean isFieldSeparatorAtStart(); protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); protected boolean isFieldSeparatorAtEnd(); protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); protected String getNullText(); protected void setNullText(String nullText); protected String getSizeStartText(); protected void setSizeStartText(String sizeStartText); protected String getSizeEndText(); protected void setSizeEndText(String sizeEndText); protected String getSummaryObjectStartText(); protected void setSummaryObjectStartText(String summaryObjectStartText); protected String getSummaryObjectEndText(); protected void setSummaryObjectEndText(String summaryObjectEndText); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); long serialVersionUID=Optional[-2587890625525655916L]; ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; boolean useFieldNames=Optional[true]; boolean useClassName=Optional[true]; boolean useShortClassName=Optional[false]; boolean useIdentityHashCode=Optional[true]; String contentStart=Optional["["]; String contentEnd=Optional["]"]; String fieldNameValueSeparator=Optional["="]; boolean fieldSeparatorAtStart=Optional[false]; boolean fieldSeparatorAtEnd=Optional[false]; String fieldSeparator=Optional[","]; String arrayStart=Optional["{"]; String arraySeparator=Optional[","]; boolean arrayContentDetail=Optional[true]; String arrayEnd=Optional["}
@Override [EOL] public T get() throws ConcurrentException { [EOL]     T result = reference.get(); [EOL]     if (result == null) { [EOL]         result = initialize(); [EOL]         if (!reference.compareAndSet(null, result)) { [EOL]             result = reference.get(); [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
@Override [EOL] public T get() throws ConcurrentException { [EOL]     T result = reference.get(); [EOL]     if (result == null) { [EOL]         result = initialize(); [EOL]         if (!reference.compareAndSet(null, result)) { [EOL]             result = reference.get(); [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
@Override [EOL] public T get() throws ConcurrentException { [EOL]     T result = reference.get(); [EOL]     if (result == null) { [EOL]         result = initialize(); [EOL]         if (!reference.compareAndSet(null, result)) { [EOL]             result = reference.get(); [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
public static int hexDigitMsb0ToInt(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return 0x0; [EOL]         case '1': [EOL]             return 0x8; [EOL]         case '2': [EOL]             return 0x4; [EOL]         case '3': [EOL]             return 0xC; [EOL]         case '4': [EOL]             return 0x2; [EOL]         case '5': [EOL]             return 0xA; [EOL]         case '6': [EOL]             return 0x6; [EOL]         case '7': [EOL]             return 0xE; [EOL]         case '8': [EOL]             return 0x1; [EOL]         case '9': [EOL]             return 0x9; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return 0x5; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return 0xD; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return 0x3; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return 0xB; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return 0x7; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return 0xF; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] }
public static int hexDigitMsb0ToInt(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return 0x0; [EOL]         case '1': [EOL]             return 0x8; [EOL]         case '2': [EOL]             return 0x4; [EOL]         case '3': [EOL]             return 0xC; [EOL]         case '4': [EOL]             return 0x2; [EOL]         case '5': [EOL]             return 0xA; [EOL]         case '6': [EOL]             return 0x6; [EOL]         case '7': [EOL]             return 0xE; [EOL]         case '8': [EOL]             return 0x1; [EOL]         case '9': [EOL]             return 0x9; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return 0x5; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return 0xD; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return 0x3; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return 0xB; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return 0x7; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return 0xF; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] }
public static int hexDigitMsb0ToInt(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return 0x0; [EOL]         case '1': [EOL]             return 0x8; [EOL]         case '2': [EOL]             return 0x4; [EOL]         case '3': [EOL]             return 0xC; [EOL]         case '4': [EOL]             return 0x2; [EOL]         case '5': [EOL]             return 0xA; [EOL]         case '6': [EOL]             return 0x6; [EOL]         case '7': [EOL]             return 0xE; [EOL]         case '8': [EOL]             return 0x1; [EOL]         case '9': [EOL]             return 0x9; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return 0x5; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return 0xD; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return 0x3; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return 0xB; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return 0x7; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return 0xF; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] }
public static int hexDigitMsb0ToInt(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return 0x0; [EOL]         case '1': [EOL]             return 0x8; [EOL]         case '2': [EOL]             return 0x4; [EOL]         case '3': [EOL]             return 0xC; [EOL]         case '4': [EOL]             return 0x2; [EOL]         case '5': [EOL]             return 0xA; [EOL]         case '6': [EOL]             return 0x6; [EOL]         case '7': [EOL]             return 0xE; [EOL]         case '8': [EOL]             return 0x1; [EOL]         case '9': [EOL]             return 0x9; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return 0x5; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return 0xD; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return 0x3; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return 0xB; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return 0x7; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return 0xF; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] }
public static int hexDigitMsb0ToInt(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return 0x0; [EOL]         case '1': [EOL]             return 0x8; [EOL]         case '2': [EOL]             return 0x4; [EOL]         case '3': [EOL]             return 0xC; [EOL]         case '4': [EOL]             return 0x2; [EOL]         case '5': [EOL]             return 0xA; [EOL]         case '6': [EOL]             return 0x6; [EOL]         case '7': [EOL]             return 0xE; [EOL]         case '8': [EOL]             return 0x1; [EOL]         case '9': [EOL]             return 0x9; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return 0x5; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return 0xD; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return 0x3; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return 0xB; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return 0x7; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return 0xF; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] }
public static int hexDigitMsb0ToInt(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return 0x0; [EOL]         case '1': [EOL]             return 0x8; [EOL]         case '2': [EOL]             return 0x4; [EOL]         case '3': [EOL]             return 0xC; [EOL]         case '4': [EOL]             return 0x2; [EOL]         case '5': [EOL]             return 0xA; [EOL]         case '6': [EOL]             return 0x6; [EOL]         case '7': [EOL]             return 0xE; [EOL]         case '8': [EOL]             return 0x1; [EOL]         case '9': [EOL]             return 0x9; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return 0x5; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return 0xD; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return 0x3; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return 0xB; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return 0x7; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return 0xF; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] }
public static int hexDigitMsb0ToInt(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return 0x0; [EOL]         case '1': [EOL]             return 0x8; [EOL]         case '2': [EOL]             return 0x4; [EOL]         case '3': [EOL]             return 0xC; [EOL]         case '4': [EOL]             return 0x2; [EOL]         case '5': [EOL]             return 0xA; [EOL]         case '6': [EOL]             return 0x6; [EOL]         case '7': [EOL]             return 0xE; [EOL]         case '8': [EOL]             return 0x1; [EOL]         case '9': [EOL]             return 0x9; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return 0x5; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return 0xD; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return 0x3; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return 0xB; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return 0x7; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return 0xF; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] }
public static int hexDigitMsb0ToInt(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return 0x0; [EOL]         case '1': [EOL]             return 0x8; [EOL]         case '2': [EOL]             return 0x4; [EOL]         case '3': [EOL]             return 0xC; [EOL]         case '4': [EOL]             return 0x2; [EOL]         case '5': [EOL]             return 0xA; [EOL]         case '6': [EOL]             return 0x6; [EOL]         case '7': [EOL]             return 0xE; [EOL]         case '8': [EOL]             return 0x1; [EOL]         case '9': [EOL]             return 0x9; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return 0x5; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return 0xD; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return 0x3; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return 0xB; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return 0x7; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return 0xF; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] }
public static int hexDigitMsb0ToInt(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return 0x0; [EOL]         case '1': [EOL]             return 0x8; [EOL]         case '2': [EOL]             return 0x4; [EOL]         case '3': [EOL]             return 0xC; [EOL]         case '4': [EOL]             return 0x2; [EOL]         case '5': [EOL]             return 0xA; [EOL]         case '6': [EOL]             return 0x6; [EOL]         case '7': [EOL]             return 0xE; [EOL]         case '8': [EOL]             return 0x1; [EOL]         case '9': [EOL]             return 0x9; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return 0x5; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return 0xD; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return 0x3; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return 0xB; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return 0x7; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return 0xF; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] }
public static int hexDigitMsb0ToInt(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return 0x0; [EOL]         case '1': [EOL]             return 0x8; [EOL]         case '2': [EOL]             return 0x4; [EOL]         case '3': [EOL]             return 0xC; [EOL]         case '4': [EOL]             return 0x2; [EOL]         case '5': [EOL]             return 0xA; [EOL]         case '6': [EOL]             return 0x6; [EOL]         case '7': [EOL]             return 0xE; [EOL]         case '8': [EOL]             return 0x1; [EOL]         case '9': [EOL]             return 0x9; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return 0x5; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return 0xD; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return 0x3; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return 0xB; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return 0x7; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return 0xF; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] }
public static int hexDigitMsb0ToInt(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return 0x0; [EOL]         case '1': [EOL]             return 0x8; [EOL]         case '2': [EOL]             return 0x4; [EOL]         case '3': [EOL]             return 0xC; [EOL]         case '4': [EOL]             return 0x2; [EOL]         case '5': [EOL]             return 0xA; [EOL]         case '6': [EOL]             return 0x6; [EOL]         case '7': [EOL]             return 0xE; [EOL]         case '8': [EOL]             return 0x1; [EOL]         case '9': [EOL]             return 0x9; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return 0x5; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return 0xD; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return 0x3; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return 0xB; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return 0x7; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return 0xF; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] }
public static int hexDigitMsb0ToInt(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return 0x0; [EOL]         case '1': [EOL]             return 0x8; [EOL]         case '2': [EOL]             return 0x4; [EOL]         case '3': [EOL]             return 0xC; [EOL]         case '4': [EOL]             return 0x2; [EOL]         case '5': [EOL]             return 0xA; [EOL]         case '6': [EOL]             return 0x6; [EOL]         case '7': [EOL]             return 0xE; [EOL]         case '8': [EOL]             return 0x1; [EOL]         case '9': [EOL]             return 0x9; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return 0x5; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return 0xD; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return 0x3; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return 0xB; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return 0x7; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return 0xF; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] }
public static int hexDigitMsb0ToInt(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return 0x0; [EOL]         case '1': [EOL]             return 0x8; [EOL]         case '2': [EOL]             return 0x4; [EOL]         case '3': [EOL]             return 0xC; [EOL]         case '4': [EOL]             return 0x2; [EOL]         case '5': [EOL]             return 0xA; [EOL]         case '6': [EOL]             return 0x6; [EOL]         case '7': [EOL]             return 0xE; [EOL]         case '8': [EOL]             return 0x1; [EOL]         case '9': [EOL]             return 0x9; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return 0x5; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return 0xD; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return 0x3; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return 0xB; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return 0x7; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return 0xF; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] }
public static int hexDigitMsb0ToInt(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return 0x0; [EOL]         case '1': [EOL]             return 0x8; [EOL]         case '2': [EOL]             return 0x4; [EOL]         case '3': [EOL]             return 0xC; [EOL]         case '4': [EOL]             return 0x2; [EOL]         case '5': [EOL]             return 0xA; [EOL]         case '6': [EOL]             return 0x6; [EOL]         case '7': [EOL]             return 0xE; [EOL]         case '8': [EOL]             return 0x1; [EOL]         case '9': [EOL]             return 0x9; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return 0x5; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return 0xD; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return 0x3; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return 0xB; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return 0x7; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return 0xF; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] }
public static int hexDigitMsb0ToInt(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return 0x0; [EOL]         case '1': [EOL]             return 0x8; [EOL]         case '2': [EOL]             return 0x4; [EOL]         case '3': [EOL]             return 0xC; [EOL]         case '4': [EOL]             return 0x2; [EOL]         case '5': [EOL]             return 0xA; [EOL]         case '6': [EOL]             return 0x6; [EOL]         case '7': [EOL]             return 0xE; [EOL]         case '8': [EOL]             return 0x1; [EOL]         case '9': [EOL]             return 0x9; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return 0x5; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return 0xD; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return 0x3; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return 0xB; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return 0x7; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return 0xF; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] }
public static int hexDigitMsb0ToInt(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return 0x0; [EOL]         case '1': [EOL]             return 0x8; [EOL]         case '2': [EOL]             return 0x4; [EOL]         case '3': [EOL]             return 0xC; [EOL]         case '4': [EOL]             return 0x2; [EOL]         case '5': [EOL]             return 0xA; [EOL]         case '6': [EOL]             return 0x6; [EOL]         case '7': [EOL]             return 0xE; [EOL]         case '8': [EOL]             return 0x1; [EOL]         case '9': [EOL]             return 0x9; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return 0x5; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return 0xD; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return 0x3; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return 0xB; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return 0x7; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return 0xF; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] }
public static int hexDigitMsb0ToInt(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return 0x0; [EOL]         case '1': [EOL]             return 0x8; [EOL]         case '2': [EOL]             return 0x4; [EOL]         case '3': [EOL]             return 0xC; [EOL]         case '4': [EOL]             return 0x2; [EOL]         case '5': [EOL]             return 0xA; [EOL]         case '6': [EOL]             return 0x6; [EOL]         case '7': [EOL]             return 0xE; [EOL]         case '8': [EOL]             return 0x1; [EOL]         case '9': [EOL]             return 0x9; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return 0x5; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return 0xD; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return 0x3; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return 0xB; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return 0x7; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return 0xF; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] }
public static int hexDigitMsb0ToInt(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return 0x0; [EOL]         case '1': [EOL]             return 0x8; [EOL]         case '2': [EOL]             return 0x4; [EOL]         case '3': [EOL]             return 0xC; [EOL]         case '4': [EOL]             return 0x2; [EOL]         case '5': [EOL]             return 0xA; [EOL]         case '6': [EOL]             return 0x6; [EOL]         case '7': [EOL]             return 0xE; [EOL]         case '8': [EOL]             return 0x1; [EOL]         case '9': [EOL]             return 0x9; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return 0x5; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return 0xD; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return 0x3; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return 0xB; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return 0x7; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return 0xF; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] }
public static int hexDigitMsb0ToInt(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return 0x0; [EOL]         case '1': [EOL]             return 0x8; [EOL]         case '2': [EOL]             return 0x4; [EOL]         case '3': [EOL]             return 0xC; [EOL]         case '4': [EOL]             return 0x2; [EOL]         case '5': [EOL]             return 0xA; [EOL]         case '6': [EOL]             return 0x6; [EOL]         case '7': [EOL]             return 0xE; [EOL]         case '8': [EOL]             return 0x1; [EOL]         case '9': [EOL]             return 0x9; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return 0x5; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return 0xD; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return 0x3; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return 0xB; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return 0x7; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return 0xF; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] }
public static int hexDigitMsb0ToInt(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return 0x0; [EOL]         case '1': [EOL]             return 0x8; [EOL]         case '2': [EOL]             return 0x4; [EOL]         case '3': [EOL]             return 0xC; [EOL]         case '4': [EOL]             return 0x2; [EOL]         case '5': [EOL]             return 0xA; [EOL]         case '6': [EOL]             return 0x6; [EOL]         case '7': [EOL]             return 0xE; [EOL]         case '8': [EOL]             return 0x1; [EOL]         case '9': [EOL]             return 0x9; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return 0x5; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return 0xD; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return 0x3; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return 0xB; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return 0x7; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return 0xF; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] }
public static int hexDigitMsb0ToInt(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return 0x0; [EOL]         case '1': [EOL]             return 0x8; [EOL]         case '2': [EOL]             return 0x4; [EOL]         case '3': [EOL]             return 0xC; [EOL]         case '4': [EOL]             return 0x2; [EOL]         case '5': [EOL]             return 0xA; [EOL]         case '6': [EOL]             return 0x6; [EOL]         case '7': [EOL]             return 0xE; [EOL]         case '8': [EOL]             return 0x1; [EOL]         case '9': [EOL]             return 0x9; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return 0x5; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return 0xD; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return 0x3; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return 0xB; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return 0x7; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return 0xF; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] }
public static int hexDigitMsb0ToInt(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return 0x0; [EOL]         case '1': [EOL]             return 0x8; [EOL]         case '2': [EOL]             return 0x4; [EOL]         case '3': [EOL]             return 0xC; [EOL]         case '4': [EOL]             return 0x2; [EOL]         case '5': [EOL]             return 0xA; [EOL]         case '6': [EOL]             return 0x6; [EOL]         case '7': [EOL]             return 0xE; [EOL]         case '8': [EOL]             return 0x1; [EOL]         case '9': [EOL]             return 0x9; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return 0x5; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return 0xD; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return 0x3; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return 0xB; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return 0x7; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return 0xF; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] }
public static int hexDigitMsb0ToInt(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return 0x0; [EOL]         case '1': [EOL]             return 0x8; [EOL]         case '2': [EOL]             return 0x4; [EOL]         case '3': [EOL]             return 0xC; [EOL]         case '4': [EOL]             return 0x2; [EOL]         case '5': [EOL]             return 0xA; [EOL]         case '6': [EOL]             return 0x6; [EOL]         case '7': [EOL]             return 0xE; [EOL]         case '8': [EOL]             return 0x1; [EOL]         case '9': [EOL]             return 0x9; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return 0x5; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return 0xD; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return 0x3; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return 0xB; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return 0x7; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return 0xF; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] }
public static boolean[] hexDigitToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '2': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '3': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case '4': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '5': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case '8': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] }
public static boolean[] hexDigitToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '2': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '3': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case '4': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '5': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case '8': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] }
public static boolean[] hexDigitToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '2': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '3': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case '4': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '5': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case '8': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] }
public static boolean[] hexDigitToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '2': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '3': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case '4': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '5': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case '8': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] }
public static boolean[] hexDigitToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '2': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '3': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case '4': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '5': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case '8': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] }
public static boolean[] hexDigitToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '2': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '3': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case '4': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '5': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case '8': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] }
public static boolean[] hexDigitToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '2': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '3': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case '4': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '5': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case '8': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] }
public static boolean[] hexDigitToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '2': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '3': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case '4': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '5': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case '8': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] }
public static boolean[] hexDigitToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '2': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '3': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case '4': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '5': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case '8': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] }
public static boolean[] hexDigitToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '2': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '3': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case '4': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '5': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case '8': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] }
public static boolean[] hexDigitToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '2': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '3': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case '4': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '5': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case '8': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] }
public static boolean[] hexDigitToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '2': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '3': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case '4': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '5': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case '8': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] }
public static boolean[] hexDigitToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '2': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '3': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case '4': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '5': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case '8': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] }
public static boolean[] hexDigitToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '2': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '3': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case '4': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '5': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case '8': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] }
public static boolean[] hexDigitToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '2': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '3': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case '4': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '5': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case '8': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] }
public static boolean[] hexDigitToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '2': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '3': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case '4': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '5': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case '8': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] }
public static boolean[] hexDigitToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '2': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '3': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case '4': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '5': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case '8': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] }
public static char binaryToHexDigitMsb0_4bits(final boolean[] src) { [EOL]     return binaryToHexDigitMsb0_4bits(src, 0); [EOL] }
public static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos) { [EOL]     if (src.length > 8) { [EOL]         throw new IllegalArgumentException("src.length>8: src.length=" + src.length); [EOL]     } [EOL]     if (src.length - srcPos < 4) { [EOL]         throw new IllegalArgumentException("src.length-srcPos<4: src.length=" + src.length + ", srcPos=" + srcPos); [EOL]     } [EOL]     if (src[srcPos + 3]) { [EOL]         if (src[srcPos + 2]) { [EOL]             if (src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'f'; [EOL]                 } else { [EOL]                     return '7'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return 'b'; [EOL]                 } else { [EOL]                     return '3'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'd'; [EOL]                 } else { [EOL]                     return '5'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '9'; [EOL]                 } else { [EOL]                     return '1'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (src[srcPos + 2]) { [EOL]             if (src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'e'; [EOL]                 } else { [EOL]                     return '6'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return 'a'; [EOL]                 } else { [EOL]                     return '2'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'c'; [EOL]                 } else { [EOL]                     return '4'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '8'; [EOL]                 } else { [EOL]                     return '0'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
public static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos) { [EOL]     if (src.length > 8) { [EOL]         throw new IllegalArgumentException("src.length>8: src.length=" + src.length); [EOL]     } [EOL]     if (src.length - srcPos < 4) { [EOL]         throw new IllegalArgumentException("src.length-srcPos<4: src.length=" + src.length + ", srcPos=" + srcPos); [EOL]     } [EOL]     if (src[srcPos + 3]) { [EOL]         if (src[srcPos + 2]) { [EOL]             if (src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'f'; [EOL]                 } else { [EOL]                     return '7'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return 'b'; [EOL]                 } else { [EOL]                     return '3'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'd'; [EOL]                 } else { [EOL]                     return '5'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '9'; [EOL]                 } else { [EOL]                     return '1'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (src[srcPos + 2]) { [EOL]             if (src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'e'; [EOL]                 } else { [EOL]                     return '6'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return 'a'; [EOL]                 } else { [EOL]                     return '2'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'c'; [EOL]                 } else { [EOL]                     return '4'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '8'; [EOL]                 } else { [EOL]                     return '0'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
public static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos) { [EOL]     if (src.length > 8) { [EOL]         throw new IllegalArgumentException("src.length>8: src.length=" + src.length); [EOL]     } [EOL]     if (src.length - srcPos < 4) { [EOL]         throw new IllegalArgumentException("src.length-srcPos<4: src.length=" + src.length + ", srcPos=" + srcPos); [EOL]     } [EOL]     if (src[srcPos + 3]) { [EOL]         if (src[srcPos + 2]) { [EOL]             if (src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'f'; [EOL]                 } else { [EOL]                     return '7'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return 'b'; [EOL]                 } else { [EOL]                     return '3'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'd'; [EOL]                 } else { [EOL]                     return '5'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '9'; [EOL]                 } else { [EOL]                     return '1'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (src[srcPos + 2]) { [EOL]             if (src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'e'; [EOL]                 } else { [EOL]                     return '6'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return 'a'; [EOL]                 } else { [EOL]                     return '2'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'c'; [EOL]                 } else { [EOL]                     return '4'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '8'; [EOL]                 } else { [EOL]                     return '0'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
public static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos) { [EOL]     if (src.length > 8) { [EOL]         throw new IllegalArgumentException("src.length>8: src.length=" + src.length); [EOL]     } [EOL]     if (src.length - srcPos < 4) { [EOL]         throw new IllegalArgumentException("src.length-srcPos<4: src.length=" + src.length + ", srcPos=" + srcPos); [EOL]     } [EOL]     if (src[srcPos + 3]) { [EOL]         if (src[srcPos + 2]) { [EOL]             if (src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'f'; [EOL]                 } else { [EOL]                     return '7'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return 'b'; [EOL]                 } else { [EOL]                     return '3'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'd'; [EOL]                 } else { [EOL]                     return '5'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '9'; [EOL]                 } else { [EOL]                     return '1'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (src[srcPos + 2]) { [EOL]             if (src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'e'; [EOL]                 } else { [EOL]                     return '6'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return 'a'; [EOL]                 } else { [EOL]                     return '2'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'c'; [EOL]                 } else { [EOL]                     return '4'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '8'; [EOL]                 } else { [EOL]                     return '0'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
public static String longToHex(final long src, final int srcPos, final String dstInit, final int dstPos, final int nHexs) { [EOL]     if (0 == nHexs) { [EOL]         return dstInit; [EOL]     } [EOL]     if ((nHexs - 1) * 4 + srcPos >= 64) { [EOL]         throw new IllegalArgumentException("(nHexs-1)*4+srcPos is greather or equal to than 64"); [EOL]     } [EOL]     final StringBuilder sb = new StringBuilder(dstInit); [EOL]     int shift = 0; [EOL]     int append = sb.length(); [EOL]     for (int i = 0; i < nHexs; i++) { [EOL]         shift = i * 4 + srcPos; [EOL]         final int bits = (int) (0xF & (src >> shift)); [EOL]         if (dstPos + i == append) { [EOL]             ++append; [EOL]             sb.append(intToHexDigit(bits)); [EOL]         } else { [EOL]             sb.setCharAt(dstPos + i, intToHexDigit(bits)); [EOL]         } [EOL]     } [EOL]     return sb.toString(); [EOL] }
public static String longToHex(final long src, final int srcPos, final String dstInit, final int dstPos, final int nHexs) { [EOL]     if (0 == nHexs) { [EOL]         return dstInit; [EOL]     } [EOL]     if ((nHexs - 1) * 4 + srcPos >= 64) { [EOL]         throw new IllegalArgumentException("(nHexs-1)*4+srcPos is greather or equal to than 64"); [EOL]     } [EOL]     final StringBuilder sb = new StringBuilder(dstInit); [EOL]     int shift = 0; [EOL]     int append = sb.length(); [EOL]     for (int i = 0; i < nHexs; i++) { [EOL]         shift = i * 4 + srcPos; [EOL]         final int bits = (int) (0xF & (src >> shift)); [EOL]         if (dstPos + i == append) { [EOL]             ++append; [EOL]             sb.append(intToHexDigit(bits)); [EOL]         } else { [EOL]             sb.setCharAt(dstPos + i, intToHexDigit(bits)); [EOL]         } [EOL]     } [EOL]     return sb.toString(); [EOL] }
public static String shortToHex(final short src, final int srcPos, final String dstInit, final int dstPos, final int nHexs) { [EOL]     if (0 == nHexs) { [EOL]         return dstInit; [EOL]     } [EOL]     if ((nHexs - 1) * 4 + srcPos >= 16) { [EOL]         throw new IllegalArgumentException("(nHexs-1)*4+srcPos is greather or equal to than 16"); [EOL]     } [EOL]     final StringBuilder sb = new StringBuilder(dstInit); [EOL]     int shift = 0; [EOL]     int append = sb.length(); [EOL]     for (int i = 0; i < nHexs; i++) { [EOL]         shift = i * 4 + srcPos; [EOL]         final int bits = 0xF & (src >> shift); [EOL]         if (dstPos + i == append) { [EOL]             ++append; [EOL]             sb.append(intToHexDigit(bits)); [EOL]         } else { [EOL]             sb.setCharAt(dstPos + i, intToHexDigit(bits)); [EOL]         } [EOL]     } [EOL]     return sb.toString(); [EOL] }
public static final String escapeJava(final String input) { [EOL]     return ESCAPE_JAVA.translate(input); [EOL] } public StringEscapeUtils(); public int translate(final CharSequence input, final int index, final Writer out) throws IOException; public int translate(final CharSequence input, final int index, final Writer out) throws IOException; public static final String escapeJava(final String input); public static final String escapeEcmaScript(final String input); public static final String escapeJson(final String input); public static final String unescapeJava(final String input); public static final String unescapeEcmaScript(final String input); public static final String unescapeJson(final String input); public static final String escapeHtml4(final String input); public static final String escapeHtml3(final String input); public static final String unescapeHtml4(final String input); public static final String unescapeHtml3(final String input); public static final String escapeXml(final String input); public static final String unescapeXml(final String input); public static final String escapeCsv(final String input); public static final String unescapeCsv(final String input); CharSequenceTranslator ESCAPE_JAVA=Optional[new LookupTranslator(new String[][] { { "\"", "\\\"" }, { "\\", "\\\\" } }).with(new LookupTranslator(EntityArrays.JAVA_CTRL_CHARS_ESCAPE())).with(JavaUnicodeEscaper.outsideOf(32, 0x7f))]; CharSequenceTranslator ESCAPE_ECMASCRIPT=Optional[new AggregateTranslator(new LookupTranslator(new String[][] { { "'", "\\'" }, { "\"", "\\\"" }, { "\\", "\\\\" }, { "/", "\\/" } }), new LookupTranslator(EntityArrays.JAVA_CTRL_CHARS_ESCAPE()), JavaUnicodeEscaper.outsideOf(32, 0x7f))]; CharSequenceTranslator ESCAPE_JSON=Optional[new AggregateTranslator(new LookupTranslator(new String[][] { { "\"", "\\\"" }, { "\\", "\\\\" }, { "/", "\\/" } }), new LookupTranslator(EntityArrays.JAVA_CTRL_CHARS_ESCAPE()), JavaUnicodeEscaper.outsideOf(32, 0x7f))]; CharSequenceTranslator ESCAPE_XML=Optional[new AggregateTranslator(new LookupTranslator(EntityArrays.BASIC_ESCAPE()), new LookupTranslator(EntityArrays.APOS_ESCAPE()))]; CharSequenceTranslator ESCAPE_HTML3=Optional[new AggregateTranslator(new LookupTranslator(EntityArrays.BASIC_ESCAPE()), new LookupTranslator(EntityArrays.ISO8859_1_ESCAPE()))]; CharSequenceTranslator ESCAPE_HTML4=Optional[new AggregateTranslator(new LookupTranslator(EntityArrays.BASIC_ESCAPE()), new LookupTranslator(EntityArrays.ISO8859_1_ESCAPE()), new LookupTranslator(EntityArrays.HTML40_EXTENDED_ESCAPE()))]; CharSequenceTranslator ESCAPE_CSV=Optional[new CsvEscaper()]; CharSequenceTranslator UNESCAPE_JAVA=Optional[new AggregateTranslator(// .between('\1', '\377'),; new OctalUnescaper(), new UnicodeUnescaper(), new LookupTranslator(EntityArrays.JAVA_CTRL_CHARS_UNESCAPE()), new LookupTranslator(new String[][] { { "\\\\", "\\" }, { "\\\"", "\"" }, { "\\'", "'" }, { "\\", "" } }
public static final String escapeHtml4(final String input) { [EOL]     return ESCAPE_HTML4.translate(input); [EOL] } public StringEscapeUtils(); public int translate(final CharSequence input, final int index, final Writer out) throws IOException; public int translate(final CharSequence input, final int index, final Writer out) throws IOException; public static final String escapeJava(final String input); public static final String escapeEcmaScript(final String input); public static final String escapeJson(final String input); public static final String unescapeJava(final String input); public static final String unescapeEcmaScript(final String input); public static final String unescapeJson(final String input); public static final String escapeHtml4(final String input); public static final String escapeHtml3(final String input); public static final String unescapeHtml4(final String input); public static final String unescapeHtml3(final String input); public static final String escapeXml(final String input); public static final String unescapeXml(final String input); public static final String escapeCsv(final String input); public static final String unescapeCsv(final String input); CharSequenceTranslator ESCAPE_JAVA=Optional[new LookupTranslator(new String[][] { { "\"", "\\\"" }, { "\\", "\\\\" } }).with(new LookupTranslator(EntityArrays.JAVA_CTRL_CHARS_ESCAPE())).with(JavaUnicodeEscaper.outsideOf(32, 0x7f))]; CharSequenceTranslator ESCAPE_ECMASCRIPT=Optional[new AggregateTranslator(new LookupTranslator(new String[][] { { "'", "\\'" }, { "\"", "\\\"" }, { "\\", "\\\\" }, { "/", "\\/" } }), new LookupTranslator(EntityArrays.JAVA_CTRL_CHARS_ESCAPE()), JavaUnicodeEscaper.outsideOf(32, 0x7f))]; CharSequenceTranslator ESCAPE_JSON=Optional[new AggregateTranslator(new LookupTranslator(new String[][] { { "\"", "\\\"" }, { "\\", "\\\\" }, { "/", "\\/" } }), new LookupTranslator(EntityArrays.JAVA_CTRL_CHARS_ESCAPE()), JavaUnicodeEscaper.outsideOf(32, 0x7f))]; CharSequenceTranslator ESCAPE_XML=Optional[new AggregateTranslator(new LookupTranslator(EntityArrays.BASIC_ESCAPE()), new LookupTranslator(EntityArrays.APOS_ESCAPE()))]; CharSequenceTranslator ESCAPE_HTML3=Optional[new AggregateTranslator(new LookupTranslator(EntityArrays.BASIC_ESCAPE()), new LookupTranslator(EntityArrays.ISO8859_1_ESCAPE()))]; CharSequenceTranslator ESCAPE_HTML4=Optional[new AggregateTranslator(new LookupTranslator(EntityArrays.BASIC_ESCAPE()), new LookupTranslator(EntityArrays.ISO8859_1_ESCAPE()), new LookupTranslator(EntityArrays.HTML40_EXTENDED_ESCAPE()))]; CharSequenceTranslator ESCAPE_CSV=Optional[new CsvEscaper()]; CharSequenceTranslator UNESCAPE_JAVA=Optional[new AggregateTranslator(// .between('\1', '\377'),; new OctalUnescaper(), new UnicodeUnescaper(), new LookupTranslator(EntityArrays.JAVA_CTRL_CHARS_UNESCAPE()), new LookupTranslator(new String[][] { { "\\\\", "\\" }, { "\\\"", "\"" }, { "\\'", "'" }, { "\\", "" } }
public static final String escapeHtml4(final String input) { [EOL]     return ESCAPE_HTML4.translate(input); [EOL] } public StringEscapeUtils(); public int translate(final CharSequence input, final int index, final Writer out) throws IOException; public int translate(final CharSequence input, final int index, final Writer out) throws IOException; public static final String escapeJava(final String input); public static final String escapeEcmaScript(final String input); public static final String escapeJson(final String input); public static final String unescapeJava(final String input); public static final String unescapeEcmaScript(final String input); public static final String unescapeJson(final String input); public static final String escapeHtml4(final String input); public static final String escapeHtml3(final String input); public static final String unescapeHtml4(final String input); public static final String unescapeHtml3(final String input); public static final String escapeXml(final String input); public static final String unescapeXml(final String input); public static final String escapeCsv(final String input); public static final String unescapeCsv(final String input); CharSequenceTranslator ESCAPE_JAVA=Optional[new LookupTranslator(new String[][] { { "\"", "\\\"" }, { "\\", "\\\\" } }).with(new LookupTranslator(EntityArrays.JAVA_CTRL_CHARS_ESCAPE())).with(JavaUnicodeEscaper.outsideOf(32, 0x7f))]; CharSequenceTranslator ESCAPE_ECMASCRIPT=Optional[new AggregateTranslator(new LookupTranslator(new String[][] { { "'", "\\'" }, { "\"", "\\\"" }, { "\\", "\\\\" }, { "/", "\\/" } }), new LookupTranslator(EntityArrays.JAVA_CTRL_CHARS_ESCAPE()), JavaUnicodeEscaper.outsideOf(32, 0x7f))]; CharSequenceTranslator ESCAPE_JSON=Optional[new AggregateTranslator(new LookupTranslator(new String[][] { { "\"", "\\\"" }, { "\\", "\\\\" }, { "/", "\\/" } }), new LookupTranslator(EntityArrays.JAVA_CTRL_CHARS_ESCAPE()), JavaUnicodeEscaper.outsideOf(32, 0x7f))]; CharSequenceTranslator ESCAPE_XML=Optional[new AggregateTranslator(new LookupTranslator(EntityArrays.BASIC_ESCAPE()), new LookupTranslator(EntityArrays.APOS_ESCAPE()))]; CharSequenceTranslator ESCAPE_HTML3=Optional[new AggregateTranslator(new LookupTranslator(EntityArrays.BASIC_ESCAPE()), new LookupTranslator(EntityArrays.ISO8859_1_ESCAPE()))]; CharSequenceTranslator ESCAPE_HTML4=Optional[new AggregateTranslator(new LookupTranslator(EntityArrays.BASIC_ESCAPE()), new LookupTranslator(EntityArrays.ISO8859_1_ESCAPE()), new LookupTranslator(EntityArrays.HTML40_EXTENDED_ESCAPE()))]; CharSequenceTranslator ESCAPE_CSV=Optional[new CsvEscaper()]; CharSequenceTranslator UNESCAPE_JAVA=Optional[new AggregateTranslator(// .between('\1', '\377'),; new OctalUnescaper(), new UnicodeUnescaper(), new LookupTranslator(EntityArrays.JAVA_CTRL_CHARS_UNESCAPE()), new LookupTranslator(new String[][] { { "\\\\", "\\" }, { "\\\"", "\"" }, { "\\'", "'" }, { "\\", "" } }
public static final String unescapeHtml4(final String input) { [EOL]     return UNESCAPE_HTML4.translate(input); [EOL] } public StringEscapeUtils(); public int translate(final CharSequence input, final int index, final Writer out) throws IOException; public int translate(final CharSequence input, final int index, final Writer out) throws IOException; public static final String escapeJava(final String input); public static final String escapeEcmaScript(final String input); public static final String escapeJson(final String input); public static final String unescapeJava(final String input); public static final String unescapeEcmaScript(final String input); public static final String unescapeJson(final String input); public static final String escapeHtml4(final String input); public static final String escapeHtml3(final String input); public static final String unescapeHtml4(final String input); public static final String unescapeHtml3(final String input); public static final String escapeXml(final String input); public static final String unescapeXml(final String input); public static final String escapeCsv(final String input); public static final String unescapeCsv(final String input); CharSequenceTranslator ESCAPE_JAVA=Optional[new LookupTranslator(new String[][] { { "\"", "\\\"" }, { "\\", "\\\\" } }).with(new LookupTranslator(EntityArrays.JAVA_CTRL_CHARS_ESCAPE())).with(JavaUnicodeEscaper.outsideOf(32, 0x7f))]; CharSequenceTranslator ESCAPE_ECMASCRIPT=Optional[new AggregateTranslator(new LookupTranslator(new String[][] { { "'", "\\'" }, { "\"", "\\\"" }, { "\\", "\\\\" }, { "/", "\\/" } }), new LookupTranslator(EntityArrays.JAVA_CTRL_CHARS_ESCAPE()), JavaUnicodeEscaper.outsideOf(32, 0x7f))]; CharSequenceTranslator ESCAPE_JSON=Optional[new AggregateTranslator(new LookupTranslator(new String[][] { { "\"", "\\\"" }, { "\\", "\\\\" }, { "/", "\\/" } }), new LookupTranslator(EntityArrays.JAVA_CTRL_CHARS_ESCAPE()), JavaUnicodeEscaper.outsideOf(32, 0x7f))]; CharSequenceTranslator ESCAPE_XML=Optional[new AggregateTranslator(new LookupTranslator(EntityArrays.BASIC_ESCAPE()), new LookupTranslator(EntityArrays.APOS_ESCAPE()))]; CharSequenceTranslator ESCAPE_HTML3=Optional[new AggregateTranslator(new LookupTranslator(EntityArrays.BASIC_ESCAPE()), new LookupTranslator(EntityArrays.ISO8859_1_ESCAPE()))]; CharSequenceTranslator ESCAPE_HTML4=Optional[new AggregateTranslator(new LookupTranslator(EntityArrays.BASIC_ESCAPE()), new LookupTranslator(EntityArrays.ISO8859_1_ESCAPE()), new LookupTranslator(EntityArrays.HTML40_EXTENDED_ESCAPE()))]; CharSequenceTranslator ESCAPE_CSV=Optional[new CsvEscaper()]; CharSequenceTranslator UNESCAPE_JAVA=Optional[new AggregateTranslator(// .between('\1', '\377'),; new OctalUnescaper(), new UnicodeUnescaper(), new LookupTranslator(EntityArrays.JAVA_CTRL_CHARS_UNESCAPE()), new LookupTranslator(new String[][] { { "\\\\", "\\" }, { "\\\"", "\"" }, { "\\'", "'" }, { "\\", "" } }
public Format getParser() { [EOL]     return this.parser; [EOL] }
public Format getFormatter() { [EOL]     return this.formatter; [EOL] }
