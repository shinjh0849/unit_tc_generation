protected AbstractPartial() { [EOL]     super(); [EOL] }
public DateTimeFieldType[] getFieldTypes() { [EOL]     DateTimeFieldType[] result = new DateTimeFieldType[size()]; [EOL]     for (int i = 0; i < result.length; i++) { [EOL]         result[i] = getFieldType(i); [EOL]     } [EOL]     return result; [EOL] }
public DateTimeFieldType[] getFieldTypes() { [EOL]     DateTimeFieldType[] result = new DateTimeFieldType[size()]; [EOL]     for (int i = 0; i < result.length; i++) { [EOL]         result[i] = getFieldType(i); [EOL]     } [EOL]     return result; [EOL] }
public DateTimeField getField(int index) { [EOL]     return getField(index, getChronology()); [EOL] }
public DateTimeField[] getFields() { [EOL]     DateTimeField[] result = new DateTimeField[size()]; [EOL]     for (int i = 0; i < result.length; i++) { [EOL]         result[i] = getField(i); [EOL]     } [EOL]     return result; [EOL] }
public int get(DateTimeFieldType type) { [EOL]     return getValue(indexOfSupported(type)); [EOL] }
public boolean isSupported(DateTimeFieldType type) { [EOL]     return (indexOf(type) != -1); [EOL] }
public boolean isSupported(DateTimeFieldType type) { [EOL]     return (indexOf(type) != -1); [EOL] }
public int indexOf(DateTimeFieldType type) { [EOL]     for (int i = 0, isize = size(); i < isize; i++) { [EOL]         if (getFieldType(i) == type) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return -1; [EOL] }
public int indexOf(DateTimeFieldType type) { [EOL]     for (int i = 0, isize = size(); i < isize; i++) { [EOL]         if (getFieldType(i) == type) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return -1; [EOL] }
protected int indexOfSupported(DateTimeFieldType type) { [EOL]     int index = indexOf(type); [EOL]     if (index == -1) { [EOL]         throw new IllegalArgumentException("Field '" + type + "' is not supported"); [EOL]     } [EOL]     return index; [EOL] }
protected int indexOfSupported(DateTimeFieldType type) { [EOL]     int index = indexOf(type); [EOL]     if (index == -1) { [EOL]         throw new IllegalArgumentException("Field '" + type + "' is not supported"); [EOL]     } [EOL]     return index; [EOL] }
public DateTime toDateTime(ReadableInstant baseInstant) { [EOL]     Chronology chrono = DateTimeUtils.getInstantChronology(baseInstant); [EOL]     long instantMillis = DateTimeUtils.getInstantMillis(baseInstant); [EOL]     long resolved = chrono.set(this, instantMillis); [EOL]     return new DateTime(resolved, chrono); [EOL] }
public DateTime toDateTime(ReadableInstant baseInstant) { [EOL]     Chronology chrono = DateTimeUtils.getInstantChronology(baseInstant); [EOL]     long instantMillis = DateTimeUtils.getInstantMillis(baseInstant); [EOL]     long resolved = chrono.set(this, instantMillis); [EOL]     return new DateTime(resolved, chrono); [EOL] }
public YearMonthDay() { [EOL]     super(); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay() { [EOL]     super(); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay() { [EOL]     super(); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay() { [EOL]     super(); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay() { [EOL]     super(); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay() { [EOL]     super(); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay() { [EOL]     super(); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay() { [EOL]     super(); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay(DateTimeZone zone) { [EOL]     super(ISOChronology.getInstance(zone)); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay(DateTimeZone zone) { [EOL]     super(ISOChronology.getInstance(zone)); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay(DateTimeZone zone) { [EOL]     super(ISOChronology.getInstance(zone)); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay(DateTimeZone zone) { [EOL]     super(ISOChronology.getInstance(zone)); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay(DateTimeZone zone) { [EOL]     super(ISOChronology.getInstance(zone)); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay(DateTimeZone zone) { [EOL]     super(ISOChronology.getInstance(zone)); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay(DateTimeZone zone) { [EOL]     super(ISOChronology.getInstance(zone)); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay(DateTimeZone zone) { [EOL]     super(ISOChronology.getInstance(zone)); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay(DateTimeZone zone) { [EOL]     super(ISOChronology.getInstance(zone)); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay(DateTimeZone zone) { [EOL]     super(ISOChronology.getInstance(zone)); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay(long instant) { [EOL]     super(instant); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay(long instant) { [EOL]     super(instant); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay(long instant) { [EOL]     super(instant); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay(long instant) { [EOL]     super(instant); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay(long instant) { [EOL]     super(instant); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay(long instant) { [EOL]     super(instant); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay(long instant) { [EOL]     super(instant); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay(long instant) { [EOL]     super(instant); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay(long instant) { [EOL]     super(instant); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
YearMonthDay(YearMonthDay partial, Chronology chrono) { [EOL]     super(partial, chrono); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
YearMonthDay(YearMonthDay partial, Chronology chrono) { [EOL]     super(partial, chrono); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
YearMonthDay(YearMonthDay partial, Chronology chrono) { [EOL]     super(partial, chrono); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
YearMonthDay(YearMonthDay partial, Chronology chrono) { [EOL]     super(partial, chrono); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
YearMonthDay(YearMonthDay partial, Chronology chrono) { [EOL]     super(partial, chrono); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
YearMonthDay(YearMonthDay partial, Chronology chrono) { [EOL]     super(partial, chrono); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
YearMonthDay(YearMonthDay partial, Chronology chrono) { [EOL]     super(partial, chrono); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
YearMonthDay(YearMonthDay partial, Chronology chrono) { [EOL]     super(partial, chrono); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
YearMonthDay(YearMonthDay partial, Chronology chrono) { [EOL]     super(partial, chrono); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
YearMonthDay(YearMonthDay partial, Chronology chrono) { [EOL]     super(partial, chrono); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public int size() { [EOL]     return 3; [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
protected DateTimeField getField(int index, Chronology chrono) { [EOL]     switch(index) { [EOL]         case YEAR: [EOL]             return chrono.year(); [EOL]         case MONTH_OF_YEAR: [EOL]             return chrono.monthOfYear(); [EOL]         case DAY_OF_MONTH: [EOL]             return chrono.dayOfMonth(); [EOL]         default: [EOL]             throw new IndexOutOfBoundsException("Invalid index: " + index); [EOL]     } [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public DateTimeFieldType getFieldType(int index) { [EOL]     return FIELD_TYPES[index]; [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay withChronologyRetainFields(Chronology newChronology) { [EOL]     newChronology = DateTimeUtils.getChronology(newChronology); [EOL]     newChronology = newChronology.withUTC(); [EOL]     if (newChronology == getChronology()) { [EOL]         return this; [EOL]     } else { [EOL]         YearMonthDay newYearMonthDay = new YearMonthDay(this, newChronology); [EOL]         newChronology.validate(newYearMonthDay, getValues()); [EOL]         return newYearMonthDay; [EOL]     } [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay withChronologyRetainFields(Chronology newChronology) { [EOL]     newChronology = DateTimeUtils.getChronology(newChronology); [EOL]     newChronology = newChronology.withUTC(); [EOL]     if (newChronology == getChronology()) { [EOL]         return this; [EOL]     } else { [EOL]         YearMonthDay newYearMonthDay = new YearMonthDay(this, newChronology); [EOL]         newChronology.validate(newYearMonthDay, getValues()); [EOL]         return newYearMonthDay; [EOL]     } [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay withChronologyRetainFields(Chronology newChronology) { [EOL]     newChronology = DateTimeUtils.getChronology(newChronology); [EOL]     newChronology = newChronology.withUTC(); [EOL]     if (newChronology == getChronology()) { [EOL]         return this; [EOL]     } else { [EOL]         YearMonthDay newYearMonthDay = new YearMonthDay(this, newChronology); [EOL]         newChronology.validate(newYearMonthDay, getValues()); [EOL]         return newYearMonthDay; [EOL]     } [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar) { [EOL]     if (period == null || scalar == 0) { [EOL]         return this; [EOL]     } [EOL]     int[] newValues = getValues(); [EOL]     for (int i = 0; i < period.size(); i++) { [EOL]         DurationFieldType fieldType = period.getFieldType(i); [EOL]         int index = indexOf(fieldType); [EOL]         if (index >= 0) { [EOL]             newValues = getField(index).add(this, index, newValues, FieldUtils.safeMultiply(period.getValue(i), scalar)); [EOL]         } [EOL]     } [EOL]     return new YearMonthDay(this, newValues); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar) { [EOL]     if (period == null || scalar == 0) { [EOL]         return this; [EOL]     } [EOL]     int[] newValues = getValues(); [EOL]     for (int i = 0; i < period.size(); i++) { [EOL]         DurationFieldType fieldType = period.getFieldType(i); [EOL]         int index = indexOf(fieldType); [EOL]         if (index >= 0) { [EOL]             newValues = getField(index).add(this, index, newValues, FieldUtils.safeMultiply(period.getValue(i), scalar)); [EOL]         } [EOL]     } [EOL]     return new YearMonthDay(this, newValues); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar) { [EOL]     if (period == null || scalar == 0) { [EOL]         return this; [EOL]     } [EOL]     int[] newValues = getValues(); [EOL]     for (int i = 0; i < period.size(); i++) { [EOL]         DurationFieldType fieldType = period.getFieldType(i); [EOL]         int index = indexOf(fieldType); [EOL]         if (index >= 0) { [EOL]             newValues = getField(index).add(this, index, newValues, FieldUtils.safeMultiply(period.getValue(i), scalar)); [EOL]         } [EOL]     } [EOL]     return new YearMonthDay(this, newValues); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar) { [EOL]     if (period == null || scalar == 0) { [EOL]         return this; [EOL]     } [EOL]     int[] newValues = getValues(); [EOL]     for (int i = 0; i < period.size(); i++) { [EOL]         DurationFieldType fieldType = period.getFieldType(i); [EOL]         int index = indexOf(fieldType); [EOL]         if (index >= 0) { [EOL]             newValues = getField(index).add(this, index, newValues, FieldUtils.safeMultiply(period.getValue(i), scalar)); [EOL]         } [EOL]     } [EOL]     return new YearMonthDay(this, newValues); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay plusYears(int years) { [EOL]     return withFieldAdded(DurationFieldType.years(), years); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay plusYears(int years) { [EOL]     return withFieldAdded(DurationFieldType.years(), years); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay plusYears(int years) { [EOL]     return withFieldAdded(DurationFieldType.years(), years); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay plusMonths(int months) { [EOL]     return withFieldAdded(DurationFieldType.months(), months); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay plusMonths(int months) { [EOL]     return withFieldAdded(DurationFieldType.months(), months); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay plusMonths(int months) { [EOL]     return withFieldAdded(DurationFieldType.months(), months); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay plusMonths(int months) { [EOL]     return withFieldAdded(DurationFieldType.months(), months); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay plusMonths(int months) { [EOL]     return withFieldAdded(DurationFieldType.months(), months); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay plusMonths(int months) { [EOL]     return withFieldAdded(DurationFieldType.months(), months); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay plusMonths(int months) { [EOL]     return withFieldAdded(DurationFieldType.months(), months); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay minus(ReadablePeriod period) { [EOL]     return withPeriodAdded(period, -1); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay minus(ReadablePeriod period) { [EOL]     return withPeriodAdded(period, -1); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay minusDays(int days) { [EOL]     return withFieldAdded(DurationFieldType.days(), FieldUtils.safeNegate(days)); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay minusDays(int days) { [EOL]     return withFieldAdded(DurationFieldType.days(), FieldUtils.safeNegate(days)); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public LocalDate toLocalDate() { [EOL]     return new LocalDate(getYear(), getMonthOfYear(), getDayOfMonth(), getChronology()); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public DateMidnight toDateMidnight(DateTimeZone zone) { [EOL]     Chronology chrono = getChronology().withZone(zone); [EOL]     return new DateMidnight(getYear(), getMonthOfYear(), getDayOfMonth(), chrono); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public DateTime toDateTime(TimeOfDay time) { [EOL]     return toDateTime(time, null); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public DateTime toDateTime(TimeOfDay time, DateTimeZone zone) { [EOL]     Chronology chrono = getChronology().withZone(zone); [EOL]     long instant = DateTimeUtils.currentTimeMillis(); [EOL]     instant = chrono.set(this, instant); [EOL]     if (time != null) { [EOL]         instant = chrono.set(time, instant); [EOL]     } [EOL]     return new DateTime(instant, chrono); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public Interval toInterval() { [EOL]     return toInterval(null); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public Interval toInterval(DateTimeZone zone) { [EOL]     zone = DateTimeUtils.getZone(zone); [EOL]     return toDateMidnight(zone).toInterval(); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public Property year() { [EOL]     return new Property(this, YEAR); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public String toString() { [EOL]     return ISODateTimeFormat.yearMonthDay().print(this); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
Property(YearMonthDay partial, int fieldIndex) { [EOL]     super(); [EOL]     iYearMonthDay = partial; [EOL]     iFieldIndex = fieldIndex; [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
Property(YearMonthDay partial, int fieldIndex) { [EOL]     super(); [EOL]     iYearMonthDay = partial; [EOL]     iFieldIndex = fieldIndex; [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
Property(YearMonthDay partial, int fieldIndex) { [EOL]     super(); [EOL]     iYearMonthDay = partial; [EOL]     iFieldIndex = fieldIndex; [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
Property(YearMonthDay partial, int fieldIndex) { [EOL]     super(); [EOL]     iYearMonthDay = partial; [EOL]     iFieldIndex = fieldIndex; [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
Property(YearMonthDay partial, int fieldIndex) { [EOL]     super(); [EOL]     iYearMonthDay = partial; [EOL]     iFieldIndex = fieldIndex; [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
Property(YearMonthDay partial, int fieldIndex) { [EOL]     super(); [EOL]     iYearMonthDay = partial; [EOL]     iFieldIndex = fieldIndex; [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
Property(YearMonthDay partial, int fieldIndex) { [EOL]     super(); [EOL]     iYearMonthDay = partial; [EOL]     iFieldIndex = fieldIndex; [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
Property(YearMonthDay partial, int fieldIndex) { [EOL]     super(); [EOL]     iYearMonthDay = partial; [EOL]     iFieldIndex = fieldIndex; [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public DateTimeField getField() { [EOL]     return iYearMonthDay.getField(iFieldIndex); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public DateTimeField getField() { [EOL]     return iYearMonthDay.getField(iFieldIndex); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public DateTimeField getField() { [EOL]     return iYearMonthDay.getField(iFieldIndex); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public DateTimeField getField() { [EOL]     return iYearMonthDay.getField(iFieldIndex); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public DateTimeField getField() { [EOL]     return iYearMonthDay.getField(iFieldIndex); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public DateTimeField getField() { [EOL]     return iYearMonthDay.getField(iFieldIndex); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public DateTimeField getField() { [EOL]     return iYearMonthDay.getField(iFieldIndex); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public DateTimeField getField() { [EOL]     return iYearMonthDay.getField(iFieldIndex); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public DateTimeField getField() { [EOL]     return iYearMonthDay.getField(iFieldIndex); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public DateTimeField getField() { [EOL]     return iYearMonthDay.getField(iFieldIndex); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public int get() { [EOL]     return iYearMonthDay.getValue(iFieldIndex); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public int get() { [EOL]     return iYearMonthDay.getValue(iFieldIndex); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public int get() { [EOL]     return iYearMonthDay.getValue(iFieldIndex); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public int get() { [EOL]     return iYearMonthDay.getValue(iFieldIndex); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public int get() { [EOL]     return iYearMonthDay.getValue(iFieldIndex); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public int get() { [EOL]     return iYearMonthDay.getValue(iFieldIndex); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public int get() { [EOL]     return iYearMonthDay.getValue(iFieldIndex); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public int get() { [EOL]     return iYearMonthDay.getValue(iFieldIndex); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public int get() { [EOL]     return iYearMonthDay.getValue(iFieldIndex); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public int get() { [EOL]     return iYearMonthDay.getValue(iFieldIndex); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public int get() { [EOL]     return iYearMonthDay.getValue(iFieldIndex); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay withMaximumValue() { [EOL]     return setCopy(getMaximumValue()); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public Class<?> getSupportedType() { [EOL]     return ReadablePartial.class; [EOL] }
public long getDurationMillis(Object object) { [EOL]     return ((Long) object).longValue(); [EOL] }
public long getDurationMillis(Object object) { [EOL]     return ((Long) object).longValue(); [EOL] }
public static Period fieldDifference(ReadablePartial start, ReadablePartial end) { [EOL]     if (start == null || end == null) { [EOL]         throw new IllegalArgumentException("ReadablePartial objects must not be null"); [EOL]     } [EOL]     if (start.size() != end.size()) { [EOL]         throw new IllegalArgumentException("ReadablePartial objects must have the same set of fields"); [EOL]     } [EOL]     DurationFieldType[] types = new DurationFieldType[start.size()]; [EOL]     int[] values = new int[start.size()]; [EOL]     for (int i = 0, isize = start.size(); i < isize; i++) { [EOL]         if (start.getFieldType(i) != end.getFieldType(i)) { [EOL]             throw new IllegalArgumentException("ReadablePartial objects must have the same set of fields"); [EOL]         } [EOL]         types[i] = start.getFieldType(i).getDurationType(); [EOL]         if (i > 0 && types[i - 1] == types[i]) { [EOL]             throw new IllegalArgumentException("ReadablePartial objects must not have overlapping fields"); [EOL]         } [EOL]         values[i] = end.getValue(i) - start.getValue(i); [EOL]     } [EOL]     return new Period(values, PeriodType.forFields(types)); [EOL] }
public static Period fieldDifference(ReadablePartial start, ReadablePartial end) { [EOL]     if (start == null || end == null) { [EOL]         throw new IllegalArgumentException("ReadablePartial objects must not be null"); [EOL]     } [EOL]     if (start.size() != end.size()) { [EOL]         throw new IllegalArgumentException("ReadablePartial objects must have the same set of fields"); [EOL]     } [EOL]     DurationFieldType[] types = new DurationFieldType[start.size()]; [EOL]     int[] values = new int[start.size()]; [EOL]     for (int i = 0, isize = start.size(); i < isize; i++) { [EOL]         if (start.getFieldType(i) != end.getFieldType(i)) { [EOL]             throw new IllegalArgumentException("ReadablePartial objects must have the same set of fields"); [EOL]         } [EOL]         types[i] = start.getFieldType(i).getDurationType(); [EOL]         if (i > 0 && types[i - 1] == types[i]) { [EOL]             throw new IllegalArgumentException("ReadablePartial objects must not have overlapping fields"); [EOL]         } [EOL]         values[i] = end.getValue(i) - start.getValue(i); [EOL]     } [EOL]     return new Period(values, PeriodType.forFields(types)); [EOL] }
public static Period fieldDifference(ReadablePartial start, ReadablePartial end) { [EOL]     if (start == null || end == null) { [EOL]         throw new IllegalArgumentException("ReadablePartial objects must not be null"); [EOL]     } [EOL]     if (start.size() != end.size()) { [EOL]         throw new IllegalArgumentException("ReadablePartial objects must have the same set of fields"); [EOL]     } [EOL]     DurationFieldType[] types = new DurationFieldType[start.size()]; [EOL]     int[] values = new int[start.size()]; [EOL]     for (int i = 0, isize = start.size(); i < isize; i++) { [EOL]         if (start.getFieldType(i) != end.getFieldType(i)) { [EOL]             throw new IllegalArgumentException("ReadablePartial objects must have the same set of fields"); [EOL]         } [EOL]         types[i] = start.getFieldType(i).getDurationType(); [EOL]         if (i > 0 && types[i - 1] == types[i]) { [EOL]             throw new IllegalArgumentException("ReadablePartial objects must not have overlapping fields"); [EOL]         } [EOL]         values[i] = end.getValue(i) - start.getValue(i); [EOL]     } [EOL]     return new Period(values, PeriodType.forFields(types)); [EOL] }
public static Period fieldDifference(ReadablePartial start, ReadablePartial end) { [EOL]     if (start == null || end == null) { [EOL]         throw new IllegalArgumentException("ReadablePartial objects must not be null"); [EOL]     } [EOL]     if (start.size() != end.size()) { [EOL]         throw new IllegalArgumentException("ReadablePartial objects must have the same set of fields"); [EOL]     } [EOL]     DurationFieldType[] types = new DurationFieldType[start.size()]; [EOL]     int[] values = new int[start.size()]; [EOL]     for (int i = 0, isize = start.size(); i < isize; i++) { [EOL]         if (start.getFieldType(i) != end.getFieldType(i)) { [EOL]             throw new IllegalArgumentException("ReadablePartial objects must have the same set of fields"); [EOL]         } [EOL]         types[i] = start.getFieldType(i).getDurationType(); [EOL]         if (i > 0 && types[i - 1] == types[i]) { [EOL]             throw new IllegalArgumentException("ReadablePartial objects must not have overlapping fields"); [EOL]         } [EOL]         values[i] = end.getValue(i) - start.getValue(i); [EOL]     } [EOL]     return new Period(values, PeriodType.forFields(types)); [EOL] }
public static Period fieldDifference(ReadablePartial start, ReadablePartial end) { [EOL]     if (start == null || end == null) { [EOL]         throw new IllegalArgumentException("ReadablePartial objects must not be null"); [EOL]     } [EOL]     if (start.size() != end.size()) { [EOL]         throw new IllegalArgumentException("ReadablePartial objects must have the same set of fields"); [EOL]     } [EOL]     DurationFieldType[] types = new DurationFieldType[start.size()]; [EOL]     int[] values = new int[start.size()]; [EOL]     for (int i = 0, isize = start.size(); i < isize; i++) { [EOL]         if (start.getFieldType(i) != end.getFieldType(i)) { [EOL]             throw new IllegalArgumentException("ReadablePartial objects must have the same set of fields"); [EOL]         } [EOL]         types[i] = start.getFieldType(i).getDurationType(); [EOL]         if (i > 0 && types[i - 1] == types[i]) { [EOL]             throw new IllegalArgumentException("ReadablePartial objects must not have overlapping fields"); [EOL]         } [EOL]         values[i] = end.getValue(i) - start.getValue(i); [EOL]     } [EOL]     return new Period(values, PeriodType.forFields(types)); [EOL] }
public static Period fieldDifference(ReadablePartial start, ReadablePartial end) { [EOL]     if (start == null || end == null) { [EOL]         throw new IllegalArgumentException("ReadablePartial objects must not be null"); [EOL]     } [EOL]     if (start.size() != end.size()) { [EOL]         throw new IllegalArgumentException("ReadablePartial objects must have the same set of fields"); [EOL]     } [EOL]     DurationFieldType[] types = new DurationFieldType[start.size()]; [EOL]     int[] values = new int[start.size()]; [EOL]     for (int i = 0, isize = start.size(); i < isize; i++) { [EOL]         if (start.getFieldType(i) != end.getFieldType(i)) { [EOL]             throw new IllegalArgumentException("ReadablePartial objects must have the same set of fields"); [EOL]         } [EOL]         types[i] = start.getFieldType(i).getDurationType(); [EOL]         if (i > 0 && types[i - 1] == types[i]) { [EOL]             throw new IllegalArgumentException("ReadablePartial objects must not have overlapping fields"); [EOL]         } [EOL]         values[i] = end.getValue(i) - start.getValue(i); [EOL]     } [EOL]     return new Period(values, PeriodType.forFields(types)); [EOL] }
public Period() { [EOL]     super(0L, null, null); [EOL] }
public Period(long duration) { [EOL]     super(duration); [EOL] }
public Period(long duration) { [EOL]     super(duration); [EOL] }
public Period(long duration) { [EOL]     super(duration); [EOL] }
public Period(long duration, PeriodType type, Chronology chronology) { [EOL]     super(duration, type, chronology); [EOL] }
public Period(long duration, PeriodType type, Chronology chronology) { [EOL]     super(duration, type, chronology); [EOL] }
public Period(long duration, PeriodType type, Chronology chronology) { [EOL]     super(duration, type, chronology); [EOL] }
public Period(long startInstant, long endInstant, Chronology chrono) { [EOL]     super(startInstant, endInstant, null, chrono); [EOL] }
public Period(long startInstant, long endInstant, Chronology chrono) { [EOL]     super(startInstant, endInstant, null, chrono); [EOL] }
public Period(ReadableInstant startInstant, ReadableInstant endInstant, PeriodType type) { [EOL]     super(startInstant, endInstant, type); [EOL] }
public Period(ReadableInstant startInstant, ReadableInstant endInstant, PeriodType type) { [EOL]     super(startInstant, endInstant, type); [EOL] }
public Period(ReadableInstant startInstant, ReadableInstant endInstant, PeriodType type) { [EOL]     super(startInstant, endInstant, type); [EOL] }
public Period(ReadableInstant startInstant, ReadableInstant endInstant, PeriodType type) { [EOL]     super(startInstant, endInstant, type); [EOL] }
public Period(ReadableInstant startInstant, ReadableDuration duration, PeriodType type) { [EOL]     super(startInstant, duration, type); [EOL] }
public Period(ReadableDuration duration, ReadableInstant endInstant, PeriodType type) { [EOL]     super(duration, endInstant, type); [EOL] }
public Period(Object period, Chronology chrono) { [EOL]     super(period, null, chrono); [EOL] }
public Period(Object period, Chronology chrono) { [EOL]     super(period, null, chrono); [EOL] }
public Period(Object period, PeriodType type, Chronology chrono) { [EOL]     super(period, type, chrono); [EOL] }
public int getYears() { [EOL]     return getPeriodType().getIndexedField(this, PeriodType.YEAR_INDEX); [EOL] }
public int getMonths() { [EOL]     return getPeriodType().getIndexedField(this, PeriodType.MONTH_INDEX); [EOL] }
public int getWeeks() { [EOL]     return getPeriodType().getIndexedField(this, PeriodType.WEEK_INDEX); [EOL] }
public int getDays() { [EOL]     return getPeriodType().getIndexedField(this, PeriodType.DAY_INDEX); [EOL] }
public int getHours() { [EOL]     return getPeriodType().getIndexedField(this, PeriodType.HOUR_INDEX); [EOL] }
public int getMinutes() { [EOL]     return getPeriodType().getIndexedField(this, PeriodType.MINUTE_INDEX); [EOL] }
public int getSeconds() { [EOL]     return getPeriodType().getIndexedField(this, PeriodType.SECOND_INDEX); [EOL] }
public int getMillis() { [EOL]     return getPeriodType().getIndexedField(this, PeriodType.MILLI_INDEX); [EOL] }
public Period withFields(ReadablePeriod period) { [EOL]     if (period == null) { [EOL]         return this; [EOL]     } [EOL]     int[] newValues = getValues(); [EOL]     newValues = super.mergePeriodInto(newValues, period); [EOL]     return new Period(newValues, getPeriodType()); [EOL] }
public Period withFields(ReadablePeriod period) { [EOL]     if (period == null) { [EOL]         return this; [EOL]     } [EOL]     int[] newValues = getValues(); [EOL]     newValues = super.mergePeriodInto(newValues, period); [EOL]     return new Period(newValues, getPeriodType()); [EOL] }
public Period withFieldAdded(DurationFieldType field, int value) { [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("Field must not be null"); [EOL]     } [EOL]     if (value == 0) { [EOL]         return this; [EOL]     } [EOL]     int[] newValues = getValues(); [EOL]     super.addFieldInto(newValues, field, value); [EOL]     return new Period(newValues, getPeriodType()); [EOL] }
public Period withFieldAdded(DurationFieldType field, int value) { [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("Field must not be null"); [EOL]     } [EOL]     if (value == 0) { [EOL]         return this; [EOL]     } [EOL]     int[] newValues = getValues(); [EOL]     super.addFieldInto(newValues, field, value); [EOL]     return new Period(newValues, getPeriodType()); [EOL] }
public Period withFieldAdded(DurationFieldType field, int value) { [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("Field must not be null"); [EOL]     } [EOL]     if (value == 0) { [EOL]         return this; [EOL]     } [EOL]     int[] newValues = getValues(); [EOL]     super.addFieldInto(newValues, field, value); [EOL]     return new Period(newValues, getPeriodType()); [EOL] }
public Period withWeeks(int weeks) { [EOL]     int[] values = getValues(); [EOL]     getPeriodType().setIndexedField(this, PeriodType.WEEK_INDEX, values, weeks); [EOL]     return new Period(values, getPeriodType()); [EOL] }
public Period withWeeks(int weeks) { [EOL]     int[] values = getValues(); [EOL]     getPeriodType().setIndexedField(this, PeriodType.WEEK_INDEX, values, weeks); [EOL]     return new Period(values, getPeriodType()); [EOL] }
public Period withDays(int days) { [EOL]     int[] values = getValues(); [EOL]     getPeriodType().setIndexedField(this, PeriodType.DAY_INDEX, values, days); [EOL]     return new Period(values, getPeriodType()); [EOL] }
public Period withMinutes(int minutes) { [EOL]     int[] values = getValues(); [EOL]     getPeriodType().setIndexedField(this, PeriodType.MINUTE_INDEX, values, minutes); [EOL]     return new Period(values, getPeriodType()); [EOL] }
public Period withMinutes(int minutes) { [EOL]     int[] values = getValues(); [EOL]     getPeriodType().setIndexedField(this, PeriodType.MINUTE_INDEX, values, minutes); [EOL]     return new Period(values, getPeriodType()); [EOL] }
public Period withSeconds(int seconds) { [EOL]     int[] values = getValues(); [EOL]     getPeriodType().setIndexedField(this, PeriodType.SECOND_INDEX, values, seconds); [EOL]     return new Period(values, getPeriodType()); [EOL] }
public Period withSeconds(int seconds) { [EOL]     int[] values = getValues(); [EOL]     getPeriodType().setIndexedField(this, PeriodType.SECOND_INDEX, values, seconds); [EOL]     return new Period(values, getPeriodType()); [EOL] }
public Period withMillis(int millis) { [EOL]     int[] values = getValues(); [EOL]     getPeriodType().setIndexedField(this, PeriodType.MILLI_INDEX, values, millis); [EOL]     return new Period(values, getPeriodType()); [EOL] }
public Period withMillis(int millis) { [EOL]     int[] values = getValues(); [EOL]     getPeriodType().setIndexedField(this, PeriodType.MILLI_INDEX, values, millis); [EOL]     return new Period(values, getPeriodType()); [EOL] }
public Weeks toStandardWeeks() { [EOL]     checkYearsAndMonths("Weeks"); [EOL]     long millis = getMillis(); [EOL]     millis += ((long) getSeconds()) * DateTimeConstants.MILLIS_PER_SECOND; [EOL]     millis += ((long) getMinutes()) * DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     millis += ((long) getHours()) * DateTimeConstants.MILLIS_PER_HOUR; [EOL]     millis += ((long) getDays()) * DateTimeConstants.MILLIS_PER_DAY; [EOL]     long weeks = ((long) getWeeks()) + millis / DateTimeConstants.MILLIS_PER_WEEK; [EOL]     return Weeks.weeks(FieldUtils.safeToInt(weeks)); [EOL] }
public Weeks toStandardWeeks() { [EOL]     checkYearsAndMonths("Weeks"); [EOL]     long millis = getMillis(); [EOL]     millis += ((long) getSeconds()) * DateTimeConstants.MILLIS_PER_SECOND; [EOL]     millis += ((long) getMinutes()) * DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     millis += ((long) getHours()) * DateTimeConstants.MILLIS_PER_HOUR; [EOL]     millis += ((long) getDays()) * DateTimeConstants.MILLIS_PER_DAY; [EOL]     long weeks = ((long) getWeeks()) + millis / DateTimeConstants.MILLIS_PER_WEEK; [EOL]     return Weeks.weeks(FieldUtils.safeToInt(weeks)); [EOL] }
public Weeks toStandardWeeks() { [EOL]     checkYearsAndMonths("Weeks"); [EOL]     long millis = getMillis(); [EOL]     millis += ((long) getSeconds()) * DateTimeConstants.MILLIS_PER_SECOND; [EOL]     millis += ((long) getMinutes()) * DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     millis += ((long) getHours()) * DateTimeConstants.MILLIS_PER_HOUR; [EOL]     millis += ((long) getDays()) * DateTimeConstants.MILLIS_PER_DAY; [EOL]     long weeks = ((long) getWeeks()) + millis / DateTimeConstants.MILLIS_PER_WEEK; [EOL]     return Weeks.weeks(FieldUtils.safeToInt(weeks)); [EOL] }
public Weeks toStandardWeeks() { [EOL]     checkYearsAndMonths("Weeks"); [EOL]     long millis = getMillis(); [EOL]     millis += ((long) getSeconds()) * DateTimeConstants.MILLIS_PER_SECOND; [EOL]     millis += ((long) getMinutes()) * DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     millis += ((long) getHours()) * DateTimeConstants.MILLIS_PER_HOUR; [EOL]     millis += ((long) getDays()) * DateTimeConstants.MILLIS_PER_DAY; [EOL]     long weeks = ((long) getWeeks()) + millis / DateTimeConstants.MILLIS_PER_WEEK; [EOL]     return Weeks.weeks(FieldUtils.safeToInt(weeks)); [EOL] }
public Weeks toStandardWeeks() { [EOL]     checkYearsAndMonths("Weeks"); [EOL]     long millis = getMillis(); [EOL]     millis += ((long) getSeconds()) * DateTimeConstants.MILLIS_PER_SECOND; [EOL]     millis += ((long) getMinutes()) * DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     millis += ((long) getHours()) * DateTimeConstants.MILLIS_PER_HOUR; [EOL]     millis += ((long) getDays()) * DateTimeConstants.MILLIS_PER_DAY; [EOL]     long weeks = ((long) getWeeks()) + millis / DateTimeConstants.MILLIS_PER_WEEK; [EOL]     return Weeks.weeks(FieldUtils.safeToInt(weeks)); [EOL] }
public Weeks toStandardWeeks() { [EOL]     checkYearsAndMonths("Weeks"); [EOL]     long millis = getMillis(); [EOL]     millis += ((long) getSeconds()) * DateTimeConstants.MILLIS_PER_SECOND; [EOL]     millis += ((long) getMinutes()) * DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     millis += ((long) getHours()) * DateTimeConstants.MILLIS_PER_HOUR; [EOL]     millis += ((long) getDays()) * DateTimeConstants.MILLIS_PER_DAY; [EOL]     long weeks = ((long) getWeeks()) + millis / DateTimeConstants.MILLIS_PER_WEEK; [EOL]     return Weeks.weeks(FieldUtils.safeToInt(weeks)); [EOL] }
public Weeks toStandardWeeks() { [EOL]     checkYearsAndMonths("Weeks"); [EOL]     long millis = getMillis(); [EOL]     millis += ((long) getSeconds()) * DateTimeConstants.MILLIS_PER_SECOND; [EOL]     millis += ((long) getMinutes()) * DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     millis += ((long) getHours()) * DateTimeConstants.MILLIS_PER_HOUR; [EOL]     millis += ((long) getDays()) * DateTimeConstants.MILLIS_PER_DAY; [EOL]     long weeks = ((long) getWeeks()) + millis / DateTimeConstants.MILLIS_PER_WEEK; [EOL]     return Weeks.weeks(FieldUtils.safeToInt(weeks)); [EOL] }
public Minutes toStandardMinutes() { [EOL]     checkYearsAndMonths("Minutes"); [EOL]     long millis = getMillis(); [EOL]     millis += ((long) getSeconds()) * DateTimeConstants.MILLIS_PER_SECOND; [EOL]     long minutes = millis / DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     minutes = FieldUtils.safeAdd(minutes, getMinutes()); [EOL]     minutes = FieldUtils.safeAdd(minutes, ((long) getHours()) * ((long) DateTimeConstants.MINUTES_PER_HOUR)); [EOL]     minutes = FieldUtils.safeAdd(minutes, ((long) getDays()) * ((long) DateTimeConstants.MINUTES_PER_DAY)); [EOL]     minutes = FieldUtils.safeAdd(minutes, ((long) getWeeks()) * ((long) DateTimeConstants.MINUTES_PER_WEEK)); [EOL]     return Minutes.minutes(FieldUtils.safeToInt(minutes)); [EOL] }
public Minutes toStandardMinutes() { [EOL]     checkYearsAndMonths("Minutes"); [EOL]     long millis = getMillis(); [EOL]     millis += ((long) getSeconds()) * DateTimeConstants.MILLIS_PER_SECOND; [EOL]     long minutes = millis / DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     minutes = FieldUtils.safeAdd(minutes, getMinutes()); [EOL]     minutes = FieldUtils.safeAdd(minutes, ((long) getHours()) * ((long) DateTimeConstants.MINUTES_PER_HOUR)); [EOL]     minutes = FieldUtils.safeAdd(minutes, ((long) getDays()) * ((long) DateTimeConstants.MINUTES_PER_DAY)); [EOL]     minutes = FieldUtils.safeAdd(minutes, ((long) getWeeks()) * ((long) DateTimeConstants.MINUTES_PER_WEEK)); [EOL]     return Minutes.minutes(FieldUtils.safeToInt(minutes)); [EOL] }
public Minutes toStandardMinutes() { [EOL]     checkYearsAndMonths("Minutes"); [EOL]     long millis = getMillis(); [EOL]     millis += ((long) getSeconds()) * DateTimeConstants.MILLIS_PER_SECOND; [EOL]     long minutes = millis / DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     minutes = FieldUtils.safeAdd(minutes, getMinutes()); [EOL]     minutes = FieldUtils.safeAdd(minutes, ((long) getHours()) * ((long) DateTimeConstants.MINUTES_PER_HOUR)); [EOL]     minutes = FieldUtils.safeAdd(minutes, ((long) getDays()) * ((long) DateTimeConstants.MINUTES_PER_DAY)); [EOL]     minutes = FieldUtils.safeAdd(minutes, ((long) getWeeks()) * ((long) DateTimeConstants.MINUTES_PER_WEEK)); [EOL]     return Minutes.minutes(FieldUtils.safeToInt(minutes)); [EOL] }
public Minutes toStandardMinutes() { [EOL]     checkYearsAndMonths("Minutes"); [EOL]     long millis = getMillis(); [EOL]     millis += ((long) getSeconds()) * DateTimeConstants.MILLIS_PER_SECOND; [EOL]     long minutes = millis / DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     minutes = FieldUtils.safeAdd(minutes, getMinutes()); [EOL]     minutes = FieldUtils.safeAdd(minutes, ((long) getHours()) * ((long) DateTimeConstants.MINUTES_PER_HOUR)); [EOL]     minutes = FieldUtils.safeAdd(minutes, ((long) getDays()) * ((long) DateTimeConstants.MINUTES_PER_DAY)); [EOL]     minutes = FieldUtils.safeAdd(minutes, ((long) getWeeks()) * ((long) DateTimeConstants.MINUTES_PER_WEEK)); [EOL]     return Minutes.minutes(FieldUtils.safeToInt(minutes)); [EOL] }
public Minutes toStandardMinutes() { [EOL]     checkYearsAndMonths("Minutes"); [EOL]     long millis = getMillis(); [EOL]     millis += ((long) getSeconds()) * DateTimeConstants.MILLIS_PER_SECOND; [EOL]     long minutes = millis / DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     minutes = FieldUtils.safeAdd(minutes, getMinutes()); [EOL]     minutes = FieldUtils.safeAdd(minutes, ((long) getHours()) * ((long) DateTimeConstants.MINUTES_PER_HOUR)); [EOL]     minutes = FieldUtils.safeAdd(minutes, ((long) getDays()) * ((long) DateTimeConstants.MINUTES_PER_DAY)); [EOL]     minutes = FieldUtils.safeAdd(minutes, ((long) getWeeks()) * ((long) DateTimeConstants.MINUTES_PER_WEEK)); [EOL]     return Minutes.minutes(FieldUtils.safeToInt(minutes)); [EOL] }
public Minutes toStandardMinutes() { [EOL]     checkYearsAndMonths("Minutes"); [EOL]     long millis = getMillis(); [EOL]     millis += ((long) getSeconds()) * DateTimeConstants.MILLIS_PER_SECOND; [EOL]     long minutes = millis / DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     minutes = FieldUtils.safeAdd(minutes, getMinutes()); [EOL]     minutes = FieldUtils.safeAdd(minutes, ((long) getHours()) * ((long) DateTimeConstants.MINUTES_PER_HOUR)); [EOL]     minutes = FieldUtils.safeAdd(minutes, ((long) getDays()) * ((long) DateTimeConstants.MINUTES_PER_DAY)); [EOL]     minutes = FieldUtils.safeAdd(minutes, ((long) getWeeks()) * ((long) DateTimeConstants.MINUTES_PER_WEEK)); [EOL]     return Minutes.minutes(FieldUtils.safeToInt(minutes)); [EOL] }
public Minutes toStandardMinutes() { [EOL]     checkYearsAndMonths("Minutes"); [EOL]     long millis = getMillis(); [EOL]     millis += ((long) getSeconds()) * DateTimeConstants.MILLIS_PER_SECOND; [EOL]     long minutes = millis / DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     minutes = FieldUtils.safeAdd(minutes, getMinutes()); [EOL]     minutes = FieldUtils.safeAdd(minutes, ((long) getHours()) * ((long) DateTimeConstants.MINUTES_PER_HOUR)); [EOL]     minutes = FieldUtils.safeAdd(minutes, ((long) getDays()) * ((long) DateTimeConstants.MINUTES_PER_DAY)); [EOL]     minutes = FieldUtils.safeAdd(minutes, ((long) getWeeks()) * ((long) DateTimeConstants.MINUTES_PER_WEEK)); [EOL]     return Minutes.minutes(FieldUtils.safeToInt(minutes)); [EOL] }
public Minutes toStandardMinutes() { [EOL]     checkYearsAndMonths("Minutes"); [EOL]     long millis = getMillis(); [EOL]     millis += ((long) getSeconds()) * DateTimeConstants.MILLIS_PER_SECOND; [EOL]     long minutes = millis / DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     minutes = FieldUtils.safeAdd(minutes, getMinutes()); [EOL]     minutes = FieldUtils.safeAdd(minutes, ((long) getHours()) * ((long) DateTimeConstants.MINUTES_PER_HOUR)); [EOL]     minutes = FieldUtils.safeAdd(minutes, ((long) getDays()) * ((long) DateTimeConstants.MINUTES_PER_DAY)); [EOL]     minutes = FieldUtils.safeAdd(minutes, ((long) getWeeks()) * ((long) DateTimeConstants.MINUTES_PER_WEEK)); [EOL]     return Minutes.minutes(FieldUtils.safeToInt(minutes)); [EOL] }
private void checkYearsAndMonths(String destintionType) { [EOL]     if (getMonths() != 0) { [EOL]         throw new UnsupportedOperationException("Cannot convert to " + destintionType + " as this period contains months and months vary in length"); [EOL]     } [EOL]     if (getYears() != 0) { [EOL]         throw new UnsupportedOperationException("Cannot convert to " + destintionType + " as this period contains years and years vary in length"); [EOL]     } [EOL] }
private void checkYearsAndMonths(String destintionType) { [EOL]     if (getMonths() != 0) { [EOL]         throw new UnsupportedOperationException("Cannot convert to " + destintionType + " as this period contains months and months vary in length"); [EOL]     } [EOL]     if (getYears() != 0) { [EOL]         throw new UnsupportedOperationException("Cannot convert to " + destintionType + " as this period contains years and years vary in length"); [EOL]     } [EOL] }
private void checkYearsAndMonths(String destintionType) { [EOL]     if (getMonths() != 0) { [EOL]         throw new UnsupportedOperationException("Cannot convert to " + destintionType + " as this period contains months and months vary in length"); [EOL]     } [EOL]     if (getYears() != 0) { [EOL]         throw new UnsupportedOperationException("Cannot convert to " + destintionType + " as this period contains years and years vary in length"); [EOL]     } [EOL] }
public static IslamicChronology getInstance() { [EOL]     return getInstance(DateTimeZone.getDefault(), LEAP_YEAR_16_BASED); [EOL] }
public static IslamicChronology getInstance(DateTimeZone zone, LeapYearPatternType leapYears) { [EOL]     if (zone == null) { [EOL]         zone = DateTimeZone.getDefault(); [EOL]     } [EOL]     IslamicChronology chrono; [EOL]     synchronized (cCache) { [EOL]         IslamicChronology[] chronos = cCache.get(zone); [EOL]         if (chronos == null) { [EOL]             chronos = new IslamicChronology[4]; [EOL]             cCache.put(zone, chronos); [EOL]         } [EOL]         chrono = chronos[leapYears.index]; [EOL]         if (chrono == null) { [EOL]             if (zone == DateTimeZone.UTC) { [EOL]                 chrono = new IslamicChronology(null, null, leapYears); [EOL]                 DateTime lowerLimit = new DateTime(1, 1, 1, 0, 0, 0, 0, chrono); [EOL]                 chrono = new IslamicChronology(LimitChronology.getInstance(chrono, lowerLimit, null), null, leapYears); [EOL]             } else { [EOL]                 chrono = getInstance(DateTimeZone.UTC, leapYears); [EOL]                 chrono = new IslamicChronology(ZonedChronology.getInstance(chrono, zone), null, leapYears); [EOL]             } [EOL]             chronos[leapYears.index] = chrono; [EOL]         } [EOL]     } [EOL]     return chrono; [EOL] }
public static IslamicChronology getInstance(DateTimeZone zone, LeapYearPatternType leapYears) { [EOL]     if (zone == null) { [EOL]         zone = DateTimeZone.getDefault(); [EOL]     } [EOL]     IslamicChronology chrono; [EOL]     synchronized (cCache) { [EOL]         IslamicChronology[] chronos = cCache.get(zone); [EOL]         if (chronos == null) { [EOL]             chronos = new IslamicChronology[4]; [EOL]             cCache.put(zone, chronos); [EOL]         } [EOL]         chrono = chronos[leapYears.index]; [EOL]         if (chrono == null) { [EOL]             if (zone == DateTimeZone.UTC) { [EOL]                 chrono = new IslamicChronology(null, null, leapYears); [EOL]                 DateTime lowerLimit = new DateTime(1, 1, 1, 0, 0, 0, 0, chrono); [EOL]                 chrono = new IslamicChronology(LimitChronology.getInstance(chrono, lowerLimit, null), null, leapYears); [EOL]             } else { [EOL]                 chrono = getInstance(DateTimeZone.UTC, leapYears); [EOL]                 chrono = new IslamicChronology(ZonedChronology.getInstance(chrono, zone), null, leapYears); [EOL]             } [EOL]             chronos[leapYears.index] = chrono; [EOL]         } [EOL]     } [EOL]     return chrono; [EOL] }
public static IslamicChronology getInstance(DateTimeZone zone, LeapYearPatternType leapYears) { [EOL]     if (zone == null) { [EOL]         zone = DateTimeZone.getDefault(); [EOL]     } [EOL]     IslamicChronology chrono; [EOL]     synchronized (cCache) { [EOL]         IslamicChronology[] chronos = cCache.get(zone); [EOL]         if (chronos == null) { [EOL]             chronos = new IslamicChronology[4]; [EOL]             cCache.put(zone, chronos); [EOL]         } [EOL]         chrono = chronos[leapYears.index]; [EOL]         if (chrono == null) { [EOL]             if (zone == DateTimeZone.UTC) { [EOL]                 chrono = new IslamicChronology(null, null, leapYears); [EOL]                 DateTime lowerLimit = new DateTime(1, 1, 1, 0, 0, 0, 0, chrono); [EOL]                 chrono = new IslamicChronology(LimitChronology.getInstance(chrono, lowerLimit, null), null, leapYears); [EOL]             } else { [EOL]                 chrono = getInstance(DateTimeZone.UTC, leapYears); [EOL]                 chrono = new IslamicChronology(ZonedChronology.getInstance(chrono, zone), null, leapYears); [EOL]             } [EOL]             chronos[leapYears.index] = chrono; [EOL]         } [EOL]     } [EOL]     return chrono; [EOL] }
long setYear(long instant, int year) { [EOL]     int thisYear = getYear(instant); [EOL]     int dayOfYear = getDayOfYear(instant, thisYear); [EOL]     int millisOfDay = getMillisOfDay(instant); [EOL]     if (dayOfYear > 354) { [EOL]         if (!isLeapYear(year)) { [EOL]             dayOfYear--; [EOL]         } [EOL]     } [EOL]     instant = getYearMonthDayMillis(year, 1, dayOfYear); [EOL]     instant += millisOfDay; [EOL]     return instant; [EOL] }
long setYear(long instant, int year) { [EOL]     int thisYear = getYear(instant); [EOL]     int dayOfYear = getDayOfYear(instant, thisYear); [EOL]     int millisOfDay = getMillisOfDay(instant); [EOL]     if (dayOfYear > 354) { [EOL]         if (!isLeapYear(year)) { [EOL]             dayOfYear--; [EOL]         } [EOL]     } [EOL]     instant = getYearMonthDayMillis(year, 1, dayOfYear); [EOL]     instant += millisOfDay; [EOL]     return instant; [EOL] }
long setYear(long instant, int year) { [EOL]     int thisYear = getYear(instant); [EOL]     int dayOfYear = getDayOfYear(instant, thisYear); [EOL]     int millisOfDay = getMillisOfDay(instant); [EOL]     if (dayOfYear > 354) { [EOL]         if (!isLeapYear(year)) { [EOL]             dayOfYear--; [EOL]         } [EOL]     } [EOL]     instant = getYearMonthDayMillis(year, 1, dayOfYear); [EOL]     instant += millisOfDay; [EOL]     return instant; [EOL] }
long getTotalMillisByYearMonth(int year, int month) { [EOL]     if (--month % 2 == 1) { [EOL]         month /= 2; [EOL]         return month * MILLIS_PER_MONTH_PAIR + MILLIS_PER_LONG_MONTH; [EOL]     } else { [EOL]         month /= 2; [EOL]         return month * MILLIS_PER_MONTH_PAIR; [EOL]     } [EOL] }
long getTotalMillisByYearMonth(int year, int month) { [EOL]     if (--month % 2 == 1) { [EOL]         month /= 2; [EOL]         return month * MILLIS_PER_MONTH_PAIR + MILLIS_PER_LONG_MONTH; [EOL]     } else { [EOL]         month /= 2; [EOL]         return month * MILLIS_PER_MONTH_PAIR; [EOL]     } [EOL] }
int getDaysInYearMonth(int year, int month) { [EOL]     if (month == 12 && isLeapYear(year)) { [EOL]         return LONG_MONTH_LENGTH; [EOL]     } [EOL]     return (--month % 2 == 0 ? LONG_MONTH_LENGTH : SHORT_MONTH_LENGTH); [EOL] }
int getDaysInYearMonth(int year, int month) { [EOL]     if (month == 12 && isLeapYear(year)) { [EOL]         return LONG_MONTH_LENGTH; [EOL]     } [EOL]     return (--month % 2 == 0 ? LONG_MONTH_LENGTH : SHORT_MONTH_LENGTH); [EOL] }
int getDaysInYearMonth(int year, int month) { [EOL]     if (month == 12 && isLeapYear(year)) { [EOL]         return LONG_MONTH_LENGTH; [EOL]     } [EOL]     return (--month % 2 == 0 ? LONG_MONTH_LENGTH : SHORT_MONTH_LENGTH); [EOL] }
int getDaysInYearMonth(int year, int month) { [EOL]     if (month == 12 && isLeapYear(year)) { [EOL]         return LONG_MONTH_LENGTH; [EOL]     } [EOL]     return (--month % 2 == 0 ? LONG_MONTH_LENGTH : SHORT_MONTH_LENGTH); [EOL] }
int getMinYear() { [EOL]     return 1; [EOL] }
int getMaxYear() { [EOL]     return MAX_YEAR; [EOL] }
private static long convertByYear(long instant, Chronology from, Chronology to) { [EOL]     return to.getDateTimeMillis(from.year().get(instant), from.monthOfYear().get(instant), from.dayOfMonth().get(instant), from.millisOfDay().get(instant)); [EOL] }
private static long convertByYear(long instant, Chronology from, Chronology to) { [EOL]     return to.getDateTimeMillis(from.year().get(instant), from.monthOfYear().get(instant), from.dayOfMonth().get(instant), from.millisOfDay().get(instant)); [EOL] }
private static long convertByWeekyear(final long instant, Chronology from, Chronology to) { [EOL]     long newInstant; [EOL]     newInstant = to.weekyear().set(0, from.weekyear().get(instant)); [EOL]     newInstant = to.weekOfWeekyear().set(newInstant, from.weekOfWeekyear().get(instant)); [EOL]     newInstant = to.dayOfWeek().set(newInstant, from.dayOfWeek().get(instant)); [EOL]     newInstant = to.millisOfDay().set(newInstant, from.millisOfDay().get(instant)); [EOL]     return newInstant; [EOL] }
private static long convertByWeekyear(final long instant, Chronology from, Chronology to) { [EOL]     long newInstant; [EOL]     newInstant = to.weekyear().set(0, from.weekyear().get(instant)); [EOL]     newInstant = to.weekOfWeekyear().set(newInstant, from.weekOfWeekyear().get(instant)); [EOL]     newInstant = to.dayOfWeek().set(newInstant, from.dayOfWeek().get(instant)); [EOL]     newInstant = to.millisOfDay().set(newInstant, from.millisOfDay().get(instant)); [EOL]     return newInstant; [EOL] }
public static GJChronology getInstanceUTC() { [EOL]     return getInstance(DateTimeZone.UTC, DEFAULT_CUTOVER, 4); [EOL] }
public static GJChronology getInstance() { [EOL]     return getInstance(DateTimeZone.getDefault(), DEFAULT_CUTOVER, 4); [EOL] }
public static GJChronology getInstance(DateTimeZone zone) { [EOL]     return getInstance(zone, DEFAULT_CUTOVER, 4); [EOL] }
public static GJChronology getInstance(DateTimeZone zone) { [EOL]     return getInstance(zone, DEFAULT_CUTOVER, 4); [EOL] }
public static synchronized GJChronology getInstance(DateTimeZone zone, ReadableInstant gregorianCutover, int minDaysInFirstWeek) { [EOL]     zone = DateTimeUtils.getZone(zone); [EOL]     Instant cutoverInstant; [EOL]     if (gregorianCutover == null) { [EOL]         cutoverInstant = DEFAULT_CUTOVER; [EOL]     } else { [EOL]         cutoverInstant = gregorianCutover.toInstant(); [EOL]         LocalDate cutoverDate = new LocalDate(cutoverInstant.getMillis(), GregorianChronology.getInstance(zone)); [EOL]         if (cutoverDate.getYear() <= 0) { [EOL]             throw new IllegalArgumentException("Cutover too early. Must be on or after 0001-01-01."); [EOL]         } [EOL]     } [EOL]     GJChronology chrono; [EOL]     synchronized (cCache) { [EOL]         ArrayList<GJChronology> chronos = cCache.get(zone); [EOL]         if (chronos == null) { [EOL]             chronos = new ArrayList<GJChronology>(2); [EOL]             cCache.put(zone, chronos); [EOL]         } else { [EOL]             for (int i = chronos.size(); --i >= 0; ) { [EOL]                 chrono = chronos.get(i); [EOL]                 if (minDaysInFirstWeek == chrono.getMinimumDaysInFirstWeek() && cutoverInstant.equals(chrono.getGregorianCutover())) { [EOL]                     return chrono; [EOL]                 } [EOL]             } [EOL]         } [EOL]         if (zone == DateTimeZone.UTC) { [EOL]             chrono = new GJChronology(JulianChronology.getInstance(zone, minDaysInFirstWeek), GregorianChronology.getInstance(zone, minDaysInFirstWeek), cutoverInstant); [EOL]         } else { [EOL]             chrono = getInstance(DateTimeZone.UTC, cutoverInstant, minDaysInFirstWeek); [EOL]             chrono = new GJChronology(ZonedChronology.getInstance(chrono, zone), chrono.iJulianChronology, chrono.iGregorianChronology, chrono.iCutoverInstant); [EOL]         } [EOL]         chronos.add(chrono); [EOL]     } [EOL]     return chrono; [EOL] }
public static synchronized GJChronology getInstance(DateTimeZone zone, ReadableInstant gregorianCutover, int minDaysInFirstWeek) { [EOL]     zone = DateTimeUtils.getZone(zone); [EOL]     Instant cutoverInstant; [EOL]     if (gregorianCutover == null) { [EOL]         cutoverInstant = DEFAULT_CUTOVER; [EOL]     } else { [EOL]         cutoverInstant = gregorianCutover.toInstant(); [EOL]         LocalDate cutoverDate = new LocalDate(cutoverInstant.getMillis(), GregorianChronology.getInstance(zone)); [EOL]         if (cutoverDate.getYear() <= 0) { [EOL]             throw new IllegalArgumentException("Cutover too early. Must be on or after 0001-01-01."); [EOL]         } [EOL]     } [EOL]     GJChronology chrono; [EOL]     synchronized (cCache) { [EOL]         ArrayList<GJChronology> chronos = cCache.get(zone); [EOL]         if (chronos == null) { [EOL]             chronos = new ArrayList<GJChronology>(2); [EOL]             cCache.put(zone, chronos); [EOL]         } else { [EOL]             for (int i = chronos.size(); --i >= 0; ) { [EOL]                 chrono = chronos.get(i); [EOL]                 if (minDaysInFirstWeek == chrono.getMinimumDaysInFirstWeek() && cutoverInstant.equals(chrono.getGregorianCutover())) { [EOL]                     return chrono; [EOL]                 } [EOL]             } [EOL]         } [EOL]         if (zone == DateTimeZone.UTC) { [EOL]             chrono = new GJChronology(JulianChronology.getInstance(zone, minDaysInFirstWeek), GregorianChronology.getInstance(zone, minDaysInFirstWeek), cutoverInstant); [EOL]         } else { [EOL]             chrono = getInstance(DateTimeZone.UTC, cutoverInstant, minDaysInFirstWeek); [EOL]             chrono = new GJChronology(ZonedChronology.getInstance(chrono, zone), chrono.iJulianChronology, chrono.iGregorianChronology, chrono.iCutoverInstant); [EOL]         } [EOL]         chronos.add(chrono); [EOL]     } [EOL]     return chrono; [EOL] }
public static synchronized GJChronology getInstance(DateTimeZone zone, ReadableInstant gregorianCutover, int minDaysInFirstWeek) { [EOL]     zone = DateTimeUtils.getZone(zone); [EOL]     Instant cutoverInstant; [EOL]     if (gregorianCutover == null) { [EOL]         cutoverInstant = DEFAULT_CUTOVER; [EOL]     } else { [EOL]         cutoverInstant = gregorianCutover.toInstant(); [EOL]         LocalDate cutoverDate = new LocalDate(cutoverInstant.getMillis(), GregorianChronology.getInstance(zone)); [EOL]         if (cutoverDate.getYear() <= 0) { [EOL]             throw new IllegalArgumentException("Cutover too early. Must be on or after 0001-01-01."); [EOL]         } [EOL]     } [EOL]     GJChronology chrono; [EOL]     synchronized (cCache) { [EOL]         ArrayList<GJChronology> chronos = cCache.get(zone); [EOL]         if (chronos == null) { [EOL]             chronos = new ArrayList<GJChronology>(2); [EOL]             cCache.put(zone, chronos); [EOL]         } else { [EOL]             for (int i = chronos.size(); --i >= 0; ) { [EOL]                 chrono = chronos.get(i); [EOL]                 if (minDaysInFirstWeek == chrono.getMinimumDaysInFirstWeek() && cutoverInstant.equals(chrono.getGregorianCutover())) { [EOL]                     return chrono; [EOL]                 } [EOL]             } [EOL]         } [EOL]         if (zone == DateTimeZone.UTC) { [EOL]             chrono = new GJChronology(JulianChronology.getInstance(zone, minDaysInFirstWeek), GregorianChronology.getInstance(zone, minDaysInFirstWeek), cutoverInstant); [EOL]         } else { [EOL]             chrono = getInstance(DateTimeZone.UTC, cutoverInstant, minDaysInFirstWeek); [EOL]             chrono = new GJChronology(ZonedChronology.getInstance(chrono, zone), chrono.iJulianChronology, chrono.iGregorianChronology, chrono.iCutoverInstant); [EOL]         } [EOL]         chronos.add(chrono); [EOL]     } [EOL]     return chrono; [EOL] }
public static synchronized GJChronology getInstance(DateTimeZone zone, ReadableInstant gregorianCutover, int minDaysInFirstWeek) { [EOL]     zone = DateTimeUtils.getZone(zone); [EOL]     Instant cutoverInstant; [EOL]     if (gregorianCutover == null) { [EOL]         cutoverInstant = DEFAULT_CUTOVER; [EOL]     } else { [EOL]         cutoverInstant = gregorianCutover.toInstant(); [EOL]         LocalDate cutoverDate = new LocalDate(cutoverInstant.getMillis(), GregorianChronology.getInstance(zone)); [EOL]         if (cutoverDate.getYear() <= 0) { [EOL]             throw new IllegalArgumentException("Cutover too early. Must be on or after 0001-01-01."); [EOL]         } [EOL]     } [EOL]     GJChronology chrono; [EOL]     synchronized (cCache) { [EOL]         ArrayList<GJChronology> chronos = cCache.get(zone); [EOL]         if (chronos == null) { [EOL]             chronos = new ArrayList<GJChronology>(2); [EOL]             cCache.put(zone, chronos); [EOL]         } else { [EOL]             for (int i = chronos.size(); --i >= 0; ) { [EOL]                 chrono = chronos.get(i); [EOL]                 if (minDaysInFirstWeek == chrono.getMinimumDaysInFirstWeek() && cutoverInstant.equals(chrono.getGregorianCutover())) { [EOL]                     return chrono; [EOL]                 } [EOL]             } [EOL]         } [EOL]         if (zone == DateTimeZone.UTC) { [EOL]             chrono = new GJChronology(JulianChronology.getInstance(zone, minDaysInFirstWeek), GregorianChronology.getInstance(zone, minDaysInFirstWeek), cutoverInstant); [EOL]         } else { [EOL]             chrono = getInstance(DateTimeZone.UTC, cutoverInstant, minDaysInFirstWeek); [EOL]             chrono = new GJChronology(ZonedChronology.getInstance(chrono, zone), chrono.iJulianChronology, chrono.iGregorianChronology, chrono.iCutoverInstant); [EOL]         } [EOL]         chronos.add(chrono); [EOL]     } [EOL]     return chrono; [EOL] }
public static synchronized GJChronology getInstance(DateTimeZone zone, ReadableInstant gregorianCutover, int minDaysInFirstWeek) { [EOL]     zone = DateTimeUtils.getZone(zone); [EOL]     Instant cutoverInstant; [EOL]     if (gregorianCutover == null) { [EOL]         cutoverInstant = DEFAULT_CUTOVER; [EOL]     } else { [EOL]         cutoverInstant = gregorianCutover.toInstant(); [EOL]         LocalDate cutoverDate = new LocalDate(cutoverInstant.getMillis(), GregorianChronology.getInstance(zone)); [EOL]         if (cutoverDate.getYear() <= 0) { [EOL]             throw new IllegalArgumentException("Cutover too early. Must be on or after 0001-01-01."); [EOL]         } [EOL]     } [EOL]     GJChronology chrono; [EOL]     synchronized (cCache) { [EOL]         ArrayList<GJChronology> chronos = cCache.get(zone); [EOL]         if (chronos == null) { [EOL]             chronos = new ArrayList<GJChronology>(2); [EOL]             cCache.put(zone, chronos); [EOL]         } else { [EOL]             for (int i = chronos.size(); --i >= 0; ) { [EOL]                 chrono = chronos.get(i); [EOL]                 if (minDaysInFirstWeek == chrono.getMinimumDaysInFirstWeek() && cutoverInstant.equals(chrono.getGregorianCutover())) { [EOL]                     return chrono; [EOL]                 } [EOL]             } [EOL]         } [EOL]         if (zone == DateTimeZone.UTC) { [EOL]             chrono = new GJChronology(JulianChronology.getInstance(zone, minDaysInFirstWeek), GregorianChronology.getInstance(zone, minDaysInFirstWeek), cutoverInstant); [EOL]         } else { [EOL]             chrono = getInstance(DateTimeZone.UTC, cutoverInstant, minDaysInFirstWeek); [EOL]             chrono = new GJChronology(ZonedChronology.getInstance(chrono, zone), chrono.iJulianChronology, chrono.iGregorianChronology, chrono.iCutoverInstant); [EOL]         } [EOL]         chronos.add(chrono); [EOL]     } [EOL]     return chrono; [EOL] }
public static synchronized GJChronology getInstance(DateTimeZone zone, ReadableInstant gregorianCutover, int minDaysInFirstWeek) { [EOL]     zone = DateTimeUtils.getZone(zone); [EOL]     Instant cutoverInstant; [EOL]     if (gregorianCutover == null) { [EOL]         cutoverInstant = DEFAULT_CUTOVER; [EOL]     } else { [EOL]         cutoverInstant = gregorianCutover.toInstant(); [EOL]         LocalDate cutoverDate = new LocalDate(cutoverInstant.getMillis(), GregorianChronology.getInstance(zone)); [EOL]         if (cutoverDate.getYear() <= 0) { [EOL]             throw new IllegalArgumentException("Cutover too early. Must be on or after 0001-01-01."); [EOL]         } [EOL]     } [EOL]     GJChronology chrono; [EOL]     synchronized (cCache) { [EOL]         ArrayList<GJChronology> chronos = cCache.get(zone); [EOL]         if (chronos == null) { [EOL]             chronos = new ArrayList<GJChronology>(2); [EOL]             cCache.put(zone, chronos); [EOL]         } else { [EOL]             for (int i = chronos.size(); --i >= 0; ) { [EOL]                 chrono = chronos.get(i); [EOL]                 if (minDaysInFirstWeek == chrono.getMinimumDaysInFirstWeek() && cutoverInstant.equals(chrono.getGregorianCutover())) { [EOL]                     return chrono; [EOL]                 } [EOL]             } [EOL]         } [EOL]         if (zone == DateTimeZone.UTC) { [EOL]             chrono = new GJChronology(JulianChronology.getInstance(zone, minDaysInFirstWeek), GregorianChronology.getInstance(zone, minDaysInFirstWeek), cutoverInstant); [EOL]         } else { [EOL]             chrono = getInstance(DateTimeZone.UTC, cutoverInstant, minDaysInFirstWeek); [EOL]             chrono = new GJChronology(ZonedChronology.getInstance(chrono, zone), chrono.iJulianChronology, chrono.iGregorianChronology, chrono.iCutoverInstant); [EOL]         } [EOL]         chronos.add(chrono); [EOL]     } [EOL]     return chrono; [EOL] }
public static synchronized GJChronology getInstance(DateTimeZone zone, ReadableInstant gregorianCutover, int minDaysInFirstWeek) { [EOL]     zone = DateTimeUtils.getZone(zone); [EOL]     Instant cutoverInstant; [EOL]     if (gregorianCutover == null) { [EOL]         cutoverInstant = DEFAULT_CUTOVER; [EOL]     } else { [EOL]         cutoverInstant = gregorianCutover.toInstant(); [EOL]         LocalDate cutoverDate = new LocalDate(cutoverInstant.getMillis(), GregorianChronology.getInstance(zone)); [EOL]         if (cutoverDate.getYear() <= 0) { [EOL]             throw new IllegalArgumentException("Cutover too early. Must be on or after 0001-01-01."); [EOL]         } [EOL]     } [EOL]     GJChronology chrono; [EOL]     synchronized (cCache) { [EOL]         ArrayList<GJChronology> chronos = cCache.get(zone); [EOL]         if (chronos == null) { [EOL]             chronos = new ArrayList<GJChronology>(2); [EOL]             cCache.put(zone, chronos); [EOL]         } else { [EOL]             for (int i = chronos.size(); --i >= 0; ) { [EOL]                 chrono = chronos.get(i); [EOL]                 if (minDaysInFirstWeek == chrono.getMinimumDaysInFirstWeek() && cutoverInstant.equals(chrono.getGregorianCutover())) { [EOL]                     return chrono; [EOL]                 } [EOL]             } [EOL]         } [EOL]         if (zone == DateTimeZone.UTC) { [EOL]             chrono = new GJChronology(JulianChronology.getInstance(zone, minDaysInFirstWeek), GregorianChronology.getInstance(zone, minDaysInFirstWeek), cutoverInstant); [EOL]         } else { [EOL]             chrono = getInstance(DateTimeZone.UTC, cutoverInstant, minDaysInFirstWeek); [EOL]             chrono = new GJChronology(ZonedChronology.getInstance(chrono, zone), chrono.iJulianChronology, chrono.iGregorianChronology, chrono.iCutoverInstant); [EOL]         } [EOL]         chronos.add(chrono); [EOL]     } [EOL]     return chrono; [EOL] }
public static GJChronology getInstance(DateTimeZone zone, long gregorianCutover, int minDaysInFirstWeek) { [EOL]     Instant cutoverInstant; [EOL]     if (gregorianCutover == DEFAULT_CUTOVER.getMillis()) { [EOL]         cutoverInstant = null; [EOL]     } else { [EOL]         cutoverInstant = new Instant(gregorianCutover); [EOL]     } [EOL]     return getInstance(zone, cutoverInstant, minDaysInFirstWeek); [EOL] }
public static GJChronology getInstance(DateTimeZone zone, long gregorianCutover, int minDaysInFirstWeek) { [EOL]     Instant cutoverInstant; [EOL]     if (gregorianCutover == DEFAULT_CUTOVER.getMillis()) { [EOL]         cutoverInstant = null; [EOL]     } else { [EOL]         cutoverInstant = new Instant(gregorianCutover); [EOL]     } [EOL]     return getInstance(zone, cutoverInstant, minDaysInFirstWeek); [EOL] }
public static GJChronology getInstance(DateTimeZone zone, long gregorianCutover, int minDaysInFirstWeek) { [EOL]     Instant cutoverInstant; [EOL]     if (gregorianCutover == DEFAULT_CUTOVER.getMillis()) { [EOL]         cutoverInstant = null; [EOL]     } else { [EOL]         cutoverInstant = new Instant(gregorianCutover); [EOL]     } [EOL]     return getInstance(zone, cutoverInstant, minDaysInFirstWeek); [EOL] }
private GJChronology(JulianChronology julian, GregorianChronology gregorian, Instant cutoverInstant) { [EOL]     super(null, new Object[] { julian, gregorian, cutoverInstant }); [EOL] }
private GJChronology(Chronology base, JulianChronology julian, GregorianChronology gregorian, Instant cutoverInstant) { [EOL]     super(base, new Object[] { julian, gregorian, cutoverInstant }); [EOL] }
private Object readResolve() { [EOL]     return getInstance(getZone(), iCutoverInstant, getMinimumDaysInFirstWeek()); [EOL] }
public DateTimeZone getZone() { [EOL]     Chronology base; [EOL]     if ((base = getBase()) != null) { [EOL]         return base.getZone(); [EOL]     } [EOL]     return DateTimeZone.UTC; [EOL] }
public DateTimeZone getZone() { [EOL]     Chronology base; [EOL]     if ((base = getBase()) != null) { [EOL]         return base.getZone(); [EOL]     } [EOL]     return DateTimeZone.UTC; [EOL] }
public Chronology withUTC() { [EOL]     return withZone(DateTimeZone.UTC); [EOL] }
public Chronology withZone(DateTimeZone zone) { [EOL]     if (zone == null) { [EOL]         zone = DateTimeZone.getDefault(); [EOL]     } [EOL]     if (zone == getZone()) { [EOL]         return this; [EOL]     } [EOL]     return getInstance(zone, iCutoverInstant, getMinimumDaysInFirstWeek()); [EOL] }
public Chronology withZone(DateTimeZone zone) { [EOL]     if (zone == null) { [EOL]         zone = DateTimeZone.getDefault(); [EOL]     } [EOL]     if (zone == getZone()) { [EOL]         return this; [EOL]     } [EOL]     return getInstance(zone, iCutoverInstant, getMinimumDaysInFirstWeek()); [EOL] }
public Chronology withZone(DateTimeZone zone) { [EOL]     if (zone == null) { [EOL]         zone = DateTimeZone.getDefault(); [EOL]     } [EOL]     if (zone == getZone()) { [EOL]         return this; [EOL]     } [EOL]     return getInstance(zone, iCutoverInstant, getMinimumDaysInFirstWeek()); [EOL] }
public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int millisOfDay) throws IllegalArgumentException { [EOL]     Chronology base; [EOL]     if ((base = getBase()) != null) { [EOL]         return base.getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay); [EOL]     } [EOL]     long instant = iGregorianChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay); [EOL]     if (instant < iCutoverMillis) { [EOL]         instant = iJulianChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay); [EOL]         if (instant >= iCutoverMillis) { [EOL]             throw new IllegalArgumentException("Specified date does not exist"); [EOL]         } [EOL]     } [EOL]     return instant; [EOL] }
public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int millisOfDay) throws IllegalArgumentException { [EOL]     Chronology base; [EOL]     if ((base = getBase()) != null) { [EOL]         return base.getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay); [EOL]     } [EOL]     long instant = iGregorianChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay); [EOL]     if (instant < iCutoverMillis) { [EOL]         instant = iJulianChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay); [EOL]         if (instant >= iCutoverMillis) { [EOL]             throw new IllegalArgumentException("Specified date does not exist"); [EOL]         } [EOL]     } [EOL]     return instant; [EOL] }
public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int millisOfDay) throws IllegalArgumentException { [EOL]     Chronology base; [EOL]     if ((base = getBase()) != null) { [EOL]         return base.getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay); [EOL]     } [EOL]     long instant = iGregorianChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay); [EOL]     if (instant < iCutoverMillis) { [EOL]         instant = iJulianChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay); [EOL]         if (instant >= iCutoverMillis) { [EOL]             throw new IllegalArgumentException("Specified date does not exist"); [EOL]         } [EOL]     } [EOL]     return instant; [EOL] }
public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) throws IllegalArgumentException { [EOL]     Chronology base; [EOL]     if ((base = getBase()) != null) { [EOL]         return base.getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]     } [EOL]     long instant; [EOL]     try { [EOL]         instant = iGregorianChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]     } catch (IllegalFieldValueException ex) { [EOL]         if (monthOfYear != 2 || dayOfMonth != 29) { [EOL]             throw ex; [EOL]         } [EOL]         instant = iGregorianChronology.getDateTimeMillis(year, monthOfYear, 28, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]         if (instant >= iCutoverMillis) { [EOL]             throw ex; [EOL]         } [EOL]     } [EOL]     if (instant < iCutoverMillis) { [EOL]         instant = iJulianChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]         if (instant >= iCutoverMillis) { [EOL]             throw new IllegalArgumentException("Specified date does not exist"); [EOL]         } [EOL]     } [EOL]     return instant; [EOL] }
public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) throws IllegalArgumentException { [EOL]     Chronology base; [EOL]     if ((base = getBase()) != null) { [EOL]         return base.getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]     } [EOL]     long instant; [EOL]     try { [EOL]         instant = iGregorianChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]     } catch (IllegalFieldValueException ex) { [EOL]         if (monthOfYear != 2 || dayOfMonth != 29) { [EOL]             throw ex; [EOL]         } [EOL]         instant = iGregorianChronology.getDateTimeMillis(year, monthOfYear, 28, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]         if (instant >= iCutoverMillis) { [EOL]             throw ex; [EOL]         } [EOL]     } [EOL]     if (instant < iCutoverMillis) { [EOL]         instant = iJulianChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]         if (instant >= iCutoverMillis) { [EOL]             throw new IllegalArgumentException("Specified date does not exist"); [EOL]         } [EOL]     } [EOL]     return instant; [EOL] }
public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) throws IllegalArgumentException { [EOL]     Chronology base; [EOL]     if ((base = getBase()) != null) { [EOL]         return base.getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]     } [EOL]     long instant; [EOL]     try { [EOL]         instant = iGregorianChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]     } catch (IllegalFieldValueException ex) { [EOL]         if (monthOfYear != 2 || dayOfMonth != 29) { [EOL]             throw ex; [EOL]         } [EOL]         instant = iGregorianChronology.getDateTimeMillis(year, monthOfYear, 28, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]         if (instant >= iCutoverMillis) { [EOL]             throw ex; [EOL]         } [EOL]     } [EOL]     if (instant < iCutoverMillis) { [EOL]         instant = iJulianChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]         if (instant >= iCutoverMillis) { [EOL]             throw new IllegalArgumentException("Specified date does not exist"); [EOL]         } [EOL]     } [EOL]     return instant; [EOL] }
public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) throws IllegalArgumentException { [EOL]     Chronology base; [EOL]     if ((base = getBase()) != null) { [EOL]         return base.getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]     } [EOL]     long instant; [EOL]     try { [EOL]         instant = iGregorianChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]     } catch (IllegalFieldValueException ex) { [EOL]         if (monthOfYear != 2 || dayOfMonth != 29) { [EOL]             throw ex; [EOL]         } [EOL]         instant = iGregorianChronology.getDateTimeMillis(year, monthOfYear, 28, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]         if (instant >= iCutoverMillis) { [EOL]             throw ex; [EOL]         } [EOL]     } [EOL]     if (instant < iCutoverMillis) { [EOL]         instant = iJulianChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]         if (instant >= iCutoverMillis) { [EOL]             throw new IllegalArgumentException("Specified date does not exist"); [EOL]         } [EOL]     } [EOL]     return instant; [EOL] }
public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) throws IllegalArgumentException { [EOL]     Chronology base; [EOL]     if ((base = getBase()) != null) { [EOL]         return base.getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]     } [EOL]     long instant; [EOL]     try { [EOL]         instant = iGregorianChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]     } catch (IllegalFieldValueException ex) { [EOL]         if (monthOfYear != 2 || dayOfMonth != 29) { [EOL]             throw ex; [EOL]         } [EOL]         instant = iGregorianChronology.getDateTimeMillis(year, monthOfYear, 28, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]         if (instant >= iCutoverMillis) { [EOL]             throw ex; [EOL]         } [EOL]     } [EOL]     if (instant < iCutoverMillis) { [EOL]         instant = iJulianChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]         if (instant >= iCutoverMillis) { [EOL]             throw new IllegalArgumentException("Specified date does not exist"); [EOL]         } [EOL]     } [EOL]     return instant; [EOL] }
public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) throws IllegalArgumentException { [EOL]     Chronology base; [EOL]     if ((base = getBase()) != null) { [EOL]         return base.getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]     } [EOL]     long instant; [EOL]     try { [EOL]         instant = iGregorianChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]     } catch (IllegalFieldValueException ex) { [EOL]         if (monthOfYear != 2 || dayOfMonth != 29) { [EOL]             throw ex; [EOL]         } [EOL]         instant = iGregorianChronology.getDateTimeMillis(year, monthOfYear, 28, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]         if (instant >= iCutoverMillis) { [EOL]             throw ex; [EOL]         } [EOL]     } [EOL]     if (instant < iCutoverMillis) { [EOL]         instant = iJulianChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]         if (instant >= iCutoverMillis) { [EOL]             throw new IllegalArgumentException("Specified date does not exist"); [EOL]         } [EOL]     } [EOL]     return instant; [EOL] }
public Instant getGregorianCutover() { [EOL]     return iCutoverInstant; [EOL] }
public int getMinimumDaysInFirstWeek() { [EOL]     return iGregorianChronology.getMinimumDaysInFirstWeek(); [EOL] }
protected void assemble(Fields fields) { [EOL]     Object[] params = (Object[]) getParam(); [EOL]     JulianChronology julian = (JulianChronology) params[0]; [EOL]     GregorianChronology gregorian = (GregorianChronology) params[1]; [EOL]     Instant cutoverInstant = (Instant) params[2]; [EOL]     iCutoverMillis = cutoverInstant.getMillis(); [EOL]     iJulianChronology = julian; [EOL]     iGregorianChronology = gregorian; [EOL]     iCutoverInstant = cutoverInstant; [EOL]     if (getBase() != null) { [EOL]         return; [EOL]     } [EOL]     if (julian.getMinimumDaysInFirstWeek() != gregorian.getMinimumDaysInFirstWeek()) { [EOL]         throw new IllegalArgumentException(); [EOL]     } [EOL]     iGapDuration = iCutoverMillis - julianToGregorianByYear(iCutoverMillis); [EOL]     fields.copyFieldsFrom(gregorian); [EOL]     if (gregorian.millisOfDay().get(iCutoverMillis) == 0) { [EOL]         fields.millisOfSecond = new CutoverField(julian.millisOfSecond(), fields.millisOfSecond, iCutoverMillis); [EOL]         fields.millisOfDay = new CutoverField(julian.millisOfDay(), fields.millisOfDay, iCutoverMillis); [EOL]         fields.secondOfMinute = new CutoverField(julian.secondOfMinute(), fields.secondOfMinute, iCutoverMillis); [EOL]         fields.secondOfDay = new CutoverField(julian.secondOfDay(), fields.secondOfDay, iCutoverMillis); [EOL]         fields.minuteOfHour = new CutoverField(julian.minuteOfHour(), fields.minuteOfHour, iCutoverMillis); [EOL]         fields.minuteOfDay = new CutoverField(julian.minuteOfDay(), fields.minuteOfDay, iCutoverMillis); [EOL]         fields.hourOfDay = new CutoverField(julian.hourOfDay(), fields.hourOfDay, iCutoverMillis); [EOL]         fields.hourOfHalfday = new CutoverField(julian.hourOfHalfday(), fields.hourOfHalfday, iCutoverMillis); [EOL]         fields.clockhourOfDay = new CutoverField(julian.clockhourOfDay(), fields.clockhourOfDay, iCutoverMillis); [EOL]         fields.clockhourOfHalfday = new CutoverField(julian.clockhourOfHalfday(), fields.clockhourOfHalfday, iCutoverMillis); [EOL]         fields.halfdayOfDay = new CutoverField(julian.halfdayOfDay(), fields.halfdayOfDay, iCutoverMillis); [EOL]     } [EOL]     { [EOL]         fields.era = new CutoverField(julian.era(), fields.era, iCutoverMillis); [EOL]     } [EOL]     { [EOL]         fields.year = new ImpreciseCutoverField(julian.year(), fields.year, iCutoverMillis); [EOL]         fields.years = fields.year.getDurationField(); [EOL]         fields.yearOfEra = new ImpreciseCutoverField(julian.yearOfEra(), fields.yearOfEra, fields.years, iCutoverMillis); [EOL]         fields.centuryOfEra = new ImpreciseCutoverField(julian.centuryOfEra(), fields.centuryOfEra, iCutoverMillis); [EOL]         fields.centuries = fields.centuryOfEra.getDurationField(); [EOL]         fields.yearOfCentury = new ImpreciseCutoverField(julian.yearOfCentury(), fields.yearOfCentury, fields.years, fields.centuries, iCutoverMillis); [EOL]         fields.monthOfYear = new ImpreciseCutoverField(julian.monthOfYear(), fields.monthOfYear, null, fields.years, iCutoverMillis); [EOL]         fields.months = fields.monthOfYear.getDurationField(); [EOL]         fields.weekyear = new ImpreciseCutoverField(julian.weekyear(), fields.weekyear, null, iCutoverMillis, true); [EOL]         fields.weekyears = fields.weekyear.getDurationField(); [EOL]         fields.weekyearOfCentury = new ImpreciseCutoverField(julian.weekyearOfCentury(), fields.weekyearOfCentury, fields.weekyears, fields.centuries, iCutoverMillis); [EOL]     } [EOL]     { [EOL]         long cutover = gregorian.year().roundCeiling(iCutoverMillis); [EOL]         fields.dayOfYear = new CutoverField(julian.dayOfYear(), fields.dayOfYear, fields.years, cutover, false); [EOL]     } [EOL]     { [EOL]         long cutover = gregorian.weekyear().roundCeiling(iCutoverMillis); [EOL]         fields.weekOfWeekyear = new CutoverField(julian.weekOfWeekyear(), fields.weekOfWeekyear, fields.weekyears, cutover, true); [EOL]     } [EOL]     { [EOL]         CutoverField cf = new CutoverField(julian.dayOfMonth(), fields.dayOfMonth, iCutoverMillis); [EOL]         cf.iRangeDurationField = fields.months; [EOL]         fields.dayOfMonth = cf; [EOL]     } [EOL] }
long julianToGregorianByYear(long instant) { [EOL]     return convertByYear(instant, iJulianChronology, iGregorianChronology); [EOL] }
long julianToGregorianByYear(long instant) { [EOL]     return convertByYear(instant, iJulianChronology, iGregorianChronology); [EOL] }
long gregorianToJulianByYear(long instant) { [EOL]     return convertByYear(instant, iGregorianChronology, iJulianChronology); [EOL] }
long gregorianToJulianByWeekyear(long instant) { [EOL]     return convertByWeekyear(instant, iGregorianChronology, iJulianChronology); [EOL] }
CutoverField(DateTimeField julianField, DateTimeField gregorianField, long cutoverMillis) { [EOL]     this(julianField, gregorianField, cutoverMillis, false); [EOL] }
CutoverField(DateTimeField julianField, DateTimeField gregorianField, long cutoverMillis, boolean convertByWeekyear) { [EOL]     this(julianField, gregorianField, null, cutoverMillis, convertByWeekyear); [EOL] }
CutoverField(DateTimeField julianField, DateTimeField gregorianField, long cutoverMillis, boolean convertByWeekyear) { [EOL]     this(julianField, gregorianField, null, cutoverMillis, convertByWeekyear); [EOL] }
CutoverField(DateTimeField julianField, DateTimeField gregorianField, DurationField rangeField, long cutoverMillis, boolean convertByWeekyear) { [EOL]     super(gregorianField.getType()); [EOL]     iJulianField = julianField; [EOL]     iGregorianField = gregorianField; [EOL]     iCutover = cutoverMillis; [EOL]     iConvertByWeekyear = convertByWeekyear; [EOL]     iDurationField = gregorianField.getDurationField(); [EOL]     if (rangeField == null) { [EOL]         rangeField = gregorianField.getRangeDurationField(); [EOL]         if (rangeField == null) { [EOL]             rangeField = julianField.getRangeDurationField(); [EOL]         } [EOL]     } [EOL]     iRangeDurationField = rangeField; [EOL] }
CutoverField(DateTimeField julianField, DateTimeField gregorianField, DurationField rangeField, long cutoverMillis, boolean convertByWeekyear) { [EOL]     super(gregorianField.getType()); [EOL]     iJulianField = julianField; [EOL]     iGregorianField = gregorianField; [EOL]     iCutover = cutoverMillis; [EOL]     iConvertByWeekyear = convertByWeekyear; [EOL]     iDurationField = gregorianField.getDurationField(); [EOL]     if (rangeField == null) { [EOL]         rangeField = gregorianField.getRangeDurationField(); [EOL]         if (rangeField == null) { [EOL]             rangeField = julianField.getRangeDurationField(); [EOL]         } [EOL]     } [EOL]     iRangeDurationField = rangeField; [EOL] }
CutoverField(DateTimeField julianField, DateTimeField gregorianField, DurationField rangeField, long cutoverMillis, boolean convertByWeekyear) { [EOL]     super(gregorianField.getType()); [EOL]     iJulianField = julianField; [EOL]     iGregorianField = gregorianField; [EOL]     iCutover = cutoverMillis; [EOL]     iConvertByWeekyear = convertByWeekyear; [EOL]     iDurationField = gregorianField.getDurationField(); [EOL]     if (rangeField == null) { [EOL]         rangeField = gregorianField.getRangeDurationField(); [EOL]         if (rangeField == null) { [EOL]             rangeField = julianField.getRangeDurationField(); [EOL]         } [EOL]     } [EOL]     iRangeDurationField = rangeField; [EOL] }
public int get(long instant) { [EOL]     if (instant >= iCutover) { [EOL]         return iGregorianField.get(instant); [EOL]     } else { [EOL]         return iJulianField.get(instant); [EOL]     } [EOL] }
public int get(long instant) { [EOL]     if (instant >= iCutover) { [EOL]         return iGregorianField.get(instant); [EOL]     } else { [EOL]         return iJulianField.get(instant); [EOL]     } [EOL] }
public long add(long instant, int value) { [EOL]     return iGregorianField.add(instant, value); [EOL] }
public int[] add(ReadablePartial partial, int fieldIndex, int[] values, int valueToAdd) { [EOL]     if (valueToAdd == 0) { [EOL]         return values; [EOL]     } [EOL]     if (DateTimeUtils.isContiguous(partial)) { [EOL]         long instant = 0L; [EOL]         for (int i = 0, isize = partial.size(); i < isize; i++) { [EOL]             instant = partial.getFieldType(i).getField(GJChronology.this).set(instant, values[i]); [EOL]         } [EOL]         instant = add(instant, valueToAdd); [EOL]         return GJChronology.this.get(partial, instant); [EOL]     } else { [EOL]         return super.add(partial, fieldIndex, values, valueToAdd); [EOL]     } [EOL] }
public int[] add(ReadablePartial partial, int fieldIndex, int[] values, int valueToAdd) { [EOL]     if (valueToAdd == 0) { [EOL]         return values; [EOL]     } [EOL]     if (DateTimeUtils.isContiguous(partial)) { [EOL]         long instant = 0L; [EOL]         for (int i = 0, isize = partial.size(); i < isize; i++) { [EOL]             instant = partial.getFieldType(i).getField(GJChronology.this).set(instant, values[i]); [EOL]         } [EOL]         instant = add(instant, valueToAdd); [EOL]         return GJChronology.this.get(partial, instant); [EOL]     } else { [EOL]         return super.add(partial, fieldIndex, values, valueToAdd); [EOL]     } [EOL] }
public int[] add(ReadablePartial partial, int fieldIndex, int[] values, int valueToAdd) { [EOL]     if (valueToAdd == 0) { [EOL]         return values; [EOL]     } [EOL]     if (DateTimeUtils.isContiguous(partial)) { [EOL]         long instant = 0L; [EOL]         for (int i = 0, isize = partial.size(); i < isize; i++) { [EOL]             instant = partial.getFieldType(i).getField(GJChronology.this).set(instant, values[i]); [EOL]         } [EOL]         instant = add(instant, valueToAdd); [EOL]         return GJChronology.this.get(partial, instant); [EOL]     } else { [EOL]         return super.add(partial, fieldIndex, values, valueToAdd); [EOL]     } [EOL] }
public long set(long instant, int value) { [EOL]     if (instant >= iCutover) { [EOL]         instant = iGregorianField.set(instant, value); [EOL]         if (instant < iCutover) { [EOL]             if (instant + iGapDuration < iCutover) { [EOL]                 instant = gregorianToJulian(instant); [EOL]             } [EOL]             if (get(instant) != value) { [EOL]                 throw new IllegalFieldValueException(iGregorianField.getType(), Integer.valueOf(value), null, null); [EOL]             } [EOL]         } [EOL]     } else { [EOL]         instant = iJulianField.set(instant, value); [EOL]         if (instant >= iCutover) { [EOL]             if (instant - iGapDuration >= iCutover) { [EOL]                 instant = julianToGregorian(instant); [EOL]             } [EOL]             if (get(instant) != value) { [EOL]                 throw new IllegalFieldValueException(iJulianField.getType(), Integer.valueOf(value), null, null); [EOL]             } [EOL]         } [EOL]     } [EOL]     return instant; [EOL] }
public long set(long instant, int value) { [EOL]     if (instant >= iCutover) { [EOL]         instant = iGregorianField.set(instant, value); [EOL]         if (instant < iCutover) { [EOL]             if (instant + iGapDuration < iCutover) { [EOL]                 instant = gregorianToJulian(instant); [EOL]             } [EOL]             if (get(instant) != value) { [EOL]                 throw new IllegalFieldValueException(iGregorianField.getType(), Integer.valueOf(value), null, null); [EOL]             } [EOL]         } [EOL]     } else { [EOL]         instant = iJulianField.set(instant, value); [EOL]         if (instant >= iCutover) { [EOL]             if (instant - iGapDuration >= iCutover) { [EOL]                 instant = julianToGregorian(instant); [EOL]             } [EOL]             if (get(instant) != value) { [EOL]                 throw new IllegalFieldValueException(iJulianField.getType(), Integer.valueOf(value), null, null); [EOL]             } [EOL]         } [EOL]     } [EOL]     return instant; [EOL] }
public long set(long instant, int value) { [EOL]     if (instant >= iCutover) { [EOL]         instant = iGregorianField.set(instant, value); [EOL]         if (instant < iCutover) { [EOL]             if (instant + iGapDuration < iCutover) { [EOL]                 instant = gregorianToJulian(instant); [EOL]             } [EOL]             if (get(instant) != value) { [EOL]                 throw new IllegalFieldValueException(iGregorianField.getType(), Integer.valueOf(value), null, null); [EOL]             } [EOL]         } [EOL]     } else { [EOL]         instant = iJulianField.set(instant, value); [EOL]         if (instant >= iCutover) { [EOL]             if (instant - iGapDuration >= iCutover) { [EOL]                 instant = julianToGregorian(instant); [EOL]             } [EOL]             if (get(instant) != value) { [EOL]                 throw new IllegalFieldValueException(iJulianField.getType(), Integer.valueOf(value), null, null); [EOL]             } [EOL]         } [EOL]     } [EOL]     return instant; [EOL] }
public long set(long instant, int value) { [EOL]     if (instant >= iCutover) { [EOL]         instant = iGregorianField.set(instant, value); [EOL]         if (instant < iCutover) { [EOL]             if (instant + iGapDuration < iCutover) { [EOL]                 instant = gregorianToJulian(instant); [EOL]             } [EOL]             if (get(instant) != value) { [EOL]                 throw new IllegalFieldValueException(iGregorianField.getType(), Integer.valueOf(value), null, null); [EOL]             } [EOL]         } [EOL]     } else { [EOL]         instant = iJulianField.set(instant, value); [EOL]         if (instant >= iCutover) { [EOL]             if (instant - iGapDuration >= iCutover) { [EOL]                 instant = julianToGregorian(instant); [EOL]             } [EOL]             if (get(instant) != value) { [EOL]                 throw new IllegalFieldValueException(iJulianField.getType(), Integer.valueOf(value), null, null); [EOL]             } [EOL]         } [EOL]     } [EOL]     return instant; [EOL] }
public long set(long instant, int value) { [EOL]     if (instant >= iCutover) { [EOL]         instant = iGregorianField.set(instant, value); [EOL]         if (instant < iCutover) { [EOL]             if (instant + iGapDuration < iCutover) { [EOL]                 instant = gregorianToJulian(instant); [EOL]             } [EOL]             if (get(instant) != value) { [EOL]                 throw new IllegalFieldValueException(iGregorianField.getType(), Integer.valueOf(value), null, null); [EOL]             } [EOL]         } [EOL]     } else { [EOL]         instant = iJulianField.set(instant, value); [EOL]         if (instant >= iCutover) { [EOL]             if (instant - iGapDuration >= iCutover) { [EOL]                 instant = julianToGregorian(instant); [EOL]             } [EOL]             if (get(instant) != value) { [EOL]                 throw new IllegalFieldValueException(iJulianField.getType(), Integer.valueOf(value), null, null); [EOL]             } [EOL]         } [EOL]     } [EOL]     return instant; [EOL] }
public long set(long instant, int value) { [EOL]     if (instant >= iCutover) { [EOL]         instant = iGregorianField.set(instant, value); [EOL]         if (instant < iCutover) { [EOL]             if (instant + iGapDuration < iCutover) { [EOL]                 instant = gregorianToJulian(instant); [EOL]             } [EOL]             if (get(instant) != value) { [EOL]                 throw new IllegalFieldValueException(iGregorianField.getType(), Integer.valueOf(value), null, null); [EOL]             } [EOL]         } [EOL]     } else { [EOL]         instant = iJulianField.set(instant, value); [EOL]         if (instant >= iCutover) { [EOL]             if (instant - iGapDuration >= iCutover) { [EOL]                 instant = julianToGregorian(instant); [EOL]             } [EOL]             if (get(instant) != value) { [EOL]                 throw new IllegalFieldValueException(iJulianField.getType(), Integer.valueOf(value), null, null); [EOL]             } [EOL]         } [EOL]     } [EOL]     return instant; [EOL] }
public DurationField getDurationField() { [EOL]     return iDurationField; [EOL] }
public DurationField getRangeDurationField() { [EOL]     return iRangeDurationField; [EOL] }
public DurationField getLeapDurationField() { [EOL]     return iGregorianField.getLeapDurationField(); [EOL] }
public int getMaximumValue(long instant) { [EOL]     if (instant >= iCutover) { [EOL]         return iGregorianField.getMaximumValue(instant); [EOL]     } [EOL]     int max = iJulianField.getMaximumValue(instant); [EOL]     instant = iJulianField.set(instant, max); [EOL]     if (instant >= iCutover) { [EOL]         max = iJulianField.get(iJulianField.add(iCutover, -1)); [EOL]     } [EOL]     return max; [EOL] }
public int getMaximumValue(long instant) { [EOL]     if (instant >= iCutover) { [EOL]         return iGregorianField.getMaximumValue(instant); [EOL]     } [EOL]     int max = iJulianField.getMaximumValue(instant); [EOL]     instant = iJulianField.set(instant, max); [EOL]     if (instant >= iCutover) { [EOL]         max = iJulianField.get(iJulianField.add(iCutover, -1)); [EOL]     } [EOL]     return max; [EOL] }
public int getMaximumValue(long instant) { [EOL]     if (instant >= iCutover) { [EOL]         return iGregorianField.getMaximumValue(instant); [EOL]     } [EOL]     int max = iJulianField.getMaximumValue(instant); [EOL]     instant = iJulianField.set(instant, max); [EOL]     if (instant >= iCutover) { [EOL]         max = iJulianField.get(iJulianField.add(iCutover, -1)); [EOL]     } [EOL]     return max; [EOL] }
public int getMaximumValue(long instant) { [EOL]     if (instant >= iCutover) { [EOL]         return iGregorianField.getMaximumValue(instant); [EOL]     } [EOL]     int max = iJulianField.getMaximumValue(instant); [EOL]     instant = iJulianField.set(instant, max); [EOL]     if (instant >= iCutover) { [EOL]         max = iJulianField.get(iJulianField.add(iCutover, -1)); [EOL]     } [EOL]     return max; [EOL] }
public int getMaximumValue(ReadablePartial partial) { [EOL]     long instant = GJChronology.getInstanceUTC().set(partial, 0L); [EOL]     return getMaximumValue(instant); [EOL] }
public int getMaximumValue(ReadablePartial partial) { [EOL]     long instant = GJChronology.getInstanceUTC().set(partial, 0L); [EOL]     return getMaximumValue(instant); [EOL] }
public long roundFloor(long instant) { [EOL]     if (instant >= iCutover) { [EOL]         instant = iGregorianField.roundFloor(instant); [EOL]         if (instant < iCutover) { [EOL]             if (instant + iGapDuration < iCutover) { [EOL]                 instant = gregorianToJulian(instant); [EOL]             } [EOL]         } [EOL]     } else { [EOL]         instant = iJulianField.roundFloor(instant); [EOL]     } [EOL]     return instant; [EOL] }
public long roundFloor(long instant) { [EOL]     if (instant >= iCutover) { [EOL]         instant = iGregorianField.roundFloor(instant); [EOL]         if (instant < iCutover) { [EOL]             if (instant + iGapDuration < iCutover) { [EOL]                 instant = gregorianToJulian(instant); [EOL]             } [EOL]         } [EOL]     } else { [EOL]         instant = iJulianField.roundFloor(instant); [EOL]     } [EOL]     return instant; [EOL] }
public long roundFloor(long instant) { [EOL]     if (instant >= iCutover) { [EOL]         instant = iGregorianField.roundFloor(instant); [EOL]         if (instant < iCutover) { [EOL]             if (instant + iGapDuration < iCutover) { [EOL]                 instant = gregorianToJulian(instant); [EOL]             } [EOL]         } [EOL]     } else { [EOL]         instant = iJulianField.roundFloor(instant); [EOL]     } [EOL]     return instant; [EOL] }
public long roundFloor(long instant) { [EOL]     if (instant >= iCutover) { [EOL]         instant = iGregorianField.roundFloor(instant); [EOL]         if (instant < iCutover) { [EOL]             if (instant + iGapDuration < iCutover) { [EOL]                 instant = gregorianToJulian(instant); [EOL]             } [EOL]         } [EOL]     } else { [EOL]         instant = iJulianField.roundFloor(instant); [EOL]     } [EOL]     return instant; [EOL] }
public long roundFloor(long instant) { [EOL]     if (instant >= iCutover) { [EOL]         instant = iGregorianField.roundFloor(instant); [EOL]         if (instant < iCutover) { [EOL]             if (instant + iGapDuration < iCutover) { [EOL]                 instant = gregorianToJulian(instant); [EOL]             } [EOL]         } [EOL]     } else { [EOL]         instant = iJulianField.roundFloor(instant); [EOL]     } [EOL]     return instant; [EOL] }
protected long julianToGregorian(long instant) { [EOL]     if (iConvertByWeekyear) { [EOL]         return julianToGregorianByWeekyear(instant); [EOL]     } else { [EOL]         return julianToGregorianByYear(instant); [EOL]     } [EOL] }
protected long julianToGregorian(long instant) { [EOL]     if (iConvertByWeekyear) { [EOL]         return julianToGregorianByWeekyear(instant); [EOL]     } else { [EOL]         return julianToGregorianByYear(instant); [EOL]     } [EOL] }
protected long gregorianToJulian(long instant) { [EOL]     if (iConvertByWeekyear) { [EOL]         return gregorianToJulianByWeekyear(instant); [EOL]     } else { [EOL]         return gregorianToJulianByYear(instant); [EOL]     } [EOL] }
ImpreciseCutoverField(DateTimeField julianField, DateTimeField gregorianField, long cutoverMillis) { [EOL]     this(julianField, gregorianField, null, cutoverMillis, false); [EOL] }
ImpreciseCutoverField(DateTimeField julianField, DateTimeField gregorianField, long cutoverMillis) { [EOL]     this(julianField, gregorianField, null, cutoverMillis, false); [EOL] }
ImpreciseCutoverField(DateTimeField julianField, DateTimeField gregorianField, long cutoverMillis) { [EOL]     this(julianField, gregorianField, null, cutoverMillis, false); [EOL] }
ImpreciseCutoverField(DateTimeField julianField, DateTimeField gregorianField, DurationField durationField, long cutoverMillis) { [EOL]     this(julianField, gregorianField, durationField, cutoverMillis, false); [EOL] }
ImpreciseCutoverField(DateTimeField julianField, DateTimeField gregorianField, DurationField durationField, DurationField rangeDurationField, long cutoverMillis) { [EOL]     this(julianField, gregorianField, durationField, cutoverMillis, false); [EOL]     iRangeDurationField = rangeDurationField; [EOL] }
ImpreciseCutoverField(DateTimeField julianField, DateTimeField gregorianField, DurationField durationField, long cutoverMillis, boolean convertByWeekyear) { [EOL]     super(julianField, gregorianField, cutoverMillis, convertByWeekyear); [EOL]     if (durationField == null) { [EOL]         durationField = new LinkedDurationField(iDurationField, this); [EOL]     } [EOL]     iDurationField = durationField; [EOL] }
ImpreciseCutoverField(DateTimeField julianField, DateTimeField gregorianField, DurationField durationField, long cutoverMillis, boolean convertByWeekyear) { [EOL]     super(julianField, gregorianField, cutoverMillis, convertByWeekyear); [EOL]     if (durationField == null) { [EOL]         durationField = new LinkedDurationField(iDurationField, this); [EOL]     } [EOL]     iDurationField = durationField; [EOL] }
public int getMaximumValue(long instant) { [EOL]     if (instant >= iCutover) { [EOL]         return iGregorianField.getMaximumValue(instant); [EOL]     } else { [EOL]         return iJulianField.getMaximumValue(instant); [EOL]     } [EOL] }
public int getMaximumValue(long instant) { [EOL]     if (instant >= iCutover) { [EOL]         return iGregorianField.getMaximumValue(instant); [EOL]     } else { [EOL]         return iJulianField.getMaximumValue(instant); [EOL]     } [EOL] }
public int getMaximumValue(long instant) { [EOL]     if (instant >= iCutover) { [EOL]         return iGregorianField.getMaximumValue(instant); [EOL]     } else { [EOL]         return iJulianField.getMaximumValue(instant); [EOL]     } [EOL] }
LinkedDurationField(DurationField durationField, ImpreciseCutoverField dateTimeField) { [EOL]     super(durationField, durationField.getType()); [EOL]     iField = dateTimeField; [EOL] }
public long getInstantMillis(Object object, Chronology chrono) { [EOL]     return DateTimeUtils.currentTimeMillis(); [EOL] }
public Chronology getChronology(Object object, DateTimeZone zone) { [EOL]     return ISOChronology.getInstance(zone); [EOL] }
public Chronology getChronology(Object object, DateTimeZone zone) { [EOL]     return ISOChronology.getInstance(zone); [EOL] }
public PeriodType getPeriodType(Object object) { [EOL]     return PeriodType.standard(); [EOL] }
public int[] getPartialValues(ReadablePartial fieldSource, Object object, Chronology chrono, DateTimeFormatter parser) { [EOL]     if (parser.getZone() != null) { [EOL]         chrono = chrono.withZone(parser.getZone()); [EOL]     } [EOL]     long millis = parser.withChronology(chrono).parseMillis((String) object); [EOL]     return chrono.get(fieldSource, millis); [EOL] }
public int[] getPartialValues(ReadablePartial fieldSource, Object object, Chronology chrono, DateTimeFormatter parser) { [EOL]     if (parser.getZone() != null) { [EOL]         chrono = chrono.withZone(parser.getZone()); [EOL]     } [EOL]     long millis = parser.withChronology(chrono).parseMillis((String) object); [EOL]     return chrono.get(fieldSource, millis); [EOL] }
public void setInto(ReadWritableInterval writableInterval, Object object, Chronology chrono) { [EOL]     String str = (String) object; [EOL]     int separator = str.indexOf('/'); [EOL]     if (separator < 0) { [EOL]         throw new IllegalArgumentException("Format requires a '/' separator: " + str); [EOL]     } [EOL]     String leftStr = str.substring(0, separator); [EOL]     if (leftStr.length() <= 0) { [EOL]         throw new IllegalArgumentException("Format invalid: " + str); [EOL]     } [EOL]     String rightStr = str.substring(separator + 1); [EOL]     if (rightStr.length() <= 0) { [EOL]         throw new IllegalArgumentException("Format invalid: " + str); [EOL]     } [EOL]     DateTimeFormatter dateTimeParser = ISODateTimeFormat.dateTimeParser(); [EOL]     dateTimeParser = dateTimeParser.withChronology(chrono); [EOL]     PeriodFormatter periodParser = ISOPeriodFormat.standard(); [EOL]     long startInstant = 0, endInstant = 0; [EOL]     Period period = null; [EOL]     Chronology parsedChrono = null; [EOL]     char c = leftStr.charAt(0); [EOL]     if (c == 'P' || c == 'p') { [EOL]         period = periodParser.withParseType(getPeriodType(leftStr)).parsePeriod(leftStr); [EOL]     } else { [EOL]         DateTime start = dateTimeParser.parseDateTime(leftStr); [EOL]         startInstant = start.getMillis(); [EOL]         parsedChrono = start.getChronology(); [EOL]     } [EOL]     c = rightStr.charAt(0); [EOL]     if (c == 'P' || c == 'p') { [EOL]         if (period != null) { [EOL]             throw new IllegalArgumentException("Interval composed of two durations: " + str); [EOL]         } [EOL]         period = periodParser.withParseType(getPeriodType(rightStr)).parsePeriod(rightStr); [EOL]         chrono = (chrono != null ? chrono : parsedChrono); [EOL]         endInstant = chrono.add(period, startInstant, 1); [EOL]     } else { [EOL]         DateTime end = dateTimeParser.parseDateTime(rightStr); [EOL]         endInstant = end.getMillis(); [EOL]         parsedChrono = (parsedChrono != null ? parsedChrono : end.getChronology()); [EOL]         chrono = (chrono != null ? chrono : parsedChrono); [EOL]         if (period != null) { [EOL]             startInstant = chrono.add(period, endInstant, -1); [EOL]         } [EOL]     } [EOL]     writableInterval.setInterval(startInstant, endInstant); [EOL]     writableInterval.setChronology(chrono); [EOL] }
public void setInto(ReadWritableInterval writableInterval, Object object, Chronology chrono) { [EOL]     String str = (String) object; [EOL]     int separator = str.indexOf('/'); [EOL]     if (separator < 0) { [EOL]         throw new IllegalArgumentException("Format requires a '/' separator: " + str); [EOL]     } [EOL]     String leftStr = str.substring(0, separator); [EOL]     if (leftStr.length() <= 0) { [EOL]         throw new IllegalArgumentException("Format invalid: " + str); [EOL]     } [EOL]     String rightStr = str.substring(separator + 1); [EOL]     if (rightStr.length() <= 0) { [EOL]         throw new IllegalArgumentException("Format invalid: " + str); [EOL]     } [EOL]     DateTimeFormatter dateTimeParser = ISODateTimeFormat.dateTimeParser(); [EOL]     dateTimeParser = dateTimeParser.withChronology(chrono); [EOL]     PeriodFormatter periodParser = ISOPeriodFormat.standard(); [EOL]     long startInstant = 0, endInstant = 0; [EOL]     Period period = null; [EOL]     Chronology parsedChrono = null; [EOL]     char c = leftStr.charAt(0); [EOL]     if (c == 'P' || c == 'p') { [EOL]         period = periodParser.withParseType(getPeriodType(leftStr)).parsePeriod(leftStr); [EOL]     } else { [EOL]         DateTime start = dateTimeParser.parseDateTime(leftStr); [EOL]         startInstant = start.getMillis(); [EOL]         parsedChrono = start.getChronology(); [EOL]     } [EOL]     c = rightStr.charAt(0); [EOL]     if (c == 'P' || c == 'p') { [EOL]         if (period != null) { [EOL]             throw new IllegalArgumentException("Interval composed of two durations: " + str); [EOL]         } [EOL]         period = periodParser.withParseType(getPeriodType(rightStr)).parsePeriod(rightStr); [EOL]         chrono = (chrono != null ? chrono : parsedChrono); [EOL]         endInstant = chrono.add(period, startInstant, 1); [EOL]     } else { [EOL]         DateTime end = dateTimeParser.parseDateTime(rightStr); [EOL]         endInstant = end.getMillis(); [EOL]         parsedChrono = (parsedChrono != null ? parsedChrono : end.getChronology()); [EOL]         chrono = (chrono != null ? chrono : parsedChrono); [EOL]         if (period != null) { [EOL]             startInstant = chrono.add(period, endInstant, -1); [EOL]         } [EOL]     } [EOL]     writableInterval.setInterval(startInstant, endInstant); [EOL]     writableInterval.setChronology(chrono); [EOL] }
public void setInto(ReadWritableInterval writableInterval, Object object, Chronology chrono) { [EOL]     String str = (String) object; [EOL]     int separator = str.indexOf('/'); [EOL]     if (separator < 0) { [EOL]         throw new IllegalArgumentException("Format requires a '/' separator: " + str); [EOL]     } [EOL]     String leftStr = str.substring(0, separator); [EOL]     if (leftStr.length() <= 0) { [EOL]         throw new IllegalArgumentException("Format invalid: " + str); [EOL]     } [EOL]     String rightStr = str.substring(separator + 1); [EOL]     if (rightStr.length() <= 0) { [EOL]         throw new IllegalArgumentException("Format invalid: " + str); [EOL]     } [EOL]     DateTimeFormatter dateTimeParser = ISODateTimeFormat.dateTimeParser(); [EOL]     dateTimeParser = dateTimeParser.withChronology(chrono); [EOL]     PeriodFormatter periodParser = ISOPeriodFormat.standard(); [EOL]     long startInstant = 0, endInstant = 0; [EOL]     Period period = null; [EOL]     Chronology parsedChrono = null; [EOL]     char c = leftStr.charAt(0); [EOL]     if (c == 'P' || c == 'p') { [EOL]         period = periodParser.withParseType(getPeriodType(leftStr)).parsePeriod(leftStr); [EOL]     } else { [EOL]         DateTime start = dateTimeParser.parseDateTime(leftStr); [EOL]         startInstant = start.getMillis(); [EOL]         parsedChrono = start.getChronology(); [EOL]     } [EOL]     c = rightStr.charAt(0); [EOL]     if (c == 'P' || c == 'p') { [EOL]         if (period != null) { [EOL]             throw new IllegalArgumentException("Interval composed of two durations: " + str); [EOL]         } [EOL]         period = periodParser.withParseType(getPeriodType(rightStr)).parsePeriod(rightStr); [EOL]         chrono = (chrono != null ? chrono : parsedChrono); [EOL]         endInstant = chrono.add(period, startInstant, 1); [EOL]     } else { [EOL]         DateTime end = dateTimeParser.parseDateTime(rightStr); [EOL]         endInstant = end.getMillis(); [EOL]         parsedChrono = (parsedChrono != null ? parsedChrono : end.getChronology()); [EOL]         chrono = (chrono != null ? chrono : parsedChrono); [EOL]         if (period != null) { [EOL]             startInstant = chrono.add(period, endInstant, -1); [EOL]         } [EOL]     } [EOL]     writableInterval.setInterval(startInstant, endInstant); [EOL]     writableInterval.setChronology(chrono); [EOL] }
public void setInto(ReadWritableInterval writableInterval, Object object, Chronology chrono) { [EOL]     String str = (String) object; [EOL]     int separator = str.indexOf('/'); [EOL]     if (separator < 0) { [EOL]         throw new IllegalArgumentException("Format requires a '/' separator: " + str); [EOL]     } [EOL]     String leftStr = str.substring(0, separator); [EOL]     if (leftStr.length() <= 0) { [EOL]         throw new IllegalArgumentException("Format invalid: " + str); [EOL]     } [EOL]     String rightStr = str.substring(separator + 1); [EOL]     if (rightStr.length() <= 0) { [EOL]         throw new IllegalArgumentException("Format invalid: " + str); [EOL]     } [EOL]     DateTimeFormatter dateTimeParser = ISODateTimeFormat.dateTimeParser(); [EOL]     dateTimeParser = dateTimeParser.withChronology(chrono); [EOL]     PeriodFormatter periodParser = ISOPeriodFormat.standard(); [EOL]     long startInstant = 0, endInstant = 0; [EOL]     Period period = null; [EOL]     Chronology parsedChrono = null; [EOL]     char c = leftStr.charAt(0); [EOL]     if (c == 'P' || c == 'p') { [EOL]         period = periodParser.withParseType(getPeriodType(leftStr)).parsePeriod(leftStr); [EOL]     } else { [EOL]         DateTime start = dateTimeParser.parseDateTime(leftStr); [EOL]         startInstant = start.getMillis(); [EOL]         parsedChrono = start.getChronology(); [EOL]     } [EOL]     c = rightStr.charAt(0); [EOL]     if (c == 'P' || c == 'p') { [EOL]         if (period != null) { [EOL]             throw new IllegalArgumentException("Interval composed of two durations: " + str); [EOL]         } [EOL]         period = periodParser.withParseType(getPeriodType(rightStr)).parsePeriod(rightStr); [EOL]         chrono = (chrono != null ? chrono : parsedChrono); [EOL]         endInstant = chrono.add(period, startInstant, 1); [EOL]     } else { [EOL]         DateTime end = dateTimeParser.parseDateTime(rightStr); [EOL]         endInstant = end.getMillis(); [EOL]         parsedChrono = (parsedChrono != null ? parsedChrono : end.getChronology()); [EOL]         chrono = (chrono != null ? chrono : parsedChrono); [EOL]         if (period != null) { [EOL]             startInstant = chrono.add(period, endInstant, -1); [EOL]         } [EOL]     } [EOL]     writableInterval.setInterval(startInstant, endInstant); [EOL]     writableInterval.setChronology(chrono); [EOL] }
public void setInto(ReadWritableInterval writableInterval, Object object, Chronology chrono) { [EOL]     String str = (String) object; [EOL]     int separator = str.indexOf('/'); [EOL]     if (separator < 0) { [EOL]         throw new IllegalArgumentException("Format requires a '/' separator: " + str); [EOL]     } [EOL]     String leftStr = str.substring(0, separator); [EOL]     if (leftStr.length() <= 0) { [EOL]         throw new IllegalArgumentException("Format invalid: " + str); [EOL]     } [EOL]     String rightStr = str.substring(separator + 1); [EOL]     if (rightStr.length() <= 0) { [EOL]         throw new IllegalArgumentException("Format invalid: " + str); [EOL]     } [EOL]     DateTimeFormatter dateTimeParser = ISODateTimeFormat.dateTimeParser(); [EOL]     dateTimeParser = dateTimeParser.withChronology(chrono); [EOL]     PeriodFormatter periodParser = ISOPeriodFormat.standard(); [EOL]     long startInstant = 0, endInstant = 0; [EOL]     Period period = null; [EOL]     Chronology parsedChrono = null; [EOL]     char c = leftStr.charAt(0); [EOL]     if (c == 'P' || c == 'p') { [EOL]         period = periodParser.withParseType(getPeriodType(leftStr)).parsePeriod(leftStr); [EOL]     } else { [EOL]         DateTime start = dateTimeParser.parseDateTime(leftStr); [EOL]         startInstant = start.getMillis(); [EOL]         parsedChrono = start.getChronology(); [EOL]     } [EOL]     c = rightStr.charAt(0); [EOL]     if (c == 'P' || c == 'p') { [EOL]         if (period != null) { [EOL]             throw new IllegalArgumentException("Interval composed of two durations: " + str); [EOL]         } [EOL]         period = periodParser.withParseType(getPeriodType(rightStr)).parsePeriod(rightStr); [EOL]         chrono = (chrono != null ? chrono : parsedChrono); [EOL]         endInstant = chrono.add(period, startInstant, 1); [EOL]     } else { [EOL]         DateTime end = dateTimeParser.parseDateTime(rightStr); [EOL]         endInstant = end.getMillis(); [EOL]         parsedChrono = (parsedChrono != null ? parsedChrono : end.getChronology()); [EOL]         chrono = (chrono != null ? chrono : parsedChrono); [EOL]         if (period != null) { [EOL]             startInstant = chrono.add(period, endInstant, -1); [EOL]         } [EOL]     } [EOL]     writableInterval.setInterval(startInstant, endInstant); [EOL]     writableInterval.setChronology(chrono); [EOL] }
public void setInto(ReadWritableInterval writableInterval, Object object, Chronology chrono) { [EOL]     String str = (String) object; [EOL]     int separator = str.indexOf('/'); [EOL]     if (separator < 0) { [EOL]         throw new IllegalArgumentException("Format requires a '/' separator: " + str); [EOL]     } [EOL]     String leftStr = str.substring(0, separator); [EOL]     if (leftStr.length() <= 0) { [EOL]         throw new IllegalArgumentException("Format invalid: " + str); [EOL]     } [EOL]     String rightStr = str.substring(separator + 1); [EOL]     if (rightStr.length() <= 0) { [EOL]         throw new IllegalArgumentException("Format invalid: " + str); [EOL]     } [EOL]     DateTimeFormatter dateTimeParser = ISODateTimeFormat.dateTimeParser(); [EOL]     dateTimeParser = dateTimeParser.withChronology(chrono); [EOL]     PeriodFormatter periodParser = ISOPeriodFormat.standard(); [EOL]     long startInstant = 0, endInstant = 0; [EOL]     Period period = null; [EOL]     Chronology parsedChrono = null; [EOL]     char c = leftStr.charAt(0); [EOL]     if (c == 'P' || c == 'p') { [EOL]         period = periodParser.withParseType(getPeriodType(leftStr)).parsePeriod(leftStr); [EOL]     } else { [EOL]         DateTime start = dateTimeParser.parseDateTime(leftStr); [EOL]         startInstant = start.getMillis(); [EOL]         parsedChrono = start.getChronology(); [EOL]     } [EOL]     c = rightStr.charAt(0); [EOL]     if (c == 'P' || c == 'p') { [EOL]         if (period != null) { [EOL]             throw new IllegalArgumentException("Interval composed of two durations: " + str); [EOL]         } [EOL]         period = periodParser.withParseType(getPeriodType(rightStr)).parsePeriod(rightStr); [EOL]         chrono = (chrono != null ? chrono : parsedChrono); [EOL]         endInstant = chrono.add(period, startInstant, 1); [EOL]     } else { [EOL]         DateTime end = dateTimeParser.parseDateTime(rightStr); [EOL]         endInstant = end.getMillis(); [EOL]         parsedChrono = (parsedChrono != null ? parsedChrono : end.getChronology()); [EOL]         chrono = (chrono != null ? chrono : parsedChrono); [EOL]         if (period != null) { [EOL]             startInstant = chrono.add(period, endInstant, -1); [EOL]         } [EOL]     } [EOL]     writableInterval.setInterval(startInstant, endInstant); [EOL]     writableInterval.setChronology(chrono); [EOL] }
public void setInto(ReadWritableInterval writableInterval, Object object, Chronology chrono) { [EOL]     String str = (String) object; [EOL]     int separator = str.indexOf('/'); [EOL]     if (separator < 0) { [EOL]         throw new IllegalArgumentException("Format requires a '/' separator: " + str); [EOL]     } [EOL]     String leftStr = str.substring(0, separator); [EOL]     if (leftStr.length() <= 0) { [EOL]         throw new IllegalArgumentException("Format invalid: " + str); [EOL]     } [EOL]     String rightStr = str.substring(separator + 1); [EOL]     if (rightStr.length() <= 0) { [EOL]         throw new IllegalArgumentException("Format invalid: " + str); [EOL]     } [EOL]     DateTimeFormatter dateTimeParser = ISODateTimeFormat.dateTimeParser(); [EOL]     dateTimeParser = dateTimeParser.withChronology(chrono); [EOL]     PeriodFormatter periodParser = ISOPeriodFormat.standard(); [EOL]     long startInstant = 0, endInstant = 0; [EOL]     Period period = null; [EOL]     Chronology parsedChrono = null; [EOL]     char c = leftStr.charAt(0); [EOL]     if (c == 'P' || c == 'p') { [EOL]         period = periodParser.withParseType(getPeriodType(leftStr)).parsePeriod(leftStr); [EOL]     } else { [EOL]         DateTime start = dateTimeParser.parseDateTime(leftStr); [EOL]         startInstant = start.getMillis(); [EOL]         parsedChrono = start.getChronology(); [EOL]     } [EOL]     c = rightStr.charAt(0); [EOL]     if (c == 'P' || c == 'p') { [EOL]         if (period != null) { [EOL]             throw new IllegalArgumentException("Interval composed of two durations: " + str); [EOL]         } [EOL]         period = periodParser.withParseType(getPeriodType(rightStr)).parsePeriod(rightStr); [EOL]         chrono = (chrono != null ? chrono : parsedChrono); [EOL]         endInstant = chrono.add(period, startInstant, 1); [EOL]     } else { [EOL]         DateTime end = dateTimeParser.parseDateTime(rightStr); [EOL]         endInstant = end.getMillis(); [EOL]         parsedChrono = (parsedChrono != null ? parsedChrono : end.getChronology()); [EOL]         chrono = (chrono != null ? chrono : parsedChrono); [EOL]         if (period != null) { [EOL]             startInstant = chrono.add(period, endInstant, -1); [EOL]         } [EOL]     } [EOL]     writableInterval.setInterval(startInstant, endInstant); [EOL]     writableInterval.setChronology(chrono); [EOL] }
public void setInto(ReadWritablePeriod duration, Object object, Chronology chrono) { [EOL]     duration.setPeriod((ReadablePeriod) object); [EOL] }
public void setInto(ReadWritablePeriod duration, Object object, Chronology chrono) { [EOL]     duration.setPeriod((ReadablePeriod) object); [EOL] }
public void setInto(ReadWritablePeriod duration, Object object, Chronology chrono) { [EOL]     duration.setPeriod((ReadablePeriod) object); [EOL] }
public SkipUndoDateTimeField(Chronology chronology, DateTimeField field) { [EOL]     this(chronology, field, 0); [EOL] }
public SkipUndoDateTimeField(Chronology chronology, DateTimeField field) { [EOL]     this(chronology, field, 0); [EOL] }
public SkipUndoDateTimeField(Chronology chronology, DateTimeField field, int skip) { [EOL]     super(field); [EOL]     iChronology = chronology; [EOL]     int min = super.getMinimumValue(); [EOL]     if (min < skip) { [EOL]         iMinValue = min + 1; [EOL]     } else if (min == skip + 1) { [EOL]         iMinValue = skip; [EOL]     } else { [EOL]         iMinValue = min; [EOL]     } [EOL]     iSkip = skip; [EOL] }
public SkipUndoDateTimeField(Chronology chronology, DateTimeField field, int skip) { [EOL]     super(field); [EOL]     iChronology = chronology; [EOL]     int min = super.getMinimumValue(); [EOL]     if (min < skip) { [EOL]         iMinValue = min + 1; [EOL]     } else if (min == skip + 1) { [EOL]         iMinValue = skip; [EOL]     } else { [EOL]         iMinValue = min; [EOL]     } [EOL]     iSkip = skip; [EOL] }
public SkipUndoDateTimeField(Chronology chronology, DateTimeField field, int skip) { [EOL]     super(field); [EOL]     iChronology = chronology; [EOL]     int min = super.getMinimumValue(); [EOL]     if (min < skip) { [EOL]         iMinValue = min + 1; [EOL]     } else if (min == skip + 1) { [EOL]         iMinValue = skip; [EOL]     } else { [EOL]         iMinValue = min; [EOL]     } [EOL]     iSkip = skip; [EOL] }
public long set(long millis, int value) { [EOL]     FieldUtils.verifyValueBounds(this, value, iMinValue, getMaximumValue()); [EOL]     if (value <= iSkip) { [EOL]         value--; [EOL]     } [EOL]     return super.set(millis, value); [EOL] }
public long set(long millis, int value) { [EOL]     FieldUtils.verifyValueBounds(this, value, iMinValue, getMaximumValue()); [EOL]     if (value <= iSkip) { [EOL]         value--; [EOL]     } [EOL]     return super.set(millis, value); [EOL] }
public long set(long millis, int value) { [EOL]     FieldUtils.verifyValueBounds(this, value, iMinValue, getMaximumValue()); [EOL]     if (value <= iSkip) { [EOL]         value--; [EOL]     } [EOL]     return super.set(millis, value); [EOL] }
public long set(long millis, int value) { [EOL]     FieldUtils.verifyValueBounds(this, value, iMinValue, getMaximumValue()); [EOL]     if (value <= iSkip) { [EOL]         value--; [EOL]     } [EOL]     return super.set(millis, value); [EOL] }
public long set(long millis, int value) { [EOL]     FieldUtils.verifyValueBounds(this, value, iMinValue, getMaximumValue()); [EOL]     if (value <= iSkip) { [EOL]         value--; [EOL]     } [EOL]     return super.set(millis, value); [EOL] }
public int getMinimumValue() { [EOL]     return iMinValue; [EOL] }
public PeriodFormatterBuilder append(PeriodPrinter printer, PeriodParser parser) { [EOL]     if (printer == null && parser == null) { [EOL]         throw new IllegalArgumentException("No printer or parser supplied"); [EOL]     } [EOL]     clearPrefix(); [EOL]     append0(printer, parser); [EOL]     return this; [EOL] }
public PeriodFormatterBuilder append(PeriodPrinter printer, PeriodParser parser) { [EOL]     if (printer == null && parser == null) { [EOL]         throw new IllegalArgumentException("No printer or parser supplied"); [EOL]     } [EOL]     clearPrefix(); [EOL]     append0(printer, parser); [EOL]     return this; [EOL] }
public PeriodFormatterBuilder append(PeriodPrinter printer, PeriodParser parser) { [EOL]     if (printer == null && parser == null) { [EOL]         throw new IllegalArgumentException("No printer or parser supplied"); [EOL]     } [EOL]     clearPrefix(); [EOL]     append0(printer, parser); [EOL]     return this; [EOL] }
public PeriodFormatterBuilder append(PeriodPrinter printer, PeriodParser parser) { [EOL]     if (printer == null && parser == null) { [EOL]         throw new IllegalArgumentException("No printer or parser supplied"); [EOL]     } [EOL]     clearPrefix(); [EOL]     append0(printer, parser); [EOL]     return this; [EOL] }
public PeriodFormatterBuilder printZeroRarelyLast() { [EOL]     iPrintZeroSetting = PRINT_ZERO_RARELY_LAST; [EOL]     return this; [EOL] }
public PeriodFormatterBuilder appendSeconds() { [EOL]     appendField(SECONDS); [EOL]     return this; [EOL] }
private PeriodFormatterBuilder appendSuffix(PeriodFieldAffix suffix) { [EOL]     final Object originalPrinter; [EOL]     final Object originalParser; [EOL]     if (iElementPairs.size() > 0) { [EOL]         originalPrinter = iElementPairs.get(iElementPairs.size() - 2); [EOL]         originalParser = iElementPairs.get(iElementPairs.size() - 1); [EOL]     } else { [EOL]         originalPrinter = null; [EOL]         originalParser = null; [EOL]     } [EOL]     if (originalPrinter == null || originalParser == null || originalPrinter != originalParser || !(originalPrinter instanceof FieldFormatter)) { [EOL]         throw new IllegalStateException("No field to apply suffix to"); [EOL]     } [EOL]     clearPrefix(); [EOL]     FieldFormatter newField = new FieldFormatter((FieldFormatter) originalPrinter, suffix); [EOL]     iElementPairs.set(iElementPairs.size() - 2, newField); [EOL]     iElementPairs.set(iElementPairs.size() - 1, newField); [EOL]     iFieldFormatters[newField.getFieldType()] = newField; [EOL]     return this; [EOL] }
private PeriodFormatterBuilder appendSuffix(PeriodFieldAffix suffix) { [EOL]     final Object originalPrinter; [EOL]     final Object originalParser; [EOL]     if (iElementPairs.size() > 0) { [EOL]         originalPrinter = iElementPairs.get(iElementPairs.size() - 2); [EOL]         originalParser = iElementPairs.get(iElementPairs.size() - 1); [EOL]     } else { [EOL]         originalPrinter = null; [EOL]         originalParser = null; [EOL]     } [EOL]     if (originalPrinter == null || originalParser == null || originalPrinter != originalParser || !(originalPrinter instanceof FieldFormatter)) { [EOL]         throw new IllegalStateException("No field to apply suffix to"); [EOL]     } [EOL]     clearPrefix(); [EOL]     FieldFormatter newField = new FieldFormatter((FieldFormatter) originalPrinter, suffix); [EOL]     iElementPairs.set(iElementPairs.size() - 2, newField); [EOL]     iElementPairs.set(iElementPairs.size() - 1, newField); [EOL]     iFieldFormatters[newField.getFieldType()] = newField; [EOL]     return this; [EOL] }
private PeriodFormatterBuilder appendSuffix(PeriodFieldAffix suffix) { [EOL]     final Object originalPrinter; [EOL]     final Object originalParser; [EOL]     if (iElementPairs.size() > 0) { [EOL]         originalPrinter = iElementPairs.get(iElementPairs.size() - 2); [EOL]         originalParser = iElementPairs.get(iElementPairs.size() - 1); [EOL]     } else { [EOL]         originalPrinter = null; [EOL]         originalParser = null; [EOL]     } [EOL]     if (originalPrinter == null || originalParser == null || originalPrinter != originalParser || !(originalPrinter instanceof FieldFormatter)) { [EOL]         throw new IllegalStateException("No field to apply suffix to"); [EOL]     } [EOL]     clearPrefix(); [EOL]     FieldFormatter newField = new FieldFormatter((FieldFormatter) originalPrinter, suffix); [EOL]     iElementPairs.set(iElementPairs.size() - 2, newField); [EOL]     iElementPairs.set(iElementPairs.size() - 1, newField); [EOL]     iFieldFormatters[newField.getFieldType()] = newField; [EOL]     return this; [EOL] }
public PeriodFormatterBuilder appendSeparatorIfFieldsAfter(String text) { [EOL]     return appendSeparator(text, text, null, false, true); [EOL] }
public PeriodFormatterBuilder appendSeparator(String text, String finalText) { [EOL]     return appendSeparator(text, finalText, null, true, true); [EOL] }
private PeriodFormatterBuilder appendSeparator(String text, String finalText, String[] variants, boolean useBefore, boolean useAfter) { [EOL]     if (text == null || finalText == null) { [EOL]         throw new IllegalArgumentException(); [EOL]     } [EOL]     clearPrefix(); [EOL]     List<Object> pairs = iElementPairs; [EOL]     if (pairs.size() == 0) { [EOL]         if (useAfter && useBefore == false) { [EOL]             Separator separator = new Separator(text, finalText, variants, Literal.EMPTY, Literal.EMPTY, useBefore, useAfter); [EOL]             append0(separator, separator); [EOL]         } [EOL]         return this; [EOL]     } [EOL]     int i; [EOL]     Separator lastSeparator = null; [EOL]     for (i = pairs.size(); --i >= 0; ) { [EOL]         if (pairs.get(i) instanceof Separator) { [EOL]             lastSeparator = (Separator) pairs.get(i); [EOL]             pairs = pairs.subList(i + 1, pairs.size()); [EOL]             break; [EOL]         } [EOL]         i--; [EOL]     } [EOL]     if (lastSeparator != null && pairs.size() == 0) { [EOL]         throw new IllegalStateException("Cannot have two adjacent separators"); [EOL]     } else { [EOL]         Object[] comp = createComposite(pairs); [EOL]         pairs.clear(); [EOL]         Separator separator = new Separator(text, finalText, variants, (PeriodPrinter) comp[0], (PeriodParser) comp[1], useBefore, useAfter); [EOL]         pairs.add(separator); [EOL]         pairs.add(separator); [EOL]     } [EOL]     return this; [EOL] }
private static PeriodFormatter toFormatter(List<Object> elementPairs, boolean notPrinter, boolean notParser) { [EOL]     if (notPrinter && notParser) { [EOL]         throw new IllegalStateException("Builder has created neither a printer nor a parser"); [EOL]     } [EOL]     int size = elementPairs.size(); [EOL]     if (size >= 2 && elementPairs.get(0) instanceof Separator) { [EOL]         Separator sep = (Separator) elementPairs.get(0); [EOL]         if (sep.iAfterParser == null && sep.iAfterPrinter == null) { [EOL]             PeriodFormatter f = toFormatter(elementPairs.subList(2, size), notPrinter, notParser); [EOL]             sep = sep.finish(f.getPrinter(), f.getParser()); [EOL]             return new PeriodFormatter(sep, sep); [EOL]         } [EOL]     } [EOL]     Object[] comp = createComposite(elementPairs); [EOL]     if (notPrinter) { [EOL]         return new PeriodFormatter(null, (PeriodParser) comp[1]); [EOL]     } else if (notParser) { [EOL]         return new PeriodFormatter((PeriodPrinter) comp[0], null); [EOL]     } else { [EOL]         return new PeriodFormatter((PeriodPrinter) comp[0], (PeriodParser) comp[1]); [EOL]     } [EOL] }
private static PeriodFormatter toFormatter(List<Object> elementPairs, boolean notPrinter, boolean notParser) { [EOL]     if (notPrinter && notParser) { [EOL]         throw new IllegalStateException("Builder has created neither a printer nor a parser"); [EOL]     } [EOL]     int size = elementPairs.size(); [EOL]     if (size >= 2 && elementPairs.get(0) instanceof Separator) { [EOL]         Separator sep = (Separator) elementPairs.get(0); [EOL]         if (sep.iAfterParser == null && sep.iAfterPrinter == null) { [EOL]             PeriodFormatter f = toFormatter(elementPairs.subList(2, size), notPrinter, notParser); [EOL]             sep = sep.finish(f.getPrinter(), f.getParser()); [EOL]             return new PeriodFormatter(sep, sep); [EOL]         } [EOL]     } [EOL]     Object[] comp = createComposite(elementPairs); [EOL]     if (notPrinter) { [EOL]         return new PeriodFormatter(null, (PeriodParser) comp[1]); [EOL]     } else if (notParser) { [EOL]         return new PeriodFormatter((PeriodPrinter) comp[0], null); [EOL]     } else { [EOL]         return new PeriodFormatter((PeriodPrinter) comp[0], (PeriodParser) comp[1]); [EOL]     } [EOL] }
private static PeriodFormatter toFormatter(List<Object> elementPairs, boolean notPrinter, boolean notParser) { [EOL]     if (notPrinter && notParser) { [EOL]         throw new IllegalStateException("Builder has created neither a printer nor a parser"); [EOL]     } [EOL]     int size = elementPairs.size(); [EOL]     if (size >= 2 && elementPairs.get(0) instanceof Separator) { [EOL]         Separator sep = (Separator) elementPairs.get(0); [EOL]         if (sep.iAfterParser == null && sep.iAfterPrinter == null) { [EOL]             PeriodFormatter f = toFormatter(elementPairs.subList(2, size), notPrinter, notParser); [EOL]             sep = sep.finish(f.getPrinter(), f.getParser()); [EOL]             return new PeriodFormatter(sep, sep); [EOL]         } [EOL]     } [EOL]     Object[] comp = createComposite(elementPairs); [EOL]     if (notPrinter) { [EOL]         return new PeriodFormatter(null, (PeriodParser) comp[1]); [EOL]     } else if (notParser) { [EOL]         return new PeriodFormatter((PeriodPrinter) comp[0], null); [EOL]     } else { [EOL]         return new PeriodFormatter((PeriodPrinter) comp[0], (PeriodParser) comp[1]); [EOL]     } [EOL] }
private static PeriodFormatter toFormatter(List<Object> elementPairs, boolean notPrinter, boolean notParser) { [EOL]     if (notPrinter && notParser) { [EOL]         throw new IllegalStateException("Builder has created neither a printer nor a parser"); [EOL]     } [EOL]     int size = elementPairs.size(); [EOL]     if (size >= 2 && elementPairs.get(0) instanceof Separator) { [EOL]         Separator sep = (Separator) elementPairs.get(0); [EOL]         if (sep.iAfterParser == null && sep.iAfterPrinter == null) { [EOL]             PeriodFormatter f = toFormatter(elementPairs.subList(2, size), notPrinter, notParser); [EOL]             sep = sep.finish(f.getPrinter(), f.getParser()); [EOL]             return new PeriodFormatter(sep, sep); [EOL]         } [EOL]     } [EOL]     Object[] comp = createComposite(elementPairs); [EOL]     if (notPrinter) { [EOL]         return new PeriodFormatter(null, (PeriodParser) comp[1]); [EOL]     } else if (notParser) { [EOL]         return new PeriodFormatter((PeriodPrinter) comp[0], null); [EOL]     } else { [EOL]         return new PeriodFormatter((PeriodPrinter) comp[0], (PeriodParser) comp[1]); [EOL]     } [EOL] }
private static PeriodFormatter toFormatter(List<Object> elementPairs, boolean notPrinter, boolean notParser) { [EOL]     if (notPrinter && notParser) { [EOL]         throw new IllegalStateException("Builder has created neither a printer nor a parser"); [EOL]     } [EOL]     int size = elementPairs.size(); [EOL]     if (size >= 2 && elementPairs.get(0) instanceof Separator) { [EOL]         Separator sep = (Separator) elementPairs.get(0); [EOL]         if (sep.iAfterParser == null && sep.iAfterPrinter == null) { [EOL]             PeriodFormatter f = toFormatter(elementPairs.subList(2, size), notPrinter, notParser); [EOL]             sep = sep.finish(f.getPrinter(), f.getParser()); [EOL]             return new PeriodFormatter(sep, sep); [EOL]         } [EOL]     } [EOL]     Object[] comp = createComposite(elementPairs); [EOL]     if (notPrinter) { [EOL]         return new PeriodFormatter(null, (PeriodParser) comp[1]); [EOL]     } else if (notParser) { [EOL]         return new PeriodFormatter((PeriodPrinter) comp[0], null); [EOL]     } else { [EOL]         return new PeriodFormatter((PeriodPrinter) comp[0], (PeriodParser) comp[1]); [EOL]     } [EOL] }
private static Object[] createComposite(List<Object> elementPairs) { [EOL]     switch(elementPairs.size()) { [EOL]         case 0: [EOL]             return new Object[] { Literal.EMPTY, Literal.EMPTY }; [EOL]         case 1: [EOL]             return new Object[] { elementPairs.get(0), elementPairs.get(1) }; [EOL]         default: [EOL]             Composite comp = new Composite(elementPairs); [EOL]             return new Object[] { comp, comp }; [EOL]     } [EOL] }
private static Object[] createComposite(List<Object> elementPairs) { [EOL]     switch(elementPairs.size()) { [EOL]         case 0: [EOL]             return new Object[] { Literal.EMPTY, Literal.EMPTY }; [EOL]         case 1: [EOL]             return new Object[] { elementPairs.get(0), elementPairs.get(1) }; [EOL]         default: [EOL]             Composite comp = new Composite(elementPairs); [EOL]             return new Object[] { comp, comp }; [EOL]     } [EOL] }
private static Object[] createComposite(List<Object> elementPairs) { [EOL]     switch(elementPairs.size()) { [EOL]         case 0: [EOL]             return new Object[] { Literal.EMPTY, Literal.EMPTY }; [EOL]         case 1: [EOL]             return new Object[] { elementPairs.get(0), elementPairs.get(1) }; [EOL]         default: [EOL]             Composite comp = new Composite(elementPairs); [EOL]             return new Object[] { comp, comp }; [EOL]     } [EOL] }
public int countFieldsToPrint(ReadablePeriod period, int stopAt, Locale locale) { [EOL]     if (stopAt <= 0) { [EOL]         return 0; [EOL]     } [EOL]     if (iPrintZeroSetting == PRINT_ZERO_ALWAYS || getFieldValue(period) != Long.MAX_VALUE) { [EOL]         return 1; [EOL]     } [EOL]     return 0; [EOL] }
public int countFieldsToPrint(ReadablePeriod period, int stopAt, Locale locale) { [EOL]     if (stopAt <= 0) { [EOL]         return 0; [EOL]     } [EOL]     if (iPrintZeroSetting == PRINT_ZERO_ALWAYS || getFieldValue(period) != Long.MAX_VALUE) { [EOL]         return 1; [EOL]     } [EOL]     return 0; [EOL] }
public int countFieldsToPrint(ReadablePeriod period, int stopAt, Locale locale) { [EOL]     if (stopAt <= 0) { [EOL]         return 0; [EOL]     } [EOL]     if (iPrintZeroSetting == PRINT_ZERO_ALWAYS || getFieldValue(period) != Long.MAX_VALUE) { [EOL]         return 1; [EOL]     } [EOL]     return 0; [EOL] }
public int calculatePrintedLength(ReadablePeriod period, Locale locale) { [EOL]     long valueLong = getFieldValue(period); [EOL]     if (valueLong == Long.MAX_VALUE) { [EOL]         return 0; [EOL]     } [EOL]     int sum = Math.max(FormatUtils.calculateDigitCount(valueLong), iMinPrintedDigits); [EOL]     if (iFieldType >= SECONDS_MILLIS) { [EOL]         sum = (valueLong < 0 ? Math.max(sum, 5) : Math.max(sum, 4)); [EOL]         sum++; [EOL]         if (iFieldType == SECONDS_OPTIONAL_MILLIS && (Math.abs(valueLong) % DateTimeConstants.MILLIS_PER_SECOND) == 0) { [EOL]             sum -= 4; [EOL]         } [EOL]         valueLong = valueLong / DateTimeConstants.MILLIS_PER_SECOND; [EOL]     } [EOL]     int value = (int) valueLong; [EOL]     if (iPrefix != null) { [EOL]         sum += iPrefix.calculatePrintedLength(value); [EOL]     } [EOL]     if (iSuffix != null) { [EOL]         sum += iSuffix.calculatePrintedLength(value); [EOL]     } [EOL]     return sum; [EOL] }
public int calculatePrintedLength(ReadablePeriod period, Locale locale) { [EOL]     long valueLong = getFieldValue(period); [EOL]     if (valueLong == Long.MAX_VALUE) { [EOL]         return 0; [EOL]     } [EOL]     int sum = Math.max(FormatUtils.calculateDigitCount(valueLong), iMinPrintedDigits); [EOL]     if (iFieldType >= SECONDS_MILLIS) { [EOL]         sum = (valueLong < 0 ? Math.max(sum, 5) : Math.max(sum, 4)); [EOL]         sum++; [EOL]         if (iFieldType == SECONDS_OPTIONAL_MILLIS && (Math.abs(valueLong) % DateTimeConstants.MILLIS_PER_SECOND) == 0) { [EOL]             sum -= 4; [EOL]         } [EOL]         valueLong = valueLong / DateTimeConstants.MILLIS_PER_SECOND; [EOL]     } [EOL]     int value = (int) valueLong; [EOL]     if (iPrefix != null) { [EOL]         sum += iPrefix.calculatePrintedLength(value); [EOL]     } [EOL]     if (iSuffix != null) { [EOL]         sum += iSuffix.calculatePrintedLength(value); [EOL]     } [EOL]     return sum; [EOL] }
public void printTo(StringBuffer buf, ReadablePeriod period, Locale locale) { [EOL]     long valueLong = getFieldValue(period); [EOL]     if (valueLong == Long.MAX_VALUE) { [EOL]         return; [EOL]     } [EOL]     int value = (int) valueLong; [EOL]     if (iFieldType >= SECONDS_MILLIS) { [EOL]         value = (int) (valueLong / DateTimeConstants.MILLIS_PER_SECOND); [EOL]     } [EOL]     if (iPrefix != null) { [EOL]         iPrefix.printTo(buf, value); [EOL]     } [EOL]     int bufLen = buf.length(); [EOL]     int minDigits = iMinPrintedDigits; [EOL]     if (minDigits <= 1) { [EOL]         FormatUtils.appendUnpaddedInteger(buf, value); [EOL]     } else { [EOL]         FormatUtils.appendPaddedInteger(buf, value, minDigits); [EOL]     } [EOL]     if (iFieldType >= SECONDS_MILLIS) { [EOL]         int dp = (int) (Math.abs(valueLong) % DateTimeConstants.MILLIS_PER_SECOND); [EOL]         if (iFieldType == SECONDS_MILLIS || dp > 0) { [EOL]             if (valueLong < 0 && valueLong > -DateTimeConstants.MILLIS_PER_SECOND) { [EOL]                 buf.insert(bufLen, '-'); [EOL]             } [EOL]             buf.append('.'); [EOL]             FormatUtils.appendPaddedInteger(buf, dp, 3); [EOL]         } [EOL]     } [EOL]     if (iSuffix != null) { [EOL]         iSuffix.printTo(buf, value); [EOL]     } [EOL] }
public int parseInto(ReadWritablePeriod period, String text, int position, Locale locale) { [EOL]     boolean mustParse = (iPrintZeroSetting == PRINT_ZERO_ALWAYS); [EOL]     if (position >= text.length()) { [EOL]         return mustParse ? ~position : position; [EOL]     } [EOL]     if (iPrefix != null) { [EOL]         position = iPrefix.parse(text, position); [EOL]         if (position >= 0) { [EOL]             mustParse = true; [EOL]         } else { [EOL]             if (!mustParse) { [EOL]                 return ~position; [EOL]             } [EOL]             return position; [EOL]         } [EOL]     } [EOL]     int suffixPos = -1; [EOL]     if (iSuffix != null && !mustParse) { [EOL]         suffixPos = iSuffix.scan(text, position); [EOL]         if (suffixPos >= 0) { [EOL]             mustParse = true; [EOL]         } else { [EOL]             if (!mustParse) { [EOL]                 return ~suffixPos; [EOL]             } [EOL]             return suffixPos; [EOL]         } [EOL]     } [EOL]     if (!mustParse && !isSupported(period.getPeriodType(), iFieldType)) { [EOL]         return position; [EOL]     } [EOL]     int limit; [EOL]     if (suffixPos > 0) { [EOL]         limit = Math.min(iMaxParsedDigits, suffixPos - position); [EOL]     } else { [EOL]         limit = Math.min(iMaxParsedDigits, text.length() - position); [EOL]     } [EOL]     int length = 0; [EOL]     int fractPos = -1; [EOL]     boolean hasDigits = false; [EOL]     while (length < limit) { [EOL]         char c = text.charAt(position + length); [EOL]         if (length == 0 && (c == '-' || c == '+') && !iRejectSignedValues) { [EOL]             boolean negative = c == '-'; [EOL]             if (length + 1 >= limit || (c = text.charAt(position + length + 1)) < '0' || c > '9') { [EOL]                 break; [EOL]             } [EOL]             if (negative) { [EOL]                 length++; [EOL]             } else { [EOL]                 position++; [EOL]             } [EOL]             limit = Math.min(limit + 1, text.length() - position); [EOL]             continue; [EOL]         } [EOL]         if (c >= '0' && c <= '9') { [EOL]             hasDigits = true; [EOL]         } else { [EOL]             if ((c == '.' || c == ',') && (iFieldType == SECONDS_MILLIS || iFieldType == SECONDS_OPTIONAL_MILLIS)) { [EOL]                 if (fractPos >= 0) { [EOL]                     break; [EOL]                 } [EOL]                 fractPos = position + length + 1; [EOL]                 limit = Math.min(limit + 1, text.length() - position); [EOL]             } else { [EOL]                 break; [EOL]             } [EOL]         } [EOL]         length++; [EOL]     } [EOL]     if (!hasDigits) { [EOL]         return ~position; [EOL]     } [EOL]     if (suffixPos >= 0 && position + length != suffixPos) { [EOL]         return position; [EOL]     } [EOL]     if (iFieldType != SECONDS_MILLIS && iFieldType != SECONDS_OPTIONAL_MILLIS) { [EOL]         setFieldValue(period, iFieldType, parseInt(text, position, length)); [EOL]     } else if (fractPos < 0) { [EOL]         setFieldValue(period, SECONDS, parseInt(text, position, length)); [EOL]         setFieldValue(period, MILLIS, 0); [EOL]     } else { [EOL]         int wholeValue = parseInt(text, position, fractPos - position - 1); [EOL]         setFieldValue(period, SECONDS, wholeValue); [EOL]         int fractLen = position + length - fractPos; [EOL]         int fractValue; [EOL]         if (fractLen <= 0) { [EOL]             fractValue = 0; [EOL]         } else { [EOL]             if (fractLen >= 3) { [EOL]                 fractValue = parseInt(text, fractPos, 3); [EOL]             } else { [EOL]                 fractValue = parseInt(text, fractPos, fractLen); [EOL]                 if (fractLen == 1) { [EOL]                     fractValue *= 100; [EOL]                 } else { [EOL]                     fractValue *= 10; [EOL]                 } [EOL]             } [EOL]             if (wholeValue < 0) { [EOL]                 fractValue = -fractValue; [EOL]             } [EOL]         } [EOL]         setFieldValue(period, MILLIS, fractValue); [EOL]     } [EOL]     position += length; [EOL]     if (position >= 0 && iSuffix != null) { [EOL]         position = iSuffix.parse(text, position); [EOL]     } [EOL]     return position; [EOL] }
private int parseInt(String text, int position, int length) { [EOL]     if (length >= 10) { [EOL]         return Integer.parseInt(text.substring(position, position + length)); [EOL]     } [EOL]     if (length <= 0) { [EOL]         return 0; [EOL]     } [EOL]     int value = text.charAt(position++); [EOL]     length--; [EOL]     boolean negative; [EOL]     if (value == '-') { [EOL]         if (--length < 0) { [EOL]             return 0; [EOL]         } [EOL]         negative = true; [EOL]         value = text.charAt(position++); [EOL]     } else { [EOL]         negative = false; [EOL]     } [EOL]     value -= '0'; [EOL]     while (length-- > 0) { [EOL]         value = ((value << 3) + (value << 1)) + text.charAt(position++) - '0'; [EOL]     } [EOL]     return negative ? -value : value; [EOL] }
private int parseInt(String text, int position, int length) { [EOL]     if (length >= 10) { [EOL]         return Integer.parseInt(text.substring(position, position + length)); [EOL]     } [EOL]     if (length <= 0) { [EOL]         return 0; [EOL]     } [EOL]     int value = text.charAt(position++); [EOL]     length--; [EOL]     boolean negative; [EOL]     if (value == '-') { [EOL]         if (--length < 0) { [EOL]             return 0; [EOL]         } [EOL]         negative = true; [EOL]         value = text.charAt(position++); [EOL]     } else { [EOL]         negative = false; [EOL]     } [EOL]     value -= '0'; [EOL]     while (length-- > 0) { [EOL]         value = ((value << 3) + (value << 1)) + text.charAt(position++) - '0'; [EOL]     } [EOL]     return negative ? -value : value; [EOL] }
private int parseInt(String text, int position, int length) { [EOL]     if (length >= 10) { [EOL]         return Integer.parseInt(text.substring(position, position + length)); [EOL]     } [EOL]     if (length <= 0) { [EOL]         return 0; [EOL]     } [EOL]     int value = text.charAt(position++); [EOL]     length--; [EOL]     boolean negative; [EOL]     if (value == '-') { [EOL]         if (--length < 0) { [EOL]             return 0; [EOL]         } [EOL]         negative = true; [EOL]         value = text.charAt(position++); [EOL]     } else { [EOL]         negative = false; [EOL]     } [EOL]     value -= '0'; [EOL]     while (length-- > 0) { [EOL]         value = ((value << 3) + (value << 1)) + text.charAt(position++) - '0'; [EOL]     } [EOL]     return negative ? -value : value; [EOL] }
private int parseInt(String text, int position, int length) { [EOL]     if (length >= 10) { [EOL]         return Integer.parseInt(text.substring(position, position + length)); [EOL]     } [EOL]     if (length <= 0) { [EOL]         return 0; [EOL]     } [EOL]     int value = text.charAt(position++); [EOL]     length--; [EOL]     boolean negative; [EOL]     if (value == '-') { [EOL]         if (--length < 0) { [EOL]             return 0; [EOL]         } [EOL]         negative = true; [EOL]         value = text.charAt(position++); [EOL]     } else { [EOL]         negative = false; [EOL]     } [EOL]     value -= '0'; [EOL]     while (length-- > 0) { [EOL]         value = ((value << 3) + (value << 1)) + text.charAt(position++) - '0'; [EOL]     } [EOL]     return negative ? -value : value; [EOL] }
private int parseInt(String text, int position, int length) { [EOL]     if (length >= 10) { [EOL]         return Integer.parseInt(text.substring(position, position + length)); [EOL]     } [EOL]     if (length <= 0) { [EOL]         return 0; [EOL]     } [EOL]     int value = text.charAt(position++); [EOL]     length--; [EOL]     boolean negative; [EOL]     if (value == '-') { [EOL]         if (--length < 0) { [EOL]             return 0; [EOL]         } [EOL]         negative = true; [EOL]         value = text.charAt(position++); [EOL]     } else { [EOL]         negative = false; [EOL]     } [EOL]     value -= '0'; [EOL]     while (length-- > 0) { [EOL]         value = ((value << 3) + (value << 1)) + text.charAt(position++) - '0'; [EOL]     } [EOL]     return negative ? -value : value; [EOL] }
private int parseInt(String text, int position, int length) { [EOL]     if (length >= 10) { [EOL]         return Integer.parseInt(text.substring(position, position + length)); [EOL]     } [EOL]     if (length <= 0) { [EOL]         return 0; [EOL]     } [EOL]     int value = text.charAt(position++); [EOL]     length--; [EOL]     boolean negative; [EOL]     if (value == '-') { [EOL]         if (--length < 0) { [EOL]             return 0; [EOL]         } [EOL]         negative = true; [EOL]         value = text.charAt(position++); [EOL]     } else { [EOL]         negative = false; [EOL]     } [EOL]     value -= '0'; [EOL]     while (length-- > 0) { [EOL]         value = ((value << 3) + (value << 1)) + text.charAt(position++) - '0'; [EOL]     } [EOL]     return negative ? -value : value; [EOL] }
long getFieldValue(ReadablePeriod period) { [EOL]     PeriodType type; [EOL]     if (iPrintZeroSetting == PRINT_ZERO_ALWAYS) { [EOL]         type = null; [EOL]     } else { [EOL]         type = period.getPeriodType(); [EOL]     } [EOL]     if (type != null && isSupported(type, iFieldType) == false) { [EOL]         return Long.MAX_VALUE; [EOL]     } [EOL]     long value; [EOL]     switch(iFieldType) { [EOL]         default: [EOL]             return Long.MAX_VALUE; [EOL]         case YEARS: [EOL]             value = period.get(DurationFieldType.years()); [EOL]             break; [EOL]         case MONTHS: [EOL]             value = period.get(DurationFieldType.months()); [EOL]             break; [EOL]         case WEEKS: [EOL]             value = period.get(DurationFieldType.weeks()); [EOL]             break; [EOL]         case DAYS: [EOL]             value = period.get(DurationFieldType.days()); [EOL]             break; [EOL]         case HOURS: [EOL]             value = period.get(DurationFieldType.hours()); [EOL]             break; [EOL]         case MINUTES: [EOL]             value = period.get(DurationFieldType.minutes()); [EOL]             break; [EOL]         case SECONDS: [EOL]             value = period.get(DurationFieldType.seconds()); [EOL]             break; [EOL]         case MILLIS: [EOL]             value = period.get(DurationFieldType.millis()); [EOL]             break; [EOL]         case SECONDS_MILLIS: [EOL]         case SECONDS_OPTIONAL_MILLIS: [EOL]             int seconds = period.get(DurationFieldType.seconds()); [EOL]             int millis = period.get(DurationFieldType.millis()); [EOL]             value = (seconds * (long) DateTimeConstants.MILLIS_PER_SECOND) + millis; [EOL]             break; [EOL]     } [EOL]     if (value == 0) { [EOL]         switch(iPrintZeroSetting) { [EOL]             case PRINT_ZERO_NEVER: [EOL]                 return Long.MAX_VALUE; [EOL]             case PRINT_ZERO_RARELY_LAST: [EOL]                 if (isZero(period) && iFieldFormatters[iFieldType] == this) { [EOL]                     for (int i = iFieldType + 1; i <= MAX_FIELD; i++) { [EOL]                         if (isSupported(type, i) && iFieldFormatters[i] != null) { [EOL]                             return Long.MAX_VALUE; [EOL]                         } [EOL]                     } [EOL]                 } else { [EOL]                     return Long.MAX_VALUE; [EOL]                 } [EOL]                 break; [EOL]             case PRINT_ZERO_RARELY_FIRST: [EOL]                 if (isZero(period) && iFieldFormatters[iFieldType] == this) { [EOL]                     int i = Math.min(iFieldType, 8); [EOL]                     i--; [EOL]                     for (; i >= 0 && i <= MAX_FIELD; i--) { [EOL]                         if (isSupported(type, i) && iFieldFormatters[i] != null) { [EOL]                             return Long.MAX_VALUE; [EOL]                         } [EOL]                     } [EOL]                 } else { [EOL]                     return Long.MAX_VALUE; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]     } [EOL]     return value; [EOL] }
boolean isZero(ReadablePeriod period) { [EOL]     for (int i = 0, isize = period.size(); i < isize; i++) { [EOL]         if (period.getValue(i) != 0) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
boolean isZero(ReadablePeriod period) { [EOL]     for (int i = 0, isize = period.size(); i < isize; i++) { [EOL]         if (period.getValue(i) != 0) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
boolean isZero(ReadablePeriod period) { [EOL]     for (int i = 0, isize = period.size(); i < isize; i++) { [EOL]         if (period.getValue(i) != 0) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
void setFieldValue(ReadWritablePeriod period, int field, int value) { [EOL]     switch(field) { [EOL]         default: [EOL]             break; [EOL]         case YEARS: [EOL]             period.setYears(value); [EOL]             break; [EOL]         case MONTHS: [EOL]             period.setMonths(value); [EOL]             break; [EOL]         case WEEKS: [EOL]             period.setWeeks(value); [EOL]             break; [EOL]         case DAYS: [EOL]             period.setDays(value); [EOL]             break; [EOL]         case HOURS: [EOL]             period.setHours(value); [EOL]             break; [EOL]         case MINUTES: [EOL]             period.setMinutes(value); [EOL]             break; [EOL]         case SECONDS: [EOL]             period.setSeconds(value); [EOL]             break; [EOL]         case MILLIS: [EOL]             period.setMillis(value); [EOL]             break; [EOL]     } [EOL] }
void setFieldValue(ReadWritablePeriod period, int field, int value) { [EOL]     switch(field) { [EOL]         default: [EOL]             break; [EOL]         case YEARS: [EOL]             period.setYears(value); [EOL]             break; [EOL]         case MONTHS: [EOL]             period.setMonths(value); [EOL]             break; [EOL]         case WEEKS: [EOL]             period.setWeeks(value); [EOL]             break; [EOL]         case DAYS: [EOL]             period.setDays(value); [EOL]             break; [EOL]         case HOURS: [EOL]             period.setHours(value); [EOL]             break; [EOL]         case MINUTES: [EOL]             period.setMinutes(value); [EOL]             break; [EOL]         case SECONDS: [EOL]             period.setSeconds(value); [EOL]             break; [EOL]         case MILLIS: [EOL]             period.setMillis(value); [EOL]             break; [EOL]     } [EOL] }
void setFieldValue(ReadWritablePeriod period, int field, int value) { [EOL]     switch(field) { [EOL]         default: [EOL]             break; [EOL]         case YEARS: [EOL]             period.setYears(value); [EOL]             break; [EOL]         case MONTHS: [EOL]             period.setMonths(value); [EOL]             break; [EOL]         case WEEKS: [EOL]             period.setWeeks(value); [EOL]             break; [EOL]         case DAYS: [EOL]             period.setDays(value); [EOL]             break; [EOL]         case HOURS: [EOL]             period.setHours(value); [EOL]             break; [EOL]         case MINUTES: [EOL]             period.setMinutes(value); [EOL]             break; [EOL]         case SECONDS: [EOL]             period.setSeconds(value); [EOL]             break; [EOL]         case MILLIS: [EOL]             period.setMillis(value); [EOL]             break; [EOL]     } [EOL] }
void setFieldValue(ReadWritablePeriod period, int field, int value) { [EOL]     switch(field) { [EOL]         default: [EOL]             break; [EOL]         case YEARS: [EOL]             period.setYears(value); [EOL]             break; [EOL]         case MONTHS: [EOL]             period.setMonths(value); [EOL]             break; [EOL]         case WEEKS: [EOL]             period.setWeeks(value); [EOL]             break; [EOL]         case DAYS: [EOL]             period.setDays(value); [EOL]             break; [EOL]         case HOURS: [EOL]             period.setHours(value); [EOL]             break; [EOL]         case MINUTES: [EOL]             period.setMinutes(value); [EOL]             break; [EOL]         case SECONDS: [EOL]             period.setSeconds(value); [EOL]             break; [EOL]         case MILLIS: [EOL]             period.setMillis(value); [EOL]             break; [EOL]     } [EOL] }
void setFieldValue(ReadWritablePeriod period, int field, int value) { [EOL]     switch(field) { [EOL]         default: [EOL]             break; [EOL]         case YEARS: [EOL]             period.setYears(value); [EOL]             break; [EOL]         case MONTHS: [EOL]             period.setMonths(value); [EOL]             break; [EOL]         case WEEKS: [EOL]             period.setWeeks(value); [EOL]             break; [EOL]         case DAYS: [EOL]             period.setDays(value); [EOL]             break; [EOL]         case HOURS: [EOL]             period.setHours(value); [EOL]             break; [EOL]         case MINUTES: [EOL]             period.setMinutes(value); [EOL]             break; [EOL]         case SECONDS: [EOL]             period.setSeconds(value); [EOL]             break; [EOL]         case MILLIS: [EOL]             period.setMillis(value); [EOL]             break; [EOL]     } [EOL] }
void setFieldValue(ReadWritablePeriod period, int field, int value) { [EOL]     switch(field) { [EOL]         default: [EOL]             break; [EOL]         case YEARS: [EOL]             period.setYears(value); [EOL]             break; [EOL]         case MONTHS: [EOL]             period.setMonths(value); [EOL]             break; [EOL]         case WEEKS: [EOL]             period.setWeeks(value); [EOL]             break; [EOL]         case DAYS: [EOL]             period.setDays(value); [EOL]             break; [EOL]         case HOURS: [EOL]             period.setHours(value); [EOL]             break; [EOL]         case MINUTES: [EOL]             period.setMinutes(value); [EOL]             break; [EOL]         case SECONDS: [EOL]             period.setSeconds(value); [EOL]             break; [EOL]         case MILLIS: [EOL]             period.setMillis(value); [EOL]             break; [EOL]     } [EOL] }
void setFieldValue(ReadWritablePeriod period, int field, int value) { [EOL]     switch(field) { [EOL]         default: [EOL]             break; [EOL]         case YEARS: [EOL]             period.setYears(value); [EOL]             break; [EOL]         case MONTHS: [EOL]             period.setMonths(value); [EOL]             break; [EOL]         case WEEKS: [EOL]             period.setWeeks(value); [EOL]             break; [EOL]         case DAYS: [EOL]             period.setDays(value); [EOL]             break; [EOL]         case HOURS: [EOL]             period.setHours(value); [EOL]             break; [EOL]         case MINUTES: [EOL]             period.setMinutes(value); [EOL]             break; [EOL]         case SECONDS: [EOL]             period.setSeconds(value); [EOL]             break; [EOL]         case MILLIS: [EOL]             period.setMillis(value); [EOL]             break; [EOL]     } [EOL] }
void setFieldValue(ReadWritablePeriod period, int field, int value) { [EOL]     switch(field) { [EOL]         default: [EOL]             break; [EOL]         case YEARS: [EOL]             period.setYears(value); [EOL]             break; [EOL]         case MONTHS: [EOL]             period.setMonths(value); [EOL]             break; [EOL]         case WEEKS: [EOL]             period.setWeeks(value); [EOL]             break; [EOL]         case DAYS: [EOL]             period.setDays(value); [EOL]             break; [EOL]         case HOURS: [EOL]             period.setHours(value); [EOL]             break; [EOL]         case MINUTES: [EOL]             period.setMinutes(value); [EOL]             break; [EOL]         case SECONDS: [EOL]             period.setSeconds(value); [EOL]             break; [EOL]         case MILLIS: [EOL]             period.setMillis(value); [EOL]             break; [EOL]     } [EOL] }
void setFieldValue(ReadWritablePeriod period, int field, int value) { [EOL]     switch(field) { [EOL]         default: [EOL]             break; [EOL]         case YEARS: [EOL]             period.setYears(value); [EOL]             break; [EOL]         case MONTHS: [EOL]             period.setMonths(value); [EOL]             break; [EOL]         case WEEKS: [EOL]             period.setWeeks(value); [EOL]             break; [EOL]         case DAYS: [EOL]             period.setDays(value); [EOL]             break; [EOL]         case HOURS: [EOL]             period.setHours(value); [EOL]             break; [EOL]         case MINUTES: [EOL]             period.setMinutes(value); [EOL]             break; [EOL]         case SECONDS: [EOL]             period.setSeconds(value); [EOL]             break; [EOL]         case MILLIS: [EOL]             period.setMillis(value); [EOL]             break; [EOL]     } [EOL] }
public int parseInto(ReadWritablePeriod period, String periodStr, int position, Locale locale) { [EOL]     if (periodStr.regionMatches(true, position, iText, 0, iText.length())) { [EOL]         return position + iText.length(); [EOL]     } [EOL]     return ~position; [EOL] }
public int parseInto(ReadWritablePeriod period, String periodStr, int position, Locale locale) { [EOL]     if (periodStr.regionMatches(true, position, iText, 0, iText.length())) { [EOL]         return position + iText.length(); [EOL]     } [EOL]     return ~position; [EOL] }
Separator(String text, String finalText, String[] variants, PeriodPrinter beforePrinter, PeriodParser beforeParser, boolean useBefore, boolean useAfter) { [EOL]     iText = text; [EOL]     iFinalText = finalText; [EOL]     if ((finalText == null || text.equals(finalText)) && (variants == null || variants.length == 0)) { [EOL]         iParsedForms = new String[] { text }; [EOL]     } else { [EOL]         TreeSet<String> parsedSet = new TreeSet<String>(String.CASE_INSENSITIVE_ORDER); [EOL]         parsedSet.add(text); [EOL]         parsedSet.add(finalText); [EOL]         if (variants != null) { [EOL]             for (int i = variants.length; --i >= 0; ) { [EOL]                 parsedSet.add(variants[i]); [EOL]             } [EOL]         } [EOL]         ArrayList<String> parsedList = new ArrayList<String>(parsedSet); [EOL]         Collections.reverse(parsedList); [EOL]         iParsedForms = parsedList.toArray(new String[parsedList.size()]); [EOL]     } [EOL]     iBeforePrinter = beforePrinter; [EOL]     iBeforeParser = beforeParser; [EOL]     iUseBefore = useBefore; [EOL]     iUseAfter = useAfter; [EOL] }
Separator(String text, String finalText, String[] variants, PeriodPrinter beforePrinter, PeriodParser beforeParser, boolean useBefore, boolean useAfter) { [EOL]     iText = text; [EOL]     iFinalText = finalText; [EOL]     if ((finalText == null || text.equals(finalText)) && (variants == null || variants.length == 0)) { [EOL]         iParsedForms = new String[] { text }; [EOL]     } else { [EOL]         TreeSet<String> parsedSet = new TreeSet<String>(String.CASE_INSENSITIVE_ORDER); [EOL]         parsedSet.add(text); [EOL]         parsedSet.add(finalText); [EOL]         if (variants != null) { [EOL]             for (int i = variants.length; --i >= 0; ) { [EOL]                 parsedSet.add(variants[i]); [EOL]             } [EOL]         } [EOL]         ArrayList<String> parsedList = new ArrayList<String>(parsedSet); [EOL]         Collections.reverse(parsedList); [EOL]         iParsedForms = parsedList.toArray(new String[parsedList.size()]); [EOL]     } [EOL]     iBeforePrinter = beforePrinter; [EOL]     iBeforeParser = beforeParser; [EOL]     iUseBefore = useBefore; [EOL]     iUseAfter = useAfter; [EOL] }
Separator(String text, String finalText, String[] variants, PeriodPrinter beforePrinter, PeriodParser beforeParser, boolean useBefore, boolean useAfter) { [EOL]     iText = text; [EOL]     iFinalText = finalText; [EOL]     if ((finalText == null || text.equals(finalText)) && (variants == null || variants.length == 0)) { [EOL]         iParsedForms = new String[] { text }; [EOL]     } else { [EOL]         TreeSet<String> parsedSet = new TreeSet<String>(String.CASE_INSENSITIVE_ORDER); [EOL]         parsedSet.add(text); [EOL]         parsedSet.add(finalText); [EOL]         if (variants != null) { [EOL]             for (int i = variants.length; --i >= 0; ) { [EOL]                 parsedSet.add(variants[i]); [EOL]             } [EOL]         } [EOL]         ArrayList<String> parsedList = new ArrayList<String>(parsedSet); [EOL]         Collections.reverse(parsedList); [EOL]         iParsedForms = parsedList.toArray(new String[parsedList.size()]); [EOL]     } [EOL]     iBeforePrinter = beforePrinter; [EOL]     iBeforeParser = beforeParser; [EOL]     iUseBefore = useBefore; [EOL]     iUseAfter = useAfter; [EOL] }
public int countFieldsToPrint(ReadablePeriod period, int stopAt, Locale locale) { [EOL]     int sum = iBeforePrinter.countFieldsToPrint(period, stopAt, locale); [EOL]     if (sum < stopAt) { [EOL]         sum += iAfterPrinter.countFieldsToPrint(period, stopAt, locale); [EOL]     } [EOL]     return sum; [EOL] }
public int countFieldsToPrint(ReadablePeriod period, int stopAt, Locale locale) { [EOL]     int sum = iBeforePrinter.countFieldsToPrint(period, stopAt, locale); [EOL]     if (sum < stopAt) { [EOL]         sum += iAfterPrinter.countFieldsToPrint(period, stopAt, locale); [EOL]     } [EOL]     return sum; [EOL] }
public int calculatePrintedLength(ReadablePeriod period, Locale locale) { [EOL]     PeriodPrinter before = iBeforePrinter; [EOL]     PeriodPrinter after = iAfterPrinter; [EOL]     int sum = before.calculatePrintedLength(period, locale) + after.calculatePrintedLength(period, locale); [EOL]     if (iUseBefore) { [EOL]         if (before.countFieldsToPrint(period, 1, locale) > 0) { [EOL]             if (iUseAfter) { [EOL]                 int afterCount = after.countFieldsToPrint(period, 2, locale); [EOL]                 if (afterCount > 0) { [EOL]                     sum += (afterCount > 1 ? iText : iFinalText).length(); [EOL]                 } [EOL]             } else { [EOL]                 sum += iText.length(); [EOL]             } [EOL]         } [EOL]     } else if (iUseAfter && after.countFieldsToPrint(period, 1, locale) > 0) { [EOL]         sum += iText.length(); [EOL]     } [EOL]     return sum; [EOL] }
public int calculatePrintedLength(ReadablePeriod period, Locale locale) { [EOL]     PeriodPrinter before = iBeforePrinter; [EOL]     PeriodPrinter after = iAfterPrinter; [EOL]     int sum = before.calculatePrintedLength(period, locale) + after.calculatePrintedLength(period, locale); [EOL]     if (iUseBefore) { [EOL]         if (before.countFieldsToPrint(period, 1, locale) > 0) { [EOL]             if (iUseAfter) { [EOL]                 int afterCount = after.countFieldsToPrint(period, 2, locale); [EOL]                 if (afterCount > 0) { [EOL]                     sum += (afterCount > 1 ? iText : iFinalText).length(); [EOL]                 } [EOL]             } else { [EOL]                 sum += iText.length(); [EOL]             } [EOL]         } [EOL]     } else if (iUseAfter && after.countFieldsToPrint(period, 1, locale) > 0) { [EOL]         sum += iText.length(); [EOL]     } [EOL]     return sum; [EOL] }
public int calculatePrintedLength(ReadablePeriod period, Locale locale) { [EOL]     PeriodPrinter before = iBeforePrinter; [EOL]     PeriodPrinter after = iAfterPrinter; [EOL]     int sum = before.calculatePrintedLength(period, locale) + after.calculatePrintedLength(period, locale); [EOL]     if (iUseBefore) { [EOL]         if (before.countFieldsToPrint(period, 1, locale) > 0) { [EOL]             if (iUseAfter) { [EOL]                 int afterCount = after.countFieldsToPrint(period, 2, locale); [EOL]                 if (afterCount > 0) { [EOL]                     sum += (afterCount > 1 ? iText : iFinalText).length(); [EOL]                 } [EOL]             } else { [EOL]                 sum += iText.length(); [EOL]             } [EOL]         } [EOL]     } else if (iUseAfter && after.countFieldsToPrint(period, 1, locale) > 0) { [EOL]         sum += iText.length(); [EOL]     } [EOL]     return sum; [EOL] }
public int calculatePrintedLength(ReadablePeriod period, Locale locale) { [EOL]     PeriodPrinter before = iBeforePrinter; [EOL]     PeriodPrinter after = iAfterPrinter; [EOL]     int sum = before.calculatePrintedLength(period, locale) + after.calculatePrintedLength(period, locale); [EOL]     if (iUseBefore) { [EOL]         if (before.countFieldsToPrint(period, 1, locale) > 0) { [EOL]             if (iUseAfter) { [EOL]                 int afterCount = after.countFieldsToPrint(period, 2, locale); [EOL]                 if (afterCount > 0) { [EOL]                     sum += (afterCount > 1 ? iText : iFinalText).length(); [EOL]                 } [EOL]             } else { [EOL]                 sum += iText.length(); [EOL]             } [EOL]         } [EOL]     } else if (iUseAfter && after.countFieldsToPrint(period, 1, locale) > 0) { [EOL]         sum += iText.length(); [EOL]     } [EOL]     return sum; [EOL] }
public void printTo(StringBuffer buf, ReadablePeriod period, Locale locale) { [EOL]     PeriodPrinter before = iBeforePrinter; [EOL]     PeriodPrinter after = iAfterPrinter; [EOL]     before.printTo(buf, period, locale); [EOL]     if (iUseBefore) { [EOL]         if (before.countFieldsToPrint(period, 1, locale) > 0) { [EOL]             if (iUseAfter) { [EOL]                 int afterCount = after.countFieldsToPrint(period, 2, locale); [EOL]                 if (afterCount > 0) { [EOL]                     buf.append(afterCount > 1 ? iText : iFinalText); [EOL]                 } [EOL]             } else { [EOL]                 buf.append(iText); [EOL]             } [EOL]         } [EOL]     } else if (iUseAfter && after.countFieldsToPrint(period, 1, locale) > 0) { [EOL]         buf.append(iText); [EOL]     } [EOL]     after.printTo(buf, period, locale); [EOL] }
public void printTo(StringBuffer buf, ReadablePeriod period, Locale locale) { [EOL]     PeriodPrinter before = iBeforePrinter; [EOL]     PeriodPrinter after = iAfterPrinter; [EOL]     before.printTo(buf, period, locale); [EOL]     if (iUseBefore) { [EOL]         if (before.countFieldsToPrint(period, 1, locale) > 0) { [EOL]             if (iUseAfter) { [EOL]                 int afterCount = after.countFieldsToPrint(period, 2, locale); [EOL]                 if (afterCount > 0) { [EOL]                     buf.append(afterCount > 1 ? iText : iFinalText); [EOL]                 } [EOL]             } else { [EOL]                 buf.append(iText); [EOL]             } [EOL]         } [EOL]     } else if (iUseAfter && after.countFieldsToPrint(period, 1, locale) > 0) { [EOL]         buf.append(iText); [EOL]     } [EOL]     after.printTo(buf, period, locale); [EOL] }
public void printTo(StringBuffer buf, ReadablePeriod period, Locale locale) { [EOL]     PeriodPrinter before = iBeforePrinter; [EOL]     PeriodPrinter after = iAfterPrinter; [EOL]     before.printTo(buf, period, locale); [EOL]     if (iUseBefore) { [EOL]         if (before.countFieldsToPrint(period, 1, locale) > 0) { [EOL]             if (iUseAfter) { [EOL]                 int afterCount = after.countFieldsToPrint(period, 2, locale); [EOL]                 if (afterCount > 0) { [EOL]                     buf.append(afterCount > 1 ? iText : iFinalText); [EOL]                 } [EOL]             } else { [EOL]                 buf.append(iText); [EOL]             } [EOL]         } [EOL]     } else if (iUseAfter && after.countFieldsToPrint(period, 1, locale) > 0) { [EOL]         buf.append(iText); [EOL]     } [EOL]     after.printTo(buf, period, locale); [EOL] }
public void printTo(StringBuffer buf, ReadablePeriod period, Locale locale) { [EOL]     PeriodPrinter before = iBeforePrinter; [EOL]     PeriodPrinter after = iAfterPrinter; [EOL]     before.printTo(buf, period, locale); [EOL]     if (iUseBefore) { [EOL]         if (before.countFieldsToPrint(period, 1, locale) > 0) { [EOL]             if (iUseAfter) { [EOL]                 int afterCount = after.countFieldsToPrint(period, 2, locale); [EOL]                 if (afterCount > 0) { [EOL]                     buf.append(afterCount > 1 ? iText : iFinalText); [EOL]                 } [EOL]             } else { [EOL]                 buf.append(iText); [EOL]             } [EOL]         } [EOL]     } else if (iUseAfter && after.countFieldsToPrint(period, 1, locale) > 0) { [EOL]         buf.append(iText); [EOL]     } [EOL]     after.printTo(buf, period, locale); [EOL] }
public int parseInto(ReadWritablePeriod period, String periodStr, int position, Locale locale) { [EOL]     int oldPos = position; [EOL]     position = iBeforeParser.parseInto(period, periodStr, position, locale); [EOL]     if (position < 0) { [EOL]         return position; [EOL]     } [EOL]     boolean found = false; [EOL]     int parsedFormLength = -1; [EOL]     if (position > oldPos) { [EOL]         String[] parsedForms = iParsedForms; [EOL]         int length = parsedForms.length; [EOL]         for (int i = 0; i < length; i++) { [EOL]             String parsedForm = parsedForms[i]; [EOL]             if ((parsedForm == null || parsedForm.length() == 0) || periodStr.regionMatches(true, position, parsedForm, 0, parsedForm.length())) { [EOL]                 parsedFormLength = (parsedForm == null ? 0 : parsedForm.length()); [EOL]                 position += parsedFormLength; [EOL]                 found = true; [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     oldPos = position; [EOL]     position = iAfterParser.parseInto(period, periodStr, position, locale); [EOL]     if (position < 0) { [EOL]         return position; [EOL]     } [EOL]     if (found && position == oldPos && parsedFormLength > 0) { [EOL]         return ~oldPos; [EOL]     } [EOL]     if (position > oldPos && !found && !iUseBefore) { [EOL]         return ~oldPos; [EOL]     } [EOL]     return position; [EOL] }
Separator finish(PeriodPrinter afterPrinter, PeriodParser afterParser) { [EOL]     iAfterPrinter = afterPrinter; [EOL]     iAfterParser = afterParser; [EOL]     return this; [EOL] }
Separator finish(PeriodPrinter afterPrinter, PeriodParser afterParser) { [EOL]     iAfterPrinter = afterPrinter; [EOL]     iAfterParser = afterParser; [EOL]     return this; [EOL] }
public int parseInto(ReadWritablePeriod period, String periodStr, int position, Locale locale) { [EOL]     PeriodParser[] parsers = iParsers; [EOL]     if (parsers == null) { [EOL]         throw new UnsupportedOperationException(); [EOL]     } [EOL]     int len = parsers.length; [EOL]     for (int i = 0; i < len && position >= 0; i++) { [EOL]         position = parsers[i].parseInto(period, periodStr, position, locale); [EOL]     } [EOL]     return position; [EOL] }
public int parseInto(ReadWritablePeriod period, String periodStr, int position, Locale locale) { [EOL]     PeriodParser[] parsers = iParsers; [EOL]     if (parsers == null) { [EOL]         throw new UnsupportedOperationException(); [EOL]     } [EOL]     int len = parsers.length; [EOL]     for (int i = 0; i < len && position >= 0; i++) { [EOL]         position = parsers[i].parseInto(period, periodStr, position, locale); [EOL]     } [EOL]     return position; [EOL] }
public int parseInto(ReadWritablePeriod period, String periodStr, int position, Locale locale) { [EOL]     PeriodParser[] parsers = iParsers; [EOL]     if (parsers == null) { [EOL]         throw new UnsupportedOperationException(); [EOL]     } [EOL]     int len = parsers.length; [EOL]     for (int i = 0; i < len && position >= 0; i++) { [EOL]         position = parsers[i].parseInto(period, periodStr, position, locale); [EOL]     } [EOL]     return position; [EOL] }
private void decompose(List<Object> elementPairs, List<Object> printerList, List<Object> parserList) { [EOL]     int size = elementPairs.size(); [EOL]     for (int i = 0; i < size; i += 2) { [EOL]         Object element = elementPairs.get(i); [EOL]         if (element instanceof PeriodPrinter) { [EOL]             if (element instanceof Composite) { [EOL]                 addArrayToList(printerList, ((Composite) element).iPrinters); [EOL]             } else { [EOL]                 printerList.add(element); [EOL]             } [EOL]         } [EOL]         element = elementPairs.get(i + 1); [EOL]         if (element instanceof PeriodParser) { [EOL]             if (element instanceof Composite) { [EOL]                 addArrayToList(parserList, ((Composite) element).iParsers); [EOL]             } else { [EOL]                 parserList.add(element); [EOL]             } [EOL]         } [EOL]     } [EOL] }
private void decompose(List<Object> elementPairs, List<Object> printerList, List<Object> parserList) { [EOL]     int size = elementPairs.size(); [EOL]     for (int i = 0; i < size; i += 2) { [EOL]         Object element = elementPairs.get(i); [EOL]         if (element instanceof PeriodPrinter) { [EOL]             if (element instanceof Composite) { [EOL]                 addArrayToList(printerList, ((Composite) element).iPrinters); [EOL]             } else { [EOL]                 printerList.add(element); [EOL]             } [EOL]         } [EOL]         element = elementPairs.get(i + 1); [EOL]         if (element instanceof PeriodParser) { [EOL]             if (element instanceof Composite) { [EOL]                 addArrayToList(parserList, ((Composite) element).iParsers); [EOL]             } else { [EOL]                 parserList.add(element); [EOL]             } [EOL]         } [EOL]     } [EOL] }
private void decompose(List<Object> elementPairs, List<Object> printerList, List<Object> parserList) { [EOL]     int size = elementPairs.size(); [EOL]     for (int i = 0; i < size; i += 2) { [EOL]         Object element = elementPairs.get(i); [EOL]         if (element instanceof PeriodPrinter) { [EOL]             if (element instanceof Composite) { [EOL]                 addArrayToList(printerList, ((Composite) element).iPrinters); [EOL]             } else { [EOL]                 printerList.add(element); [EOL]             } [EOL]         } [EOL]         element = elementPairs.get(i + 1); [EOL]         if (element instanceof PeriodParser) { [EOL]             if (element instanceof Composite) { [EOL]                 addArrayToList(parserList, ((Composite) element).iParsers); [EOL]             } else { [EOL]                 parserList.add(element); [EOL]             } [EOL]         } [EOL]     } [EOL] }
private void decompose(List<Object> elementPairs, List<Object> printerList, List<Object> parserList) { [EOL]     int size = elementPairs.size(); [EOL]     for (int i = 0; i < size; i += 2) { [EOL]         Object element = elementPairs.get(i); [EOL]         if (element instanceof PeriodPrinter) { [EOL]             if (element instanceof Composite) { [EOL]                 addArrayToList(printerList, ((Composite) element).iPrinters); [EOL]             } else { [EOL]                 printerList.add(element); [EOL]             } [EOL]         } [EOL]         element = elementPairs.get(i + 1); [EOL]         if (element instanceof PeriodParser) { [EOL]             if (element instanceof Composite) { [EOL]                 addArrayToList(parserList, ((Composite) element).iParsers); [EOL]             } else { [EOL]                 parserList.add(element); [EOL]             } [EOL]         } [EOL]     } [EOL] }
private void addArrayToList(List<Object> list, Object[] array) { [EOL]     if (array != null) { [EOL]         for (int i = 0; i < array.length; i++) { [EOL]             list.add(array[i]); [EOL]         } [EOL]     } [EOL] }
private void addArrayToList(List<Object> list, Object[] array) { [EOL]     if (array != null) { [EOL]         for (int i = 0; i < array.length; i++) { [EOL]             list.add(array[i]); [EOL]         } [EOL]     } [EOL] }
public int get(long instant) { [EOL]     return iChronology.getWeekyear(instant); [EOL] }
public DurationField getRangeDurationField() { [EOL]     return null; [EOL] }
public DurationField getLeapDurationField() { [EOL]     return iChronology.weeks(); [EOL] }
public static DateTimeFormatter shortDate() { [EOL]     return createFormatterForStyleIndex(SHORT, NONE); [EOL] } protected DateTimeFormat();  StyleFormatter(int dateStyle, int timeStyle, int type); protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest); public static DateTimeFormatter forPattern(String pattern); public static DateTimeFormatter forStyle(String style); public static String patternForStyle(String style, Locale locale); public static DateTimeFormatter shortDate(); public static DateTimeFormatter shortTime(); public static DateTimeFormatter shortDateTime(); public static DateTimeFormatter mediumDate(); public static DateTimeFormatter mediumTime(); public static DateTimeFormatter mediumDateTime(); public static DateTimeFormatter longDate(); public static DateTimeFormatter longTime(); public static DateTimeFormatter longDateTime(); public static DateTimeFormatter fullDate(); public static DateTimeFormatter fullTime(); public static DateTimeFormatter fullDateTime();  static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern); private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern); private static String parseToken(String pattern, int[] indexRef); private static boolean isNumericToken(String token); private static DateTimeFormatter createFormatterForPattern(String pattern); private static DateTimeFormatter createFormatterForStyle(String style); private static DateTimeFormatter createFormatterForStyleIndex(int dateStyle, int timeStyle); private static DateTimeFormatter createDateTimeFormatter(int dateStyle, int timeStyle); private static int selectStyle(char ch); public int estimatePrintedLength(); public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale); public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException; public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale); public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException; public int estimateParsedLength(); public int parseInto(DateTimeParserBucket bucket, String text, int position); private DateTimeFormatter getFormatter(Locale locale);  String getPattern(Locale locale); int FULL=Optional[0]; int LONG=Optional[1]; int MEDIUM=Optional[2]; int SHORT=Optional[3]; int NONE=Optional[4]; int DATE=Optional[0]; int TIME=Optional[1]; int DATETIME=Optional[2]; int PATTERN_CACHE_SIZE=Optional[500]; Map<String, DateTimeFormatter> PATTERN_CACHE=Optional[new LinkedHashMap<String, DateTimeFormatter>(7) {; ;     private static final long serialVersionUID = 23L;; ;     @Override;     protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest) {;         return size() > PATTERN_CACHE_SIZE;;     }; }
public static DateTimeFormatter fullDate() { [EOL]     return createFormatterForStyleIndex(FULL, NONE); [EOL] } protected DateTimeFormat();  StyleFormatter(int dateStyle, int timeStyle, int type); protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest); public static DateTimeFormatter forPattern(String pattern); public static DateTimeFormatter forStyle(String style); public static String patternForStyle(String style, Locale locale); public static DateTimeFormatter shortDate(); public static DateTimeFormatter shortTime(); public static DateTimeFormatter shortDateTime(); public static DateTimeFormatter mediumDate(); public static DateTimeFormatter mediumTime(); public static DateTimeFormatter mediumDateTime(); public static DateTimeFormatter longDate(); public static DateTimeFormatter longTime(); public static DateTimeFormatter longDateTime(); public static DateTimeFormatter fullDate(); public static DateTimeFormatter fullTime(); public static DateTimeFormatter fullDateTime();  static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern); private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern); private static String parseToken(String pattern, int[] indexRef); private static boolean isNumericToken(String token); private static DateTimeFormatter createFormatterForPattern(String pattern); private static DateTimeFormatter createFormatterForStyle(String style); private static DateTimeFormatter createFormatterForStyleIndex(int dateStyle, int timeStyle); private static DateTimeFormatter createDateTimeFormatter(int dateStyle, int timeStyle); private static int selectStyle(char ch); public int estimatePrintedLength(); public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale); public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException; public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale); public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException; public int estimateParsedLength(); public int parseInto(DateTimeParserBucket bucket, String text, int position); private DateTimeFormatter getFormatter(Locale locale);  String getPattern(Locale locale); int FULL=Optional[0]; int LONG=Optional[1]; int MEDIUM=Optional[2]; int SHORT=Optional[3]; int NONE=Optional[4]; int DATE=Optional[0]; int TIME=Optional[1]; int DATETIME=Optional[2]; int PATTERN_CACHE_SIZE=Optional[500]; Map<String, DateTimeFormatter> PATTERN_CACHE=Optional[new LinkedHashMap<String, DateTimeFormatter>(7) {; ;     private static final long serialVersionUID = 23L;; ;     @Override;     protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest) {;         return size() > PATTERN_CACHE_SIZE;;     }; }
static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern) { [EOL]     parsePatternTo(builder, pattern); [EOL] } protected DateTimeFormat();  StyleFormatter(int dateStyle, int timeStyle, int type); protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest); public static DateTimeFormatter forPattern(String pattern); public static DateTimeFormatter forStyle(String style); public static String patternForStyle(String style, Locale locale); public static DateTimeFormatter shortDate(); public static DateTimeFormatter shortTime(); public static DateTimeFormatter shortDateTime(); public static DateTimeFormatter mediumDate(); public static DateTimeFormatter mediumTime(); public static DateTimeFormatter mediumDateTime(); public static DateTimeFormatter longDate(); public static DateTimeFormatter longTime(); public static DateTimeFormatter longDateTime(); public static DateTimeFormatter fullDate(); public static DateTimeFormatter fullTime(); public static DateTimeFormatter fullDateTime();  static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern); private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern); private static String parseToken(String pattern, int[] indexRef); private static boolean isNumericToken(String token); private static DateTimeFormatter createFormatterForPattern(String pattern); private static DateTimeFormatter createFormatterForStyle(String style); private static DateTimeFormatter createFormatterForStyleIndex(int dateStyle, int timeStyle); private static DateTimeFormatter createDateTimeFormatter(int dateStyle, int timeStyle); private static int selectStyle(char ch); public int estimatePrintedLength(); public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale); public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException; public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale); public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException; public int estimateParsedLength(); public int parseInto(DateTimeParserBucket bucket, String text, int position); private DateTimeFormatter getFormatter(Locale locale);  String getPattern(Locale locale); int FULL=Optional[0]; int LONG=Optional[1]; int MEDIUM=Optional[2]; int SHORT=Optional[3]; int NONE=Optional[4]; int DATE=Optional[0]; int TIME=Optional[1]; int DATETIME=Optional[2]; int PATTERN_CACHE_SIZE=Optional[500]; Map<String, DateTimeFormatter> PATTERN_CACHE=Optional[new LinkedHashMap<String, DateTimeFormatter>(7) {; ;     private static final long serialVersionUID = 23L;; ;     @Override;     protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest) {;         return size() > PATTERN_CACHE_SIZE;;     }; }
private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern) { [EOL]     int length = pattern.length(); [EOL]     int[] indexRef = new int[1]; [EOL]     for (int i = 0; i < length; i++) { [EOL]         indexRef[0] = i; [EOL]         String token = parseToken(pattern, indexRef); [EOL]         i = indexRef[0]; [EOL]         int tokenLen = token.length(); [EOL]         if (tokenLen == 0) { [EOL]             break; [EOL]         } [EOL]         char c = token.charAt(0); [EOL]         switch(c) { [EOL]             case 'G': [EOL]                 builder.appendEraText(); [EOL]                 break; [EOL]             case 'C': [EOL]                 builder.appendCenturyOfEra(tokenLen, tokenLen); [EOL]                 break; [EOL]             case 'x': [EOL]             case 'y': [EOL]             case 'Y': [EOL]                 if (tokenLen == 2) { [EOL]                     boolean lenientParse = true; [EOL]                     if (i + 1 < length) { [EOL]                         indexRef[0]++; [EOL]                         if (isNumericToken(parseToken(pattern, indexRef))) { [EOL]                             lenientParse = false; [EOL]                         } [EOL]                         indexRef[0]--; [EOL]                     } [EOL]                     switch(c) { [EOL]                         case 'x': [EOL]                             builder.appendTwoDigitWeekyear(new DateTime().getWeekyear() - 30, lenientParse); [EOL]                             break; [EOL]                         case 'y': [EOL]                         case 'Y': [EOL]                         default: [EOL]                             builder.appendTwoDigitYear(new DateTime().getYear() - 30, lenientParse); [EOL]                             break; [EOL]                     } [EOL]                 } else { [EOL]                     int maxDigits = 9; [EOL]                     if (i + 1 < length) { [EOL]                         indexRef[0]++; [EOL]                         if (isNumericToken(parseToken(pattern, indexRef))) { [EOL]                             maxDigits = tokenLen; [EOL]                         } [EOL]                         indexRef[0]--; [EOL]                     } [EOL]                     switch(c) { [EOL]                         case 'x': [EOL]                             builder.appendWeekyear(tokenLen, maxDigits); [EOL]                             break; [EOL]                         case 'y': [EOL]                             builder.appendYear(tokenLen, maxDigits); [EOL]                             break; [EOL]                         case 'Y': [EOL]                             builder.appendYearOfEra(tokenLen, maxDigits); [EOL]                             break; [EOL]                     } [EOL]                 } [EOL]                 break; [EOL]             case 'M': [EOL]                 if (tokenLen >= 3) { [EOL]                     if (tokenLen >= 4) { [EOL]                         builder.appendMonthOfYearText(); [EOL]                     } else { [EOL]                         builder.appendMonthOfYearShortText(); [EOL]                     } [EOL]                 } else { [EOL]                     builder.appendMonthOfYear(tokenLen); [EOL]                 } [EOL]                 break; [EOL]             case 'd': [EOL]                 builder.appendDayOfMonth(tokenLen); [EOL]                 break; [EOL]             case 'a': [EOL]                 builder.appendHalfdayOfDayText(); [EOL]                 break; [EOL]             case 'h': [EOL]                 builder.appendClockhourOfHalfday(tokenLen); [EOL]                 break; [EOL]             case 'H': [EOL]                 builder.appendHourOfDay(tokenLen); [EOL]                 break; [EOL]             case 'k': [EOL]                 builder.appendClockhourOfDay(tokenLen); [EOL]                 break; [EOL]             case 'K': [EOL]                 builder.appendHourOfHalfday(tokenLen); [EOL]                 break; [EOL]             case 'm': [EOL]                 builder.appendMinuteOfHour(tokenLen); [EOL]                 break; [EOL]             case 's': [EOL]                 builder.appendSecondOfMinute(tokenLen); [EOL]                 break; [EOL]             case 'S': [EOL]                 builder.appendFractionOfSecond(tokenLen, tokenLen); [EOL]                 break; [EOL]             case 'e': [EOL]                 builder.appendDayOfWeek(tokenLen); [EOL]                 break; [EOL]             case 'E': [EOL]                 if (tokenLen >= 4) { [EOL]                     builder.appendDayOfWeekText(); [EOL]                 } else { [EOL]                     builder.appendDayOfWeekShortText(); [EOL]                 } [EOL]                 break; [EOL]             case 'D': [EOL]                 builder.appendDayOfYear(tokenLen); [EOL]                 break; [EOL]             case 'w': [EOL]                 builder.appendWeekOfWeekyear(tokenLen); [EOL]                 break; [EOL]             case 'z': [EOL]                 if (tokenLen >= 4) { [EOL]                     builder.appendTimeZoneName(); [EOL]                 } else { [EOL]                     builder.appendTimeZoneShortName(null); [EOL]                 } [EOL]                 break; [EOL]             case 'Z': [EOL]                 if (tokenLen == 1) { [EOL]                     builder.appendTimeZoneOffset(null, "Z", false, 2, 2); [EOL]                 } else if (tokenLen == 2) { [EOL]                     builder.appendTimeZoneOffset(null, "Z", true, 2, 2); [EOL]                 } else { [EOL]                     builder.appendTimeZoneId(); [EOL]                 } [EOL]                 break; [EOL]             case '\'': [EOL]                 String sub = token.substring(1); [EOL]                 if (sub.length() == 1) { [EOL]                     builder.appendLiteral(sub.charAt(0)); [EOL]                 } else { [EOL]                     builder.appendLiteral(new String(sub)); [EOL]                 } [EOL]                 break; [EOL]             default: [EOL]                 throw new IllegalArgumentException("Illegal pattern component: " + token); [EOL]         } [EOL]     } [EOL] } protected DateTimeFormat();  StyleFormatter(int dateStyle, int timeStyle, int type); protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest); public static DateTimeFormatter forPattern(String pattern); public static DateTimeFormatter forStyle(String style); public static String patternForStyle(String style, Locale locale); public static DateTimeFormatter shortDate(); public static DateTimeFormatter shortTime(); public static DateTimeFormatter shortDateTime(); public static DateTimeFormatter mediumDate(); public static DateTimeFormatter mediumTime(); public static DateTimeFormatter mediumDateTime(); public static DateTimeFormatter longDate(); public static DateTimeFormatter longTime(); public static DateTimeFormatter longDateTime(); public static DateTimeFormatter fullDate(); public static DateTimeFormatter fullTime(); public static DateTimeFormatter fullDateTime();  static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern); private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern); private static String parseToken(String pattern, int[] indexRef); private static boolean isNumericToken(String token); private static DateTimeFormatter createFormatterForPattern(String pattern); private static DateTimeFormatter createFormatterForStyle(String style); private static DateTimeFormatter createFormatterForStyleIndex(int dateStyle, int timeStyle); private static DateTimeFormatter createDateTimeFormatter(int dateStyle, int timeStyle); private static int selectStyle(char ch); public int estimatePrintedLength(); public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale); public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException; public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale); public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException; public int estimateParsedLength(); public int parseInto(DateTimeParserBucket bucket, String text, int position); private DateTimeFormatter getFormatter(Locale locale);  String getPattern(Locale locale); int FULL=Optional[0]; int LONG=Optional[1]; int MEDIUM=Optional[2]; int SHORT=Optional[3]; int NONE=Optional[4]; int DATE=Optional[0]; int TIME=Optional[1]; int DATETIME=Optional[2]; int PATTERN_CACHE_SIZE=Optional[500]; Map<String, DateTimeFormatter> PATTERN_CACHE=Optional[new LinkedHashMap<String, DateTimeFormatter>(7) {; ;     private static final long serialVersionUID = 23L;; ;     @Override;     protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest) {;         return size() > PATTERN_CACHE_SIZE;;     }; }
private static String parseToken(String pattern, int[] indexRef) { [EOL]     StringBuilder buf = new StringBuilder(); [EOL]     int i = indexRef[0]; [EOL]     int length = pattern.length(); [EOL]     char c = pattern.charAt(i); [EOL]     if (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z') { [EOL]         buf.append(c); [EOL]         while (i + 1 < length) { [EOL]             char peek = pattern.charAt(i + 1); [EOL]             if (peek == c) { [EOL]                 buf.append(c); [EOL]                 i++; [EOL]             } else { [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         buf.append('\''); [EOL]         boolean inLiteral = false; [EOL]         for (; i < length; i++) { [EOL]             c = pattern.charAt(i); [EOL]             if (c == '\'') { [EOL]                 if (i + 1 < length && pattern.charAt(i + 1) == '\'') { [EOL]                     i++; [EOL]                     buf.append(c); [EOL]                 } else { [EOL]                     inLiteral = !inLiteral; [EOL]                 } [EOL]             } else if (!inLiteral && (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z')) { [EOL]                 i--; [EOL]                 break; [EOL]             } else { [EOL]                 buf.append(c); [EOL]             } [EOL]         } [EOL]     } [EOL]     indexRef[0] = i; [EOL]     return buf.toString(); [EOL] } protected DateTimeFormat();  StyleFormatter(int dateStyle, int timeStyle, int type); protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest); public static DateTimeFormatter forPattern(String pattern); public static DateTimeFormatter forStyle(String style); public static String patternForStyle(String style, Locale locale); public static DateTimeFormatter shortDate(); public static DateTimeFormatter shortTime(); public static DateTimeFormatter shortDateTime(); public static DateTimeFormatter mediumDate(); public static DateTimeFormatter mediumTime(); public static DateTimeFormatter mediumDateTime(); public static DateTimeFormatter longDate(); public static DateTimeFormatter longTime(); public static DateTimeFormatter longDateTime(); public static DateTimeFormatter fullDate(); public static DateTimeFormatter fullTime(); public static DateTimeFormatter fullDateTime();  static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern); private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern); private static String parseToken(String pattern, int[] indexRef); private static boolean isNumericToken(String token); private static DateTimeFormatter createFormatterForPattern(String pattern); private static DateTimeFormatter createFormatterForStyle(String style); private static DateTimeFormatter createFormatterForStyleIndex(int dateStyle, int timeStyle); private static DateTimeFormatter createDateTimeFormatter(int dateStyle, int timeStyle); private static int selectStyle(char ch); public int estimatePrintedLength(); public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale); public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException; public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale); public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException; public int estimateParsedLength(); public int parseInto(DateTimeParserBucket bucket, String text, int position); private DateTimeFormatter getFormatter(Locale locale);  String getPattern(Locale locale); int FULL=Optional[0]; int LONG=Optional[1]; int MEDIUM=Optional[2]; int SHORT=Optional[3]; int NONE=Optional[4]; int DATE=Optional[0]; int TIME=Optional[1]; int DATETIME=Optional[2]; int PATTERN_CACHE_SIZE=Optional[500]; Map<String, DateTimeFormatter> PATTERN_CACHE=Optional[new LinkedHashMap<String, DateTimeFormatter>(7) {; ;     private static final long serialVersionUID = 23L;; ;     @Override;     protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest) {;         return size() > PATTERN_CACHE_SIZE;;     }; }
private static boolean isNumericToken(String token) { [EOL]     int tokenLen = token.length(); [EOL]     if (tokenLen > 0) { [EOL]         char c = token.charAt(0); [EOL]         switch(c) { [EOL]             case 'c': [EOL]             case 'C': [EOL]             case 'x': [EOL]             case 'y': [EOL]             case 'Y': [EOL]             case 'd': [EOL]             case 'h': [EOL]             case 'H': [EOL]             case 'm': [EOL]             case 's': [EOL]             case 'S': [EOL]             case 'e': [EOL]             case 'D': [EOL]             case 'F': [EOL]             case 'w': [EOL]             case 'W': [EOL]             case 'k': [EOL]             case 'K': [EOL]                 return true; [EOL]             case 'M': [EOL]                 if (tokenLen <= 2) { [EOL]                     return true; [EOL]                 } [EOL]         } [EOL]     } [EOL]     return false; [EOL] } protected DateTimeFormat();  StyleFormatter(int dateStyle, int timeStyle, int type); protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest); public static DateTimeFormatter forPattern(String pattern); public static DateTimeFormatter forStyle(String style); public static String patternForStyle(String style, Locale locale); public static DateTimeFormatter shortDate(); public static DateTimeFormatter shortTime(); public static DateTimeFormatter shortDateTime(); public static DateTimeFormatter mediumDate(); public static DateTimeFormatter mediumTime(); public static DateTimeFormatter mediumDateTime(); public static DateTimeFormatter longDate(); public static DateTimeFormatter longTime(); public static DateTimeFormatter longDateTime(); public static DateTimeFormatter fullDate(); public static DateTimeFormatter fullTime(); public static DateTimeFormatter fullDateTime();  static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern); private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern); private static String parseToken(String pattern, int[] indexRef); private static boolean isNumericToken(String token); private static DateTimeFormatter createFormatterForPattern(String pattern); private static DateTimeFormatter createFormatterForStyle(String style); private static DateTimeFormatter createFormatterForStyleIndex(int dateStyle, int timeStyle); private static DateTimeFormatter createDateTimeFormatter(int dateStyle, int timeStyle); private static int selectStyle(char ch); public int estimatePrintedLength(); public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale); public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException; public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale); public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException; public int estimateParsedLength(); public int parseInto(DateTimeParserBucket bucket, String text, int position); private DateTimeFormatter getFormatter(Locale locale);  String getPattern(Locale locale); int FULL=Optional[0]; int LONG=Optional[1]; int MEDIUM=Optional[2]; int SHORT=Optional[3]; int NONE=Optional[4]; int DATE=Optional[0]; int TIME=Optional[1]; int DATETIME=Optional[2]; int PATTERN_CACHE_SIZE=Optional[500]; Map<String, DateTimeFormatter> PATTERN_CACHE=Optional[new LinkedHashMap<String, DateTimeFormatter>(7) {; ;     private static final long serialVersionUID = 23L;; ;     @Override;     protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest) {;         return size() > PATTERN_CACHE_SIZE;;     }; }
private static boolean isNumericToken(String token) { [EOL]     int tokenLen = token.length(); [EOL]     if (tokenLen > 0) { [EOL]         char c = token.charAt(0); [EOL]         switch(c) { [EOL]             case 'c': [EOL]             case 'C': [EOL]             case 'x': [EOL]             case 'y': [EOL]             case 'Y': [EOL]             case 'd': [EOL]             case 'h': [EOL]             case 'H': [EOL]             case 'm': [EOL]             case 's': [EOL]             case 'S': [EOL]             case 'e': [EOL]             case 'D': [EOL]             case 'F': [EOL]             case 'w': [EOL]             case 'W': [EOL]             case 'k': [EOL]             case 'K': [EOL]                 return true; [EOL]             case 'M': [EOL]                 if (tokenLen <= 2) { [EOL]                     return true; [EOL]                 } [EOL]         } [EOL]     } [EOL]     return false; [EOL] } protected DateTimeFormat();  StyleFormatter(int dateStyle, int timeStyle, int type); protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest); public static DateTimeFormatter forPattern(String pattern); public static DateTimeFormatter forStyle(String style); public static String patternForStyle(String style, Locale locale); public static DateTimeFormatter shortDate(); public static DateTimeFormatter shortTime(); public static DateTimeFormatter shortDateTime(); public static DateTimeFormatter mediumDate(); public static DateTimeFormatter mediumTime(); public static DateTimeFormatter mediumDateTime(); public static DateTimeFormatter longDate(); public static DateTimeFormatter longTime(); public static DateTimeFormatter longDateTime(); public static DateTimeFormatter fullDate(); public static DateTimeFormatter fullTime(); public static DateTimeFormatter fullDateTime();  static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern); private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern); private static String parseToken(String pattern, int[] indexRef); private static boolean isNumericToken(String token); private static DateTimeFormatter createFormatterForPattern(String pattern); private static DateTimeFormatter createFormatterForStyle(String style); private static DateTimeFormatter createFormatterForStyleIndex(int dateStyle, int timeStyle); private static DateTimeFormatter createDateTimeFormatter(int dateStyle, int timeStyle); private static int selectStyle(char ch); public int estimatePrintedLength(); public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale); public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException; public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale); public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException; public int estimateParsedLength(); public int parseInto(DateTimeParserBucket bucket, String text, int position); private DateTimeFormatter getFormatter(Locale locale);  String getPattern(Locale locale); int FULL=Optional[0]; int LONG=Optional[1]; int MEDIUM=Optional[2]; int SHORT=Optional[3]; int NONE=Optional[4]; int DATE=Optional[0]; int TIME=Optional[1]; int DATETIME=Optional[2]; int PATTERN_CACHE_SIZE=Optional[500]; Map<String, DateTimeFormatter> PATTERN_CACHE=Optional[new LinkedHashMap<String, DateTimeFormatter>(7) {; ;     private static final long serialVersionUID = 23L;; ;     @Override;     protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest) {;         return size() > PATTERN_CACHE_SIZE;;     }; }
private static DateTimeFormatter createFormatterForPattern(String pattern) { [EOL]     if (pattern == null || pattern.length() == 0) { [EOL]         throw new IllegalArgumentException("Invalid pattern specification"); [EOL]     } [EOL]     DateTimeFormatter formatter = null; [EOL]     synchronized (PATTERN_CACHE) { [EOL]         formatter = PATTERN_CACHE.get(pattern); [EOL]         if (formatter == null) { [EOL]             DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL]             parsePatternTo(builder, pattern); [EOL]             formatter = builder.toFormatter(); [EOL]             PATTERN_CACHE.put(pattern, formatter); [EOL]         } [EOL]     } [EOL]     return formatter; [EOL] } protected DateTimeFormat();  StyleFormatter(int dateStyle, int timeStyle, int type); protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest); public static DateTimeFormatter forPattern(String pattern); public static DateTimeFormatter forStyle(String style); public static String patternForStyle(String style, Locale locale); public static DateTimeFormatter shortDate(); public static DateTimeFormatter shortTime(); public static DateTimeFormatter shortDateTime(); public static DateTimeFormatter mediumDate(); public static DateTimeFormatter mediumTime(); public static DateTimeFormatter mediumDateTime(); public static DateTimeFormatter longDate(); public static DateTimeFormatter longTime(); public static DateTimeFormatter longDateTime(); public static DateTimeFormatter fullDate(); public static DateTimeFormatter fullTime(); public static DateTimeFormatter fullDateTime();  static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern); private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern); private static String parseToken(String pattern, int[] indexRef); private static boolean isNumericToken(String token); private static DateTimeFormatter createFormatterForPattern(String pattern); private static DateTimeFormatter createFormatterForStyle(String style); private static DateTimeFormatter createFormatterForStyleIndex(int dateStyle, int timeStyle); private static DateTimeFormatter createDateTimeFormatter(int dateStyle, int timeStyle); private static int selectStyle(char ch); public int estimatePrintedLength(); public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale); public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException; public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale); public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException; public int estimateParsedLength(); public int parseInto(DateTimeParserBucket bucket, String text, int position); private DateTimeFormatter getFormatter(Locale locale);  String getPattern(Locale locale); int FULL=Optional[0]; int LONG=Optional[1]; int MEDIUM=Optional[2]; int SHORT=Optional[3]; int NONE=Optional[4]; int DATE=Optional[0]; int TIME=Optional[1]; int DATETIME=Optional[2]; int PATTERN_CACHE_SIZE=Optional[500]; Map<String, DateTimeFormatter> PATTERN_CACHE=Optional[new LinkedHashMap<String, DateTimeFormatter>(7) {; ;     private static final long serialVersionUID = 23L;; ;     @Override;     protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest) {;         return size() > PATTERN_CACHE_SIZE;;     }; }
private static DateTimeFormatter createFormatterForPattern(String pattern) { [EOL]     if (pattern == null || pattern.length() == 0) { [EOL]         throw new IllegalArgumentException("Invalid pattern specification"); [EOL]     } [EOL]     DateTimeFormatter formatter = null; [EOL]     synchronized (PATTERN_CACHE) { [EOL]         formatter = PATTERN_CACHE.get(pattern); [EOL]         if (formatter == null) { [EOL]             DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL]             parsePatternTo(builder, pattern); [EOL]             formatter = builder.toFormatter(); [EOL]             PATTERN_CACHE.put(pattern, formatter); [EOL]         } [EOL]     } [EOL]     return formatter; [EOL] } protected DateTimeFormat();  StyleFormatter(int dateStyle, int timeStyle, int type); protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest); public static DateTimeFormatter forPattern(String pattern); public static DateTimeFormatter forStyle(String style); public static String patternForStyle(String style, Locale locale); public static DateTimeFormatter shortDate(); public static DateTimeFormatter shortTime(); public static DateTimeFormatter shortDateTime(); public static DateTimeFormatter mediumDate(); public static DateTimeFormatter mediumTime(); public static DateTimeFormatter mediumDateTime(); public static DateTimeFormatter longDate(); public static DateTimeFormatter longTime(); public static DateTimeFormatter longDateTime(); public static DateTimeFormatter fullDate(); public static DateTimeFormatter fullTime(); public static DateTimeFormatter fullDateTime();  static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern); private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern); private static String parseToken(String pattern, int[] indexRef); private static boolean isNumericToken(String token); private static DateTimeFormatter createFormatterForPattern(String pattern); private static DateTimeFormatter createFormatterForStyle(String style); private static DateTimeFormatter createFormatterForStyleIndex(int dateStyle, int timeStyle); private static DateTimeFormatter createDateTimeFormatter(int dateStyle, int timeStyle); private static int selectStyle(char ch); public int estimatePrintedLength(); public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale); public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException; public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale); public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException; public int estimateParsedLength(); public int parseInto(DateTimeParserBucket bucket, String text, int position); private DateTimeFormatter getFormatter(Locale locale);  String getPattern(Locale locale); int FULL=Optional[0]; int LONG=Optional[1]; int MEDIUM=Optional[2]; int SHORT=Optional[3]; int NONE=Optional[4]; int DATE=Optional[0]; int TIME=Optional[1]; int DATETIME=Optional[2]; int PATTERN_CACHE_SIZE=Optional[500]; Map<String, DateTimeFormatter> PATTERN_CACHE=Optional[new LinkedHashMap<String, DateTimeFormatter>(7) {; ;     private static final long serialVersionUID = 23L;; ;     @Override;     protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest) {;         return size() > PATTERN_CACHE_SIZE;;     }; }
private static int selectStyle(char ch) { [EOL]     switch(ch) { [EOL]         case 'S': [EOL]             return SHORT; [EOL]         case 'M': [EOL]             return MEDIUM; [EOL]         case 'L': [EOL]             return LONG; [EOL]         case 'F': [EOL]             return FULL; [EOL]         case '-': [EOL]             return NONE; [EOL]         default: [EOL]             throw new IllegalArgumentException("Invalid style character: " + ch); [EOL]     } [EOL] } protected DateTimeFormat();  StyleFormatter(int dateStyle, int timeStyle, int type); protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest); public static DateTimeFormatter forPattern(String pattern); public static DateTimeFormatter forStyle(String style); public static String patternForStyle(String style, Locale locale); public static DateTimeFormatter shortDate(); public static DateTimeFormatter shortTime(); public static DateTimeFormatter shortDateTime(); public static DateTimeFormatter mediumDate(); public static DateTimeFormatter mediumTime(); public static DateTimeFormatter mediumDateTime(); public static DateTimeFormatter longDate(); public static DateTimeFormatter longTime(); public static DateTimeFormatter longDateTime(); public static DateTimeFormatter fullDate(); public static DateTimeFormatter fullTime(); public static DateTimeFormatter fullDateTime();  static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern); private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern); private static String parseToken(String pattern, int[] indexRef); private static boolean isNumericToken(String token); private static DateTimeFormatter createFormatterForPattern(String pattern); private static DateTimeFormatter createFormatterForStyle(String style); private static DateTimeFormatter createFormatterForStyleIndex(int dateStyle, int timeStyle); private static DateTimeFormatter createDateTimeFormatter(int dateStyle, int timeStyle); private static int selectStyle(char ch); public int estimatePrintedLength(); public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale); public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException; public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale); public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException; public int estimateParsedLength(); public int parseInto(DateTimeParserBucket bucket, String text, int position); private DateTimeFormatter getFormatter(Locale locale);  String getPattern(Locale locale); int FULL=Optional[0]; int LONG=Optional[1]; int MEDIUM=Optional[2]; int SHORT=Optional[3]; int NONE=Optional[4]; int DATE=Optional[0]; int TIME=Optional[1]; int DATETIME=Optional[2]; int PATTERN_CACHE_SIZE=Optional[500]; Map<String, DateTimeFormatter> PATTERN_CACHE=Optional[new LinkedHashMap<String, DateTimeFormatter>(7) {; ;     private static final long serialVersionUID = 23L;; ;     @Override;     protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest) {;         return size() > PATTERN_CACHE_SIZE;;     }; }
private static int selectStyle(char ch) { [EOL]     switch(ch) { [EOL]         case 'S': [EOL]             return SHORT; [EOL]         case 'M': [EOL]             return MEDIUM; [EOL]         case 'L': [EOL]             return LONG; [EOL]         case 'F': [EOL]             return FULL; [EOL]         case '-': [EOL]             return NONE; [EOL]         default: [EOL]             throw new IllegalArgumentException("Invalid style character: " + ch); [EOL]     } [EOL] } protected DateTimeFormat();  StyleFormatter(int dateStyle, int timeStyle, int type); protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest); public static DateTimeFormatter forPattern(String pattern); public static DateTimeFormatter forStyle(String style); public static String patternForStyle(String style, Locale locale); public static DateTimeFormatter shortDate(); public static DateTimeFormatter shortTime(); public static DateTimeFormatter shortDateTime(); public static DateTimeFormatter mediumDate(); public static DateTimeFormatter mediumTime(); public static DateTimeFormatter mediumDateTime(); public static DateTimeFormatter longDate(); public static DateTimeFormatter longTime(); public static DateTimeFormatter longDateTime(); public static DateTimeFormatter fullDate(); public static DateTimeFormatter fullTime(); public static DateTimeFormatter fullDateTime();  static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern); private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern); private static String parseToken(String pattern, int[] indexRef); private static boolean isNumericToken(String token); private static DateTimeFormatter createFormatterForPattern(String pattern); private static DateTimeFormatter createFormatterForStyle(String style); private static DateTimeFormatter createFormatterForStyleIndex(int dateStyle, int timeStyle); private static DateTimeFormatter createDateTimeFormatter(int dateStyle, int timeStyle); private static int selectStyle(char ch); public int estimatePrintedLength(); public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale); public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException; public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale); public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException; public int estimateParsedLength(); public int parseInto(DateTimeParserBucket bucket, String text, int position); private DateTimeFormatter getFormatter(Locale locale);  String getPattern(Locale locale); int FULL=Optional[0]; int LONG=Optional[1]; int MEDIUM=Optional[2]; int SHORT=Optional[3]; int NONE=Optional[4]; int DATE=Optional[0]; int TIME=Optional[1]; int DATETIME=Optional[2]; int PATTERN_CACHE_SIZE=Optional[500]; Map<String, DateTimeFormatter> PATTERN_CACHE=Optional[new LinkedHashMap<String, DateTimeFormatter>(7) {; ;     private static final long serialVersionUID = 23L;; ;     @Override;     protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest) {;         return size() > PATTERN_CACHE_SIZE;;     }; }
private static int selectStyle(char ch) { [EOL]     switch(ch) { [EOL]         case 'S': [EOL]             return SHORT; [EOL]         case 'M': [EOL]             return MEDIUM; [EOL]         case 'L': [EOL]             return LONG; [EOL]         case 'F': [EOL]             return FULL; [EOL]         case '-': [EOL]             return NONE; [EOL]         default: [EOL]             throw new IllegalArgumentException("Invalid style character: " + ch); [EOL]     } [EOL] } protected DateTimeFormat();  StyleFormatter(int dateStyle, int timeStyle, int type); protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest); public static DateTimeFormatter forPattern(String pattern); public static DateTimeFormatter forStyle(String style); public static String patternForStyle(String style, Locale locale); public static DateTimeFormatter shortDate(); public static DateTimeFormatter shortTime(); public static DateTimeFormatter shortDateTime(); public static DateTimeFormatter mediumDate(); public static DateTimeFormatter mediumTime(); public static DateTimeFormatter mediumDateTime(); public static DateTimeFormatter longDate(); public static DateTimeFormatter longTime(); public static DateTimeFormatter longDateTime(); public static DateTimeFormatter fullDate(); public static DateTimeFormatter fullTime(); public static DateTimeFormatter fullDateTime();  static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern); private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern); private static String parseToken(String pattern, int[] indexRef); private static boolean isNumericToken(String token); private static DateTimeFormatter createFormatterForPattern(String pattern); private static DateTimeFormatter createFormatterForStyle(String style); private static DateTimeFormatter createFormatterForStyleIndex(int dateStyle, int timeStyle); private static DateTimeFormatter createDateTimeFormatter(int dateStyle, int timeStyle); private static int selectStyle(char ch); public int estimatePrintedLength(); public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale); public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException; public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale); public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException; public int estimateParsedLength(); public int parseInto(DateTimeParserBucket bucket, String text, int position); private DateTimeFormatter getFormatter(Locale locale);  String getPattern(Locale locale); int FULL=Optional[0]; int LONG=Optional[1]; int MEDIUM=Optional[2]; int SHORT=Optional[3]; int NONE=Optional[4]; int DATE=Optional[0]; int TIME=Optional[1]; int DATETIME=Optional[2]; int PATTERN_CACHE_SIZE=Optional[500]; Map<String, DateTimeFormatter> PATTERN_CACHE=Optional[new LinkedHashMap<String, DateTimeFormatter>(7) {; ;     private static final long serialVersionUID = 23L;; ;     @Override;     protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest) {;         return size() > PATTERN_CACHE_SIZE;;     }; }
private static int selectStyle(char ch) { [EOL]     switch(ch) { [EOL]         case 'S': [EOL]             return SHORT; [EOL]         case 'M': [EOL]             return MEDIUM; [EOL]         case 'L': [EOL]             return LONG; [EOL]         case 'F': [EOL]             return FULL; [EOL]         case '-': [EOL]             return NONE; [EOL]         default: [EOL]             throw new IllegalArgumentException("Invalid style character: " + ch); [EOL]     } [EOL] } protected DateTimeFormat();  StyleFormatter(int dateStyle, int timeStyle, int type); protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest); public static DateTimeFormatter forPattern(String pattern); public static DateTimeFormatter forStyle(String style); public static String patternForStyle(String style, Locale locale); public static DateTimeFormatter shortDate(); public static DateTimeFormatter shortTime(); public static DateTimeFormatter shortDateTime(); public static DateTimeFormatter mediumDate(); public static DateTimeFormatter mediumTime(); public static DateTimeFormatter mediumDateTime(); public static DateTimeFormatter longDate(); public static DateTimeFormatter longTime(); public static DateTimeFormatter longDateTime(); public static DateTimeFormatter fullDate(); public static DateTimeFormatter fullTime(); public static DateTimeFormatter fullDateTime();  static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern); private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern); private static String parseToken(String pattern, int[] indexRef); private static boolean isNumericToken(String token); private static DateTimeFormatter createFormatterForPattern(String pattern); private static DateTimeFormatter createFormatterForStyle(String style); private static DateTimeFormatter createFormatterForStyleIndex(int dateStyle, int timeStyle); private static DateTimeFormatter createDateTimeFormatter(int dateStyle, int timeStyle); private static int selectStyle(char ch); public int estimatePrintedLength(); public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale); public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException; public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale); public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException; public int estimateParsedLength(); public int parseInto(DateTimeParserBucket bucket, String text, int position); private DateTimeFormatter getFormatter(Locale locale);  String getPattern(Locale locale); int FULL=Optional[0]; int LONG=Optional[1]; int MEDIUM=Optional[2]; int SHORT=Optional[3]; int NONE=Optional[4]; int DATE=Optional[0]; int TIME=Optional[1]; int DATETIME=Optional[2]; int PATTERN_CACHE_SIZE=Optional[500]; Map<String, DateTimeFormatter> PATTERN_CACHE=Optional[new LinkedHashMap<String, DateTimeFormatter>(7) {; ;     private static final long serialVersionUID = 23L;; ;     @Override;     protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest) {;         return size() > PATTERN_CACHE_SIZE;;     }; }
private static int selectStyle(char ch) { [EOL]     switch(ch) { [EOL]         case 'S': [EOL]             return SHORT; [EOL]         case 'M': [EOL]             return MEDIUM; [EOL]         case 'L': [EOL]             return LONG; [EOL]         case 'F': [EOL]             return FULL; [EOL]         case '-': [EOL]             return NONE; [EOL]         default: [EOL]             throw new IllegalArgumentException("Invalid style character: " + ch); [EOL]     } [EOL] } protected DateTimeFormat();  StyleFormatter(int dateStyle, int timeStyle, int type); protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest); public static DateTimeFormatter forPattern(String pattern); public static DateTimeFormatter forStyle(String style); public static String patternForStyle(String style, Locale locale); public static DateTimeFormatter shortDate(); public static DateTimeFormatter shortTime(); public static DateTimeFormatter shortDateTime(); public static DateTimeFormatter mediumDate(); public static DateTimeFormatter mediumTime(); public static DateTimeFormatter mediumDateTime(); public static DateTimeFormatter longDate(); public static DateTimeFormatter longTime(); public static DateTimeFormatter longDateTime(); public static DateTimeFormatter fullDate(); public static DateTimeFormatter fullTime(); public static DateTimeFormatter fullDateTime();  static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern); private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern); private static String parseToken(String pattern, int[] indexRef); private static boolean isNumericToken(String token); private static DateTimeFormatter createFormatterForPattern(String pattern); private static DateTimeFormatter createFormatterForStyle(String style); private static DateTimeFormatter createFormatterForStyleIndex(int dateStyle, int timeStyle); private static DateTimeFormatter createDateTimeFormatter(int dateStyle, int timeStyle); private static int selectStyle(char ch); public int estimatePrintedLength(); public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale); public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException; public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale); public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException; public int estimateParsedLength(); public int parseInto(DateTimeParserBucket bucket, String text, int position); private DateTimeFormatter getFormatter(Locale locale);  String getPattern(Locale locale); int FULL=Optional[0]; int LONG=Optional[1]; int MEDIUM=Optional[2]; int SHORT=Optional[3]; int NONE=Optional[4]; int DATE=Optional[0]; int TIME=Optional[1]; int DATETIME=Optional[2]; int PATTERN_CACHE_SIZE=Optional[500]; Map<String, DateTimeFormatter> PATTERN_CACHE=Optional[new LinkedHashMap<String, DateTimeFormatter>(7) {; ;     private static final long serialVersionUID = 23L;; ;     @Override;     protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest) {;         return size() > PATTERN_CACHE_SIZE;;     }; }
private static int selectStyle(char ch) { [EOL]     switch(ch) { [EOL]         case 'S': [EOL]             return SHORT; [EOL]         case 'M': [EOL]             return MEDIUM; [EOL]         case 'L': [EOL]             return LONG; [EOL]         case 'F': [EOL]             return FULL; [EOL]         case '-': [EOL]             return NONE; [EOL]         default: [EOL]             throw new IllegalArgumentException("Invalid style character: " + ch); [EOL]     } [EOL] } protected DateTimeFormat();  StyleFormatter(int dateStyle, int timeStyle, int type); protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest); public static DateTimeFormatter forPattern(String pattern); public static DateTimeFormatter forStyle(String style); public static String patternForStyle(String style, Locale locale); public static DateTimeFormatter shortDate(); public static DateTimeFormatter shortTime(); public static DateTimeFormatter shortDateTime(); public static DateTimeFormatter mediumDate(); public static DateTimeFormatter mediumTime(); public static DateTimeFormatter mediumDateTime(); public static DateTimeFormatter longDate(); public static DateTimeFormatter longTime(); public static DateTimeFormatter longDateTime(); public static DateTimeFormatter fullDate(); public static DateTimeFormatter fullTime(); public static DateTimeFormatter fullDateTime();  static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern); private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern); private static String parseToken(String pattern, int[] indexRef); private static boolean isNumericToken(String token); private static DateTimeFormatter createFormatterForPattern(String pattern); private static DateTimeFormatter createFormatterForStyle(String style); private static DateTimeFormatter createFormatterForStyleIndex(int dateStyle, int timeStyle); private static DateTimeFormatter createDateTimeFormatter(int dateStyle, int timeStyle); private static int selectStyle(char ch); public int estimatePrintedLength(); public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale); public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException; public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale); public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException; public int estimateParsedLength(); public int parseInto(DateTimeParserBucket bucket, String text, int position); private DateTimeFormatter getFormatter(Locale locale);  String getPattern(Locale locale); int FULL=Optional[0]; int LONG=Optional[1]; int MEDIUM=Optional[2]; int SHORT=Optional[3]; int NONE=Optional[4]; int DATE=Optional[0]; int TIME=Optional[1]; int DATETIME=Optional[2]; int PATTERN_CACHE_SIZE=Optional[500]; Map<String, DateTimeFormatter> PATTERN_CACHE=Optional[new LinkedHashMap<String, DateTimeFormatter>(7) {; ;     private static final long serialVersionUID = 23L;; ;     @Override;     protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest) {;         return size() > PATTERN_CACHE_SIZE;;     }; }
public static Duration standardSeconds(long seconds) { [EOL]     if (seconds == 0) { [EOL]         return ZERO; [EOL]     } [EOL]     return new Duration(FieldUtils.safeMultiply(seconds, DateTimeConstants.MILLIS_PER_SECOND)); [EOL] }
public static Duration standardSeconds(long seconds) { [EOL]     if (seconds == 0) { [EOL]         return ZERO; [EOL]     } [EOL]     return new Duration(FieldUtils.safeMultiply(seconds, DateTimeConstants.MILLIS_PER_SECOND)); [EOL] }
public static Duration standardSeconds(long seconds) { [EOL]     if (seconds == 0) { [EOL]         return ZERO; [EOL]     } [EOL]     return new Duration(FieldUtils.safeMultiply(seconds, DateTimeConstants.MILLIS_PER_SECOND)); [EOL] }
public static Duration millis(long millis) { [EOL]     if (millis == 0) { [EOL]         return ZERO; [EOL]     } [EOL]     return new Duration(millis); [EOL] }
public static Duration millis(long millis) { [EOL]     if (millis == 0) { [EOL]         return ZERO; [EOL]     } [EOL]     return new Duration(millis); [EOL] }
public static Duration millis(long millis) { [EOL]     if (millis == 0) { [EOL]         return ZERO; [EOL]     } [EOL]     return new Duration(millis); [EOL] }
public Duration toDuration() { [EOL]     return this; [EOL] }
public Duration withDurationAdded(long durationToAdd, int scalar) { [EOL]     if (durationToAdd == 0 || scalar == 0) { [EOL]         return this; [EOL]     } [EOL]     long add = FieldUtils.safeMultiply(durationToAdd, scalar); [EOL]     long duration = FieldUtils.safeAdd(getMillis(), add); [EOL]     return new Duration(duration); [EOL] }
public Duration withDurationAdded(long durationToAdd, int scalar) { [EOL]     if (durationToAdd == 0 || scalar == 0) { [EOL]         return this; [EOL]     } [EOL]     long add = FieldUtils.safeMultiply(durationToAdd, scalar); [EOL]     long duration = FieldUtils.safeAdd(getMillis(), add); [EOL]     return new Duration(duration); [EOL] }
public Duration plus(ReadableDuration amount) { [EOL]     if (amount == null) { [EOL]         return this; [EOL]     } [EOL]     return withDurationAdded(amount.getMillis(), 1); [EOL] }
public Duration plus(ReadableDuration amount) { [EOL]     if (amount == null) { [EOL]         return this; [EOL]     } [EOL]     return withDurationAdded(amount.getMillis(), 1); [EOL] }
public Duration multipliedBy(long multiplicand) { [EOL]     if (multiplicand == 1) { [EOL]         return this; [EOL]     } [EOL]     return new Duration(FieldUtils.safeMultiply(getMillis(), multiplicand)); [EOL] }
public Duration multipliedBy(long multiplicand) { [EOL]     if (multiplicand == 1) { [EOL]         return this; [EOL]     } [EOL]     return new Duration(FieldUtils.safeMultiply(getMillis(), multiplicand)); [EOL] }
public Duration multipliedBy(long multiplicand) { [EOL]     if (multiplicand == 1) { [EOL]         return this; [EOL]     } [EOL]     return new Duration(FieldUtils.safeMultiply(getMillis(), multiplicand)); [EOL] }
public Duration multipliedBy(long multiplicand) { [EOL]     if (multiplicand == 1) { [EOL]         return this; [EOL]     } [EOL]     return new Duration(FieldUtils.safeMultiply(getMillis(), multiplicand)); [EOL] }
public static PeriodFormatter alternateExtended() { [EOL]     if (cAlternateExtended == null) { [EOL]         cAlternateExtended = new PeriodFormatterBuilder().appendLiteral("P").printZeroAlways().minimumPrintedDigits(4).appendYears().appendSeparator("-").minimumPrintedDigits(2).appendMonths().appendSeparator("-").appendDays().appendSeparatorIfFieldsAfter("T").appendHours().appendSeparator(":").appendMinutes().appendSeparator(":").appendSecondsWithOptionalMillis().toFormatter(); [EOL]     } [EOL]     return cAlternateExtended; [EOL] }
public static PeriodFormatter alternateExtended() { [EOL]     if (cAlternateExtended == null) { [EOL]         cAlternateExtended = new PeriodFormatterBuilder().appendLiteral("P").printZeroAlways().minimumPrintedDigits(4).appendYears().appendSeparator("-").minimumPrintedDigits(2).appendMonths().appendSeparator("-").appendDays().appendSeparatorIfFieldsAfter("T").appendHours().appendSeparator(":").appendMinutes().appendSeparator(":").appendSecondsWithOptionalMillis().toFormatter(); [EOL]     } [EOL]     return cAlternateExtended; [EOL] }
public int get(long instant) { [EOL]     int value = getWrappedField().get(instant); [EOL]     if (value == 0) { [EOL]         value = getMaximumValue(); [EOL]     } [EOL]     return value; [EOL] }
public int get(long instant) { [EOL]     int value = getWrappedField().get(instant); [EOL]     if (value == 0) { [EOL]         value = getMaximumValue(); [EOL]     } [EOL]     return value; [EOL] }
public int getMaximumValue() { [EOL]     return getWrappedField().getMaximumValue() + 1; [EOL] }
public static DateTimeZone readFrom(DataInput in, String id) throws IOException { [EOL]     switch(in.readUnsignedByte()) { [EOL]         case 'F': [EOL]             DateTimeZone fixed = new FixedDateTimeZone(id, in.readUTF(), (int) readMillis(in), (int) readMillis(in)); [EOL]             if (fixed.equals(DateTimeZone.UTC)) { [EOL]                 fixed = DateTimeZone.UTC; [EOL]             } [EOL]             return fixed; [EOL]         case 'C': [EOL]             return CachedDateTimeZone.forZone(PrecalculatedZone.readFrom(in, id)); [EOL]         case 'P': [EOL]             return PrecalculatedZone.readFrom(in, id); [EOL]         default: [EOL]             throw new IOException("Invalid encoding"); [EOL]     } [EOL] }
private static DateTimeZone buildFixedZone(String id, String nameKey, int wallOffset, int standardOffset) { [EOL]     if ("UTC".equals(id) && id.equals(nameKey) && wallOffset == 0 && standardOffset == 0) { [EOL]         return DateTimeZone.UTC; [EOL]     } [EOL]     return new FixedDateTimeZone(id, nameKey, wallOffset, standardOffset); [EOL] }
private static DateTimeZone buildFixedZone(String id, String nameKey, int wallOffset, int standardOffset) { [EOL]     if ("UTC".equals(id) && id.equals(nameKey) && wallOffset == 0 && standardOffset == 0) { [EOL]         return DateTimeZone.UTC; [EOL]     } [EOL]     return new FixedDateTimeZone(id, nameKey, wallOffset, standardOffset); [EOL] }
public DateTimeZoneBuilder() { [EOL]     iRuleSets = new ArrayList<RuleSet>(10); [EOL] }
public DateTimeZoneBuilder addCutover(int year, char mode, int monthOfYear, int dayOfMonth, int dayOfWeek, boolean advanceDayOfWeek, int millisOfDay) { [EOL]     if (iRuleSets.size() > 0) { [EOL]         OfYear ofYear = new OfYear(mode, monthOfYear, dayOfMonth, dayOfWeek, advanceDayOfWeek, millisOfDay); [EOL]         RuleSet lastRuleSet = iRuleSets.get(iRuleSets.size() - 1); [EOL]         lastRuleSet.setUpperLimit(year, ofYear); [EOL]     } [EOL]     iRuleSets.add(new RuleSet()); [EOL]     return this; [EOL] }
public DateTimeZoneBuilder addCutover(int year, char mode, int monthOfYear, int dayOfMonth, int dayOfWeek, boolean advanceDayOfWeek, int millisOfDay) { [EOL]     if (iRuleSets.size() > 0) { [EOL]         OfYear ofYear = new OfYear(mode, monthOfYear, dayOfMonth, dayOfWeek, advanceDayOfWeek, millisOfDay); [EOL]         RuleSet lastRuleSet = iRuleSets.get(iRuleSets.size() - 1); [EOL]         lastRuleSet.setUpperLimit(year, ofYear); [EOL]     } [EOL]     iRuleSets.add(new RuleSet()); [EOL]     return this; [EOL] }
public DateTimeZoneBuilder setStandardOffset(int standardOffset) { [EOL]     getLastRuleSet().setStandardOffset(standardOffset); [EOL]     return this; [EOL] }
public DateTimeZoneBuilder setStandardOffset(int standardOffset) { [EOL]     getLastRuleSet().setStandardOffset(standardOffset); [EOL]     return this; [EOL] }
public DateTimeZoneBuilder setStandardOffset(int standardOffset) { [EOL]     getLastRuleSet().setStandardOffset(standardOffset); [EOL]     return this; [EOL] }
public DateTimeZoneBuilder addRecurringSavings(String nameKey, int saveMillis, int fromYear, int toYear, char mode, int monthOfYear, int dayOfMonth, int dayOfWeek, boolean advanceDayOfWeek, int millisOfDay) { [EOL]     if (fromYear <= toYear) { [EOL]         OfYear ofYear = new OfYear(mode, monthOfYear, dayOfMonth, dayOfWeek, advanceDayOfWeek, millisOfDay); [EOL]         Recurrence recurrence = new Recurrence(ofYear, nameKey, saveMillis); [EOL]         Rule rule = new Rule(recurrence, fromYear, toYear); [EOL]         getLastRuleSet().addRule(rule); [EOL]     } [EOL]     return this; [EOL] }
public DateTimeZoneBuilder addRecurringSavings(String nameKey, int saveMillis, int fromYear, int toYear, char mode, int monthOfYear, int dayOfMonth, int dayOfWeek, boolean advanceDayOfWeek, int millisOfDay) { [EOL]     if (fromYear <= toYear) { [EOL]         OfYear ofYear = new OfYear(mode, monthOfYear, dayOfMonth, dayOfWeek, advanceDayOfWeek, millisOfDay); [EOL]         Recurrence recurrence = new Recurrence(ofYear, nameKey, saveMillis); [EOL]         Rule rule = new Rule(recurrence, fromYear, toYear); [EOL]         getLastRuleSet().addRule(rule); [EOL]     } [EOL]     return this; [EOL] }
public DateTimeZoneBuilder addRecurringSavings(String nameKey, int saveMillis, int fromYear, int toYear, char mode, int monthOfYear, int dayOfMonth, int dayOfWeek, boolean advanceDayOfWeek, int millisOfDay) { [EOL]     if (fromYear <= toYear) { [EOL]         OfYear ofYear = new OfYear(mode, monthOfYear, dayOfMonth, dayOfWeek, advanceDayOfWeek, millisOfDay); [EOL]         Recurrence recurrence = new Recurrence(ofYear, nameKey, saveMillis); [EOL]         Rule rule = new Rule(recurrence, fromYear, toYear); [EOL]         getLastRuleSet().addRule(rule); [EOL]     } [EOL]     return this; [EOL] }
private RuleSet getLastRuleSet() { [EOL]     if (iRuleSets.size() == 0) { [EOL]         addCutover(Integer.MIN_VALUE, 'w', 1, 1, 0, false, 0); [EOL]     } [EOL]     return iRuleSets.get(iRuleSets.size() - 1); [EOL] }
private RuleSet getLastRuleSet() { [EOL]     if (iRuleSets.size() == 0) { [EOL]         addCutover(Integer.MIN_VALUE, 'w', 1, 1, 0, false, 0); [EOL]     } [EOL]     return iRuleSets.get(iRuleSets.size() - 1); [EOL] }
public DateTimeZone toDateTimeZone(String id, boolean outputID) { [EOL]     if (id == null) { [EOL]         throw new IllegalArgumentException(); [EOL]     } [EOL]     ArrayList<Transition> transitions = new ArrayList<Transition>(); [EOL]     DSTZone tailZone = null; [EOL]     long millis = Long.MIN_VALUE; [EOL]     int saveMillis = 0; [EOL]     int ruleSetCount = iRuleSets.size(); [EOL]     for (int i = 0; i < ruleSetCount; i++) { [EOL]         RuleSet rs = iRuleSets.get(i); [EOL]         Transition next = rs.firstTransition(millis); [EOL]         if (next == null) { [EOL]             continue; [EOL]         } [EOL]         addTransition(transitions, next); [EOL]         millis = next.getMillis(); [EOL]         saveMillis = next.getSaveMillis(); [EOL]         rs = new RuleSet(rs); [EOL]         while ((next = rs.nextTransition(millis, saveMillis)) != null) { [EOL]             if (addTransition(transitions, next)) { [EOL]                 if (tailZone != null) { [EOL]                     break; [EOL]                 } [EOL]             } [EOL]             millis = next.getMillis(); [EOL]             saveMillis = next.getSaveMillis(); [EOL]             if (tailZone == null && i == ruleSetCount - 1) { [EOL]                 tailZone = rs.buildTailZone(id); [EOL]             } [EOL]         } [EOL]         millis = rs.getUpperLimit(saveMillis); [EOL]     } [EOL]     if (transitions.size() == 0) { [EOL]         if (tailZone != null) { [EOL]             return tailZone; [EOL]         } [EOL]         return buildFixedZone(id, "UTC", 0, 0); [EOL]     } [EOL]     if (transitions.size() == 1 && tailZone == null) { [EOL]         Transition tr = transitions.get(0); [EOL]         return buildFixedZone(id, tr.getNameKey(), tr.getWallOffset(), tr.getStandardOffset()); [EOL]     } [EOL]     PrecalculatedZone zone = PrecalculatedZone.create(id, outputID, transitions, tailZone); [EOL]     if (zone.isCachable()) { [EOL]         return CachedDateTimeZone.forZone(zone); [EOL]     } [EOL]     return zone; [EOL] }
public DateTimeZone toDateTimeZone(String id, boolean outputID) { [EOL]     if (id == null) { [EOL]         throw new IllegalArgumentException(); [EOL]     } [EOL]     ArrayList<Transition> transitions = new ArrayList<Transition>(); [EOL]     DSTZone tailZone = null; [EOL]     long millis = Long.MIN_VALUE; [EOL]     int saveMillis = 0; [EOL]     int ruleSetCount = iRuleSets.size(); [EOL]     for (int i = 0; i < ruleSetCount; i++) { [EOL]         RuleSet rs = iRuleSets.get(i); [EOL]         Transition next = rs.firstTransition(millis); [EOL]         if (next == null) { [EOL]             continue; [EOL]         } [EOL]         addTransition(transitions, next); [EOL]         millis = next.getMillis(); [EOL]         saveMillis = next.getSaveMillis(); [EOL]         rs = new RuleSet(rs); [EOL]         while ((next = rs.nextTransition(millis, saveMillis)) != null) { [EOL]             if (addTransition(transitions, next)) { [EOL]                 if (tailZone != null) { [EOL]                     break; [EOL]                 } [EOL]             } [EOL]             millis = next.getMillis(); [EOL]             saveMillis = next.getSaveMillis(); [EOL]             if (tailZone == null && i == ruleSetCount - 1) { [EOL]                 tailZone = rs.buildTailZone(id); [EOL]             } [EOL]         } [EOL]         millis = rs.getUpperLimit(saveMillis); [EOL]     } [EOL]     if (transitions.size() == 0) { [EOL]         if (tailZone != null) { [EOL]             return tailZone; [EOL]         } [EOL]         return buildFixedZone(id, "UTC", 0, 0); [EOL]     } [EOL]     if (transitions.size() == 1 && tailZone == null) { [EOL]         Transition tr = transitions.get(0); [EOL]         return buildFixedZone(id, tr.getNameKey(), tr.getWallOffset(), tr.getStandardOffset()); [EOL]     } [EOL]     PrecalculatedZone zone = PrecalculatedZone.create(id, outputID, transitions, tailZone); [EOL]     if (zone.isCachable()) { [EOL]         return CachedDateTimeZone.forZone(zone); [EOL]     } [EOL]     return zone; [EOL] }
public DateTimeZone toDateTimeZone(String id, boolean outputID) { [EOL]     if (id == null) { [EOL]         throw new IllegalArgumentException(); [EOL]     } [EOL]     ArrayList<Transition> transitions = new ArrayList<Transition>(); [EOL]     DSTZone tailZone = null; [EOL]     long millis = Long.MIN_VALUE; [EOL]     int saveMillis = 0; [EOL]     int ruleSetCount = iRuleSets.size(); [EOL]     for (int i = 0; i < ruleSetCount; i++) { [EOL]         RuleSet rs = iRuleSets.get(i); [EOL]         Transition next = rs.firstTransition(millis); [EOL]         if (next == null) { [EOL]             continue; [EOL]         } [EOL]         addTransition(transitions, next); [EOL]         millis = next.getMillis(); [EOL]         saveMillis = next.getSaveMillis(); [EOL]         rs = new RuleSet(rs); [EOL]         while ((next = rs.nextTransition(millis, saveMillis)) != null) { [EOL]             if (addTransition(transitions, next)) { [EOL]                 if (tailZone != null) { [EOL]                     break; [EOL]                 } [EOL]             } [EOL]             millis = next.getMillis(); [EOL]             saveMillis = next.getSaveMillis(); [EOL]             if (tailZone == null && i == ruleSetCount - 1) { [EOL]                 tailZone = rs.buildTailZone(id); [EOL]             } [EOL]         } [EOL]         millis = rs.getUpperLimit(saveMillis); [EOL]     } [EOL]     if (transitions.size() == 0) { [EOL]         if (tailZone != null) { [EOL]             return tailZone; [EOL]         } [EOL]         return buildFixedZone(id, "UTC", 0, 0); [EOL]     } [EOL]     if (transitions.size() == 1 && tailZone == null) { [EOL]         Transition tr = transitions.get(0); [EOL]         return buildFixedZone(id, tr.getNameKey(), tr.getWallOffset(), tr.getStandardOffset()); [EOL]     } [EOL]     PrecalculatedZone zone = PrecalculatedZone.create(id, outputID, transitions, tailZone); [EOL]     if (zone.isCachable()) { [EOL]         return CachedDateTimeZone.forZone(zone); [EOL]     } [EOL]     return zone; [EOL] }
public DateTimeZone toDateTimeZone(String id, boolean outputID) { [EOL]     if (id == null) { [EOL]         throw new IllegalArgumentException(); [EOL]     } [EOL]     ArrayList<Transition> transitions = new ArrayList<Transition>(); [EOL]     DSTZone tailZone = null; [EOL]     long millis = Long.MIN_VALUE; [EOL]     int saveMillis = 0; [EOL]     int ruleSetCount = iRuleSets.size(); [EOL]     for (int i = 0; i < ruleSetCount; i++) { [EOL]         RuleSet rs = iRuleSets.get(i); [EOL]         Transition next = rs.firstTransition(millis); [EOL]         if (next == null) { [EOL]             continue; [EOL]         } [EOL]         addTransition(transitions, next); [EOL]         millis = next.getMillis(); [EOL]         saveMillis = next.getSaveMillis(); [EOL]         rs = new RuleSet(rs); [EOL]         while ((next = rs.nextTransition(millis, saveMillis)) != null) { [EOL]             if (addTransition(transitions, next)) { [EOL]                 if (tailZone != null) { [EOL]                     break; [EOL]                 } [EOL]             } [EOL]             millis = next.getMillis(); [EOL]             saveMillis = next.getSaveMillis(); [EOL]             if (tailZone == null && i == ruleSetCount - 1) { [EOL]                 tailZone = rs.buildTailZone(id); [EOL]             } [EOL]         } [EOL]         millis = rs.getUpperLimit(saveMillis); [EOL]     } [EOL]     if (transitions.size() == 0) { [EOL]         if (tailZone != null) { [EOL]             return tailZone; [EOL]         } [EOL]         return buildFixedZone(id, "UTC", 0, 0); [EOL]     } [EOL]     if (transitions.size() == 1 && tailZone == null) { [EOL]         Transition tr = transitions.get(0); [EOL]         return buildFixedZone(id, tr.getNameKey(), tr.getWallOffset(), tr.getStandardOffset()); [EOL]     } [EOL]     PrecalculatedZone zone = PrecalculatedZone.create(id, outputID, transitions, tailZone); [EOL]     if (zone.isCachable()) { [EOL]         return CachedDateTimeZone.forZone(zone); [EOL]     } [EOL]     return zone; [EOL] }
public DateTimeZone toDateTimeZone(String id, boolean outputID) { [EOL]     if (id == null) { [EOL]         throw new IllegalArgumentException(); [EOL]     } [EOL]     ArrayList<Transition> transitions = new ArrayList<Transition>(); [EOL]     DSTZone tailZone = null; [EOL]     long millis = Long.MIN_VALUE; [EOL]     int saveMillis = 0; [EOL]     int ruleSetCount = iRuleSets.size(); [EOL]     for (int i = 0; i < ruleSetCount; i++) { [EOL]         RuleSet rs = iRuleSets.get(i); [EOL]         Transition next = rs.firstTransition(millis); [EOL]         if (next == null) { [EOL]             continue; [EOL]         } [EOL]         addTransition(transitions, next); [EOL]         millis = next.getMillis(); [EOL]         saveMillis = next.getSaveMillis(); [EOL]         rs = new RuleSet(rs); [EOL]         while ((next = rs.nextTransition(millis, saveMillis)) != null) { [EOL]             if (addTransition(transitions, next)) { [EOL]                 if (tailZone != null) { [EOL]                     break; [EOL]                 } [EOL]             } [EOL]             millis = next.getMillis(); [EOL]             saveMillis = next.getSaveMillis(); [EOL]             if (tailZone == null && i == ruleSetCount - 1) { [EOL]                 tailZone = rs.buildTailZone(id); [EOL]             } [EOL]         } [EOL]         millis = rs.getUpperLimit(saveMillis); [EOL]     } [EOL]     if (transitions.size() == 0) { [EOL]         if (tailZone != null) { [EOL]             return tailZone; [EOL]         } [EOL]         return buildFixedZone(id, "UTC", 0, 0); [EOL]     } [EOL]     if (transitions.size() == 1 && tailZone == null) { [EOL]         Transition tr = transitions.get(0); [EOL]         return buildFixedZone(id, tr.getNameKey(), tr.getWallOffset(), tr.getStandardOffset()); [EOL]     } [EOL]     PrecalculatedZone zone = PrecalculatedZone.create(id, outputID, transitions, tailZone); [EOL]     if (zone.isCachable()) { [EOL]         return CachedDateTimeZone.forZone(zone); [EOL]     } [EOL]     return zone; [EOL] }
public DateTimeZone toDateTimeZone(String id, boolean outputID) { [EOL]     if (id == null) { [EOL]         throw new IllegalArgumentException(); [EOL]     } [EOL]     ArrayList<Transition> transitions = new ArrayList<Transition>(); [EOL]     DSTZone tailZone = null; [EOL]     long millis = Long.MIN_VALUE; [EOL]     int saveMillis = 0; [EOL]     int ruleSetCount = iRuleSets.size(); [EOL]     for (int i = 0; i < ruleSetCount; i++) { [EOL]         RuleSet rs = iRuleSets.get(i); [EOL]         Transition next = rs.firstTransition(millis); [EOL]         if (next == null) { [EOL]             continue; [EOL]         } [EOL]         addTransition(transitions, next); [EOL]         millis = next.getMillis(); [EOL]         saveMillis = next.getSaveMillis(); [EOL]         rs = new RuleSet(rs); [EOL]         while ((next = rs.nextTransition(millis, saveMillis)) != null) { [EOL]             if (addTransition(transitions, next)) { [EOL]                 if (tailZone != null) { [EOL]                     break; [EOL]                 } [EOL]             } [EOL]             millis = next.getMillis(); [EOL]             saveMillis = next.getSaveMillis(); [EOL]             if (tailZone == null && i == ruleSetCount - 1) { [EOL]                 tailZone = rs.buildTailZone(id); [EOL]             } [EOL]         } [EOL]         millis = rs.getUpperLimit(saveMillis); [EOL]     } [EOL]     if (transitions.size() == 0) { [EOL]         if (tailZone != null) { [EOL]             return tailZone; [EOL]         } [EOL]         return buildFixedZone(id, "UTC", 0, 0); [EOL]     } [EOL]     if (transitions.size() == 1 && tailZone == null) { [EOL]         Transition tr = transitions.get(0); [EOL]         return buildFixedZone(id, tr.getNameKey(), tr.getWallOffset(), tr.getStandardOffset()); [EOL]     } [EOL]     PrecalculatedZone zone = PrecalculatedZone.create(id, outputID, transitions, tailZone); [EOL]     if (zone.isCachable()) { [EOL]         return CachedDateTimeZone.forZone(zone); [EOL]     } [EOL]     return zone; [EOL] }
private boolean addTransition(ArrayList<Transition> transitions, Transition tr) { [EOL]     int size = transitions.size(); [EOL]     if (size == 0) { [EOL]         transitions.add(tr); [EOL]         return true; [EOL]     } [EOL]     Transition last = transitions.get(size - 1); [EOL]     if (!tr.isTransitionFrom(last)) { [EOL]         return false; [EOL]     } [EOL]     int offsetForLast = 0; [EOL]     if (size >= 2) { [EOL]         offsetForLast = transitions.get(size - 2).getWallOffset(); [EOL]     } [EOL]     int offsetForNew = last.getWallOffset(); [EOL]     long lastLocal = last.getMillis() + offsetForLast; [EOL]     long newLocal = tr.getMillis() + offsetForNew; [EOL]     if (newLocal != lastLocal) { [EOL]         transitions.add(tr); [EOL]         return true; [EOL]     } [EOL]     transitions.remove(size - 1); [EOL]     return addTransition(transitions, tr); [EOL] }
private boolean addTransition(ArrayList<Transition> transitions, Transition tr) { [EOL]     int size = transitions.size(); [EOL]     if (size == 0) { [EOL]         transitions.add(tr); [EOL]         return true; [EOL]     } [EOL]     Transition last = transitions.get(size - 1); [EOL]     if (!tr.isTransitionFrom(last)) { [EOL]         return false; [EOL]     } [EOL]     int offsetForLast = 0; [EOL]     if (size >= 2) { [EOL]         offsetForLast = transitions.get(size - 2).getWallOffset(); [EOL]     } [EOL]     int offsetForNew = last.getWallOffset(); [EOL]     long lastLocal = last.getMillis() + offsetForLast; [EOL]     long newLocal = tr.getMillis() + offsetForNew; [EOL]     if (newLocal != lastLocal) { [EOL]         transitions.add(tr); [EOL]         return true; [EOL]     } [EOL]     transitions.remove(size - 1); [EOL]     return addTransition(transitions, tr); [EOL] }
private boolean addTransition(ArrayList<Transition> transitions, Transition tr) { [EOL]     int size = transitions.size(); [EOL]     if (size == 0) { [EOL]         transitions.add(tr); [EOL]         return true; [EOL]     } [EOL]     Transition last = transitions.get(size - 1); [EOL]     if (!tr.isTransitionFrom(last)) { [EOL]         return false; [EOL]     } [EOL]     int offsetForLast = 0; [EOL]     if (size >= 2) { [EOL]         offsetForLast = transitions.get(size - 2).getWallOffset(); [EOL]     } [EOL]     int offsetForNew = last.getWallOffset(); [EOL]     long lastLocal = last.getMillis() + offsetForLast; [EOL]     long newLocal = tr.getMillis() + offsetForNew; [EOL]     if (newLocal != lastLocal) { [EOL]         transitions.add(tr); [EOL]         return true; [EOL]     } [EOL]     transitions.remove(size - 1); [EOL]     return addTransition(transitions, tr); [EOL] }
private boolean addTransition(ArrayList<Transition> transitions, Transition tr) { [EOL]     int size = transitions.size(); [EOL]     if (size == 0) { [EOL]         transitions.add(tr); [EOL]         return true; [EOL]     } [EOL]     Transition last = transitions.get(size - 1); [EOL]     if (!tr.isTransitionFrom(last)) { [EOL]         return false; [EOL]     } [EOL]     int offsetForLast = 0; [EOL]     if (size >= 2) { [EOL]         offsetForLast = transitions.get(size - 2).getWallOffset(); [EOL]     } [EOL]     int offsetForNew = last.getWallOffset(); [EOL]     long lastLocal = last.getMillis() + offsetForLast; [EOL]     long newLocal = tr.getMillis() + offsetForNew; [EOL]     if (newLocal != lastLocal) { [EOL]         transitions.add(tr); [EOL]         return true; [EOL]     } [EOL]     transitions.remove(size - 1); [EOL]     return addTransition(transitions, tr); [EOL] }
public void writeTo(String zoneID, DataOutput out) throws IOException { [EOL]     DateTimeZone zone = toDateTimeZone(zoneID, false); [EOL]     if (zone instanceof FixedDateTimeZone) { [EOL]         out.writeByte('F'); [EOL]         out.writeUTF(zone.getNameKey(0)); [EOL]         writeMillis(out, zone.getOffset(0)); [EOL]         writeMillis(out, zone.getStandardOffset(0)); [EOL]     } else { [EOL]         if (zone instanceof CachedDateTimeZone) { [EOL]             out.writeByte('C'); [EOL]             zone = ((CachedDateTimeZone) zone).getUncachedZone(); [EOL]         } else { [EOL]             out.writeByte('P'); [EOL]         } [EOL]         ((PrecalculatedZone) zone).writeTo(out); [EOL]     } [EOL] }
public void writeTo(String zoneID, DataOutput out) throws IOException { [EOL]     DateTimeZone zone = toDateTimeZone(zoneID, false); [EOL]     if (zone instanceof FixedDateTimeZone) { [EOL]         out.writeByte('F'); [EOL]         out.writeUTF(zone.getNameKey(0)); [EOL]         writeMillis(out, zone.getOffset(0)); [EOL]         writeMillis(out, zone.getStandardOffset(0)); [EOL]     } else { [EOL]         if (zone instanceof CachedDateTimeZone) { [EOL]             out.writeByte('C'); [EOL]             zone = ((CachedDateTimeZone) zone).getUncachedZone(); [EOL]         } else { [EOL]             out.writeByte('P'); [EOL]         } [EOL]         ((PrecalculatedZone) zone).writeTo(out); [EOL]     } [EOL] }
public void writeTo(String zoneID, DataOutput out) throws IOException { [EOL]     DateTimeZone zone = toDateTimeZone(zoneID, false); [EOL]     if (zone instanceof FixedDateTimeZone) { [EOL]         out.writeByte('F'); [EOL]         out.writeUTF(zone.getNameKey(0)); [EOL]         writeMillis(out, zone.getOffset(0)); [EOL]         writeMillis(out, zone.getStandardOffset(0)); [EOL]     } else { [EOL]         if (zone instanceof CachedDateTimeZone) { [EOL]             out.writeByte('C'); [EOL]             zone = ((CachedDateTimeZone) zone).getUncachedZone(); [EOL]         } else { [EOL]             out.writeByte('P'); [EOL]         } [EOL]         ((PrecalculatedZone) zone).writeTo(out); [EOL]     } [EOL] }
OfYear(char mode, int monthOfYear, int dayOfMonth, int dayOfWeek, boolean advanceDayOfWeek, int millisOfDay) { [EOL]     if (mode != 'u' && mode != 'w' && mode != 's') { [EOL]         throw new IllegalArgumentException("Unknown mode: " + mode); [EOL]     } [EOL]     iMode = mode; [EOL]     iMonthOfYear = monthOfYear; [EOL]     iDayOfMonth = dayOfMonth; [EOL]     iDayOfWeek = dayOfWeek; [EOL]     iAdvance = advanceDayOfWeek; [EOL]     iMillisOfDay = millisOfDay; [EOL] }
OfYear(char mode, int monthOfYear, int dayOfMonth, int dayOfWeek, boolean advanceDayOfWeek, int millisOfDay) { [EOL]     if (mode != 'u' && mode != 'w' && mode != 's') { [EOL]         throw new IllegalArgumentException("Unknown mode: " + mode); [EOL]     } [EOL]     iMode = mode; [EOL]     iMonthOfYear = monthOfYear; [EOL]     iDayOfMonth = dayOfMonth; [EOL]     iDayOfWeek = dayOfWeek; [EOL]     iAdvance = advanceDayOfWeek; [EOL]     iMillisOfDay = millisOfDay; [EOL] }
OfYear(char mode, int monthOfYear, int dayOfMonth, int dayOfWeek, boolean advanceDayOfWeek, int millisOfDay) { [EOL]     if (mode != 'u' && mode != 'w' && mode != 's') { [EOL]         throw new IllegalArgumentException("Unknown mode: " + mode); [EOL]     } [EOL]     iMode = mode; [EOL]     iMonthOfYear = monthOfYear; [EOL]     iDayOfMonth = dayOfMonth; [EOL]     iDayOfWeek = dayOfWeek; [EOL]     iAdvance = advanceDayOfWeek; [EOL]     iMillisOfDay = millisOfDay; [EOL] }
OfYear(char mode, int monthOfYear, int dayOfMonth, int dayOfWeek, boolean advanceDayOfWeek, int millisOfDay) { [EOL]     if (mode != 'u' && mode != 'w' && mode != 's') { [EOL]         throw new IllegalArgumentException("Unknown mode: " + mode); [EOL]     } [EOL]     iMode = mode; [EOL]     iMonthOfYear = monthOfYear; [EOL]     iDayOfMonth = dayOfMonth; [EOL]     iDayOfWeek = dayOfWeek; [EOL]     iAdvance = advanceDayOfWeek; [EOL]     iMillisOfDay = millisOfDay; [EOL] }
public long next(long instant, int standardOffset, int saveMillis) { [EOL]     int offset; [EOL]     if (iMode == 'w') { [EOL]         offset = standardOffset + saveMillis; [EOL]     } else if (iMode == 's') { [EOL]         offset = standardOffset; [EOL]     } else { [EOL]         offset = 0; [EOL]     } [EOL]     instant += offset; [EOL]     Chronology chrono = ISOChronology.getInstanceUTC(); [EOL]     long next = chrono.monthOfYear().set(instant, iMonthOfYear); [EOL]     next = chrono.millisOfDay().set(next, 0); [EOL]     next = chrono.millisOfDay().add(next, iMillisOfDay); [EOL]     next = setDayOfMonthNext(chrono, next); [EOL]     if (iDayOfWeek == 0) { [EOL]         if (next <= instant) { [EOL]             next = chrono.year().add(next, 1); [EOL]             next = setDayOfMonthNext(chrono, next); [EOL]         } [EOL]     } else { [EOL]         next = setDayOfWeek(chrono, next); [EOL]         if (next <= instant) { [EOL]             next = chrono.year().add(next, 1); [EOL]             next = chrono.monthOfYear().set(next, iMonthOfYear); [EOL]             next = setDayOfMonthNext(chrono, next); [EOL]             next = setDayOfWeek(chrono, next); [EOL]         } [EOL]     } [EOL]     return next - offset; [EOL] }
public long next(long instant, int standardOffset, int saveMillis) { [EOL]     int offset; [EOL]     if (iMode == 'w') { [EOL]         offset = standardOffset + saveMillis; [EOL]     } else if (iMode == 's') { [EOL]         offset = standardOffset; [EOL]     } else { [EOL]         offset = 0; [EOL]     } [EOL]     instant += offset; [EOL]     Chronology chrono = ISOChronology.getInstanceUTC(); [EOL]     long next = chrono.monthOfYear().set(instant, iMonthOfYear); [EOL]     next = chrono.millisOfDay().set(next, 0); [EOL]     next = chrono.millisOfDay().add(next, iMillisOfDay); [EOL]     next = setDayOfMonthNext(chrono, next); [EOL]     if (iDayOfWeek == 0) { [EOL]         if (next <= instant) { [EOL]             next = chrono.year().add(next, 1); [EOL]             next = setDayOfMonthNext(chrono, next); [EOL]         } [EOL]     } else { [EOL]         next = setDayOfWeek(chrono, next); [EOL]         if (next <= instant) { [EOL]             next = chrono.year().add(next, 1); [EOL]             next = chrono.monthOfYear().set(next, iMonthOfYear); [EOL]             next = setDayOfMonthNext(chrono, next); [EOL]             next = setDayOfWeek(chrono, next); [EOL]         } [EOL]     } [EOL]     return next - offset; [EOL] }
public long next(long instant, int standardOffset, int saveMillis) { [EOL]     int offset; [EOL]     if (iMode == 'w') { [EOL]         offset = standardOffset + saveMillis; [EOL]     } else if (iMode == 's') { [EOL]         offset = standardOffset; [EOL]     } else { [EOL]         offset = 0; [EOL]     } [EOL]     instant += offset; [EOL]     Chronology chrono = ISOChronology.getInstanceUTC(); [EOL]     long next = chrono.monthOfYear().set(instant, iMonthOfYear); [EOL]     next = chrono.millisOfDay().set(next, 0); [EOL]     next = chrono.millisOfDay().add(next, iMillisOfDay); [EOL]     next = setDayOfMonthNext(chrono, next); [EOL]     if (iDayOfWeek == 0) { [EOL]         if (next <= instant) { [EOL]             next = chrono.year().add(next, 1); [EOL]             next = setDayOfMonthNext(chrono, next); [EOL]         } [EOL]     } else { [EOL]         next = setDayOfWeek(chrono, next); [EOL]         if (next <= instant) { [EOL]             next = chrono.year().add(next, 1); [EOL]             next = chrono.monthOfYear().set(next, iMonthOfYear); [EOL]             next = setDayOfMonthNext(chrono, next); [EOL]             next = setDayOfWeek(chrono, next); [EOL]         } [EOL]     } [EOL]     return next - offset; [EOL] }
public long next(long instant, int standardOffset, int saveMillis) { [EOL]     int offset; [EOL]     if (iMode == 'w') { [EOL]         offset = standardOffset + saveMillis; [EOL]     } else if (iMode == 's') { [EOL]         offset = standardOffset; [EOL]     } else { [EOL]         offset = 0; [EOL]     } [EOL]     instant += offset; [EOL]     Chronology chrono = ISOChronology.getInstanceUTC(); [EOL]     long next = chrono.monthOfYear().set(instant, iMonthOfYear); [EOL]     next = chrono.millisOfDay().set(next, 0); [EOL]     next = chrono.millisOfDay().add(next, iMillisOfDay); [EOL]     next = setDayOfMonthNext(chrono, next); [EOL]     if (iDayOfWeek == 0) { [EOL]         if (next <= instant) { [EOL]             next = chrono.year().add(next, 1); [EOL]             next = setDayOfMonthNext(chrono, next); [EOL]         } [EOL]     } else { [EOL]         next = setDayOfWeek(chrono, next); [EOL]         if (next <= instant) { [EOL]             next = chrono.year().add(next, 1); [EOL]             next = chrono.monthOfYear().set(next, iMonthOfYear); [EOL]             next = setDayOfMonthNext(chrono, next); [EOL]             next = setDayOfWeek(chrono, next); [EOL]         } [EOL]     } [EOL]     return next - offset; [EOL] }
public long next(long instant, int standardOffset, int saveMillis) { [EOL]     int offset; [EOL]     if (iMode == 'w') { [EOL]         offset = standardOffset + saveMillis; [EOL]     } else if (iMode == 's') { [EOL]         offset = standardOffset; [EOL]     } else { [EOL]         offset = 0; [EOL]     } [EOL]     instant += offset; [EOL]     Chronology chrono = ISOChronology.getInstanceUTC(); [EOL]     long next = chrono.monthOfYear().set(instant, iMonthOfYear); [EOL]     next = chrono.millisOfDay().set(next, 0); [EOL]     next = chrono.millisOfDay().add(next, iMillisOfDay); [EOL]     next = setDayOfMonthNext(chrono, next); [EOL]     if (iDayOfWeek == 0) { [EOL]         if (next <= instant) { [EOL]             next = chrono.year().add(next, 1); [EOL]             next = setDayOfMonthNext(chrono, next); [EOL]         } [EOL]     } else { [EOL]         next = setDayOfWeek(chrono, next); [EOL]         if (next <= instant) { [EOL]             next = chrono.year().add(next, 1); [EOL]             next = chrono.monthOfYear().set(next, iMonthOfYear); [EOL]             next = setDayOfMonthNext(chrono, next); [EOL]             next = setDayOfWeek(chrono, next); [EOL]         } [EOL]     } [EOL]     return next - offset; [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof OfYear) { [EOL]         OfYear other = (OfYear) obj; [EOL]         return iMode == other.iMode && iMonthOfYear == other.iMonthOfYear && iDayOfMonth == other.iDayOfMonth && iDayOfWeek == other.iDayOfWeek && iAdvance == other.iAdvance && iMillisOfDay == other.iMillisOfDay; [EOL]     } [EOL]     return false; [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof OfYear) { [EOL]         OfYear other = (OfYear) obj; [EOL]         return iMode == other.iMode && iMonthOfYear == other.iMonthOfYear && iDayOfMonth == other.iDayOfMonth && iDayOfWeek == other.iDayOfWeek && iAdvance == other.iAdvance && iMillisOfDay == other.iMillisOfDay; [EOL]     } [EOL]     return false; [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof OfYear) { [EOL]         OfYear other = (OfYear) obj; [EOL]         return iMode == other.iMode && iMonthOfYear == other.iMonthOfYear && iDayOfMonth == other.iDayOfMonth && iDayOfWeek == other.iDayOfWeek && iAdvance == other.iAdvance && iMillisOfDay == other.iMillisOfDay; [EOL]     } [EOL]     return false; [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof OfYear) { [EOL]         OfYear other = (OfYear) obj; [EOL]         return iMode == other.iMode && iMonthOfYear == other.iMonthOfYear && iDayOfMonth == other.iDayOfMonth && iDayOfWeek == other.iDayOfWeek && iAdvance == other.iAdvance && iMillisOfDay == other.iMillisOfDay; [EOL]     } [EOL]     return false; [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof OfYear) { [EOL]         OfYear other = (OfYear) obj; [EOL]         return iMode == other.iMode && iMonthOfYear == other.iMonthOfYear && iDayOfMonth == other.iDayOfMonth && iDayOfWeek == other.iDayOfWeek && iAdvance == other.iAdvance && iMillisOfDay == other.iMillisOfDay; [EOL]     } [EOL]     return false; [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof OfYear) { [EOL]         OfYear other = (OfYear) obj; [EOL]         return iMode == other.iMode && iMonthOfYear == other.iMonthOfYear && iDayOfMonth == other.iDayOfMonth && iDayOfWeek == other.iDayOfWeek && iAdvance == other.iAdvance && iMillisOfDay == other.iMillisOfDay; [EOL]     } [EOL]     return false; [EOL] }
private long setDayOfMonthNext(Chronology chrono, long next) { [EOL]     try { [EOL]         next = setDayOfMonth(chrono, next); [EOL]     } catch (IllegalArgumentException e) { [EOL]         if (iMonthOfYear == 2 && iDayOfMonth == 29) { [EOL]             while (chrono.year().isLeap(next) == false) { [EOL]                 next = chrono.year().add(next, 1); [EOL]             } [EOL]             next = setDayOfMonth(chrono, next); [EOL]         } else { [EOL]             throw e; [EOL]         } [EOL]     } [EOL]     return next; [EOL] }
private long setDayOfMonth(Chronology chrono, long instant) { [EOL]     if (iDayOfMonth >= 0) { [EOL]         instant = chrono.dayOfMonth().set(instant, iDayOfMonth); [EOL]     } else { [EOL]         instant = chrono.dayOfMonth().set(instant, 1); [EOL]         instant = chrono.monthOfYear().add(instant, 1); [EOL]         instant = chrono.dayOfMonth().add(instant, iDayOfMonth); [EOL]     } [EOL]     return instant; [EOL] }
private long setDayOfMonth(Chronology chrono, long instant) { [EOL]     if (iDayOfMonth >= 0) { [EOL]         instant = chrono.dayOfMonth().set(instant, iDayOfMonth); [EOL]     } else { [EOL]         instant = chrono.dayOfMonth().set(instant, 1); [EOL]         instant = chrono.monthOfYear().add(instant, 1); [EOL]         instant = chrono.dayOfMonth().add(instant, iDayOfMonth); [EOL]     } [EOL]     return instant; [EOL] }
private long setDayOfWeek(Chronology chrono, long instant) { [EOL]     int dayOfWeek = chrono.dayOfWeek().get(instant); [EOL]     int daysToAdd = iDayOfWeek - dayOfWeek; [EOL]     if (daysToAdd != 0) { [EOL]         if (iAdvance) { [EOL]             if (daysToAdd < 0) { [EOL]                 daysToAdd += 7; [EOL]             } [EOL]         } else { [EOL]             if (daysToAdd > 0) { [EOL]                 daysToAdd -= 7; [EOL]             } [EOL]         } [EOL]         instant = chrono.dayOfWeek().add(instant, daysToAdd); [EOL]     } [EOL]     return instant; [EOL] }
private long setDayOfWeek(Chronology chrono, long instant) { [EOL]     int dayOfWeek = chrono.dayOfWeek().get(instant); [EOL]     int daysToAdd = iDayOfWeek - dayOfWeek; [EOL]     if (daysToAdd != 0) { [EOL]         if (iAdvance) { [EOL]             if (daysToAdd < 0) { [EOL]                 daysToAdd += 7; [EOL]             } [EOL]         } else { [EOL]             if (daysToAdd > 0) { [EOL]                 daysToAdd -= 7; [EOL]             } [EOL]         } [EOL]         instant = chrono.dayOfWeek().add(instant, daysToAdd); [EOL]     } [EOL]     return instant; [EOL] }
private long setDayOfWeek(Chronology chrono, long instant) { [EOL]     int dayOfWeek = chrono.dayOfWeek().get(instant); [EOL]     int daysToAdd = iDayOfWeek - dayOfWeek; [EOL]     if (daysToAdd != 0) { [EOL]         if (iAdvance) { [EOL]             if (daysToAdd < 0) { [EOL]                 daysToAdd += 7; [EOL]             } [EOL]         } else { [EOL]             if (daysToAdd > 0) { [EOL]                 daysToAdd -= 7; [EOL]             } [EOL]         } [EOL]         instant = chrono.dayOfWeek().add(instant, daysToAdd); [EOL]     } [EOL]     return instant; [EOL] }
Recurrence(OfYear ofYear, String nameKey, int saveMillis) { [EOL]     iOfYear = ofYear; [EOL]     iNameKey = nameKey; [EOL]     iSaveMillis = saveMillis; [EOL] }
public long next(long instant, int standardOffset, int saveMillis) { [EOL]     return iOfYear.next(instant, standardOffset, saveMillis); [EOL] }
public int getSaveMillis() { [EOL]     return iSaveMillis; [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof Recurrence) { [EOL]         Recurrence other = (Recurrence) obj; [EOL]         return iSaveMillis == other.iSaveMillis && iNameKey.equals(other.iNameKey) && iOfYear.equals(other.iOfYear); [EOL]     } [EOL]     return false; [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof Recurrence) { [EOL]         Recurrence other = (Recurrence) obj; [EOL]         return iSaveMillis == other.iSaveMillis && iNameKey.equals(other.iNameKey) && iOfYear.equals(other.iOfYear); [EOL]     } [EOL]     return false; [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof Recurrence) { [EOL]         Recurrence other = (Recurrence) obj; [EOL]         return iSaveMillis == other.iSaveMillis && iNameKey.equals(other.iNameKey) && iOfYear.equals(other.iOfYear); [EOL]     } [EOL]     return false; [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof Recurrence) { [EOL]         Recurrence other = (Recurrence) obj; [EOL]         return iSaveMillis == other.iSaveMillis && iNameKey.equals(other.iNameKey) && iOfYear.equals(other.iOfYear); [EOL]     } [EOL]     return false; [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof Recurrence) { [EOL]         Recurrence other = (Recurrence) obj; [EOL]         return iSaveMillis == other.iSaveMillis && iNameKey.equals(other.iNameKey) && iOfYear.equals(other.iOfYear); [EOL]     } [EOL]     return false; [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof Recurrence) { [EOL]         Recurrence other = (Recurrence) obj; [EOL]         return iSaveMillis == other.iSaveMillis && iNameKey.equals(other.iNameKey) && iOfYear.equals(other.iOfYear); [EOL]     } [EOL]     return false; [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof Recurrence) { [EOL]         Recurrence other = (Recurrence) obj; [EOL]         return iSaveMillis == other.iSaveMillis && iNameKey.equals(other.iNameKey) && iOfYear.equals(other.iOfYear); [EOL]     } [EOL]     return false; [EOL] }
Recurrence rename(String nameKey) { [EOL]     return new Recurrence(iOfYear, nameKey, iSaveMillis); [EOL] }
Recurrence rename(String nameKey) { [EOL]     return new Recurrence(iOfYear, nameKey, iSaveMillis); [EOL] }
Recurrence renameAppend(String appendNameKey) { [EOL]     return rename((iNameKey + appendNameKey).intern()); [EOL] }
Recurrence renameAppend(String appendNameKey) { [EOL]     return rename((iNameKey + appendNameKey).intern()); [EOL] }
Recurrence renameAppend(String appendNameKey) { [EOL]     return rename((iNameKey + appendNameKey).intern()); [EOL] }
Rule(Recurrence recurrence, int fromYear, int toYear) { [EOL]     iRecurrence = recurrence; [EOL]     iFromYear = fromYear; [EOL]     iToYear = toYear; [EOL] }
public int getToYear() { [EOL]     return iToYear; [EOL] }
public String getNameKey() { [EOL]     return iRecurrence.getNameKey(); [EOL] }
public int getSaveMillis() { [EOL]     return iRecurrence.getSaveMillis(); [EOL] }
public long next(final long instant, int standardOffset, int saveMillis) { [EOL]     Chronology chrono = ISOChronology.getInstanceUTC(); [EOL]     final int wallOffset = standardOffset + saveMillis; [EOL]     long testInstant = instant; [EOL]     int year; [EOL]     if (instant == Long.MIN_VALUE) { [EOL]         year = Integer.MIN_VALUE; [EOL]     } else { [EOL]         year = chrono.year().get(instant + wallOffset); [EOL]     } [EOL]     if (year < iFromYear) { [EOL]         testInstant = chrono.year().set(0, iFromYear) - wallOffset; [EOL]         testInstant -= 1; [EOL]     } [EOL]     long next = iRecurrence.next(testInstant, standardOffset, saveMillis); [EOL]     if (next > instant) { [EOL]         year = chrono.year().get(next + wallOffset); [EOL]         if (year > iToYear) { [EOL]             next = instant; [EOL]         } [EOL]     } [EOL]     return next; [EOL] }
Transition(long millis, Rule rule, int standardOffset) { [EOL]     iMillis = millis; [EOL]     iNameKey = rule.getNameKey(); [EOL]     iWallOffset = standardOffset + rule.getSaveMillis(); [EOL]     iStandardOffset = standardOffset; [EOL] }
Transition(long millis, Rule rule, int standardOffset) { [EOL]     iMillis = millis; [EOL]     iNameKey = rule.getNameKey(); [EOL]     iWallOffset = standardOffset + rule.getSaveMillis(); [EOL]     iStandardOffset = standardOffset; [EOL] }
public long getMillis() { [EOL]     return iMillis; [EOL] }
public String getNameKey() { [EOL]     return iNameKey; [EOL] }
public int getWallOffset() { [EOL]     return iWallOffset; [EOL] }
public int getStandardOffset() { [EOL]     return iStandardOffset; [EOL] }
public int getSaveMillis() { [EOL]     return iWallOffset - iStandardOffset; [EOL] }
public int getSaveMillis() { [EOL]     return iWallOffset - iStandardOffset; [EOL] }
public int getSaveMillis() { [EOL]     return iWallOffset - iStandardOffset; [EOL] }
public boolean isTransitionFrom(Transition other) { [EOL]     if (other == null) { [EOL]         return true; [EOL]     } [EOL]     return iMillis > other.iMillis && (iWallOffset != other.iWallOffset || !(iNameKey.equals(other.iNameKey))); [EOL] }
public boolean isTransitionFrom(Transition other) { [EOL]     if (other == null) { [EOL]         return true; [EOL]     } [EOL]     return iMillis > other.iMillis && (iWallOffset != other.iWallOffset || !(iNameKey.equals(other.iNameKey))); [EOL] }
public boolean isTransitionFrom(Transition other) { [EOL]     if (other == null) { [EOL]         return true; [EOL]     } [EOL]     return iMillis > other.iMillis && (iWallOffset != other.iWallOffset || !(iNameKey.equals(other.iNameKey))); [EOL] }
public boolean isTransitionFrom(Transition other) { [EOL]     if (other == null) { [EOL]         return true; [EOL]     } [EOL]     return iMillis > other.iMillis && (iWallOffset != other.iWallOffset || !(iNameKey.equals(other.iNameKey))); [EOL] }
public boolean isTransitionFrom(Transition other) { [EOL]     if (other == null) { [EOL]         return true; [EOL]     } [EOL]     return iMillis > other.iMillis && (iWallOffset != other.iWallOffset || !(iNameKey.equals(other.iNameKey))); [EOL] }
public boolean isTransitionFrom(Transition other) { [EOL]     if (other == null) { [EOL]         return true; [EOL]     } [EOL]     return iMillis > other.iMillis && (iWallOffset != other.iWallOffset || !(iNameKey.equals(other.iNameKey))); [EOL] }
RuleSet() { [EOL]     iRules = new ArrayList<Rule>(10); [EOL]     iUpperYear = Integer.MAX_VALUE; [EOL] }
RuleSet(RuleSet rs) { [EOL]     iStandardOffset = rs.iStandardOffset; [EOL]     iRules = new ArrayList<Rule>(rs.iRules); [EOL]     iInitialNameKey = rs.iInitialNameKey; [EOL]     iInitialSaveMillis = rs.iInitialSaveMillis; [EOL]     iUpperYear = rs.iUpperYear; [EOL]     iUpperOfYear = rs.iUpperOfYear; [EOL] }
public void setStandardOffset(int standardOffset) { [EOL]     iStandardOffset = standardOffset; [EOL] }
public void addRule(Rule rule) { [EOL]     if (!iRules.contains(rule)) { [EOL]         iRules.add(rule); [EOL]     } [EOL] }
public void addRule(Rule rule) { [EOL]     if (!iRules.contains(rule)) { [EOL]         iRules.add(rule); [EOL]     } [EOL] }
public Transition firstTransition(final long firstMillis) { [EOL]     if (iInitialNameKey != null) { [EOL]         return new Transition(firstMillis, iInitialNameKey, iStandardOffset + iInitialSaveMillis, iStandardOffset); [EOL]     } [EOL]     ArrayList<Rule> copy = new ArrayList<Rule>(iRules); [EOL]     long millis = Long.MIN_VALUE; [EOL]     int saveMillis = 0; [EOL]     Transition first = null; [EOL]     Transition next; [EOL]     while ((next = nextTransition(millis, saveMillis)) != null) { [EOL]         millis = next.getMillis(); [EOL]         if (millis == firstMillis) { [EOL]             first = new Transition(firstMillis, next); [EOL]             break; [EOL]         } [EOL]         if (millis > firstMillis) { [EOL]             if (first == null) { [EOL]                 for (Rule rule : copy) { [EOL]                     if (rule.getSaveMillis() == 0) { [EOL]                         first = new Transition(firstMillis, rule, iStandardOffset); [EOL]                         break; [EOL]                     } [EOL]                 } [EOL]             } [EOL]             if (first == null) { [EOL]                 first = new Transition(firstMillis, next.getNameKey(), iStandardOffset, iStandardOffset); [EOL]             } [EOL]             break; [EOL]         } [EOL]         first = new Transition(firstMillis, next); [EOL]         saveMillis = next.getSaveMillis(); [EOL]     } [EOL]     iRules = copy; [EOL]     return first; [EOL] }
public Transition firstTransition(final long firstMillis) { [EOL]     if (iInitialNameKey != null) { [EOL]         return new Transition(firstMillis, iInitialNameKey, iStandardOffset + iInitialSaveMillis, iStandardOffset); [EOL]     } [EOL]     ArrayList<Rule> copy = new ArrayList<Rule>(iRules); [EOL]     long millis = Long.MIN_VALUE; [EOL]     int saveMillis = 0; [EOL]     Transition first = null; [EOL]     Transition next; [EOL]     while ((next = nextTransition(millis, saveMillis)) != null) { [EOL]         millis = next.getMillis(); [EOL]         if (millis == firstMillis) { [EOL]             first = new Transition(firstMillis, next); [EOL]             break; [EOL]         } [EOL]         if (millis > firstMillis) { [EOL]             if (first == null) { [EOL]                 for (Rule rule : copy) { [EOL]                     if (rule.getSaveMillis() == 0) { [EOL]                         first = new Transition(firstMillis, rule, iStandardOffset); [EOL]                         break; [EOL]                     } [EOL]                 } [EOL]             } [EOL]             if (first == null) { [EOL]                 first = new Transition(firstMillis, next.getNameKey(), iStandardOffset, iStandardOffset); [EOL]             } [EOL]             break; [EOL]         } [EOL]         first = new Transition(firstMillis, next); [EOL]         saveMillis = next.getSaveMillis(); [EOL]     } [EOL]     iRules = copy; [EOL]     return first; [EOL] }
public Transition firstTransition(final long firstMillis) { [EOL]     if (iInitialNameKey != null) { [EOL]         return new Transition(firstMillis, iInitialNameKey, iStandardOffset + iInitialSaveMillis, iStandardOffset); [EOL]     } [EOL]     ArrayList<Rule> copy = new ArrayList<Rule>(iRules); [EOL]     long millis = Long.MIN_VALUE; [EOL]     int saveMillis = 0; [EOL]     Transition first = null; [EOL]     Transition next; [EOL]     while ((next = nextTransition(millis, saveMillis)) != null) { [EOL]         millis = next.getMillis(); [EOL]         if (millis == firstMillis) { [EOL]             first = new Transition(firstMillis, next); [EOL]             break; [EOL]         } [EOL]         if (millis > firstMillis) { [EOL]             if (first == null) { [EOL]                 for (Rule rule : copy) { [EOL]                     if (rule.getSaveMillis() == 0) { [EOL]                         first = new Transition(firstMillis, rule, iStandardOffset); [EOL]                         break; [EOL]                     } [EOL]                 } [EOL]             } [EOL]             if (first == null) { [EOL]                 first = new Transition(firstMillis, next.getNameKey(), iStandardOffset, iStandardOffset); [EOL]             } [EOL]             break; [EOL]         } [EOL]         first = new Transition(firstMillis, next); [EOL]         saveMillis = next.getSaveMillis(); [EOL]     } [EOL]     iRules = copy; [EOL]     return first; [EOL] }
public Transition firstTransition(final long firstMillis) { [EOL]     if (iInitialNameKey != null) { [EOL]         return new Transition(firstMillis, iInitialNameKey, iStandardOffset + iInitialSaveMillis, iStandardOffset); [EOL]     } [EOL]     ArrayList<Rule> copy = new ArrayList<Rule>(iRules); [EOL]     long millis = Long.MIN_VALUE; [EOL]     int saveMillis = 0; [EOL]     Transition first = null; [EOL]     Transition next; [EOL]     while ((next = nextTransition(millis, saveMillis)) != null) { [EOL]         millis = next.getMillis(); [EOL]         if (millis == firstMillis) { [EOL]             first = new Transition(firstMillis, next); [EOL]             break; [EOL]         } [EOL]         if (millis > firstMillis) { [EOL]             if (first == null) { [EOL]                 for (Rule rule : copy) { [EOL]                     if (rule.getSaveMillis() == 0) { [EOL]                         first = new Transition(firstMillis, rule, iStandardOffset); [EOL]                         break; [EOL]                     } [EOL]                 } [EOL]             } [EOL]             if (first == null) { [EOL]                 first = new Transition(firstMillis, next.getNameKey(), iStandardOffset, iStandardOffset); [EOL]             } [EOL]             break; [EOL]         } [EOL]         first = new Transition(firstMillis, next); [EOL]         saveMillis = next.getSaveMillis(); [EOL]     } [EOL]     iRules = copy; [EOL]     return first; [EOL] }
public Transition nextTransition(final long instant, final int saveMillis) { [EOL]     Chronology chrono = ISOChronology.getInstanceUTC(); [EOL]     Rule nextRule = null; [EOL]     long nextMillis = Long.MAX_VALUE; [EOL]     Iterator<Rule> it = iRules.iterator(); [EOL]     while (it.hasNext()) { [EOL]         Rule rule = it.next(); [EOL]         long next = rule.next(instant, iStandardOffset, saveMillis); [EOL]         if (next <= instant) { [EOL]             it.remove(); [EOL]             continue; [EOL]         } [EOL]         if (next <= nextMillis) { [EOL]             nextRule = rule; [EOL]             nextMillis = next; [EOL]         } [EOL]     } [EOL]     if (nextRule == null) { [EOL]         return null; [EOL]     } [EOL]     if (chrono.year().get(nextMillis) >= YEAR_LIMIT) { [EOL]         return null; [EOL]     } [EOL]     if (iUpperYear < Integer.MAX_VALUE) { [EOL]         long upperMillis = iUpperOfYear.setInstant(iUpperYear, iStandardOffset, saveMillis); [EOL]         if (nextMillis >= upperMillis) { [EOL]             return null; [EOL]         } [EOL]     } [EOL]     return new Transition(nextMillis, nextRule, iStandardOffset); [EOL] }
public Transition nextTransition(final long instant, final int saveMillis) { [EOL]     Chronology chrono = ISOChronology.getInstanceUTC(); [EOL]     Rule nextRule = null; [EOL]     long nextMillis = Long.MAX_VALUE; [EOL]     Iterator<Rule> it = iRules.iterator(); [EOL]     while (it.hasNext()) { [EOL]         Rule rule = it.next(); [EOL]         long next = rule.next(instant, iStandardOffset, saveMillis); [EOL]         if (next <= instant) { [EOL]             it.remove(); [EOL]             continue; [EOL]         } [EOL]         if (next <= nextMillis) { [EOL]             nextRule = rule; [EOL]             nextMillis = next; [EOL]         } [EOL]     } [EOL]     if (nextRule == null) { [EOL]         return null; [EOL]     } [EOL]     if (chrono.year().get(nextMillis) >= YEAR_LIMIT) { [EOL]         return null; [EOL]     } [EOL]     if (iUpperYear < Integer.MAX_VALUE) { [EOL]         long upperMillis = iUpperOfYear.setInstant(iUpperYear, iStandardOffset, saveMillis); [EOL]         if (nextMillis >= upperMillis) { [EOL]             return null; [EOL]         } [EOL]     } [EOL]     return new Transition(nextMillis, nextRule, iStandardOffset); [EOL] }
public Transition nextTransition(final long instant, final int saveMillis) { [EOL]     Chronology chrono = ISOChronology.getInstanceUTC(); [EOL]     Rule nextRule = null; [EOL]     long nextMillis = Long.MAX_VALUE; [EOL]     Iterator<Rule> it = iRules.iterator(); [EOL]     while (it.hasNext()) { [EOL]         Rule rule = it.next(); [EOL]         long next = rule.next(instant, iStandardOffset, saveMillis); [EOL]         if (next <= instant) { [EOL]             it.remove(); [EOL]             continue; [EOL]         } [EOL]         if (next <= nextMillis) { [EOL]             nextRule = rule; [EOL]             nextMillis = next; [EOL]         } [EOL]     } [EOL]     if (nextRule == null) { [EOL]         return null; [EOL]     } [EOL]     if (chrono.year().get(nextMillis) >= YEAR_LIMIT) { [EOL]         return null; [EOL]     } [EOL]     if (iUpperYear < Integer.MAX_VALUE) { [EOL]         long upperMillis = iUpperOfYear.setInstant(iUpperYear, iStandardOffset, saveMillis); [EOL]         if (nextMillis >= upperMillis) { [EOL]             return null; [EOL]         } [EOL]     } [EOL]     return new Transition(nextMillis, nextRule, iStandardOffset); [EOL] }
public Transition nextTransition(final long instant, final int saveMillis) { [EOL]     Chronology chrono = ISOChronology.getInstanceUTC(); [EOL]     Rule nextRule = null; [EOL]     long nextMillis = Long.MAX_VALUE; [EOL]     Iterator<Rule> it = iRules.iterator(); [EOL]     while (it.hasNext()) { [EOL]         Rule rule = it.next(); [EOL]         long next = rule.next(instant, iStandardOffset, saveMillis); [EOL]         if (next <= instant) { [EOL]             it.remove(); [EOL]             continue; [EOL]         } [EOL]         if (next <= nextMillis) { [EOL]             nextRule = rule; [EOL]             nextMillis = next; [EOL]         } [EOL]     } [EOL]     if (nextRule == null) { [EOL]         return null; [EOL]     } [EOL]     if (chrono.year().get(nextMillis) >= YEAR_LIMIT) { [EOL]         return null; [EOL]     } [EOL]     if (iUpperYear < Integer.MAX_VALUE) { [EOL]         long upperMillis = iUpperOfYear.setInstant(iUpperYear, iStandardOffset, saveMillis); [EOL]         if (nextMillis >= upperMillis) { [EOL]             return null; [EOL]         } [EOL]     } [EOL]     return new Transition(nextMillis, nextRule, iStandardOffset); [EOL] }
public Transition nextTransition(final long instant, final int saveMillis) { [EOL]     Chronology chrono = ISOChronology.getInstanceUTC(); [EOL]     Rule nextRule = null; [EOL]     long nextMillis = Long.MAX_VALUE; [EOL]     Iterator<Rule> it = iRules.iterator(); [EOL]     while (it.hasNext()) { [EOL]         Rule rule = it.next(); [EOL]         long next = rule.next(instant, iStandardOffset, saveMillis); [EOL]         if (next <= instant) { [EOL]             it.remove(); [EOL]             continue; [EOL]         } [EOL]         if (next <= nextMillis) { [EOL]             nextRule = rule; [EOL]             nextMillis = next; [EOL]         } [EOL]     } [EOL]     if (nextRule == null) { [EOL]         return null; [EOL]     } [EOL]     if (chrono.year().get(nextMillis) >= YEAR_LIMIT) { [EOL]         return null; [EOL]     } [EOL]     if (iUpperYear < Integer.MAX_VALUE) { [EOL]         long upperMillis = iUpperOfYear.setInstant(iUpperYear, iStandardOffset, saveMillis); [EOL]         if (nextMillis >= upperMillis) { [EOL]             return null; [EOL]         } [EOL]     } [EOL]     return new Transition(nextMillis, nextRule, iStandardOffset); [EOL] }
public Transition nextTransition(final long instant, final int saveMillis) { [EOL]     Chronology chrono = ISOChronology.getInstanceUTC(); [EOL]     Rule nextRule = null; [EOL]     long nextMillis = Long.MAX_VALUE; [EOL]     Iterator<Rule> it = iRules.iterator(); [EOL]     while (it.hasNext()) { [EOL]         Rule rule = it.next(); [EOL]         long next = rule.next(instant, iStandardOffset, saveMillis); [EOL]         if (next <= instant) { [EOL]             it.remove(); [EOL]             continue; [EOL]         } [EOL]         if (next <= nextMillis) { [EOL]             nextRule = rule; [EOL]             nextMillis = next; [EOL]         } [EOL]     } [EOL]     if (nextRule == null) { [EOL]         return null; [EOL]     } [EOL]     if (chrono.year().get(nextMillis) >= YEAR_LIMIT) { [EOL]         return null; [EOL]     } [EOL]     if (iUpperYear < Integer.MAX_VALUE) { [EOL]         long upperMillis = iUpperOfYear.setInstant(iUpperYear, iStandardOffset, saveMillis); [EOL]         if (nextMillis >= upperMillis) { [EOL]             return null; [EOL]         } [EOL]     } [EOL]     return new Transition(nextMillis, nextRule, iStandardOffset); [EOL] }
public Transition nextTransition(final long instant, final int saveMillis) { [EOL]     Chronology chrono = ISOChronology.getInstanceUTC(); [EOL]     Rule nextRule = null; [EOL]     long nextMillis = Long.MAX_VALUE; [EOL]     Iterator<Rule> it = iRules.iterator(); [EOL]     while (it.hasNext()) { [EOL]         Rule rule = it.next(); [EOL]         long next = rule.next(instant, iStandardOffset, saveMillis); [EOL]         if (next <= instant) { [EOL]             it.remove(); [EOL]             continue; [EOL]         } [EOL]         if (next <= nextMillis) { [EOL]             nextRule = rule; [EOL]             nextMillis = next; [EOL]         } [EOL]     } [EOL]     if (nextRule == null) { [EOL]         return null; [EOL]     } [EOL]     if (chrono.year().get(nextMillis) >= YEAR_LIMIT) { [EOL]         return null; [EOL]     } [EOL]     if (iUpperYear < Integer.MAX_VALUE) { [EOL]         long upperMillis = iUpperOfYear.setInstant(iUpperYear, iStandardOffset, saveMillis); [EOL]         if (nextMillis >= upperMillis) { [EOL]             return null; [EOL]         } [EOL]     } [EOL]     return new Transition(nextMillis, nextRule, iStandardOffset); [EOL] }
public long getUpperLimit(int saveMillis) { [EOL]     if (iUpperYear == Integer.MAX_VALUE) { [EOL]         return Long.MAX_VALUE; [EOL]     } [EOL]     return iUpperOfYear.setInstant(iUpperYear, iStandardOffset, saveMillis); [EOL] }
public long getUpperLimit(int saveMillis) { [EOL]     if (iUpperYear == Integer.MAX_VALUE) { [EOL]         return Long.MAX_VALUE; [EOL]     } [EOL]     return iUpperOfYear.setInstant(iUpperYear, iStandardOffset, saveMillis); [EOL] }
public DSTZone buildTailZone(String id) { [EOL]     if (iRules.size() == 2) { [EOL]         Rule startRule = iRules.get(0); [EOL]         Rule endRule = iRules.get(1); [EOL]         if (startRule.getToYear() == Integer.MAX_VALUE && endRule.getToYear() == Integer.MAX_VALUE) { [EOL]             return new DSTZone(id, iStandardOffset, startRule.iRecurrence, endRule.iRecurrence); [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public DSTZone buildTailZone(String id) { [EOL]     if (iRules.size() == 2) { [EOL]         Rule startRule = iRules.get(0); [EOL]         Rule endRule = iRules.get(1); [EOL]         if (startRule.getToYear() == Integer.MAX_VALUE && endRule.getToYear() == Integer.MAX_VALUE) { [EOL]             return new DSTZone(id, iStandardOffset, startRule.iRecurrence, endRule.iRecurrence); [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public DSTZone buildTailZone(String id) { [EOL]     if (iRules.size() == 2) { [EOL]         Rule startRule = iRules.get(0); [EOL]         Rule endRule = iRules.get(1); [EOL]         if (startRule.getToYear() == Integer.MAX_VALUE && endRule.getToYear() == Integer.MAX_VALUE) { [EOL]             return new DSTZone(id, iStandardOffset, startRule.iRecurrence, endRule.iRecurrence); [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
DSTZone(String id, int standardOffset, Recurrence startRecurrence, Recurrence endRecurrence) { [EOL]     super(id); [EOL]     iStandardOffset = standardOffset; [EOL]     iStartRecurrence = startRecurrence; [EOL]     iEndRecurrence = endRecurrence; [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof DSTZone) { [EOL]         DSTZone other = (DSTZone) obj; [EOL]         return getID().equals(other.getID()) && iStandardOffset == other.iStandardOffset && iStartRecurrence.equals(other.iStartRecurrence) && iEndRecurrence.equals(other.iEndRecurrence); [EOL]     } [EOL]     return false; [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof DSTZone) { [EOL]         DSTZone other = (DSTZone) obj; [EOL]         return getID().equals(other.getID()) && iStandardOffset == other.iStandardOffset && iStartRecurrence.equals(other.iStartRecurrence) && iEndRecurrence.equals(other.iEndRecurrence); [EOL]     } [EOL]     return false; [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof DSTZone) { [EOL]         DSTZone other = (DSTZone) obj; [EOL]         return getID().equals(other.getID()) && iStandardOffset == other.iStandardOffset && iStartRecurrence.equals(other.iStartRecurrence) && iEndRecurrence.equals(other.iEndRecurrence); [EOL]     } [EOL]     return false; [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof DSTZone) { [EOL]         DSTZone other = (DSTZone) obj; [EOL]         return getID().equals(other.getID()) && iStandardOffset == other.iStandardOffset && iStartRecurrence.equals(other.iStartRecurrence) && iEndRecurrence.equals(other.iEndRecurrence); [EOL]     } [EOL]     return false; [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof DSTZone) { [EOL]         DSTZone other = (DSTZone) obj; [EOL]         return getID().equals(other.getID()) && iStandardOffset == other.iStandardOffset && iStartRecurrence.equals(other.iStartRecurrence) && iEndRecurrence.equals(other.iEndRecurrence); [EOL]     } [EOL]     return false; [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof DSTZone) { [EOL]         DSTZone other = (DSTZone) obj; [EOL]         return getID().equals(other.getID()) && iStandardOffset == other.iStandardOffset && iStartRecurrence.equals(other.iStartRecurrence) && iEndRecurrence.equals(other.iEndRecurrence); [EOL]     } [EOL]     return false; [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof DSTZone) { [EOL]         DSTZone other = (DSTZone) obj; [EOL]         return getID().equals(other.getID()) && iStandardOffset == other.iStandardOffset && iStartRecurrence.equals(other.iStartRecurrence) && iEndRecurrence.equals(other.iEndRecurrence); [EOL]     } [EOL]     return false; [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof DSTZone) { [EOL]         DSTZone other = (DSTZone) obj; [EOL]         return getID().equals(other.getID()) && iStandardOffset == other.iStandardOffset && iStartRecurrence.equals(other.iStartRecurrence) && iEndRecurrence.equals(other.iEndRecurrence); [EOL]     } [EOL]     return false; [EOL] }
static PrecalculatedZone create(String id, boolean outputID, ArrayList<Transition> transitions, DSTZone tailZone) { [EOL]     int size = transitions.size(); [EOL]     if (size == 0) { [EOL]         throw new IllegalArgumentException(); [EOL]     } [EOL]     long[] trans = new long[size]; [EOL]     int[] wallOffsets = new int[size]; [EOL]     int[] standardOffsets = new int[size]; [EOL]     String[] nameKeys = new String[size]; [EOL]     Transition last = null; [EOL]     for (int i = 0; i < size; i++) { [EOL]         Transition tr = transitions.get(i); [EOL]         if (!tr.isTransitionFrom(last)) { [EOL]             throw new IllegalArgumentException(id); [EOL]         } [EOL]         trans[i] = tr.getMillis(); [EOL]         wallOffsets[i] = tr.getWallOffset(); [EOL]         standardOffsets[i] = tr.getStandardOffset(); [EOL]         nameKeys[i] = tr.getNameKey(); [EOL]         last = tr; [EOL]     } [EOL]     String[] zoneNameData = new String[5]; [EOL]     String[][] zoneStrings = new DateFormatSymbols(Locale.ENGLISH).getZoneStrings(); [EOL]     for (int j = 0; j < zoneStrings.length; j++) { [EOL]         String[] set = zoneStrings[j]; [EOL]         if (set != null && set.length == 5 && id.equals(set[0])) { [EOL]             zoneNameData = set; [EOL]         } [EOL]     } [EOL]     Chronology chrono = ISOChronology.getInstanceUTC(); [EOL]     for (int i = 0; i < nameKeys.length - 1; i++) { [EOL]         String curNameKey = nameKeys[i]; [EOL]         String nextNameKey = nameKeys[i + 1]; [EOL]         long curOffset = wallOffsets[i]; [EOL]         long nextOffset = wallOffsets[i + 1]; [EOL]         long curStdOffset = standardOffsets[i]; [EOL]         long nextStdOffset = standardOffsets[i + 1]; [EOL]         Period p = new Period(trans[i], trans[i + 1], PeriodType.yearMonthDay(), chrono); [EOL]         if (curOffset != nextOffset && curStdOffset == nextStdOffset && curNameKey.equals(nextNameKey) && p.getYears() == 0 && p.getMonths() > 4 && p.getMonths() < 8 && curNameKey.equals(zoneNameData[2]) && curNameKey.equals(zoneNameData[4])) { [EOL]             if (ZoneInfoCompiler.verbose()) { [EOL]                 System.out.println("Fixing duplicate name key - " + nextNameKey); [EOL]                 System.out.println("     - " + new DateTime(trans[i], chrono) + " - " + new DateTime(trans[i + 1], chrono)); [EOL]             } [EOL]             if (curOffset > nextOffset) { [EOL]                 nameKeys[i] = (curNameKey + "-Summer").intern(); [EOL]             } else if (curOffset < nextOffset) { [EOL]                 nameKeys[i + 1] = (nextNameKey + "-Summer").intern(); [EOL]                 i++; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (tailZone != null) { [EOL]         if (tailZone.iStartRecurrence.getNameKey().equals(tailZone.iEndRecurrence.getNameKey())) { [EOL]             if (ZoneInfoCompiler.verbose()) { [EOL]                 System.out.println("Fixing duplicate recurrent name key - " + tailZone.iStartRecurrence.getNameKey()); [EOL]             } [EOL]             if (tailZone.iStartRecurrence.getSaveMillis() > 0) { [EOL]                 tailZone = new DSTZone(tailZone.getID(), tailZone.iStandardOffset, tailZone.iStartRecurrence.renameAppend("-Summer"), tailZone.iEndRecurrence); [EOL]             } else { [EOL]                 tailZone = new DSTZone(tailZone.getID(), tailZone.iStandardOffset, tailZone.iStartRecurrence, tailZone.iEndRecurrence.renameAppend("-Summer")); [EOL]             } [EOL]         } [EOL]     } [EOL]     return new PrecalculatedZone((outputID ? id : ""), trans, wallOffsets, standardOffsets, nameKeys, tailZone); [EOL] }
private PrecalculatedZone(String id, long[] transitions, int[] wallOffsets, int[] standardOffsets, String[] nameKeys, DSTZone tailZone) { [EOL]     super(id); [EOL]     iTransitions = transitions; [EOL]     iWallOffsets = wallOffsets; [EOL]     iStandardOffsets = standardOffsets; [EOL]     iNameKeys = nameKeys; [EOL]     iTailZone = tailZone; [EOL] }
public int getOffset(long instant) { [EOL]     long[] transitions = iTransitions; [EOL]     int i = Arrays.binarySearch(transitions, instant); [EOL]     if (i >= 0) { [EOL]         return iWallOffsets[i]; [EOL]     } [EOL]     i = ~i; [EOL]     if (i < transitions.length) { [EOL]         if (i > 0) { [EOL]             return iWallOffsets[i - 1]; [EOL]         } [EOL]         return 0; [EOL]     } [EOL]     if (iTailZone == null) { [EOL]         return iWallOffsets[i - 1]; [EOL]     } [EOL]     return iTailZone.getOffset(instant); [EOL] }
public long previousTransition(long instant) { [EOL]     long[] transitions = iTransitions; [EOL]     int i = Arrays.binarySearch(transitions, instant); [EOL]     if (i >= 0) { [EOL]         if (instant > Long.MIN_VALUE) { [EOL]             return instant - 1; [EOL]         } [EOL]         return instant; [EOL]     } [EOL]     i = ~i; [EOL]     if (i < transitions.length) { [EOL]         if (i > 0) { [EOL]             long prev = transitions[i - 1]; [EOL]             if (prev > Long.MIN_VALUE) { [EOL]                 return prev - 1; [EOL]             } [EOL]         } [EOL]         return instant; [EOL]     } [EOL]     if (iTailZone != null) { [EOL]         long prev = iTailZone.previousTransition(instant); [EOL]         if (prev < instant) { [EOL]             return prev; [EOL]         } [EOL]     } [EOL]     long prev = transitions[i - 1]; [EOL]     if (prev > Long.MIN_VALUE) { [EOL]         return prev - 1; [EOL]     } [EOL]     return instant; [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof PrecalculatedZone) { [EOL]         PrecalculatedZone other = (PrecalculatedZone) obj; [EOL]         return getID().equals(other.getID()) && Arrays.equals(iTransitions, other.iTransitions) && Arrays.equals(iNameKeys, other.iNameKeys) && Arrays.equals(iWallOffsets, other.iWallOffsets) && Arrays.equals(iStandardOffsets, other.iStandardOffsets) && ((iTailZone == null) ? (null == other.iTailZone) : (iTailZone.equals(other.iTailZone))); [EOL]     } [EOL]     return false; [EOL] }
public boolean isCachable() { [EOL]     if (iTailZone != null) { [EOL]         return true; [EOL]     } [EOL]     long[] transitions = iTransitions; [EOL]     if (transitions.length <= 1) { [EOL]         return false; [EOL]     } [EOL]     double distances = 0; [EOL]     int count = 0; [EOL]     for (int i = 1; i < transitions.length; i++) { [EOL]         long diff = transitions[i] - transitions[i - 1]; [EOL]         if (diff < ((366L + 365) * 24 * 60 * 60 * 1000)) { [EOL]             distances += (double) diff; [EOL]             count++; [EOL]         } [EOL]     } [EOL]     if (count > 0) { [EOL]         double avg = distances / count; [EOL]         avg /= 24 * 60 * 60 * 1000; [EOL]         if (avg >= 25) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public boolean isCachable() { [EOL]     if (iTailZone != null) { [EOL]         return true; [EOL]     } [EOL]     long[] transitions = iTransitions; [EOL]     if (transitions.length <= 1) { [EOL]         return false; [EOL]     } [EOL]     double distances = 0; [EOL]     int count = 0; [EOL]     for (int i = 1; i < transitions.length; i++) { [EOL]         long diff = transitions[i] - transitions[i - 1]; [EOL]         if (diff < ((366L + 365) * 24 * 60 * 60 * 1000)) { [EOL]             distances += (double) diff; [EOL]             count++; [EOL]         } [EOL]     } [EOL]     if (count > 0) { [EOL]         double avg = distances / count; [EOL]         avg /= 24 * 60 * 60 * 1000; [EOL]         if (avg >= 25) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public boolean isCachable() { [EOL]     if (iTailZone != null) { [EOL]         return true; [EOL]     } [EOL]     long[] transitions = iTransitions; [EOL]     if (transitions.length <= 1) { [EOL]         return false; [EOL]     } [EOL]     double distances = 0; [EOL]     int count = 0; [EOL]     for (int i = 1; i < transitions.length; i++) { [EOL]         long diff = transitions[i] - transitions[i - 1]; [EOL]         if (diff < ((366L + 365) * 24 * 60 * 60 * 1000)) { [EOL]             distances += (double) diff; [EOL]             count++; [EOL]         } [EOL]     } [EOL]     if (count > 0) { [EOL]         double avg = distances / count; [EOL]         avg /= 24 * 60 * 60 * 1000; [EOL]         if (avg >= 25) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public boolean isCachable() { [EOL]     if (iTailZone != null) { [EOL]         return true; [EOL]     } [EOL]     long[] transitions = iTransitions; [EOL]     if (transitions.length <= 1) { [EOL]         return false; [EOL]     } [EOL]     double distances = 0; [EOL]     int count = 0; [EOL]     for (int i = 1; i < transitions.length; i++) { [EOL]         long diff = transitions[i] - transitions[i - 1]; [EOL]         if (diff < ((366L + 365) * 24 * 60 * 60 * 1000)) { [EOL]             distances += (double) diff; [EOL]             count++; [EOL]         } [EOL]     } [EOL]     if (count > 0) { [EOL]         double avg = distances / count; [EOL]         avg /= 24 * 60 * 60 * 1000; [EOL]         if (avg >= 25) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public boolean isCachable() { [EOL]     if (iTailZone != null) { [EOL]         return true; [EOL]     } [EOL]     long[] transitions = iTransitions; [EOL]     if (transitions.length <= 1) { [EOL]         return false; [EOL]     } [EOL]     double distances = 0; [EOL]     int count = 0; [EOL]     for (int i = 1; i < transitions.length; i++) { [EOL]         long diff = transitions[i] - transitions[i - 1]; [EOL]         if (diff < ((366L + 365) * 24 * 60 * 60 * 1000)) { [EOL]             distances += (double) diff; [EOL]             count++; [EOL]         } [EOL]     } [EOL]     if (count > 0) { [EOL]         double avg = distances / count; [EOL]         avg /= 24 * 60 * 60 * 1000; [EOL]         if (avg >= 25) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public boolean isCachable() { [EOL]     if (iTailZone != null) { [EOL]         return true; [EOL]     } [EOL]     long[] transitions = iTransitions; [EOL]     if (transitions.length <= 1) { [EOL]         return false; [EOL]     } [EOL]     double distances = 0; [EOL]     int count = 0; [EOL]     for (int i = 1; i < transitions.length; i++) { [EOL]         long diff = transitions[i] - transitions[i - 1]; [EOL]         if (diff < ((366L + 365) * 24 * 60 * 60 * 1000)) { [EOL]             distances += (double) diff; [EOL]             count++; [EOL]         } [EOL]     } [EOL]     if (count > 0) { [EOL]         double avg = distances / count; [EOL]         avg /= 24 * 60 * 60 * 1000; [EOL]         if (avg >= 25) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public boolean isCachable() { [EOL]     if (iTailZone != null) { [EOL]         return true; [EOL]     } [EOL]     long[] transitions = iTransitions; [EOL]     if (transitions.length <= 1) { [EOL]         return false; [EOL]     } [EOL]     double distances = 0; [EOL]     int count = 0; [EOL]     for (int i = 1; i < transitions.length; i++) { [EOL]         long diff = transitions[i] - transitions[i - 1]; [EOL]         if (diff < ((366L + 365) * 24 * 60 * 60 * 1000)) { [EOL]             distances += (double) diff; [EOL]             count++; [EOL]         } [EOL]     } [EOL]     if (count > 0) { [EOL]         double avg = distances / count; [EOL]         avg /= 24 * 60 * 60 * 1000; [EOL]         if (avg >= 25) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof CachedDateTimeZone) { [EOL]         return iZone.equals(((CachedDateTimeZone) obj).iZone); [EOL]     } [EOL]     return false; [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof CachedDateTimeZone) { [EOL]         return iZone.equals(((CachedDateTimeZone) obj).iZone); [EOL]     } [EOL]     return false; [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof CachedDateTimeZone) { [EOL]         return iZone.equals(((CachedDateTimeZone) obj).iZone); [EOL]     } [EOL]     return false; [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof CachedDateTimeZone) { [EOL]         return iZone.equals(((CachedDateTimeZone) obj).iZone); [EOL]     } [EOL]     return false; [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof CachedDateTimeZone) { [EOL]         return iZone.equals(((CachedDateTimeZone) obj).iZone); [EOL]     } [EOL]     return false; [EOL] }
public long add(long instant, long value) { [EOL]     long scaled = FieldUtils.safeMultiply(value, iScalar); [EOL]     return getWrappedField().add(instant, scaled); [EOL] }
public int getDifference(long minuendInstant, long subtrahendInstant) { [EOL]     return getWrappedField().getDifference(minuendInstant, subtrahendInstant) / iScalar; [EOL] }
public int getDifference(long minuendInstant, long subtrahendInstant) { [EOL]     return getWrappedField().getDifference(minuendInstant, subtrahendInstant) / iScalar; [EOL] }
public int getDifference(long minuendInstant, long subtrahendInstant) { [EOL]     return getWrappedField().getDifference(minuendInstant, subtrahendInstant) / iScalar; [EOL] }
public Chronology withZone(DateTimeZone zone) { [EOL]     if (zone == null) { [EOL]         zone = DateTimeZone.getDefault(); [EOL]     } [EOL]     if (zone == getZone()) { [EOL]         return this; [EOL]     } [EOL]     return getInstance(zone); [EOL] }
public Chronology withZone(DateTimeZone zone) { [EOL]     if (zone == null) { [EOL]         zone = DateTimeZone.getDefault(); [EOL]     } [EOL]     if (zone == getZone()) { [EOL]         return this; [EOL]     } [EOL]     return getInstance(zone); [EOL] }
public Chronology withZone(DateTimeZone zone) { [EOL]     if (zone == null) { [EOL]         zone = DateTimeZone.getDefault(); [EOL]     } [EOL]     if (zone == getZone()) { [EOL]         return this; [EOL]     } [EOL]     return getInstance(zone); [EOL] }
public int hashCode() { [EOL]     return "ISO".hashCode() * 11 + getZone().hashCode(); [EOL] }
public final DurationFieldType getType() { [EOL]     return iType; [EOL] }
public final boolean isSupported() { [EOL]     return true; [EOL] }
public int getValue(long duration) { [EOL]     return FieldUtils.safeToInt(getValueAsLong(duration)); [EOL] }
public int getDifference(long minuendInstant, long subtrahendInstant) { [EOL]     return FieldUtils.safeToInt(getDifferenceAsLong(minuendInstant, subtrahendInstant)); [EOL] }
public int compareTo(DurationField otherField) { [EOL]     long otherMillis = otherField.getUnitMillis(); [EOL]     long thisMillis = getUnitMillis(); [EOL]     if (thisMillis == otherMillis) { [EOL]         return 0; [EOL]     } [EOL]     if (thisMillis < otherMillis) { [EOL]         return -1; [EOL]     } else { [EOL]         return 1; [EOL]     } [EOL] }
public int compareTo(DurationField otherField) { [EOL]     long otherMillis = otherField.getUnitMillis(); [EOL]     long thisMillis = getUnitMillis(); [EOL]     if (thisMillis == otherMillis) { [EOL]         return 0; [EOL]     } [EOL]     if (thisMillis < otherMillis) { [EOL]         return -1; [EOL]     } else { [EOL]         return 1; [EOL]     } [EOL] }
public int compareTo(DurationField otherField) { [EOL]     long otherMillis = otherField.getUnitMillis(); [EOL]     long thisMillis = getUnitMillis(); [EOL]     if (thisMillis == otherMillis) { [EOL]         return 0; [EOL]     } [EOL]     if (thisMillis < otherMillis) { [EOL]         return -1; [EOL]     } else { [EOL]         return 1; [EOL]     } [EOL] }
long calculateFirstDayOfYearMillis(int year) { [EOL]     int relativeYear = year - 1687; [EOL]     int leapYears; [EOL]     if (relativeYear <= 0) { [EOL]         leapYears = (relativeYear + 3) >> 2; [EOL]     } else { [EOL]         leapYears = relativeYear >> 2; [EOL]         if (!isLeapYear(year)) { [EOL]             leapYears++; [EOL]         } [EOL]     } [EOL]     long millis = (relativeYear * 365L + leapYears) * (long) DateTimeConstants.MILLIS_PER_DAY; [EOL]     return millis + (365L - 112) * DateTimeConstants.MILLIS_PER_DAY; [EOL] }
long calculateFirstDayOfYearMillis(int year) { [EOL]     int relativeYear = year - 1687; [EOL]     int leapYears; [EOL]     if (relativeYear <= 0) { [EOL]         leapYears = (relativeYear + 3) >> 2; [EOL]     } else { [EOL]         leapYears = relativeYear >> 2; [EOL]         if (!isLeapYear(year)) { [EOL]             leapYears++; [EOL]         } [EOL]     } [EOL]     long millis = (relativeYear * 365L + leapYears) * (long) DateTimeConstants.MILLIS_PER_DAY; [EOL]     return millis + (365L - 112) * DateTimeConstants.MILLIS_PER_DAY; [EOL] }
long calculateFirstDayOfYearMillis(int year) { [EOL]     int relativeYear = year - 1687; [EOL]     int leapYears; [EOL]     if (relativeYear <= 0) { [EOL]         leapYears = (relativeYear + 3) >> 2; [EOL]     } else { [EOL]         leapYears = relativeYear >> 2; [EOL]         if (!isLeapYear(year)) { [EOL]             leapYears++; [EOL]         } [EOL]     } [EOL]     long millis = (relativeYear * 365L + leapYears) * (long) DateTimeConstants.MILLIS_PER_DAY; [EOL]     return millis + (365L - 112) * DateTimeConstants.MILLIS_PER_DAY; [EOL] }
int getMinYear() { [EOL]     return MIN_YEAR; [EOL] }
private Object readResolve() { [EOL]     return Months.months(getValue()); [EOL] }
public Months dividedBy(int divisor) { [EOL]     if (divisor == 1) { [EOL]         return this; [EOL]     } [EOL]     return Months.months(getValue() / divisor); [EOL] }
public Months dividedBy(int divisor) { [EOL]     if (divisor == 1) { [EOL]         return this; [EOL]     } [EOL]     return Months.months(getValue() / divisor); [EOL] }
public Months dividedBy(int divisor) { [EOL]     if (divisor == 1) { [EOL]         return this; [EOL]     } [EOL]     return Months.months(getValue() / divisor); [EOL] }
public boolean isLessThan(Months other) { [EOL]     if (other == null) { [EOL]         return getValue() < 0; [EOL]     } [EOL]     return getValue() < other.getValue(); [EOL] }
public boolean isLessThan(Months other) { [EOL]     if (other == null) { [EOL]         return getValue() < 0; [EOL]     } [EOL]     return getValue() < other.getValue(); [EOL] }
public boolean isLessThan(Months other) { [EOL]     if (other == null) { [EOL]         return getValue() < 0; [EOL]     } [EOL]     return getValue() < other.getValue(); [EOL] }
public boolean isLessThan(Months other) { [EOL]     if (other == null) { [EOL]         return getValue() < 0; [EOL]     } [EOL]     return getValue() < other.getValue(); [EOL] }
public Interval(Object interval) { [EOL]     super(interval, null); [EOL] }
public Interval gap(ReadableInterval interval) { [EOL]     interval = DateTimeUtils.getReadableInterval(interval); [EOL]     long otherStart = interval.getStartMillis(); [EOL]     long otherEnd = interval.getEndMillis(); [EOL]     long thisStart = getStartMillis(); [EOL]     long thisEnd = getEndMillis(); [EOL]     if (thisStart > otherEnd) { [EOL]         return new Interval(otherEnd, thisStart, getChronology()); [EOL]     } else if (otherStart > thisEnd) { [EOL]         return new Interval(thisEnd, otherStart, getChronology()); [EOL]     } else { [EOL]         return null; [EOL]     } [EOL] }
public Interval gap(ReadableInterval interval) { [EOL]     interval = DateTimeUtils.getReadableInterval(interval); [EOL]     long otherStart = interval.getStartMillis(); [EOL]     long otherEnd = interval.getEndMillis(); [EOL]     long thisStart = getStartMillis(); [EOL]     long thisEnd = getEndMillis(); [EOL]     if (thisStart > otherEnd) { [EOL]         return new Interval(otherEnd, thisStart, getChronology()); [EOL]     } else if (otherStart > thisEnd) { [EOL]         return new Interval(thisEnd, otherStart, getChronology()); [EOL]     } else { [EOL]         return null; [EOL]     } [EOL] }
public Interval gap(ReadableInterval interval) { [EOL]     interval = DateTimeUtils.getReadableInterval(interval); [EOL]     long otherStart = interval.getStartMillis(); [EOL]     long otherEnd = interval.getEndMillis(); [EOL]     long thisStart = getStartMillis(); [EOL]     long thisEnd = getEndMillis(); [EOL]     if (thisStart > otherEnd) { [EOL]         return new Interval(otherEnd, thisStart, getChronology()); [EOL]     } else if (otherStart > thisEnd) { [EOL]         return new Interval(thisEnd, otherStart, getChronology()); [EOL]     } else { [EOL]         return null; [EOL]     } [EOL] }
public boolean abuts(ReadableInterval interval) { [EOL]     if (interval == null) { [EOL]         long now = DateTimeUtils.currentTimeMillis(); [EOL]         return (getStartMillis() == now || getEndMillis() == now); [EOL]     } else { [EOL]         return (interval.getEndMillis() == getStartMillis() || getEndMillis() == interval.getStartMillis()); [EOL]     } [EOL] }
public boolean abuts(ReadableInterval interval) { [EOL]     if (interval == null) { [EOL]         long now = DateTimeUtils.currentTimeMillis(); [EOL]         return (getStartMillis() == now || getEndMillis() == now); [EOL]     } else { [EOL]         return (interval.getEndMillis() == getStartMillis() || getEndMillis() == interval.getStartMillis()); [EOL]     } [EOL] }
public boolean abuts(ReadableInterval interval) { [EOL]     if (interval == null) { [EOL]         long now = DateTimeUtils.currentTimeMillis(); [EOL]         return (getStartMillis() == now || getEndMillis() == now); [EOL]     } else { [EOL]         return (interval.getEndMillis() == getStartMillis() || getEndMillis() == interval.getStartMillis()); [EOL]     } [EOL] }
public boolean abuts(ReadableInterval interval) { [EOL]     if (interval == null) { [EOL]         long now = DateTimeUtils.currentTimeMillis(); [EOL]         return (getStartMillis() == now || getEndMillis() == now); [EOL]     } else { [EOL]         return (interval.getEndMillis() == getStartMillis() || getEndMillis() == interval.getStartMillis()); [EOL]     } [EOL] }
public Interval withDurationAfterStart(ReadableDuration duration) { [EOL]     long durationMillis = DateTimeUtils.getDurationMillis(duration); [EOL]     if (durationMillis == toDurationMillis()) { [EOL]         return this; [EOL]     } [EOL]     Chronology chrono = getChronology(); [EOL]     long startMillis = getStartMillis(); [EOL]     long endMillis = chrono.add(startMillis, durationMillis, 1); [EOL]     return new Interval(startMillis, endMillis, chrono); [EOL] }
public Interval withDurationAfterStart(ReadableDuration duration) { [EOL]     long durationMillis = DateTimeUtils.getDurationMillis(duration); [EOL]     if (durationMillis == toDurationMillis()) { [EOL]         return this; [EOL]     } [EOL]     Chronology chrono = getChronology(); [EOL]     long startMillis = getStartMillis(); [EOL]     long endMillis = chrono.add(startMillis, durationMillis, 1); [EOL]     return new Interval(startMillis, endMillis, chrono); [EOL] }
public Interval withDurationBeforeEnd(ReadableDuration duration) { [EOL]     long durationMillis = DateTimeUtils.getDurationMillis(duration); [EOL]     if (durationMillis == toDurationMillis()) { [EOL]         return this; [EOL]     } [EOL]     Chronology chrono = getChronology(); [EOL]     long endMillis = getEndMillis(); [EOL]     long startMillis = chrono.add(endMillis, durationMillis, -1); [EOL]     return new Interval(startMillis, endMillis, chrono); [EOL] }
public Interval withDurationBeforeEnd(ReadableDuration duration) { [EOL]     long durationMillis = DateTimeUtils.getDurationMillis(duration); [EOL]     if (durationMillis == toDurationMillis()) { [EOL]         return this; [EOL]     } [EOL]     Chronology chrono = getChronology(); [EOL]     long endMillis = getEndMillis(); [EOL]     long startMillis = chrono.add(endMillis, durationMillis, -1); [EOL]     return new Interval(startMillis, endMillis, chrono); [EOL] }
public Interval withDurationBeforeEnd(ReadableDuration duration) { [EOL]     long durationMillis = DateTimeUtils.getDurationMillis(duration); [EOL]     if (durationMillis == toDurationMillis()) { [EOL]         return this; [EOL]     } [EOL]     Chronology chrono = getChronology(); [EOL]     long endMillis = getEndMillis(); [EOL]     long startMillis = chrono.add(endMillis, durationMillis, -1); [EOL]     return new Interval(startMillis, endMillis, chrono); [EOL] }
public Interval withPeriodAfterStart(ReadablePeriod period) { [EOL]     if (period == null) { [EOL]         return withDurationAfterStart(null); [EOL]     } [EOL]     Chronology chrono = getChronology(); [EOL]     long startMillis = getStartMillis(); [EOL]     long endMillis = chrono.add(period, startMillis, 1); [EOL]     return new Interval(startMillis, endMillis, chrono); [EOL] }
public Interval withPeriodAfterStart(ReadablePeriod period) { [EOL]     if (period == null) { [EOL]         return withDurationAfterStart(null); [EOL]     } [EOL]     Chronology chrono = getChronology(); [EOL]     long startMillis = getStartMillis(); [EOL]     long endMillis = chrono.add(period, startMillis, 1); [EOL]     return new Interval(startMillis, endMillis, chrono); [EOL] }
public YearMonth(long instant) { [EOL]     super(instant); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth(long instant) { [EOL]     super(instant); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth(long instant) { [EOL]     super(instant); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth(long instant) { [EOL]     super(instant); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth(long instant) { [EOL]     super(instant); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth(long instant) { [EOL]     super(instant); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth(long instant) { [EOL]     super(instant); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth(long instant) { [EOL]     super(instant); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth(long instant) { [EOL]     super(instant); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth(long instant) { [EOL]     super(instant); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth(long instant) { [EOL]     super(instant); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth(long instant) { [EOL]     super(instant); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth(long instant) { [EOL]     super(instant); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth(long instant) { [EOL]     super(instant); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth(long instant) { [EOL]     super(instant); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth(long instant) { [EOL]     super(instant); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth(Object instant) { [EOL]     super(instant, null, ISODateTimeFormat.localDateParser()); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth(Object instant) { [EOL]     super(instant, null, ISODateTimeFormat.localDateParser()); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth(Object instant) { [EOL]     super(instant, null, ISODateTimeFormat.localDateParser()); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth(Object instant) { [EOL]     super(instant, null, ISODateTimeFormat.localDateParser()); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth(Object instant) { [EOL]     super(instant, null, ISODateTimeFormat.localDateParser()); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth(Object instant) { [EOL]     super(instant, null, ISODateTimeFormat.localDateParser()); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth(Object instant) { [EOL]     super(instant, null, ISODateTimeFormat.localDateParser()); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth(Object instant) { [EOL]     super(instant, null, ISODateTimeFormat.localDateParser()); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth(Object instant) { [EOL]     super(instant, null, ISODateTimeFormat.localDateParser()); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth(int year, int monthOfYear) { [EOL]     this(year, monthOfYear, null); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth(int year, int monthOfYear) { [EOL]     this(year, monthOfYear, null); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth(int year, int monthOfYear) { [EOL]     this(year, monthOfYear, null); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth(int year, int monthOfYear) { [EOL]     this(year, monthOfYear, null); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth(int year, int monthOfYear) { [EOL]     this(year, monthOfYear, null); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth(int year, int monthOfYear) { [EOL]     this(year, monthOfYear, null); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth(int year, int monthOfYear) { [EOL]     this(year, monthOfYear, null); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth(int year, int monthOfYear) { [EOL]     this(year, monthOfYear, null); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth(int year, int monthOfYear) { [EOL]     this(year, monthOfYear, null); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth(int year, int monthOfYear) { [EOL]     this(year, monthOfYear, null); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth(int year, int monthOfYear) { [EOL]     this(year, monthOfYear, null); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth(int year, int monthOfYear) { [EOL]     this(year, monthOfYear, null); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth(int year, int monthOfYear) { [EOL]     this(year, monthOfYear, null); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth(int year, int monthOfYear, Chronology chronology) { [EOL]     super(new int[] { year, monthOfYear }, chronology); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth(int year, int monthOfYear, Chronology chronology) { [EOL]     super(new int[] { year, monthOfYear }, chronology); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth(int year, int monthOfYear, Chronology chronology) { [EOL]     super(new int[] { year, monthOfYear }, chronology); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth(int year, int monthOfYear, Chronology chronology) { [EOL]     super(new int[] { year, monthOfYear }, chronology); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
YearMonth(YearMonth partial, int[] values) { [EOL]     super(partial, values); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
YearMonth(YearMonth partial, int[] values) { [EOL]     super(partial, values); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
YearMonth(YearMonth partial, int[] values) { [EOL]     super(partial, values); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
YearMonth(YearMonth partial, int[] values) { [EOL]     super(partial, values); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
YearMonth(YearMonth partial, int[] values) { [EOL]     super(partial, values); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
YearMonth(YearMonth partial, int[] values) { [EOL]     super(partial, values); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
YearMonth(YearMonth partial, int[] values) { [EOL]     super(partial, values); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
YearMonth(YearMonth partial, int[] values) { [EOL]     super(partial, values); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
YearMonth(YearMonth partial, int[] values) { [EOL]     super(partial, values); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
YearMonth(YearMonth partial, int[] values) { [EOL]     super(partial, values); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
YearMonth(YearMonth partial, int[] values) { [EOL]     super(partial, values); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
YearMonth(YearMonth partial, int[] values) { [EOL]     super(partial, values); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public int size() { [EOL]     return 2; [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
protected DateTimeField getField(int index, Chronology chrono) { [EOL]     switch(index) { [EOL]         case YEAR: [EOL]             return chrono.year(); [EOL]         case MONTH_OF_YEAR: [EOL]             return chrono.monthOfYear(); [EOL]         default: [EOL]             throw new IndexOutOfBoundsException("Invalid index: " + index); [EOL]     } [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public DateTimeFieldType[] getFieldTypes() { [EOL]     return (DateTimeFieldType[]) FIELD_TYPES.clone(); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public DateTimeFieldType[] getFieldTypes() { [EOL]     return (DateTimeFieldType[]) FIELD_TYPES.clone(); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public DateTimeFieldType[] getFieldTypes() { [EOL]     return (DateTimeFieldType[]) FIELD_TYPES.clone(); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public DateTimeFieldType[] getFieldTypes() { [EOL]     return (DateTimeFieldType[]) FIELD_TYPES.clone(); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public DateTimeFieldType[] getFieldTypes() { [EOL]     return (DateTimeFieldType[]) FIELD_TYPES.clone(); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public DateTimeFieldType[] getFieldTypes() { [EOL]     return (DateTimeFieldType[]) FIELD_TYPES.clone(); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public DateTimeFieldType[] getFieldTypes() { [EOL]     return (DateTimeFieldType[]) FIELD_TYPES.clone(); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public DateTimeFieldType[] getFieldTypes() { [EOL]     return (DateTimeFieldType[]) FIELD_TYPES.clone(); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public DateTimeFieldType[] getFieldTypes() { [EOL]     return (DateTimeFieldType[]) FIELD_TYPES.clone(); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public DateTimeFieldType[] getFieldTypes() { [EOL]     return (DateTimeFieldType[]) FIELD_TYPES.clone(); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public DateTimeFieldType[] getFieldTypes() { [EOL]     return (DateTimeFieldType[]) FIELD_TYPES.clone(); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public DateTimeFieldType[] getFieldTypes() { [EOL]     return (DateTimeFieldType[]) FIELD_TYPES.clone(); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public DateTimeFieldType[] getFieldTypes() { [EOL]     return (DateTimeFieldType[]) FIELD_TYPES.clone(); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public DateTimeFieldType[] getFieldTypes() { [EOL]     return (DateTimeFieldType[]) FIELD_TYPES.clone(); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public DateTimeFieldType[] getFieldTypes() { [EOL]     return (DateTimeFieldType[]) FIELD_TYPES.clone(); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public DateTimeFieldType[] getFieldTypes() { [EOL]     return (DateTimeFieldType[]) FIELD_TYPES.clone(); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public DateTimeFieldType[] getFieldTypes() { [EOL]     return (DateTimeFieldType[]) FIELD_TYPES.clone(); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public DateTimeFieldType[] getFieldTypes() { [EOL]     return (DateTimeFieldType[]) FIELD_TYPES.clone(); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public DateTimeFieldType[] getFieldTypes() { [EOL]     return (DateTimeFieldType[]) FIELD_TYPES.clone(); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth withChronologyRetainFields(Chronology newChronology) { [EOL]     newChronology = DateTimeUtils.getChronology(newChronology); [EOL]     newChronology = newChronology.withUTC(); [EOL]     if (newChronology == getChronology()) { [EOL]         return this; [EOL]     } else { [EOL]         YearMonth newYearMonth = new YearMonth(this, newChronology); [EOL]         newChronology.validate(newYearMonth, getValues()); [EOL]         return newYearMonth; [EOL]     } [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth withChronologyRetainFields(Chronology newChronology) { [EOL]     newChronology = DateTimeUtils.getChronology(newChronology); [EOL]     newChronology = newChronology.withUTC(); [EOL]     if (newChronology == getChronology()) { [EOL]         return this; [EOL]     } else { [EOL]         YearMonth newYearMonth = new YearMonth(this, newChronology); [EOL]         newChronology.validate(newYearMonth, getValues()); [EOL]         return newYearMonth; [EOL]     } [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth withFieldAdded(DurationFieldType fieldType, int amount) { [EOL]     int index = indexOfSupported(fieldType); [EOL]     if (amount == 0) { [EOL]         return this; [EOL]     } [EOL]     int[] newValues = getValues(); [EOL]     newValues = getField(index).add(this, index, newValues, amount); [EOL]     return new YearMonth(this, newValues); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth withFieldAdded(DurationFieldType fieldType, int amount) { [EOL]     int index = indexOfSupported(fieldType); [EOL]     if (amount == 0) { [EOL]         return this; [EOL]     } [EOL]     int[] newValues = getValues(); [EOL]     newValues = getField(index).add(this, index, newValues, amount); [EOL]     return new YearMonth(this, newValues); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth withFieldAdded(DurationFieldType fieldType, int amount) { [EOL]     int index = indexOfSupported(fieldType); [EOL]     if (amount == 0) { [EOL]         return this; [EOL]     } [EOL]     int[] newValues = getValues(); [EOL]     newValues = getField(index).add(this, index, newValues, amount); [EOL]     return new YearMonth(this, newValues); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth withPeriodAdded(ReadablePeriod period, int scalar) { [EOL]     if (period == null || scalar == 0) { [EOL]         return this; [EOL]     } [EOL]     int[] newValues = getValues(); [EOL]     for (int i = 0; i < period.size(); i++) { [EOL]         DurationFieldType fieldType = period.getFieldType(i); [EOL]         int index = indexOf(fieldType); [EOL]         if (index >= 0) { [EOL]             newValues = getField(index).add(this, index, newValues, FieldUtils.safeMultiply(period.getValue(i), scalar)); [EOL]         } [EOL]     } [EOL]     return new YearMonth(this, newValues); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth withPeriodAdded(ReadablePeriod period, int scalar) { [EOL]     if (period == null || scalar == 0) { [EOL]         return this; [EOL]     } [EOL]     int[] newValues = getValues(); [EOL]     for (int i = 0; i < period.size(); i++) { [EOL]         DurationFieldType fieldType = period.getFieldType(i); [EOL]         int index = indexOf(fieldType); [EOL]         if (index >= 0) { [EOL]             newValues = getField(index).add(this, index, newValues, FieldUtils.safeMultiply(period.getValue(i), scalar)); [EOL]         } [EOL]     } [EOL]     return new YearMonth(this, newValues); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth withPeriodAdded(ReadablePeriod period, int scalar) { [EOL]     if (period == null || scalar == 0) { [EOL]         return this; [EOL]     } [EOL]     int[] newValues = getValues(); [EOL]     for (int i = 0; i < period.size(); i++) { [EOL]         DurationFieldType fieldType = period.getFieldType(i); [EOL]         int index = indexOf(fieldType); [EOL]         if (index >= 0) { [EOL]             newValues = getField(index).add(this, index, newValues, FieldUtils.safeMultiply(period.getValue(i), scalar)); [EOL]         } [EOL]     } [EOL]     return new YearMonth(this, newValues); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth withPeriodAdded(ReadablePeriod period, int scalar) { [EOL]     if (period == null || scalar == 0) { [EOL]         return this; [EOL]     } [EOL]     int[] newValues = getValues(); [EOL]     for (int i = 0; i < period.size(); i++) { [EOL]         DurationFieldType fieldType = period.getFieldType(i); [EOL]         int index = indexOf(fieldType); [EOL]         if (index >= 0) { [EOL]             newValues = getField(index).add(this, index, newValues, FieldUtils.safeMultiply(period.getValue(i), scalar)); [EOL]         } [EOL]     } [EOL]     return new YearMonth(this, newValues); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth withPeriodAdded(ReadablePeriod period, int scalar) { [EOL]     if (period == null || scalar == 0) { [EOL]         return this; [EOL]     } [EOL]     int[] newValues = getValues(); [EOL]     for (int i = 0; i < period.size(); i++) { [EOL]         DurationFieldType fieldType = period.getFieldType(i); [EOL]         int index = indexOf(fieldType); [EOL]         if (index >= 0) { [EOL]             newValues = getField(index).add(this, index, newValues, FieldUtils.safeMultiply(period.getValue(i), scalar)); [EOL]         } [EOL]     } [EOL]     return new YearMonth(this, newValues); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth plus(ReadablePeriod period) { [EOL]     return withPeriodAdded(period, 1); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth plus(ReadablePeriod period) { [EOL]     return withPeriodAdded(period, 1); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth plusYears(int years) { [EOL]     return withFieldAdded(DurationFieldType.years(), years); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth plusYears(int years) { [EOL]     return withFieldAdded(DurationFieldType.years(), years); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth plusYears(int years) { [EOL]     return withFieldAdded(DurationFieldType.years(), years); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth plusMonths(int months) { [EOL]     return withFieldAdded(DurationFieldType.months(), months); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth minus(ReadablePeriod period) { [EOL]     return withPeriodAdded(period, -1); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth minus(ReadablePeriod period) { [EOL]     return withPeriodAdded(period, -1); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public LocalDate toLocalDate(int dayOfMonth) { [EOL]     return new LocalDate(getYear(), getMonthOfYear(), dayOfMonth, getChronology()); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public LocalDate toLocalDate(int dayOfMonth) { [EOL]     return new LocalDate(getYear(), getMonthOfYear(), dayOfMonth, getChronology()); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public LocalDate toLocalDate(int dayOfMonth) { [EOL]     return new LocalDate(getYear(), getMonthOfYear(), dayOfMonth, getChronology()); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public LocalDate toLocalDate(int dayOfMonth) { [EOL]     return new LocalDate(getYear(), getMonthOfYear(), dayOfMonth, getChronology()); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public LocalDate toLocalDate(int dayOfMonth) { [EOL]     return new LocalDate(getYear(), getMonthOfYear(), dayOfMonth, getChronology()); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public LocalDate toLocalDate(int dayOfMonth) { [EOL]     return new LocalDate(getYear(), getMonthOfYear(), dayOfMonth, getChronology()); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public LocalDate toLocalDate(int dayOfMonth) { [EOL]     return new LocalDate(getYear(), getMonthOfYear(), dayOfMonth, getChronology()); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public LocalDate toLocalDate(int dayOfMonth) { [EOL]     return new LocalDate(getYear(), getMonthOfYear(), dayOfMonth, getChronology()); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public LocalDate toLocalDate(int dayOfMonth) { [EOL]     return new LocalDate(getYear(), getMonthOfYear(), dayOfMonth, getChronology()); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public LocalDate toLocalDate(int dayOfMonth) { [EOL]     return new LocalDate(getYear(), getMonthOfYear(), dayOfMonth, getChronology()); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public LocalDate toLocalDate(int dayOfMonth) { [EOL]     return new LocalDate(getYear(), getMonthOfYear(), dayOfMonth, getChronology()); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public LocalDate toLocalDate(int dayOfMonth) { [EOL]     return new LocalDate(getYear(), getMonthOfYear(), dayOfMonth, getChronology()); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public LocalDate toLocalDate(int dayOfMonth) { [EOL]     return new LocalDate(getYear(), getMonthOfYear(), dayOfMonth, getChronology()); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public LocalDate toLocalDate(int dayOfMonth) { [EOL]     return new LocalDate(getYear(), getMonthOfYear(), dayOfMonth, getChronology()); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public LocalDate toLocalDate(int dayOfMonth) { [EOL]     return new LocalDate(getYear(), getMonthOfYear(), dayOfMonth, getChronology()); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public LocalDate toLocalDate(int dayOfMonth) { [EOL]     return new LocalDate(getYear(), getMonthOfYear(), dayOfMonth, getChronology()); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public LocalDate toLocalDate(int dayOfMonth) { [EOL]     return new LocalDate(getYear(), getMonthOfYear(), dayOfMonth, getChronology()); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public Interval toInterval() { [EOL]     return toInterval(null); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public Interval toInterval() { [EOL]     return toInterval(null); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public Interval toInterval() { [EOL]     return toInterval(null); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public Interval toInterval() { [EOL]     return toInterval(null); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public Interval toInterval() { [EOL]     return toInterval(null); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public Interval toInterval() { [EOL]     return toInterval(null); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public Interval toInterval() { [EOL]     return toInterval(null); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public Interval toInterval() { [EOL]     return toInterval(null); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public Interval toInterval() { [EOL]     return toInterval(null); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public Interval toInterval() { [EOL]     return toInterval(null); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public Interval toInterval() { [EOL]     return toInterval(null); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public Interval toInterval() { [EOL]     return toInterval(null); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public Interval toInterval() { [EOL]     return toInterval(null); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public Interval toInterval() { [EOL]     return toInterval(null); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public Interval toInterval() { [EOL]     return toInterval(null); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public Interval toInterval() { [EOL]     return toInterval(null); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public Interval toInterval() { [EOL]     return toInterval(null); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public Interval toInterval() { [EOL]     return toInterval(null); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public Interval toInterval() { [EOL]     return toInterval(null); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public Interval toInterval(DateTimeZone zone) { [EOL]     zone = DateTimeUtils.getZone(zone); [EOL]     DateTime start = toLocalDate(1).toDateTimeAtStartOfDay(zone); [EOL]     DateTime end = plusMonths(1).toLocalDate(1).toDateTimeAtStartOfDay(zone); [EOL]     return new Interval(start, end); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public int getYear() { [EOL]     return getValue(YEAR); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public int getMonthOfYear() { [EOL]     return getValue(MONTH_OF_YEAR); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public int getMonthOfYear() { [EOL]     return getValue(MONTH_OF_YEAR); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public int getMonthOfYear() { [EOL]     return getValue(MONTH_OF_YEAR); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public int getMonthOfYear() { [EOL]     return getValue(MONTH_OF_YEAR); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public int getMonthOfYear() { [EOL]     return getValue(MONTH_OF_YEAR); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public int getMonthOfYear() { [EOL]     return getValue(MONTH_OF_YEAR); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public int getMonthOfYear() { [EOL]     return getValue(MONTH_OF_YEAR); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public int getMonthOfYear() { [EOL]     return getValue(MONTH_OF_YEAR); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public int getMonthOfYear() { [EOL]     return getValue(MONTH_OF_YEAR); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public int getMonthOfYear() { [EOL]     return getValue(MONTH_OF_YEAR); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public int getMonthOfYear() { [EOL]     return getValue(MONTH_OF_YEAR); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public int getMonthOfYear() { [EOL]     return getValue(MONTH_OF_YEAR); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public int getMonthOfYear() { [EOL]     return getValue(MONTH_OF_YEAR); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public int getMonthOfYear() { [EOL]     return getValue(MONTH_OF_YEAR); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public int getMonthOfYear() { [EOL]     return getValue(MONTH_OF_YEAR); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public Property monthOfYear() { [EOL]     return new Property(this, MONTH_OF_YEAR); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
Property(YearMonth partial, int fieldIndex) { [EOL]     super(); [EOL]     iBase = partial; [EOL]     iFieldIndex = fieldIndex; [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
Property(YearMonth partial, int fieldIndex) { [EOL]     super(); [EOL]     iBase = partial; [EOL]     iFieldIndex = fieldIndex; [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
Property(YearMonth partial, int fieldIndex) { [EOL]     super(); [EOL]     iBase = partial; [EOL]     iFieldIndex = fieldIndex; [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
Property(YearMonth partial, int fieldIndex) { [EOL]     super(); [EOL]     iBase = partial; [EOL]     iFieldIndex = fieldIndex; [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
Property(YearMonth partial, int fieldIndex) { [EOL]     super(); [EOL]     iBase = partial; [EOL]     iFieldIndex = fieldIndex; [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
Property(YearMonth partial, int fieldIndex) { [EOL]     super(); [EOL]     iBase = partial; [EOL]     iFieldIndex = fieldIndex; [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
Property(YearMonth partial, int fieldIndex) { [EOL]     super(); [EOL]     iBase = partial; [EOL]     iFieldIndex = fieldIndex; [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
Property(YearMonth partial, int fieldIndex) { [EOL]     super(); [EOL]     iBase = partial; [EOL]     iFieldIndex = fieldIndex; [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
Property(YearMonth partial, int fieldIndex) { [EOL]     super(); [EOL]     iBase = partial; [EOL]     iFieldIndex = fieldIndex; [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
Property(YearMonth partial, int fieldIndex) { [EOL]     super(); [EOL]     iBase = partial; [EOL]     iFieldIndex = fieldIndex; [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public DateTimeField getField() { [EOL]     return iBase.getField(iFieldIndex); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth getYearMonth() { [EOL]     return iBase; [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth getYearMonth() { [EOL]     return iBase; [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth getYearMonth() { [EOL]     return iBase; [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth getYearMonth() { [EOL]     return iBase; [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth getYearMonth() { [EOL]     return iBase; [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth getYearMonth() { [EOL]     return iBase; [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth getYearMonth() { [EOL]     return iBase; [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth getYearMonth() { [EOL]     return iBase; [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth getYearMonth() { [EOL]     return iBase; [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth getYearMonth() { [EOL]     return iBase; [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth getYearMonth() { [EOL]     return iBase; [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public int get() { [EOL]     return iBase.getValue(iFieldIndex); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public int get() { [EOL]     return iBase.getValue(iFieldIndex); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public int get() { [EOL]     return iBase.getValue(iFieldIndex); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public int get() { [EOL]     return iBase.getValue(iFieldIndex); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public int get() { [EOL]     return iBase.getValue(iFieldIndex); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public int get() { [EOL]     return iBase.getValue(iFieldIndex); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public int get() { [EOL]     return iBase.getValue(iFieldIndex); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public int get() { [EOL]     return iBase.getValue(iFieldIndex); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public int get() { [EOL]     return iBase.getValue(iFieldIndex); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public int get() { [EOL]     return iBase.getValue(iFieldIndex); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public int get() { [EOL]     return iBase.getValue(iFieldIndex); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public int get() { [EOL]     return iBase.getValue(iFieldIndex); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public int get() { [EOL]     return iBase.getValue(iFieldIndex); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public int get() { [EOL]     return iBase.getValue(iFieldIndex); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public int get() { [EOL]     return iBase.getValue(iFieldIndex); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public int get() { [EOL]     return iBase.getValue(iFieldIndex); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public int get() { [EOL]     return iBase.getValue(iFieldIndex); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public int get() { [EOL]     return iBase.getValue(iFieldIndex); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public int get() { [EOL]     return iBase.getValue(iFieldIndex); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth setCopy(int value) { [EOL]     int[] newValues = iBase.getValues(); [EOL]     newValues = getField().set(iBase, iFieldIndex, newValues, value); [EOL]     return new YearMonth(iBase, newValues); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth setCopy(int value) { [EOL]     int[] newValues = iBase.getValues(); [EOL]     newValues = getField().set(iBase, iFieldIndex, newValues, value); [EOL]     return new YearMonth(iBase, newValues); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth setCopy(int value) { [EOL]     int[] newValues = iBase.getValues(); [EOL]     newValues = getField().set(iBase, iFieldIndex, newValues, value); [EOL]     return new YearMonth(iBase, newValues); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth setCopy(int value) { [EOL]     int[] newValues = iBase.getValues(); [EOL]     newValues = getField().set(iBase, iFieldIndex, newValues, value); [EOL]     return new YearMonth(iBase, newValues); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public String getAsText(ReadablePartial partial, int fieldValue, Locale locale) { [EOL]     return getAsText(fieldValue, locale); [EOL] }
public int[] addWrapPartial(ReadablePartial instant, int fieldIndex, int[] values, int valueToAdd) { [EOL]     if (valueToAdd == 0) { [EOL]         return values; [EOL]     } [EOL]     DateTimeField nextField = null; [EOL]     while (valueToAdd > 0) { [EOL]         int max = getMaximumValue(instant, values); [EOL]         long proposed = values[fieldIndex] + valueToAdd; [EOL]         if (proposed <= max) { [EOL]             values[fieldIndex] = (int) proposed; [EOL]             break; [EOL]         } [EOL]         if (nextField == null) { [EOL]             if (fieldIndex == 0) { [EOL]                 valueToAdd -= (max + 1) - values[fieldIndex]; [EOL]                 values[fieldIndex] = getMinimumValue(instant, values); [EOL]                 continue; [EOL]             } [EOL]             nextField = instant.getField(fieldIndex - 1); [EOL]             if (getRangeDurationField().getType() != nextField.getDurationField().getType()) { [EOL]                 throw new IllegalArgumentException("Fields invalid for add"); [EOL]             } [EOL]         } [EOL]         valueToAdd -= (max + 1) - values[fieldIndex]; [EOL]         values = nextField.addWrapPartial(instant, fieldIndex - 1, values, 1); [EOL]         values[fieldIndex] = getMinimumValue(instant, values); [EOL]     } [EOL]     while (valueToAdd < 0) { [EOL]         int min = getMinimumValue(instant, values); [EOL]         long proposed = values[fieldIndex] + valueToAdd; [EOL]         if (proposed >= min) { [EOL]             values[fieldIndex] = (int) proposed; [EOL]             break; [EOL]         } [EOL]         if (nextField == null) { [EOL]             if (fieldIndex == 0) { [EOL]                 valueToAdd -= (min - 1) - values[fieldIndex]; [EOL]                 values[fieldIndex] = getMaximumValue(instant, values); [EOL]                 continue; [EOL]             } [EOL]             nextField = instant.getField(fieldIndex - 1); [EOL]             if (getRangeDurationField().getType() != nextField.getDurationField().getType()) { [EOL]                 throw new IllegalArgumentException("Fields invalid for add"); [EOL]             } [EOL]         } [EOL]         valueToAdd -= (min - 1) - values[fieldIndex]; [EOL]         values = nextField.addWrapPartial(instant, fieldIndex - 1, values, -1); [EOL]         values[fieldIndex] = getMaximumValue(instant, values); [EOL]     } [EOL]     return set(instant, fieldIndex, values, values[fieldIndex]); [EOL] }
public int[] addWrapPartial(ReadablePartial instant, int fieldIndex, int[] values, int valueToAdd) { [EOL]     if (valueToAdd == 0) { [EOL]         return values; [EOL]     } [EOL]     DateTimeField nextField = null; [EOL]     while (valueToAdd > 0) { [EOL]         int max = getMaximumValue(instant, values); [EOL]         long proposed = values[fieldIndex] + valueToAdd; [EOL]         if (proposed <= max) { [EOL]             values[fieldIndex] = (int) proposed; [EOL]             break; [EOL]         } [EOL]         if (nextField == null) { [EOL]             if (fieldIndex == 0) { [EOL]                 valueToAdd -= (max + 1) - values[fieldIndex]; [EOL]                 values[fieldIndex] = getMinimumValue(instant, values); [EOL]                 continue; [EOL]             } [EOL]             nextField = instant.getField(fieldIndex - 1); [EOL]             if (getRangeDurationField().getType() != nextField.getDurationField().getType()) { [EOL]                 throw new IllegalArgumentException("Fields invalid for add"); [EOL]             } [EOL]         } [EOL]         valueToAdd -= (max + 1) - values[fieldIndex]; [EOL]         values = nextField.addWrapPartial(instant, fieldIndex - 1, values, 1); [EOL]         values[fieldIndex] = getMinimumValue(instant, values); [EOL]     } [EOL]     while (valueToAdd < 0) { [EOL]         int min = getMinimumValue(instant, values); [EOL]         long proposed = values[fieldIndex] + valueToAdd; [EOL]         if (proposed >= min) { [EOL]             values[fieldIndex] = (int) proposed; [EOL]             break; [EOL]         } [EOL]         if (nextField == null) { [EOL]             if (fieldIndex == 0) { [EOL]                 valueToAdd -= (min - 1) - values[fieldIndex]; [EOL]                 values[fieldIndex] = getMaximumValue(instant, values); [EOL]                 continue; [EOL]             } [EOL]             nextField = instant.getField(fieldIndex - 1); [EOL]             if (getRangeDurationField().getType() != nextField.getDurationField().getType()) { [EOL]                 throw new IllegalArgumentException("Fields invalid for add"); [EOL]             } [EOL]         } [EOL]         valueToAdd -= (min - 1) - values[fieldIndex]; [EOL]         values = nextField.addWrapPartial(instant, fieldIndex - 1, values, -1); [EOL]         values[fieldIndex] = getMaximumValue(instant, values); [EOL]     } [EOL]     return set(instant, fieldIndex, values, values[fieldIndex]); [EOL] }
public int[] addWrapPartial(ReadablePartial instant, int fieldIndex, int[] values, int valueToAdd) { [EOL]     if (valueToAdd == 0) { [EOL]         return values; [EOL]     } [EOL]     DateTimeField nextField = null; [EOL]     while (valueToAdd > 0) { [EOL]         int max = getMaximumValue(instant, values); [EOL]         long proposed = values[fieldIndex] + valueToAdd; [EOL]         if (proposed <= max) { [EOL]             values[fieldIndex] = (int) proposed; [EOL]             break; [EOL]         } [EOL]         if (nextField == null) { [EOL]             if (fieldIndex == 0) { [EOL]                 valueToAdd -= (max + 1) - values[fieldIndex]; [EOL]                 values[fieldIndex] = getMinimumValue(instant, values); [EOL]                 continue; [EOL]             } [EOL]             nextField = instant.getField(fieldIndex - 1); [EOL]             if (getRangeDurationField().getType() != nextField.getDurationField().getType()) { [EOL]                 throw new IllegalArgumentException("Fields invalid for add"); [EOL]             } [EOL]         } [EOL]         valueToAdd -= (max + 1) - values[fieldIndex]; [EOL]         values = nextField.addWrapPartial(instant, fieldIndex - 1, values, 1); [EOL]         values[fieldIndex] = getMinimumValue(instant, values); [EOL]     } [EOL]     while (valueToAdd < 0) { [EOL]         int min = getMinimumValue(instant, values); [EOL]         long proposed = values[fieldIndex] + valueToAdd; [EOL]         if (proposed >= min) { [EOL]             values[fieldIndex] = (int) proposed; [EOL]             break; [EOL]         } [EOL]         if (nextField == null) { [EOL]             if (fieldIndex == 0) { [EOL]                 valueToAdd -= (min - 1) - values[fieldIndex]; [EOL]                 values[fieldIndex] = getMaximumValue(instant, values); [EOL]                 continue; [EOL]             } [EOL]             nextField = instant.getField(fieldIndex - 1); [EOL]             if (getRangeDurationField().getType() != nextField.getDurationField().getType()) { [EOL]                 throw new IllegalArgumentException("Fields invalid for add"); [EOL]             } [EOL]         } [EOL]         valueToAdd -= (min - 1) - values[fieldIndex]; [EOL]         values = nextField.addWrapPartial(instant, fieldIndex - 1, values, -1); [EOL]         values[fieldIndex] = getMaximumValue(instant, values); [EOL]     } [EOL]     return set(instant, fieldIndex, values, values[fieldIndex]); [EOL] }
public int[] addWrapPartial(ReadablePartial instant, int fieldIndex, int[] values, int valueToAdd) { [EOL]     if (valueToAdd == 0) { [EOL]         return values; [EOL]     } [EOL]     DateTimeField nextField = null; [EOL]     while (valueToAdd > 0) { [EOL]         int max = getMaximumValue(instant, values); [EOL]         long proposed = values[fieldIndex] + valueToAdd; [EOL]         if (proposed <= max) { [EOL]             values[fieldIndex] = (int) proposed; [EOL]             break; [EOL]         } [EOL]         if (nextField == null) { [EOL]             if (fieldIndex == 0) { [EOL]                 valueToAdd -= (max + 1) - values[fieldIndex]; [EOL]                 values[fieldIndex] = getMinimumValue(instant, values); [EOL]                 continue; [EOL]             } [EOL]             nextField = instant.getField(fieldIndex - 1); [EOL]             if (getRangeDurationField().getType() != nextField.getDurationField().getType()) { [EOL]                 throw new IllegalArgumentException("Fields invalid for add"); [EOL]             } [EOL]         } [EOL]         valueToAdd -= (max + 1) - values[fieldIndex]; [EOL]         values = nextField.addWrapPartial(instant, fieldIndex - 1, values, 1); [EOL]         values[fieldIndex] = getMinimumValue(instant, values); [EOL]     } [EOL]     while (valueToAdd < 0) { [EOL]         int min = getMinimumValue(instant, values); [EOL]         long proposed = values[fieldIndex] + valueToAdd; [EOL]         if (proposed >= min) { [EOL]             values[fieldIndex] = (int) proposed; [EOL]             break; [EOL]         } [EOL]         if (nextField == null) { [EOL]             if (fieldIndex == 0) { [EOL]                 valueToAdd -= (min - 1) - values[fieldIndex]; [EOL]                 values[fieldIndex] = getMaximumValue(instant, values); [EOL]                 continue; [EOL]             } [EOL]             nextField = instant.getField(fieldIndex - 1); [EOL]             if (getRangeDurationField().getType() != nextField.getDurationField().getType()) { [EOL]                 throw new IllegalArgumentException("Fields invalid for add"); [EOL]             } [EOL]         } [EOL]         valueToAdd -= (min - 1) - values[fieldIndex]; [EOL]         values = nextField.addWrapPartial(instant, fieldIndex - 1, values, -1); [EOL]         values[fieldIndex] = getMaximumValue(instant, values); [EOL]     } [EOL]     return set(instant, fieldIndex, values, values[fieldIndex]); [EOL] }
public int[] addWrapPartial(ReadablePartial instant, int fieldIndex, int[] values, int valueToAdd) { [EOL]     if (valueToAdd == 0) { [EOL]         return values; [EOL]     } [EOL]     DateTimeField nextField = null; [EOL]     while (valueToAdd > 0) { [EOL]         int max = getMaximumValue(instant, values); [EOL]         long proposed = values[fieldIndex] + valueToAdd; [EOL]         if (proposed <= max) { [EOL]             values[fieldIndex] = (int) proposed; [EOL]             break; [EOL]         } [EOL]         if (nextField == null) { [EOL]             if (fieldIndex == 0) { [EOL]                 valueToAdd -= (max + 1) - values[fieldIndex]; [EOL]                 values[fieldIndex] = getMinimumValue(instant, values); [EOL]                 continue; [EOL]             } [EOL]             nextField = instant.getField(fieldIndex - 1); [EOL]             if (getRangeDurationField().getType() != nextField.getDurationField().getType()) { [EOL]                 throw new IllegalArgumentException("Fields invalid for add"); [EOL]             } [EOL]         } [EOL]         valueToAdd -= (max + 1) - values[fieldIndex]; [EOL]         values = nextField.addWrapPartial(instant, fieldIndex - 1, values, 1); [EOL]         values[fieldIndex] = getMinimumValue(instant, values); [EOL]     } [EOL]     while (valueToAdd < 0) { [EOL]         int min = getMinimumValue(instant, values); [EOL]         long proposed = values[fieldIndex] + valueToAdd; [EOL]         if (proposed >= min) { [EOL]             values[fieldIndex] = (int) proposed; [EOL]             break; [EOL]         } [EOL]         if (nextField == null) { [EOL]             if (fieldIndex == 0) { [EOL]                 valueToAdd -= (min - 1) - values[fieldIndex]; [EOL]                 values[fieldIndex] = getMaximumValue(instant, values); [EOL]                 continue; [EOL]             } [EOL]             nextField = instant.getField(fieldIndex - 1); [EOL]             if (getRangeDurationField().getType() != nextField.getDurationField().getType()) { [EOL]                 throw new IllegalArgumentException("Fields invalid for add"); [EOL]             } [EOL]         } [EOL]         valueToAdd -= (min - 1) - values[fieldIndex]; [EOL]         values = nextField.addWrapPartial(instant, fieldIndex - 1, values, -1); [EOL]         values[fieldIndex] = getMaximumValue(instant, values); [EOL]     } [EOL]     return set(instant, fieldIndex, values, values[fieldIndex]); [EOL] }
public int[] addWrapPartial(ReadablePartial instant, int fieldIndex, int[] values, int valueToAdd) { [EOL]     if (valueToAdd == 0) { [EOL]         return values; [EOL]     } [EOL]     DateTimeField nextField = null; [EOL]     while (valueToAdd > 0) { [EOL]         int max = getMaximumValue(instant, values); [EOL]         long proposed = values[fieldIndex] + valueToAdd; [EOL]         if (proposed <= max) { [EOL]             values[fieldIndex] = (int) proposed; [EOL]             break; [EOL]         } [EOL]         if (nextField == null) { [EOL]             if (fieldIndex == 0) { [EOL]                 valueToAdd -= (max + 1) - values[fieldIndex]; [EOL]                 values[fieldIndex] = getMinimumValue(instant, values); [EOL]                 continue; [EOL]             } [EOL]             nextField = instant.getField(fieldIndex - 1); [EOL]             if (getRangeDurationField().getType() != nextField.getDurationField().getType()) { [EOL]                 throw new IllegalArgumentException("Fields invalid for add"); [EOL]             } [EOL]         } [EOL]         valueToAdd -= (max + 1) - values[fieldIndex]; [EOL]         values = nextField.addWrapPartial(instant, fieldIndex - 1, values, 1); [EOL]         values[fieldIndex] = getMinimumValue(instant, values); [EOL]     } [EOL]     while (valueToAdd < 0) { [EOL]         int min = getMinimumValue(instant, values); [EOL]         long proposed = values[fieldIndex] + valueToAdd; [EOL]         if (proposed >= min) { [EOL]             values[fieldIndex] = (int) proposed; [EOL]             break; [EOL]         } [EOL]         if (nextField == null) { [EOL]             if (fieldIndex == 0) { [EOL]                 valueToAdd -= (min - 1) - values[fieldIndex]; [EOL]                 values[fieldIndex] = getMaximumValue(instant, values); [EOL]                 continue; [EOL]             } [EOL]             nextField = instant.getField(fieldIndex - 1); [EOL]             if (getRangeDurationField().getType() != nextField.getDurationField().getType()) { [EOL]                 throw new IllegalArgumentException("Fields invalid for add"); [EOL]             } [EOL]         } [EOL]         valueToAdd -= (min - 1) - values[fieldIndex]; [EOL]         values = nextField.addWrapPartial(instant, fieldIndex - 1, values, -1); [EOL]         values[fieldIndex] = getMaximumValue(instant, values); [EOL]     } [EOL]     return set(instant, fieldIndex, values, values[fieldIndex]); [EOL] }
public int[] addWrapPartial(ReadablePartial instant, int fieldIndex, int[] values, int valueToAdd) { [EOL]     if (valueToAdd == 0) { [EOL]         return values; [EOL]     } [EOL]     DateTimeField nextField = null; [EOL]     while (valueToAdd > 0) { [EOL]         int max = getMaximumValue(instant, values); [EOL]         long proposed = values[fieldIndex] + valueToAdd; [EOL]         if (proposed <= max) { [EOL]             values[fieldIndex] = (int) proposed; [EOL]             break; [EOL]         } [EOL]         if (nextField == null) { [EOL]             if (fieldIndex == 0) { [EOL]                 valueToAdd -= (max + 1) - values[fieldIndex]; [EOL]                 values[fieldIndex] = getMinimumValue(instant, values); [EOL]                 continue; [EOL]             } [EOL]             nextField = instant.getField(fieldIndex - 1); [EOL]             if (getRangeDurationField().getType() != nextField.getDurationField().getType()) { [EOL]                 throw new IllegalArgumentException("Fields invalid for add"); [EOL]             } [EOL]         } [EOL]         valueToAdd -= (max + 1) - values[fieldIndex]; [EOL]         values = nextField.addWrapPartial(instant, fieldIndex - 1, values, 1); [EOL]         values[fieldIndex] = getMinimumValue(instant, values); [EOL]     } [EOL]     while (valueToAdd < 0) { [EOL]         int min = getMinimumValue(instant, values); [EOL]         long proposed = values[fieldIndex] + valueToAdd; [EOL]         if (proposed >= min) { [EOL]             values[fieldIndex] = (int) proposed; [EOL]             break; [EOL]         } [EOL]         if (nextField == null) { [EOL]             if (fieldIndex == 0) { [EOL]                 valueToAdd -= (min - 1) - values[fieldIndex]; [EOL]                 values[fieldIndex] = getMaximumValue(instant, values); [EOL]                 continue; [EOL]             } [EOL]             nextField = instant.getField(fieldIndex - 1); [EOL]             if (getRangeDurationField().getType() != nextField.getDurationField().getType()) { [EOL]                 throw new IllegalArgumentException("Fields invalid for add"); [EOL]             } [EOL]         } [EOL]         valueToAdd -= (min - 1) - values[fieldIndex]; [EOL]         values = nextField.addWrapPartial(instant, fieldIndex - 1, values, -1); [EOL]         values[fieldIndex] = getMaximumValue(instant, values); [EOL]     } [EOL]     return set(instant, fieldIndex, values, values[fieldIndex]); [EOL] }
BasicDayOfMonthDateTimeField(BasicChronology chronology, DurationField days) { [EOL]     super(DateTimeFieldType.dayOfMonth(), days); [EOL]     iChronology = chronology; [EOL] }
BasicDayOfMonthDateTimeField(BasicChronology chronology, DurationField days) { [EOL]     super(DateTimeFieldType.dayOfMonth(), days); [EOL]     iChronology = chronology; [EOL] }
public DurationField getRangeDurationField() { [EOL]     return iChronology.months(); [EOL] }
public int getMaximumValue(ReadablePartial partial, int[] values) { [EOL]     int size = partial.size(); [EOL]     for (int i = 0; i < size; i++) { [EOL]         if (partial.getFieldType(i) == DateTimeFieldType.monthOfYear()) { [EOL]             int month = values[i]; [EOL]             for (int j = 0; j < size; j++) { [EOL]                 if (partial.getFieldType(j) == DateTimeFieldType.year()) { [EOL]                     int year = values[j]; [EOL]                     return iChronology.getDaysInYearMonth(year, month); [EOL]                 } [EOL]             } [EOL]             return iChronology.getDaysInMonthMax(month); [EOL]         } [EOL]     } [EOL]     return getMaximumValue(); [EOL] }
public int getMaximumValue(ReadablePartial partial, int[] values) { [EOL]     int size = partial.size(); [EOL]     for (int i = 0; i < size; i++) { [EOL]         if (partial.getFieldType(i) == DateTimeFieldType.monthOfYear()) { [EOL]             int month = values[i]; [EOL]             for (int j = 0; j < size; j++) { [EOL]                 if (partial.getFieldType(j) == DateTimeFieldType.year()) { [EOL]                     int year = values[j]; [EOL]                     return iChronology.getDaysInYearMonth(year, month); [EOL]                 } [EOL]             } [EOL]             return iChronology.getDaysInMonthMax(month); [EOL]         } [EOL]     } [EOL]     return getMaximumValue(); [EOL] }
public int getMaximumValue(ReadablePartial partial, int[] values) { [EOL]     int size = partial.size(); [EOL]     for (int i = 0; i < size; i++) { [EOL]         if (partial.getFieldType(i) == DateTimeFieldType.monthOfYear()) { [EOL]             int month = values[i]; [EOL]             for (int j = 0; j < size; j++) { [EOL]                 if (partial.getFieldType(j) == DateTimeFieldType.year()) { [EOL]                     int year = values[j]; [EOL]                     return iChronology.getDaysInYearMonth(year, month); [EOL]                 } [EOL]             } [EOL]             return iChronology.getDaysInMonthMax(month); [EOL]         } [EOL]     } [EOL]     return getMaximumValue(); [EOL] }
public static void appendPaddedInteger(StringBuffer buf, int value, int size) { [EOL]     if (value < 0) { [EOL]         buf.append('-'); [EOL]         if (value != Integer.MIN_VALUE) { [EOL]             value = -value; [EOL]         } else { [EOL]             for (; size > 10; size--) { [EOL]                 buf.append('0'); [EOL]             } [EOL]             buf.append("" + -(long) Integer.MIN_VALUE); [EOL]             return; [EOL]         } [EOL]     } [EOL]     if (value < 10) { [EOL]         for (; size > 1; size--) { [EOL]             buf.append('0'); [EOL]         } [EOL]         buf.append((char) (value + '0')); [EOL]     } else if (value < 100) { [EOL]         for (; size > 2; size--) { [EOL]             buf.append('0'); [EOL]         } [EOL]         int d = ((value + 1) * 13421772) >> 27; [EOL]         buf.append((char) (d + '0')); [EOL]         buf.append((char) (value - (d << 3) - (d << 1) + '0')); [EOL]     } else { [EOL]         int digits; [EOL]         if (value < 1000) { [EOL]             digits = 3; [EOL]         } else if (value < 10000) { [EOL]             digits = 4; [EOL]         } else { [EOL]             digits = (int) (Math.log(value) / LOG_10) + 1; [EOL]         } [EOL]         for (; size > digits; size--) { [EOL]             buf.append('0'); [EOL]         } [EOL]         buf.append(Integer.toString(value)); [EOL]     } [EOL] }
public static void appendUnpaddedInteger(StringBuffer buf, int value) { [EOL]     if (value < 0) { [EOL]         buf.append('-'); [EOL]         if (value != Integer.MIN_VALUE) { [EOL]             value = -value; [EOL]         } else { [EOL]             buf.append("" + -(long) Integer.MIN_VALUE); [EOL]             return; [EOL]         } [EOL]     } [EOL]     if (value < 10) { [EOL]         buf.append((char) (value + '0')); [EOL]     } else if (value < 100) { [EOL]         int d = ((value + 1) * 13421772) >> 27; [EOL]         buf.append((char) (d + '0')); [EOL]         buf.append((char) (value - (d << 3) - (d << 1) + '0')); [EOL]     } else { [EOL]         buf.append(Integer.toString(value)); [EOL]     } [EOL] }
public static void appendUnpaddedInteger(StringBuffer buf, int value) { [EOL]     if (value < 0) { [EOL]         buf.append('-'); [EOL]         if (value != Integer.MIN_VALUE) { [EOL]             value = -value; [EOL]         } else { [EOL]             buf.append("" + -(long) Integer.MIN_VALUE); [EOL]             return; [EOL]         } [EOL]     } [EOL]     if (value < 10) { [EOL]         buf.append((char) (value + '0')); [EOL]     } else if (value < 100) { [EOL]         int d = ((value + 1) * 13421772) >> 27; [EOL]         buf.append((char) (d + '0')); [EOL]         buf.append((char) (value - (d << 3) - (d << 1) + '0')); [EOL]     } else { [EOL]         buf.append(Integer.toString(value)); [EOL]     } [EOL] }
public static void appendUnpaddedInteger(StringBuffer buf, long value) { [EOL]     int intValue = (int) value; [EOL]     if (intValue == value) { [EOL]         appendUnpaddedInteger(buf, intValue); [EOL]     } else { [EOL]         buf.append(Long.toString(value)); [EOL]     } [EOL] }
public static void appendUnpaddedInteger(StringBuffer buf, long value) { [EOL]     int intValue = (int) value; [EOL]     if (intValue == value) { [EOL]         appendUnpaddedInteger(buf, intValue); [EOL]     } else { [EOL]         buf.append(Long.toString(value)); [EOL]     } [EOL] }
static String createErrorMessage(final String text, final int errorPos) { [EOL]     int sampleLen = errorPos + 32; [EOL]     String sampleText; [EOL]     if (text.length() <= sampleLen + 3) { [EOL]         sampleText = text; [EOL]     } else { [EOL]         sampleText = text.substring(0, sampleLen).concat("..."); [EOL]     } [EOL]     if (errorPos <= 0) { [EOL]         return "Invalid format: \"" + sampleText + '"'; [EOL]     } [EOL]     if (errorPos >= text.length()) { [EOL]         return "Invalid format: \"" + sampleText + "\" is too short"; [EOL]     } [EOL]     return "Invalid format: \"" + sampleText + "\" is malformed at \"" + sampleText.substring(errorPos) + '"'; [EOL] }
static String createErrorMessage(final String text, final int errorPos) { [EOL]     int sampleLen = errorPos + 32; [EOL]     String sampleText; [EOL]     if (text.length() <= sampleLen + 3) { [EOL]         sampleText = text; [EOL]     } else { [EOL]         sampleText = text.substring(0, sampleLen).concat("..."); [EOL]     } [EOL]     if (errorPos <= 0) { [EOL]         return "Invalid format: \"" + sampleText + '"'; [EOL]     } [EOL]     if (errorPos >= text.length()) { [EOL]         return "Invalid format: \"" + sampleText + "\" is too short"; [EOL]     } [EOL]     return "Invalid format: \"" + sampleText + "\" is malformed at \"" + sampleText.substring(errorPos) + '"'; [EOL] }
static String createErrorMessage(final String text, final int errorPos) { [EOL]     int sampleLen = errorPos + 32; [EOL]     String sampleText; [EOL]     if (text.length() <= sampleLen + 3) { [EOL]         sampleText = text; [EOL]     } else { [EOL]         sampleText = text.substring(0, sampleLen).concat("..."); [EOL]     } [EOL]     if (errorPos <= 0) { [EOL]         return "Invalid format: \"" + sampleText + '"'; [EOL]     } [EOL]     if (errorPos >= text.length()) { [EOL]         return "Invalid format: \"" + sampleText + "\" is too short"; [EOL]     } [EOL]     return "Invalid format: \"" + sampleText + "\" is malformed at \"" + sampleText.substring(errorPos) + '"'; [EOL] }
static String createErrorMessage(final String text, final int errorPos) { [EOL]     int sampleLen = errorPos + 32; [EOL]     String sampleText; [EOL]     if (text.length() <= sampleLen + 3) { [EOL]         sampleText = text; [EOL]     } else { [EOL]         sampleText = text.substring(0, sampleLen).concat("..."); [EOL]     } [EOL]     if (errorPos <= 0) { [EOL]         return "Invalid format: \"" + sampleText + '"'; [EOL]     } [EOL]     if (errorPos >= text.length()) { [EOL]         return "Invalid format: \"" + sampleText + "\" is too short"; [EOL]     } [EOL]     return "Invalid format: \"" + sampleText + "\" is malformed at \"" + sampleText.substring(errorPos) + '"'; [EOL] }
static String createErrorMessage(final String text, final int errorPos) { [EOL]     int sampleLen = errorPos + 32; [EOL]     String sampleText; [EOL]     if (text.length() <= sampleLen + 3) { [EOL]         sampleText = text; [EOL]     } else { [EOL]         sampleText = text.substring(0, sampleLen).concat("..."); [EOL]     } [EOL]     if (errorPos <= 0) { [EOL]         return "Invalid format: \"" + sampleText + '"'; [EOL]     } [EOL]     if (errorPos >= text.length()) { [EOL]         return "Invalid format: \"" + sampleText + "\" is too short"; [EOL]     } [EOL]     return "Invalid format: \"" + sampleText + "\" is malformed at \"" + sampleText.substring(errorPos) + '"'; [EOL] }
public static JulianChronology getInstanceUTC() { [EOL]     return INSTANCE_UTC; [EOL] }
public static JulianChronology getInstance() { [EOL]     return getInstance(DateTimeZone.getDefault(), 4); [EOL] }
public static JulianChronology getInstance(DateTimeZone zone) { [EOL]     return getInstance(zone, 4); [EOL] }
public static JulianChronology getInstance(DateTimeZone zone, int minDaysInFirstWeek) { [EOL]     if (zone == null) { [EOL]         zone = DateTimeZone.getDefault(); [EOL]     } [EOL]     JulianChronology chrono; [EOL]     synchronized (cCache) { [EOL]         JulianChronology[] chronos = cCache.get(zone); [EOL]         if (chronos == null) { [EOL]             chronos = new JulianChronology[7]; [EOL]             cCache.put(zone, chronos); [EOL]         } [EOL]         try { [EOL]             chrono = chronos[minDaysInFirstWeek - 1]; [EOL]         } catch (ArrayIndexOutOfBoundsException e) { [EOL]             throw new IllegalArgumentException("Invalid min days in first week: " + minDaysInFirstWeek); [EOL]         } [EOL]         if (chrono == null) { [EOL]             if (zone == DateTimeZone.UTC) { [EOL]                 chrono = new JulianChronology(null, null, minDaysInFirstWeek); [EOL]             } else { [EOL]                 chrono = getInstance(DateTimeZone.UTC, minDaysInFirstWeek); [EOL]                 chrono = new JulianChronology(ZonedChronology.getInstance(chrono, zone), null, minDaysInFirstWeek); [EOL]             } [EOL]             chronos[minDaysInFirstWeek - 1] = chrono; [EOL]         } [EOL]     } [EOL]     return chrono; [EOL] }
JulianChronology(Chronology base, Object param, int minDaysInFirstWeek) { [EOL]     super(base, param, minDaysInFirstWeek); [EOL] }
public Chronology withUTC() { [EOL]     return INSTANCE_UTC; [EOL] }
protected void assemble(Fields fields) { [EOL]     if (getBase() == null) { [EOL]         super.assemble(fields); [EOL]         fields.year = new SkipDateTimeField(this, fields.year); [EOL]         fields.weekyear = new SkipDateTimeField(this, fields.weekyear); [EOL]     } [EOL] }
public Class<?> getSupportedType() { [EOL]     return ReadableInstant.class; [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof BuddhistChronology) { [EOL]         BuddhistChronology chrono = (BuddhistChronology) obj; [EOL]         return getZone().equals(chrono.getZone()); [EOL]     } [EOL]     return false; [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof BuddhistChronology) { [EOL]         BuddhistChronology chrono = (BuddhistChronology) obj; [EOL]         return getZone().equals(chrono.getZone()); [EOL]     } [EOL]     return false; [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof BuddhistChronology) { [EOL]         BuddhistChronology chrono = (BuddhistChronology) obj; [EOL]         return getZone().equals(chrono.getZone()); [EOL]     } [EOL]     return false; [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof BuddhistChronology) { [EOL]         BuddhistChronology chrono = (BuddhistChronology) obj; [EOL]         return getZone().equals(chrono.getZone()); [EOL]     } [EOL]     return false; [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof BuddhistChronology) { [EOL]         BuddhistChronology chrono = (BuddhistChronology) obj; [EOL]         return getZone().equals(chrono.getZone()); [EOL]     } [EOL]     return false; [EOL] }
protected AbstractPartialFieldProperty() { [EOL]     super(); [EOL] }
public DateTimeFieldType getFieldType() { [EOL]     return getField().getType(); [EOL] }
public String getName() { [EOL]     return getField().getName(); [EOL] }
public String getAsString() { [EOL]     return Integer.toString(get()); [EOL] }
public String getAsText() { [EOL]     return getAsText(null); [EOL] }
public String getAsText(Locale locale) { [EOL]     return getField().getAsText(getReadablePartial(), get(), locale); [EOL] }
public String getAsText(Locale locale) { [EOL]     return getField().getAsText(getReadablePartial(), get(), locale); [EOL] }
public String getAsShortText() { [EOL]     return getAsShortText(null); [EOL] }
public String getAsShortText(Locale locale) { [EOL]     return getField().getAsShortText(getReadablePartial(), get(), locale); [EOL] }
public String getAsShortText(Locale locale) { [EOL]     return getField().getAsShortText(getReadablePartial(), get(), locale); [EOL] }
public DurationField getDurationField() { [EOL]     return getField().getDurationField(); [EOL] }
public DurationField getRangeDurationField() { [EOL]     return getField().getRangeDurationField(); [EOL] }
public int getMaximumTextLength(Locale locale) { [EOL]     return getField().getMaximumTextLength(locale); [EOL] }
public int getMaximumShortTextLength(Locale locale) { [EOL]     return getField().getMaximumShortTextLength(locale); [EOL] }
public int getMaximumShortTextLength(Locale locale) { [EOL]     return getField().getMaximumShortTextLength(locale); [EOL] }
public int compareTo(ReadableInstant instant) { [EOL]     if (instant == null) { [EOL]         throw new IllegalArgumentException("The instant must not be null"); [EOL]     } [EOL]     int thisValue = get(); [EOL]     int otherValue = instant.get(getFieldType()); [EOL]     if (thisValue < otherValue) { [EOL]         return -1; [EOL]     } else if (thisValue > otherValue) { [EOL]         return 1; [EOL]     } else { [EOL]         return 0; [EOL]     } [EOL] }
public int compareTo(ReadableInstant instant) { [EOL]     if (instant == null) { [EOL]         throw new IllegalArgumentException("The instant must not be null"); [EOL]     } [EOL]     int thisValue = get(); [EOL]     int otherValue = instant.get(getFieldType()); [EOL]     if (thisValue < otherValue) { [EOL]         return -1; [EOL]     } else if (thisValue > otherValue) { [EOL]         return 1; [EOL]     } else { [EOL]         return 0; [EOL]     } [EOL] }
public int compareTo(ReadableInstant instant) { [EOL]     if (instant == null) { [EOL]         throw new IllegalArgumentException("The instant must not be null"); [EOL]     } [EOL]     int thisValue = get(); [EOL]     int otherValue = instant.get(getFieldType()); [EOL]     if (thisValue < otherValue) { [EOL]         return -1; [EOL]     } else if (thisValue > otherValue) { [EOL]         return 1; [EOL]     } else { [EOL]         return 0; [EOL]     } [EOL] }
public int compareTo(ReadableInstant instant) { [EOL]     if (instant == null) { [EOL]         throw new IllegalArgumentException("The instant must not be null"); [EOL]     } [EOL]     int thisValue = get(); [EOL]     int otherValue = instant.get(getFieldType()); [EOL]     if (thisValue < otherValue) { [EOL]         return -1; [EOL]     } else if (thisValue > otherValue) { [EOL]         return 1; [EOL]     } else { [EOL]         return 0; [EOL]     } [EOL] }
public int compareTo(ReadablePartial partial) { [EOL]     if (partial == null) { [EOL]         throw new IllegalArgumentException("The instant must not be null"); [EOL]     } [EOL]     int thisValue = get(); [EOL]     int otherValue = partial.get(getFieldType()); [EOL]     if (thisValue < otherValue) { [EOL]         return -1; [EOL]     } else if (thisValue > otherValue) { [EOL]         return 1; [EOL]     } else { [EOL]         return 0; [EOL]     } [EOL] }
public int compareTo(ReadablePartial partial) { [EOL]     if (partial == null) { [EOL]         throw new IllegalArgumentException("The instant must not be null"); [EOL]     } [EOL]     int thisValue = get(); [EOL]     int otherValue = partial.get(getFieldType()); [EOL]     if (thisValue < otherValue) { [EOL]         return -1; [EOL]     } else if (thisValue > otherValue) { [EOL]         return 1; [EOL]     } else { [EOL]         return 0; [EOL]     } [EOL] }
public int compareTo(ReadablePartial partial) { [EOL]     if (partial == null) { [EOL]         throw new IllegalArgumentException("The instant must not be null"); [EOL]     } [EOL]     int thisValue = get(); [EOL]     int otherValue = partial.get(getFieldType()); [EOL]     if (thisValue < otherValue) { [EOL]         return -1; [EOL]     } else if (thisValue > otherValue) { [EOL]         return 1; [EOL]     } else { [EOL]         return 0; [EOL]     } [EOL] }
public int compareTo(ReadablePartial partial) { [EOL]     if (partial == null) { [EOL]         throw new IllegalArgumentException("The instant must not be null"); [EOL]     } [EOL]     int thisValue = get(); [EOL]     int otherValue = partial.get(getFieldType()); [EOL]     if (thisValue < otherValue) { [EOL]         return -1; [EOL]     } else if (thisValue > otherValue) { [EOL]         return 1; [EOL]     } else { [EOL]         return 0; [EOL]     } [EOL] }
public boolean equals(Object object) { [EOL]     if (this == object) { [EOL]         return true; [EOL]     } [EOL]     if (object instanceof AbstractPartialFieldProperty == false) { [EOL]         return false; [EOL]     } [EOL]     AbstractPartialFieldProperty other = (AbstractPartialFieldProperty) object; [EOL]     return get() == other.get() && getFieldType() == other.getFieldType() && FieldUtils.equals(getReadablePartial().getChronology(), other.getReadablePartial().getChronology()); [EOL] }
public boolean equals(Object object) { [EOL]     if (this == object) { [EOL]         return true; [EOL]     } [EOL]     if (object instanceof AbstractPartialFieldProperty == false) { [EOL]         return false; [EOL]     } [EOL]     AbstractPartialFieldProperty other = (AbstractPartialFieldProperty) object; [EOL]     return get() == other.get() && getFieldType() == other.getFieldType() && FieldUtils.equals(getReadablePartial().getChronology(), other.getReadablePartial().getChronology()); [EOL] }
public boolean equals(Object object) { [EOL]     if (this == object) { [EOL]         return true; [EOL]     } [EOL]     if (object instanceof AbstractPartialFieldProperty == false) { [EOL]         return false; [EOL]     } [EOL]     AbstractPartialFieldProperty other = (AbstractPartialFieldProperty) object; [EOL]     return get() == other.get() && getFieldType() == other.getFieldType() && FieldUtils.equals(getReadablePartial().getChronology(), other.getReadablePartial().getChronology()); [EOL] }
public boolean equals(Object object) { [EOL]     if (this == object) { [EOL]         return true; [EOL]     } [EOL]     if (object instanceof AbstractPartialFieldProperty == false) { [EOL]         return false; [EOL]     } [EOL]     AbstractPartialFieldProperty other = (AbstractPartialFieldProperty) object; [EOL]     return get() == other.get() && getFieldType() == other.getFieldType() && FieldUtils.equals(getReadablePartial().getChronology(), other.getReadablePartial().getChronology()); [EOL] }
public boolean equals(Object object) { [EOL]     if (this == object) { [EOL]         return true; [EOL]     } [EOL]     if (object instanceof AbstractPartialFieldProperty == false) { [EOL]         return false; [EOL]     } [EOL]     AbstractPartialFieldProperty other = (AbstractPartialFieldProperty) object; [EOL]     return get() == other.get() && getFieldType() == other.getFieldType() && FieldUtils.equals(getReadablePartial().getChronology(), other.getReadablePartial().getChronology()); [EOL] }
public boolean equals(Object object) { [EOL]     if (this == object) { [EOL]         return true; [EOL]     } [EOL]     if (object instanceof AbstractPartialFieldProperty == false) { [EOL]         return false; [EOL]     } [EOL]     AbstractPartialFieldProperty other = (AbstractPartialFieldProperty) object; [EOL]     return get() == other.get() && getFieldType() == other.getFieldType() && FieldUtils.equals(getReadablePartial().getChronology(), other.getReadablePartial().getChronology()); [EOL] }
public boolean equals(Object object) { [EOL]     if (this == object) { [EOL]         return true; [EOL]     } [EOL]     if (object instanceof AbstractPartialFieldProperty == false) { [EOL]         return false; [EOL]     } [EOL]     AbstractPartialFieldProperty other = (AbstractPartialFieldProperty) object; [EOL]     return get() == other.get() && getFieldType() == other.getFieldType() && FieldUtils.equals(getReadablePartial().getChronology(), other.getReadablePartial().getChronology()); [EOL] }
public String toString() { [EOL]     return "Property[" + getName() + "]"; [EOL] }
public long getMillis(int value, long instant) { [EOL]     return value * iUnitMillis; [EOL] }
public long getMillis(int value, long instant) { [EOL]     return value * iUnitMillis; [EOL] }
public long getMillis(int value, long instant) { [EOL]     return value * iUnitMillis; [EOL] }
public long add(long instant, int value) { [EOL]     long addition = value * iUnitMillis; [EOL]     return FieldUtils.safeAdd(instant, addition); [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } else if (obj instanceof PreciseDurationField) { [EOL]         PreciseDurationField other = (PreciseDurationField) obj; [EOL]         return (getType() == other.getType()) && (iUnitMillis == other.iUnitMillis); [EOL]     } [EOL]     return false; [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } else if (obj instanceof PreciseDurationField) { [EOL]         PreciseDurationField other = (PreciseDurationField) obj; [EOL]         return (getType() == other.getType()) && (iUnitMillis == other.iUnitMillis); [EOL]     } [EOL]     return false; [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } else if (obj instanceof PreciseDurationField) { [EOL]         PreciseDurationField other = (PreciseDurationField) obj; [EOL]         return (getType() == other.getType()) && (iUnitMillis == other.iUnitMillis); [EOL]     } [EOL]     return false; [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } else if (obj instanceof PreciseDurationField) { [EOL]         PreciseDurationField other = (PreciseDurationField) obj; [EOL]         return (getType() == other.getType()) && (iUnitMillis == other.iUnitMillis); [EOL]     } [EOL]     return false; [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } else if (obj instanceof PreciseDurationField) { [EOL]         PreciseDurationField other = (PreciseDurationField) obj; [EOL]         return (getType() == other.getType()) && (iUnitMillis == other.iUnitMillis); [EOL]     } [EOL]     return false; [EOL] }
public int[] add(ReadablePartial partial, int fieldIndex, int[] values, int valueToAdd) { [EOL]     if (valueToAdd == 0) { [EOL]         return values; [EOL]     } [EOL]     if (partial.size() > 0 && partial.getFieldType(0).equals(DateTimeFieldType.monthOfYear()) && fieldIndex == 0) { [EOL]         int curMonth0 = partial.getValue(0) - 1; [EOL]         int newMonth = ((curMonth0 + (valueToAdd % 12) + 12) % 12) + 1; [EOL]         return set(partial, 0, values, newMonth); [EOL]     } [EOL]     if (DateTimeUtils.isContiguous(partial)) { [EOL]         long instant = 0L; [EOL]         for (int i = 0, isize = partial.size(); i < isize; i++) { [EOL]             instant = partial.getFieldType(i).getField(iChronology).set(instant, values[i]); [EOL]         } [EOL]         instant = add(instant, valueToAdd); [EOL]         return iChronology.get(partial, instant); [EOL]     } else { [EOL]         return super.add(partial, fieldIndex, values, valueToAdd); [EOL]     } [EOL] }
public int[] add(ReadablePartial partial, int fieldIndex, int[] values, int valueToAdd) { [EOL]     if (valueToAdd == 0) { [EOL]         return values; [EOL]     } [EOL]     if (partial.size() > 0 && partial.getFieldType(0).equals(DateTimeFieldType.monthOfYear()) && fieldIndex == 0) { [EOL]         int curMonth0 = partial.getValue(0) - 1; [EOL]         int newMonth = ((curMonth0 + (valueToAdd % 12) + 12) % 12) + 1; [EOL]         return set(partial, 0, values, newMonth); [EOL]     } [EOL]     if (DateTimeUtils.isContiguous(partial)) { [EOL]         long instant = 0L; [EOL]         for (int i = 0, isize = partial.size(); i < isize; i++) { [EOL]             instant = partial.getFieldType(i).getField(iChronology).set(instant, values[i]); [EOL]         } [EOL]         instant = add(instant, valueToAdd); [EOL]         return iChronology.get(partial, instant); [EOL]     } else { [EOL]         return super.add(partial, fieldIndex, values, valueToAdd); [EOL]     } [EOL] }
public int[] add(ReadablePartial partial, int fieldIndex, int[] values, int valueToAdd) { [EOL]     if (valueToAdd == 0) { [EOL]         return values; [EOL]     } [EOL]     if (partial.size() > 0 && partial.getFieldType(0).equals(DateTimeFieldType.monthOfYear()) && fieldIndex == 0) { [EOL]         int curMonth0 = partial.getValue(0) - 1; [EOL]         int newMonth = ((curMonth0 + (valueToAdd % 12) + 12) % 12) + 1; [EOL]         return set(partial, 0, values, newMonth); [EOL]     } [EOL]     if (DateTimeUtils.isContiguous(partial)) { [EOL]         long instant = 0L; [EOL]         for (int i = 0, isize = partial.size(); i < isize; i++) { [EOL]             instant = partial.getFieldType(i).getField(iChronology).set(instant, values[i]); [EOL]         } [EOL]         instant = add(instant, valueToAdd); [EOL]         return iChronology.get(partial, instant); [EOL]     } else { [EOL]         return super.add(partial, fieldIndex, values, valueToAdd); [EOL]     } [EOL] }
public int[] add(ReadablePartial partial, int fieldIndex, int[] values, int valueToAdd) { [EOL]     if (valueToAdd == 0) { [EOL]         return values; [EOL]     } [EOL]     if (partial.size() > 0 && partial.getFieldType(0).equals(DateTimeFieldType.monthOfYear()) && fieldIndex == 0) { [EOL]         int curMonth0 = partial.getValue(0) - 1; [EOL]         int newMonth = ((curMonth0 + (valueToAdd % 12) + 12) % 12) + 1; [EOL]         return set(partial, 0, values, newMonth); [EOL]     } [EOL]     if (DateTimeUtils.isContiguous(partial)) { [EOL]         long instant = 0L; [EOL]         for (int i = 0, isize = partial.size(); i < isize; i++) { [EOL]             instant = partial.getFieldType(i).getField(iChronology).set(instant, values[i]); [EOL]         } [EOL]         instant = add(instant, valueToAdd); [EOL]         return iChronology.get(partial, instant); [EOL]     } else { [EOL]         return super.add(partial, fieldIndex, values, valueToAdd); [EOL]     } [EOL] }
public long addWrapField(long instant, int months) { [EOL]     return set(instant, FieldUtils.getWrappedValue(get(instant), months, MIN, iMax)); [EOL] }
public long addWrapField(long instant, int months) { [EOL]     return set(instant, FieldUtils.getWrappedValue(get(instant), months, MIN, iMax)); [EOL] }
public long addWrapField(long instant, int months) { [EOL]     return set(instant, FieldUtils.getWrappedValue(get(instant), months, MIN, iMax)); [EOL] }
public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) { [EOL]     if (minuendInstant < subtrahendInstant) { [EOL]         return -getDifference(subtrahendInstant, minuendInstant); [EOL]     } [EOL]     int minuendYear = iChronology.getYear(minuendInstant); [EOL]     int minuendMonth = iChronology.getMonthOfYear(minuendInstant, minuendYear); [EOL]     int subtrahendYear = iChronology.getYear(subtrahendInstant); [EOL]     int subtrahendMonth = iChronology.getMonthOfYear(subtrahendInstant, subtrahendYear); [EOL]     long difference = (minuendYear - subtrahendYear) * ((long) iMax) + minuendMonth - subtrahendMonth; [EOL]     int minuendDom = iChronology.getDayOfMonth(minuendInstant, minuendYear, minuendMonth); [EOL]     if (minuendDom == iChronology.getDaysInYearMonth(minuendYear, minuendMonth)) { [EOL]         int subtrahendDom = iChronology.getDayOfMonth(subtrahendInstant, subtrahendYear, subtrahendMonth); [EOL]         if (subtrahendDom > minuendDom) { [EOL]             subtrahendInstant = iChronology.dayOfMonth().set(subtrahendInstant, minuendDom); [EOL]         } [EOL]     } [EOL]     long minuendRem = minuendInstant - iChronology.getYearMonthMillis(minuendYear, minuendMonth); [EOL]     long subtrahendRem = subtrahendInstant - iChronology.getYearMonthMillis(subtrahendYear, subtrahendMonth); [EOL]     if (minuendRem < subtrahendRem) { [EOL]         difference--; [EOL]     } [EOL]     return difference; [EOL] }
public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) { [EOL]     if (minuendInstant < subtrahendInstant) { [EOL]         return -getDifference(subtrahendInstant, minuendInstant); [EOL]     } [EOL]     int minuendYear = iChronology.getYear(minuendInstant); [EOL]     int minuendMonth = iChronology.getMonthOfYear(minuendInstant, minuendYear); [EOL]     int subtrahendYear = iChronology.getYear(subtrahendInstant); [EOL]     int subtrahendMonth = iChronology.getMonthOfYear(subtrahendInstant, subtrahendYear); [EOL]     long difference = (minuendYear - subtrahendYear) * ((long) iMax) + minuendMonth - subtrahendMonth; [EOL]     int minuendDom = iChronology.getDayOfMonth(minuendInstant, minuendYear, minuendMonth); [EOL]     if (minuendDom == iChronology.getDaysInYearMonth(minuendYear, minuendMonth)) { [EOL]         int subtrahendDom = iChronology.getDayOfMonth(subtrahendInstant, subtrahendYear, subtrahendMonth); [EOL]         if (subtrahendDom > minuendDom) { [EOL]             subtrahendInstant = iChronology.dayOfMonth().set(subtrahendInstant, minuendDom); [EOL]         } [EOL]     } [EOL]     long minuendRem = minuendInstant - iChronology.getYearMonthMillis(minuendYear, minuendMonth); [EOL]     long subtrahendRem = subtrahendInstant - iChronology.getYearMonthMillis(subtrahendYear, subtrahendMonth); [EOL]     if (minuendRem < subtrahendRem) { [EOL]         difference--; [EOL]     } [EOL]     return difference; [EOL] }
public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) { [EOL]     if (minuendInstant < subtrahendInstant) { [EOL]         return -getDifference(subtrahendInstant, minuendInstant); [EOL]     } [EOL]     int minuendYear = iChronology.getYear(minuendInstant); [EOL]     int minuendMonth = iChronology.getMonthOfYear(minuendInstant, minuendYear); [EOL]     int subtrahendYear = iChronology.getYear(subtrahendInstant); [EOL]     int subtrahendMonth = iChronology.getMonthOfYear(subtrahendInstant, subtrahendYear); [EOL]     long difference = (minuendYear - subtrahendYear) * ((long) iMax) + minuendMonth - subtrahendMonth; [EOL]     int minuendDom = iChronology.getDayOfMonth(minuendInstant, minuendYear, minuendMonth); [EOL]     if (minuendDom == iChronology.getDaysInYearMonth(minuendYear, minuendMonth)) { [EOL]         int subtrahendDom = iChronology.getDayOfMonth(subtrahendInstant, subtrahendYear, subtrahendMonth); [EOL]         if (subtrahendDom > minuendDom) { [EOL]             subtrahendInstant = iChronology.dayOfMonth().set(subtrahendInstant, minuendDom); [EOL]         } [EOL]     } [EOL]     long minuendRem = minuendInstant - iChronology.getYearMonthMillis(minuendYear, minuendMonth); [EOL]     long subtrahendRem = subtrahendInstant - iChronology.getYearMonthMillis(subtrahendYear, subtrahendMonth); [EOL]     if (minuendRem < subtrahendRem) { [EOL]         difference--; [EOL]     } [EOL]     return difference; [EOL] }
public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) { [EOL]     if (minuendInstant < subtrahendInstant) { [EOL]         return -getDifference(subtrahendInstant, minuendInstant); [EOL]     } [EOL]     int minuendYear = iChronology.getYear(minuendInstant); [EOL]     int minuendMonth = iChronology.getMonthOfYear(minuendInstant, minuendYear); [EOL]     int subtrahendYear = iChronology.getYear(subtrahendInstant); [EOL]     int subtrahendMonth = iChronology.getMonthOfYear(subtrahendInstant, subtrahendYear); [EOL]     long difference = (minuendYear - subtrahendYear) * ((long) iMax) + minuendMonth - subtrahendMonth; [EOL]     int minuendDom = iChronology.getDayOfMonth(minuendInstant, minuendYear, minuendMonth); [EOL]     if (minuendDom == iChronology.getDaysInYearMonth(minuendYear, minuendMonth)) { [EOL]         int subtrahendDom = iChronology.getDayOfMonth(subtrahendInstant, subtrahendYear, subtrahendMonth); [EOL]         if (subtrahendDom > minuendDom) { [EOL]             subtrahendInstant = iChronology.dayOfMonth().set(subtrahendInstant, minuendDom); [EOL]         } [EOL]     } [EOL]     long minuendRem = minuendInstant - iChronology.getYearMonthMillis(minuendYear, minuendMonth); [EOL]     long subtrahendRem = subtrahendInstant - iChronology.getYearMonthMillis(subtrahendYear, subtrahendMonth); [EOL]     if (minuendRem < subtrahendRem) { [EOL]         difference--; [EOL]     } [EOL]     return difference; [EOL] }
public DurationField getRangeDurationField() { [EOL]     return iChronology.years(); [EOL] }
public int get(long instant) { [EOL]     return iChronology.getDayOfYear(instant); [EOL] }
public int getMinimumValue() { [EOL]     return 1; [EOL] }
public int getMaximumValue(long instant) { [EOL]     int year = iChronology.getYear(instant); [EOL]     return iChronology.getDaysInYear(year); [EOL] }
public int getMaximumValue(long instant) { [EOL]     int year = iChronology.getYear(instant); [EOL]     return iChronology.getDaysInYear(year); [EOL] }
protected int getMaximumValueForSet(long instant, int value) { [EOL]     int maxLessOne = iChronology.getDaysInYearMax() - 1; [EOL]     return (value > maxLessOne || value < 1) ? getMaximumValue(instant) : maxLessOne; [EOL] }
protected int getMaximumValueForSet(long instant, int value) { [EOL]     int maxLessOne = iChronology.getDaysInYearMax() - 1; [EOL]     return (value > maxLessOne || value < 1) ? getMaximumValue(instant) : maxLessOne; [EOL] }
protected int getMaximumValueForSet(long instant, int value) { [EOL]     int maxLessOne = iChronology.getDaysInYearMax() - 1; [EOL]     return (value > maxLessOne || value < 1) ? getMaximumValue(instant) : maxLessOne; [EOL] }
public static long safeAdd(long val1, long val2) { [EOL]     long sum = val1 + val2; [EOL]     if ((val1 ^ sum) < 0 && (val1 ^ val2) >= 0) { [EOL]         throw new ArithmeticException("The calculation caused an overflow: " + val1 + " + " + val2); [EOL]     } [EOL]     return sum; [EOL] }
public static long safeAdd(long val1, long val2) { [EOL]     long sum = val1 + val2; [EOL]     if ((val1 ^ sum) < 0 && (val1 ^ val2) >= 0) { [EOL]         throw new ArithmeticException("The calculation caused an overflow: " + val1 + " + " + val2); [EOL]     } [EOL]     return sum; [EOL] }
public static long safeAdd(long val1, long val2) { [EOL]     long sum = val1 + val2; [EOL]     if ((val1 ^ sum) < 0 && (val1 ^ val2) >= 0) { [EOL]         throw new ArithmeticException("The calculation caused an overflow: " + val1 + " + " + val2); [EOL]     } [EOL]     return sum; [EOL] }
public static long safeDivide(long dividend, long divisor) { [EOL]     if (dividend == Long.MIN_VALUE && divisor == -1L) { [EOL]         throw new ArithmeticException("Multiplication overflows a long: " + dividend + " / " + divisor); [EOL]     } [EOL]     return dividend / divisor; [EOL] }
public static long safeDivide(long dividend, long divisor) { [EOL]     if (dividend == Long.MIN_VALUE && divisor == -1L) { [EOL]         throw new ArithmeticException("Multiplication overflows a long: " + dividend + " / " + divisor); [EOL]     } [EOL]     return dividend / divisor; [EOL] }
public static long safeDivide(long dividend, long divisor) { [EOL]     if (dividend == Long.MIN_VALUE && divisor == -1L) { [EOL]         throw new ArithmeticException("Multiplication overflows a long: " + dividend + " / " + divisor); [EOL]     } [EOL]     return dividend / divisor; [EOL] }
public static long safeDivide(long dividend, long divisor) { [EOL]     if (dividend == Long.MIN_VALUE && divisor == -1L) { [EOL]         throw new ArithmeticException("Multiplication overflows a long: " + dividend + " / " + divisor); [EOL]     } [EOL]     return dividend / divisor; [EOL] }
public static long safeDivide(long dividend, long divisor) { [EOL]     if (dividend == Long.MIN_VALUE && divisor == -1L) { [EOL]         throw new ArithmeticException("Multiplication overflows a long: " + dividend + " / " + divisor); [EOL]     } [EOL]     return dividend / divisor; [EOL] }
public static long safeDivide(long dividend, long divisor) { [EOL]     if (dividend == Long.MIN_VALUE && divisor == -1L) { [EOL]         throw new ArithmeticException("Multiplication overflows a long: " + dividend + " / " + divisor); [EOL]     } [EOL]     return dividend / divisor; [EOL] }
public static long safeDivide(long dividend, long divisor) { [EOL]     if (dividend == Long.MIN_VALUE && divisor == -1L) { [EOL]         throw new ArithmeticException("Multiplication overflows a long: " + dividend + " / " + divisor); [EOL]     } [EOL]     return dividend / divisor; [EOL] }
public static boolean equals(Object object1, Object object2) { [EOL]     if (object1 == object2) { [EOL]         return true; [EOL]     } [EOL]     if (object1 == null || object2 == null) { [EOL]         return false; [EOL]     } [EOL]     return object1.equals(object2); [EOL] }
public static boolean equals(Object object1, Object object2) { [EOL]     if (object1 == object2) { [EOL]         return true; [EOL]     } [EOL]     if (object1 == null || object2 == null) { [EOL]         return false; [EOL]     } [EOL]     return object1.equals(object2); [EOL] }
public static boolean equals(Object object1, Object object2) { [EOL]     if (object1 == object2) { [EOL]         return true; [EOL]     } [EOL]     if (object1 == null || object2 == null) { [EOL]         return false; [EOL]     } [EOL]     return object1.equals(object2); [EOL] }
public static boolean equals(Object object1, Object object2) { [EOL]     if (object1 == object2) { [EOL]         return true; [EOL]     } [EOL]     if (object1 == null || object2 == null) { [EOL]         return false; [EOL]     } [EOL]     return object1.equals(object2); [EOL] }
public static boolean equals(Object object1, Object object2) { [EOL]     if (object1 == object2) { [EOL]         return true; [EOL]     } [EOL]     if (object1 == null || object2 == null) { [EOL]         return false; [EOL]     } [EOL]     return object1.equals(object2); [EOL] }
public DurationField getDurationField() { [EOL]     return iField.getDurationField(); [EOL] }
public DurationField getRangeDurationField() { [EOL]     return iField.getRangeDurationField(); [EOL] }
public DurationField getRangeDurationField() { [EOL]     return iField.getRangeDurationField(); [EOL] }
public InstantConverter getInstantConverter(Object object) { [EOL]     InstantConverter converter = (InstantConverter) iInstantConverters.select(object == null ? null : object.getClass()); [EOL]     if (converter != null) { [EOL]         return converter; [EOL]     } [EOL]     throw new IllegalArgumentException("No instant converter found for type: " + (object == null ? "null" : object.getClass().getName())); [EOL] }
public InstantConverter getInstantConverter(Object object) { [EOL]     InstantConverter converter = (InstantConverter) iInstantConverters.select(object == null ? null : object.getClass()); [EOL]     if (converter != null) { [EOL]         return converter; [EOL]     } [EOL]     throw new IllegalArgumentException("No instant converter found for type: " + (object == null ? "null" : object.getClass().getName())); [EOL] }
public InstantConverter getInstantConverter(Object object) { [EOL]     InstantConverter converter = (InstantConverter) iInstantConverters.select(object == null ? null : object.getClass()); [EOL]     if (converter != null) { [EOL]         return converter; [EOL]     } [EOL]     throw new IllegalArgumentException("No instant converter found for type: " + (object == null ? "null" : object.getClass().getName())); [EOL] }
public InstantConverter[] getInstantConverters() { [EOL]     ConverterSet set = iInstantConverters; [EOL]     InstantConverter[] converters = new InstantConverter[set.size()]; [EOL]     set.copyInto(converters); [EOL]     return converters; [EOL] }
public InstantConverter[] getInstantConverters() { [EOL]     ConverterSet set = iInstantConverters; [EOL]     InstantConverter[] converters = new InstantConverter[set.size()]; [EOL]     set.copyInto(converters); [EOL]     return converters; [EOL] }
public InstantConverter addInstantConverter(InstantConverter converter) throws SecurityException { [EOL]     checkAlterInstantConverters(); [EOL]     if (converter == null) { [EOL]         return null; [EOL]     } [EOL]     InstantConverter[] removed = new InstantConverter[1]; [EOL]     iInstantConverters = iInstantConverters.add(converter, removed); [EOL]     return removed[0]; [EOL] }
public InstantConverter addInstantConverter(InstantConverter converter) throws SecurityException { [EOL]     checkAlterInstantConverters(); [EOL]     if (converter == null) { [EOL]         return null; [EOL]     } [EOL]     InstantConverter[] removed = new InstantConverter[1]; [EOL]     iInstantConverters = iInstantConverters.add(converter, removed); [EOL]     return removed[0]; [EOL] }
public InstantConverter addInstantConverter(InstantConverter converter) throws SecurityException { [EOL]     checkAlterInstantConverters(); [EOL]     if (converter == null) { [EOL]         return null; [EOL]     } [EOL]     InstantConverter[] removed = new InstantConverter[1]; [EOL]     iInstantConverters = iInstantConverters.add(converter, removed); [EOL]     return removed[0]; [EOL] }
public InstantConverter removeInstantConverter(InstantConverter converter) throws SecurityException { [EOL]     checkAlterInstantConverters(); [EOL]     if (converter == null) { [EOL]         return null; [EOL]     } [EOL]     InstantConverter[] removed = new InstantConverter[1]; [EOL]     iInstantConverters = iInstantConverters.remove(converter, removed); [EOL]     return removed[0]; [EOL] }
private void checkAlterInstantConverters() throws SecurityException { [EOL]     SecurityManager sm = System.getSecurityManager(); [EOL]     if (sm != null) { [EOL]         sm.checkPermission(new JodaTimePermission("ConverterManager.alterInstantConverters")); [EOL]     } [EOL] }
private void checkAlterInstantConverters() throws SecurityException { [EOL]     SecurityManager sm = System.getSecurityManager(); [EOL]     if (sm != null) { [EOL]         sm.checkPermission(new JodaTimePermission("ConverterManager.alterInstantConverters")); [EOL]     } [EOL] }
public PartialConverter getPartialConverter(Object object) { [EOL]     PartialConverter converter = (PartialConverter) iPartialConverters.select(object == null ? null : object.getClass()); [EOL]     if (converter != null) { [EOL]         return converter; [EOL]     } [EOL]     throw new IllegalArgumentException("No partial converter found for type: " + (object == null ? "null" : object.getClass().getName())); [EOL] }
public PartialConverter getPartialConverter(Object object) { [EOL]     PartialConverter converter = (PartialConverter) iPartialConverters.select(object == null ? null : object.getClass()); [EOL]     if (converter != null) { [EOL]         return converter; [EOL]     } [EOL]     throw new IllegalArgumentException("No partial converter found for type: " + (object == null ? "null" : object.getClass().getName())); [EOL] }
public PartialConverter getPartialConverter(Object object) { [EOL]     PartialConverter converter = (PartialConverter) iPartialConverters.select(object == null ? null : object.getClass()); [EOL]     if (converter != null) { [EOL]         return converter; [EOL]     } [EOL]     throw new IllegalArgumentException("No partial converter found for type: " + (object == null ? "null" : object.getClass().getName())); [EOL] }
public PartialConverter[] getPartialConverters() { [EOL]     ConverterSet set = iPartialConverters; [EOL]     PartialConverter[] converters = new PartialConverter[set.size()]; [EOL]     set.copyInto(converters); [EOL]     return converters; [EOL] }
public PartialConverter[] getPartialConverters() { [EOL]     ConverterSet set = iPartialConverters; [EOL]     PartialConverter[] converters = new PartialConverter[set.size()]; [EOL]     set.copyInto(converters); [EOL]     return converters; [EOL] }
public PartialConverter removePartialConverter(PartialConverter converter) throws SecurityException { [EOL]     checkAlterPartialConverters(); [EOL]     if (converter == null) { [EOL]         return null; [EOL]     } [EOL]     PartialConverter[] removed = new PartialConverter[1]; [EOL]     iPartialConverters = iPartialConverters.remove(converter, removed); [EOL]     return removed[0]; [EOL] }
public PartialConverter removePartialConverter(PartialConverter converter) throws SecurityException { [EOL]     checkAlterPartialConverters(); [EOL]     if (converter == null) { [EOL]         return null; [EOL]     } [EOL]     PartialConverter[] removed = new PartialConverter[1]; [EOL]     iPartialConverters = iPartialConverters.remove(converter, removed); [EOL]     return removed[0]; [EOL] }
public PartialConverter removePartialConverter(PartialConverter converter) throws SecurityException { [EOL]     checkAlterPartialConverters(); [EOL]     if (converter == null) { [EOL]         return null; [EOL]     } [EOL]     PartialConverter[] removed = new PartialConverter[1]; [EOL]     iPartialConverters = iPartialConverters.remove(converter, removed); [EOL]     return removed[0]; [EOL] }
private void checkAlterPartialConverters() throws SecurityException { [EOL]     SecurityManager sm = System.getSecurityManager(); [EOL]     if (sm != null) { [EOL]         sm.checkPermission(new JodaTimePermission("ConverterManager.alterPartialConverters")); [EOL]     } [EOL] }
private void checkAlterPartialConverters() throws SecurityException { [EOL]     SecurityManager sm = System.getSecurityManager(); [EOL]     if (sm != null) { [EOL]         sm.checkPermission(new JodaTimePermission("ConverterManager.alterPartialConverters")); [EOL]     } [EOL] }
public IntervalConverter addIntervalConverter(IntervalConverter converter) throws SecurityException { [EOL]     checkAlterIntervalConverters(); [EOL]     if (converter == null) { [EOL]         return null; [EOL]     } [EOL]     IntervalConverter[] removed = new IntervalConverter[1]; [EOL]     iIntervalConverters = iIntervalConverters.add(converter, removed); [EOL]     return removed[0]; [EOL] }
public IntervalConverter addIntervalConverter(IntervalConverter converter) throws SecurityException { [EOL]     checkAlterIntervalConverters(); [EOL]     if (converter == null) { [EOL]         return null; [EOL]     } [EOL]     IntervalConverter[] removed = new IntervalConverter[1]; [EOL]     iIntervalConverters = iIntervalConverters.add(converter, removed); [EOL]     return removed[0]; [EOL] }
public boolean isSupported() { [EOL]     return iField.isSupported(); [EOL] }
public boolean isSupported() { [EOL]     return iField.isSupported(); [EOL] }
public long add(long instant, int value) { [EOL]     return iField.add(instant, value); [EOL] }
public long set(long instant, int value) { [EOL]     return iField.set(instant, value); [EOL] }
public long set(long instant, int value) { [EOL]     return iField.set(instant, value); [EOL] }
public DurationField getRangeDurationField() { [EOL]     if (iRangeDurationField != null) { [EOL]         return iRangeDurationField; [EOL]     } [EOL]     return iField.getRangeDurationField(); [EOL] }
public DurationField getRangeDurationField() { [EOL]     if (iRangeDurationField != null) { [EOL]         return iRangeDurationField; [EOL]     } [EOL]     return iField.getRangeDurationField(); [EOL] }
public DurationField getLeapDurationField() { [EOL]     return iField.getLeapDurationField(); [EOL] }
public int getMaximumValue() { [EOL]     return iField.getMaximumValue(); [EOL] }
public int getMaximumValue(long instant) { [EOL]     return iField.getMaximumValue(instant); [EOL] }
public long roundFloor(long instant) { [EOL]     return iField.roundFloor(instant); [EOL] }
public long roundFloor(long instant) { [EOL]     return iField.roundFloor(instant); [EOL] }
public long roundFloor(long instant) { [EOL]     return iField.roundFloor(instant); [EOL] }
public static DateTimeComparator getInstance(DateTimeFieldType lowerLimit, DateTimeFieldType upperLimit) { [EOL]     if (lowerLimit == null && upperLimit == null) { [EOL]         return ALL_INSTANCE; [EOL]     } [EOL]     if (lowerLimit == DateTimeFieldType.dayOfYear() && upperLimit == null) { [EOL]         return DATE_INSTANCE; [EOL]     } [EOL]     if (lowerLimit == null && upperLimit == DateTimeFieldType.dayOfYear()) { [EOL]         return TIME_INSTANCE; [EOL]     } [EOL]     return new DateTimeComparator(lowerLimit, upperLimit); [EOL] }
public static DateTimeComparator getInstance(DateTimeFieldType lowerLimit, DateTimeFieldType upperLimit) { [EOL]     if (lowerLimit == null && upperLimit == null) { [EOL]         return ALL_INSTANCE; [EOL]     } [EOL]     if (lowerLimit == DateTimeFieldType.dayOfYear() && upperLimit == null) { [EOL]         return DATE_INSTANCE; [EOL]     } [EOL]     if (lowerLimit == null && upperLimit == DateTimeFieldType.dayOfYear()) { [EOL]         return TIME_INSTANCE; [EOL]     } [EOL]     return new DateTimeComparator(lowerLimit, upperLimit); [EOL] }
public static DateTimeComparator getInstance(DateTimeFieldType lowerLimit, DateTimeFieldType upperLimit) { [EOL]     if (lowerLimit == null && upperLimit == null) { [EOL]         return ALL_INSTANCE; [EOL]     } [EOL]     if (lowerLimit == DateTimeFieldType.dayOfYear() && upperLimit == null) { [EOL]         return DATE_INSTANCE; [EOL]     } [EOL]     if (lowerLimit == null && upperLimit == DateTimeFieldType.dayOfYear()) { [EOL]         return TIME_INSTANCE; [EOL]     } [EOL]     return new DateTimeComparator(lowerLimit, upperLimit); [EOL] }
public static DateTimeComparator getInstance(DateTimeFieldType lowerLimit, DateTimeFieldType upperLimit) { [EOL]     if (lowerLimit == null && upperLimit == null) { [EOL]         return ALL_INSTANCE; [EOL]     } [EOL]     if (lowerLimit == DateTimeFieldType.dayOfYear() && upperLimit == null) { [EOL]         return DATE_INSTANCE; [EOL]     } [EOL]     if (lowerLimit == null && upperLimit == DateTimeFieldType.dayOfYear()) { [EOL]         return TIME_INSTANCE; [EOL]     } [EOL]     return new DateTimeComparator(lowerLimit, upperLimit); [EOL] }
public static DateTimeComparator getTimeOnlyInstance() { [EOL]     return TIME_INSTANCE; [EOL] }
protected DateTimeComparator(DateTimeFieldType lowerLimit, DateTimeFieldType upperLimit) { [EOL]     super(); [EOL]     iLowerLimit = lowerLimit; [EOL]     iUpperLimit = upperLimit; [EOL] }
protected DateTimeComparator(DateTimeFieldType lowerLimit, DateTimeFieldType upperLimit) { [EOL]     super(); [EOL]     iLowerLimit = lowerLimit; [EOL]     iUpperLimit = upperLimit; [EOL] }
protected DateTimeComparator(DateTimeFieldType lowerLimit, DateTimeFieldType upperLimit) { [EOL]     super(); [EOL]     iLowerLimit = lowerLimit; [EOL]     iUpperLimit = upperLimit; [EOL] }
protected DateTimeComparator(DateTimeFieldType lowerLimit, DateTimeFieldType upperLimit) { [EOL]     super(); [EOL]     iLowerLimit = lowerLimit; [EOL]     iUpperLimit = upperLimit; [EOL] }
public boolean equals(Object object) { [EOL]     if (object instanceof DateTimeComparator) { [EOL]         DateTimeComparator other = (DateTimeComparator) object; [EOL]         return (iLowerLimit == other.getLowerLimit() || (iLowerLimit != null && iLowerLimit.equals(other.getLowerLimit()))) && (iUpperLimit == other.getUpperLimit() || (iUpperLimit != null && iUpperLimit.equals(other.getUpperLimit()))); [EOL]     } [EOL]     return false; [EOL] }
public boolean equals(Object object) { [EOL]     if (object instanceof DateTimeComparator) { [EOL]         DateTimeComparator other = (DateTimeComparator) object; [EOL]         return (iLowerLimit == other.getLowerLimit() || (iLowerLimit != null && iLowerLimit.equals(other.getLowerLimit()))) && (iUpperLimit == other.getUpperLimit() || (iUpperLimit != null && iUpperLimit.equals(other.getUpperLimit()))); [EOL]     } [EOL]     return false; [EOL] }
public boolean equals(Object object) { [EOL]     if (object instanceof DateTimeComparator) { [EOL]         DateTimeComparator other = (DateTimeComparator) object; [EOL]         return (iLowerLimit == other.getLowerLimit() || (iLowerLimit != null && iLowerLimit.equals(other.getLowerLimit()))) && (iUpperLimit == other.getUpperLimit() || (iUpperLimit != null && iUpperLimit.equals(other.getUpperLimit()))); [EOL]     } [EOL]     return false; [EOL] }
public boolean equals(Object object) { [EOL]     if (object instanceof DateTimeComparator) { [EOL]         DateTimeComparator other = (DateTimeComparator) object; [EOL]         return (iLowerLimit == other.getLowerLimit() || (iLowerLimit != null && iLowerLimit.equals(other.getLowerLimit()))) && (iUpperLimit == other.getUpperLimit() || (iUpperLimit != null && iUpperLimit.equals(other.getUpperLimit()))); [EOL]     } [EOL]     return false; [EOL] }
public boolean equals(Object object) { [EOL]     if (object instanceof DateTimeComparator) { [EOL]         DateTimeComparator other = (DateTimeComparator) object; [EOL]         return (iLowerLimit == other.getLowerLimit() || (iLowerLimit != null && iLowerLimit.equals(other.getLowerLimit()))) && (iUpperLimit == other.getUpperLimit() || (iUpperLimit != null && iUpperLimit.equals(other.getUpperLimit()))); [EOL]     } [EOL]     return false; [EOL] }
public boolean equals(Object object) { [EOL]     if (object instanceof DateTimeComparator) { [EOL]         DateTimeComparator other = (DateTimeComparator) object; [EOL]         return (iLowerLimit == other.getLowerLimit() || (iLowerLimit != null && iLowerLimit.equals(other.getLowerLimit()))) && (iUpperLimit == other.getUpperLimit() || (iUpperLimit != null && iUpperLimit.equals(other.getUpperLimit()))); [EOL]     } [EOL]     return false; [EOL] }
public int hashCode() { [EOL]     return (iLowerLimit == null ? 0 : iLowerLimit.hashCode()) + (123 * (iUpperLimit == null ? 0 : iUpperLimit.hashCode())); [EOL] }
public DurationFieldType getFieldType(int index) { [EOL]     if (index != 0) { [EOL]         throw new IndexOutOfBoundsException(String.valueOf(index)); [EOL]     } [EOL]     return getFieldType(); [EOL] }
public DurationFieldType getFieldType(int index) { [EOL]     if (index != 0) { [EOL]         throw new IndexOutOfBoundsException(String.valueOf(index)); [EOL]     } [EOL]     return getFieldType(); [EOL] }
public static StrictChronology getInstance(Chronology base) { [EOL]     if (base == null) { [EOL]         throw new IllegalArgumentException("Must supply a chronology"); [EOL]     } [EOL]     return new StrictChronology(base); [EOL] }
public static StrictChronology getInstance(Chronology base) { [EOL]     if (base == null) { [EOL]         throw new IllegalArgumentException("Must supply a chronology"); [EOL]     } [EOL]     return new StrictChronology(base); [EOL] }
private StrictChronology(Chronology base) { [EOL]     super(base, null); [EOL] }
protected void assemble(Fields fields) { [EOL]     fields.year = convertField(fields.year); [EOL]     fields.yearOfEra = convertField(fields.yearOfEra); [EOL]     fields.yearOfCentury = convertField(fields.yearOfCentury); [EOL]     fields.centuryOfEra = convertField(fields.centuryOfEra); [EOL]     fields.era = convertField(fields.era); [EOL]     fields.dayOfWeek = convertField(fields.dayOfWeek); [EOL]     fields.dayOfMonth = convertField(fields.dayOfMonth); [EOL]     fields.dayOfYear = convertField(fields.dayOfYear); [EOL]     fields.monthOfYear = convertField(fields.monthOfYear); [EOL]     fields.weekOfWeekyear = convertField(fields.weekOfWeekyear); [EOL]     fields.weekyear = convertField(fields.weekyear); [EOL]     fields.weekyearOfCentury = convertField(fields.weekyearOfCentury); [EOL]     fields.millisOfSecond = convertField(fields.millisOfSecond); [EOL]     fields.millisOfDay = convertField(fields.millisOfDay); [EOL]     fields.secondOfMinute = convertField(fields.secondOfMinute); [EOL]     fields.secondOfDay = convertField(fields.secondOfDay); [EOL]     fields.minuteOfHour = convertField(fields.minuteOfHour); [EOL]     fields.minuteOfDay = convertField(fields.minuteOfDay); [EOL]     fields.hourOfDay = convertField(fields.hourOfDay); [EOL]     fields.hourOfHalfday = convertField(fields.hourOfHalfday); [EOL]     fields.clockhourOfDay = convertField(fields.clockhourOfDay); [EOL]     fields.clockhourOfHalfday = convertField(fields.clockhourOfHalfday); [EOL]     fields.halfdayOfDay = convertField(fields.halfdayOfDay); [EOL] }
private static final DateTimeField convertField(DateTimeField field) { [EOL]     return StrictDateTimeField.getInstance(field); [EOL] }
private static final DateTimeField convertField(DateTimeField field) { [EOL]     return StrictDateTimeField.getInstance(field); [EOL] }
public String toString() { [EOL]     return "StrictChronology[" + getBase().toString() + ']'; [EOL] }
int getMonthOfYear(long millis, int year) { [EOL]     int i = (int) ((millis - getYearMillis(year)) >> 10); [EOL]     return (isLeapYear(year)) ? ((i < 182 * 84375) ? ((i < 91 * 84375) ? ((i < 31 * 84375) ? 1 : (i < 60 * 84375) ? 2 : 3) : ((i < 121 * 84375) ? 4 : (i < 152 * 84375) ? 5 : 6)) : ((i < 274 * 84375) ? ((i < 213 * 84375) ? 7 : (i < 244 * 84375) ? 8 : 9) : ((i < 305 * 84375) ? 10 : (i < 335 * 84375) ? 11 : 12))) : ((i < 181 * 84375) ? ((i < 90 * 84375) ? ((i < 31 * 84375) ? 1 : (i < 59 * 84375) ? 2 : 3) : ((i < 120 * 84375) ? 4 : (i < 151 * 84375) ? 5 : 6)) : ((i < 273 * 84375) ? ((i < 212 * 84375) ? 7 : (i < 243 * 84375) ? 8 : 9) : ((i < 304 * 84375) ? 10 : (i < 334 * 84375) ? 11 : 12))); [EOL] }  BasicGJChronology(Chronology base, Object param, int minDaysInFirstWeek);  int getMonthOfYear(long millis, int year);  int getDaysInYearMonth(int year, int month);  int getDaysInMonthMax(int month);  int getDaysInMonthMaxForSet(long instant, int value);  long getTotalMillisByYearMonth(int year, int month);  long getYearDifference(long minuendInstant, long subtrahendInstant);  long setYear(long instant, int year); long serialVersionUID=Optional[538276888268L]; int[] MIN_DAYS_PER_MONTH_ARRAY=Optional[{ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }]; int[] MAX_DAYS_PER_MONTH_ARRAY=Optional[{ 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }
long setYear(long instant, int year) { [EOL]     int thisYear = getYear(instant); [EOL]     int dayOfYear = getDayOfYear(instant, thisYear); [EOL]     int millisOfDay = getMillisOfDay(instant); [EOL]     if (dayOfYear > (31 + 28)) { [EOL]         if (isLeapYear(thisYear)) { [EOL]             if (!isLeapYear(year)) { [EOL]                 dayOfYear--; [EOL]             } [EOL]         } else { [EOL]             if (isLeapYear(year)) { [EOL]                 dayOfYear++; [EOL]             } [EOL]         } [EOL]     } [EOL]     instant = getYearMonthDayMillis(year, 1, dayOfYear); [EOL]     instant += millisOfDay; [EOL]     return instant; [EOL] }  BasicGJChronology(Chronology base, Object param, int minDaysInFirstWeek);  int getMonthOfYear(long millis, int year);  int getDaysInYearMonth(int year, int month);  int getDaysInMonthMax(int month);  int getDaysInMonthMaxForSet(long instant, int value);  long getTotalMillisByYearMonth(int year, int month);  long getYearDifference(long minuendInstant, long subtrahendInstant);  long setYear(long instant, int year); long serialVersionUID=Optional[538276888268L]; int[] MIN_DAYS_PER_MONTH_ARRAY=Optional[{ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }]; int[] MAX_DAYS_PER_MONTH_ARRAY=Optional[{ 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }
public static Seconds seconds(int seconds) { [EOL]     switch(seconds) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Seconds(seconds); [EOL]     } [EOL] }
public DurationFieldType getFieldType() { [EOL]     return DurationFieldType.seconds(); [EOL] }
public Weeks toStandardWeeks() { [EOL]     return Weeks.weeks(getValue() / DateTimeConstants.SECONDS_PER_WEEK); [EOL] }
public Weeks toStandardWeeks() { [EOL]     return Weeks.weeks(getValue() / DateTimeConstants.SECONDS_PER_WEEK); [EOL] }
public Weeks toStandardWeeks() { [EOL]     return Weeks.weeks(getValue() / DateTimeConstants.SECONDS_PER_WEEK); [EOL] }
public Weeks toStandardWeeks() { [EOL]     return Weeks.weeks(getValue() / DateTimeConstants.SECONDS_PER_WEEK); [EOL] }
public Seconds plus(int seconds) { [EOL]     if (seconds == 0) { [EOL]         return this; [EOL]     } [EOL]     return Seconds.seconds(FieldUtils.safeAdd(getValue(), seconds)); [EOL] }
public Seconds plus(int seconds) { [EOL]     if (seconds == 0) { [EOL]         return this; [EOL]     } [EOL]     return Seconds.seconds(FieldUtils.safeAdd(getValue(), seconds)); [EOL] }
public Seconds minus(Seconds seconds) { [EOL]     if (seconds == null) { [EOL]         return this; [EOL]     } [EOL]     return minus(seconds.getValue()); [EOL] }
public Seconds minus(Seconds seconds) { [EOL]     if (seconds == null) { [EOL]         return this; [EOL]     } [EOL]     return minus(seconds.getValue()); [EOL] }
public boolean isLessThan(Seconds other) { [EOL]     if (other == null) { [EOL]         return getValue() < 0; [EOL]     } [EOL]     return getValue() < other.getValue(); [EOL] }
public boolean isLessThan(Seconds other) { [EOL]     if (other == null) { [EOL]         return getValue() < 0; [EOL]     } [EOL]     return getValue() < other.getValue(); [EOL] }
public boolean isLessThan(Seconds other) { [EOL]     if (other == null) { [EOL]         return getValue() < 0; [EOL]     } [EOL]     return getValue() < other.getValue(); [EOL] }
public boolean isLessThan(Seconds other) { [EOL]     if (other == null) { [EOL]         return getValue() < 0; [EOL]     } [EOL]     return getValue() < other.getValue(); [EOL] }
public boolean isLessThan(Seconds other) { [EOL]     if (other == null) { [EOL]         return getValue() < 0; [EOL]     } [EOL]     return getValue() < other.getValue(); [EOL] }
public static LimitChronology getInstance(Chronology base, ReadableDateTime lowerLimit, ReadableDateTime upperLimit) { [EOL]     if (base == null) { [EOL]         throw new IllegalArgumentException("Must supply a chronology"); [EOL]     } [EOL]     lowerLimit = lowerLimit == null ? null : lowerLimit.toDateTime(); [EOL]     upperLimit = upperLimit == null ? null : upperLimit.toDateTime(); [EOL]     if (lowerLimit != null && upperLimit != null) { [EOL]         if (!lowerLimit.isBefore(upperLimit)) { [EOL]             throw new IllegalArgumentException("The lower limit must be come before than the upper limit"); [EOL]         } [EOL]     } [EOL]     return new LimitChronology(base, (DateTime) lowerLimit, (DateTime) upperLimit); [EOL] }
public static LimitChronology getInstance(Chronology base, ReadableDateTime lowerLimit, ReadableDateTime upperLimit) { [EOL]     if (base == null) { [EOL]         throw new IllegalArgumentException("Must supply a chronology"); [EOL]     } [EOL]     lowerLimit = lowerLimit == null ? null : lowerLimit.toDateTime(); [EOL]     upperLimit = upperLimit == null ? null : upperLimit.toDateTime(); [EOL]     if (lowerLimit != null && upperLimit != null) { [EOL]         if (!lowerLimit.isBefore(upperLimit)) { [EOL]             throw new IllegalArgumentException("The lower limit must be come before than the upper limit"); [EOL]         } [EOL]     } [EOL]     return new LimitChronology(base, (DateTime) lowerLimit, (DateTime) upperLimit); [EOL] }
public static LimitChronology getInstance(Chronology base, ReadableDateTime lowerLimit, ReadableDateTime upperLimit) { [EOL]     if (base == null) { [EOL]         throw new IllegalArgumentException("Must supply a chronology"); [EOL]     } [EOL]     lowerLimit = lowerLimit == null ? null : lowerLimit.toDateTime(); [EOL]     upperLimit = upperLimit == null ? null : upperLimit.toDateTime(); [EOL]     if (lowerLimit != null && upperLimit != null) { [EOL]         if (!lowerLimit.isBefore(upperLimit)) { [EOL]             throw new IllegalArgumentException("The lower limit must be come before than the upper limit"); [EOL]         } [EOL]     } [EOL]     return new LimitChronology(base, (DateTime) lowerLimit, (DateTime) upperLimit); [EOL] }
public static LimitChronology getInstance(Chronology base, ReadableDateTime lowerLimit, ReadableDateTime upperLimit) { [EOL]     if (base == null) { [EOL]         throw new IllegalArgumentException("Must supply a chronology"); [EOL]     } [EOL]     lowerLimit = lowerLimit == null ? null : lowerLimit.toDateTime(); [EOL]     upperLimit = upperLimit == null ? null : upperLimit.toDateTime(); [EOL]     if (lowerLimit != null && upperLimit != null) { [EOL]         if (!lowerLimit.isBefore(upperLimit)) { [EOL]             throw new IllegalArgumentException("The lower limit must be come before than the upper limit"); [EOL]         } [EOL]     } [EOL]     return new LimitChronology(base, (DateTime) lowerLimit, (DateTime) upperLimit); [EOL] }
public static LimitChronology getInstance(Chronology base, ReadableDateTime lowerLimit, ReadableDateTime upperLimit) { [EOL]     if (base == null) { [EOL]         throw new IllegalArgumentException("Must supply a chronology"); [EOL]     } [EOL]     lowerLimit = lowerLimit == null ? null : lowerLimit.toDateTime(); [EOL]     upperLimit = upperLimit == null ? null : upperLimit.toDateTime(); [EOL]     if (lowerLimit != null && upperLimit != null) { [EOL]         if (!lowerLimit.isBefore(upperLimit)) { [EOL]             throw new IllegalArgumentException("The lower limit must be come before than the upper limit"); [EOL]         } [EOL]     } [EOL]     return new LimitChronology(base, (DateTime) lowerLimit, (DateTime) upperLimit); [EOL] }
public static LimitChronology getInstance(Chronology base, ReadableDateTime lowerLimit, ReadableDateTime upperLimit) { [EOL]     if (base == null) { [EOL]         throw new IllegalArgumentException("Must supply a chronology"); [EOL]     } [EOL]     lowerLimit = lowerLimit == null ? null : lowerLimit.toDateTime(); [EOL]     upperLimit = upperLimit == null ? null : upperLimit.toDateTime(); [EOL]     if (lowerLimit != null && upperLimit != null) { [EOL]         if (!lowerLimit.isBefore(upperLimit)) { [EOL]             throw new IllegalArgumentException("The lower limit must be come before than the upper limit"); [EOL]         } [EOL]     } [EOL]     return new LimitChronology(base, (DateTime) lowerLimit, (DateTime) upperLimit); [EOL] }
private LimitChronology(Chronology base, DateTime lowerLimit, DateTime upperLimit) { [EOL]     super(base, null); [EOL]     iLowerLimit = lowerLimit; [EOL]     iUpperLimit = upperLimit; [EOL] }
private LimitChronology(Chronology base, DateTime lowerLimit, DateTime upperLimit) { [EOL]     super(base, null); [EOL]     iLowerLimit = lowerLimit; [EOL]     iUpperLimit = upperLimit; [EOL] }
private LimitChronology(Chronology base, DateTime lowerLimit, DateTime upperLimit) { [EOL]     super(base, null); [EOL]     iLowerLimit = lowerLimit; [EOL]     iUpperLimit = upperLimit; [EOL] }
private LimitChronology(Chronology base, DateTime lowerLimit, DateTime upperLimit) { [EOL]     super(base, null); [EOL]     iLowerLimit = lowerLimit; [EOL]     iUpperLimit = upperLimit; [EOL] }
public long getDateTimeMillis(long instant, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) throws IllegalArgumentException { [EOL]     checkLimits(instant, null); [EOL]     instant = getBase().getDateTimeMillis(instant, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]     checkLimits(instant, "resulting"); [EOL]     return instant; [EOL] }
public long getDateTimeMillis(long instant, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) throws IllegalArgumentException { [EOL]     checkLimits(instant, null); [EOL]     instant = getBase().getDateTimeMillis(instant, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]     checkLimits(instant, "resulting"); [EOL]     return instant; [EOL] }
public long getDateTimeMillis(long instant, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) throws IllegalArgumentException { [EOL]     checkLimits(instant, null); [EOL]     instant = getBase().getDateTimeMillis(instant, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]     checkLimits(instant, "resulting"); [EOL]     return instant; [EOL] }
void checkLimits(long instant, String desc) { [EOL]     DateTime limit; [EOL]     if ((limit = iLowerLimit) != null && instant < limit.getMillis()) { [EOL]         throw new LimitException(desc, true); [EOL]     } [EOL]     if ((limit = iUpperLimit) != null && instant >= limit.getMillis()) { [EOL]         throw new LimitException(desc, false); [EOL]     } [EOL] }
void checkLimits(long instant, String desc) { [EOL]     DateTime limit; [EOL]     if ((limit = iLowerLimit) != null && instant < limit.getMillis()) { [EOL]         throw new LimitException(desc, true); [EOL]     } [EOL]     if ((limit = iUpperLimit) != null && instant >= limit.getMillis()) { [EOL]         throw new LimitException(desc, false); [EOL]     } [EOL] }
void checkLimits(long instant, String desc) { [EOL]     DateTime limit; [EOL]     if ((limit = iLowerLimit) != null && instant < limit.getMillis()) { [EOL]         throw new LimitException(desc, true); [EOL]     } [EOL]     if ((limit = iUpperLimit) != null && instant >= limit.getMillis()) { [EOL]         throw new LimitException(desc, false); [EOL]     } [EOL] }
public String toString() { [EOL]     return "LimitChronology[" + getBase().toString() + ", " + (getLowerLimit() == null ? "NoLimit" : getLowerLimit().toString()) + ", " + (getUpperLimit() == null ? "NoLimit" : getUpperLimit().toString()) + ']'; [EOL] }
public String toString() { [EOL]     return "LimitChronology[" + getBase().toString() + ", " + (getLowerLimit() == null ? "NoLimit" : getLowerLimit().toString()) + ", " + (getUpperLimit() == null ? "NoLimit" : getUpperLimit().toString()) + ']'; [EOL] }
public String toString() { [EOL]     return "LimitChronology[" + getBase().toString() + ", " + (getLowerLimit() == null ? "NoLimit" : getLowerLimit().toString()) + ", " + (getUpperLimit() == null ? "NoLimit" : getUpperLimit().toString()) + ']'; [EOL] }
public String toString() { [EOL]     return "LimitChronology[" + getBase().toString() + ", " + (getLowerLimit() == null ? "NoLimit" : getLowerLimit().toString()) + ", " + (getUpperLimit() == null ? "NoLimit" : getUpperLimit().toString()) + ']'; [EOL] }
LimitException(String desc, boolean isLow) { [EOL]     super(desc); [EOL]     iIsLow = isLow; [EOL] }
LimitException(String desc, boolean isLow) { [EOL]     super(desc); [EOL]     iIsLow = isLow; [EOL] }
public int get(DateTimeFieldType type) { [EOL]     if (type == null) { [EOL]         throw new IllegalArgumentException("The DateTimeFieldType must not be null"); [EOL]     } [EOL]     return type.getField(getChronology()).get(getMillis()); [EOL] }
public int get(DateTimeFieldType type) { [EOL]     if (type == null) { [EOL]         throw new IllegalArgumentException("The DateTimeFieldType must not be null"); [EOL]     } [EOL]     return type.getField(getChronology()).get(getMillis()); [EOL] }
public Chronology withUTC() { [EOL]     if (iWithUTC == null) { [EOL]         if (getZone() == DateTimeZone.UTC) { [EOL]             iWithUTC = this; [EOL]         } else { [EOL]             iWithUTC = LenientChronology.getInstance(getBase().withUTC()); [EOL]         } [EOL]     } [EOL]     return iWithUTC; [EOL] }
public Chronology withUTC() { [EOL]     if (iWithUTC == null) { [EOL]         if (getZone() == DateTimeZone.UTC) { [EOL]             iWithUTC = this; [EOL]         } else { [EOL]             iWithUTC = LenientChronology.getInstance(getBase().withUTC()); [EOL]         } [EOL]     } [EOL]     return iWithUTC; [EOL] }
public String toString() { [EOL]     return "LenientChronology[" + getBase().toString() + ']'; [EOL] }
public final DurationField getDurationField() { [EOL]     return iDurationField; [EOL] }
public boolean isPrecise() { [EOL]     return false; [EOL] }
public int getValue(long duration, long instant) { [EOL]     return ImpreciseDateTimeField.this.getDifference(instant + duration, instant); [EOL] }
public int getValue(long duration, long instant) { [EOL]     return ImpreciseDateTimeField.this.getDifference(instant + duration, instant); [EOL] }
public int getValue(long duration, long instant) { [EOL]     return ImpreciseDateTimeField.this.getDifference(instant + duration, instant); [EOL] }
public long getMillis(int value, long instant) { [EOL]     return ImpreciseDateTimeField.this.add(instant, value) - instant; [EOL] }
public long getMillis(int value, long instant) { [EOL]     return ImpreciseDateTimeField.this.add(instant, value) - instant; [EOL] }
public long getMillis(int value, long instant) { [EOL]     return ImpreciseDateTimeField.this.add(instant, value) - instant; [EOL] }
public long getMillis(long value, long instant) { [EOL]     return ImpreciseDateTimeField.this.add(instant, value) - instant; [EOL] }
public static Weeks weeks(int weeks) { [EOL]     switch(weeks) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Weeks(weeks); [EOL]     } [EOL] }
public static Weeks weeks(int weeks) { [EOL]     switch(weeks) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Weeks(weeks); [EOL]     } [EOL] }
public static Weeks weeks(int weeks) { [EOL]     switch(weeks) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Weeks(weeks); [EOL]     } [EOL] }
public static Weeks weeks(int weeks) { [EOL]     switch(weeks) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Weeks(weeks); [EOL]     } [EOL] }
public static Weeks weeks(int weeks) { [EOL]     switch(weeks) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Weeks(weeks); [EOL]     } [EOL] }
public static Weeks weeks(int weeks) { [EOL]     switch(weeks) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Weeks(weeks); [EOL]     } [EOL] }
public static Weeks weeks(int weeks) { [EOL]     switch(weeks) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Weeks(weeks); [EOL]     } [EOL] }
public static Weeks weeksBetween(ReadableInstant start, ReadableInstant end) { [EOL]     int amount = BaseSingleFieldPeriod.between(start, end, DurationFieldType.weeks()); [EOL]     return Weeks.weeks(amount); [EOL] }
public static Weeks weeksBetween(ReadableInstant start, ReadableInstant end) { [EOL]     int amount = BaseSingleFieldPeriod.between(start, end, DurationFieldType.weeks()); [EOL]     return Weeks.weeks(amount); [EOL] }
public static Weeks weeksBetween(ReadableInstant start, ReadableInstant end) { [EOL]     int amount = BaseSingleFieldPeriod.between(start, end, DurationFieldType.weeks()); [EOL]     return Weeks.weeks(amount); [EOL] }
@FromString [EOL] public static Weeks parseWeeks(String periodStr) { [EOL]     if (periodStr == null) { [EOL]         return Weeks.ZERO; [EOL]     } [EOL]     Period p = PARSER.parsePeriod(periodStr); [EOL]     return Weeks.weeks(p.getWeeks()); [EOL] }
@FromString [EOL] public static Weeks parseWeeks(String periodStr) { [EOL]     if (periodStr == null) { [EOL]         return Weeks.ZERO; [EOL]     } [EOL]     Period p = PARSER.parsePeriod(periodStr); [EOL]     return Weeks.weeks(p.getWeeks()); [EOL] }
@FromString [EOL] public static Weeks parseWeeks(String periodStr) { [EOL]     if (periodStr == null) { [EOL]         return Weeks.ZERO; [EOL]     } [EOL]     Period p = PARSER.parsePeriod(periodStr); [EOL]     return Weeks.weeks(p.getWeeks()); [EOL] }
private Weeks(int weeks) { [EOL]     super(weeks); [EOL] }
private Object readResolve() { [EOL]     return Weeks.weeks(getValue()); [EOL] }
public DurationFieldType getFieldType() { [EOL]     return DurationFieldType.weeks(); [EOL] }
public Hours toStandardHours() { [EOL]     return Hours.hours(FieldUtils.safeMultiply(getValue(), DateTimeConstants.HOURS_PER_WEEK)); [EOL] }
public Hours toStandardHours() { [EOL]     return Hours.hours(FieldUtils.safeMultiply(getValue(), DateTimeConstants.HOURS_PER_WEEK)); [EOL] }
public Hours toStandardHours() { [EOL]     return Hours.hours(FieldUtils.safeMultiply(getValue(), DateTimeConstants.HOURS_PER_WEEK)); [EOL] }
public int getWeeks() { [EOL]     return getValue(); [EOL] }
public static DateTime now(DateTimeZone zone) { [EOL]     if (zone == null) { [EOL]         throw new NullPointerException("Zone must not be null"); [EOL]     } [EOL]     return new DateTime(zone); [EOL] }
public static DateTime now(DateTimeZone zone) { [EOL]     if (zone == null) { [EOL]         throw new NullPointerException("Zone must not be null"); [EOL]     } [EOL]     return new DateTime(zone); [EOL] }
public DateTime(long instant) { [EOL]     super(instant); [EOL] }
public DateTime(int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, DateTimeZone zone) { [EOL]     super(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, 0, 0, zone); [EOL] }
public DateTime(int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, DateTimeZone zone) { [EOL]     super(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond, zone); [EOL] }
public DateTime withEarlierOffsetAtOverlap() { [EOL]     long newMillis = getZone().adjustOffset(getMillis(), false); [EOL]     return withMillis(newMillis); [EOL] }
public DateTime withEarlierOffsetAtOverlap() { [EOL]     long newMillis = getZone().adjustOffset(getMillis(), false); [EOL]     return withMillis(newMillis); [EOL] }
public DateTime withLaterOffsetAtOverlap() { [EOL]     long newMillis = getZone().adjustOffset(getMillis(), true); [EOL]     return withMillis(newMillis); [EOL] }
public DateTime withLaterOffsetAtOverlap() { [EOL]     long newMillis = getZone().adjustOffset(getMillis(), true); [EOL]     return withMillis(newMillis); [EOL] }
public DateTime withDate(int year, int monthOfYear, int dayOfMonth) { [EOL]     Chronology chrono = getChronology(); [EOL]     long instant = getMillis(); [EOL]     instant = chrono.year().set(instant, year); [EOL]     instant = chrono.monthOfYear().set(instant, monthOfYear); [EOL]     instant = chrono.dayOfMonth().set(instant, dayOfMonth); [EOL]     return withMillis(instant); [EOL] }
public DateTime withDate(int year, int monthOfYear, int dayOfMonth) { [EOL]     Chronology chrono = getChronology(); [EOL]     long instant = getMillis(); [EOL]     instant = chrono.year().set(instant, year); [EOL]     instant = chrono.monthOfYear().set(instant, monthOfYear); [EOL]     instant = chrono.dayOfMonth().set(instant, dayOfMonth); [EOL]     return withMillis(instant); [EOL] }
public DateTime withDate(int year, int monthOfYear, int dayOfMonth) { [EOL]     Chronology chrono = getChronology(); [EOL]     long instant = getMillis(); [EOL]     instant = chrono.year().set(instant, year); [EOL]     instant = chrono.monthOfYear().set(instant, monthOfYear); [EOL]     instant = chrono.dayOfMonth().set(instant, dayOfMonth); [EOL]     return withMillis(instant); [EOL] }
public DateTime withDate(int year, int monthOfYear, int dayOfMonth) { [EOL]     Chronology chrono = getChronology(); [EOL]     long instant = getMillis(); [EOL]     instant = chrono.year().set(instant, year); [EOL]     instant = chrono.monthOfYear().set(instant, monthOfYear); [EOL]     instant = chrono.dayOfMonth().set(instant, dayOfMonth); [EOL]     return withMillis(instant); [EOL] }
public DateTime withFields(ReadablePartial partial) { [EOL]     if (partial == null) { [EOL]         return this; [EOL]     } [EOL]     return withMillis(getChronology().set(partial, getMillis())); [EOL] }
public DateTime withFields(ReadablePartial partial) { [EOL]     if (partial == null) { [EOL]         return this; [EOL]     } [EOL]     return withMillis(getChronology().set(partial, getMillis())); [EOL] }
public DateTime withField(DateTimeFieldType fieldType, int value) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("Field must not be null"); [EOL]     } [EOL]     long instant = fieldType.getField(getChronology()).set(getMillis(), value); [EOL]     return withMillis(instant); [EOL] }
public DateTime withField(DateTimeFieldType fieldType, int value) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("Field must not be null"); [EOL]     } [EOL]     long instant = fieldType.getField(getChronology()).set(getMillis(), value); [EOL]     return withMillis(instant); [EOL] }
public DateTime withDurationAdded(long durationToAdd, int scalar) { [EOL]     if (durationToAdd == 0 || scalar == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().add(getMillis(), durationToAdd, scalar); [EOL]     return withMillis(instant); [EOL] }
public DateTime withDurationAdded(long durationToAdd, int scalar) { [EOL]     if (durationToAdd == 0 || scalar == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().add(getMillis(), durationToAdd, scalar); [EOL]     return withMillis(instant); [EOL] }
public DateTime withDurationAdded(long durationToAdd, int scalar) { [EOL]     if (durationToAdd == 0 || scalar == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().add(getMillis(), durationToAdd, scalar); [EOL]     return withMillis(instant); [EOL] }
public DateTime withPeriodAdded(ReadablePeriod period, int scalar) { [EOL]     if (period == null || scalar == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().add(period, getMillis(), scalar); [EOL]     return withMillis(instant); [EOL] }
public DateTime plus(ReadablePeriod period) { [EOL]     return withPeriodAdded(period, 1); [EOL] }
public DateTime plus(ReadablePeriod period) { [EOL]     return withPeriodAdded(period, 1); [EOL] }
public DateTime plusHours(int hours) { [EOL]     if (hours == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().hours().add(getMillis(), hours); [EOL]     return withMillis(instant); [EOL] }
public DateTime plusHours(int hours) { [EOL]     if (hours == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().hours().add(getMillis(), hours); [EOL]     return withMillis(instant); [EOL] }
public DateTime plusHours(int hours) { [EOL]     if (hours == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().hours().add(getMillis(), hours); [EOL]     return withMillis(instant); [EOL] }
public DateTime minus(long duration) { [EOL]     return withDurationAdded(duration, -1); [EOL] }
public DateTime minus(long duration) { [EOL]     return withDurationAdded(duration, -1); [EOL] }
public DateTime minus(long duration) { [EOL]     return withDurationAdded(duration, -1); [EOL] }
public Property centuryOfEra() { [EOL]     return new Property(this, getChronology().centuryOfEra()); [EOL] }
public Property dayOfWeek() { [EOL]     return new Property(this, getChronology().dayOfWeek()); [EOL] }
public DateTime addToCopy(long value) { [EOL]     return iInstant.withMillis(iField.add(iInstant.getMillis(), value)); [EOL] }
public DateTime withMaximumValue() { [EOL]     try { [EOL]         return setCopy(getMaximumValue()); [EOL]     } catch (RuntimeException ex) { [EOL]         if (IllegalInstantException.isIllegalInstant(ex)) { [EOL]             long beforeGap = getChronology().getZone().previousTransition(getMillis() + DateTimeConstants.MILLIS_PER_DAY); [EOL]             return new DateTime(beforeGap, getChronology()); [EOL]         } [EOL]         throw ex; [EOL]     } [EOL] }
public static DateTimeField getInstance(DateTimeField field) { [EOL]     if (field == null) { [EOL]         return null; [EOL]     } [EOL]     if (field instanceof LenientDateTimeField) { [EOL]         field = ((LenientDateTimeField) field).getWrappedField(); [EOL]     } [EOL]     if (!field.isLenient()) { [EOL]         return field; [EOL]     } [EOL]     return new StrictDateTimeField(field); [EOL] }
public static DateTimeField getInstance(DateTimeField field) { [EOL]     if (field == null) { [EOL]         return null; [EOL]     } [EOL]     if (field instanceof LenientDateTimeField) { [EOL]         field = ((LenientDateTimeField) field).getWrappedField(); [EOL]     } [EOL]     if (!field.isLenient()) { [EOL]         return field; [EOL]     } [EOL]     return new StrictDateTimeField(field); [EOL] }
public static DateTimeField getInstance(DateTimeField field) { [EOL]     if (field == null) { [EOL]         return null; [EOL]     } [EOL]     if (field instanceof LenientDateTimeField) { [EOL]         field = ((LenientDateTimeField) field).getWrappedField(); [EOL]     } [EOL]     if (!field.isLenient()) { [EOL]         return field; [EOL]     } [EOL]     return new StrictDateTimeField(field); [EOL] }
public DateTimeZone getZone(String id) { [EOL]     if (id == null) { [EOL]         return null; [EOL]     } [EOL]     Object obj = iZoneInfoMap.get(id); [EOL]     if (obj == null) { [EOL]         return null; [EOL]     } [EOL]     if (id.equals(obj)) { [EOL]         return loadZoneData(id); [EOL]     } [EOL]     if (obj instanceof SoftReference<?>) { [EOL]         @SuppressWarnings("unchecked") [EOL]         SoftReference<DateTimeZone> ref = (SoftReference<DateTimeZone>) obj; [EOL]         DateTimeZone tz = ref.get(); [EOL]         if (tz != null) { [EOL]             return tz; [EOL]         } [EOL]         return loadZoneData(id); [EOL]     } [EOL]     return getZone((String) obj); [EOL] }
public DateTimeZone getZone(String id) { [EOL]     if (id == null) { [EOL]         return null; [EOL]     } [EOL]     Object obj = iZoneInfoMap.get(id); [EOL]     if (obj == null) { [EOL]         return null; [EOL]     } [EOL]     if (id.equals(obj)) { [EOL]         return loadZoneData(id); [EOL]     } [EOL]     if (obj instanceof SoftReference<?>) { [EOL]         @SuppressWarnings("unchecked") [EOL]         SoftReference<DateTimeZone> ref = (SoftReference<DateTimeZone>) obj; [EOL]         DateTimeZone tz = ref.get(); [EOL]         if (tz != null) { [EOL]             return tz; [EOL]         } [EOL]         return loadZoneData(id); [EOL]     } [EOL]     return getZone((String) obj); [EOL] }
public DateTimeZone getZone(String id) { [EOL]     if (id == null) { [EOL]         return null; [EOL]     } [EOL]     Object obj = iZoneInfoMap.get(id); [EOL]     if (obj == null) { [EOL]         return null; [EOL]     } [EOL]     if (id.equals(obj)) { [EOL]         return loadZoneData(id); [EOL]     } [EOL]     if (obj instanceof SoftReference<?>) { [EOL]         @SuppressWarnings("unchecked") [EOL]         SoftReference<DateTimeZone> ref = (SoftReference<DateTimeZone>) obj; [EOL]         DateTimeZone tz = ref.get(); [EOL]         if (tz != null) { [EOL]             return tz; [EOL]         } [EOL]         return loadZoneData(id); [EOL]     } [EOL]     return getZone((String) obj); [EOL] }
public DateTimeZone getZone(String id) { [EOL]     if (id == null) { [EOL]         return null; [EOL]     } [EOL]     Object obj = iZoneInfoMap.get(id); [EOL]     if (obj == null) { [EOL]         return null; [EOL]     } [EOL]     if (id.equals(obj)) { [EOL]         return loadZoneData(id); [EOL]     } [EOL]     if (obj instanceof SoftReference<?>) { [EOL]         @SuppressWarnings("unchecked") [EOL]         SoftReference<DateTimeZone> ref = (SoftReference<DateTimeZone>) obj; [EOL]         DateTimeZone tz = ref.get(); [EOL]         if (tz != null) { [EOL]             return tz; [EOL]         } [EOL]         return loadZoneData(id); [EOL]     } [EOL]     return getZone((String) obj); [EOL] }
public DateTimeZone getZone(String id) { [EOL]     if (id == null) { [EOL]         return null; [EOL]     } [EOL]     Object obj = iZoneInfoMap.get(id); [EOL]     if (obj == null) { [EOL]         return null; [EOL]     } [EOL]     if (id.equals(obj)) { [EOL]         return loadZoneData(id); [EOL]     } [EOL]     if (obj instanceof SoftReference<?>) { [EOL]         @SuppressWarnings("unchecked") [EOL]         SoftReference<DateTimeZone> ref = (SoftReference<DateTimeZone>) obj; [EOL]         DateTimeZone tz = ref.get(); [EOL]         if (tz != null) { [EOL]             return tz; [EOL]         } [EOL]         return loadZoneData(id); [EOL]     } [EOL]     return getZone((String) obj); [EOL] }
public DateTimeZone getZone(String id) { [EOL]     if (id == null) { [EOL]         return null; [EOL]     } [EOL]     Object obj = iZoneInfoMap.get(id); [EOL]     if (obj == null) { [EOL]         return null; [EOL]     } [EOL]     if (id.equals(obj)) { [EOL]         return loadZoneData(id); [EOL]     } [EOL]     if (obj instanceof SoftReference<?>) { [EOL]         @SuppressWarnings("unchecked") [EOL]         SoftReference<DateTimeZone> ref = (SoftReference<DateTimeZone>) obj; [EOL]         DateTimeZone tz = ref.get(); [EOL]         if (tz != null) { [EOL]             return tz; [EOL]         } [EOL]         return loadZoneData(id); [EOL]     } [EOL]     return getZone((String) obj); [EOL] }
@SuppressWarnings("resource") [EOL] private InputStream openResource(String name) throws IOException { [EOL]     InputStream in; [EOL]     if (iFileDir != null) { [EOL]         in = new FileInputStream(new File(iFileDir, name)); [EOL]     } else { [EOL]         String path = iResourcePath.concat(name); [EOL]         if (iLoader != null) { [EOL]             in = iLoader.getResourceAsStream(path); [EOL]         } else { [EOL]             in = ClassLoader.getSystemResourceAsStream(path); [EOL]         } [EOL]         if (in == null) { [EOL]             StringBuilder buf = new StringBuilder(40).append("Resource not found: \"").append(path).append("\" ClassLoader: ").append(iLoader != null ? iLoader.toString() : "system"); [EOL]             throw new IOException(buf.toString()); [EOL]         } [EOL]     } [EOL]     return in; [EOL] }
@SuppressWarnings("resource") [EOL] private InputStream openResource(String name) throws IOException { [EOL]     InputStream in; [EOL]     if (iFileDir != null) { [EOL]         in = new FileInputStream(new File(iFileDir, name)); [EOL]     } else { [EOL]         String path = iResourcePath.concat(name); [EOL]         if (iLoader != null) { [EOL]             in = iLoader.getResourceAsStream(path); [EOL]         } else { [EOL]             in = ClassLoader.getSystemResourceAsStream(path); [EOL]         } [EOL]         if (in == null) { [EOL]             StringBuilder buf = new StringBuilder(40).append("Resource not found: \"").append(path).append("\" ClassLoader: ").append(iLoader != null ? iLoader.toString() : "system"); [EOL]             throw new IOException(buf.toString()); [EOL]         } [EOL]     } [EOL]     return in; [EOL] }
@SuppressWarnings("resource") [EOL] private InputStream openResource(String name) throws IOException { [EOL]     InputStream in; [EOL]     if (iFileDir != null) { [EOL]         in = new FileInputStream(new File(iFileDir, name)); [EOL]     } else { [EOL]         String path = iResourcePath.concat(name); [EOL]         if (iLoader != null) { [EOL]             in = iLoader.getResourceAsStream(path); [EOL]         } else { [EOL]             in = ClassLoader.getSystemResourceAsStream(path); [EOL]         } [EOL]         if (in == null) { [EOL]             StringBuilder buf = new StringBuilder(40).append("Resource not found: \"").append(path).append("\" ClassLoader: ").append(iLoader != null ? iLoader.toString() : "system"); [EOL]             throw new IOException(buf.toString()); [EOL]         } [EOL]     } [EOL]     return in; [EOL] }
@SuppressWarnings("resource") [EOL] private InputStream openResource(String name) throws IOException { [EOL]     InputStream in; [EOL]     if (iFileDir != null) { [EOL]         in = new FileInputStream(new File(iFileDir, name)); [EOL]     } else { [EOL]         String path = iResourcePath.concat(name); [EOL]         if (iLoader != null) { [EOL]             in = iLoader.getResourceAsStream(path); [EOL]         } else { [EOL]             in = ClassLoader.getSystemResourceAsStream(path); [EOL]         } [EOL]         if (in == null) { [EOL]             StringBuilder buf = new StringBuilder(40).append("Resource not found: \"").append(path).append("\" ClassLoader: ").append(iLoader != null ? iLoader.toString() : "system"); [EOL]             throw new IOException(buf.toString()); [EOL]         } [EOL]     } [EOL]     return in; [EOL] }
private DateTimeZone loadZoneData(String id) { [EOL]     InputStream in = null; [EOL]     try { [EOL]         in = openResource(id); [EOL]         DateTimeZone tz = DateTimeZoneBuilder.readFrom(in, id); [EOL]         iZoneInfoMap.put(id, new SoftReference<DateTimeZone>(tz)); [EOL]         return tz; [EOL]     } catch (IOException ex) { [EOL]         uncaughtException(ex); [EOL]         iZoneInfoMap.remove(id); [EOL]         return null; [EOL]     } finally { [EOL]         try { [EOL]             if (in != null) { [EOL]                 in.close(); [EOL]             } [EOL]         } catch (IOException ex) { [EOL]         } [EOL]     } [EOL] }
public boolean isPrinter() { [EOL]     return (iPrinter != null); [EOL] }
public boolean isPrinter() { [EOL]     return (iPrinter != null); [EOL] }
public boolean isParser() { [EOL]     return (iParser != null); [EOL] }
public boolean isParser() { [EOL]     return (iParser != null); [EOL] }
public PeriodParser getParser() { [EOL]     return iParser; [EOL] }
public Period parsePeriod(String text) { [EOL]     checkParser(); [EOL]     return parseMutablePeriod(text).toPeriod(); [EOL] }
public Period parsePeriod(String text) { [EOL]     checkParser(); [EOL]     return parseMutablePeriod(text).toPeriod(); [EOL] }
public Period parsePeriod(String text) { [EOL]     checkParser(); [EOL]     return parseMutablePeriod(text).toPeriod(); [EOL] }
public MutablePeriod parseMutablePeriod(String text) { [EOL]     checkParser(); [EOL]     MutablePeriod period = new MutablePeriod(0, iParseType); [EOL]     int newPos = getParser().parseInto(period, text, 0, iLocale); [EOL]     if (newPos >= 0) { [EOL]         if (newPos >= text.length()) { [EOL]             return period; [EOL]         } [EOL]     } else { [EOL]         newPos = ~newPos; [EOL]     } [EOL]     throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos)); [EOL] }
public MutablePeriod parseMutablePeriod(String text) { [EOL]     checkParser(); [EOL]     MutablePeriod period = new MutablePeriod(0, iParseType); [EOL]     int newPos = getParser().parseInto(period, text, 0, iLocale); [EOL]     if (newPos >= 0) { [EOL]         if (newPos >= text.length()) { [EOL]             return period; [EOL]         } [EOL]     } else { [EOL]         newPos = ~newPos; [EOL]     } [EOL]     throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos)); [EOL] }
public MutablePeriod parseMutablePeriod(String text) { [EOL]     checkParser(); [EOL]     MutablePeriod period = new MutablePeriod(0, iParseType); [EOL]     int newPos = getParser().parseInto(period, text, 0, iLocale); [EOL]     if (newPos >= 0) { [EOL]         if (newPos >= text.length()) { [EOL]             return period; [EOL]         } [EOL]     } else { [EOL]         newPos = ~newPos; [EOL]     } [EOL]     throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos)); [EOL] }
public MutablePeriod parseMutablePeriod(String text) { [EOL]     checkParser(); [EOL]     MutablePeriod period = new MutablePeriod(0, iParseType); [EOL]     int newPos = getParser().parseInto(period, text, 0, iLocale); [EOL]     if (newPos >= 0) { [EOL]         if (newPos >= text.length()) { [EOL]             return period; [EOL]         } [EOL]     } else { [EOL]         newPos = ~newPos; [EOL]     } [EOL]     throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos)); [EOL] }
private void checkParser() { [EOL]     if (iParser == null) { [EOL]         throw new UnsupportedOperationException("Parsing not supported"); [EOL]     } [EOL] }
private void checkParser() { [EOL]     if (iParser == null) { [EOL]         throw new UnsupportedOperationException("Parsing not supported"); [EOL]     } [EOL] }
public Partial(Chronology chrono) { [EOL]     super(); [EOL]     iChronology = DateTimeUtils.getChronology(chrono).withUTC(); [EOL]     iTypes = new DateTimeFieldType[0]; [EOL]     iValues = new int[0]; [EOL] }
public Partial(Chronology chrono) { [EOL]     super(); [EOL]     iChronology = DateTimeUtils.getChronology(chrono).withUTC(); [EOL]     iTypes = new DateTimeFieldType[0]; [EOL]     iValues = new int[0]; [EOL] }
public Partial(DateTimeFieldType[] types, int[] values, Chronology chronology) { [EOL]     super(); [EOL]     chronology = DateTimeUtils.getChronology(chronology).withUTC(); [EOL]     iChronology = chronology; [EOL]     if (types == null) { [EOL]         throw new IllegalArgumentException("Types array must not be null"); [EOL]     } [EOL]     if (values == null) { [EOL]         throw new IllegalArgumentException("Values array must not be null"); [EOL]     } [EOL]     if (values.length != types.length) { [EOL]         throw new IllegalArgumentException("Values array must be the same length as the types array"); [EOL]     } [EOL]     if (types.length == 0) { [EOL]         iTypes = types; [EOL]         iValues = values; [EOL]         return; [EOL]     } [EOL]     for (int i = 0; i < types.length; i++) { [EOL]         if (types[i] == null) { [EOL]             throw new IllegalArgumentException("Types array must not contain null: index " + i); [EOL]         } [EOL]     } [EOL]     DurationField lastUnitField = null; [EOL]     for (int i = 0; i < types.length; i++) { [EOL]         DateTimeFieldType loopType = types[i]; [EOL]         DurationField loopUnitField = loopType.getDurationType().getField(iChronology); [EOL]         if (i > 0) { [EOL]             if (loopUnitField.isSupported() == false) { [EOL]                 if (lastUnitField.isSupported()) { [EOL]                     throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); [EOL]                 } else { [EOL]                     throw new IllegalArgumentException("Types array must not contain duplicate unsupported: " + types[i - 1].getName() + " and " + loopType.getName()); [EOL]                 } [EOL]             } [EOL]             int compare = lastUnitField.compareTo(loopUnitField); [EOL]             if (compare < 0) { [EOL]                 throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); [EOL]             } else if (compare == 0 && lastUnitField.equals(loopUnitField)) { [EOL]                 if (types[i - 1].getRangeDurationType() == null) { [EOL]                     if (loopType.getRangeDurationType() == null) { [EOL]                         throw new IllegalArgumentException("Types array must not contain duplicate: " + types[i - 1].getName() + " and " + loopType.getName()); [EOL]                     } [EOL]                 } else { [EOL]                     if (loopType.getRangeDurationType() == null) { [EOL]                         throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); [EOL]                     } [EOL]                     DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology); [EOL]                     DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology); [EOL]                     if (lastRangeField.compareTo(loopRangeField) < 0) { [EOL]                         throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); [EOL]                     } [EOL]                     if (lastRangeField.compareTo(loopRangeField) == 0) { [EOL]                         throw new IllegalArgumentException("Types array must not contain duplicate: " + types[i - 1].getName() + " and " + loopType.getName()); [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]         lastUnitField = loopUnitField; [EOL]     } [EOL]     iTypes = (DateTimeFieldType[]) types.clone(); [EOL]     chronology.validate(this, values); [EOL]     iValues = (int[]) values.clone(); [EOL] }
public int size() { [EOL]     return iTypes.length; [EOL] }
public Chronology getChronology() { [EOL]     return iChronology; [EOL] }
protected DateTimeField getField(int index, Chronology chrono) { [EOL]     return iTypes[index].getField(chrono); [EOL] }
protected DateTimeField getField(int index, Chronology chrono) { [EOL]     return iTypes[index].getField(chrono); [EOL] }
public DateTimeFieldType[] getFieldTypes() { [EOL]     return (DateTimeFieldType[]) iTypes.clone(); [EOL] }
public DateTimeFieldType[] getFieldTypes() { [EOL]     return (DateTimeFieldType[]) iTypes.clone(); [EOL] }
public Partial with(DateTimeFieldType fieldType, int value) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("The field type must not be null"); [EOL]     } [EOL]     int index = indexOf(fieldType); [EOL]     if (index == -1) { [EOL]         DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1]; [EOL]         int[] newValues = new int[newTypes.length]; [EOL]         int i = 0; [EOL]         DurationField unitField = fieldType.getDurationType().getField(iChronology); [EOL]         if (unitField.isSupported()) { [EOL]             for (; i < iTypes.length; i++) { [EOL]                 DateTimeFieldType loopType = iTypes[i]; [EOL]                 DurationField loopUnitField = loopType.getDurationType().getField(iChronology); [EOL]                 if (loopUnitField.isSupported()) { [EOL]                     int compare = unitField.compareTo(loopUnitField); [EOL]                     if (compare > 0) { [EOL]                         break; [EOL]                     } else if (compare == 0) { [EOL]                         if (fieldType.getRangeDurationType() == null) { [EOL]                             break; [EOL]                         } [EOL]                         DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology); [EOL]                         DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology); [EOL]                         if (rangeField.compareTo(loopRangeField) > 0) { [EOL]                             break; [EOL]                         } [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]         System.arraycopy(iTypes, 0, newTypes, 0, i); [EOL]         System.arraycopy(iValues, 0, newValues, 0, i); [EOL]         newTypes[i] = fieldType; [EOL]         newValues[i] = value; [EOL]         System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1); [EOL]         System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1); [EOL]         Partial newPartial = new Partial(newTypes, newValues, iChronology); [EOL]         iChronology.validate(newPartial, newValues); [EOL]         return newPartial; [EOL]     } [EOL]     if (value == getValue(index)) { [EOL]         return this; [EOL]     } [EOL]     int[] newValues = getValues(); [EOL]     newValues = getField(index).set(this, index, newValues, value); [EOL]     return new Partial(this, newValues); [EOL] }
public Partial with(DateTimeFieldType fieldType, int value) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("The field type must not be null"); [EOL]     } [EOL]     int index = indexOf(fieldType); [EOL]     if (index == -1) { [EOL]         DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1]; [EOL]         int[] newValues = new int[newTypes.length]; [EOL]         int i = 0; [EOL]         DurationField unitField = fieldType.getDurationType().getField(iChronology); [EOL]         if (unitField.isSupported()) { [EOL]             for (; i < iTypes.length; i++) { [EOL]                 DateTimeFieldType loopType = iTypes[i]; [EOL]                 DurationField loopUnitField = loopType.getDurationType().getField(iChronology); [EOL]                 if (loopUnitField.isSupported()) { [EOL]                     int compare = unitField.compareTo(loopUnitField); [EOL]                     if (compare > 0) { [EOL]                         break; [EOL]                     } else if (compare == 0) { [EOL]                         if (fieldType.getRangeDurationType() == null) { [EOL]                             break; [EOL]                         } [EOL]                         DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology); [EOL]                         DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology); [EOL]                         if (rangeField.compareTo(loopRangeField) > 0) { [EOL]                             break; [EOL]                         } [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]         System.arraycopy(iTypes, 0, newTypes, 0, i); [EOL]         System.arraycopy(iValues, 0, newValues, 0, i); [EOL]         newTypes[i] = fieldType; [EOL]         newValues[i] = value; [EOL]         System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1); [EOL]         System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1); [EOL]         Partial newPartial = new Partial(newTypes, newValues, iChronology); [EOL]         iChronology.validate(newPartial, newValues); [EOL]         return newPartial; [EOL]     } [EOL]     if (value == getValue(index)) { [EOL]         return this; [EOL]     } [EOL]     int[] newValues = getValues(); [EOL]     newValues = getField(index).set(this, index, newValues, value); [EOL]     return new Partial(this, newValues); [EOL] }
public Partial with(DateTimeFieldType fieldType, int value) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("The field type must not be null"); [EOL]     } [EOL]     int index = indexOf(fieldType); [EOL]     if (index == -1) { [EOL]         DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1]; [EOL]         int[] newValues = new int[newTypes.length]; [EOL]         int i = 0; [EOL]         DurationField unitField = fieldType.getDurationType().getField(iChronology); [EOL]         if (unitField.isSupported()) { [EOL]             for (; i < iTypes.length; i++) { [EOL]                 DateTimeFieldType loopType = iTypes[i]; [EOL]                 DurationField loopUnitField = loopType.getDurationType().getField(iChronology); [EOL]                 if (loopUnitField.isSupported()) { [EOL]                     int compare = unitField.compareTo(loopUnitField); [EOL]                     if (compare > 0) { [EOL]                         break; [EOL]                     } else if (compare == 0) { [EOL]                         if (fieldType.getRangeDurationType() == null) { [EOL]                             break; [EOL]                         } [EOL]                         DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology); [EOL]                         DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology); [EOL]                         if (rangeField.compareTo(loopRangeField) > 0) { [EOL]                             break; [EOL]                         } [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]         System.arraycopy(iTypes, 0, newTypes, 0, i); [EOL]         System.arraycopy(iValues, 0, newValues, 0, i); [EOL]         newTypes[i] = fieldType; [EOL]         newValues[i] = value; [EOL]         System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1); [EOL]         System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1); [EOL]         Partial newPartial = new Partial(newTypes, newValues, iChronology); [EOL]         iChronology.validate(newPartial, newValues); [EOL]         return newPartial; [EOL]     } [EOL]     if (value == getValue(index)) { [EOL]         return this; [EOL]     } [EOL]     int[] newValues = getValues(); [EOL]     newValues = getField(index).set(this, index, newValues, value); [EOL]     return new Partial(this, newValues); [EOL] }
public Partial with(DateTimeFieldType fieldType, int value) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("The field type must not be null"); [EOL]     } [EOL]     int index = indexOf(fieldType); [EOL]     if (index == -1) { [EOL]         DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1]; [EOL]         int[] newValues = new int[newTypes.length]; [EOL]         int i = 0; [EOL]         DurationField unitField = fieldType.getDurationType().getField(iChronology); [EOL]         if (unitField.isSupported()) { [EOL]             for (; i < iTypes.length; i++) { [EOL]                 DateTimeFieldType loopType = iTypes[i]; [EOL]                 DurationField loopUnitField = loopType.getDurationType().getField(iChronology); [EOL]                 if (loopUnitField.isSupported()) { [EOL]                     int compare = unitField.compareTo(loopUnitField); [EOL]                     if (compare > 0) { [EOL]                         break; [EOL]                     } else if (compare == 0) { [EOL]                         if (fieldType.getRangeDurationType() == null) { [EOL]                             break; [EOL]                         } [EOL]                         DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology); [EOL]                         DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology); [EOL]                         if (rangeField.compareTo(loopRangeField) > 0) { [EOL]                             break; [EOL]                         } [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]         System.arraycopy(iTypes, 0, newTypes, 0, i); [EOL]         System.arraycopy(iValues, 0, newValues, 0, i); [EOL]         newTypes[i] = fieldType; [EOL]         newValues[i] = value; [EOL]         System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1); [EOL]         System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1); [EOL]         Partial newPartial = new Partial(newTypes, newValues, iChronology); [EOL]         iChronology.validate(newPartial, newValues); [EOL]         return newPartial; [EOL]     } [EOL]     if (value == getValue(index)) { [EOL]         return this; [EOL]     } [EOL]     int[] newValues = getValues(); [EOL]     newValues = getField(index).set(this, index, newValues, value); [EOL]     return new Partial(this, newValues); [EOL] }
public Partial without(DateTimeFieldType fieldType) { [EOL]     int index = indexOf(fieldType); [EOL]     if (index != -1) { [EOL]         DateTimeFieldType[] newTypes = new DateTimeFieldType[size() - 1]; [EOL]         int[] newValues = new int[size() - 1]; [EOL]         System.arraycopy(iTypes, 0, newTypes, 0, index); [EOL]         System.arraycopy(iTypes, index + 1, newTypes, index, newTypes.length - index); [EOL]         System.arraycopy(iValues, 0, newValues, 0, index); [EOL]         System.arraycopy(iValues, index + 1, newValues, index, newValues.length - index); [EOL]         Partial newPartial = new Partial(iChronology, newTypes, newValues); [EOL]         iChronology.validate(newPartial, newValues); [EOL]         return newPartial; [EOL]     } [EOL]     return this; [EOL] }
public Partial without(DateTimeFieldType fieldType) { [EOL]     int index = indexOf(fieldType); [EOL]     if (index != -1) { [EOL]         DateTimeFieldType[] newTypes = new DateTimeFieldType[size() - 1]; [EOL]         int[] newValues = new int[size() - 1]; [EOL]         System.arraycopy(iTypes, 0, newTypes, 0, index); [EOL]         System.arraycopy(iTypes, index + 1, newTypes, index, newTypes.length - index); [EOL]         System.arraycopy(iValues, 0, newValues, 0, index); [EOL]         System.arraycopy(iValues, index + 1, newValues, index, newValues.length - index); [EOL]         Partial newPartial = new Partial(iChronology, newTypes, newValues); [EOL]         iChronology.validate(newPartial, newValues); [EOL]         return newPartial; [EOL]     } [EOL]     return this; [EOL] }
public DateTimeFormatter getFormatter() { [EOL]     DateTimeFormatter[] f = iFormatter; [EOL]     if (f == null) { [EOL]         if (size() == 0) { [EOL]             return null; [EOL]         } [EOL]         f = new DateTimeFormatter[2]; [EOL]         try { [EOL]             List<DateTimeFieldType> list = new ArrayList<DateTimeFieldType>(Arrays.asList(iTypes)); [EOL]             f[0] = ISODateTimeFormat.forFields(list, true, false); [EOL]             if (list.size() == 0) { [EOL]                 f[1] = f[0]; [EOL]             } [EOL]         } catch (IllegalArgumentException ex) { [EOL]         } [EOL]         iFormatter = f; [EOL]     } [EOL]     return f[0]; [EOL] }
public DateTimeFormatter getFormatter() { [EOL]     DateTimeFormatter[] f = iFormatter; [EOL]     if (f == null) { [EOL]         if (size() == 0) { [EOL]             return null; [EOL]         } [EOL]         f = new DateTimeFormatter[2]; [EOL]         try { [EOL]             List<DateTimeFieldType> list = new ArrayList<DateTimeFieldType>(Arrays.asList(iTypes)); [EOL]             f[0] = ISODateTimeFormat.forFields(list, true, false); [EOL]             if (list.size() == 0) { [EOL]                 f[1] = f[0]; [EOL]             } [EOL]         } catch (IllegalArgumentException ex) { [EOL]         } [EOL]         iFormatter = f; [EOL]     } [EOL]     return f[0]; [EOL] }
public DateTimeFormatter getFormatter() { [EOL]     DateTimeFormatter[] f = iFormatter; [EOL]     if (f == null) { [EOL]         if (size() == 0) { [EOL]             return null; [EOL]         } [EOL]         f = new DateTimeFormatter[2]; [EOL]         try { [EOL]             List<DateTimeFieldType> list = new ArrayList<DateTimeFieldType>(Arrays.asList(iTypes)); [EOL]             f[0] = ISODateTimeFormat.forFields(list, true, false); [EOL]             if (list.size() == 0) { [EOL]                 f[1] = f[0]; [EOL]             } [EOL]         } catch (IllegalArgumentException ex) { [EOL]         } [EOL]         iFormatter = f; [EOL]     } [EOL]     return f[0]; [EOL] }
public DateTimeFormatter getFormatter() { [EOL]     DateTimeFormatter[] f = iFormatter; [EOL]     if (f == null) { [EOL]         if (size() == 0) { [EOL]             return null; [EOL]         } [EOL]         f = new DateTimeFormatter[2]; [EOL]         try { [EOL]             List<DateTimeFieldType> list = new ArrayList<DateTimeFieldType>(Arrays.asList(iTypes)); [EOL]             f[0] = ISODateTimeFormat.forFields(list, true, false); [EOL]             if (list.size() == 0) { [EOL]                 f[1] = f[0]; [EOL]             } [EOL]         } catch (IllegalArgumentException ex) { [EOL]         } [EOL]         iFormatter = f; [EOL]     } [EOL]     return f[0]; [EOL] }
public String toString() { [EOL]     DateTimeFormatter[] f = iFormatter; [EOL]     if (f == null) { [EOL]         getFormatter(); [EOL]         f = iFormatter; [EOL]         if (f == null) { [EOL]             return toStringList(); [EOL]         } [EOL]     } [EOL]     DateTimeFormatter f1 = f[1]; [EOL]     if (f1 == null) { [EOL]         return toStringList(); [EOL]     } [EOL]     return f1.print(this); [EOL] }
public String toString() { [EOL]     DateTimeFormatter[] f = iFormatter; [EOL]     if (f == null) { [EOL]         getFormatter(); [EOL]         f = iFormatter; [EOL]         if (f == null) { [EOL]             return toStringList(); [EOL]         } [EOL]     } [EOL]     DateTimeFormatter f1 = f[1]; [EOL]     if (f1 == null) { [EOL]         return toStringList(); [EOL]     } [EOL]     return f1.print(this); [EOL] }
public String toString() { [EOL]     DateTimeFormatter[] f = iFormatter; [EOL]     if (f == null) { [EOL]         getFormatter(); [EOL]         f = iFormatter; [EOL]         if (f == null) { [EOL]             return toStringList(); [EOL]         } [EOL]     } [EOL]     DateTimeFormatter f1 = f[1]; [EOL]     if (f1 == null) { [EOL]         return toStringList(); [EOL]     } [EOL]     return f1.print(this); [EOL] }
public Partial getPartial() { [EOL]     return iPartial; [EOL] }
public int get() { [EOL]     return iPartial.getValue(iFieldIndex); [EOL] }
protected BaseDuration(ReadableInstant start, ReadableInstant end) { [EOL]     super(); [EOL]     if (start == end) { [EOL]         iMillis = 0L; [EOL]     } else { [EOL]         long startMillis = DateTimeUtils.getInstantMillis(start); [EOL]         long endMillis = DateTimeUtils.getInstantMillis(end); [EOL]         iMillis = FieldUtils.safeAdd(endMillis, -startMillis); [EOL]     } [EOL] }
protected BaseDuration(ReadableInstant start, ReadableInstant end) { [EOL]     super(); [EOL]     if (start == end) { [EOL]         iMillis = 0L; [EOL]     } else { [EOL]         long startMillis = DateTimeUtils.getInstantMillis(start); [EOL]         long endMillis = DateTimeUtils.getInstantMillis(end); [EOL]         iMillis = FieldUtils.safeAdd(endMillis, -startMillis); [EOL]     } [EOL] }
public Period toPeriod(Chronology chrono) { [EOL]     return new Period(getMillis(), chrono); [EOL] }
public Period toPeriod(Chronology chrono) { [EOL]     return new Period(getMillis(), chrono); [EOL] }
public Period toPeriod(PeriodType type, Chronology chrono) { [EOL]     return new Period(getMillis(), type, chrono); [EOL] }
public Period toPeriod(PeriodType type, Chronology chrono) { [EOL]     return new Period(getMillis(), type, chrono); [EOL] }
public Period toPeriodFrom(ReadableInstant startInstant, PeriodType type) { [EOL]     return new Period(startInstant, this, type); [EOL] }
public Period toPeriodFrom(ReadableInstant startInstant, PeriodType type) { [EOL]     return new Period(startInstant, this, type); [EOL] }
public static Years years(int years) { [EOL]     switch(years) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Years(years); [EOL]     } [EOL] }
public static Years years(int years) { [EOL]     switch(years) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Years(years); [EOL]     } [EOL] }
public static Years years(int years) { [EOL]     switch(years) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Years(years); [EOL]     } [EOL] }
public static Years years(int years) { [EOL]     switch(years) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Years(years); [EOL]     } [EOL] }
public static Years years(int years) { [EOL]     switch(years) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Years(years); [EOL]     } [EOL] }
public static Years years(int years) { [EOL]     switch(years) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Years(years); [EOL]     } [EOL] }
public static Years years(int years) { [EOL]     switch(years) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Years(years); [EOL]     } [EOL] }
public static Years yearsBetween(ReadableInstant start, ReadableInstant end) { [EOL]     int amount = BaseSingleFieldPeriod.between(start, end, DurationFieldType.years()); [EOL]     return Years.years(amount); [EOL] }
public static Years yearsBetween(ReadableInstant start, ReadableInstant end) { [EOL]     int amount = BaseSingleFieldPeriod.between(start, end, DurationFieldType.years()); [EOL]     return Years.years(amount); [EOL] }
public static Years yearsBetween(ReadableInstant start, ReadableInstant end) { [EOL]     int amount = BaseSingleFieldPeriod.between(start, end, DurationFieldType.years()); [EOL]     return Years.years(amount); [EOL] }
public static Years yearsBetween(ReadablePartial start, ReadablePartial end) { [EOL]     if (start instanceof LocalDate && end instanceof LocalDate) { [EOL]         Chronology chrono = DateTimeUtils.getChronology(start.getChronology()); [EOL]         int years = chrono.years().getDifference(((LocalDate) end).getLocalMillis(), ((LocalDate) start).getLocalMillis()); [EOL]         return Years.years(years); [EOL]     } [EOL]     int amount = BaseSingleFieldPeriod.between(start, end, ZERO); [EOL]     return Years.years(amount); [EOL] }
public static Years yearsBetween(ReadablePartial start, ReadablePartial end) { [EOL]     if (start instanceof LocalDate && end instanceof LocalDate) { [EOL]         Chronology chrono = DateTimeUtils.getChronology(start.getChronology()); [EOL]         int years = chrono.years().getDifference(((LocalDate) end).getLocalMillis(), ((LocalDate) start).getLocalMillis()); [EOL]         return Years.years(years); [EOL]     } [EOL]     int amount = BaseSingleFieldPeriod.between(start, end, ZERO); [EOL]     return Years.years(amount); [EOL] }
private Years(int years) { [EOL]     super(years); [EOL] }
public int getYears() { [EOL]     return getValue(); [EOL] }
public Years negated() { [EOL]     return Years.years(FieldUtils.safeNegate(getValue())); [EOL] }
public Years negated() { [EOL]     return Years.years(FieldUtils.safeNegate(getValue())); [EOL] }
public Years negated() { [EOL]     return Years.years(FieldUtils.safeNegate(getValue())); [EOL] }
public Years negated() { [EOL]     return Years.years(FieldUtils.safeNegate(getValue())); [EOL] }
public Years negated() { [EOL]     return Years.years(FieldUtils.safeNegate(getValue())); [EOL] }
public boolean isGreaterThan(Years other) { [EOL]     if (other == null) { [EOL]         return getValue() > 0; [EOL]     } [EOL]     return getValue() > other.getValue(); [EOL] }
public boolean isLessThan(Years other) { [EOL]     if (other == null) { [EOL]         return getValue() < 0; [EOL]     } [EOL]     return getValue() < other.getValue(); [EOL] }
public boolean isLessThan(Years other) { [EOL]     if (other == null) { [EOL]         return getValue() < 0; [EOL]     } [EOL]     return getValue() < other.getValue(); [EOL] }
public boolean isLessThan(Years other) { [EOL]     if (other == null) { [EOL]         return getValue() < 0; [EOL]     } [EOL]     return getValue() < other.getValue(); [EOL] }
public boolean isLessThan(Years other) { [EOL]     if (other == null) { [EOL]         return getValue() < 0; [EOL]     } [EOL]     return getValue() < other.getValue(); [EOL] }
public boolean isLessThan(Years other) { [EOL]     if (other == null) { [EOL]         return getValue() < 0; [EOL]     } [EOL]     return getValue() < other.getValue(); [EOL] }
@ToString [EOL] public String toString() { [EOL]     return "P" + String.valueOf(getValue()) + "Y"; [EOL] }
public Instant() { [EOL]     super(); [EOL]     iMillis = DateTimeUtils.currentTimeMillis(); [EOL] }
public Instant(Object instant) { [EOL]     super(); [EOL]     InstantConverter converter = ConverterManager.getInstance().getInstantConverter(instant); [EOL]     iMillis = converter.getInstantMillis(instant, ISOChronology.getInstanceUTC()); [EOL] }
public Instant(Object instant) { [EOL]     super(); [EOL]     InstantConverter converter = ConverterManager.getInstance().getInstantConverter(instant); [EOL]     iMillis = converter.getInstantMillis(instant, ISOChronology.getInstanceUTC()); [EOL] }
public Instant toInstant() { [EOL]     return this; [EOL] }
public static LocalDate now() { [EOL]     return new LocalDate(); [EOL] }
@FromString [EOL] public static LocalDate parse(String str) { [EOL]     return parse(str, ISODateTimeFormat.localDateParser()); [EOL] }
@FromString [EOL] public static LocalDate parse(String str) { [EOL]     return parse(str, ISODateTimeFormat.localDateParser()); [EOL] }
public static LocalDate parse(String str, DateTimeFormatter formatter) { [EOL]     return formatter.parseLocalDate(str); [EOL] }
public static LocalDate parse(String str, DateTimeFormatter formatter) { [EOL]     return formatter.parseLocalDate(str); [EOL] }
public static LocalDate parse(String str, DateTimeFormatter formatter) { [EOL]     return formatter.parseLocalDate(str); [EOL] }
public static LocalDate parse(String str, DateTimeFormatter formatter) { [EOL]     return formatter.parseLocalDate(str); [EOL] }
@SuppressWarnings("deprecation") [EOL] public static LocalDate fromDateFields(Date date) { [EOL]     if (date == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     if (date.getTime() < 0) { [EOL]         GregorianCalendar cal = new GregorianCalendar(); [EOL]         cal.setTime(date); [EOL]         return fromCalendarFields(cal); [EOL]     } [EOL]     return new LocalDate(date.getYear() + 1900, date.getMonth() + 1, date.getDate()); [EOL] }
@SuppressWarnings("deprecation") [EOL] public static LocalDate fromDateFields(Date date) { [EOL]     if (date == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     if (date.getTime() < 0) { [EOL]         GregorianCalendar cal = new GregorianCalendar(); [EOL]         cal.setTime(date); [EOL]         return fromCalendarFields(cal); [EOL]     } [EOL]     return new LocalDate(date.getYear() + 1900, date.getMonth() + 1, date.getDate()); [EOL] }
@SuppressWarnings("deprecation") [EOL] public static LocalDate fromDateFields(Date date) { [EOL]     if (date == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     if (date.getTime() < 0) { [EOL]         GregorianCalendar cal = new GregorianCalendar(); [EOL]         cal.setTime(date); [EOL]         return fromCalendarFields(cal); [EOL]     } [EOL]     return new LocalDate(date.getYear() + 1900, date.getMonth() + 1, date.getDate()); [EOL] }
public LocalDate(Chronology chronology) { [EOL]     this(DateTimeUtils.currentTimeMillis(), chronology); [EOL] }
public LocalDate(Chronology chronology) { [EOL]     this(DateTimeUtils.currentTimeMillis(), chronology); [EOL] }
public LocalDate(Object instant, DateTimeZone zone) { [EOL]     PartialConverter converter = ConverterManager.getInstance().getPartialConverter(instant); [EOL]     Chronology chronology = converter.getChronology(instant, zone); [EOL]     chronology = DateTimeUtils.getChronology(chronology); [EOL]     iChronology = chronology.withUTC(); [EOL]     int[] values = converter.getPartialValues(this, instant, chronology, ISODateTimeFormat.localDateParser()); [EOL]     iLocalMillis = iChronology.getDateTimeMillis(values[0], values[1], values[2], 0); [EOL] }
public LocalDate(Object instant, DateTimeZone zone) { [EOL]     PartialConverter converter = ConverterManager.getInstance().getPartialConverter(instant); [EOL]     Chronology chronology = converter.getChronology(instant, zone); [EOL]     chronology = DateTimeUtils.getChronology(chronology); [EOL]     iChronology = chronology.withUTC(); [EOL]     int[] values = converter.getPartialValues(this, instant, chronology, ISODateTimeFormat.localDateParser()); [EOL]     iLocalMillis = iChronology.getDateTimeMillis(values[0], values[1], values[2], 0); [EOL] }
public LocalDate(Object instant, DateTimeZone zone) { [EOL]     PartialConverter converter = ConverterManager.getInstance().getPartialConverter(instant); [EOL]     Chronology chronology = converter.getChronology(instant, zone); [EOL]     chronology = DateTimeUtils.getChronology(chronology); [EOL]     iChronology = chronology.withUTC(); [EOL]     int[] values = converter.getPartialValues(this, instant, chronology, ISODateTimeFormat.localDateParser()); [EOL]     iLocalMillis = iChronology.getDateTimeMillis(values[0], values[1], values[2], 0); [EOL] }
public LocalDate(Object instant, DateTimeZone zone) { [EOL]     PartialConverter converter = ConverterManager.getInstance().getPartialConverter(instant); [EOL]     Chronology chronology = converter.getChronology(instant, zone); [EOL]     chronology = DateTimeUtils.getChronology(chronology); [EOL]     iChronology = chronology.withUTC(); [EOL]     int[] values = converter.getPartialValues(this, instant, chronology, ISODateTimeFormat.localDateParser()); [EOL]     iLocalMillis = iChronology.getDateTimeMillis(values[0], values[1], values[2], 0); [EOL] }
private Object readResolve() { [EOL]     if (iChronology == null) { [EOL]         return new LocalDate(iLocalMillis, ISOChronology.getInstanceUTC()); [EOL]     } [EOL]     if (DateTimeZone.UTC.equals(iChronology.getZone()) == false) { [EOL]         return new LocalDate(iLocalMillis, iChronology.withUTC()); [EOL]     } [EOL]     return this; [EOL] }
private Object readResolve() { [EOL]     if (iChronology == null) { [EOL]         return new LocalDate(iLocalMillis, ISOChronology.getInstanceUTC()); [EOL]     } [EOL]     if (DateTimeZone.UTC.equals(iChronology.getZone()) == false) { [EOL]         return new LocalDate(iLocalMillis, iChronology.withUTC()); [EOL]     } [EOL]     return this; [EOL] }
private Object readResolve() { [EOL]     if (iChronology == null) { [EOL]         return new LocalDate(iLocalMillis, ISOChronology.getInstanceUTC()); [EOL]     } [EOL]     if (DateTimeZone.UTC.equals(iChronology.getZone()) == false) { [EOL]         return new LocalDate(iLocalMillis, iChronology.withUTC()); [EOL]     } [EOL]     return this; [EOL] }
public int get(DateTimeFieldType fieldType) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("The DateTimeFieldType must not be null"); [EOL]     } [EOL]     if (isSupported(fieldType) == false) { [EOL]         throw new IllegalArgumentException("Field '" + fieldType + "' is not supported"); [EOL]     } [EOL]     return fieldType.getField(getChronology()).get(getLocalMillis()); [EOL] }
public int get(DateTimeFieldType fieldType) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("The DateTimeFieldType must not be null"); [EOL]     } [EOL]     if (isSupported(fieldType) == false) { [EOL]         throw new IllegalArgumentException("Field '" + fieldType + "' is not supported"); [EOL]     } [EOL]     return fieldType.getField(getChronology()).get(getLocalMillis()); [EOL] }
public int get(DateTimeFieldType fieldType) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("The DateTimeFieldType must not be null"); [EOL]     } [EOL]     if (isSupported(fieldType) == false) { [EOL]         throw new IllegalArgumentException("Field '" + fieldType + "' is not supported"); [EOL]     } [EOL]     return fieldType.getField(getChronology()).get(getLocalMillis()); [EOL] }
public int compareTo(ReadablePartial partial) { [EOL]     if (this == partial) { [EOL]         return 0; [EOL]     } [EOL]     if (partial instanceof LocalDate) { [EOL]         LocalDate other = (LocalDate) partial; [EOL]         if (iChronology.equals(other.iChronology)) { [EOL]             return (iLocalMillis < other.iLocalMillis ? -1 : (iLocalMillis == other.iLocalMillis ? 0 : 1)); [EOL]         } [EOL]     } [EOL]     return super.compareTo(partial); [EOL] }
@Deprecated [EOL] public DateTime toDateTimeAtMidnight() { [EOL]     return toDateTimeAtMidnight(null); [EOL] }
@Deprecated [EOL] public DateTime toDateTimeAtMidnight(DateTimeZone zone) { [EOL]     zone = DateTimeUtils.getZone(zone); [EOL]     Chronology chrono = getChronology().withZone(zone); [EOL]     return new DateTime(getYear(), getMonthOfYear(), getDayOfMonth(), 0, 0, 0, 0, chrono); [EOL] }
@Deprecated [EOL] public DateTime toDateTimeAtMidnight(DateTimeZone zone) { [EOL]     zone = DateTimeUtils.getZone(zone); [EOL]     Chronology chrono = getChronology().withZone(zone); [EOL]     return new DateTime(getYear(), getMonthOfYear(), getDayOfMonth(), 0, 0, 0, 0, chrono); [EOL] }
public LocalDateTime toLocalDateTime(LocalTime time) { [EOL]     if (time == null) { [EOL]         throw new IllegalArgumentException("The time must not be null"); [EOL]     } [EOL]     if (getChronology() != time.getChronology()) { [EOL]         throw new IllegalArgumentException("The chronology of the time does not match"); [EOL]     } [EOL]     long localMillis = getLocalMillis() + time.getLocalMillis(); [EOL]     return new LocalDateTime(localMillis, getChronology()); [EOL] }
public LocalDateTime toLocalDateTime(LocalTime time) { [EOL]     if (time == null) { [EOL]         throw new IllegalArgumentException("The time must not be null"); [EOL]     } [EOL]     if (getChronology() != time.getChronology()) { [EOL]         throw new IllegalArgumentException("The chronology of the time does not match"); [EOL]     } [EOL]     long localMillis = getLocalMillis() + time.getLocalMillis(); [EOL]     return new LocalDateTime(localMillis, getChronology()); [EOL] }
public LocalDateTime toLocalDateTime(LocalTime time) { [EOL]     if (time == null) { [EOL]         throw new IllegalArgumentException("The time must not be null"); [EOL]     } [EOL]     if (getChronology() != time.getChronology()) { [EOL]         throw new IllegalArgumentException("The chronology of the time does not match"); [EOL]     } [EOL]     long localMillis = getLocalMillis() + time.getLocalMillis(); [EOL]     return new LocalDateTime(localMillis, getChronology()); [EOL] }
public DateTime toDateTime(LocalTime time, DateTimeZone zone) { [EOL]     if (time != null && getChronology() != time.getChronology()) { [EOL]         throw new IllegalArgumentException("The chronology of the time does not match"); [EOL]     } [EOL]     Chronology chrono = getChronology().withZone(zone); [EOL]     long instant = DateTimeUtils.currentTimeMillis(); [EOL]     instant = chrono.set(this, instant); [EOL]     if (time != null) { [EOL]         instant = chrono.set(time, instant); [EOL]     } [EOL]     return new DateTime(instant, chrono); [EOL] }
public DateTime toDateTime(LocalTime time, DateTimeZone zone) { [EOL]     if (time != null && getChronology() != time.getChronology()) { [EOL]         throw new IllegalArgumentException("The chronology of the time does not match"); [EOL]     } [EOL]     Chronology chrono = getChronology().withZone(zone); [EOL]     long instant = DateTimeUtils.currentTimeMillis(); [EOL]     instant = chrono.set(this, instant); [EOL]     if (time != null) { [EOL]         instant = chrono.set(time, instant); [EOL]     } [EOL]     return new DateTime(instant, chrono); [EOL] }
public DateTime toDateTime(LocalTime time, DateTimeZone zone) { [EOL]     if (time != null && getChronology() != time.getChronology()) { [EOL]         throw new IllegalArgumentException("The chronology of the time does not match"); [EOL]     } [EOL]     Chronology chrono = getChronology().withZone(zone); [EOL]     long instant = DateTimeUtils.currentTimeMillis(); [EOL]     instant = chrono.set(this, instant); [EOL]     if (time != null) { [EOL]         instant = chrono.set(time, instant); [EOL]     } [EOL]     return new DateTime(instant, chrono); [EOL] }
public Interval toInterval(DateTimeZone zone) { [EOL]     zone = DateTimeUtils.getZone(zone); [EOL]     DateTime start = toDateTimeAtStartOfDay(zone); [EOL]     DateTime end = plusDays(1).toDateTimeAtStartOfDay(zone); [EOL]     return new Interval(start, end); [EOL] }
public Interval toInterval(DateTimeZone zone) { [EOL]     zone = DateTimeUtils.getZone(zone); [EOL]     DateTime start = toDateTimeAtStartOfDay(zone); [EOL]     DateTime end = plusDays(1).toDateTimeAtStartOfDay(zone); [EOL]     return new Interval(start, end); [EOL] }
@SuppressWarnings("deprecation") [EOL] public Date toDate() { [EOL]     int dom = getDayOfMonth(); [EOL]     Date date = new Date(getYear() - 1900, getMonthOfYear() - 1, dom); [EOL]     LocalDate check = LocalDate.fromDateFields(date); [EOL]     if (check.isBefore(this)) { [EOL]         while (check.equals(this) == false) { [EOL]             date.setTime(date.getTime() + 3600000); [EOL]             check = LocalDate.fromDateFields(date); [EOL]         } [EOL]         while (date.getDate() == dom) { [EOL]             date.setTime(date.getTime() - 1000); [EOL]         } [EOL]         date.setTime(date.getTime() + 1000); [EOL]     } else if (check.equals(this)) { [EOL]         Date earlier = new Date(date.getTime() - TimeZone.getDefault().getDSTSavings()); [EOL]         if (earlier.getDate() == dom) { [EOL]             date = earlier; [EOL]         } [EOL]     } [EOL]     return date; [EOL] }
@SuppressWarnings("deprecation") [EOL] public Date toDate() { [EOL]     int dom = getDayOfMonth(); [EOL]     Date date = new Date(getYear() - 1900, getMonthOfYear() - 1, dom); [EOL]     LocalDate check = LocalDate.fromDateFields(date); [EOL]     if (check.isBefore(this)) { [EOL]         while (check.equals(this) == false) { [EOL]             date.setTime(date.getTime() + 3600000); [EOL]             check = LocalDate.fromDateFields(date); [EOL]         } [EOL]         while (date.getDate() == dom) { [EOL]             date.setTime(date.getTime() - 1000); [EOL]         } [EOL]         date.setTime(date.getTime() + 1000); [EOL]     } else if (check.equals(this)) { [EOL]         Date earlier = new Date(date.getTime() - TimeZone.getDefault().getDSTSavings()); [EOL]         if (earlier.getDate() == dom) { [EOL]             date = earlier; [EOL]         } [EOL]     } [EOL]     return date; [EOL] }
@SuppressWarnings("deprecation") [EOL] public Date toDate() { [EOL]     int dom = getDayOfMonth(); [EOL]     Date date = new Date(getYear() - 1900, getMonthOfYear() - 1, dom); [EOL]     LocalDate check = LocalDate.fromDateFields(date); [EOL]     if (check.isBefore(this)) { [EOL]         while (check.equals(this) == false) { [EOL]             date.setTime(date.getTime() + 3600000); [EOL]             check = LocalDate.fromDateFields(date); [EOL]         } [EOL]         while (date.getDate() == dom) { [EOL]             date.setTime(date.getTime() - 1000); [EOL]         } [EOL]         date.setTime(date.getTime() + 1000); [EOL]     } else if (check.equals(this)) { [EOL]         Date earlier = new Date(date.getTime() - TimeZone.getDefault().getDSTSavings()); [EOL]         if (earlier.getDate() == dom) { [EOL]             date = earlier; [EOL]         } [EOL]     } [EOL]     return date; [EOL] }
LocalDate withLocalMillis(long newMillis) { [EOL]     newMillis = iChronology.dayOfMonth().roundFloor(newMillis); [EOL]     return (newMillis == getLocalMillis() ? this : new LocalDate(newMillis, getChronology())); [EOL] }
LocalDate withLocalMillis(long newMillis) { [EOL]     newMillis = iChronology.dayOfMonth().roundFloor(newMillis); [EOL]     return (newMillis == getLocalMillis() ? this : new LocalDate(newMillis, getChronology())); [EOL] }
public LocalDate withField(DateTimeFieldType fieldType, int value) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("Field must not be null"); [EOL]     } [EOL]     if (isSupported(fieldType) == false) { [EOL]         throw new IllegalArgumentException("Field '" + fieldType + "' is not supported"); [EOL]     } [EOL]     long instant = fieldType.getField(getChronology()).set(getLocalMillis(), value); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalDate withField(DateTimeFieldType fieldType, int value) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("Field must not be null"); [EOL]     } [EOL]     if (isSupported(fieldType) == false) { [EOL]         throw new IllegalArgumentException("Field '" + fieldType + "' is not supported"); [EOL]     } [EOL]     long instant = fieldType.getField(getChronology()).set(getLocalMillis(), value); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalDate withField(DateTimeFieldType fieldType, int value) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("Field must not be null"); [EOL]     } [EOL]     if (isSupported(fieldType) == false) { [EOL]         throw new IllegalArgumentException("Field '" + fieldType + "' is not supported"); [EOL]     } [EOL]     long instant = fieldType.getField(getChronology()).set(getLocalMillis(), value); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalDate withFieldAdded(DurationFieldType fieldType, int amount) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("Field must not be null"); [EOL]     } [EOL]     if (isSupported(fieldType) == false) { [EOL]         throw new IllegalArgumentException("Field '" + fieldType + "' is not supported"); [EOL]     } [EOL]     if (amount == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = fieldType.getField(getChronology()).add(getLocalMillis(), amount); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalDate withFieldAdded(DurationFieldType fieldType, int amount) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("Field must not be null"); [EOL]     } [EOL]     if (isSupported(fieldType) == false) { [EOL]         throw new IllegalArgumentException("Field '" + fieldType + "' is not supported"); [EOL]     } [EOL]     if (amount == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = fieldType.getField(getChronology()).add(getLocalMillis(), amount); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalDate withFieldAdded(DurationFieldType fieldType, int amount) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("Field must not be null"); [EOL]     } [EOL]     if (isSupported(fieldType) == false) { [EOL]         throw new IllegalArgumentException("Field '" + fieldType + "' is not supported"); [EOL]     } [EOL]     if (amount == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = fieldType.getField(getChronology()).add(getLocalMillis(), amount); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalDate withFieldAdded(DurationFieldType fieldType, int amount) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("Field must not be null"); [EOL]     } [EOL]     if (isSupported(fieldType) == false) { [EOL]         throw new IllegalArgumentException("Field '" + fieldType + "' is not supported"); [EOL]     } [EOL]     if (amount == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = fieldType.getField(getChronology()).add(getLocalMillis(), amount); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalDate plusWeeks(int weeks) { [EOL]     if (weeks == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().weeks().add(getLocalMillis(), weeks); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalDate plusWeeks(int weeks) { [EOL]     if (weeks == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().weeks().add(getLocalMillis(), weeks); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalDate plusWeeks(int weeks) { [EOL]     if (weeks == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().weeks().add(getLocalMillis(), weeks); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalDate plusDays(int days) { [EOL]     if (days == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().days().add(getLocalMillis(), days); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalDate plusDays(int days) { [EOL]     if (days == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().days().add(getLocalMillis(), days); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalDate plusDays(int days) { [EOL]     if (days == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().days().add(getLocalMillis(), days); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalDate minusMonths(int months) { [EOL]     if (months == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().months().subtract(getLocalMillis(), months); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalDate minusMonths(int months) { [EOL]     if (months == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().months().subtract(getLocalMillis(), months); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalDate minusMonths(int months) { [EOL]     if (months == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().months().subtract(getLocalMillis(), months); [EOL]     return withLocalMillis(instant); [EOL] }
public static PeriodFormatter getDefault() { [EOL]     return wordBased(Locale.ENGLISH); [EOL] }
public static EthiopicChronology getInstance(DateTimeZone zone, int minDaysInFirstWeek) { [EOL]     if (zone == null) { [EOL]         zone = DateTimeZone.getDefault(); [EOL]     } [EOL]     EthiopicChronology chrono; [EOL]     synchronized (cCache) { [EOL]         EthiopicChronology[] chronos = cCache.get(zone); [EOL]         if (chronos == null) { [EOL]             chronos = new EthiopicChronology[7]; [EOL]             cCache.put(zone, chronos); [EOL]         } [EOL]         try { [EOL]             chrono = chronos[minDaysInFirstWeek - 1]; [EOL]         } catch (ArrayIndexOutOfBoundsException e) { [EOL]             throw new IllegalArgumentException("Invalid min days in first week: " + minDaysInFirstWeek); [EOL]         } [EOL]         if (chrono == null) { [EOL]             if (zone == DateTimeZone.UTC) { [EOL]                 chrono = new EthiopicChronology(null, null, minDaysInFirstWeek); [EOL]                 DateTime lowerLimit = new DateTime(1, 1, 1, 0, 0, 0, 0, chrono); [EOL]                 chrono = new EthiopicChronology(LimitChronology.getInstance(chrono, lowerLimit, null), null, minDaysInFirstWeek); [EOL]             } else { [EOL]                 chrono = getInstance(DateTimeZone.UTC, minDaysInFirstWeek); [EOL]                 chrono = new EthiopicChronology(ZonedChronology.getInstance(chrono, zone), null, minDaysInFirstWeek); [EOL]             } [EOL]             chronos[minDaysInFirstWeek - 1] = chrono; [EOL]         } [EOL]     } [EOL]     return chrono; [EOL] }
public static EthiopicChronology getInstance(DateTimeZone zone, int minDaysInFirstWeek) { [EOL]     if (zone == null) { [EOL]         zone = DateTimeZone.getDefault(); [EOL]     } [EOL]     EthiopicChronology chrono; [EOL]     synchronized (cCache) { [EOL]         EthiopicChronology[] chronos = cCache.get(zone); [EOL]         if (chronos == null) { [EOL]             chronos = new EthiopicChronology[7]; [EOL]             cCache.put(zone, chronos); [EOL]         } [EOL]         try { [EOL]             chrono = chronos[minDaysInFirstWeek - 1]; [EOL]         } catch (ArrayIndexOutOfBoundsException e) { [EOL]             throw new IllegalArgumentException("Invalid min days in first week: " + minDaysInFirstWeek); [EOL]         } [EOL]         if (chrono == null) { [EOL]             if (zone == DateTimeZone.UTC) { [EOL]                 chrono = new EthiopicChronology(null, null, minDaysInFirstWeek); [EOL]                 DateTime lowerLimit = new DateTime(1, 1, 1, 0, 0, 0, 0, chrono); [EOL]                 chrono = new EthiopicChronology(LimitChronology.getInstance(chrono, lowerLimit, null), null, minDaysInFirstWeek); [EOL]             } else { [EOL]                 chrono = getInstance(DateTimeZone.UTC, minDaysInFirstWeek); [EOL]                 chrono = new EthiopicChronology(ZonedChronology.getInstance(chrono, zone), null, minDaysInFirstWeek); [EOL]             } [EOL]             chronos[minDaysInFirstWeek - 1] = chrono; [EOL]         } [EOL]     } [EOL]     return chrono; [EOL] }
public static EthiopicChronology getInstance(DateTimeZone zone, int minDaysInFirstWeek) { [EOL]     if (zone == null) { [EOL]         zone = DateTimeZone.getDefault(); [EOL]     } [EOL]     EthiopicChronology chrono; [EOL]     synchronized (cCache) { [EOL]         EthiopicChronology[] chronos = cCache.get(zone); [EOL]         if (chronos == null) { [EOL]             chronos = new EthiopicChronology[7]; [EOL]             cCache.put(zone, chronos); [EOL]         } [EOL]         try { [EOL]             chrono = chronos[minDaysInFirstWeek - 1]; [EOL]         } catch (ArrayIndexOutOfBoundsException e) { [EOL]             throw new IllegalArgumentException("Invalid min days in first week: " + minDaysInFirstWeek); [EOL]         } [EOL]         if (chrono == null) { [EOL]             if (zone == DateTimeZone.UTC) { [EOL]                 chrono = new EthiopicChronology(null, null, minDaysInFirstWeek); [EOL]                 DateTime lowerLimit = new DateTime(1, 1, 1, 0, 0, 0, 0, chrono); [EOL]                 chrono = new EthiopicChronology(LimitChronology.getInstance(chrono, lowerLimit, null), null, minDaysInFirstWeek); [EOL]             } else { [EOL]                 chrono = getInstance(DateTimeZone.UTC, minDaysInFirstWeek); [EOL]                 chrono = new EthiopicChronology(ZonedChronology.getInstance(chrono, zone), null, minDaysInFirstWeek); [EOL]             } [EOL]             chronos[minDaysInFirstWeek - 1] = chrono; [EOL]         } [EOL]     } [EOL]     return chrono; [EOL] }
public static EthiopicChronology getInstance(DateTimeZone zone, int minDaysInFirstWeek) { [EOL]     if (zone == null) { [EOL]         zone = DateTimeZone.getDefault(); [EOL]     } [EOL]     EthiopicChronology chrono; [EOL]     synchronized (cCache) { [EOL]         EthiopicChronology[] chronos = cCache.get(zone); [EOL]         if (chronos == null) { [EOL]             chronos = new EthiopicChronology[7]; [EOL]             cCache.put(zone, chronos); [EOL]         } [EOL]         try { [EOL]             chrono = chronos[minDaysInFirstWeek - 1]; [EOL]         } catch (ArrayIndexOutOfBoundsException e) { [EOL]             throw new IllegalArgumentException("Invalid min days in first week: " + minDaysInFirstWeek); [EOL]         } [EOL]         if (chrono == null) { [EOL]             if (zone == DateTimeZone.UTC) { [EOL]                 chrono = new EthiopicChronology(null, null, minDaysInFirstWeek); [EOL]                 DateTime lowerLimit = new DateTime(1, 1, 1, 0, 0, 0, 0, chrono); [EOL]                 chrono = new EthiopicChronology(LimitChronology.getInstance(chrono, lowerLimit, null), null, minDaysInFirstWeek); [EOL]             } else { [EOL]                 chrono = getInstance(DateTimeZone.UTC, minDaysInFirstWeek); [EOL]                 chrono = new EthiopicChronology(ZonedChronology.getInstance(chrono, zone), null, minDaysInFirstWeek); [EOL]             } [EOL]             chronos[minDaysInFirstWeek - 1] = chrono; [EOL]         } [EOL]     } [EOL]     return chrono; [EOL] }
EthiopicChronology(Chronology base, Object param, int minDaysInFirstWeek) { [EOL]     super(base, param, minDaysInFirstWeek); [EOL] }
protected void assemble(Fields fields) { [EOL]     if (getBase() == null) { [EOL]         super.assemble(fields); [EOL]         fields.year = new SkipDateTimeField(this, fields.year); [EOL]         fields.weekyear = new SkipDateTimeField(this, fields.weekyear); [EOL]         fields.era = ERA_FIELD; [EOL]         fields.monthOfYear = new BasicMonthOfYearDateTimeField(this, 13); [EOL]         fields.months = fields.monthOfYear.getDurationField(); [EOL]     } [EOL] }
public DurationField getDurationField() { [EOL]     return UnsupportedDurationField.getInstance(DurationFieldType.eras()); [EOL] }
public static PeriodType standard() { [EOL]     PeriodType type = cStandard; [EOL]     if (type == null) { [EOL]         type = new PeriodType("Standard", new DurationFieldType[] { DurationFieldType.years(), DurationFieldType.months(), DurationFieldType.weeks(), DurationFieldType.days(), DurationFieldType.hours(), DurationFieldType.minutes(), DurationFieldType.seconds(), DurationFieldType.millis() }, new int[] { 0, 1, 2, 3, 4, 5, 6, 7 }); [EOL]         cStandard = type; [EOL]     } [EOL]     return type; [EOL] }
public static PeriodType standard() { [EOL]     PeriodType type = cStandard; [EOL]     if (type == null) { [EOL]         type = new PeriodType("Standard", new DurationFieldType[] { DurationFieldType.years(), DurationFieldType.months(), DurationFieldType.weeks(), DurationFieldType.days(), DurationFieldType.hours(), DurationFieldType.minutes(), DurationFieldType.seconds(), DurationFieldType.millis() }, new int[] { 0, 1, 2, 3, 4, 5, 6, 7 }); [EOL]         cStandard = type; [EOL]     } [EOL]     return type; [EOL] }
public static PeriodType yearMonthDayTime() { [EOL]     PeriodType type = cYMDTime; [EOL]     if (type == null) { [EOL]         type = new PeriodType("YearMonthDayTime", new DurationFieldType[] { DurationFieldType.years(), DurationFieldType.months(), DurationFieldType.days(), DurationFieldType.hours(), DurationFieldType.minutes(), DurationFieldType.seconds(), DurationFieldType.millis() }, new int[] { 0, 1, -1, 2, 3, 4, 5, 6 }); [EOL]         cYMDTime = type; [EOL]     } [EOL]     return type; [EOL] }
public static PeriodType yearMonthDayTime() { [EOL]     PeriodType type = cYMDTime; [EOL]     if (type == null) { [EOL]         type = new PeriodType("YearMonthDayTime", new DurationFieldType[] { DurationFieldType.years(), DurationFieldType.months(), DurationFieldType.days(), DurationFieldType.hours(), DurationFieldType.minutes(), DurationFieldType.seconds(), DurationFieldType.millis() }, new int[] { 0, 1, -1, 2, 3, 4, 5, 6 }); [EOL]         cYMDTime = type; [EOL]     } [EOL]     return type; [EOL] }
public static PeriodType time() { [EOL]     PeriodType type = cTime; [EOL]     if (type == null) { [EOL]         type = new PeriodType("Time", new DurationFieldType[] { DurationFieldType.hours(), DurationFieldType.minutes(), DurationFieldType.seconds(), DurationFieldType.millis() }, new int[] { -1, -1, -1, -1, 0, 1, 2, 3 }); [EOL]         cTime = type; [EOL]     } [EOL]     return type; [EOL] }
public static PeriodType time() { [EOL]     PeriodType type = cTime; [EOL]     if (type == null) { [EOL]         type = new PeriodType("Time", new DurationFieldType[] { DurationFieldType.hours(), DurationFieldType.minutes(), DurationFieldType.seconds(), DurationFieldType.millis() }, new int[] { -1, -1, -1, -1, 0, 1, 2, 3 }); [EOL]         cTime = type; [EOL]     } [EOL]     return type; [EOL] }
public static PeriodType seconds() { [EOL]     PeriodType type = cSeconds; [EOL]     if (type == null) { [EOL]         type = new PeriodType("Seconds", new DurationFieldType[] { DurationFieldType.seconds() }, new int[] { -1, -1, -1, -1, -1, -1, 0, -1 }); [EOL]         cSeconds = type; [EOL]     } [EOL]     return type; [EOL] }
public static PeriodType millis() { [EOL]     PeriodType type = cMillis; [EOL]     if (type == null) { [EOL]         type = new PeriodType("Millis", new DurationFieldType[] { DurationFieldType.millis() }, new int[] { -1, -1, -1, -1, -1, -1, -1, 0 }); [EOL]         cMillis = type; [EOL]     } [EOL]     return type; [EOL] }
public static PeriodType millis() { [EOL]     PeriodType type = cMillis; [EOL]     if (type == null) { [EOL]         type = new PeriodType("Millis", new DurationFieldType[] { DurationFieldType.millis() }, new int[] { -1, -1, -1, -1, -1, -1, -1, 0 }); [EOL]         cMillis = type; [EOL]     } [EOL]     return type; [EOL] }
public static synchronized PeriodType forFields(DurationFieldType[] types) { [EOL]     if (types == null || types.length == 0) { [EOL]         throw new IllegalArgumentException("Types array must not be null or empty"); [EOL]     } [EOL]     for (int i = 0; i < types.length; i++) { [EOL]         if (types[i] == null) { [EOL]             throw new IllegalArgumentException("Types array must not contain null"); [EOL]         } [EOL]     } [EOL]     Map<PeriodType, Object> cache = cTypes; [EOL]     if (cache.isEmpty()) { [EOL]         cache.put(standard(), standard()); [EOL]         cache.put(yearMonthDayTime(), yearMonthDayTime()); [EOL]         cache.put(yearMonthDay(), yearMonthDay()); [EOL]         cache.put(yearWeekDayTime(), yearWeekDayTime()); [EOL]         cache.put(yearWeekDay(), yearWeekDay()); [EOL]         cache.put(yearDayTime(), yearDayTime()); [EOL]         cache.put(yearDay(), yearDay()); [EOL]         cache.put(dayTime(), dayTime()); [EOL]         cache.put(time(), time()); [EOL]         cache.put(years(), years()); [EOL]         cache.put(months(), months()); [EOL]         cache.put(weeks(), weeks()); [EOL]         cache.put(days(), days()); [EOL]         cache.put(hours(), hours()); [EOL]         cache.put(minutes(), minutes()); [EOL]         cache.put(seconds(), seconds()); [EOL]         cache.put(millis(), millis()); [EOL]     } [EOL]     PeriodType inPartType = new PeriodType(null, types, null); [EOL]     Object cached = cache.get(inPartType); [EOL]     if (cached instanceof PeriodType) { [EOL]         return (PeriodType) cached; [EOL]     } [EOL]     if (cached != null) { [EOL]         throw new IllegalArgumentException("PeriodType does not support fields: " + cached); [EOL]     } [EOL]     PeriodType type = standard(); [EOL]     List<DurationFieldType> list = new ArrayList<DurationFieldType>(Arrays.asList(types)); [EOL]     if (list.remove(DurationFieldType.years()) == false) { [EOL]         type = type.withYearsRemoved(); [EOL]     } [EOL]     if (list.remove(DurationFieldType.months()) == false) { [EOL]         type = type.withMonthsRemoved(); [EOL]     } [EOL]     if (list.remove(DurationFieldType.weeks()) == false) { [EOL]         type = type.withWeeksRemoved(); [EOL]     } [EOL]     if (list.remove(DurationFieldType.days()) == false) { [EOL]         type = type.withDaysRemoved(); [EOL]     } [EOL]     if (list.remove(DurationFieldType.hours()) == false) { [EOL]         type = type.withHoursRemoved(); [EOL]     } [EOL]     if (list.remove(DurationFieldType.minutes()) == false) { [EOL]         type = type.withMinutesRemoved(); [EOL]     } [EOL]     if (list.remove(DurationFieldType.seconds()) == false) { [EOL]         type = type.withSecondsRemoved(); [EOL]     } [EOL]     if (list.remove(DurationFieldType.millis()) == false) { [EOL]         type = type.withMillisRemoved(); [EOL]     } [EOL]     if (list.size() > 0) { [EOL]         cache.put(inPartType, list); [EOL]         throw new IllegalArgumentException("PeriodType does not support fields: " + list); [EOL]     } [EOL]     PeriodType checkPartType = new PeriodType(null, type.iTypes, null); [EOL]     PeriodType checkedType = (PeriodType) cache.get(checkPartType); [EOL]     if (checkedType != null) { [EOL]         cache.put(checkPartType, checkedType); [EOL]         return checkedType; [EOL]     } [EOL]     cache.put(checkPartType, type); [EOL]     return type; [EOL] }
public static synchronized PeriodType forFields(DurationFieldType[] types) { [EOL]     if (types == null || types.length == 0) { [EOL]         throw new IllegalArgumentException("Types array must not be null or empty"); [EOL]     } [EOL]     for (int i = 0; i < types.length; i++) { [EOL]         if (types[i] == null) { [EOL]             throw new IllegalArgumentException("Types array must not contain null"); [EOL]         } [EOL]     } [EOL]     Map<PeriodType, Object> cache = cTypes; [EOL]     if (cache.isEmpty()) { [EOL]         cache.put(standard(), standard()); [EOL]         cache.put(yearMonthDayTime(), yearMonthDayTime()); [EOL]         cache.put(yearMonthDay(), yearMonthDay()); [EOL]         cache.put(yearWeekDayTime(), yearWeekDayTime()); [EOL]         cache.put(yearWeekDay(), yearWeekDay()); [EOL]         cache.put(yearDayTime(), yearDayTime()); [EOL]         cache.put(yearDay(), yearDay()); [EOL]         cache.put(dayTime(), dayTime()); [EOL]         cache.put(time(), time()); [EOL]         cache.put(years(), years()); [EOL]         cache.put(months(), months()); [EOL]         cache.put(weeks(), weeks()); [EOL]         cache.put(days(), days()); [EOL]         cache.put(hours(), hours()); [EOL]         cache.put(minutes(), minutes()); [EOL]         cache.put(seconds(), seconds()); [EOL]         cache.put(millis(), millis()); [EOL]     } [EOL]     PeriodType inPartType = new PeriodType(null, types, null); [EOL]     Object cached = cache.get(inPartType); [EOL]     if (cached instanceof PeriodType) { [EOL]         return (PeriodType) cached; [EOL]     } [EOL]     if (cached != null) { [EOL]         throw new IllegalArgumentException("PeriodType does not support fields: " + cached); [EOL]     } [EOL]     PeriodType type = standard(); [EOL]     List<DurationFieldType> list = new ArrayList<DurationFieldType>(Arrays.asList(types)); [EOL]     if (list.remove(DurationFieldType.years()) == false) { [EOL]         type = type.withYearsRemoved(); [EOL]     } [EOL]     if (list.remove(DurationFieldType.months()) == false) { [EOL]         type = type.withMonthsRemoved(); [EOL]     } [EOL]     if (list.remove(DurationFieldType.weeks()) == false) { [EOL]         type = type.withWeeksRemoved(); [EOL]     } [EOL]     if (list.remove(DurationFieldType.days()) == false) { [EOL]         type = type.withDaysRemoved(); [EOL]     } [EOL]     if (list.remove(DurationFieldType.hours()) == false) { [EOL]         type = type.withHoursRemoved(); [EOL]     } [EOL]     if (list.remove(DurationFieldType.minutes()) == false) { [EOL]         type = type.withMinutesRemoved(); [EOL]     } [EOL]     if (list.remove(DurationFieldType.seconds()) == false) { [EOL]         type = type.withSecondsRemoved(); [EOL]     } [EOL]     if (list.remove(DurationFieldType.millis()) == false) { [EOL]         type = type.withMillisRemoved(); [EOL]     } [EOL]     if (list.size() > 0) { [EOL]         cache.put(inPartType, list); [EOL]         throw new IllegalArgumentException("PeriodType does not support fields: " + list); [EOL]     } [EOL]     PeriodType checkPartType = new PeriodType(null, type.iTypes, null); [EOL]     PeriodType checkedType = (PeriodType) cache.get(checkPartType); [EOL]     if (checkedType != null) { [EOL]         cache.put(checkPartType, checkedType); [EOL]         return checkedType; [EOL]     } [EOL]     cache.put(checkPartType, type); [EOL]     return type; [EOL] }
public static synchronized PeriodType forFields(DurationFieldType[] types) { [EOL]     if (types == null || types.length == 0) { [EOL]         throw new IllegalArgumentException("Types array must not be null or empty"); [EOL]     } [EOL]     for (int i = 0; i < types.length; i++) { [EOL]         if (types[i] == null) { [EOL]             throw new IllegalArgumentException("Types array must not contain null"); [EOL]         } [EOL]     } [EOL]     Map<PeriodType, Object> cache = cTypes; [EOL]     if (cache.isEmpty()) { [EOL]         cache.put(standard(), standard()); [EOL]         cache.put(yearMonthDayTime(), yearMonthDayTime()); [EOL]         cache.put(yearMonthDay(), yearMonthDay()); [EOL]         cache.put(yearWeekDayTime(), yearWeekDayTime()); [EOL]         cache.put(yearWeekDay(), yearWeekDay()); [EOL]         cache.put(yearDayTime(), yearDayTime()); [EOL]         cache.put(yearDay(), yearDay()); [EOL]         cache.put(dayTime(), dayTime()); [EOL]         cache.put(time(), time()); [EOL]         cache.put(years(), years()); [EOL]         cache.put(months(), months()); [EOL]         cache.put(weeks(), weeks()); [EOL]         cache.put(days(), days()); [EOL]         cache.put(hours(), hours()); [EOL]         cache.put(minutes(), minutes()); [EOL]         cache.put(seconds(), seconds()); [EOL]         cache.put(millis(), millis()); [EOL]     } [EOL]     PeriodType inPartType = new PeriodType(null, types, null); [EOL]     Object cached = cache.get(inPartType); [EOL]     if (cached instanceof PeriodType) { [EOL]         return (PeriodType) cached; [EOL]     } [EOL]     if (cached != null) { [EOL]         throw new IllegalArgumentException("PeriodType does not support fields: " + cached); [EOL]     } [EOL]     PeriodType type = standard(); [EOL]     List<DurationFieldType> list = new ArrayList<DurationFieldType>(Arrays.asList(types)); [EOL]     if (list.remove(DurationFieldType.years()) == false) { [EOL]         type = type.withYearsRemoved(); [EOL]     } [EOL]     if (list.remove(DurationFieldType.months()) == false) { [EOL]         type = type.withMonthsRemoved(); [EOL]     } [EOL]     if (list.remove(DurationFieldType.weeks()) == false) { [EOL]         type = type.withWeeksRemoved(); [EOL]     } [EOL]     if (list.remove(DurationFieldType.days()) == false) { [EOL]         type = type.withDaysRemoved(); [EOL]     } [EOL]     if (list.remove(DurationFieldType.hours()) == false) { [EOL]         type = type.withHoursRemoved(); [EOL]     } [EOL]     if (list.remove(DurationFieldType.minutes()) == false) { [EOL]         type = type.withMinutesRemoved(); [EOL]     } [EOL]     if (list.remove(DurationFieldType.seconds()) == false) { [EOL]         type = type.withSecondsRemoved(); [EOL]     } [EOL]     if (list.remove(DurationFieldType.millis()) == false) { [EOL]         type = type.withMillisRemoved(); [EOL]     } [EOL]     if (list.size() > 0) { [EOL]         cache.put(inPartType, list); [EOL]         throw new IllegalArgumentException("PeriodType does not support fields: " + list); [EOL]     } [EOL]     PeriodType checkPartType = new PeriodType(null, type.iTypes, null); [EOL]     PeriodType checkedType = (PeriodType) cache.get(checkPartType); [EOL]     if (checkedType != null) { [EOL]         cache.put(checkPartType, checkedType); [EOL]         return checkedType; [EOL]     } [EOL]     cache.put(checkPartType, type); [EOL]     return type; [EOL] }
public static synchronized PeriodType forFields(DurationFieldType[] types) { [EOL]     if (types == null || types.length == 0) { [EOL]         throw new IllegalArgumentException("Types array must not be null or empty"); [EOL]     } [EOL]     for (int i = 0; i < types.length; i++) { [EOL]         if (types[i] == null) { [EOL]             throw new IllegalArgumentException("Types array must not contain null"); [EOL]         } [EOL]     } [EOL]     Map<PeriodType, Object> cache = cTypes; [EOL]     if (cache.isEmpty()) { [EOL]         cache.put(standard(), standard()); [EOL]         cache.put(yearMonthDayTime(), yearMonthDayTime()); [EOL]         cache.put(yearMonthDay(), yearMonthDay()); [EOL]         cache.put(yearWeekDayTime(), yearWeekDayTime()); [EOL]         cache.put(yearWeekDay(), yearWeekDay()); [EOL]         cache.put(yearDayTime(), yearDayTime()); [EOL]         cache.put(yearDay(), yearDay()); [EOL]         cache.put(dayTime(), dayTime()); [EOL]         cache.put(time(), time()); [EOL]         cache.put(years(), years()); [EOL]         cache.put(months(), months()); [EOL]         cache.put(weeks(), weeks()); [EOL]         cache.put(days(), days()); [EOL]         cache.put(hours(), hours()); [EOL]         cache.put(minutes(), minutes()); [EOL]         cache.put(seconds(), seconds()); [EOL]         cache.put(millis(), millis()); [EOL]     } [EOL]     PeriodType inPartType = new PeriodType(null, types, null); [EOL]     Object cached = cache.get(inPartType); [EOL]     if (cached instanceof PeriodType) { [EOL]         return (PeriodType) cached; [EOL]     } [EOL]     if (cached != null) { [EOL]         throw new IllegalArgumentException("PeriodType does not support fields: " + cached); [EOL]     } [EOL]     PeriodType type = standard(); [EOL]     List<DurationFieldType> list = new ArrayList<DurationFieldType>(Arrays.asList(types)); [EOL]     if (list.remove(DurationFieldType.years()) == false) { [EOL]         type = type.withYearsRemoved(); [EOL]     } [EOL]     if (list.remove(DurationFieldType.months()) == false) { [EOL]         type = type.withMonthsRemoved(); [EOL]     } [EOL]     if (list.remove(DurationFieldType.weeks()) == false) { [EOL]         type = type.withWeeksRemoved(); [EOL]     } [EOL]     if (list.remove(DurationFieldType.days()) == false) { [EOL]         type = type.withDaysRemoved(); [EOL]     } [EOL]     if (list.remove(DurationFieldType.hours()) == false) { [EOL]         type = type.withHoursRemoved(); [EOL]     } [EOL]     if (list.remove(DurationFieldType.minutes()) == false) { [EOL]         type = type.withMinutesRemoved(); [EOL]     } [EOL]     if (list.remove(DurationFieldType.seconds()) == false) { [EOL]         type = type.withSecondsRemoved(); [EOL]     } [EOL]     if (list.remove(DurationFieldType.millis()) == false) { [EOL]         type = type.withMillisRemoved(); [EOL]     } [EOL]     if (list.size() > 0) { [EOL]         cache.put(inPartType, list); [EOL]         throw new IllegalArgumentException("PeriodType does not support fields: " + list); [EOL]     } [EOL]     PeriodType checkPartType = new PeriodType(null, type.iTypes, null); [EOL]     PeriodType checkedType = (PeriodType) cache.get(checkPartType); [EOL]     if (checkedType != null) { [EOL]         cache.put(checkPartType, checkedType); [EOL]         return checkedType; [EOL]     } [EOL]     cache.put(checkPartType, type); [EOL]     return type; [EOL] }
public static synchronized PeriodType forFields(DurationFieldType[] types) { [EOL]     if (types == null || types.length == 0) { [EOL]         throw new IllegalArgumentException("Types array must not be null or empty"); [EOL]     } [EOL]     for (int i = 0; i < types.length; i++) { [EOL]         if (types[i] == null) { [EOL]             throw new IllegalArgumentException("Types array must not contain null"); [EOL]         } [EOL]     } [EOL]     Map<PeriodType, Object> cache = cTypes; [EOL]     if (cache.isEmpty()) { [EOL]         cache.put(standard(), standard()); [EOL]         cache.put(yearMonthDayTime(), yearMonthDayTime()); [EOL]         cache.put(yearMonthDay(), yearMonthDay()); [EOL]         cache.put(yearWeekDayTime(), yearWeekDayTime()); [EOL]         cache.put(yearWeekDay(), yearWeekDay()); [EOL]         cache.put(yearDayTime(), yearDayTime()); [EOL]         cache.put(yearDay(), yearDay()); [EOL]         cache.put(dayTime(), dayTime()); [EOL]         cache.put(time(), time()); [EOL]         cache.put(years(), years()); [EOL]         cache.put(months(), months()); [EOL]         cache.put(weeks(), weeks()); [EOL]         cache.put(days(), days()); [EOL]         cache.put(hours(), hours()); [EOL]         cache.put(minutes(), minutes()); [EOL]         cache.put(seconds(), seconds()); [EOL]         cache.put(millis(), millis()); [EOL]     } [EOL]     PeriodType inPartType = new PeriodType(null, types, null); [EOL]     Object cached = cache.get(inPartType); [EOL]     if (cached instanceof PeriodType) { [EOL]         return (PeriodType) cached; [EOL]     } [EOL]     if (cached != null) { [EOL]         throw new IllegalArgumentException("PeriodType does not support fields: " + cached); [EOL]     } [EOL]     PeriodType type = standard(); [EOL]     List<DurationFieldType> list = new ArrayList<DurationFieldType>(Arrays.asList(types)); [EOL]     if (list.remove(DurationFieldType.years()) == false) { [EOL]         type = type.withYearsRemoved(); [EOL]     } [EOL]     if (list.remove(DurationFieldType.months()) == false) { [EOL]         type = type.withMonthsRemoved(); [EOL]     } [EOL]     if (list.remove(DurationFieldType.weeks()) == false) { [EOL]         type = type.withWeeksRemoved(); [EOL]     } [EOL]     if (list.remove(DurationFieldType.days()) == false) { [EOL]         type = type.withDaysRemoved(); [EOL]     } [EOL]     if (list.remove(DurationFieldType.hours()) == false) { [EOL]         type = type.withHoursRemoved(); [EOL]     } [EOL]     if (list.remove(DurationFieldType.minutes()) == false) { [EOL]         type = type.withMinutesRemoved(); [EOL]     } [EOL]     if (list.remove(DurationFieldType.seconds()) == false) { [EOL]         type = type.withSecondsRemoved(); [EOL]     } [EOL]     if (list.remove(DurationFieldType.millis()) == false) { [EOL]         type = type.withMillisRemoved(); [EOL]     } [EOL]     if (list.size() > 0) { [EOL]         cache.put(inPartType, list); [EOL]         throw new IllegalArgumentException("PeriodType does not support fields: " + list); [EOL]     } [EOL]     PeriodType checkPartType = new PeriodType(null, type.iTypes, null); [EOL]     PeriodType checkedType = (PeriodType) cache.get(checkPartType); [EOL]     if (checkedType != null) { [EOL]         cache.put(checkPartType, checkedType); [EOL]         return checkedType; [EOL]     } [EOL]     cache.put(checkPartType, type); [EOL]     return type; [EOL] }
public static synchronized PeriodType forFields(DurationFieldType[] types) { [EOL]     if (types == null || types.length == 0) { [EOL]         throw new IllegalArgumentException("Types array must not be null or empty"); [EOL]     } [EOL]     for (int i = 0; i < types.length; i++) { [EOL]         if (types[i] == null) { [EOL]             throw new IllegalArgumentException("Types array must not contain null"); [EOL]         } [EOL]     } [EOL]     Map<PeriodType, Object> cache = cTypes; [EOL]     if (cache.isEmpty()) { [EOL]         cache.put(standard(), standard()); [EOL]         cache.put(yearMonthDayTime(), yearMonthDayTime()); [EOL]         cache.put(yearMonthDay(), yearMonthDay()); [EOL]         cache.put(yearWeekDayTime(), yearWeekDayTime()); [EOL]         cache.put(yearWeekDay(), yearWeekDay()); [EOL]         cache.put(yearDayTime(), yearDayTime()); [EOL]         cache.put(yearDay(), yearDay()); [EOL]         cache.put(dayTime(), dayTime()); [EOL]         cache.put(time(), time()); [EOL]         cache.put(years(), years()); [EOL]         cache.put(months(), months()); [EOL]         cache.put(weeks(), weeks()); [EOL]         cache.put(days(), days()); [EOL]         cache.put(hours(), hours()); [EOL]         cache.put(minutes(), minutes()); [EOL]         cache.put(seconds(), seconds()); [EOL]         cache.put(millis(), millis()); [EOL]     } [EOL]     PeriodType inPartType = new PeriodType(null, types, null); [EOL]     Object cached = cache.get(inPartType); [EOL]     if (cached instanceof PeriodType) { [EOL]         return (PeriodType) cached; [EOL]     } [EOL]     if (cached != null) { [EOL]         throw new IllegalArgumentException("PeriodType does not support fields: " + cached); [EOL]     } [EOL]     PeriodType type = standard(); [EOL]     List<DurationFieldType> list = new ArrayList<DurationFieldType>(Arrays.asList(types)); [EOL]     if (list.remove(DurationFieldType.years()) == false) { [EOL]         type = type.withYearsRemoved(); [EOL]     } [EOL]     if (list.remove(DurationFieldType.months()) == false) { [EOL]         type = type.withMonthsRemoved(); [EOL]     } [EOL]     if (list.remove(DurationFieldType.weeks()) == false) { [EOL]         type = type.withWeeksRemoved(); [EOL]     } [EOL]     if (list.remove(DurationFieldType.days()) == false) { [EOL]         type = type.withDaysRemoved(); [EOL]     } [EOL]     if (list.remove(DurationFieldType.hours()) == false) { [EOL]         type = type.withHoursRemoved(); [EOL]     } [EOL]     if (list.remove(DurationFieldType.minutes()) == false) { [EOL]         type = type.withMinutesRemoved(); [EOL]     } [EOL]     if (list.remove(DurationFieldType.seconds()) == false) { [EOL]         type = type.withSecondsRemoved(); [EOL]     } [EOL]     if (list.remove(DurationFieldType.millis()) == false) { [EOL]         type = type.withMillisRemoved(); [EOL]     } [EOL]     if (list.size() > 0) { [EOL]         cache.put(inPartType, list); [EOL]         throw new IllegalArgumentException("PeriodType does not support fields: " + list); [EOL]     } [EOL]     PeriodType checkPartType = new PeriodType(null, type.iTypes, null); [EOL]     PeriodType checkedType = (PeriodType) cache.get(checkPartType); [EOL]     if (checkedType != null) { [EOL]         cache.put(checkPartType, checkedType); [EOL]         return checkedType; [EOL]     } [EOL]     cache.put(checkPartType, type); [EOL]     return type; [EOL] }
protected PeriodType(String name, DurationFieldType[] types, int[] indices) { [EOL]     super(); [EOL]     iName = name; [EOL]     iTypes = types; [EOL]     iIndices = indices; [EOL] }
public String getName() { [EOL]     return iName; [EOL] }
public DurationFieldType getFieldType(int index) { [EOL]     return iTypes[index]; [EOL] }
public DurationFieldType getFieldType(int index) { [EOL]     return iTypes[index]; [EOL] }
public String toString() { [EOL]     return "PeriodType[" + getName() + "]"; [EOL] }
int getIndexedField(ReadablePeriod period, int index) { [EOL]     int realIndex = iIndices[index]; [EOL]     return (realIndex == -1 ? 0 : period.getValue(realIndex)); [EOL] }
int getIndexedField(ReadablePeriod period, int index) { [EOL]     int realIndex = iIndices[index]; [EOL]     return (realIndex == -1 ? 0 : period.getValue(realIndex)); [EOL] }
int getIndexedField(ReadablePeriod period, int index) { [EOL]     int realIndex = iIndices[index]; [EOL]     return (realIndex == -1 ? 0 : period.getValue(realIndex)); [EOL] }
boolean setIndexedField(ReadablePeriod period, int index, int[] values, int newValue) { [EOL]     int realIndex = iIndices[index]; [EOL]     if (realIndex == -1) { [EOL]         throw new UnsupportedOperationException("Field is not supported"); [EOL]     } [EOL]     values[realIndex] = newValue; [EOL]     return true; [EOL] }
public PeriodType withMonthsRemoved() { [EOL]     return withFieldRemoved(1, "NoMonths"); [EOL] }
public PeriodType withWeeksRemoved() { [EOL]     return withFieldRemoved(2, "NoWeeks"); [EOL] }
public PeriodType withDaysRemoved() { [EOL]     return withFieldRemoved(3, "NoDays"); [EOL] }
public PeriodType withHoursRemoved() { [EOL]     return withFieldRemoved(4, "NoHours"); [EOL] }
public PeriodType withHoursRemoved() { [EOL]     return withFieldRemoved(4, "NoHours"); [EOL] }
public PeriodType withSecondsRemoved() { [EOL]     return withFieldRemoved(6, "NoSeconds"); [EOL] }
private PeriodType withFieldRemoved(int indicesIndex, String name) { [EOL]     int fieldIndex = iIndices[indicesIndex]; [EOL]     if (fieldIndex == -1) { [EOL]         return this; [EOL]     } [EOL]     DurationFieldType[] types = new DurationFieldType[size() - 1]; [EOL]     for (int i = 0; i < iTypes.length; i++) { [EOL]         if (i < fieldIndex) { [EOL]             types[i] = iTypes[i]; [EOL]         } else if (i > fieldIndex) { [EOL]             types[i - 1] = iTypes[i]; [EOL]         } [EOL]     } [EOL]     int[] indices = new int[8]; [EOL]     for (int i = 0; i < indices.length; i++) { [EOL]         if (i < indicesIndex) { [EOL]             indices[i] = iIndices[i]; [EOL]         } else if (i > indicesIndex) { [EOL]             indices[i] = (iIndices[i] == -1 ? -1 : iIndices[i] - 1); [EOL]         } else { [EOL]             indices[i] = -1; [EOL]         } [EOL]     } [EOL]     return new PeriodType(getName() + name, types, indices); [EOL] }
private PeriodType withFieldRemoved(int indicesIndex, String name) { [EOL]     int fieldIndex = iIndices[indicesIndex]; [EOL]     if (fieldIndex == -1) { [EOL]         return this; [EOL]     } [EOL]     DurationFieldType[] types = new DurationFieldType[size() - 1]; [EOL]     for (int i = 0; i < iTypes.length; i++) { [EOL]         if (i < fieldIndex) { [EOL]             types[i] = iTypes[i]; [EOL]         } else if (i > fieldIndex) { [EOL]             types[i - 1] = iTypes[i]; [EOL]         } [EOL]     } [EOL]     int[] indices = new int[8]; [EOL]     for (int i = 0; i < indices.length; i++) { [EOL]         if (i < indicesIndex) { [EOL]             indices[i] = iIndices[i]; [EOL]         } else if (i > indicesIndex) { [EOL]             indices[i] = (iIndices[i] == -1 ? -1 : iIndices[i] - 1); [EOL]         } else { [EOL]             indices[i] = -1; [EOL]         } [EOL]     } [EOL]     return new PeriodType(getName() + name, types, indices); [EOL] }
private PeriodType withFieldRemoved(int indicesIndex, String name) { [EOL]     int fieldIndex = iIndices[indicesIndex]; [EOL]     if (fieldIndex == -1) { [EOL]         return this; [EOL]     } [EOL]     DurationFieldType[] types = new DurationFieldType[size() - 1]; [EOL]     for (int i = 0; i < iTypes.length; i++) { [EOL]         if (i < fieldIndex) { [EOL]             types[i] = iTypes[i]; [EOL]         } else if (i > fieldIndex) { [EOL]             types[i - 1] = iTypes[i]; [EOL]         } [EOL]     } [EOL]     int[] indices = new int[8]; [EOL]     for (int i = 0; i < indices.length; i++) { [EOL]         if (i < indicesIndex) { [EOL]             indices[i] = iIndices[i]; [EOL]         } else if (i > indicesIndex) { [EOL]             indices[i] = (iIndices[i] == -1 ? -1 : iIndices[i] - 1); [EOL]         } else { [EOL]             indices[i] = -1; [EOL]         } [EOL]     } [EOL]     return new PeriodType(getName() + name, types, indices); [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof PeriodType == false) { [EOL]         return false; [EOL]     } [EOL]     PeriodType other = (PeriodType) obj; [EOL]     return (Arrays.equals(iTypes, other.iTypes)); [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof PeriodType == false) { [EOL]         return false; [EOL]     } [EOL]     PeriodType other = (PeriodType) obj; [EOL]     return (Arrays.equals(iTypes, other.iTypes)); [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof PeriodType == false) { [EOL]         return false; [EOL]     } [EOL]     PeriodType other = (PeriodType) obj; [EOL]     return (Arrays.equals(iTypes, other.iTypes)); [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof PeriodType == false) { [EOL]         return false; [EOL]     } [EOL]     PeriodType other = (PeriodType) obj; [EOL]     return (Arrays.equals(iTypes, other.iTypes)); [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof PeriodType == false) { [EOL]         return false; [EOL]     } [EOL]     PeriodType other = (PeriodType) obj; [EOL]     return (Arrays.equals(iTypes, other.iTypes)); [EOL] }
public int hashCode() { [EOL]     int hash = 0; [EOL]     for (int i = 0; i < iTypes.length; i++) { [EOL]         hash += iTypes[i].hashCode(); [EOL]     } [EOL]     return hash; [EOL] }
public int hashCode() { [EOL]     int hash = 0; [EOL]     for (int i = 0; i < iTypes.length; i++) { [EOL]         hash += iTypes[i].hashCode(); [EOL]     } [EOL]     return hash; [EOL] }
public int hashCode() { [EOL]     int hash = 0; [EOL]     for (int i = 0; i < iTypes.length; i++) { [EOL]         hash += iTypes[i].hashCode(); [EOL]     } [EOL]     return hash; [EOL] }
public static final Chronology getInstantChronology(ReadableInstant instant) { [EOL]     if (instant == null) { [EOL]         return ISOChronology.getInstance(); [EOL]     } [EOL]     Chronology chrono = instant.getChronology(); [EOL]     if (chrono == null) { [EOL]         return ISOChronology.getInstance(); [EOL]     } [EOL]     return chrono; [EOL] }
public static final Chronology getInstantChronology(ReadableInstant instant) { [EOL]     if (instant == null) { [EOL]         return ISOChronology.getInstance(); [EOL]     } [EOL]     Chronology chrono = instant.getChronology(); [EOL]     if (chrono == null) { [EOL]         return ISOChronology.getInstance(); [EOL]     } [EOL]     return chrono; [EOL] }
public static final Chronology getInstantChronology(ReadableInstant instant) { [EOL]     if (instant == null) { [EOL]         return ISOChronology.getInstance(); [EOL]     } [EOL]     Chronology chrono = instant.getChronology(); [EOL]     if (chrono == null) { [EOL]         return ISOChronology.getInstance(); [EOL]     } [EOL]     return chrono; [EOL] }
public static final Chronology getChronology(Chronology chrono) { [EOL]     if (chrono == null) { [EOL]         return ISOChronology.getInstance(); [EOL]     } [EOL]     return chrono; [EOL] }
public static final Chronology getChronology(Chronology chrono) { [EOL]     if (chrono == null) { [EOL]         return ISOChronology.getInstance(); [EOL]     } [EOL]     return chrono; [EOL] }
public static final PeriodType getPeriodType(PeriodType type) { [EOL]     if (type == null) { [EOL]         return PeriodType.standard(); [EOL]     } [EOL]     return type; [EOL] }
public static final long getDurationMillis(ReadableDuration duration) { [EOL]     if (duration == null) { [EOL]         return 0L; [EOL]     } [EOL]     return duration.getMillis(); [EOL] }
public static final long getDurationMillis(ReadableDuration duration) { [EOL]     if (duration == null) { [EOL]         return 0L; [EOL]     } [EOL]     return duration.getMillis(); [EOL] }
public static final boolean isContiguous(ReadablePartial partial) { [EOL]     if (partial == null) { [EOL]         throw new IllegalArgumentException("Partial must not be null"); [EOL]     } [EOL]     DurationFieldType lastType = null; [EOL]     for (int i = 0; i < partial.size(); i++) { [EOL]         DateTimeField loopField = partial.getField(i); [EOL]         if (i > 0) { [EOL]             if (loopField.getRangeDurationField() == null || loopField.getRangeDurationField().getType() != lastType) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]         lastType = loopField.getDurationField().getType(); [EOL]     } [EOL]     return true; [EOL] }
public static final boolean isContiguous(ReadablePartial partial) { [EOL]     if (partial == null) { [EOL]         throw new IllegalArgumentException("Partial must not be null"); [EOL]     } [EOL]     DurationFieldType lastType = null; [EOL]     for (int i = 0; i < partial.size(); i++) { [EOL]         DateTimeField loopField = partial.getField(i); [EOL]         if (i > 0) { [EOL]             if (loopField.getRangeDurationField() == null || loopField.getRangeDurationField().getType() != lastType) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]         lastType = loopField.getDurationField().getType(); [EOL]     } [EOL]     return true; [EOL] }
public static final boolean isContiguous(ReadablePartial partial) { [EOL]     if (partial == null) { [EOL]         throw new IllegalArgumentException("Partial must not be null"); [EOL]     } [EOL]     DurationFieldType lastType = null; [EOL]     for (int i = 0; i < partial.size(); i++) { [EOL]         DateTimeField loopField = partial.getField(i); [EOL]         if (i > 0) { [EOL]             if (loopField.getRangeDurationField() == null || loopField.getRangeDurationField().getType() != lastType) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]         lastType = loopField.getDurationField().getType(); [EOL]     } [EOL]     return true; [EOL] }
public static final boolean isContiguous(ReadablePartial partial) { [EOL]     if (partial == null) { [EOL]         throw new IllegalArgumentException("Partial must not be null"); [EOL]     } [EOL]     DurationFieldType lastType = null; [EOL]     for (int i = 0; i < partial.size(); i++) { [EOL]         DateTimeField loopField = partial.getField(i); [EOL]         if (i > 0) { [EOL]             if (loopField.getRangeDurationField() == null || loopField.getRangeDurationField().getType() != lastType) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]         lastType = loopField.getDurationField().getType(); [EOL]     } [EOL]     return true; [EOL] }
public static final DateFormatSymbols getDateFormatSymbols(Locale locale) { [EOL]     try { [EOL]         Method method = DateFormatSymbols.class.getMethod("getInstance", new Class[] { Locale.class }); [EOL]         return (DateFormatSymbols) method.invoke(null, new Object[] { locale }); [EOL]     } catch (Exception ex) { [EOL]         return new DateFormatSymbols(locale); [EOL]     } [EOL] }
public static final DateFormatSymbols getDateFormatSymbols(Locale locale) { [EOL]     try { [EOL]         Method method = DateFormatSymbols.class.getMethod("getInstance", new Class[] { Locale.class }); [EOL]         return (DateFormatSymbols) method.invoke(null, new Object[] { locale }); [EOL]     } catch (Exception ex) { [EOL]         return new DateFormatSymbols(locale); [EOL]     } [EOL] }
protected BaseInterval(ReadablePeriod period, ReadableInstant end) { [EOL]     super(); [EOL]     Chronology chrono = DateTimeUtils.getInstantChronology(end); [EOL]     iChronology = chrono; [EOL]     iEndMillis = DateTimeUtils.getInstantMillis(end); [EOL]     if (period == null) { [EOL]         iStartMillis = iEndMillis; [EOL]     } else { [EOL]         iStartMillis = chrono.add(period, iEndMillis, -1); [EOL]     } [EOL]     checkInterval(iStartMillis, iEndMillis); [EOL] }
protected BaseInterval(ReadablePeriod period, ReadableInstant end) { [EOL]     super(); [EOL]     Chronology chrono = DateTimeUtils.getInstantChronology(end); [EOL]     iChronology = chrono; [EOL]     iEndMillis = DateTimeUtils.getInstantMillis(end); [EOL]     if (period == null) { [EOL]         iStartMillis = iEndMillis; [EOL]     } else { [EOL]         iStartMillis = chrono.add(period, iEndMillis, -1); [EOL]     } [EOL]     checkInterval(iStartMillis, iEndMillis); [EOL] }
public long getStartMillis() { [EOL]     return iStartMillis; [EOL] }
public long getEndMillis() { [EOL]     return iEndMillis; [EOL] }
public static void setDefault(DateTimeZone zone) throws SecurityException { [EOL]     SecurityManager sm = System.getSecurityManager(); [EOL]     if (sm != null) { [EOL]         sm.checkPermission(new JodaTimePermission("DateTimeZone.setDefault")); [EOL]     } [EOL]     if (zone == null) { [EOL]         throw new IllegalArgumentException("The datetime zone must not be null"); [EOL]     } [EOL]     synchronized (DateTimeZone.class) { [EOL]         cDefault = zone; [EOL]     } [EOL] }
public static void setDefault(DateTimeZone zone) throws SecurityException { [EOL]     SecurityManager sm = System.getSecurityManager(); [EOL]     if (sm != null) { [EOL]         sm.checkPermission(new JodaTimePermission("DateTimeZone.setDefault")); [EOL]     } [EOL]     if (zone == null) { [EOL]         throw new IllegalArgumentException("The datetime zone must not be null"); [EOL]     } [EOL]     synchronized (DateTimeZone.class) { [EOL]         cDefault = zone; [EOL]     } [EOL] }
public static void setDefault(DateTimeZone zone) throws SecurityException { [EOL]     SecurityManager sm = System.getSecurityManager(); [EOL]     if (sm != null) { [EOL]         sm.checkPermission(new JodaTimePermission("DateTimeZone.setDefault")); [EOL]     } [EOL]     if (zone == null) { [EOL]         throw new IllegalArgumentException("The datetime zone must not be null"); [EOL]     } [EOL]     synchronized (DateTimeZone.class) { [EOL]         cDefault = zone; [EOL]     } [EOL] }
@FromString [EOL] public static DateTimeZone forID(String id) { [EOL]     if (id == null) { [EOL]         return getDefault(); [EOL]     } [EOL]     if (id.equals("UTC")) { [EOL]         return DateTimeZone.UTC; [EOL]     } [EOL]     DateTimeZone zone = cProvider.getZone(id); [EOL]     if (zone != null) { [EOL]         return zone; [EOL]     } [EOL]     if (id.startsWith("+") || id.startsWith("-")) { [EOL]         int offset = parseOffset(id); [EOL]         if (offset == 0L) { [EOL]             return DateTimeZone.UTC; [EOL]         } else { [EOL]             id = printOffset(offset); [EOL]             return fixedOffsetZone(id, offset); [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("The datetime zone id '" + id + "' is not recognised"); [EOL] }
@FromString [EOL] public static DateTimeZone forID(String id) { [EOL]     if (id == null) { [EOL]         return getDefault(); [EOL]     } [EOL]     if (id.equals("UTC")) { [EOL]         return DateTimeZone.UTC; [EOL]     } [EOL]     DateTimeZone zone = cProvider.getZone(id); [EOL]     if (zone != null) { [EOL]         return zone; [EOL]     } [EOL]     if (id.startsWith("+") || id.startsWith("-")) { [EOL]         int offset = parseOffset(id); [EOL]         if (offset == 0L) { [EOL]             return DateTimeZone.UTC; [EOL]         } else { [EOL]             id = printOffset(offset); [EOL]             return fixedOffsetZone(id, offset); [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("The datetime zone id '" + id + "' is not recognised"); [EOL] }
@FromString [EOL] public static DateTimeZone forID(String id) { [EOL]     if (id == null) { [EOL]         return getDefault(); [EOL]     } [EOL]     if (id.equals("UTC")) { [EOL]         return DateTimeZone.UTC; [EOL]     } [EOL]     DateTimeZone zone = cProvider.getZone(id); [EOL]     if (zone != null) { [EOL]         return zone; [EOL]     } [EOL]     if (id.startsWith("+") || id.startsWith("-")) { [EOL]         int offset = parseOffset(id); [EOL]         if (offset == 0L) { [EOL]             return DateTimeZone.UTC; [EOL]         } else { [EOL]             id = printOffset(offset); [EOL]             return fixedOffsetZone(id, offset); [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("The datetime zone id '" + id + "' is not recognised"); [EOL] }
@FromString [EOL] public static DateTimeZone forID(String id) { [EOL]     if (id == null) { [EOL]         return getDefault(); [EOL]     } [EOL]     if (id.equals("UTC")) { [EOL]         return DateTimeZone.UTC; [EOL]     } [EOL]     DateTimeZone zone = cProvider.getZone(id); [EOL]     if (zone != null) { [EOL]         return zone; [EOL]     } [EOL]     if (id.startsWith("+") || id.startsWith("-")) { [EOL]         int offset = parseOffset(id); [EOL]         if (offset == 0L) { [EOL]             return DateTimeZone.UTC; [EOL]         } else { [EOL]             id = printOffset(offset); [EOL]             return fixedOffsetZone(id, offset); [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("The datetime zone id '" + id + "' is not recognised"); [EOL] }
@FromString [EOL] public static DateTimeZone forID(String id) { [EOL]     if (id == null) { [EOL]         return getDefault(); [EOL]     } [EOL]     if (id.equals("UTC")) { [EOL]         return DateTimeZone.UTC; [EOL]     } [EOL]     DateTimeZone zone = cProvider.getZone(id); [EOL]     if (zone != null) { [EOL]         return zone; [EOL]     } [EOL]     if (id.startsWith("+") || id.startsWith("-")) { [EOL]         int offset = parseOffset(id); [EOL]         if (offset == 0L) { [EOL]             return DateTimeZone.UTC; [EOL]         } else { [EOL]             id = printOffset(offset); [EOL]             return fixedOffsetZone(id, offset); [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("The datetime zone id '" + id + "' is not recognised"); [EOL] }
@FromString [EOL] public static DateTimeZone forID(String id) { [EOL]     if (id == null) { [EOL]         return getDefault(); [EOL]     } [EOL]     if (id.equals("UTC")) { [EOL]         return DateTimeZone.UTC; [EOL]     } [EOL]     DateTimeZone zone = cProvider.getZone(id); [EOL]     if (zone != null) { [EOL]         return zone; [EOL]     } [EOL]     if (id.startsWith("+") || id.startsWith("-")) { [EOL]         int offset = parseOffset(id); [EOL]         if (offset == 0L) { [EOL]             return DateTimeZone.UTC; [EOL]         } else { [EOL]             id = printOffset(offset); [EOL]             return fixedOffsetZone(id, offset); [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("The datetime zone id '" + id + "' is not recognised"); [EOL] }
public static DateTimeZone forOffsetHours(int hoursOffset) throws IllegalArgumentException { [EOL]     return forOffsetHoursMinutes(hoursOffset, 0); [EOL] }
public static DateTimeZone forOffsetHours(int hoursOffset) throws IllegalArgumentException { [EOL]     return forOffsetHoursMinutes(hoursOffset, 0); [EOL] }
public static DateTimeZone forOffsetHours(int hoursOffset) throws IllegalArgumentException { [EOL]     return forOffsetHoursMinutes(hoursOffset, 0); [EOL] }
public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException { [EOL]     if (hoursOffset == 0 && minutesOffset == 0) { [EOL]         return DateTimeZone.UTC; [EOL]     } [EOL]     if (hoursOffset < -23 || hoursOffset > 23) { [EOL]         throw new IllegalArgumentException("Hours out of range: " + hoursOffset); [EOL]     } [EOL]     if (minutesOffset < -59 || minutesOffset > 59) { [EOL]         throw new IllegalArgumentException("Minutes out of range: " + minutesOffset); [EOL]     } [EOL]     if (hoursOffset > 0 && minutesOffset < 0) { [EOL]         throw new IllegalArgumentException("Positive hours must not have negative minutes: " + minutesOffset); [EOL]     } [EOL]     int offset = 0; [EOL]     try { [EOL]         int hoursInMinutes = hoursOffset * 60; [EOL]         if (hoursInMinutes < 0) { [EOL]             minutesOffset = hoursInMinutes - Math.abs(minutesOffset); [EOL]         } else { [EOL]             minutesOffset = hoursInMinutes + minutesOffset; [EOL]         } [EOL]         offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE); [EOL]     } catch (ArithmeticException ex) { [EOL]         throw new IllegalArgumentException("Offset is too large"); [EOL]     } [EOL]     return forOffsetMillis(offset); [EOL] }
public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException { [EOL]     if (hoursOffset == 0 && minutesOffset == 0) { [EOL]         return DateTimeZone.UTC; [EOL]     } [EOL]     if (hoursOffset < -23 || hoursOffset > 23) { [EOL]         throw new IllegalArgumentException("Hours out of range: " + hoursOffset); [EOL]     } [EOL]     if (minutesOffset < -59 || minutesOffset > 59) { [EOL]         throw new IllegalArgumentException("Minutes out of range: " + minutesOffset); [EOL]     } [EOL]     if (hoursOffset > 0 && minutesOffset < 0) { [EOL]         throw new IllegalArgumentException("Positive hours must not have negative minutes: " + minutesOffset); [EOL]     } [EOL]     int offset = 0; [EOL]     try { [EOL]         int hoursInMinutes = hoursOffset * 60; [EOL]         if (hoursInMinutes < 0) { [EOL]             minutesOffset = hoursInMinutes - Math.abs(minutesOffset); [EOL]         } else { [EOL]             minutesOffset = hoursInMinutes + minutesOffset; [EOL]         } [EOL]         offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE); [EOL]     } catch (ArithmeticException ex) { [EOL]         throw new IllegalArgumentException("Offset is too large"); [EOL]     } [EOL]     return forOffsetMillis(offset); [EOL] }
public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException { [EOL]     if (hoursOffset == 0 && minutesOffset == 0) { [EOL]         return DateTimeZone.UTC; [EOL]     } [EOL]     if (hoursOffset < -23 || hoursOffset > 23) { [EOL]         throw new IllegalArgumentException("Hours out of range: " + hoursOffset); [EOL]     } [EOL]     if (minutesOffset < -59 || minutesOffset > 59) { [EOL]         throw new IllegalArgumentException("Minutes out of range: " + minutesOffset); [EOL]     } [EOL]     if (hoursOffset > 0 && minutesOffset < 0) { [EOL]         throw new IllegalArgumentException("Positive hours must not have negative minutes: " + minutesOffset); [EOL]     } [EOL]     int offset = 0; [EOL]     try { [EOL]         int hoursInMinutes = hoursOffset * 60; [EOL]         if (hoursInMinutes < 0) { [EOL]             minutesOffset = hoursInMinutes - Math.abs(minutesOffset); [EOL]         } else { [EOL]             minutesOffset = hoursInMinutes + minutesOffset; [EOL]         } [EOL]         offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE); [EOL]     } catch (ArithmeticException ex) { [EOL]         throw new IllegalArgumentException("Offset is too large"); [EOL]     } [EOL]     return forOffsetMillis(offset); [EOL] }
public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException { [EOL]     if (hoursOffset == 0 && minutesOffset == 0) { [EOL]         return DateTimeZone.UTC; [EOL]     } [EOL]     if (hoursOffset < -23 || hoursOffset > 23) { [EOL]         throw new IllegalArgumentException("Hours out of range: " + hoursOffset); [EOL]     } [EOL]     if (minutesOffset < -59 || minutesOffset > 59) { [EOL]         throw new IllegalArgumentException("Minutes out of range: " + minutesOffset); [EOL]     } [EOL]     if (hoursOffset > 0 && minutesOffset < 0) { [EOL]         throw new IllegalArgumentException("Positive hours must not have negative minutes: " + minutesOffset); [EOL]     } [EOL]     int offset = 0; [EOL]     try { [EOL]         int hoursInMinutes = hoursOffset * 60; [EOL]         if (hoursInMinutes < 0) { [EOL]             minutesOffset = hoursInMinutes - Math.abs(minutesOffset); [EOL]         } else { [EOL]             minutesOffset = hoursInMinutes + minutesOffset; [EOL]         } [EOL]         offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE); [EOL]     } catch (ArithmeticException ex) { [EOL]         throw new IllegalArgumentException("Offset is too large"); [EOL]     } [EOL]     return forOffsetMillis(offset); [EOL] }
public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException { [EOL]     if (hoursOffset == 0 && minutesOffset == 0) { [EOL]         return DateTimeZone.UTC; [EOL]     } [EOL]     if (hoursOffset < -23 || hoursOffset > 23) { [EOL]         throw new IllegalArgumentException("Hours out of range: " + hoursOffset); [EOL]     } [EOL]     if (minutesOffset < -59 || minutesOffset > 59) { [EOL]         throw new IllegalArgumentException("Minutes out of range: " + minutesOffset); [EOL]     } [EOL]     if (hoursOffset > 0 && minutesOffset < 0) { [EOL]         throw new IllegalArgumentException("Positive hours must not have negative minutes: " + minutesOffset); [EOL]     } [EOL]     int offset = 0; [EOL]     try { [EOL]         int hoursInMinutes = hoursOffset * 60; [EOL]         if (hoursInMinutes < 0) { [EOL]             minutesOffset = hoursInMinutes - Math.abs(minutesOffset); [EOL]         } else { [EOL]             minutesOffset = hoursInMinutes + minutesOffset; [EOL]         } [EOL]         offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE); [EOL]     } catch (ArithmeticException ex) { [EOL]         throw new IllegalArgumentException("Offset is too large"); [EOL]     } [EOL]     return forOffsetMillis(offset); [EOL] }
public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException { [EOL]     if (hoursOffset == 0 && minutesOffset == 0) { [EOL]         return DateTimeZone.UTC; [EOL]     } [EOL]     if (hoursOffset < -23 || hoursOffset > 23) { [EOL]         throw new IllegalArgumentException("Hours out of range: " + hoursOffset); [EOL]     } [EOL]     if (minutesOffset < -59 || minutesOffset > 59) { [EOL]         throw new IllegalArgumentException("Minutes out of range: " + minutesOffset); [EOL]     } [EOL]     if (hoursOffset > 0 && minutesOffset < 0) { [EOL]         throw new IllegalArgumentException("Positive hours must not have negative minutes: " + minutesOffset); [EOL]     } [EOL]     int offset = 0; [EOL]     try { [EOL]         int hoursInMinutes = hoursOffset * 60; [EOL]         if (hoursInMinutes < 0) { [EOL]             minutesOffset = hoursInMinutes - Math.abs(minutesOffset); [EOL]         } else { [EOL]             minutesOffset = hoursInMinutes + minutesOffset; [EOL]         } [EOL]         offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE); [EOL]     } catch (ArithmeticException ex) { [EOL]         throw new IllegalArgumentException("Offset is too large"); [EOL]     } [EOL]     return forOffsetMillis(offset); [EOL] }
public static DateTimeZone forTimeZone(TimeZone zone) { [EOL]     if (zone == null) { [EOL]         return getDefault(); [EOL]     } [EOL]     final String id = zone.getID(); [EOL]     if (id.equals("UTC")) { [EOL]         return DateTimeZone.UTC; [EOL]     } [EOL]     DateTimeZone dtz = null; [EOL]     String convId = getConvertedId(id); [EOL]     if (convId != null) { [EOL]         dtz = cProvider.getZone(convId); [EOL]     } [EOL]     if (dtz == null) { [EOL]         dtz = cProvider.getZone(id); [EOL]     } [EOL]     if (dtz != null) { [EOL]         return dtz; [EOL]     } [EOL]     if (convId == null) { [EOL]         convId = zone.getID(); [EOL]         if (convId.startsWith("GMT+") || convId.startsWith("GMT-")) { [EOL]             convId = convId.substring(3); [EOL]             int offset = parseOffset(convId); [EOL]             if (offset == 0L) { [EOL]                 return DateTimeZone.UTC; [EOL]             } else { [EOL]                 convId = printOffset(offset); [EOL]                 return fixedOffsetZone(convId, offset); [EOL]             } [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("The datetime zone id '" + id + "' is not recognised"); [EOL] }
public static DateTimeZone forTimeZone(TimeZone zone) { [EOL]     if (zone == null) { [EOL]         return getDefault(); [EOL]     } [EOL]     final String id = zone.getID(); [EOL]     if (id.equals("UTC")) { [EOL]         return DateTimeZone.UTC; [EOL]     } [EOL]     DateTimeZone dtz = null; [EOL]     String convId = getConvertedId(id); [EOL]     if (convId != null) { [EOL]         dtz = cProvider.getZone(convId); [EOL]     } [EOL]     if (dtz == null) { [EOL]         dtz = cProvider.getZone(id); [EOL]     } [EOL]     if (dtz != null) { [EOL]         return dtz; [EOL]     } [EOL]     if (convId == null) { [EOL]         convId = zone.getID(); [EOL]         if (convId.startsWith("GMT+") || convId.startsWith("GMT-")) { [EOL]             convId = convId.substring(3); [EOL]             int offset = parseOffset(convId); [EOL]             if (offset == 0L) { [EOL]                 return DateTimeZone.UTC; [EOL]             } else { [EOL]                 convId = printOffset(offset); [EOL]                 return fixedOffsetZone(convId, offset); [EOL]             } [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("The datetime zone id '" + id + "' is not recognised"); [EOL] }
public static DateTimeZone forTimeZone(TimeZone zone) { [EOL]     if (zone == null) { [EOL]         return getDefault(); [EOL]     } [EOL]     final String id = zone.getID(); [EOL]     if (id.equals("UTC")) { [EOL]         return DateTimeZone.UTC; [EOL]     } [EOL]     DateTimeZone dtz = null; [EOL]     String convId = getConvertedId(id); [EOL]     if (convId != null) { [EOL]         dtz = cProvider.getZone(convId); [EOL]     } [EOL]     if (dtz == null) { [EOL]         dtz = cProvider.getZone(id); [EOL]     } [EOL]     if (dtz != null) { [EOL]         return dtz; [EOL]     } [EOL]     if (convId == null) { [EOL]         convId = zone.getID(); [EOL]         if (convId.startsWith("GMT+") || convId.startsWith("GMT-")) { [EOL]             convId = convId.substring(3); [EOL]             int offset = parseOffset(convId); [EOL]             if (offset == 0L) { [EOL]                 return DateTimeZone.UTC; [EOL]             } else { [EOL]                 convId = printOffset(offset); [EOL]                 return fixedOffsetZone(convId, offset); [EOL]             } [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("The datetime zone id '" + id + "' is not recognised"); [EOL] }
public static DateTimeZone forTimeZone(TimeZone zone) { [EOL]     if (zone == null) { [EOL]         return getDefault(); [EOL]     } [EOL]     final String id = zone.getID(); [EOL]     if (id.equals("UTC")) { [EOL]         return DateTimeZone.UTC; [EOL]     } [EOL]     DateTimeZone dtz = null; [EOL]     String convId = getConvertedId(id); [EOL]     if (convId != null) { [EOL]         dtz = cProvider.getZone(convId); [EOL]     } [EOL]     if (dtz == null) { [EOL]         dtz = cProvider.getZone(id); [EOL]     } [EOL]     if (dtz != null) { [EOL]         return dtz; [EOL]     } [EOL]     if (convId == null) { [EOL]         convId = zone.getID(); [EOL]         if (convId.startsWith("GMT+") || convId.startsWith("GMT-")) { [EOL]             convId = convId.substring(3); [EOL]             int offset = parseOffset(convId); [EOL]             if (offset == 0L) { [EOL]                 return DateTimeZone.UTC; [EOL]             } else { [EOL]                 convId = printOffset(offset); [EOL]                 return fixedOffsetZone(convId, offset); [EOL]             } [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("The datetime zone id '" + id + "' is not recognised"); [EOL] }
public static DateTimeZone forTimeZone(TimeZone zone) { [EOL]     if (zone == null) { [EOL]         return getDefault(); [EOL]     } [EOL]     final String id = zone.getID(); [EOL]     if (id.equals("UTC")) { [EOL]         return DateTimeZone.UTC; [EOL]     } [EOL]     DateTimeZone dtz = null; [EOL]     String convId = getConvertedId(id); [EOL]     if (convId != null) { [EOL]         dtz = cProvider.getZone(convId); [EOL]     } [EOL]     if (dtz == null) { [EOL]         dtz = cProvider.getZone(id); [EOL]     } [EOL]     if (dtz != null) { [EOL]         return dtz; [EOL]     } [EOL]     if (convId == null) { [EOL]         convId = zone.getID(); [EOL]         if (convId.startsWith("GMT+") || convId.startsWith("GMT-")) { [EOL]             convId = convId.substring(3); [EOL]             int offset = parseOffset(convId); [EOL]             if (offset == 0L) { [EOL]                 return DateTimeZone.UTC; [EOL]             } else { [EOL]                 convId = printOffset(offset); [EOL]                 return fixedOffsetZone(convId, offset); [EOL]             } [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("The datetime zone id '" + id + "' is not recognised"); [EOL] }
public static DateTimeZone forTimeZone(TimeZone zone) { [EOL]     if (zone == null) { [EOL]         return getDefault(); [EOL]     } [EOL]     final String id = zone.getID(); [EOL]     if (id.equals("UTC")) { [EOL]         return DateTimeZone.UTC; [EOL]     } [EOL]     DateTimeZone dtz = null; [EOL]     String convId = getConvertedId(id); [EOL]     if (convId != null) { [EOL]         dtz = cProvider.getZone(convId); [EOL]     } [EOL]     if (dtz == null) { [EOL]         dtz = cProvider.getZone(id); [EOL]     } [EOL]     if (dtz != null) { [EOL]         return dtz; [EOL]     } [EOL]     if (convId == null) { [EOL]         convId = zone.getID(); [EOL]         if (convId.startsWith("GMT+") || convId.startsWith("GMT-")) { [EOL]             convId = convId.substring(3); [EOL]             int offset = parseOffset(convId); [EOL]             if (offset == 0L) { [EOL]                 return DateTimeZone.UTC; [EOL]             } else { [EOL]                 convId = printOffset(offset); [EOL]                 return fixedOffsetZone(convId, offset); [EOL]             } [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("The datetime zone id '" + id + "' is not recognised"); [EOL] }
private static synchronized DateTimeZone fixedOffsetZone(String id, int offset) { [EOL]     if (offset == 0) { [EOL]         return DateTimeZone.UTC; [EOL]     } [EOL]     if (iFixedOffsetCache == null) { [EOL]         iFixedOffsetCache = new HashMap<String, SoftReference<DateTimeZone>>(); [EOL]     } [EOL]     DateTimeZone zone; [EOL]     Reference<DateTimeZone> ref = iFixedOffsetCache.get(id); [EOL]     if (ref != null) { [EOL]         zone = ref.get(); [EOL]         if (zone != null) { [EOL]             return zone; [EOL]         } [EOL]     } [EOL]     zone = new FixedDateTimeZone(id, null, offset, offset); [EOL]     iFixedOffsetCache.put(id, new SoftReference<DateTimeZone>(zone)); [EOL]     return zone; [EOL] }
private static synchronized DateTimeZone fixedOffsetZone(String id, int offset) { [EOL]     if (offset == 0) { [EOL]         return DateTimeZone.UTC; [EOL]     } [EOL]     if (iFixedOffsetCache == null) { [EOL]         iFixedOffsetCache = new HashMap<String, SoftReference<DateTimeZone>>(); [EOL]     } [EOL]     DateTimeZone zone; [EOL]     Reference<DateTimeZone> ref = iFixedOffsetCache.get(id); [EOL]     if (ref != null) { [EOL]         zone = ref.get(); [EOL]         if (zone != null) { [EOL]             return zone; [EOL]         } [EOL]     } [EOL]     zone = new FixedDateTimeZone(id, null, offset, offset); [EOL]     iFixedOffsetCache.put(id, new SoftReference<DateTimeZone>(zone)); [EOL]     return zone; [EOL] }
private static synchronized DateTimeZone fixedOffsetZone(String id, int offset) { [EOL]     if (offset == 0) { [EOL]         return DateTimeZone.UTC; [EOL]     } [EOL]     if (iFixedOffsetCache == null) { [EOL]         iFixedOffsetCache = new HashMap<String, SoftReference<DateTimeZone>>(); [EOL]     } [EOL]     DateTimeZone zone; [EOL]     Reference<DateTimeZone> ref = iFixedOffsetCache.get(id); [EOL]     if (ref != null) { [EOL]         zone = ref.get(); [EOL]         if (zone != null) { [EOL]             return zone; [EOL]         } [EOL]     } [EOL]     zone = new FixedDateTimeZone(id, null, offset, offset); [EOL]     iFixedOffsetCache.put(id, new SoftReference<DateTimeZone>(zone)); [EOL]     return zone; [EOL] }
private static synchronized String getConvertedId(String id) { [EOL]     Map<String, String> map = cZoneIdConversion; [EOL]     if (map == null) { [EOL]         map = new HashMap<String, String>(); [EOL]         map.put("GMT", "UTC"); [EOL]         map.put("WET", "WET"); [EOL]         map.put("CET", "CET"); [EOL]         map.put("MET", "CET"); [EOL]         map.put("ECT", "CET"); [EOL]         map.put("EET", "EET"); [EOL]         map.put("MIT", "Pacific/Apia"); [EOL]         map.put("HST", "Pacific/Honolulu"); [EOL]         map.put("AST", "America/Anchorage"); [EOL]         map.put("PST", "America/Los_Angeles"); [EOL]         map.put("MST", "America/Denver"); [EOL]         map.put("PNT", "America/Phoenix"); [EOL]         map.put("CST", "America/Chicago"); [EOL]         map.put("EST", "America/New_York"); [EOL]         map.put("IET", "America/Indiana/Indianapolis"); [EOL]         map.put("PRT", "America/Puerto_Rico"); [EOL]         map.put("CNT", "America/St_Johns"); [EOL]         map.put("AGT", "America/Argentina/Buenos_Aires"); [EOL]         map.put("BET", "America/Sao_Paulo"); [EOL]         map.put("ART", "Africa/Cairo"); [EOL]         map.put("CAT", "Africa/Harare"); [EOL]         map.put("EAT", "Africa/Addis_Ababa"); [EOL]         map.put("NET", "Asia/Yerevan"); [EOL]         map.put("PLT", "Asia/Karachi"); [EOL]         map.put("IST", "Asia/Kolkata"); [EOL]         map.put("BST", "Asia/Dhaka"); [EOL]         map.put("VST", "Asia/Ho_Chi_Minh"); [EOL]         map.put("CTT", "Asia/Shanghai"); [EOL]         map.put("JST", "Asia/Tokyo"); [EOL]         map.put("ACT", "Australia/Darwin"); [EOL]         map.put("AET", "Australia/Sydney"); [EOL]         map.put("SST", "Pacific/Guadalcanal"); [EOL]         map.put("NST", "Pacific/Auckland"); [EOL]         cZoneIdConversion = map; [EOL]     } [EOL]     return map.get(id); [EOL] }
private static synchronized String getConvertedId(String id) { [EOL]     Map<String, String> map = cZoneIdConversion; [EOL]     if (map == null) { [EOL]         map = new HashMap<String, String>(); [EOL]         map.put("GMT", "UTC"); [EOL]         map.put("WET", "WET"); [EOL]         map.put("CET", "CET"); [EOL]         map.put("MET", "CET"); [EOL]         map.put("ECT", "CET"); [EOL]         map.put("EET", "EET"); [EOL]         map.put("MIT", "Pacific/Apia"); [EOL]         map.put("HST", "Pacific/Honolulu"); [EOL]         map.put("AST", "America/Anchorage"); [EOL]         map.put("PST", "America/Los_Angeles"); [EOL]         map.put("MST", "America/Denver"); [EOL]         map.put("PNT", "America/Phoenix"); [EOL]         map.put("CST", "America/Chicago"); [EOL]         map.put("EST", "America/New_York"); [EOL]         map.put("IET", "America/Indiana/Indianapolis"); [EOL]         map.put("PRT", "America/Puerto_Rico"); [EOL]         map.put("CNT", "America/St_Johns"); [EOL]         map.put("AGT", "America/Argentina/Buenos_Aires"); [EOL]         map.put("BET", "America/Sao_Paulo"); [EOL]         map.put("ART", "Africa/Cairo"); [EOL]         map.put("CAT", "Africa/Harare"); [EOL]         map.put("EAT", "Africa/Addis_Ababa"); [EOL]         map.put("NET", "Asia/Yerevan"); [EOL]         map.put("PLT", "Asia/Karachi"); [EOL]         map.put("IST", "Asia/Kolkata"); [EOL]         map.put("BST", "Asia/Dhaka"); [EOL]         map.put("VST", "Asia/Ho_Chi_Minh"); [EOL]         map.put("CTT", "Asia/Shanghai"); [EOL]         map.put("JST", "Asia/Tokyo"); [EOL]         map.put("ACT", "Australia/Darwin"); [EOL]         map.put("AET", "Australia/Sydney"); [EOL]         map.put("SST", "Pacific/Guadalcanal"); [EOL]         map.put("NST", "Pacific/Auckland"); [EOL]         cZoneIdConversion = map; [EOL]     } [EOL]     return map.get(id); [EOL] }
private static synchronized String getConvertedId(String id) { [EOL]     Map<String, String> map = cZoneIdConversion; [EOL]     if (map == null) { [EOL]         map = new HashMap<String, String>(); [EOL]         map.put("GMT", "UTC"); [EOL]         map.put("WET", "WET"); [EOL]         map.put("CET", "CET"); [EOL]         map.put("MET", "CET"); [EOL]         map.put("ECT", "CET"); [EOL]         map.put("EET", "EET"); [EOL]         map.put("MIT", "Pacific/Apia"); [EOL]         map.put("HST", "Pacific/Honolulu"); [EOL]         map.put("AST", "America/Anchorage"); [EOL]         map.put("PST", "America/Los_Angeles"); [EOL]         map.put("MST", "America/Denver"); [EOL]         map.put("PNT", "America/Phoenix"); [EOL]         map.put("CST", "America/Chicago"); [EOL]         map.put("EST", "America/New_York"); [EOL]         map.put("IET", "America/Indiana/Indianapolis"); [EOL]         map.put("PRT", "America/Puerto_Rico"); [EOL]         map.put("CNT", "America/St_Johns"); [EOL]         map.put("AGT", "America/Argentina/Buenos_Aires"); [EOL]         map.put("BET", "America/Sao_Paulo"); [EOL]         map.put("ART", "Africa/Cairo"); [EOL]         map.put("CAT", "Africa/Harare"); [EOL]         map.put("EAT", "Africa/Addis_Ababa"); [EOL]         map.put("NET", "Asia/Yerevan"); [EOL]         map.put("PLT", "Asia/Karachi"); [EOL]         map.put("IST", "Asia/Kolkata"); [EOL]         map.put("BST", "Asia/Dhaka"); [EOL]         map.put("VST", "Asia/Ho_Chi_Minh"); [EOL]         map.put("CTT", "Asia/Shanghai"); [EOL]         map.put("JST", "Asia/Tokyo"); [EOL]         map.put("ACT", "Australia/Darwin"); [EOL]         map.put("AET", "Australia/Sydney"); [EOL]         map.put("SST", "Pacific/Guadalcanal"); [EOL]         map.put("NST", "Pacific/Auckland"); [EOL]         cZoneIdConversion = map; [EOL]     } [EOL]     return map.get(id); [EOL] }
private static synchronized String getConvertedId(String id) { [EOL]     Map<String, String> map = cZoneIdConversion; [EOL]     if (map == null) { [EOL]         map = new HashMap<String, String>(); [EOL]         map.put("GMT", "UTC"); [EOL]         map.put("WET", "WET"); [EOL]         map.put("CET", "CET"); [EOL]         map.put("MET", "CET"); [EOL]         map.put("ECT", "CET"); [EOL]         map.put("EET", "EET"); [EOL]         map.put("MIT", "Pacific/Apia"); [EOL]         map.put("HST", "Pacific/Honolulu"); [EOL]         map.put("AST", "America/Anchorage"); [EOL]         map.put("PST", "America/Los_Angeles"); [EOL]         map.put("MST", "America/Denver"); [EOL]         map.put("PNT", "America/Phoenix"); [EOL]         map.put("CST", "America/Chicago"); [EOL]         map.put("EST", "America/New_York"); [EOL]         map.put("IET", "America/Indiana/Indianapolis"); [EOL]         map.put("PRT", "America/Puerto_Rico"); [EOL]         map.put("CNT", "America/St_Johns"); [EOL]         map.put("AGT", "America/Argentina/Buenos_Aires"); [EOL]         map.put("BET", "America/Sao_Paulo"); [EOL]         map.put("ART", "Africa/Cairo"); [EOL]         map.put("CAT", "Africa/Harare"); [EOL]         map.put("EAT", "Africa/Addis_Ababa"); [EOL]         map.put("NET", "Asia/Yerevan"); [EOL]         map.put("PLT", "Asia/Karachi"); [EOL]         map.put("IST", "Asia/Kolkata"); [EOL]         map.put("BST", "Asia/Dhaka"); [EOL]         map.put("VST", "Asia/Ho_Chi_Minh"); [EOL]         map.put("CTT", "Asia/Shanghai"); [EOL]         map.put("JST", "Asia/Tokyo"); [EOL]         map.put("ACT", "Australia/Darwin"); [EOL]         map.put("AET", "Australia/Sydney"); [EOL]         map.put("SST", "Pacific/Guadalcanal"); [EOL]         map.put("NST", "Pacific/Auckland"); [EOL]         cZoneIdConversion = map; [EOL]     } [EOL]     return map.get(id); [EOL] }
private static int parseOffset(String str) { [EOL]     Chronology chrono = new BaseChronology() { [EOL]  [EOL]         private static final long serialVersionUID = -3128740902654445468L; [EOL]  [EOL]         public DateTimeZone getZone() { [EOL]             return null; [EOL]         } [EOL]  [EOL]         public Chronology withUTC() { [EOL]             return this; [EOL]         } [EOL]  [EOL]         public Chronology withZone(DateTimeZone zone) { [EOL]             return this; [EOL]         } [EOL]  [EOL]         public String toString() { [EOL]             return getClass().getName(); [EOL]         } [EOL]     }; [EOL]     return -(int) offsetFormatter().withChronology(chrono).parseMillis(str); [EOL] }
private static String printOffset(int offset) { [EOL]     StringBuffer buf = new StringBuffer(); [EOL]     if (offset >= 0) { [EOL]         buf.append('+'); [EOL]     } else { [EOL]         buf.append('-'); [EOL]         offset = -offset; [EOL]     } [EOL]     int hours = offset / DateTimeConstants.MILLIS_PER_HOUR; [EOL]     FormatUtils.appendPaddedInteger(buf, hours, 2); [EOL]     offset -= hours * (int) DateTimeConstants.MILLIS_PER_HOUR; [EOL]     int minutes = offset / DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     buf.append(':'); [EOL]     FormatUtils.appendPaddedInteger(buf, minutes, 2); [EOL]     offset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     if (offset == 0) { [EOL]         return buf.toString(); [EOL]     } [EOL]     int seconds = offset / DateTimeConstants.MILLIS_PER_SECOND; [EOL]     buf.append(':'); [EOL]     FormatUtils.appendPaddedInteger(buf, seconds, 2); [EOL]     offset -= seconds * DateTimeConstants.MILLIS_PER_SECOND; [EOL]     if (offset == 0) { [EOL]         return buf.toString(); [EOL]     } [EOL]     buf.append('.'); [EOL]     FormatUtils.appendPaddedInteger(buf, offset, 3); [EOL]     return buf.toString(); [EOL] }
private static String printOffset(int offset) { [EOL]     StringBuffer buf = new StringBuffer(); [EOL]     if (offset >= 0) { [EOL]         buf.append('+'); [EOL]     } else { [EOL]         buf.append('-'); [EOL]         offset = -offset; [EOL]     } [EOL]     int hours = offset / DateTimeConstants.MILLIS_PER_HOUR; [EOL]     FormatUtils.appendPaddedInteger(buf, hours, 2); [EOL]     offset -= hours * (int) DateTimeConstants.MILLIS_PER_HOUR; [EOL]     int minutes = offset / DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     buf.append(':'); [EOL]     FormatUtils.appendPaddedInteger(buf, minutes, 2); [EOL]     offset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     if (offset == 0) { [EOL]         return buf.toString(); [EOL]     } [EOL]     int seconds = offset / DateTimeConstants.MILLIS_PER_SECOND; [EOL]     buf.append(':'); [EOL]     FormatUtils.appendPaddedInteger(buf, seconds, 2); [EOL]     offset -= seconds * DateTimeConstants.MILLIS_PER_SECOND; [EOL]     if (offset == 0) { [EOL]         return buf.toString(); [EOL]     } [EOL]     buf.append('.'); [EOL]     FormatUtils.appendPaddedInteger(buf, offset, 3); [EOL]     return buf.toString(); [EOL] }
private static String printOffset(int offset) { [EOL]     StringBuffer buf = new StringBuffer(); [EOL]     if (offset >= 0) { [EOL]         buf.append('+'); [EOL]     } else { [EOL]         buf.append('-'); [EOL]         offset = -offset; [EOL]     } [EOL]     int hours = offset / DateTimeConstants.MILLIS_PER_HOUR; [EOL]     FormatUtils.appendPaddedInteger(buf, hours, 2); [EOL]     offset -= hours * (int) DateTimeConstants.MILLIS_PER_HOUR; [EOL]     int minutes = offset / DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     buf.append(':'); [EOL]     FormatUtils.appendPaddedInteger(buf, minutes, 2); [EOL]     offset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     if (offset == 0) { [EOL]         return buf.toString(); [EOL]     } [EOL]     int seconds = offset / DateTimeConstants.MILLIS_PER_SECOND; [EOL]     buf.append(':'); [EOL]     FormatUtils.appendPaddedInteger(buf, seconds, 2); [EOL]     offset -= seconds * DateTimeConstants.MILLIS_PER_SECOND; [EOL]     if (offset == 0) { [EOL]         return buf.toString(); [EOL]     } [EOL]     buf.append('.'); [EOL]     FormatUtils.appendPaddedInteger(buf, offset, 3); [EOL]     return buf.toString(); [EOL] }
private static String printOffset(int offset) { [EOL]     StringBuffer buf = new StringBuffer(); [EOL]     if (offset >= 0) { [EOL]         buf.append('+'); [EOL]     } else { [EOL]         buf.append('-'); [EOL]         offset = -offset; [EOL]     } [EOL]     int hours = offset / DateTimeConstants.MILLIS_PER_HOUR; [EOL]     FormatUtils.appendPaddedInteger(buf, hours, 2); [EOL]     offset -= hours * (int) DateTimeConstants.MILLIS_PER_HOUR; [EOL]     int minutes = offset / DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     buf.append(':'); [EOL]     FormatUtils.appendPaddedInteger(buf, minutes, 2); [EOL]     offset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     if (offset == 0) { [EOL]         return buf.toString(); [EOL]     } [EOL]     int seconds = offset / DateTimeConstants.MILLIS_PER_SECOND; [EOL]     buf.append(':'); [EOL]     FormatUtils.appendPaddedInteger(buf, seconds, 2); [EOL]     offset -= seconds * DateTimeConstants.MILLIS_PER_SECOND; [EOL]     if (offset == 0) { [EOL]         return buf.toString(); [EOL]     } [EOL]     buf.append('.'); [EOL]     FormatUtils.appendPaddedInteger(buf, offset, 3); [EOL]     return buf.toString(); [EOL] }
private static String printOffset(int offset) { [EOL]     StringBuffer buf = new StringBuffer(); [EOL]     if (offset >= 0) { [EOL]         buf.append('+'); [EOL]     } else { [EOL]         buf.append('-'); [EOL]         offset = -offset; [EOL]     } [EOL]     int hours = offset / DateTimeConstants.MILLIS_PER_HOUR; [EOL]     FormatUtils.appendPaddedInteger(buf, hours, 2); [EOL]     offset -= hours * (int) DateTimeConstants.MILLIS_PER_HOUR; [EOL]     int minutes = offset / DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     buf.append(':'); [EOL]     FormatUtils.appendPaddedInteger(buf, minutes, 2); [EOL]     offset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     if (offset == 0) { [EOL]         return buf.toString(); [EOL]     } [EOL]     int seconds = offset / DateTimeConstants.MILLIS_PER_SECOND; [EOL]     buf.append(':'); [EOL]     FormatUtils.appendPaddedInteger(buf, seconds, 2); [EOL]     offset -= seconds * DateTimeConstants.MILLIS_PER_SECOND; [EOL]     if (offset == 0) { [EOL]         return buf.toString(); [EOL]     } [EOL]     buf.append('.'); [EOL]     FormatUtils.appendPaddedInteger(buf, offset, 3); [EOL]     return buf.toString(); [EOL] }
private static String printOffset(int offset) { [EOL]     StringBuffer buf = new StringBuffer(); [EOL]     if (offset >= 0) { [EOL]         buf.append('+'); [EOL]     } else { [EOL]         buf.append('-'); [EOL]         offset = -offset; [EOL]     } [EOL]     int hours = offset / DateTimeConstants.MILLIS_PER_HOUR; [EOL]     FormatUtils.appendPaddedInteger(buf, hours, 2); [EOL]     offset -= hours * (int) DateTimeConstants.MILLIS_PER_HOUR; [EOL]     int minutes = offset / DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     buf.append(':'); [EOL]     FormatUtils.appendPaddedInteger(buf, minutes, 2); [EOL]     offset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     if (offset == 0) { [EOL]         return buf.toString(); [EOL]     } [EOL]     int seconds = offset / DateTimeConstants.MILLIS_PER_SECOND; [EOL]     buf.append(':'); [EOL]     FormatUtils.appendPaddedInteger(buf, seconds, 2); [EOL]     offset -= seconds * DateTimeConstants.MILLIS_PER_SECOND; [EOL]     if (offset == 0) { [EOL]         return buf.toString(); [EOL]     } [EOL]     buf.append('.'); [EOL]     FormatUtils.appendPaddedInteger(buf, offset, 3); [EOL]     return buf.toString(); [EOL] }
private static String printOffset(int offset) { [EOL]     StringBuffer buf = new StringBuffer(); [EOL]     if (offset >= 0) { [EOL]         buf.append('+'); [EOL]     } else { [EOL]         buf.append('-'); [EOL]         offset = -offset; [EOL]     } [EOL]     int hours = offset / DateTimeConstants.MILLIS_PER_HOUR; [EOL]     FormatUtils.appendPaddedInteger(buf, hours, 2); [EOL]     offset -= hours * (int) DateTimeConstants.MILLIS_PER_HOUR; [EOL]     int minutes = offset / DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     buf.append(':'); [EOL]     FormatUtils.appendPaddedInteger(buf, minutes, 2); [EOL]     offset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     if (offset == 0) { [EOL]         return buf.toString(); [EOL]     } [EOL]     int seconds = offset / DateTimeConstants.MILLIS_PER_SECOND; [EOL]     buf.append(':'); [EOL]     FormatUtils.appendPaddedInteger(buf, seconds, 2); [EOL]     offset -= seconds * DateTimeConstants.MILLIS_PER_SECOND; [EOL]     if (offset == 0) { [EOL]         return buf.toString(); [EOL]     } [EOL]     buf.append('.'); [EOL]     FormatUtils.appendPaddedInteger(buf, offset, 3); [EOL]     return buf.toString(); [EOL] }
private static String printOffset(int offset) { [EOL]     StringBuffer buf = new StringBuffer(); [EOL]     if (offset >= 0) { [EOL]         buf.append('+'); [EOL]     } else { [EOL]         buf.append('-'); [EOL]         offset = -offset; [EOL]     } [EOL]     int hours = offset / DateTimeConstants.MILLIS_PER_HOUR; [EOL]     FormatUtils.appendPaddedInteger(buf, hours, 2); [EOL]     offset -= hours * (int) DateTimeConstants.MILLIS_PER_HOUR; [EOL]     int minutes = offset / DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     buf.append(':'); [EOL]     FormatUtils.appendPaddedInteger(buf, minutes, 2); [EOL]     offset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     if (offset == 0) { [EOL]         return buf.toString(); [EOL]     } [EOL]     int seconds = offset / DateTimeConstants.MILLIS_PER_SECOND; [EOL]     buf.append(':'); [EOL]     FormatUtils.appendPaddedInteger(buf, seconds, 2); [EOL]     offset -= seconds * DateTimeConstants.MILLIS_PER_SECOND; [EOL]     if (offset == 0) { [EOL]         return buf.toString(); [EOL]     } [EOL]     buf.append('.'); [EOL]     FormatUtils.appendPaddedInteger(buf, offset, 3); [EOL]     return buf.toString(); [EOL] }
private static synchronized DateTimeFormatter offsetFormatter() { [EOL]     if (cOffsetFormatter == null) { [EOL]         cOffsetFormatter = new DateTimeFormatterBuilder().appendTimeZoneOffset(null, true, 2, 4).toFormatter(); [EOL]     } [EOL]     return cOffsetFormatter; [EOL] }
public boolean isLocalDateTimeGap(LocalDateTime localDateTime) { [EOL]     if (isFixed()) { [EOL]         return false; [EOL]     } [EOL]     try { [EOL]         localDateTime.toDateTime(this); [EOL]         return false; [EOL]     } catch (IllegalInstantException ex) { [EOL]         return true; [EOL]     } [EOL] }
public boolean isLocalDateTimeGap(LocalDateTime localDateTime) { [EOL]     if (isFixed()) { [EOL]         return false; [EOL]     } [EOL]     try { [EOL]         localDateTime.toDateTime(this); [EOL]         return false; [EOL]     } catch (IllegalInstantException ex) { [EOL]         return true; [EOL]     } [EOL] }
public boolean isLocalDateTimeGap(LocalDateTime localDateTime) { [EOL]     if (isFixed()) { [EOL]         return false; [EOL]     } [EOL]     try { [EOL]         localDateTime.toDateTime(this); [EOL]         return false; [EOL]     } catch (IllegalInstantException ex) { [EOL]         return true; [EOL]     } [EOL] }
public long adjustOffset(long instant, boolean earlierOrLater) { [EOL]     long instantBefore = instant - 3 * DateTimeConstants.MILLIS_PER_HOUR; [EOL]     long instantAfter = instant + 3 * DateTimeConstants.MILLIS_PER_HOUR; [EOL]     long offsetBefore = getOffset(instantBefore); [EOL]     long offsetAfter = getOffset(instantAfter); [EOL]     if (offsetBefore <= offsetAfter) { [EOL]         return instant; [EOL]     } [EOL]     long diff = offsetBefore - offsetAfter; [EOL]     long transition = nextTransition(instantBefore); [EOL]     long overlapStart = transition - diff; [EOL]     long overlapEnd = transition + diff; [EOL]     if (instant < overlapStart || instant >= overlapEnd) { [EOL]         return instant; [EOL]     } [EOL]     long afterStart = instant - overlapStart; [EOL]     if (afterStart >= diff) { [EOL]         return earlierOrLater ? instant : instant - diff; [EOL]     } else { [EOL]         return earlierOrLater ? instant + diff : instant; [EOL]     } [EOL] }
public long adjustOffset(long instant, boolean earlierOrLater) { [EOL]     long instantBefore = instant - 3 * DateTimeConstants.MILLIS_PER_HOUR; [EOL]     long instantAfter = instant + 3 * DateTimeConstants.MILLIS_PER_HOUR; [EOL]     long offsetBefore = getOffset(instantBefore); [EOL]     long offsetAfter = getOffset(instantAfter); [EOL]     if (offsetBefore <= offsetAfter) { [EOL]         return instant; [EOL]     } [EOL]     long diff = offsetBefore - offsetAfter; [EOL]     long transition = nextTransition(instantBefore); [EOL]     long overlapStart = transition - diff; [EOL]     long overlapEnd = transition + diff; [EOL]     if (instant < overlapStart || instant >= overlapEnd) { [EOL]         return instant; [EOL]     } [EOL]     long afterStart = instant - overlapStart; [EOL]     if (afterStart >= diff) { [EOL]         return earlierOrLater ? instant : instant - diff; [EOL]     } else { [EOL]         return earlierOrLater ? instant + diff : instant; [EOL]     } [EOL] }
public long adjustOffset(long instant, boolean earlierOrLater) { [EOL]     long instantBefore = instant - 3 * DateTimeConstants.MILLIS_PER_HOUR; [EOL]     long instantAfter = instant + 3 * DateTimeConstants.MILLIS_PER_HOUR; [EOL]     long offsetBefore = getOffset(instantBefore); [EOL]     long offsetAfter = getOffset(instantAfter); [EOL]     if (offsetBefore <= offsetAfter) { [EOL]         return instant; [EOL]     } [EOL]     long diff = offsetBefore - offsetAfter; [EOL]     long transition = nextTransition(instantBefore); [EOL]     long overlapStart = transition - diff; [EOL]     long overlapEnd = transition + diff; [EOL]     if (instant < overlapStart || instant >= overlapEnd) { [EOL]         return instant; [EOL]     } [EOL]     long afterStart = instant - overlapStart; [EOL]     if (afterStart >= diff) { [EOL]         return earlierOrLater ? instant : instant - diff; [EOL]     } else { [EOL]         return earlierOrLater ? instant + diff : instant; [EOL]     } [EOL] }
public long adjustOffset(long instant, boolean earlierOrLater) { [EOL]     long instantBefore = instant - 3 * DateTimeConstants.MILLIS_PER_HOUR; [EOL]     long instantAfter = instant + 3 * DateTimeConstants.MILLIS_PER_HOUR; [EOL]     long offsetBefore = getOffset(instantBefore); [EOL]     long offsetAfter = getOffset(instantAfter); [EOL]     if (offsetBefore <= offsetAfter) { [EOL]         return instant; [EOL]     } [EOL]     long diff = offsetBefore - offsetAfter; [EOL]     long transition = nextTransition(instantBefore); [EOL]     long overlapStart = transition - diff; [EOL]     long overlapEnd = transition + diff; [EOL]     if (instant < overlapStart || instant >= overlapEnd) { [EOL]         return instant; [EOL]     } [EOL]     long afterStart = instant - overlapStart; [EOL]     if (afterStart >= diff) { [EOL]         return earlierOrLater ? instant : instant - diff; [EOL]     } else { [EOL]         return earlierOrLater ? instant + diff : instant; [EOL]     } [EOL] }
public long adjustOffset(long instant, boolean earlierOrLater) { [EOL]     long instantBefore = instant - 3 * DateTimeConstants.MILLIS_PER_HOUR; [EOL]     long instantAfter = instant + 3 * DateTimeConstants.MILLIS_PER_HOUR; [EOL]     long offsetBefore = getOffset(instantBefore); [EOL]     long offsetAfter = getOffset(instantAfter); [EOL]     if (offsetBefore <= offsetAfter) { [EOL]         return instant; [EOL]     } [EOL]     long diff = offsetBefore - offsetAfter; [EOL]     long transition = nextTransition(instantBefore); [EOL]     long overlapStart = transition - diff; [EOL]     long overlapEnd = transition + diff; [EOL]     if (instant < overlapStart || instant >= overlapEnd) { [EOL]         return instant; [EOL]     } [EOL]     long afterStart = instant - overlapStart; [EOL]     if (afterStart >= diff) { [EOL]         return earlierOrLater ? instant : instant - diff; [EOL]     } else { [EOL]         return earlierOrLater ? instant + diff : instant; [EOL]     } [EOL] }
public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int millisOfDay) throws IllegalArgumentException { [EOL]     Chronology base; [EOL]     if ((base = getBase()) != null) { [EOL]         return base.getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay); [EOL]     } [EOL]     FieldUtils.verifyValueBounds(DateTimeFieldType.millisOfDay(), millisOfDay, 0, DateTimeConstants.MILLIS_PER_DAY - 1); [EOL]     return getDateMidnightMillis(year, monthOfYear, dayOfMonth) + millisOfDay; [EOL] }
public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int millisOfDay) throws IllegalArgumentException { [EOL]     Chronology base; [EOL]     if ((base = getBase()) != null) { [EOL]         return base.getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay); [EOL]     } [EOL]     FieldUtils.verifyValueBounds(DateTimeFieldType.millisOfDay(), millisOfDay, 0, DateTimeConstants.MILLIS_PER_DAY - 1); [EOL]     return getDateMidnightMillis(year, monthOfYear, dayOfMonth) + millisOfDay; [EOL] }
public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int millisOfDay) throws IllegalArgumentException { [EOL]     Chronology base; [EOL]     if ((base = getBase()) != null) { [EOL]         return base.getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay); [EOL]     } [EOL]     FieldUtils.verifyValueBounds(DateTimeFieldType.millisOfDay(), millisOfDay, 0, DateTimeConstants.MILLIS_PER_DAY - 1); [EOL]     return getDateMidnightMillis(year, monthOfYear, dayOfMonth) + millisOfDay; [EOL] }
public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) throws IllegalArgumentException { [EOL]     Chronology base; [EOL]     if ((base = getBase()) != null) { [EOL]         return base.getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]     } [EOL]     FieldUtils.verifyValueBounds(DateTimeFieldType.hourOfDay(), hourOfDay, 0, 23); [EOL]     FieldUtils.verifyValueBounds(DateTimeFieldType.minuteOfHour(), minuteOfHour, 0, 59); [EOL]     FieldUtils.verifyValueBounds(DateTimeFieldType.secondOfMinute(), secondOfMinute, 0, 59); [EOL]     FieldUtils.verifyValueBounds(DateTimeFieldType.millisOfSecond(), millisOfSecond, 0, 999); [EOL]     return getDateMidnightMillis(year, monthOfYear, dayOfMonth) + hourOfDay * DateTimeConstants.MILLIS_PER_HOUR + minuteOfHour * DateTimeConstants.MILLIS_PER_MINUTE + secondOfMinute * DateTimeConstants.MILLIS_PER_SECOND + millisOfSecond; [EOL] }
public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) throws IllegalArgumentException { [EOL]     Chronology base; [EOL]     if ((base = getBase()) != null) { [EOL]         return base.getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]     } [EOL]     FieldUtils.verifyValueBounds(DateTimeFieldType.hourOfDay(), hourOfDay, 0, 23); [EOL]     FieldUtils.verifyValueBounds(DateTimeFieldType.minuteOfHour(), minuteOfHour, 0, 59); [EOL]     FieldUtils.verifyValueBounds(DateTimeFieldType.secondOfMinute(), secondOfMinute, 0, 59); [EOL]     FieldUtils.verifyValueBounds(DateTimeFieldType.millisOfSecond(), millisOfSecond, 0, 999); [EOL]     return getDateMidnightMillis(year, monthOfYear, dayOfMonth) + hourOfDay * DateTimeConstants.MILLIS_PER_HOUR + minuteOfHour * DateTimeConstants.MILLIS_PER_MINUTE + secondOfMinute * DateTimeConstants.MILLIS_PER_SECOND + millisOfSecond; [EOL] }
public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) throws IllegalArgumentException { [EOL]     Chronology base; [EOL]     if ((base = getBase()) != null) { [EOL]         return base.getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]     } [EOL]     FieldUtils.verifyValueBounds(DateTimeFieldType.hourOfDay(), hourOfDay, 0, 23); [EOL]     FieldUtils.verifyValueBounds(DateTimeFieldType.minuteOfHour(), minuteOfHour, 0, 59); [EOL]     FieldUtils.verifyValueBounds(DateTimeFieldType.secondOfMinute(), secondOfMinute, 0, 59); [EOL]     FieldUtils.verifyValueBounds(DateTimeFieldType.millisOfSecond(), millisOfSecond, 0, 999); [EOL]     return getDateMidnightMillis(year, monthOfYear, dayOfMonth) + hourOfDay * DateTimeConstants.MILLIS_PER_HOUR + minuteOfHour * DateTimeConstants.MILLIS_PER_MINUTE + secondOfMinute * DateTimeConstants.MILLIS_PER_SECOND + millisOfSecond; [EOL] }
public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) throws IllegalArgumentException { [EOL]     Chronology base; [EOL]     if ((base = getBase()) != null) { [EOL]         return base.getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]     } [EOL]     FieldUtils.verifyValueBounds(DateTimeFieldType.hourOfDay(), hourOfDay, 0, 23); [EOL]     FieldUtils.verifyValueBounds(DateTimeFieldType.minuteOfHour(), minuteOfHour, 0, 59); [EOL]     FieldUtils.verifyValueBounds(DateTimeFieldType.secondOfMinute(), secondOfMinute, 0, 59); [EOL]     FieldUtils.verifyValueBounds(DateTimeFieldType.millisOfSecond(), millisOfSecond, 0, 999); [EOL]     return getDateMidnightMillis(year, monthOfYear, dayOfMonth) + hourOfDay * DateTimeConstants.MILLIS_PER_HOUR + minuteOfHour * DateTimeConstants.MILLIS_PER_MINUTE + secondOfMinute * DateTimeConstants.MILLIS_PER_SECOND + millisOfSecond; [EOL] }
public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) throws IllegalArgumentException { [EOL]     Chronology base; [EOL]     if ((base = getBase()) != null) { [EOL]         return base.getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]     } [EOL]     FieldUtils.verifyValueBounds(DateTimeFieldType.hourOfDay(), hourOfDay, 0, 23); [EOL]     FieldUtils.verifyValueBounds(DateTimeFieldType.minuteOfHour(), minuteOfHour, 0, 59); [EOL]     FieldUtils.verifyValueBounds(DateTimeFieldType.secondOfMinute(), secondOfMinute, 0, 59); [EOL]     FieldUtils.verifyValueBounds(DateTimeFieldType.millisOfSecond(), millisOfSecond, 0, 999); [EOL]     return getDateMidnightMillis(year, monthOfYear, dayOfMonth) + hourOfDay * DateTimeConstants.MILLIS_PER_HOUR + minuteOfHour * DateTimeConstants.MILLIS_PER_MINUTE + secondOfMinute * DateTimeConstants.MILLIS_PER_SECOND + millisOfSecond; [EOL] }
public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) throws IllegalArgumentException { [EOL]     Chronology base; [EOL]     if ((base = getBase()) != null) { [EOL]         return base.getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]     } [EOL]     FieldUtils.verifyValueBounds(DateTimeFieldType.hourOfDay(), hourOfDay, 0, 23); [EOL]     FieldUtils.verifyValueBounds(DateTimeFieldType.minuteOfHour(), minuteOfHour, 0, 59); [EOL]     FieldUtils.verifyValueBounds(DateTimeFieldType.secondOfMinute(), secondOfMinute, 0, 59); [EOL]     FieldUtils.verifyValueBounds(DateTimeFieldType.millisOfSecond(), millisOfSecond, 0, 999); [EOL]     return getDateMidnightMillis(year, monthOfYear, dayOfMonth) + hourOfDay * DateTimeConstants.MILLIS_PER_HOUR + minuteOfHour * DateTimeConstants.MILLIS_PER_MINUTE + secondOfMinute * DateTimeConstants.MILLIS_PER_SECOND + millisOfSecond; [EOL] }
public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) throws IllegalArgumentException { [EOL]     Chronology base; [EOL]     if ((base = getBase()) != null) { [EOL]         return base.getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]     } [EOL]     FieldUtils.verifyValueBounds(DateTimeFieldType.hourOfDay(), hourOfDay, 0, 23); [EOL]     FieldUtils.verifyValueBounds(DateTimeFieldType.minuteOfHour(), minuteOfHour, 0, 59); [EOL]     FieldUtils.verifyValueBounds(DateTimeFieldType.secondOfMinute(), secondOfMinute, 0, 59); [EOL]     FieldUtils.verifyValueBounds(DateTimeFieldType.millisOfSecond(), millisOfSecond, 0, 999); [EOL]     return getDateMidnightMillis(year, monthOfYear, dayOfMonth) + hourOfDay * DateTimeConstants.MILLIS_PER_HOUR + minuteOfHour * DateTimeConstants.MILLIS_PER_MINUTE + secondOfMinute * DateTimeConstants.MILLIS_PER_SECOND + millisOfSecond; [EOL] }
public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) throws IllegalArgumentException { [EOL]     Chronology base; [EOL]     if ((base = getBase()) != null) { [EOL]         return base.getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]     } [EOL]     FieldUtils.verifyValueBounds(DateTimeFieldType.hourOfDay(), hourOfDay, 0, 23); [EOL]     FieldUtils.verifyValueBounds(DateTimeFieldType.minuteOfHour(), minuteOfHour, 0, 59); [EOL]     FieldUtils.verifyValueBounds(DateTimeFieldType.secondOfMinute(), secondOfMinute, 0, 59); [EOL]     FieldUtils.verifyValueBounds(DateTimeFieldType.millisOfSecond(), millisOfSecond, 0, 999); [EOL]     return getDateMidnightMillis(year, monthOfYear, dayOfMonth) + hourOfDay * DateTimeConstants.MILLIS_PER_HOUR + minuteOfHour * DateTimeConstants.MILLIS_PER_MINUTE + secondOfMinute * DateTimeConstants.MILLIS_PER_SECOND + millisOfSecond; [EOL] }
public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) throws IllegalArgumentException { [EOL]     Chronology base; [EOL]     if ((base = getBase()) != null) { [EOL]         return base.getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]     } [EOL]     FieldUtils.verifyValueBounds(DateTimeFieldType.hourOfDay(), hourOfDay, 0, 23); [EOL]     FieldUtils.verifyValueBounds(DateTimeFieldType.minuteOfHour(), minuteOfHour, 0, 59); [EOL]     FieldUtils.verifyValueBounds(DateTimeFieldType.secondOfMinute(), secondOfMinute, 0, 59); [EOL]     FieldUtils.verifyValueBounds(DateTimeFieldType.millisOfSecond(), millisOfSecond, 0, 999); [EOL]     return getDateMidnightMillis(year, monthOfYear, dayOfMonth) + hourOfDay * DateTimeConstants.MILLIS_PER_HOUR + minuteOfHour * DateTimeConstants.MILLIS_PER_MINUTE + secondOfMinute * DateTimeConstants.MILLIS_PER_SECOND + millisOfSecond; [EOL] }
public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) throws IllegalArgumentException { [EOL]     Chronology base; [EOL]     if ((base = getBase()) != null) { [EOL]         return base.getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]     } [EOL]     FieldUtils.verifyValueBounds(DateTimeFieldType.hourOfDay(), hourOfDay, 0, 23); [EOL]     FieldUtils.verifyValueBounds(DateTimeFieldType.minuteOfHour(), minuteOfHour, 0, 59); [EOL]     FieldUtils.verifyValueBounds(DateTimeFieldType.secondOfMinute(), secondOfMinute, 0, 59); [EOL]     FieldUtils.verifyValueBounds(DateTimeFieldType.millisOfSecond(), millisOfSecond, 0, 999); [EOL]     return getDateMidnightMillis(year, monthOfYear, dayOfMonth) + hourOfDay * DateTimeConstants.MILLIS_PER_HOUR + minuteOfHour * DateTimeConstants.MILLIS_PER_MINUTE + secondOfMinute * DateTimeConstants.MILLIS_PER_SECOND + millisOfSecond; [EOL] }
long getYearMonthMillis(int year, int month) { [EOL]     long millis = getYearMillis(year); [EOL]     millis += getTotalMillisByYearMonth(year, month); [EOL]     return millis; [EOL] }
int getYear(long instant) { [EOL]     long unitMillis = getAverageMillisPerYearDividedByTwo(); [EOL]     long i2 = (instant >> 1) + getApproxMillisAtEpochDividedByTwo(); [EOL]     if (i2 < 0) { [EOL]         i2 = i2 - unitMillis + 1; [EOL]     } [EOL]     int year = (int) (i2 / unitMillis); [EOL]     long yearStart = getYearMillis(year); [EOL]     long diff = instant - yearStart; [EOL]     if (diff < 0) { [EOL]         year--; [EOL]     } else if (diff >= DateTimeConstants.MILLIS_PER_DAY * 365L) { [EOL]         long oneYear; [EOL]         if (isLeapYear(year)) { [EOL]             oneYear = DateTimeConstants.MILLIS_PER_DAY * 366L; [EOL]         } else { [EOL]             oneYear = DateTimeConstants.MILLIS_PER_DAY * 365L; [EOL]         } [EOL]         yearStart += oneYear; [EOL]         if (yearStart <= instant) { [EOL]             year++; [EOL]         } [EOL]     } [EOL]     return year; [EOL] }
int getYear(long instant) { [EOL]     long unitMillis = getAverageMillisPerYearDividedByTwo(); [EOL]     long i2 = (instant >> 1) + getApproxMillisAtEpochDividedByTwo(); [EOL]     if (i2 < 0) { [EOL]         i2 = i2 - unitMillis + 1; [EOL]     } [EOL]     int year = (int) (i2 / unitMillis); [EOL]     long yearStart = getYearMillis(year); [EOL]     long diff = instant - yearStart; [EOL]     if (diff < 0) { [EOL]         year--; [EOL]     } else if (diff >= DateTimeConstants.MILLIS_PER_DAY * 365L) { [EOL]         long oneYear; [EOL]         if (isLeapYear(year)) { [EOL]             oneYear = DateTimeConstants.MILLIS_PER_DAY * 366L; [EOL]         } else { [EOL]             oneYear = DateTimeConstants.MILLIS_PER_DAY * 365L; [EOL]         } [EOL]         yearStart += oneYear; [EOL]         if (yearStart <= instant) { [EOL]             year++; [EOL]         } [EOL]     } [EOL]     return year; [EOL] }
int getYear(long instant) { [EOL]     long unitMillis = getAverageMillisPerYearDividedByTwo(); [EOL]     long i2 = (instant >> 1) + getApproxMillisAtEpochDividedByTwo(); [EOL]     if (i2 < 0) { [EOL]         i2 = i2 - unitMillis + 1; [EOL]     } [EOL]     int year = (int) (i2 / unitMillis); [EOL]     long yearStart = getYearMillis(year); [EOL]     long diff = instant - yearStart; [EOL]     if (diff < 0) { [EOL]         year--; [EOL]     } else if (diff >= DateTimeConstants.MILLIS_PER_DAY * 365L) { [EOL]         long oneYear; [EOL]         if (isLeapYear(year)) { [EOL]             oneYear = DateTimeConstants.MILLIS_PER_DAY * 366L; [EOL]         } else { [EOL]             oneYear = DateTimeConstants.MILLIS_PER_DAY * 365L; [EOL]         } [EOL]         yearStart += oneYear; [EOL]         if (yearStart <= instant) { [EOL]             year++; [EOL]         } [EOL]     } [EOL]     return year; [EOL] }
int getYear(long instant) { [EOL]     long unitMillis = getAverageMillisPerYearDividedByTwo(); [EOL]     long i2 = (instant >> 1) + getApproxMillisAtEpochDividedByTwo(); [EOL]     if (i2 < 0) { [EOL]         i2 = i2 - unitMillis + 1; [EOL]     } [EOL]     int year = (int) (i2 / unitMillis); [EOL]     long yearStart = getYearMillis(year); [EOL]     long diff = instant - yearStart; [EOL]     if (diff < 0) { [EOL]         year--; [EOL]     } else if (diff >= DateTimeConstants.MILLIS_PER_DAY * 365L) { [EOL]         long oneYear; [EOL]         if (isLeapYear(year)) { [EOL]             oneYear = DateTimeConstants.MILLIS_PER_DAY * 366L; [EOL]         } else { [EOL]             oneYear = DateTimeConstants.MILLIS_PER_DAY * 365L; [EOL]         } [EOL]         yearStart += oneYear; [EOL]         if (yearStart <= instant) { [EOL]             year++; [EOL]         } [EOL]     } [EOL]     return year; [EOL] }
int getYear(long instant) { [EOL]     long unitMillis = getAverageMillisPerYearDividedByTwo(); [EOL]     long i2 = (instant >> 1) + getApproxMillisAtEpochDividedByTwo(); [EOL]     if (i2 < 0) { [EOL]         i2 = i2 - unitMillis + 1; [EOL]     } [EOL]     int year = (int) (i2 / unitMillis); [EOL]     long yearStart = getYearMillis(year); [EOL]     long diff = instant - yearStart; [EOL]     if (diff < 0) { [EOL]         year--; [EOL]     } else if (diff >= DateTimeConstants.MILLIS_PER_DAY * 365L) { [EOL]         long oneYear; [EOL]         if (isLeapYear(year)) { [EOL]             oneYear = DateTimeConstants.MILLIS_PER_DAY * 366L; [EOL]         } else { [EOL]             oneYear = DateTimeConstants.MILLIS_PER_DAY * 365L; [EOL]         } [EOL]         yearStart += oneYear; [EOL]         if (yearStart <= instant) { [EOL]             year++; [EOL]         } [EOL]     } [EOL]     return year; [EOL] }
int getDayOfYear(long instant) { [EOL]     return getDayOfYear(instant, getYear(instant)); [EOL] }
public PeriodType getPeriodType() { [EOL]     return PeriodType.time(); [EOL] } protected BasePeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis, PeriodType type); protected BasePeriod(long startInstant, long endInstant, PeriodType type, Chronology chrono); protected BasePeriod(ReadableInstant startInstant, ReadableInstant endInstant, PeriodType type); protected BasePeriod(ReadablePartial start, ReadablePartial end, PeriodType type); protected BasePeriod(ReadableInstant startInstant, ReadableDuration duration, PeriodType type); protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, PeriodType type); protected BasePeriod(long duration); protected BasePeriod(long duration, PeriodType type, Chronology chrono); protected BasePeriod(Object period, PeriodType type, Chronology chrono); protected BasePeriod(int[] values, PeriodType type); public int getValue(int index); public PeriodType getPeriodType(); protected PeriodType checkPeriodType(PeriodType type); public PeriodType getPeriodType(); public int getValue(int index); public Duration toDurationFrom(ReadableInstant startInstant); public Duration toDurationTo(ReadableInstant endInstant); private void checkAndUpdate(DurationFieldType type, int[] values, int newValue); protected void setPeriod(ReadablePeriod period); private void setPeriodInternal(ReadablePeriod period); protected void setPeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); private int[] setPeriodInternal(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); protected void setField(DurationFieldType field, int value); protected void setFieldInto(int[] values, DurationFieldType field, int value); protected void addField(DurationFieldType field, int value); protected void addFieldInto(int[] values, DurationFieldType field, int value); protected void mergePeriod(ReadablePeriod period); protected int[] mergePeriodInto(int[] values, ReadablePeriod period); protected void addPeriod(ReadablePeriod period); protected int[] addPeriodInto(int[] values, ReadablePeriod period); protected void setValue(int index, int value); protected void setValues(int[] values); long serialVersionUID=Optional[-2110953284060001145L]; ReadablePeriod DUMMY_PERIOD=Optional[new AbstractPeriod() {; ;     public int getValue(int index) {;         return 0;;     }; ;     public PeriodType getPeriodType() {;         return PeriodType.time();;     }; }
protected BasePeriod(ReadablePartial start, ReadablePartial end, PeriodType type) { [EOL]     super(); [EOL]     if (start == null || end == null) { [EOL]         throw new IllegalArgumentException("ReadablePartial objects must not be null"); [EOL]     } [EOL]     if (start instanceof BaseLocal && end instanceof BaseLocal && start.getClass() == end.getClass()) { [EOL]         type = checkPeriodType(type); [EOL]         long startMillis = ((BaseLocal) start).getLocalMillis(); [EOL]         long endMillis = ((BaseLocal) end).getLocalMillis(); [EOL]         Chronology chrono = start.getChronology(); [EOL]         chrono = DateTimeUtils.getChronology(chrono); [EOL]         iType = type; [EOL]         iValues = chrono.get(this, startMillis, endMillis); [EOL]     } else { [EOL]         if (start.size() != end.size()) { [EOL]             throw new IllegalArgumentException("ReadablePartial objects must have the same set of fields"); [EOL]         } [EOL]         for (int i = 0, isize = start.size(); i < isize; i++) { [EOL]             if (start.getFieldType(i) != end.getFieldType(i)) { [EOL]                 throw new IllegalArgumentException("ReadablePartial objects must have the same set of fields"); [EOL]             } [EOL]         } [EOL]         if (DateTimeUtils.isContiguous(start) == false) { [EOL]             throw new IllegalArgumentException("ReadablePartial objects must be contiguous"); [EOL]         } [EOL]         iType = checkPeriodType(type); [EOL]         Chronology chrono = DateTimeUtils.getChronology(start.getChronology()).withUTC(); [EOL]         iValues = chrono.get(this, chrono.set(start, 0L), chrono.set(end, 0L)); [EOL]     } [EOL] } protected BasePeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis, PeriodType type); protected BasePeriod(long startInstant, long endInstant, PeriodType type, Chronology chrono); protected BasePeriod(ReadableInstant startInstant, ReadableInstant endInstant, PeriodType type); protected BasePeriod(ReadablePartial start, ReadablePartial end, PeriodType type); protected BasePeriod(ReadableInstant startInstant, ReadableDuration duration, PeriodType type); protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, PeriodType type); protected BasePeriod(long duration); protected BasePeriod(long duration, PeriodType type, Chronology chrono); protected BasePeriod(Object period, PeriodType type, Chronology chrono); protected BasePeriod(int[] values, PeriodType type); public int getValue(int index); public PeriodType getPeriodType(); protected PeriodType checkPeriodType(PeriodType type); public PeriodType getPeriodType(); public int getValue(int index); public Duration toDurationFrom(ReadableInstant startInstant); public Duration toDurationTo(ReadableInstant endInstant); private void checkAndUpdate(DurationFieldType type, int[] values, int newValue); protected void setPeriod(ReadablePeriod period); private void setPeriodInternal(ReadablePeriod period); protected void setPeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); private int[] setPeriodInternal(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); protected void setField(DurationFieldType field, int value); protected void setFieldInto(int[] values, DurationFieldType field, int value); protected void addField(DurationFieldType field, int value); protected void addFieldInto(int[] values, DurationFieldType field, int value); protected void mergePeriod(ReadablePeriod period); protected int[] mergePeriodInto(int[] values, ReadablePeriod period); protected void addPeriod(ReadablePeriod period); protected int[] addPeriodInto(int[] values, ReadablePeriod period); protected void setValue(int index, int value); protected void setValues(int[] values); long serialVersionUID=Optional[-2110953284060001145L]; ReadablePeriod DUMMY_PERIOD=Optional[new AbstractPeriod() {; ;     public int getValue(int index) {;         return 0;;     }; ;     public PeriodType getPeriodType() {;         return PeriodType.time();;     }; }
protected BasePeriod(ReadableInstant startInstant, ReadableDuration duration, PeriodType type) { [EOL]     super(); [EOL]     type = checkPeriodType(type); [EOL]     long startMillis = DateTimeUtils.getInstantMillis(startInstant); [EOL]     long durationMillis = DateTimeUtils.getDurationMillis(duration); [EOL]     long endMillis = FieldUtils.safeAdd(startMillis, durationMillis); [EOL]     Chronology chrono = DateTimeUtils.getInstantChronology(startInstant); [EOL]     iType = type; [EOL]     iValues = chrono.get(this, startMillis, endMillis); [EOL] } protected BasePeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis, PeriodType type); protected BasePeriod(long startInstant, long endInstant, PeriodType type, Chronology chrono); protected BasePeriod(ReadableInstant startInstant, ReadableInstant endInstant, PeriodType type); protected BasePeriod(ReadablePartial start, ReadablePartial end, PeriodType type); protected BasePeriod(ReadableInstant startInstant, ReadableDuration duration, PeriodType type); protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, PeriodType type); protected BasePeriod(long duration); protected BasePeriod(long duration, PeriodType type, Chronology chrono); protected BasePeriod(Object period, PeriodType type, Chronology chrono); protected BasePeriod(int[] values, PeriodType type); public int getValue(int index); public PeriodType getPeriodType(); protected PeriodType checkPeriodType(PeriodType type); public PeriodType getPeriodType(); public int getValue(int index); public Duration toDurationFrom(ReadableInstant startInstant); public Duration toDurationTo(ReadableInstant endInstant); private void checkAndUpdate(DurationFieldType type, int[] values, int newValue); protected void setPeriod(ReadablePeriod period); private void setPeriodInternal(ReadablePeriod period); protected void setPeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); private int[] setPeriodInternal(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); protected void setField(DurationFieldType field, int value); protected void setFieldInto(int[] values, DurationFieldType field, int value); protected void addField(DurationFieldType field, int value); protected void addFieldInto(int[] values, DurationFieldType field, int value); protected void mergePeriod(ReadablePeriod period); protected int[] mergePeriodInto(int[] values, ReadablePeriod period); protected void addPeriod(ReadablePeriod period); protected int[] addPeriodInto(int[] values, ReadablePeriod period); protected void setValue(int index, int value); protected void setValues(int[] values); long serialVersionUID=Optional[-2110953284060001145L]; ReadablePeriod DUMMY_PERIOD=Optional[new AbstractPeriod() {; ;     public int getValue(int index) {;         return 0;;     }; ;     public PeriodType getPeriodType() {;         return PeriodType.time();;     }; }
protected BasePeriod(long duration) { [EOL]     super(); [EOL]     iType = PeriodType.standard(); [EOL]     int[] values = ISOChronology.getInstanceUTC().get(DUMMY_PERIOD, duration); [EOL]     iValues = new int[8]; [EOL]     System.arraycopy(values, 0, iValues, 4, 4); [EOL] } protected BasePeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis, PeriodType type); protected BasePeriod(long startInstant, long endInstant, PeriodType type, Chronology chrono); protected BasePeriod(ReadableInstant startInstant, ReadableInstant endInstant, PeriodType type); protected BasePeriod(ReadablePartial start, ReadablePartial end, PeriodType type); protected BasePeriod(ReadableInstant startInstant, ReadableDuration duration, PeriodType type); protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, PeriodType type); protected BasePeriod(long duration); protected BasePeriod(long duration, PeriodType type, Chronology chrono); protected BasePeriod(Object period, PeriodType type, Chronology chrono); protected BasePeriod(int[] values, PeriodType type); public int getValue(int index); public PeriodType getPeriodType(); protected PeriodType checkPeriodType(PeriodType type); public PeriodType getPeriodType(); public int getValue(int index); public Duration toDurationFrom(ReadableInstant startInstant); public Duration toDurationTo(ReadableInstant endInstant); private void checkAndUpdate(DurationFieldType type, int[] values, int newValue); protected void setPeriod(ReadablePeriod period); private void setPeriodInternal(ReadablePeriod period); protected void setPeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); private int[] setPeriodInternal(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); protected void setField(DurationFieldType field, int value); protected void setFieldInto(int[] values, DurationFieldType field, int value); protected void addField(DurationFieldType field, int value); protected void addFieldInto(int[] values, DurationFieldType field, int value); protected void mergePeriod(ReadablePeriod period); protected int[] mergePeriodInto(int[] values, ReadablePeriod period); protected void addPeriod(ReadablePeriod period); protected int[] addPeriodInto(int[] values, ReadablePeriod period); protected void setValue(int index, int value); protected void setValues(int[] values); long serialVersionUID=Optional[-2110953284060001145L]; ReadablePeriod DUMMY_PERIOD=Optional[new AbstractPeriod() {; ;     public int getValue(int index) {;         return 0;;     }; ;     public PeriodType getPeriodType() {;         return PeriodType.time();;     }; }
protected BasePeriod(long duration) { [EOL]     super(); [EOL]     iType = PeriodType.standard(); [EOL]     int[] values = ISOChronology.getInstanceUTC().get(DUMMY_PERIOD, duration); [EOL]     iValues = new int[8]; [EOL]     System.arraycopy(values, 0, iValues, 4, 4); [EOL] } protected BasePeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis, PeriodType type); protected BasePeriod(long startInstant, long endInstant, PeriodType type, Chronology chrono); protected BasePeriod(ReadableInstant startInstant, ReadableInstant endInstant, PeriodType type); protected BasePeriod(ReadablePartial start, ReadablePartial end, PeriodType type); protected BasePeriod(ReadableInstant startInstant, ReadableDuration duration, PeriodType type); protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, PeriodType type); protected BasePeriod(long duration); protected BasePeriod(long duration, PeriodType type, Chronology chrono); protected BasePeriod(Object period, PeriodType type, Chronology chrono); protected BasePeriod(int[] values, PeriodType type); public int getValue(int index); public PeriodType getPeriodType(); protected PeriodType checkPeriodType(PeriodType type); public PeriodType getPeriodType(); public int getValue(int index); public Duration toDurationFrom(ReadableInstant startInstant); public Duration toDurationTo(ReadableInstant endInstant); private void checkAndUpdate(DurationFieldType type, int[] values, int newValue); protected void setPeriod(ReadablePeriod period); private void setPeriodInternal(ReadablePeriod period); protected void setPeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); private int[] setPeriodInternal(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); protected void setField(DurationFieldType field, int value); protected void setFieldInto(int[] values, DurationFieldType field, int value); protected void addField(DurationFieldType field, int value); protected void addFieldInto(int[] values, DurationFieldType field, int value); protected void mergePeriod(ReadablePeriod period); protected int[] mergePeriodInto(int[] values, ReadablePeriod period); protected void addPeriod(ReadablePeriod period); protected int[] addPeriodInto(int[] values, ReadablePeriod period); protected void setValue(int index, int value); protected void setValues(int[] values); long serialVersionUID=Optional[-2110953284060001145L]; ReadablePeriod DUMMY_PERIOD=Optional[new AbstractPeriod() {; ;     public int getValue(int index) {;         return 0;;     }; ;     public PeriodType getPeriodType() {;         return PeriodType.time();;     }; }
protected BasePeriod(long duration, PeriodType type, Chronology chrono) { [EOL]     super(); [EOL]     type = checkPeriodType(type); [EOL]     chrono = DateTimeUtils.getChronology(chrono); [EOL]     iType = type; [EOL]     iValues = chrono.get(this, duration); [EOL] } protected BasePeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis, PeriodType type); protected BasePeriod(long startInstant, long endInstant, PeriodType type, Chronology chrono); protected BasePeriod(ReadableInstant startInstant, ReadableInstant endInstant, PeriodType type); protected BasePeriod(ReadablePartial start, ReadablePartial end, PeriodType type); protected BasePeriod(ReadableInstant startInstant, ReadableDuration duration, PeriodType type); protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, PeriodType type); protected BasePeriod(long duration); protected BasePeriod(long duration, PeriodType type, Chronology chrono); protected BasePeriod(Object period, PeriodType type, Chronology chrono); protected BasePeriod(int[] values, PeriodType type); public int getValue(int index); public PeriodType getPeriodType(); protected PeriodType checkPeriodType(PeriodType type); public PeriodType getPeriodType(); public int getValue(int index); public Duration toDurationFrom(ReadableInstant startInstant); public Duration toDurationTo(ReadableInstant endInstant); private void checkAndUpdate(DurationFieldType type, int[] values, int newValue); protected void setPeriod(ReadablePeriod period); private void setPeriodInternal(ReadablePeriod period); protected void setPeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); private int[] setPeriodInternal(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); protected void setField(DurationFieldType field, int value); protected void setFieldInto(int[] values, DurationFieldType field, int value); protected void addField(DurationFieldType field, int value); protected void addFieldInto(int[] values, DurationFieldType field, int value); protected void mergePeriod(ReadablePeriod period); protected int[] mergePeriodInto(int[] values, ReadablePeriod period); protected void addPeriod(ReadablePeriod period); protected int[] addPeriodInto(int[] values, ReadablePeriod period); protected void setValue(int index, int value); protected void setValues(int[] values); long serialVersionUID=Optional[-2110953284060001145L]; ReadablePeriod DUMMY_PERIOD=Optional[new AbstractPeriod() {; ;     public int getValue(int index) {;         return 0;;     }; ;     public PeriodType getPeriodType() {;         return PeriodType.time();;     }; }
protected BasePeriod(int[] values, PeriodType type) { [EOL]     super(); [EOL]     iType = type; [EOL]     iValues = values; [EOL] } protected BasePeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis, PeriodType type); protected BasePeriod(long startInstant, long endInstant, PeriodType type, Chronology chrono); protected BasePeriod(ReadableInstant startInstant, ReadableInstant endInstant, PeriodType type); protected BasePeriod(ReadablePartial start, ReadablePartial end, PeriodType type); protected BasePeriod(ReadableInstant startInstant, ReadableDuration duration, PeriodType type); protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, PeriodType type); protected BasePeriod(long duration); protected BasePeriod(long duration, PeriodType type, Chronology chrono); protected BasePeriod(Object period, PeriodType type, Chronology chrono); protected BasePeriod(int[] values, PeriodType type); public int getValue(int index); public PeriodType getPeriodType(); protected PeriodType checkPeriodType(PeriodType type); public PeriodType getPeriodType(); public int getValue(int index); public Duration toDurationFrom(ReadableInstant startInstant); public Duration toDurationTo(ReadableInstant endInstant); private void checkAndUpdate(DurationFieldType type, int[] values, int newValue); protected void setPeriod(ReadablePeriod period); private void setPeriodInternal(ReadablePeriod period); protected void setPeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); private int[] setPeriodInternal(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); protected void setField(DurationFieldType field, int value); protected void setFieldInto(int[] values, DurationFieldType field, int value); protected void addField(DurationFieldType field, int value); protected void addFieldInto(int[] values, DurationFieldType field, int value); protected void mergePeriod(ReadablePeriod period); protected int[] mergePeriodInto(int[] values, ReadablePeriod period); protected void addPeriod(ReadablePeriod period); protected int[] addPeriodInto(int[] values, ReadablePeriod period); protected void setValue(int index, int value); protected void setValues(int[] values); long serialVersionUID=Optional[-2110953284060001145L]; ReadablePeriod DUMMY_PERIOD=Optional[new AbstractPeriod() {; ;     public int getValue(int index) {;         return 0;;     }; ;     public PeriodType getPeriodType() {;         return PeriodType.time();;     }; }
protected PeriodType checkPeriodType(PeriodType type) { [EOL]     return DateTimeUtils.getPeriodType(type); [EOL] } protected BasePeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis, PeriodType type); protected BasePeriod(long startInstant, long endInstant, PeriodType type, Chronology chrono); protected BasePeriod(ReadableInstant startInstant, ReadableInstant endInstant, PeriodType type); protected BasePeriod(ReadablePartial start, ReadablePartial end, PeriodType type); protected BasePeriod(ReadableInstant startInstant, ReadableDuration duration, PeriodType type); protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, PeriodType type); protected BasePeriod(long duration); protected BasePeriod(long duration, PeriodType type, Chronology chrono); protected BasePeriod(Object period, PeriodType type, Chronology chrono); protected BasePeriod(int[] values, PeriodType type); public int getValue(int index); public PeriodType getPeriodType(); protected PeriodType checkPeriodType(PeriodType type); public PeriodType getPeriodType(); public int getValue(int index); public Duration toDurationFrom(ReadableInstant startInstant); public Duration toDurationTo(ReadableInstant endInstant); private void checkAndUpdate(DurationFieldType type, int[] values, int newValue); protected void setPeriod(ReadablePeriod period); private void setPeriodInternal(ReadablePeriod period); protected void setPeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); private int[] setPeriodInternal(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); protected void setField(DurationFieldType field, int value); protected void setFieldInto(int[] values, DurationFieldType field, int value); protected void addField(DurationFieldType field, int value); protected void addFieldInto(int[] values, DurationFieldType field, int value); protected void mergePeriod(ReadablePeriod period); protected int[] mergePeriodInto(int[] values, ReadablePeriod period); protected void addPeriod(ReadablePeriod period); protected int[] addPeriodInto(int[] values, ReadablePeriod period); protected void setValue(int index, int value); protected void setValues(int[] values); long serialVersionUID=Optional[-2110953284060001145L]; ReadablePeriod DUMMY_PERIOD=Optional[new AbstractPeriod() {; ;     public int getValue(int index) {;         return 0;;     }; ;     public PeriodType getPeriodType() {;         return PeriodType.time();;     }; }
public PeriodType getPeriodType() { [EOL]     return iType; [EOL] } protected BasePeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis, PeriodType type); protected BasePeriod(long startInstant, long endInstant, PeriodType type, Chronology chrono); protected BasePeriod(ReadableInstant startInstant, ReadableInstant endInstant, PeriodType type); protected BasePeriod(ReadablePartial start, ReadablePartial end, PeriodType type); protected BasePeriod(ReadableInstant startInstant, ReadableDuration duration, PeriodType type); protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, PeriodType type); protected BasePeriod(long duration); protected BasePeriod(long duration, PeriodType type, Chronology chrono); protected BasePeriod(Object period, PeriodType type, Chronology chrono); protected BasePeriod(int[] values, PeriodType type); public int getValue(int index); public PeriodType getPeriodType(); protected PeriodType checkPeriodType(PeriodType type); public PeriodType getPeriodType(); public int getValue(int index); public Duration toDurationFrom(ReadableInstant startInstant); public Duration toDurationTo(ReadableInstant endInstant); private void checkAndUpdate(DurationFieldType type, int[] values, int newValue); protected void setPeriod(ReadablePeriod period); private void setPeriodInternal(ReadablePeriod period); protected void setPeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); private int[] setPeriodInternal(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); protected void setField(DurationFieldType field, int value); protected void setFieldInto(int[] values, DurationFieldType field, int value); protected void addField(DurationFieldType field, int value); protected void addFieldInto(int[] values, DurationFieldType field, int value); protected void mergePeriod(ReadablePeriod period); protected int[] mergePeriodInto(int[] values, ReadablePeriod period); protected void addPeriod(ReadablePeriod period); protected int[] addPeriodInto(int[] values, ReadablePeriod period); protected void setValue(int index, int value); protected void setValues(int[] values); long serialVersionUID=Optional[-2110953284060001145L]; ReadablePeriod DUMMY_PERIOD=Optional[new AbstractPeriod() {; ;     public int getValue(int index) {;         return 0;;     }; ;     public PeriodType getPeriodType() {;         return PeriodType.time();;     }; }
public int getValue(int index) { [EOL]     return iValues[index]; [EOL] } protected BasePeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis, PeriodType type); protected BasePeriod(long startInstant, long endInstant, PeriodType type, Chronology chrono); protected BasePeriod(ReadableInstant startInstant, ReadableInstant endInstant, PeriodType type); protected BasePeriod(ReadablePartial start, ReadablePartial end, PeriodType type); protected BasePeriod(ReadableInstant startInstant, ReadableDuration duration, PeriodType type); protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, PeriodType type); protected BasePeriod(long duration); protected BasePeriod(long duration, PeriodType type, Chronology chrono); protected BasePeriod(Object period, PeriodType type, Chronology chrono); protected BasePeriod(int[] values, PeriodType type); public int getValue(int index); public PeriodType getPeriodType(); protected PeriodType checkPeriodType(PeriodType type); public PeriodType getPeriodType(); public int getValue(int index); public Duration toDurationFrom(ReadableInstant startInstant); public Duration toDurationTo(ReadableInstant endInstant); private void checkAndUpdate(DurationFieldType type, int[] values, int newValue); protected void setPeriod(ReadablePeriod period); private void setPeriodInternal(ReadablePeriod period); protected void setPeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); private int[] setPeriodInternal(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); protected void setField(DurationFieldType field, int value); protected void setFieldInto(int[] values, DurationFieldType field, int value); protected void addField(DurationFieldType field, int value); protected void addFieldInto(int[] values, DurationFieldType field, int value); protected void mergePeriod(ReadablePeriod period); protected int[] mergePeriodInto(int[] values, ReadablePeriod period); protected void addPeriod(ReadablePeriod period); protected int[] addPeriodInto(int[] values, ReadablePeriod period); protected void setValue(int index, int value); protected void setValues(int[] values); long serialVersionUID=Optional[-2110953284060001145L]; ReadablePeriod DUMMY_PERIOD=Optional[new AbstractPeriod() {; ;     public int getValue(int index) {;         return 0;;     }; ;     public PeriodType getPeriodType() {;         return PeriodType.time();;     }; }
public int getValue(int index) { [EOL]     return iValues[index]; [EOL] } protected BasePeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis, PeriodType type); protected BasePeriod(long startInstant, long endInstant, PeriodType type, Chronology chrono); protected BasePeriod(ReadableInstant startInstant, ReadableInstant endInstant, PeriodType type); protected BasePeriod(ReadablePartial start, ReadablePartial end, PeriodType type); protected BasePeriod(ReadableInstant startInstant, ReadableDuration duration, PeriodType type); protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, PeriodType type); protected BasePeriod(long duration); protected BasePeriod(long duration, PeriodType type, Chronology chrono); protected BasePeriod(Object period, PeriodType type, Chronology chrono); protected BasePeriod(int[] values, PeriodType type); public int getValue(int index); public PeriodType getPeriodType(); protected PeriodType checkPeriodType(PeriodType type); public PeriodType getPeriodType(); public int getValue(int index); public Duration toDurationFrom(ReadableInstant startInstant); public Duration toDurationTo(ReadableInstant endInstant); private void checkAndUpdate(DurationFieldType type, int[] values, int newValue); protected void setPeriod(ReadablePeriod period); private void setPeriodInternal(ReadablePeriod period); protected void setPeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); private int[] setPeriodInternal(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); protected void setField(DurationFieldType field, int value); protected void setFieldInto(int[] values, DurationFieldType field, int value); protected void addField(DurationFieldType field, int value); protected void addFieldInto(int[] values, DurationFieldType field, int value); protected void mergePeriod(ReadablePeriod period); protected int[] mergePeriodInto(int[] values, ReadablePeriod period); protected void addPeriod(ReadablePeriod period); protected int[] addPeriodInto(int[] values, ReadablePeriod period); protected void setValue(int index, int value); protected void setValues(int[] values); long serialVersionUID=Optional[-2110953284060001145L]; ReadablePeriod DUMMY_PERIOD=Optional[new AbstractPeriod() {; ;     public int getValue(int index) {;         return 0;;     }; ;     public PeriodType getPeriodType() {;         return PeriodType.time();;     }; }
protected void setPeriod(ReadablePeriod period) { [EOL]     if (period == null) { [EOL]         setValues(new int[size()]); [EOL]     } else { [EOL]         setPeriodInternal(period); [EOL]     } [EOL] } protected BasePeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis, PeriodType type); protected BasePeriod(long startInstant, long endInstant, PeriodType type, Chronology chrono); protected BasePeriod(ReadableInstant startInstant, ReadableInstant endInstant, PeriodType type); protected BasePeriod(ReadablePartial start, ReadablePartial end, PeriodType type); protected BasePeriod(ReadableInstant startInstant, ReadableDuration duration, PeriodType type); protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, PeriodType type); protected BasePeriod(long duration); protected BasePeriod(long duration, PeriodType type, Chronology chrono); protected BasePeriod(Object period, PeriodType type, Chronology chrono); protected BasePeriod(int[] values, PeriodType type); public int getValue(int index); public PeriodType getPeriodType(); protected PeriodType checkPeriodType(PeriodType type); public PeriodType getPeriodType(); public int getValue(int index); public Duration toDurationFrom(ReadableInstant startInstant); public Duration toDurationTo(ReadableInstant endInstant); private void checkAndUpdate(DurationFieldType type, int[] values, int newValue); protected void setPeriod(ReadablePeriod period); private void setPeriodInternal(ReadablePeriod period); protected void setPeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); private int[] setPeriodInternal(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); protected void setField(DurationFieldType field, int value); protected void setFieldInto(int[] values, DurationFieldType field, int value); protected void addField(DurationFieldType field, int value); protected void addFieldInto(int[] values, DurationFieldType field, int value); protected void mergePeriod(ReadablePeriod period); protected int[] mergePeriodInto(int[] values, ReadablePeriod period); protected void addPeriod(ReadablePeriod period); protected int[] addPeriodInto(int[] values, ReadablePeriod period); protected void setValue(int index, int value); protected void setValues(int[] values); long serialVersionUID=Optional[-2110953284060001145L]; ReadablePeriod DUMMY_PERIOD=Optional[new AbstractPeriod() {; ;     public int getValue(int index) {;         return 0;;     }; ;     public PeriodType getPeriodType() {;         return PeriodType.time();;     }; }
protected void addField(DurationFieldType field, int value) { [EOL]     addFieldInto(iValues, field, value); [EOL] } protected BasePeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis, PeriodType type); protected BasePeriod(long startInstant, long endInstant, PeriodType type, Chronology chrono); protected BasePeriod(ReadableInstant startInstant, ReadableInstant endInstant, PeriodType type); protected BasePeriod(ReadablePartial start, ReadablePartial end, PeriodType type); protected BasePeriod(ReadableInstant startInstant, ReadableDuration duration, PeriodType type); protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, PeriodType type); protected BasePeriod(long duration); protected BasePeriod(long duration, PeriodType type, Chronology chrono); protected BasePeriod(Object period, PeriodType type, Chronology chrono); protected BasePeriod(int[] values, PeriodType type); public int getValue(int index); public PeriodType getPeriodType(); protected PeriodType checkPeriodType(PeriodType type); public PeriodType getPeriodType(); public int getValue(int index); public Duration toDurationFrom(ReadableInstant startInstant); public Duration toDurationTo(ReadableInstant endInstant); private void checkAndUpdate(DurationFieldType type, int[] values, int newValue); protected void setPeriod(ReadablePeriod period); private void setPeriodInternal(ReadablePeriod period); protected void setPeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); private int[] setPeriodInternal(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); protected void setField(DurationFieldType field, int value); protected void setFieldInto(int[] values, DurationFieldType field, int value); protected void addField(DurationFieldType field, int value); protected void addFieldInto(int[] values, DurationFieldType field, int value); protected void mergePeriod(ReadablePeriod period); protected int[] mergePeriodInto(int[] values, ReadablePeriod period); protected void addPeriod(ReadablePeriod period); protected int[] addPeriodInto(int[] values, ReadablePeriod period); protected void setValue(int index, int value); protected void setValues(int[] values); long serialVersionUID=Optional[-2110953284060001145L]; ReadablePeriod DUMMY_PERIOD=Optional[new AbstractPeriod() {; ;     public int getValue(int index) {;         return 0;;     }; ;     public PeriodType getPeriodType() {;         return PeriodType.time();;     }; }
protected void addFieldInto(int[] values, DurationFieldType field, int value) { [EOL]     int index = indexOf(field); [EOL]     if (index == -1) { [EOL]         if (value != 0 || field == null) { [EOL]             throw new IllegalArgumentException("Period does not support field '" + field + "'"); [EOL]         } [EOL]     } else { [EOL]         values[index] = FieldUtils.safeAdd(values[index], value); [EOL]     } [EOL] } protected BasePeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis, PeriodType type); protected BasePeriod(long startInstant, long endInstant, PeriodType type, Chronology chrono); protected BasePeriod(ReadableInstant startInstant, ReadableInstant endInstant, PeriodType type); protected BasePeriod(ReadablePartial start, ReadablePartial end, PeriodType type); protected BasePeriod(ReadableInstant startInstant, ReadableDuration duration, PeriodType type); protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, PeriodType type); protected BasePeriod(long duration); protected BasePeriod(long duration, PeriodType type, Chronology chrono); protected BasePeriod(Object period, PeriodType type, Chronology chrono); protected BasePeriod(int[] values, PeriodType type); public int getValue(int index); public PeriodType getPeriodType(); protected PeriodType checkPeriodType(PeriodType type); public PeriodType getPeriodType(); public int getValue(int index); public Duration toDurationFrom(ReadableInstant startInstant); public Duration toDurationTo(ReadableInstant endInstant); private void checkAndUpdate(DurationFieldType type, int[] values, int newValue); protected void setPeriod(ReadablePeriod period); private void setPeriodInternal(ReadablePeriod period); protected void setPeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); private int[] setPeriodInternal(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); protected void setField(DurationFieldType field, int value); protected void setFieldInto(int[] values, DurationFieldType field, int value); protected void addField(DurationFieldType field, int value); protected void addFieldInto(int[] values, DurationFieldType field, int value); protected void mergePeriod(ReadablePeriod period); protected int[] mergePeriodInto(int[] values, ReadablePeriod period); protected void addPeriod(ReadablePeriod period); protected int[] addPeriodInto(int[] values, ReadablePeriod period); protected void setValue(int index, int value); protected void setValues(int[] values); long serialVersionUID=Optional[-2110953284060001145L]; ReadablePeriod DUMMY_PERIOD=Optional[new AbstractPeriod() {; ;     public int getValue(int index) {;         return 0;;     }; ;     public PeriodType getPeriodType() {;         return PeriodType.time();;     }; }
protected void setValue(int index, int value) { [EOL]     iValues[index] = value; [EOL] } protected BasePeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis, PeriodType type); protected BasePeriod(long startInstant, long endInstant, PeriodType type, Chronology chrono); protected BasePeriod(ReadableInstant startInstant, ReadableInstant endInstant, PeriodType type); protected BasePeriod(ReadablePartial start, ReadablePartial end, PeriodType type); protected BasePeriod(ReadableInstant startInstant, ReadableDuration duration, PeriodType type); protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, PeriodType type); protected BasePeriod(long duration); protected BasePeriod(long duration, PeriodType type, Chronology chrono); protected BasePeriod(Object period, PeriodType type, Chronology chrono); protected BasePeriod(int[] values, PeriodType type); public int getValue(int index); public PeriodType getPeriodType(); protected PeriodType checkPeriodType(PeriodType type); public PeriodType getPeriodType(); public int getValue(int index); public Duration toDurationFrom(ReadableInstant startInstant); public Duration toDurationTo(ReadableInstant endInstant); private void checkAndUpdate(DurationFieldType type, int[] values, int newValue); protected void setPeriod(ReadablePeriod period); private void setPeriodInternal(ReadablePeriod period); protected void setPeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); private int[] setPeriodInternal(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); protected void setField(DurationFieldType field, int value); protected void setFieldInto(int[] values, DurationFieldType field, int value); protected void addField(DurationFieldType field, int value); protected void addFieldInto(int[] values, DurationFieldType field, int value); protected void mergePeriod(ReadablePeriod period); protected int[] mergePeriodInto(int[] values, ReadablePeriod period); protected void addPeriod(ReadablePeriod period); protected int[] addPeriodInto(int[] values, ReadablePeriod period); protected void setValue(int index, int value); protected void setValues(int[] values); long serialVersionUID=Optional[-2110953284060001145L]; ReadablePeriod DUMMY_PERIOD=Optional[new AbstractPeriod() {; ;     public int getValue(int index) {;         return 0;;     }; ;     public PeriodType getPeriodType() {;         return PeriodType.time();;     }; }
protected ISODateTimeFormat() { [EOL]     super(); [EOL] }
public static DateTimeFormatter forFields(Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO) { [EOL]     if (fields == null || fields.size() == 0) { [EOL]         throw new IllegalArgumentException("The fields must not be null or empty"); [EOL]     } [EOL]     Set<DateTimeFieldType> workingFields = new HashSet<DateTimeFieldType>(fields); [EOL]     int inputSize = workingFields.size(); [EOL]     boolean reducedPrec = false; [EOL]     DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL]     if (workingFields.contains(DateTimeFieldType.monthOfYear())) { [EOL]         reducedPrec = dateByMonth(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfYear())) { [EOL]         reducedPrec = dateByOrdinal(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.weekOfWeekyear())) { [EOL]         reducedPrec = dateByWeek(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfMonth())) { [EOL]         reducedPrec = dateByMonth(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfWeek())) { [EOL]         reducedPrec = dateByWeek(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.remove(DateTimeFieldType.year())) { [EOL]         bld.append(Constants.ye); [EOL]         reducedPrec = true; [EOL]     } else if (workingFields.remove(DateTimeFieldType.weekyear())) { [EOL]         bld.append(Constants.we); [EOL]         reducedPrec = true; [EOL]     } [EOL]     boolean datePresent = (workingFields.size() < inputSize); [EOL]     time(bld, workingFields, extended, strictISO, reducedPrec, datePresent); [EOL]     if (bld.canBuildFormatter() == false) { [EOL]         throw new IllegalArgumentException("No valid format for fields: " + fields); [EOL]     } [EOL]     try { [EOL]         fields.retainAll(workingFields); [EOL]     } catch (UnsupportedOperationException ex) { [EOL]     } [EOL]     return bld.toFormatter(); [EOL] }
public static DateTimeFormatter forFields(Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO) { [EOL]     if (fields == null || fields.size() == 0) { [EOL]         throw new IllegalArgumentException("The fields must not be null or empty"); [EOL]     } [EOL]     Set<DateTimeFieldType> workingFields = new HashSet<DateTimeFieldType>(fields); [EOL]     int inputSize = workingFields.size(); [EOL]     boolean reducedPrec = false; [EOL]     DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL]     if (workingFields.contains(DateTimeFieldType.monthOfYear())) { [EOL]         reducedPrec = dateByMonth(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfYear())) { [EOL]         reducedPrec = dateByOrdinal(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.weekOfWeekyear())) { [EOL]         reducedPrec = dateByWeek(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfMonth())) { [EOL]         reducedPrec = dateByMonth(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfWeek())) { [EOL]         reducedPrec = dateByWeek(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.remove(DateTimeFieldType.year())) { [EOL]         bld.append(Constants.ye); [EOL]         reducedPrec = true; [EOL]     } else if (workingFields.remove(DateTimeFieldType.weekyear())) { [EOL]         bld.append(Constants.we); [EOL]         reducedPrec = true; [EOL]     } [EOL]     boolean datePresent = (workingFields.size() < inputSize); [EOL]     time(bld, workingFields, extended, strictISO, reducedPrec, datePresent); [EOL]     if (bld.canBuildFormatter() == false) { [EOL]         throw new IllegalArgumentException("No valid format for fields: " + fields); [EOL]     } [EOL]     try { [EOL]         fields.retainAll(workingFields); [EOL]     } catch (UnsupportedOperationException ex) { [EOL]     } [EOL]     return bld.toFormatter(); [EOL] }
public static DateTimeFormatter forFields(Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO) { [EOL]     if (fields == null || fields.size() == 0) { [EOL]         throw new IllegalArgumentException("The fields must not be null or empty"); [EOL]     } [EOL]     Set<DateTimeFieldType> workingFields = new HashSet<DateTimeFieldType>(fields); [EOL]     int inputSize = workingFields.size(); [EOL]     boolean reducedPrec = false; [EOL]     DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL]     if (workingFields.contains(DateTimeFieldType.monthOfYear())) { [EOL]         reducedPrec = dateByMonth(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfYear())) { [EOL]         reducedPrec = dateByOrdinal(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.weekOfWeekyear())) { [EOL]         reducedPrec = dateByWeek(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfMonth())) { [EOL]         reducedPrec = dateByMonth(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfWeek())) { [EOL]         reducedPrec = dateByWeek(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.remove(DateTimeFieldType.year())) { [EOL]         bld.append(Constants.ye); [EOL]         reducedPrec = true; [EOL]     } else if (workingFields.remove(DateTimeFieldType.weekyear())) { [EOL]         bld.append(Constants.we); [EOL]         reducedPrec = true; [EOL]     } [EOL]     boolean datePresent = (workingFields.size() < inputSize); [EOL]     time(bld, workingFields, extended, strictISO, reducedPrec, datePresent); [EOL]     if (bld.canBuildFormatter() == false) { [EOL]         throw new IllegalArgumentException("No valid format for fields: " + fields); [EOL]     } [EOL]     try { [EOL]         fields.retainAll(workingFields); [EOL]     } catch (UnsupportedOperationException ex) { [EOL]     } [EOL]     return bld.toFormatter(); [EOL] }
public static DateTimeFormatter forFields(Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO) { [EOL]     if (fields == null || fields.size() == 0) { [EOL]         throw new IllegalArgumentException("The fields must not be null or empty"); [EOL]     } [EOL]     Set<DateTimeFieldType> workingFields = new HashSet<DateTimeFieldType>(fields); [EOL]     int inputSize = workingFields.size(); [EOL]     boolean reducedPrec = false; [EOL]     DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL]     if (workingFields.contains(DateTimeFieldType.monthOfYear())) { [EOL]         reducedPrec = dateByMonth(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfYear())) { [EOL]         reducedPrec = dateByOrdinal(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.weekOfWeekyear())) { [EOL]         reducedPrec = dateByWeek(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfMonth())) { [EOL]         reducedPrec = dateByMonth(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfWeek())) { [EOL]         reducedPrec = dateByWeek(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.remove(DateTimeFieldType.year())) { [EOL]         bld.append(Constants.ye); [EOL]         reducedPrec = true; [EOL]     } else if (workingFields.remove(DateTimeFieldType.weekyear())) { [EOL]         bld.append(Constants.we); [EOL]         reducedPrec = true; [EOL]     } [EOL]     boolean datePresent = (workingFields.size() < inputSize); [EOL]     time(bld, workingFields, extended, strictISO, reducedPrec, datePresent); [EOL]     if (bld.canBuildFormatter() == false) { [EOL]         throw new IllegalArgumentException("No valid format for fields: " + fields); [EOL]     } [EOL]     try { [EOL]         fields.retainAll(workingFields); [EOL]     } catch (UnsupportedOperationException ex) { [EOL]     } [EOL]     return bld.toFormatter(); [EOL] }
public static DateTimeFormatter forFields(Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO) { [EOL]     if (fields == null || fields.size() == 0) { [EOL]         throw new IllegalArgumentException("The fields must not be null or empty"); [EOL]     } [EOL]     Set<DateTimeFieldType> workingFields = new HashSet<DateTimeFieldType>(fields); [EOL]     int inputSize = workingFields.size(); [EOL]     boolean reducedPrec = false; [EOL]     DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL]     if (workingFields.contains(DateTimeFieldType.monthOfYear())) { [EOL]         reducedPrec = dateByMonth(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfYear())) { [EOL]         reducedPrec = dateByOrdinal(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.weekOfWeekyear())) { [EOL]         reducedPrec = dateByWeek(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfMonth())) { [EOL]         reducedPrec = dateByMonth(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfWeek())) { [EOL]         reducedPrec = dateByWeek(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.remove(DateTimeFieldType.year())) { [EOL]         bld.append(Constants.ye); [EOL]         reducedPrec = true; [EOL]     } else if (workingFields.remove(DateTimeFieldType.weekyear())) { [EOL]         bld.append(Constants.we); [EOL]         reducedPrec = true; [EOL]     } [EOL]     boolean datePresent = (workingFields.size() < inputSize); [EOL]     time(bld, workingFields, extended, strictISO, reducedPrec, datePresent); [EOL]     if (bld.canBuildFormatter() == false) { [EOL]         throw new IllegalArgumentException("No valid format for fields: " + fields); [EOL]     } [EOL]     try { [EOL]         fields.retainAll(workingFields); [EOL]     } catch (UnsupportedOperationException ex) { [EOL]     } [EOL]     return bld.toFormatter(); [EOL] }
public static DateTimeFormatter forFields(Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO) { [EOL]     if (fields == null || fields.size() == 0) { [EOL]         throw new IllegalArgumentException("The fields must not be null or empty"); [EOL]     } [EOL]     Set<DateTimeFieldType> workingFields = new HashSet<DateTimeFieldType>(fields); [EOL]     int inputSize = workingFields.size(); [EOL]     boolean reducedPrec = false; [EOL]     DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL]     if (workingFields.contains(DateTimeFieldType.monthOfYear())) { [EOL]         reducedPrec = dateByMonth(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfYear())) { [EOL]         reducedPrec = dateByOrdinal(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.weekOfWeekyear())) { [EOL]         reducedPrec = dateByWeek(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfMonth())) { [EOL]         reducedPrec = dateByMonth(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfWeek())) { [EOL]         reducedPrec = dateByWeek(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.remove(DateTimeFieldType.year())) { [EOL]         bld.append(Constants.ye); [EOL]         reducedPrec = true; [EOL]     } else if (workingFields.remove(DateTimeFieldType.weekyear())) { [EOL]         bld.append(Constants.we); [EOL]         reducedPrec = true; [EOL]     } [EOL]     boolean datePresent = (workingFields.size() < inputSize); [EOL]     time(bld, workingFields, extended, strictISO, reducedPrec, datePresent); [EOL]     if (bld.canBuildFormatter() == false) { [EOL]         throw new IllegalArgumentException("No valid format for fields: " + fields); [EOL]     } [EOL]     try { [EOL]         fields.retainAll(workingFields); [EOL]     } catch (UnsupportedOperationException ex) { [EOL]     } [EOL]     return bld.toFormatter(); [EOL] }
public static DateTimeFormatter forFields(Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO) { [EOL]     if (fields == null || fields.size() == 0) { [EOL]         throw new IllegalArgumentException("The fields must not be null or empty"); [EOL]     } [EOL]     Set<DateTimeFieldType> workingFields = new HashSet<DateTimeFieldType>(fields); [EOL]     int inputSize = workingFields.size(); [EOL]     boolean reducedPrec = false; [EOL]     DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL]     if (workingFields.contains(DateTimeFieldType.monthOfYear())) { [EOL]         reducedPrec = dateByMonth(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfYear())) { [EOL]         reducedPrec = dateByOrdinal(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.weekOfWeekyear())) { [EOL]         reducedPrec = dateByWeek(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfMonth())) { [EOL]         reducedPrec = dateByMonth(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfWeek())) { [EOL]         reducedPrec = dateByWeek(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.remove(DateTimeFieldType.year())) { [EOL]         bld.append(Constants.ye); [EOL]         reducedPrec = true; [EOL]     } else if (workingFields.remove(DateTimeFieldType.weekyear())) { [EOL]         bld.append(Constants.we); [EOL]         reducedPrec = true; [EOL]     } [EOL]     boolean datePresent = (workingFields.size() < inputSize); [EOL]     time(bld, workingFields, extended, strictISO, reducedPrec, datePresent); [EOL]     if (bld.canBuildFormatter() == false) { [EOL]         throw new IllegalArgumentException("No valid format for fields: " + fields); [EOL]     } [EOL]     try { [EOL]         fields.retainAll(workingFields); [EOL]     } catch (UnsupportedOperationException ex) { [EOL]     } [EOL]     return bld.toFormatter(); [EOL] }
public static DateTimeFormatter forFields(Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO) { [EOL]     if (fields == null || fields.size() == 0) { [EOL]         throw new IllegalArgumentException("The fields must not be null or empty"); [EOL]     } [EOL]     Set<DateTimeFieldType> workingFields = new HashSet<DateTimeFieldType>(fields); [EOL]     int inputSize = workingFields.size(); [EOL]     boolean reducedPrec = false; [EOL]     DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL]     if (workingFields.contains(DateTimeFieldType.monthOfYear())) { [EOL]         reducedPrec = dateByMonth(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfYear())) { [EOL]         reducedPrec = dateByOrdinal(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.weekOfWeekyear())) { [EOL]         reducedPrec = dateByWeek(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfMonth())) { [EOL]         reducedPrec = dateByMonth(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfWeek())) { [EOL]         reducedPrec = dateByWeek(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.remove(DateTimeFieldType.year())) { [EOL]         bld.append(Constants.ye); [EOL]         reducedPrec = true; [EOL]     } else if (workingFields.remove(DateTimeFieldType.weekyear())) { [EOL]         bld.append(Constants.we); [EOL]         reducedPrec = true; [EOL]     } [EOL]     boolean datePresent = (workingFields.size() < inputSize); [EOL]     time(bld, workingFields, extended, strictISO, reducedPrec, datePresent); [EOL]     if (bld.canBuildFormatter() == false) { [EOL]         throw new IllegalArgumentException("No valid format for fields: " + fields); [EOL]     } [EOL]     try { [EOL]         fields.retainAll(workingFields); [EOL]     } catch (UnsupportedOperationException ex) { [EOL]     } [EOL]     return bld.toFormatter(); [EOL] }
public static DateTimeFormatter forFields(Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO) { [EOL]     if (fields == null || fields.size() == 0) { [EOL]         throw new IllegalArgumentException("The fields must not be null or empty"); [EOL]     } [EOL]     Set<DateTimeFieldType> workingFields = new HashSet<DateTimeFieldType>(fields); [EOL]     int inputSize = workingFields.size(); [EOL]     boolean reducedPrec = false; [EOL]     DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL]     if (workingFields.contains(DateTimeFieldType.monthOfYear())) { [EOL]         reducedPrec = dateByMonth(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfYear())) { [EOL]         reducedPrec = dateByOrdinal(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.weekOfWeekyear())) { [EOL]         reducedPrec = dateByWeek(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfMonth())) { [EOL]         reducedPrec = dateByMonth(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfWeek())) { [EOL]         reducedPrec = dateByWeek(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.remove(DateTimeFieldType.year())) { [EOL]         bld.append(Constants.ye); [EOL]         reducedPrec = true; [EOL]     } else if (workingFields.remove(DateTimeFieldType.weekyear())) { [EOL]         bld.append(Constants.we); [EOL]         reducedPrec = true; [EOL]     } [EOL]     boolean datePresent = (workingFields.size() < inputSize); [EOL]     time(bld, workingFields, extended, strictISO, reducedPrec, datePresent); [EOL]     if (bld.canBuildFormatter() == false) { [EOL]         throw new IllegalArgumentException("No valid format for fields: " + fields); [EOL]     } [EOL]     try { [EOL]         fields.retainAll(workingFields); [EOL]     } catch (UnsupportedOperationException ex) { [EOL]     } [EOL]     return bld.toFormatter(); [EOL] }
public static DateTimeFormatter forFields(Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO) { [EOL]     if (fields == null || fields.size() == 0) { [EOL]         throw new IllegalArgumentException("The fields must not be null or empty"); [EOL]     } [EOL]     Set<DateTimeFieldType> workingFields = new HashSet<DateTimeFieldType>(fields); [EOL]     int inputSize = workingFields.size(); [EOL]     boolean reducedPrec = false; [EOL]     DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL]     if (workingFields.contains(DateTimeFieldType.monthOfYear())) { [EOL]         reducedPrec = dateByMonth(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfYear())) { [EOL]         reducedPrec = dateByOrdinal(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.weekOfWeekyear())) { [EOL]         reducedPrec = dateByWeek(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfMonth())) { [EOL]         reducedPrec = dateByMonth(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfWeek())) { [EOL]         reducedPrec = dateByWeek(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.remove(DateTimeFieldType.year())) { [EOL]         bld.append(Constants.ye); [EOL]         reducedPrec = true; [EOL]     } else if (workingFields.remove(DateTimeFieldType.weekyear())) { [EOL]         bld.append(Constants.we); [EOL]         reducedPrec = true; [EOL]     } [EOL]     boolean datePresent = (workingFields.size() < inputSize); [EOL]     time(bld, workingFields, extended, strictISO, reducedPrec, datePresent); [EOL]     if (bld.canBuildFormatter() == false) { [EOL]         throw new IllegalArgumentException("No valid format for fields: " + fields); [EOL]     } [EOL]     try { [EOL]         fields.retainAll(workingFields); [EOL]     } catch (UnsupportedOperationException ex) { [EOL]     } [EOL]     return bld.toFormatter(); [EOL] }
public static DateTimeFormatter forFields(Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO) { [EOL]     if (fields == null || fields.size() == 0) { [EOL]         throw new IllegalArgumentException("The fields must not be null or empty"); [EOL]     } [EOL]     Set<DateTimeFieldType> workingFields = new HashSet<DateTimeFieldType>(fields); [EOL]     int inputSize = workingFields.size(); [EOL]     boolean reducedPrec = false; [EOL]     DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL]     if (workingFields.contains(DateTimeFieldType.monthOfYear())) { [EOL]         reducedPrec = dateByMonth(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfYear())) { [EOL]         reducedPrec = dateByOrdinal(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.weekOfWeekyear())) { [EOL]         reducedPrec = dateByWeek(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfMonth())) { [EOL]         reducedPrec = dateByMonth(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfWeek())) { [EOL]         reducedPrec = dateByWeek(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.remove(DateTimeFieldType.year())) { [EOL]         bld.append(Constants.ye); [EOL]         reducedPrec = true; [EOL]     } else if (workingFields.remove(DateTimeFieldType.weekyear())) { [EOL]         bld.append(Constants.we); [EOL]         reducedPrec = true; [EOL]     } [EOL]     boolean datePresent = (workingFields.size() < inputSize); [EOL]     time(bld, workingFields, extended, strictISO, reducedPrec, datePresent); [EOL]     if (bld.canBuildFormatter() == false) { [EOL]         throw new IllegalArgumentException("No valid format for fields: " + fields); [EOL]     } [EOL]     try { [EOL]         fields.retainAll(workingFields); [EOL]     } catch (UnsupportedOperationException ex) { [EOL]     } [EOL]     return bld.toFormatter(); [EOL] }
private static boolean dateByMonth(DateTimeFormatterBuilder bld, Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO) { [EOL]     boolean reducedPrec = false; [EOL]     if (fields.remove(DateTimeFieldType.year())) { [EOL]         bld.append(Constants.ye); [EOL]         if (fields.remove(DateTimeFieldType.monthOfYear())) { [EOL]             if (fields.remove(DateTimeFieldType.dayOfMonth())) { [EOL]                 appendSeparator(bld, extended); [EOL]                 bld.appendMonthOfYear(2); [EOL]                 appendSeparator(bld, extended); [EOL]                 bld.appendDayOfMonth(2); [EOL]             } else { [EOL]                 bld.appendLiteral('-'); [EOL]                 bld.appendMonthOfYear(2); [EOL]                 reducedPrec = true; [EOL]             } [EOL]         } else { [EOL]             if (fields.remove(DateTimeFieldType.dayOfMonth())) { [EOL]                 checkNotStrictISO(fields, strictISO); [EOL]                 bld.appendLiteral('-'); [EOL]                 bld.appendLiteral('-'); [EOL]                 bld.appendDayOfMonth(2); [EOL]             } else { [EOL]                 reducedPrec = true; [EOL]             } [EOL]         } [EOL]     } else if (fields.remove(DateTimeFieldType.monthOfYear())) { [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendMonthOfYear(2); [EOL]         if (fields.remove(DateTimeFieldType.dayOfMonth())) { [EOL]             appendSeparator(bld, extended); [EOL]             bld.appendDayOfMonth(2); [EOL]         } else { [EOL]             reducedPrec = true; [EOL]         } [EOL]     } else if (fields.remove(DateTimeFieldType.dayOfMonth())) { [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendDayOfMonth(2); [EOL]     } [EOL]     return reducedPrec; [EOL] }
private static boolean dateByMonth(DateTimeFormatterBuilder bld, Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO) { [EOL]     boolean reducedPrec = false; [EOL]     if (fields.remove(DateTimeFieldType.year())) { [EOL]         bld.append(Constants.ye); [EOL]         if (fields.remove(DateTimeFieldType.monthOfYear())) { [EOL]             if (fields.remove(DateTimeFieldType.dayOfMonth())) { [EOL]                 appendSeparator(bld, extended); [EOL]                 bld.appendMonthOfYear(2); [EOL]                 appendSeparator(bld, extended); [EOL]                 bld.appendDayOfMonth(2); [EOL]             } else { [EOL]                 bld.appendLiteral('-'); [EOL]                 bld.appendMonthOfYear(2); [EOL]                 reducedPrec = true; [EOL]             } [EOL]         } else { [EOL]             if (fields.remove(DateTimeFieldType.dayOfMonth())) { [EOL]                 checkNotStrictISO(fields, strictISO); [EOL]                 bld.appendLiteral('-'); [EOL]                 bld.appendLiteral('-'); [EOL]                 bld.appendDayOfMonth(2); [EOL]             } else { [EOL]                 reducedPrec = true; [EOL]             } [EOL]         } [EOL]     } else if (fields.remove(DateTimeFieldType.monthOfYear())) { [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendMonthOfYear(2); [EOL]         if (fields.remove(DateTimeFieldType.dayOfMonth())) { [EOL]             appendSeparator(bld, extended); [EOL]             bld.appendDayOfMonth(2); [EOL]         } else { [EOL]             reducedPrec = true; [EOL]         } [EOL]     } else if (fields.remove(DateTimeFieldType.dayOfMonth())) { [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendDayOfMonth(2); [EOL]     } [EOL]     return reducedPrec; [EOL] }
private static boolean dateByMonth(DateTimeFormatterBuilder bld, Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO) { [EOL]     boolean reducedPrec = false; [EOL]     if (fields.remove(DateTimeFieldType.year())) { [EOL]         bld.append(Constants.ye); [EOL]         if (fields.remove(DateTimeFieldType.monthOfYear())) { [EOL]             if (fields.remove(DateTimeFieldType.dayOfMonth())) { [EOL]                 appendSeparator(bld, extended); [EOL]                 bld.appendMonthOfYear(2); [EOL]                 appendSeparator(bld, extended); [EOL]                 bld.appendDayOfMonth(2); [EOL]             } else { [EOL]                 bld.appendLiteral('-'); [EOL]                 bld.appendMonthOfYear(2); [EOL]                 reducedPrec = true; [EOL]             } [EOL]         } else { [EOL]             if (fields.remove(DateTimeFieldType.dayOfMonth())) { [EOL]                 checkNotStrictISO(fields, strictISO); [EOL]                 bld.appendLiteral('-'); [EOL]                 bld.appendLiteral('-'); [EOL]                 bld.appendDayOfMonth(2); [EOL]             } else { [EOL]                 reducedPrec = true; [EOL]             } [EOL]         } [EOL]     } else if (fields.remove(DateTimeFieldType.monthOfYear())) { [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendMonthOfYear(2); [EOL]         if (fields.remove(DateTimeFieldType.dayOfMonth())) { [EOL]             appendSeparator(bld, extended); [EOL]             bld.appendDayOfMonth(2); [EOL]         } else { [EOL]             reducedPrec = true; [EOL]         } [EOL]     } else if (fields.remove(DateTimeFieldType.dayOfMonth())) { [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendDayOfMonth(2); [EOL]     } [EOL]     return reducedPrec; [EOL] }
private static boolean dateByMonth(DateTimeFormatterBuilder bld, Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO) { [EOL]     boolean reducedPrec = false; [EOL]     if (fields.remove(DateTimeFieldType.year())) { [EOL]         bld.append(Constants.ye); [EOL]         if (fields.remove(DateTimeFieldType.monthOfYear())) { [EOL]             if (fields.remove(DateTimeFieldType.dayOfMonth())) { [EOL]                 appendSeparator(bld, extended); [EOL]                 bld.appendMonthOfYear(2); [EOL]                 appendSeparator(bld, extended); [EOL]                 bld.appendDayOfMonth(2); [EOL]             } else { [EOL]                 bld.appendLiteral('-'); [EOL]                 bld.appendMonthOfYear(2); [EOL]                 reducedPrec = true; [EOL]             } [EOL]         } else { [EOL]             if (fields.remove(DateTimeFieldType.dayOfMonth())) { [EOL]                 checkNotStrictISO(fields, strictISO); [EOL]                 bld.appendLiteral('-'); [EOL]                 bld.appendLiteral('-'); [EOL]                 bld.appendDayOfMonth(2); [EOL]             } else { [EOL]                 reducedPrec = true; [EOL]             } [EOL]         } [EOL]     } else if (fields.remove(DateTimeFieldType.monthOfYear())) { [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendMonthOfYear(2); [EOL]         if (fields.remove(DateTimeFieldType.dayOfMonth())) { [EOL]             appendSeparator(bld, extended); [EOL]             bld.appendDayOfMonth(2); [EOL]         } else { [EOL]             reducedPrec = true; [EOL]         } [EOL]     } else if (fields.remove(DateTimeFieldType.dayOfMonth())) { [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendDayOfMonth(2); [EOL]     } [EOL]     return reducedPrec; [EOL] }
private static boolean dateByMonth(DateTimeFormatterBuilder bld, Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO) { [EOL]     boolean reducedPrec = false; [EOL]     if (fields.remove(DateTimeFieldType.year())) { [EOL]         bld.append(Constants.ye); [EOL]         if (fields.remove(DateTimeFieldType.monthOfYear())) { [EOL]             if (fields.remove(DateTimeFieldType.dayOfMonth())) { [EOL]                 appendSeparator(bld, extended); [EOL]                 bld.appendMonthOfYear(2); [EOL]                 appendSeparator(bld, extended); [EOL]                 bld.appendDayOfMonth(2); [EOL]             } else { [EOL]                 bld.appendLiteral('-'); [EOL]                 bld.appendMonthOfYear(2); [EOL]                 reducedPrec = true; [EOL]             } [EOL]         } else { [EOL]             if (fields.remove(DateTimeFieldType.dayOfMonth())) { [EOL]                 checkNotStrictISO(fields, strictISO); [EOL]                 bld.appendLiteral('-'); [EOL]                 bld.appendLiteral('-'); [EOL]                 bld.appendDayOfMonth(2); [EOL]             } else { [EOL]                 reducedPrec = true; [EOL]             } [EOL]         } [EOL]     } else if (fields.remove(DateTimeFieldType.monthOfYear())) { [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendMonthOfYear(2); [EOL]         if (fields.remove(DateTimeFieldType.dayOfMonth())) { [EOL]             appendSeparator(bld, extended); [EOL]             bld.appendDayOfMonth(2); [EOL]         } else { [EOL]             reducedPrec = true; [EOL]         } [EOL]     } else if (fields.remove(DateTimeFieldType.dayOfMonth())) { [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendDayOfMonth(2); [EOL]     } [EOL]     return reducedPrec; [EOL] }
private static boolean dateByMonth(DateTimeFormatterBuilder bld, Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO) { [EOL]     boolean reducedPrec = false; [EOL]     if (fields.remove(DateTimeFieldType.year())) { [EOL]         bld.append(Constants.ye); [EOL]         if (fields.remove(DateTimeFieldType.monthOfYear())) { [EOL]             if (fields.remove(DateTimeFieldType.dayOfMonth())) { [EOL]                 appendSeparator(bld, extended); [EOL]                 bld.appendMonthOfYear(2); [EOL]                 appendSeparator(bld, extended); [EOL]                 bld.appendDayOfMonth(2); [EOL]             } else { [EOL]                 bld.appendLiteral('-'); [EOL]                 bld.appendMonthOfYear(2); [EOL]                 reducedPrec = true; [EOL]             } [EOL]         } else { [EOL]             if (fields.remove(DateTimeFieldType.dayOfMonth())) { [EOL]                 checkNotStrictISO(fields, strictISO); [EOL]                 bld.appendLiteral('-'); [EOL]                 bld.appendLiteral('-'); [EOL]                 bld.appendDayOfMonth(2); [EOL]             } else { [EOL]                 reducedPrec = true; [EOL]             } [EOL]         } [EOL]     } else if (fields.remove(DateTimeFieldType.monthOfYear())) { [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendMonthOfYear(2); [EOL]         if (fields.remove(DateTimeFieldType.dayOfMonth())) { [EOL]             appendSeparator(bld, extended); [EOL]             bld.appendDayOfMonth(2); [EOL]         } else { [EOL]             reducedPrec = true; [EOL]         } [EOL]     } else if (fields.remove(DateTimeFieldType.dayOfMonth())) { [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendDayOfMonth(2); [EOL]     } [EOL]     return reducedPrec; [EOL] }
private static boolean dateByMonth(DateTimeFormatterBuilder bld, Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO) { [EOL]     boolean reducedPrec = false; [EOL]     if (fields.remove(DateTimeFieldType.year())) { [EOL]         bld.append(Constants.ye); [EOL]         if (fields.remove(DateTimeFieldType.monthOfYear())) { [EOL]             if (fields.remove(DateTimeFieldType.dayOfMonth())) { [EOL]                 appendSeparator(bld, extended); [EOL]                 bld.appendMonthOfYear(2); [EOL]                 appendSeparator(bld, extended); [EOL]                 bld.appendDayOfMonth(2); [EOL]             } else { [EOL]                 bld.appendLiteral('-'); [EOL]                 bld.appendMonthOfYear(2); [EOL]                 reducedPrec = true; [EOL]             } [EOL]         } else { [EOL]             if (fields.remove(DateTimeFieldType.dayOfMonth())) { [EOL]                 checkNotStrictISO(fields, strictISO); [EOL]                 bld.appendLiteral('-'); [EOL]                 bld.appendLiteral('-'); [EOL]                 bld.appendDayOfMonth(2); [EOL]             } else { [EOL]                 reducedPrec = true; [EOL]             } [EOL]         } [EOL]     } else if (fields.remove(DateTimeFieldType.monthOfYear())) { [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendMonthOfYear(2); [EOL]         if (fields.remove(DateTimeFieldType.dayOfMonth())) { [EOL]             appendSeparator(bld, extended); [EOL]             bld.appendDayOfMonth(2); [EOL]         } else { [EOL]             reducedPrec = true; [EOL]         } [EOL]     } else if (fields.remove(DateTimeFieldType.dayOfMonth())) { [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendDayOfMonth(2); [EOL]     } [EOL]     return reducedPrec; [EOL] }
private static boolean dateByMonth(DateTimeFormatterBuilder bld, Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO) { [EOL]     boolean reducedPrec = false; [EOL]     if (fields.remove(DateTimeFieldType.year())) { [EOL]         bld.append(Constants.ye); [EOL]         if (fields.remove(DateTimeFieldType.monthOfYear())) { [EOL]             if (fields.remove(DateTimeFieldType.dayOfMonth())) { [EOL]                 appendSeparator(bld, extended); [EOL]                 bld.appendMonthOfYear(2); [EOL]                 appendSeparator(bld, extended); [EOL]                 bld.appendDayOfMonth(2); [EOL]             } else { [EOL]                 bld.appendLiteral('-'); [EOL]                 bld.appendMonthOfYear(2); [EOL]                 reducedPrec = true; [EOL]             } [EOL]         } else { [EOL]             if (fields.remove(DateTimeFieldType.dayOfMonth())) { [EOL]                 checkNotStrictISO(fields, strictISO); [EOL]                 bld.appendLiteral('-'); [EOL]                 bld.appendLiteral('-'); [EOL]                 bld.appendDayOfMonth(2); [EOL]             } else { [EOL]                 reducedPrec = true; [EOL]             } [EOL]         } [EOL]     } else if (fields.remove(DateTimeFieldType.monthOfYear())) { [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendMonthOfYear(2); [EOL]         if (fields.remove(DateTimeFieldType.dayOfMonth())) { [EOL]             appendSeparator(bld, extended); [EOL]             bld.appendDayOfMonth(2); [EOL]         } else { [EOL]             reducedPrec = true; [EOL]         } [EOL]     } else if (fields.remove(DateTimeFieldType.dayOfMonth())) { [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendDayOfMonth(2); [EOL]     } [EOL]     return reducedPrec; [EOL] }
private static boolean dateByOrdinal(DateTimeFormatterBuilder bld, Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO) { [EOL]     boolean reducedPrec = false; [EOL]     if (fields.remove(DateTimeFieldType.year())) { [EOL]         bld.append(Constants.ye); [EOL]         if (fields.remove(DateTimeFieldType.dayOfYear())) { [EOL]             appendSeparator(bld, extended); [EOL]             bld.appendDayOfYear(3); [EOL]         } else { [EOL]             reducedPrec = true; [EOL]         } [EOL]     } else if (fields.remove(DateTimeFieldType.dayOfYear())) { [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendDayOfYear(3); [EOL]     } [EOL]     return reducedPrec; [EOL] }
private static boolean dateByOrdinal(DateTimeFormatterBuilder bld, Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO) { [EOL]     boolean reducedPrec = false; [EOL]     if (fields.remove(DateTimeFieldType.year())) { [EOL]         bld.append(Constants.ye); [EOL]         if (fields.remove(DateTimeFieldType.dayOfYear())) { [EOL]             appendSeparator(bld, extended); [EOL]             bld.appendDayOfYear(3); [EOL]         } else { [EOL]             reducedPrec = true; [EOL]         } [EOL]     } else if (fields.remove(DateTimeFieldType.dayOfYear())) { [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendDayOfYear(3); [EOL]     } [EOL]     return reducedPrec; [EOL] }
private static boolean dateByOrdinal(DateTimeFormatterBuilder bld, Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO) { [EOL]     boolean reducedPrec = false; [EOL]     if (fields.remove(DateTimeFieldType.year())) { [EOL]         bld.append(Constants.ye); [EOL]         if (fields.remove(DateTimeFieldType.dayOfYear())) { [EOL]             appendSeparator(bld, extended); [EOL]             bld.appendDayOfYear(3); [EOL]         } else { [EOL]             reducedPrec = true; [EOL]         } [EOL]     } else if (fields.remove(DateTimeFieldType.dayOfYear())) { [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendDayOfYear(3); [EOL]     } [EOL]     return reducedPrec; [EOL] }
private static boolean dateByOrdinal(DateTimeFormatterBuilder bld, Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO) { [EOL]     boolean reducedPrec = false; [EOL]     if (fields.remove(DateTimeFieldType.year())) { [EOL]         bld.append(Constants.ye); [EOL]         if (fields.remove(DateTimeFieldType.dayOfYear())) { [EOL]             appendSeparator(bld, extended); [EOL]             bld.appendDayOfYear(3); [EOL]         } else { [EOL]             reducedPrec = true; [EOL]         } [EOL]     } else if (fields.remove(DateTimeFieldType.dayOfYear())) { [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendDayOfYear(3); [EOL]     } [EOL]     return reducedPrec; [EOL] }
private static boolean dateByWeek(DateTimeFormatterBuilder bld, Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO) { [EOL]     boolean reducedPrec = false; [EOL]     if (fields.remove(DateTimeFieldType.weekyear())) { [EOL]         bld.append(Constants.we); [EOL]         if (fields.remove(DateTimeFieldType.weekOfWeekyear())) { [EOL]             appendSeparator(bld, extended); [EOL]             bld.appendLiteral('W'); [EOL]             bld.appendWeekOfWeekyear(2); [EOL]             if (fields.remove(DateTimeFieldType.dayOfWeek())) { [EOL]                 appendSeparator(bld, extended); [EOL]                 bld.appendDayOfWeek(1); [EOL]             } else { [EOL]                 reducedPrec = true; [EOL]             } [EOL]         } else { [EOL]             if (fields.remove(DateTimeFieldType.dayOfWeek())) { [EOL]                 checkNotStrictISO(fields, strictISO); [EOL]                 appendSeparator(bld, extended); [EOL]                 bld.appendLiteral('W'); [EOL]                 bld.appendLiteral('-'); [EOL]                 bld.appendDayOfWeek(1); [EOL]             } else { [EOL]                 reducedPrec = true; [EOL]             } [EOL]         } [EOL]     } else if (fields.remove(DateTimeFieldType.weekOfWeekyear())) { [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('W'); [EOL]         bld.appendWeekOfWeekyear(2); [EOL]         if (fields.remove(DateTimeFieldType.dayOfWeek())) { [EOL]             appendSeparator(bld, extended); [EOL]             bld.appendDayOfWeek(1); [EOL]         } else { [EOL]             reducedPrec = true; [EOL]         } [EOL]     } else if (fields.remove(DateTimeFieldType.dayOfWeek())) { [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('W'); [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendDayOfWeek(1); [EOL]     } [EOL]     return reducedPrec; [EOL] }
private static boolean dateByWeek(DateTimeFormatterBuilder bld, Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO) { [EOL]     boolean reducedPrec = false; [EOL]     if (fields.remove(DateTimeFieldType.weekyear())) { [EOL]         bld.append(Constants.we); [EOL]         if (fields.remove(DateTimeFieldType.weekOfWeekyear())) { [EOL]             appendSeparator(bld, extended); [EOL]             bld.appendLiteral('W'); [EOL]             bld.appendWeekOfWeekyear(2); [EOL]             if (fields.remove(DateTimeFieldType.dayOfWeek())) { [EOL]                 appendSeparator(bld, extended); [EOL]                 bld.appendDayOfWeek(1); [EOL]             } else { [EOL]                 reducedPrec = true; [EOL]             } [EOL]         } else { [EOL]             if (fields.remove(DateTimeFieldType.dayOfWeek())) { [EOL]                 checkNotStrictISO(fields, strictISO); [EOL]                 appendSeparator(bld, extended); [EOL]                 bld.appendLiteral('W'); [EOL]                 bld.appendLiteral('-'); [EOL]                 bld.appendDayOfWeek(1); [EOL]             } else { [EOL]                 reducedPrec = true; [EOL]             } [EOL]         } [EOL]     } else if (fields.remove(DateTimeFieldType.weekOfWeekyear())) { [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('W'); [EOL]         bld.appendWeekOfWeekyear(2); [EOL]         if (fields.remove(DateTimeFieldType.dayOfWeek())) { [EOL]             appendSeparator(bld, extended); [EOL]             bld.appendDayOfWeek(1); [EOL]         } else { [EOL]             reducedPrec = true; [EOL]         } [EOL]     } else if (fields.remove(DateTimeFieldType.dayOfWeek())) { [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('W'); [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendDayOfWeek(1); [EOL]     } [EOL]     return reducedPrec; [EOL] }
private static boolean dateByWeek(DateTimeFormatterBuilder bld, Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO) { [EOL]     boolean reducedPrec = false; [EOL]     if (fields.remove(DateTimeFieldType.weekyear())) { [EOL]         bld.append(Constants.we); [EOL]         if (fields.remove(DateTimeFieldType.weekOfWeekyear())) { [EOL]             appendSeparator(bld, extended); [EOL]             bld.appendLiteral('W'); [EOL]             bld.appendWeekOfWeekyear(2); [EOL]             if (fields.remove(DateTimeFieldType.dayOfWeek())) { [EOL]                 appendSeparator(bld, extended); [EOL]                 bld.appendDayOfWeek(1); [EOL]             } else { [EOL]                 reducedPrec = true; [EOL]             } [EOL]         } else { [EOL]             if (fields.remove(DateTimeFieldType.dayOfWeek())) { [EOL]                 checkNotStrictISO(fields, strictISO); [EOL]                 appendSeparator(bld, extended); [EOL]                 bld.appendLiteral('W'); [EOL]                 bld.appendLiteral('-'); [EOL]                 bld.appendDayOfWeek(1); [EOL]             } else { [EOL]                 reducedPrec = true; [EOL]             } [EOL]         } [EOL]     } else if (fields.remove(DateTimeFieldType.weekOfWeekyear())) { [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('W'); [EOL]         bld.appendWeekOfWeekyear(2); [EOL]         if (fields.remove(DateTimeFieldType.dayOfWeek())) { [EOL]             appendSeparator(bld, extended); [EOL]             bld.appendDayOfWeek(1); [EOL]         } else { [EOL]             reducedPrec = true; [EOL]         } [EOL]     } else if (fields.remove(DateTimeFieldType.dayOfWeek())) { [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('W'); [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendDayOfWeek(1); [EOL]     } [EOL]     return reducedPrec; [EOL] }
private static boolean dateByWeek(DateTimeFormatterBuilder bld, Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO) { [EOL]     boolean reducedPrec = false; [EOL]     if (fields.remove(DateTimeFieldType.weekyear())) { [EOL]         bld.append(Constants.we); [EOL]         if (fields.remove(DateTimeFieldType.weekOfWeekyear())) { [EOL]             appendSeparator(bld, extended); [EOL]             bld.appendLiteral('W'); [EOL]             bld.appendWeekOfWeekyear(2); [EOL]             if (fields.remove(DateTimeFieldType.dayOfWeek())) { [EOL]                 appendSeparator(bld, extended); [EOL]                 bld.appendDayOfWeek(1); [EOL]             } else { [EOL]                 reducedPrec = true; [EOL]             } [EOL]         } else { [EOL]             if (fields.remove(DateTimeFieldType.dayOfWeek())) { [EOL]                 checkNotStrictISO(fields, strictISO); [EOL]                 appendSeparator(bld, extended); [EOL]                 bld.appendLiteral('W'); [EOL]                 bld.appendLiteral('-'); [EOL]                 bld.appendDayOfWeek(1); [EOL]             } else { [EOL]                 reducedPrec = true; [EOL]             } [EOL]         } [EOL]     } else if (fields.remove(DateTimeFieldType.weekOfWeekyear())) { [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('W'); [EOL]         bld.appendWeekOfWeekyear(2); [EOL]         if (fields.remove(DateTimeFieldType.dayOfWeek())) { [EOL]             appendSeparator(bld, extended); [EOL]             bld.appendDayOfWeek(1); [EOL]         } else { [EOL]             reducedPrec = true; [EOL]         } [EOL]     } else if (fields.remove(DateTimeFieldType.dayOfWeek())) { [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('W'); [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendDayOfWeek(1); [EOL]     } [EOL]     return reducedPrec; [EOL] }
private static boolean dateByWeek(DateTimeFormatterBuilder bld, Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO) { [EOL]     boolean reducedPrec = false; [EOL]     if (fields.remove(DateTimeFieldType.weekyear())) { [EOL]         bld.append(Constants.we); [EOL]         if (fields.remove(DateTimeFieldType.weekOfWeekyear())) { [EOL]             appendSeparator(bld, extended); [EOL]             bld.appendLiteral('W'); [EOL]             bld.appendWeekOfWeekyear(2); [EOL]             if (fields.remove(DateTimeFieldType.dayOfWeek())) { [EOL]                 appendSeparator(bld, extended); [EOL]                 bld.appendDayOfWeek(1); [EOL]             } else { [EOL]                 reducedPrec = true; [EOL]             } [EOL]         } else { [EOL]             if (fields.remove(DateTimeFieldType.dayOfWeek())) { [EOL]                 checkNotStrictISO(fields, strictISO); [EOL]                 appendSeparator(bld, extended); [EOL]                 bld.appendLiteral('W'); [EOL]                 bld.appendLiteral('-'); [EOL]                 bld.appendDayOfWeek(1); [EOL]             } else { [EOL]                 reducedPrec = true; [EOL]             } [EOL]         } [EOL]     } else if (fields.remove(DateTimeFieldType.weekOfWeekyear())) { [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('W'); [EOL]         bld.appendWeekOfWeekyear(2); [EOL]         if (fields.remove(DateTimeFieldType.dayOfWeek())) { [EOL]             appendSeparator(bld, extended); [EOL]             bld.appendDayOfWeek(1); [EOL]         } else { [EOL]             reducedPrec = true; [EOL]         } [EOL]     } else if (fields.remove(DateTimeFieldType.dayOfWeek())) { [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('W'); [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendDayOfWeek(1); [EOL]     } [EOL]     return reducedPrec; [EOL] }
private static boolean dateByWeek(DateTimeFormatterBuilder bld, Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO) { [EOL]     boolean reducedPrec = false; [EOL]     if (fields.remove(DateTimeFieldType.weekyear())) { [EOL]         bld.append(Constants.we); [EOL]         if (fields.remove(DateTimeFieldType.weekOfWeekyear())) { [EOL]             appendSeparator(bld, extended); [EOL]             bld.appendLiteral('W'); [EOL]             bld.appendWeekOfWeekyear(2); [EOL]             if (fields.remove(DateTimeFieldType.dayOfWeek())) { [EOL]                 appendSeparator(bld, extended); [EOL]                 bld.appendDayOfWeek(1); [EOL]             } else { [EOL]                 reducedPrec = true; [EOL]             } [EOL]         } else { [EOL]             if (fields.remove(DateTimeFieldType.dayOfWeek())) { [EOL]                 checkNotStrictISO(fields, strictISO); [EOL]                 appendSeparator(bld, extended); [EOL]                 bld.appendLiteral('W'); [EOL]                 bld.appendLiteral('-'); [EOL]                 bld.appendDayOfWeek(1); [EOL]             } else { [EOL]                 reducedPrec = true; [EOL]             } [EOL]         } [EOL]     } else if (fields.remove(DateTimeFieldType.weekOfWeekyear())) { [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('W'); [EOL]         bld.appendWeekOfWeekyear(2); [EOL]         if (fields.remove(DateTimeFieldType.dayOfWeek())) { [EOL]             appendSeparator(bld, extended); [EOL]             bld.appendDayOfWeek(1); [EOL]         } else { [EOL]             reducedPrec = true; [EOL]         } [EOL]     } else if (fields.remove(DateTimeFieldType.dayOfWeek())) { [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('W'); [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendDayOfWeek(1); [EOL]     } [EOL]     return reducedPrec; [EOL] }
private static boolean dateByWeek(DateTimeFormatterBuilder bld, Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO) { [EOL]     boolean reducedPrec = false; [EOL]     if (fields.remove(DateTimeFieldType.weekyear())) { [EOL]         bld.append(Constants.we); [EOL]         if (fields.remove(DateTimeFieldType.weekOfWeekyear())) { [EOL]             appendSeparator(bld, extended); [EOL]             bld.appendLiteral('W'); [EOL]             bld.appendWeekOfWeekyear(2); [EOL]             if (fields.remove(DateTimeFieldType.dayOfWeek())) { [EOL]                 appendSeparator(bld, extended); [EOL]                 bld.appendDayOfWeek(1); [EOL]             } else { [EOL]                 reducedPrec = true; [EOL]             } [EOL]         } else { [EOL]             if (fields.remove(DateTimeFieldType.dayOfWeek())) { [EOL]                 checkNotStrictISO(fields, strictISO); [EOL]                 appendSeparator(bld, extended); [EOL]                 bld.appendLiteral('W'); [EOL]                 bld.appendLiteral('-'); [EOL]                 bld.appendDayOfWeek(1); [EOL]             } else { [EOL]                 reducedPrec = true; [EOL]             } [EOL]         } [EOL]     } else if (fields.remove(DateTimeFieldType.weekOfWeekyear())) { [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('W'); [EOL]         bld.appendWeekOfWeekyear(2); [EOL]         if (fields.remove(DateTimeFieldType.dayOfWeek())) { [EOL]             appendSeparator(bld, extended); [EOL]             bld.appendDayOfWeek(1); [EOL]         } else { [EOL]             reducedPrec = true; [EOL]         } [EOL]     } else if (fields.remove(DateTimeFieldType.dayOfWeek())) { [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('W'); [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendDayOfWeek(1); [EOL]     } [EOL]     return reducedPrec; [EOL] }
private static void time(DateTimeFormatterBuilder bld, Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO, boolean reducedPrec, boolean datePresent) { [EOL]     boolean hour = fields.remove(DateTimeFieldType.hourOfDay()); [EOL]     boolean minute = fields.remove(DateTimeFieldType.minuteOfHour()); [EOL]     boolean second = fields.remove(DateTimeFieldType.secondOfMinute()); [EOL]     boolean milli = fields.remove(DateTimeFieldType.millisOfSecond()); [EOL]     if (!hour && !minute && !second && !milli) { [EOL]         return; [EOL]     } [EOL]     if (hour || minute || second || milli) { [EOL]         if (strictISO && reducedPrec) { [EOL]             throw new IllegalArgumentException("No valid ISO8601 format for fields because Date was reduced precision: " + fields); [EOL]         } [EOL]         if (datePresent) { [EOL]             bld.appendLiteral('T'); [EOL]         } [EOL]     } [EOL]     if (hour && minute && second || (hour && !second && !milli)) { [EOL]     } else { [EOL]         if (strictISO && datePresent) { [EOL]             throw new IllegalArgumentException("No valid ISO8601 format for fields because Time was truncated: " + fields); [EOL]         } [EOL]         if (!hour && (minute && second || (minute && !milli) || second)) { [EOL]         } else { [EOL]             if (strictISO) { [EOL]                 throw new IllegalArgumentException("No valid ISO8601 format for fields: " + fields); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (hour) { [EOL]         bld.appendHourOfDay(2); [EOL]     } else if (minute || second || milli) { [EOL]         bld.appendLiteral('-'); [EOL]     } [EOL]     if (extended && hour && minute) { [EOL]         bld.appendLiteral(':'); [EOL]     } [EOL]     if (minute) { [EOL]         bld.appendMinuteOfHour(2); [EOL]     } else if (second || milli) { [EOL]         bld.appendLiteral('-'); [EOL]     } [EOL]     if (extended && minute && second) { [EOL]         bld.appendLiteral(':'); [EOL]     } [EOL]     if (second) { [EOL]         bld.appendSecondOfMinute(2); [EOL]     } else if (milli) { [EOL]         bld.appendLiteral('-'); [EOL]     } [EOL]     if (milli) { [EOL]         bld.appendLiteral('.'); [EOL]         bld.appendMillisOfSecond(3); [EOL]     } [EOL] }
private static void time(DateTimeFormatterBuilder bld, Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO, boolean reducedPrec, boolean datePresent) { [EOL]     boolean hour = fields.remove(DateTimeFieldType.hourOfDay()); [EOL]     boolean minute = fields.remove(DateTimeFieldType.minuteOfHour()); [EOL]     boolean second = fields.remove(DateTimeFieldType.secondOfMinute()); [EOL]     boolean milli = fields.remove(DateTimeFieldType.millisOfSecond()); [EOL]     if (!hour && !minute && !second && !milli) { [EOL]         return; [EOL]     } [EOL]     if (hour || minute || second || milli) { [EOL]         if (strictISO && reducedPrec) { [EOL]             throw new IllegalArgumentException("No valid ISO8601 format for fields because Date was reduced precision: " + fields); [EOL]         } [EOL]         if (datePresent) { [EOL]             bld.appendLiteral('T'); [EOL]         } [EOL]     } [EOL]     if (hour && minute && second || (hour && !second && !milli)) { [EOL]     } else { [EOL]         if (strictISO && datePresent) { [EOL]             throw new IllegalArgumentException("No valid ISO8601 format for fields because Time was truncated: " + fields); [EOL]         } [EOL]         if (!hour && (minute && second || (minute && !milli) || second)) { [EOL]         } else { [EOL]             if (strictISO) { [EOL]                 throw new IllegalArgumentException("No valid ISO8601 format for fields: " + fields); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (hour) { [EOL]         bld.appendHourOfDay(2); [EOL]     } else if (minute || second || milli) { [EOL]         bld.appendLiteral('-'); [EOL]     } [EOL]     if (extended && hour && minute) { [EOL]         bld.appendLiteral(':'); [EOL]     } [EOL]     if (minute) { [EOL]         bld.appendMinuteOfHour(2); [EOL]     } else if (second || milli) { [EOL]         bld.appendLiteral('-'); [EOL]     } [EOL]     if (extended && minute && second) { [EOL]         bld.appendLiteral(':'); [EOL]     } [EOL]     if (second) { [EOL]         bld.appendSecondOfMinute(2); [EOL]     } else if (milli) { [EOL]         bld.appendLiteral('-'); [EOL]     } [EOL]     if (milli) { [EOL]         bld.appendLiteral('.'); [EOL]         bld.appendMillisOfSecond(3); [EOL]     } [EOL] }
private static void time(DateTimeFormatterBuilder bld, Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO, boolean reducedPrec, boolean datePresent) { [EOL]     boolean hour = fields.remove(DateTimeFieldType.hourOfDay()); [EOL]     boolean minute = fields.remove(DateTimeFieldType.minuteOfHour()); [EOL]     boolean second = fields.remove(DateTimeFieldType.secondOfMinute()); [EOL]     boolean milli = fields.remove(DateTimeFieldType.millisOfSecond()); [EOL]     if (!hour && !minute && !second && !milli) { [EOL]         return; [EOL]     } [EOL]     if (hour || minute || second || milli) { [EOL]         if (strictISO && reducedPrec) { [EOL]             throw new IllegalArgumentException("No valid ISO8601 format for fields because Date was reduced precision: " + fields); [EOL]         } [EOL]         if (datePresent) { [EOL]             bld.appendLiteral('T'); [EOL]         } [EOL]     } [EOL]     if (hour && minute && second || (hour && !second && !milli)) { [EOL]     } else { [EOL]         if (strictISO && datePresent) { [EOL]             throw new IllegalArgumentException("No valid ISO8601 format for fields because Time was truncated: " + fields); [EOL]         } [EOL]         if (!hour && (minute && second || (minute && !milli) || second)) { [EOL]         } else { [EOL]             if (strictISO) { [EOL]                 throw new IllegalArgumentException("No valid ISO8601 format for fields: " + fields); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (hour) { [EOL]         bld.appendHourOfDay(2); [EOL]     } else if (minute || second || milli) { [EOL]         bld.appendLiteral('-'); [EOL]     } [EOL]     if (extended && hour && minute) { [EOL]         bld.appendLiteral(':'); [EOL]     } [EOL]     if (minute) { [EOL]         bld.appendMinuteOfHour(2); [EOL]     } else if (second || milli) { [EOL]         bld.appendLiteral('-'); [EOL]     } [EOL]     if (extended && minute && second) { [EOL]         bld.appendLiteral(':'); [EOL]     } [EOL]     if (second) { [EOL]         bld.appendSecondOfMinute(2); [EOL]     } else if (milli) { [EOL]         bld.appendLiteral('-'); [EOL]     } [EOL]     if (milli) { [EOL]         bld.appendLiteral('.'); [EOL]         bld.appendMillisOfSecond(3); [EOL]     } [EOL] }
private static void time(DateTimeFormatterBuilder bld, Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO, boolean reducedPrec, boolean datePresent) { [EOL]     boolean hour = fields.remove(DateTimeFieldType.hourOfDay()); [EOL]     boolean minute = fields.remove(DateTimeFieldType.minuteOfHour()); [EOL]     boolean second = fields.remove(DateTimeFieldType.secondOfMinute()); [EOL]     boolean milli = fields.remove(DateTimeFieldType.millisOfSecond()); [EOL]     if (!hour && !minute && !second && !milli) { [EOL]         return; [EOL]     } [EOL]     if (hour || minute || second || milli) { [EOL]         if (strictISO && reducedPrec) { [EOL]             throw new IllegalArgumentException("No valid ISO8601 format for fields because Date was reduced precision: " + fields); [EOL]         } [EOL]         if (datePresent) { [EOL]             bld.appendLiteral('T'); [EOL]         } [EOL]     } [EOL]     if (hour && minute && second || (hour && !second && !milli)) { [EOL]     } else { [EOL]         if (strictISO && datePresent) { [EOL]             throw new IllegalArgumentException("No valid ISO8601 format for fields because Time was truncated: " + fields); [EOL]         } [EOL]         if (!hour && (minute && second || (minute && !milli) || second)) { [EOL]         } else { [EOL]             if (strictISO) { [EOL]                 throw new IllegalArgumentException("No valid ISO8601 format for fields: " + fields); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (hour) { [EOL]         bld.appendHourOfDay(2); [EOL]     } else if (minute || second || milli) { [EOL]         bld.appendLiteral('-'); [EOL]     } [EOL]     if (extended && hour && minute) { [EOL]         bld.appendLiteral(':'); [EOL]     } [EOL]     if (minute) { [EOL]         bld.appendMinuteOfHour(2); [EOL]     } else if (second || milli) { [EOL]         bld.appendLiteral('-'); [EOL]     } [EOL]     if (extended && minute && second) { [EOL]         bld.appendLiteral(':'); [EOL]     } [EOL]     if (second) { [EOL]         bld.appendSecondOfMinute(2); [EOL]     } else if (milli) { [EOL]         bld.appendLiteral('-'); [EOL]     } [EOL]     if (milli) { [EOL]         bld.appendLiteral('.'); [EOL]         bld.appendMillisOfSecond(3); [EOL]     } [EOL] }
private static void time(DateTimeFormatterBuilder bld, Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO, boolean reducedPrec, boolean datePresent) { [EOL]     boolean hour = fields.remove(DateTimeFieldType.hourOfDay()); [EOL]     boolean minute = fields.remove(DateTimeFieldType.minuteOfHour()); [EOL]     boolean second = fields.remove(DateTimeFieldType.secondOfMinute()); [EOL]     boolean milli = fields.remove(DateTimeFieldType.millisOfSecond()); [EOL]     if (!hour && !minute && !second && !milli) { [EOL]         return; [EOL]     } [EOL]     if (hour || minute || second || milli) { [EOL]         if (strictISO && reducedPrec) { [EOL]             throw new IllegalArgumentException("No valid ISO8601 format for fields because Date was reduced precision: " + fields); [EOL]         } [EOL]         if (datePresent) { [EOL]             bld.appendLiteral('T'); [EOL]         } [EOL]     } [EOL]     if (hour && minute && second || (hour && !second && !milli)) { [EOL]     } else { [EOL]         if (strictISO && datePresent) { [EOL]             throw new IllegalArgumentException("No valid ISO8601 format for fields because Time was truncated: " + fields); [EOL]         } [EOL]         if (!hour && (minute && second || (minute && !milli) || second)) { [EOL]         } else { [EOL]             if (strictISO) { [EOL]                 throw new IllegalArgumentException("No valid ISO8601 format for fields: " + fields); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (hour) { [EOL]         bld.appendHourOfDay(2); [EOL]     } else if (minute || second || milli) { [EOL]         bld.appendLiteral('-'); [EOL]     } [EOL]     if (extended && hour && minute) { [EOL]         bld.appendLiteral(':'); [EOL]     } [EOL]     if (minute) { [EOL]         bld.appendMinuteOfHour(2); [EOL]     } else if (second || milli) { [EOL]         bld.appendLiteral('-'); [EOL]     } [EOL]     if (extended && minute && second) { [EOL]         bld.appendLiteral(':'); [EOL]     } [EOL]     if (second) { [EOL]         bld.appendSecondOfMinute(2); [EOL]     } else if (milli) { [EOL]         bld.appendLiteral('-'); [EOL]     } [EOL]     if (milli) { [EOL]         bld.appendLiteral('.'); [EOL]         bld.appendMillisOfSecond(3); [EOL]     } [EOL] }
private static void time(DateTimeFormatterBuilder bld, Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO, boolean reducedPrec, boolean datePresent) { [EOL]     boolean hour = fields.remove(DateTimeFieldType.hourOfDay()); [EOL]     boolean minute = fields.remove(DateTimeFieldType.minuteOfHour()); [EOL]     boolean second = fields.remove(DateTimeFieldType.secondOfMinute()); [EOL]     boolean milli = fields.remove(DateTimeFieldType.millisOfSecond()); [EOL]     if (!hour && !minute && !second && !milli) { [EOL]         return; [EOL]     } [EOL]     if (hour || minute || second || milli) { [EOL]         if (strictISO && reducedPrec) { [EOL]             throw new IllegalArgumentException("No valid ISO8601 format for fields because Date was reduced precision: " + fields); [EOL]         } [EOL]         if (datePresent) { [EOL]             bld.appendLiteral('T'); [EOL]         } [EOL]     } [EOL]     if (hour && minute && second || (hour && !second && !milli)) { [EOL]     } else { [EOL]         if (strictISO && datePresent) { [EOL]             throw new IllegalArgumentException("No valid ISO8601 format for fields because Time was truncated: " + fields); [EOL]         } [EOL]         if (!hour && (minute && second || (minute && !milli) || second)) { [EOL]         } else { [EOL]             if (strictISO) { [EOL]                 throw new IllegalArgumentException("No valid ISO8601 format for fields: " + fields); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (hour) { [EOL]         bld.appendHourOfDay(2); [EOL]     } else if (minute || second || milli) { [EOL]         bld.appendLiteral('-'); [EOL]     } [EOL]     if (extended && hour && minute) { [EOL]         bld.appendLiteral(':'); [EOL]     } [EOL]     if (minute) { [EOL]         bld.appendMinuteOfHour(2); [EOL]     } else if (second || milli) { [EOL]         bld.appendLiteral('-'); [EOL]     } [EOL]     if (extended && minute && second) { [EOL]         bld.appendLiteral(':'); [EOL]     } [EOL]     if (second) { [EOL]         bld.appendSecondOfMinute(2); [EOL]     } else if (milli) { [EOL]         bld.appendLiteral('-'); [EOL]     } [EOL]     if (milli) { [EOL]         bld.appendLiteral('.'); [EOL]         bld.appendMillisOfSecond(3); [EOL]     } [EOL] }
private static void time(DateTimeFormatterBuilder bld, Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO, boolean reducedPrec, boolean datePresent) { [EOL]     boolean hour = fields.remove(DateTimeFieldType.hourOfDay()); [EOL]     boolean minute = fields.remove(DateTimeFieldType.minuteOfHour()); [EOL]     boolean second = fields.remove(DateTimeFieldType.secondOfMinute()); [EOL]     boolean milli = fields.remove(DateTimeFieldType.millisOfSecond()); [EOL]     if (!hour && !minute && !second && !milli) { [EOL]         return; [EOL]     } [EOL]     if (hour || minute || second || milli) { [EOL]         if (strictISO && reducedPrec) { [EOL]             throw new IllegalArgumentException("No valid ISO8601 format for fields because Date was reduced precision: " + fields); [EOL]         } [EOL]         if (datePresent) { [EOL]             bld.appendLiteral('T'); [EOL]         } [EOL]     } [EOL]     if (hour && minute && second || (hour && !second && !milli)) { [EOL]     } else { [EOL]         if (strictISO && datePresent) { [EOL]             throw new IllegalArgumentException("No valid ISO8601 format for fields because Time was truncated: " + fields); [EOL]         } [EOL]         if (!hour && (minute && second || (minute && !milli) || second)) { [EOL]         } else { [EOL]             if (strictISO) { [EOL]                 throw new IllegalArgumentException("No valid ISO8601 format for fields: " + fields); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (hour) { [EOL]         bld.appendHourOfDay(2); [EOL]     } else if (minute || second || milli) { [EOL]         bld.appendLiteral('-'); [EOL]     } [EOL]     if (extended && hour && minute) { [EOL]         bld.appendLiteral(':'); [EOL]     } [EOL]     if (minute) { [EOL]         bld.appendMinuteOfHour(2); [EOL]     } else if (second || milli) { [EOL]         bld.appendLiteral('-'); [EOL]     } [EOL]     if (extended && minute && second) { [EOL]         bld.appendLiteral(':'); [EOL]     } [EOL]     if (second) { [EOL]         bld.appendSecondOfMinute(2); [EOL]     } else if (milli) { [EOL]         bld.appendLiteral('-'); [EOL]     } [EOL]     if (milli) { [EOL]         bld.appendLiteral('.'); [EOL]         bld.appendMillisOfSecond(3); [EOL]     } [EOL] }
public static DateTimeFormatter timeParser() { [EOL]     return Constants.tp; [EOL] }
public static DateTimeFormatter localDateOptionalTimeParser() { [EOL]     return Constants.ldotp; [EOL] }
public static DateTimeFormatter basicTTime() { [EOL]     return Constants.btt; [EOL] }
public static DateTimeFormatter basicWeekDateTime() { [EOL]     return Constants.bwdt; [EOL] }
public static DateTimeFormatter yearMonthDay() { [EOL]     return Constants.ymd; [EOL] }
public static DateTimeFormatter weekyear() { [EOL]     return Constants.we; [EOL] }
public static DateTimeFormatter weekyearWeekDay() { [EOL]     return Constants.wwd; [EOL] }
public static DateTimeFormatter dateHourMinuteSecondMillis() { [EOL]     return Constants.dhmsl; [EOL] }
public static DateTimeFormatter dateHourMinuteSecondFraction() { [EOL]     return Constants.dhmsf; [EOL] }
public static Minutes minutes(int minutes) { [EOL]     switch(minutes) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Minutes(minutes); [EOL]     } [EOL] }
public static Minutes minutes(int minutes) { [EOL]     switch(minutes) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Minutes(minutes); [EOL]     } [EOL] }
public static Minutes minutes(int minutes) { [EOL]     switch(minutes) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Minutes(minutes); [EOL]     } [EOL] }
public static Minutes minutes(int minutes) { [EOL]     switch(minutes) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Minutes(minutes); [EOL]     } [EOL] }
public static Minutes minutes(int minutes) { [EOL]     switch(minutes) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Minutes(minutes); [EOL]     } [EOL] }
public static Minutes minutes(int minutes) { [EOL]     switch(minutes) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Minutes(minutes); [EOL]     } [EOL] }
public static Minutes minutes(int minutes) { [EOL]     switch(minutes) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Minutes(minutes); [EOL]     } [EOL] }
public static Minutes minutesBetween(ReadablePartial start, ReadablePartial end) { [EOL]     if (start instanceof LocalTime && end instanceof LocalTime) { [EOL]         Chronology chrono = DateTimeUtils.getChronology(start.getChronology()); [EOL]         int minutes = chrono.minutes().getDifference(((LocalTime) end).getLocalMillis(), ((LocalTime) start).getLocalMillis()); [EOL]         return Minutes.minutes(minutes); [EOL]     } [EOL]     int amount = BaseSingleFieldPeriod.between(start, end, ZERO); [EOL]     return Minutes.minutes(amount); [EOL] }
public static Minutes minutesBetween(ReadablePartial start, ReadablePartial end) { [EOL]     if (start instanceof LocalTime && end instanceof LocalTime) { [EOL]         Chronology chrono = DateTimeUtils.getChronology(start.getChronology()); [EOL]         int minutes = chrono.minutes().getDifference(((LocalTime) end).getLocalMillis(), ((LocalTime) start).getLocalMillis()); [EOL]         return Minutes.minutes(minutes); [EOL]     } [EOL]     int amount = BaseSingleFieldPeriod.between(start, end, ZERO); [EOL]     return Minutes.minutes(amount); [EOL] }
public static Minutes minutesBetween(ReadablePartial start, ReadablePartial end) { [EOL]     if (start instanceof LocalTime && end instanceof LocalTime) { [EOL]         Chronology chrono = DateTimeUtils.getChronology(start.getChronology()); [EOL]         int minutes = chrono.minutes().getDifference(((LocalTime) end).getLocalMillis(), ((LocalTime) start).getLocalMillis()); [EOL]         return Minutes.minutes(minutes); [EOL]     } [EOL]     int amount = BaseSingleFieldPeriod.between(start, end, ZERO); [EOL]     return Minutes.minutes(amount); [EOL] }
@FromString [EOL] public static Minutes parseMinutes(String periodStr) { [EOL]     if (periodStr == null) { [EOL]         return Minutes.ZERO; [EOL]     } [EOL]     Period p = PARSER.parsePeriod(periodStr); [EOL]     return Minutes.minutes(p.getMinutes()); [EOL] }
@FromString [EOL] public static Minutes parseMinutes(String periodStr) { [EOL]     if (periodStr == null) { [EOL]         return Minutes.ZERO; [EOL]     } [EOL]     Period p = PARSER.parsePeriod(periodStr); [EOL]     return Minutes.minutes(p.getMinutes()); [EOL] }
@FromString [EOL] public static Minutes parseMinutes(String periodStr) { [EOL]     if (periodStr == null) { [EOL]         return Minutes.ZERO; [EOL]     } [EOL]     Period p = PARSER.parsePeriod(periodStr); [EOL]     return Minutes.minutes(p.getMinutes()); [EOL] }
public DurationFieldType getFieldType() { [EOL]     return DurationFieldType.minutes(); [EOL] }
public Weeks toStandardWeeks() { [EOL]     return Weeks.weeks(getValue() / DateTimeConstants.MINUTES_PER_WEEK); [EOL] }
public Minutes minus(Minutes minutes) { [EOL]     if (minutes == null) { [EOL]         return this; [EOL]     } [EOL]     return minus(minutes.getValue()); [EOL] }
public Minutes minus(Minutes minutes) { [EOL]     if (minutes == null) { [EOL]         return this; [EOL]     } [EOL]     return minus(minutes.getValue()); [EOL] }
protected Boolean initialValue() { [EOL]     return Boolean.FALSE; [EOL] } public ZoneInfoCompiler();  DateTimeOfYear();  DateTimeOfYear(StringTokenizer st);  Rule(StringTokenizer st);  RuleSet(Rule rule);  Zone(StringTokenizer st); private Zone(String name, StringTokenizer st); protected Boolean initialValue(); public static boolean verbose(); public static void main(String[] args) throws Exception; private static void printUsage();  static DateTimeOfYear getStartOfYear();  static Chronology getLenientISOChronology();  static void writeZoneInfoMap(DataOutputStream dout, Map<String, DateTimeZone> zimap) throws IOException;  static int parseYear(String str, int def);  static int parseMonth(String str);  static int parseDayOfWeek(String str);  static String parseOptional(String str);  static int parseTime(String str);  static char parseZoneChar(char c);  static boolean test(String id, DateTimeZone tz); public Map<String, DateTimeZone> compile(File outputDir, File[] sources) throws IOException; public void parseDataFile(BufferedReader in) throws IOException; public void addRecurring(DateTimeZoneBuilder builder, String nameKey, int saveMillis, int fromYear, int toYear); public void addCutover(DateTimeZoneBuilder builder, int year); public String toString(); public void addRecurring(DateTimeZoneBuilder builder, String nameFormat); private String formatName(String nameFormat); public String toString();  void addRule(Rule rule); public void addRecurring(DateTimeZoneBuilder builder, String nameFormat);  void chain(StringTokenizer st); public void addToBuilder(DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); private static void addToBuilder(Zone zone, DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); public String toString(); DateTimeOfYear cStartOfYear; Chronology cLenientISO; ThreadLocal<Boolean> cVerbose=Optional[new ThreadLocal<Boolean>() {; ;     protected Boolean initialValue() {;         return Boolean.FALSE;;     }; }
public static boolean verbose() { [EOL]     return cVerbose.get(); [EOL] } public ZoneInfoCompiler();  DateTimeOfYear();  DateTimeOfYear(StringTokenizer st);  Rule(StringTokenizer st);  RuleSet(Rule rule);  Zone(StringTokenizer st); private Zone(String name, StringTokenizer st); protected Boolean initialValue(); public static boolean verbose(); public static void main(String[] args) throws Exception; private static void printUsage();  static DateTimeOfYear getStartOfYear();  static Chronology getLenientISOChronology();  static void writeZoneInfoMap(DataOutputStream dout, Map<String, DateTimeZone> zimap) throws IOException;  static int parseYear(String str, int def);  static int parseMonth(String str);  static int parseDayOfWeek(String str);  static String parseOptional(String str);  static int parseTime(String str);  static char parseZoneChar(char c);  static boolean test(String id, DateTimeZone tz); public Map<String, DateTimeZone> compile(File outputDir, File[] sources) throws IOException; public void parseDataFile(BufferedReader in) throws IOException; public void addRecurring(DateTimeZoneBuilder builder, String nameKey, int saveMillis, int fromYear, int toYear); public void addCutover(DateTimeZoneBuilder builder, int year); public String toString(); public void addRecurring(DateTimeZoneBuilder builder, String nameFormat); private String formatName(String nameFormat); public String toString();  void addRule(Rule rule); public void addRecurring(DateTimeZoneBuilder builder, String nameFormat);  void chain(StringTokenizer st); public void addToBuilder(DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); private static void addToBuilder(Zone zone, DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); public String toString(); DateTimeOfYear cStartOfYear; Chronology cLenientISO; ThreadLocal<Boolean> cVerbose=Optional[new ThreadLocal<Boolean>() {; ;     protected Boolean initialValue() {;         return Boolean.FALSE;;     }; }
public static GregorianChronology getInstance(DateTimeZone zone, int minDaysInFirstWeek) { [EOL]     if (zone == null) { [EOL]         zone = DateTimeZone.getDefault(); [EOL]     } [EOL]     GregorianChronology chrono; [EOL]     synchronized (cCache) { [EOL]         GregorianChronology[] chronos = cCache.get(zone); [EOL]         if (chronos == null) { [EOL]             chronos = new GregorianChronology[7]; [EOL]             cCache.put(zone, chronos); [EOL]         } [EOL]         try { [EOL]             chrono = chronos[minDaysInFirstWeek - 1]; [EOL]         } catch (ArrayIndexOutOfBoundsException e) { [EOL]             throw new IllegalArgumentException("Invalid min days in first week: " + minDaysInFirstWeek); [EOL]         } [EOL]         if (chrono == null) { [EOL]             if (zone == DateTimeZone.UTC) { [EOL]                 chrono = new GregorianChronology(null, null, minDaysInFirstWeek); [EOL]             } else { [EOL]                 chrono = getInstance(DateTimeZone.UTC, minDaysInFirstWeek); [EOL]                 chrono = new GregorianChronology(ZonedChronology.getInstance(chrono, zone), null, minDaysInFirstWeek); [EOL]             } [EOL]             chronos[minDaysInFirstWeek - 1] = chrono; [EOL]         } [EOL]     } [EOL]     return chrono; [EOL] }
public static GregorianChronology getInstance(DateTimeZone zone, int minDaysInFirstWeek) { [EOL]     if (zone == null) { [EOL]         zone = DateTimeZone.getDefault(); [EOL]     } [EOL]     GregorianChronology chrono; [EOL]     synchronized (cCache) { [EOL]         GregorianChronology[] chronos = cCache.get(zone); [EOL]         if (chronos == null) { [EOL]             chronos = new GregorianChronology[7]; [EOL]             cCache.put(zone, chronos); [EOL]         } [EOL]         try { [EOL]             chrono = chronos[minDaysInFirstWeek - 1]; [EOL]         } catch (ArrayIndexOutOfBoundsException e) { [EOL]             throw new IllegalArgumentException("Invalid min days in first week: " + minDaysInFirstWeek); [EOL]         } [EOL]         if (chrono == null) { [EOL]             if (zone == DateTimeZone.UTC) { [EOL]                 chrono = new GregorianChronology(null, null, minDaysInFirstWeek); [EOL]             } else { [EOL]                 chrono = getInstance(DateTimeZone.UTC, minDaysInFirstWeek); [EOL]                 chrono = new GregorianChronology(ZonedChronology.getInstance(chrono, zone), null, minDaysInFirstWeek); [EOL]             } [EOL]             chronos[minDaysInFirstWeek - 1] = chrono; [EOL]         } [EOL]     } [EOL]     return chrono; [EOL] }
public static GregorianChronology getInstance(DateTimeZone zone, int minDaysInFirstWeek) { [EOL]     if (zone == null) { [EOL]         zone = DateTimeZone.getDefault(); [EOL]     } [EOL]     GregorianChronology chrono; [EOL]     synchronized (cCache) { [EOL]         GregorianChronology[] chronos = cCache.get(zone); [EOL]         if (chronos == null) { [EOL]             chronos = new GregorianChronology[7]; [EOL]             cCache.put(zone, chronos); [EOL]         } [EOL]         try { [EOL]             chrono = chronos[minDaysInFirstWeek - 1]; [EOL]         } catch (ArrayIndexOutOfBoundsException e) { [EOL]             throw new IllegalArgumentException("Invalid min days in first week: " + minDaysInFirstWeek); [EOL]         } [EOL]         if (chrono == null) { [EOL]             if (zone == DateTimeZone.UTC) { [EOL]                 chrono = new GregorianChronology(null, null, minDaysInFirstWeek); [EOL]             } else { [EOL]                 chrono = getInstance(DateTimeZone.UTC, minDaysInFirstWeek); [EOL]                 chrono = new GregorianChronology(ZonedChronology.getInstance(chrono, zone), null, minDaysInFirstWeek); [EOL]             } [EOL]             chronos[minDaysInFirstWeek - 1] = chrono; [EOL]         } [EOL]     } [EOL]     return chrono; [EOL] }
public static GregorianChronology getInstance(DateTimeZone zone, int minDaysInFirstWeek) { [EOL]     if (zone == null) { [EOL]         zone = DateTimeZone.getDefault(); [EOL]     } [EOL]     GregorianChronology chrono; [EOL]     synchronized (cCache) { [EOL]         GregorianChronology[] chronos = cCache.get(zone); [EOL]         if (chronos == null) { [EOL]             chronos = new GregorianChronology[7]; [EOL]             cCache.put(zone, chronos); [EOL]         } [EOL]         try { [EOL]             chrono = chronos[minDaysInFirstWeek - 1]; [EOL]         } catch (ArrayIndexOutOfBoundsException e) { [EOL]             throw new IllegalArgumentException("Invalid min days in first week: " + minDaysInFirstWeek); [EOL]         } [EOL]         if (chrono == null) { [EOL]             if (zone == DateTimeZone.UTC) { [EOL]                 chrono = new GregorianChronology(null, null, minDaysInFirstWeek); [EOL]             } else { [EOL]                 chrono = getInstance(DateTimeZone.UTC, minDaysInFirstWeek); [EOL]                 chrono = new GregorianChronology(ZonedChronology.getInstance(chrono, zone), null, minDaysInFirstWeek); [EOL]             } [EOL]             chronos[minDaysInFirstWeek - 1] = chrono; [EOL]         } [EOL]     } [EOL]     return chrono; [EOL] }
public BaseDateTime(long instant, DateTimeZone zone) { [EOL]     this(instant, ISOChronology.getInstance(zone)); [EOL] }
public BaseDateTime(long instant, DateTimeZone zone) { [EOL]     this(instant, ISOChronology.getInstance(zone)); [EOL] }
public int getStandardOffset(long instant) { [EOL]     return iStandardOffset; [EOL] }
public long nextTransition(long instant) { [EOL]     return instant; [EOL] }
public long previousTransition(long instant) { [EOL]     return instant; [EOL] }
public int getMinimumValueOverall() { [EOL]     return getField().getMinimumValue(); [EOL] }
public int getMinimumValue() { [EOL]     return getField().getMinimumValue(getMillis()); [EOL] }
public int getMaximumValueOverall() { [EOL]     return getField().getMaximumValue(); [EOL] }
public int getMaximumValue() { [EOL]     return getField().getMaximumValue(getMillis()); [EOL] }
public int hashCode() { [EOL]     return get() * 17 + getFieldType().hashCode() + getChronology().hashCode(); [EOL] }
public String getName() { [EOL]     return iType.getName(); [EOL] }
public DurationField getRangeDurationField() { [EOL]     return iRangeField; [EOL] }
public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int millisOfDay) throws IllegalArgumentException { [EOL]     return localToUTC(getBase().getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay)); [EOL] }
public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int millisOfDay) throws IllegalArgumentException { [EOL]     return localToUTC(getBase().getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay)); [EOL] }
public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int millisOfDay) throws IllegalArgumentException { [EOL]     return localToUTC(getBase().getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay)); [EOL] }
public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int millisOfDay) throws IllegalArgumentException { [EOL]     return localToUTC(getBase().getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay)); [EOL] }
public long getDateTimeMillis(long instant, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) throws IllegalArgumentException { [EOL]     return localToUTC(getBase().getDateTimeMillis(instant + getZone().getOffset(instant), hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond)); [EOL] }
public long getDateTimeMillis(long instant, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) throws IllegalArgumentException { [EOL]     return localToUTC(getBase().getDateTimeMillis(instant + getZone().getOffset(instant), hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond)); [EOL] }
private long localToUTC(long localInstant) { [EOL]     DateTimeZone zone = getZone(); [EOL]     int offset = zone.getOffsetFromLocal(localInstant); [EOL]     localInstant -= offset; [EOL]     if (offset != zone.getOffset(localInstant)) { [EOL]         throw new IllegalInstantException(localInstant, zone.getID()); [EOL]     } [EOL]     return localInstant; [EOL] }
private long localToUTC(long localInstant) { [EOL]     DateTimeZone zone = getZone(); [EOL]     int offset = zone.getOffsetFromLocal(localInstant); [EOL]     localInstant -= offset; [EOL]     if (offset != zone.getOffset(localInstant)) { [EOL]         throw new IllegalInstantException(localInstant, zone.getID()); [EOL]     } [EOL]     return localInstant; [EOL] }
public String toString() { [EOL]     return "ZonedChronology[" + getBase() + ", " + getZone().getID() + ']'; [EOL] }
public long add(long instant, int value) { [EOL]     int offset = getOffsetToAdd(instant); [EOL]     instant = iField.add(instant + offset, value); [EOL]     return instant - (iTimeField ? offset : getOffsetFromLocalToSubtract(instant)); [EOL] }
public long add(long instant, long value) { [EOL]     int offset = getOffsetToAdd(instant); [EOL]     instant = iField.add(instant + offset, value); [EOL]     return instant - (iTimeField ? offset : getOffsetFromLocalToSubtract(instant)); [EOL] }
public long add(long instant, long value) { [EOL]     int offset = getOffsetToAdd(instant); [EOL]     instant = iField.add(instant + offset, value); [EOL]     return instant - (iTimeField ? offset : getOffsetFromLocalToSubtract(instant)); [EOL] }
public long add(long instant, long value) { [EOL]     int offset = getOffsetToAdd(instant); [EOL]     instant = iField.add(instant + offset, value); [EOL]     return instant - (iTimeField ? offset : getOffsetFromLocalToSubtract(instant)); [EOL] }
public long add(long instant, long value) { [EOL]     int offset = getOffsetToAdd(instant); [EOL]     instant = iField.add(instant + offset, value); [EOL]     return instant - (iTimeField ? offset : getOffsetFromLocalToSubtract(instant)); [EOL] }
private int getOffsetFromLocalToSubtract(long instant) { [EOL]     int offset = this.iZone.getOffsetFromLocal(instant); [EOL]     long diff = instant - offset; [EOL]     if ((instant ^ diff) < 0 && (instant ^ offset) < 0) { [EOL]         throw new ArithmeticException("Subtracting time zone offset caused overflow"); [EOL]     } [EOL]     return offset; [EOL] }
private int getOffsetFromLocalToSubtract(long instant) { [EOL]     int offset = this.iZone.getOffsetFromLocal(instant); [EOL]     long diff = instant - offset; [EOL]     if ((instant ^ diff) < 0 && (instant ^ offset) < 0) { [EOL]         throw new ArithmeticException("Subtracting time zone offset caused overflow"); [EOL]     } [EOL]     return offset; [EOL] }
public String getAsText(int fieldValue, Locale locale) { [EOL]     return iField.getAsText(fieldValue, locale); [EOL] }
public String getAsShortText(int fieldValue, Locale locale) { [EOL]     return iField.getAsShortText(fieldValue, locale); [EOL] }
public String getAsShortText(int fieldValue, Locale locale) { [EOL]     return iField.getAsShortText(fieldValue, locale); [EOL] }
public String getAsShortText(int fieldValue, Locale locale) { [EOL]     return iField.getAsShortText(fieldValue, locale); [EOL] }
public long add(long instant, long value) { [EOL]     if (iTimeField) { [EOL]         int offset = getOffsetToAdd(instant); [EOL]         long localInstant = iField.add(instant + offset, value); [EOL]         return localInstant - offset; [EOL]     } else { [EOL]         long localInstant = iZone.convertUTCToLocal(instant); [EOL]         localInstant = iField.add(localInstant, value); [EOL]         return iZone.convertLocalToUTC(localInstant, false, instant); [EOL]     } [EOL] }
public long add(long instant, long value) { [EOL]     if (iTimeField) { [EOL]         int offset = getOffsetToAdd(instant); [EOL]         long localInstant = iField.add(instant + offset, value); [EOL]         return localInstant - offset; [EOL]     } else { [EOL]         long localInstant = iZone.convertUTCToLocal(instant); [EOL]         localInstant = iField.add(localInstant, value); [EOL]         return iZone.convertLocalToUTC(localInstant, false, instant); [EOL]     } [EOL] }
public int getMinimumValue() { [EOL]     return iField.getMinimumValue(); [EOL] }
public int getMinimumValue(long instant) { [EOL]     long localInstant = iZone.convertUTCToLocal(instant); [EOL]     return iField.getMinimumValue(localInstant); [EOL] }
public int getMinimumValue(long instant) { [EOL]     long localInstant = iZone.convertUTCToLocal(instant); [EOL]     return iField.getMinimumValue(localInstant); [EOL] }
public DurationField getRangeDurationField() { [EOL]     return iChronology.weeks(); [EOL] }
public int getMinimumValue() { [EOL]     return DateTimeConstants.MONDAY; [EOL] }
public int getMaximumValue() { [EOL]     return DateTimeConstants.SUNDAY; [EOL] }
public int getMaximumShortTextLength(Locale locale) { [EOL]     return GJLocaleSymbols.forLocale(locale).getDayOfWeekMaxShortTextLength(); [EOL] }
public int getMaximumShortTextLength(Locale locale) { [EOL]     return GJLocaleSymbols.forLocale(locale).getDayOfWeekMaxShortTextLength(); [EOL] }
public int getMaximumShortTextLength(Locale locale) { [EOL]     return GJLocaleSymbols.forLocale(locale).getDayOfWeekMaxShortTextLength(); [EOL] }
private static String createMessage(String fieldName, Number value, Number lowerBound, Number upperBound, String explain) { [EOL]     StringBuilder buf = new StringBuilder().append("Value ").append(value).append(" for ").append(fieldName).append(' '); [EOL]     if (lowerBound == null) { [EOL]         if (upperBound == null) { [EOL]             buf.append("is not supported"); [EOL]         } else { [EOL]             buf.append("must not be larger than ").append(upperBound); [EOL]         } [EOL]     } else if (upperBound == null) { [EOL]         buf.append("must not be smaller than ").append(lowerBound); [EOL]     } else { [EOL]         buf.append("must be in the range [").append(lowerBound).append(',').append(upperBound).append(']'); [EOL]     } [EOL]     if (explain != null) { [EOL]         buf.append(": ").append(explain); [EOL]     } [EOL]     return buf.toString(); [EOL] }
private static String createMessage(String fieldName, Number value, Number lowerBound, Number upperBound, String explain) { [EOL]     StringBuilder buf = new StringBuilder().append("Value ").append(value).append(" for ").append(fieldName).append(' '); [EOL]     if (lowerBound == null) { [EOL]         if (upperBound == null) { [EOL]             buf.append("is not supported"); [EOL]         } else { [EOL]             buf.append("must not be larger than ").append(upperBound); [EOL]         } [EOL]     } else if (upperBound == null) { [EOL]         buf.append("must not be smaller than ").append(lowerBound); [EOL]     } else { [EOL]         buf.append("must be in the range [").append(lowerBound).append(',').append(upperBound).append(']'); [EOL]     } [EOL]     if (explain != null) { [EOL]         buf.append(": ").append(explain); [EOL]     } [EOL]     return buf.toString(); [EOL] }
private static String createMessage(String fieldName, Number value, Number lowerBound, Number upperBound, String explain) { [EOL]     StringBuilder buf = new StringBuilder().append("Value ").append(value).append(" for ").append(fieldName).append(' '); [EOL]     if (lowerBound == null) { [EOL]         if (upperBound == null) { [EOL]             buf.append("is not supported"); [EOL]         } else { [EOL]             buf.append("must not be larger than ").append(upperBound); [EOL]         } [EOL]     } else if (upperBound == null) { [EOL]         buf.append("must not be smaller than ").append(lowerBound); [EOL]     } else { [EOL]         buf.append("must be in the range [").append(lowerBound).append(',').append(upperBound).append(']'); [EOL]     } [EOL]     if (explain != null) { [EOL]         buf.append(": ").append(explain); [EOL]     } [EOL]     return buf.toString(); [EOL] }
private static String createMessage(String fieldName, Number value, Number lowerBound, Number upperBound, String explain) { [EOL]     StringBuilder buf = new StringBuilder().append("Value ").append(value).append(" for ").append(fieldName).append(' '); [EOL]     if (lowerBound == null) { [EOL]         if (upperBound == null) { [EOL]             buf.append("is not supported"); [EOL]         } else { [EOL]             buf.append("must not be larger than ").append(upperBound); [EOL]         } [EOL]     } else if (upperBound == null) { [EOL]         buf.append("must not be smaller than ").append(lowerBound); [EOL]     } else { [EOL]         buf.append("must be in the range [").append(lowerBound).append(',').append(upperBound).append(']'); [EOL]     } [EOL]     if (explain != null) { [EOL]         buf.append(": ").append(explain); [EOL]     } [EOL]     return buf.toString(); [EOL] }
private static String createMessage(String fieldName, Number value, Number lowerBound, Number upperBound, String explain) { [EOL]     StringBuilder buf = new StringBuilder().append("Value ").append(value).append(" for ").append(fieldName).append(' '); [EOL]     if (lowerBound == null) { [EOL]         if (upperBound == null) { [EOL]             buf.append("is not supported"); [EOL]         } else { [EOL]             buf.append("must not be larger than ").append(upperBound); [EOL]         } [EOL]     } else if (upperBound == null) { [EOL]         buf.append("must not be smaller than ").append(lowerBound); [EOL]     } else { [EOL]         buf.append("must be in the range [").append(lowerBound).append(',').append(upperBound).append(']'); [EOL]     } [EOL]     if (explain != null) { [EOL]         buf.append(": ").append(explain); [EOL]     } [EOL]     return buf.toString(); [EOL] }
public IllegalFieldValueException(DateTimeFieldType fieldType, Number value, String explain) { [EOL]     super(createMessage(fieldType.getName(), value, null, null, explain)); [EOL]     iDateTimeFieldType = fieldType; [EOL]     iDurationFieldType = null; [EOL]     iFieldName = fieldType.getName(); [EOL]     iNumberValue = value; [EOL]     iStringValue = null; [EOL]     iLowerBound = null; [EOL]     iUpperBound = null; [EOL]     iMessage = super.getMessage(); [EOL] }
public IllegalFieldValueException(DateTimeFieldType fieldType, Number value, String explain) { [EOL]     super(createMessage(fieldType.getName(), value, null, null, explain)); [EOL]     iDateTimeFieldType = fieldType; [EOL]     iDurationFieldType = null; [EOL]     iFieldName = fieldType.getName(); [EOL]     iNumberValue = value; [EOL]     iStringValue = null; [EOL]     iLowerBound = null; [EOL]     iUpperBound = null; [EOL]     iMessage = super.getMessage(); [EOL] }
@SuppressWarnings("deprecation") [EOL] public static LocalTime fromDateFields(Date date) { [EOL]     if (date == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     return new LocalTime(date.getHours(), date.getMinutes(), date.getSeconds(), (((int) (date.getTime() % 1000)) + 1000) % 1000); [EOL] }
@SuppressWarnings("deprecation") [EOL] public static LocalTime fromDateFields(Date date) { [EOL]     if (date == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     return new LocalTime(date.getHours(), date.getMinutes(), date.getSeconds(), (((int) (date.getTime() % 1000)) + 1000) % 1000); [EOL] }
public LocalTime(Object instant) { [EOL]     this(instant, (Chronology) null); [EOL] }
public LocalTime(Object instant) { [EOL]     this(instant, (Chronology) null); [EOL] }
public LocalTime(Object instant) { [EOL]     this(instant, (Chronology) null); [EOL] }
public LocalTime(Object instant, DateTimeZone zone) { [EOL]     PartialConverter converter = ConverterManager.getInstance().getPartialConverter(instant); [EOL]     Chronology chronology = converter.getChronology(instant, zone); [EOL]     chronology = DateTimeUtils.getChronology(chronology); [EOL]     iChronology = chronology.withUTC(); [EOL]     int[] values = converter.getPartialValues(this, instant, chronology, ISODateTimeFormat.localTimeParser()); [EOL]     iLocalMillis = iChronology.getDateTimeMillis(0L, values[0], values[1], values[2], values[3]); [EOL] }
public LocalTime(Object instant, DateTimeZone zone) { [EOL]     PartialConverter converter = ConverterManager.getInstance().getPartialConverter(instant); [EOL]     Chronology chronology = converter.getChronology(instant, zone); [EOL]     chronology = DateTimeUtils.getChronology(chronology); [EOL]     iChronology = chronology.withUTC(); [EOL]     int[] values = converter.getPartialValues(this, instant, chronology, ISODateTimeFormat.localTimeParser()); [EOL]     iLocalMillis = iChronology.getDateTimeMillis(0L, values[0], values[1], values[2], values[3]); [EOL] }
public LocalTime(Object instant, DateTimeZone zone) { [EOL]     PartialConverter converter = ConverterManager.getInstance().getPartialConverter(instant); [EOL]     Chronology chronology = converter.getChronology(instant, zone); [EOL]     chronology = DateTimeUtils.getChronology(chronology); [EOL]     iChronology = chronology.withUTC(); [EOL]     int[] values = converter.getPartialValues(this, instant, chronology, ISODateTimeFormat.localTimeParser()); [EOL]     iLocalMillis = iChronology.getDateTimeMillis(0L, values[0], values[1], values[2], values[3]); [EOL] }
public LocalTime(Object instant, DateTimeZone zone) { [EOL]     PartialConverter converter = ConverterManager.getInstance().getPartialConverter(instant); [EOL]     Chronology chronology = converter.getChronology(instant, zone); [EOL]     chronology = DateTimeUtils.getChronology(chronology); [EOL]     iChronology = chronology.withUTC(); [EOL]     int[] values = converter.getPartialValues(this, instant, chronology, ISODateTimeFormat.localTimeParser()); [EOL]     iLocalMillis = iChronology.getDateTimeMillis(0L, values[0], values[1], values[2], values[3]); [EOL] }
public LocalTime(Object instant, Chronology chronology) { [EOL]     PartialConverter converter = ConverterManager.getInstance().getPartialConverter(instant); [EOL]     chronology = converter.getChronology(instant, chronology); [EOL]     chronology = DateTimeUtils.getChronology(chronology); [EOL]     iChronology = chronology.withUTC(); [EOL]     int[] values = converter.getPartialValues(this, instant, chronology, ISODateTimeFormat.localTimeParser()); [EOL]     iLocalMillis = iChronology.getDateTimeMillis(0L, values[0], values[1], values[2], values[3]); [EOL] }
public int size() { [EOL]     return 4; [EOL] }
protected DateTimeField getField(int index, Chronology chrono) { [EOL]     switch(index) { [EOL]         case HOUR_OF_DAY: [EOL]             return chrono.hourOfDay(); [EOL]         case MINUTE_OF_HOUR: [EOL]             return chrono.minuteOfHour(); [EOL]         case SECOND_OF_MINUTE: [EOL]             return chrono.secondOfMinute(); [EOL]         case MILLIS_OF_SECOND: [EOL]             return chrono.millisOfSecond(); [EOL]         default: [EOL]             throw new IndexOutOfBoundsException("Invalid index: " + index); [EOL]     } [EOL] }
protected DateTimeField getField(int index, Chronology chrono) { [EOL]     switch(index) { [EOL]         case HOUR_OF_DAY: [EOL]             return chrono.hourOfDay(); [EOL]         case MINUTE_OF_HOUR: [EOL]             return chrono.minuteOfHour(); [EOL]         case SECOND_OF_MINUTE: [EOL]             return chrono.secondOfMinute(); [EOL]         case MILLIS_OF_SECOND: [EOL]             return chrono.millisOfSecond(); [EOL]         default: [EOL]             throw new IndexOutOfBoundsException("Invalid index: " + index); [EOL]     } [EOL] }
protected DateTimeField getField(int index, Chronology chrono) { [EOL]     switch(index) { [EOL]         case HOUR_OF_DAY: [EOL]             return chrono.hourOfDay(); [EOL]         case MINUTE_OF_HOUR: [EOL]             return chrono.minuteOfHour(); [EOL]         case SECOND_OF_MINUTE: [EOL]             return chrono.secondOfMinute(); [EOL]         case MILLIS_OF_SECOND: [EOL]             return chrono.millisOfSecond(); [EOL]         default: [EOL]             throw new IndexOutOfBoundsException("Invalid index: " + index); [EOL]     } [EOL] }
protected DateTimeField getField(int index, Chronology chrono) { [EOL]     switch(index) { [EOL]         case HOUR_OF_DAY: [EOL]             return chrono.hourOfDay(); [EOL]         case MINUTE_OF_HOUR: [EOL]             return chrono.minuteOfHour(); [EOL]         case SECOND_OF_MINUTE: [EOL]             return chrono.secondOfMinute(); [EOL]         case MILLIS_OF_SECOND: [EOL]             return chrono.millisOfSecond(); [EOL]         default: [EOL]             throw new IndexOutOfBoundsException("Invalid index: " + index); [EOL]     } [EOL] }
protected DateTimeField getField(int index, Chronology chrono) { [EOL]     switch(index) { [EOL]         case HOUR_OF_DAY: [EOL]             return chrono.hourOfDay(); [EOL]         case MINUTE_OF_HOUR: [EOL]             return chrono.minuteOfHour(); [EOL]         case SECOND_OF_MINUTE: [EOL]             return chrono.secondOfMinute(); [EOL]         case MILLIS_OF_SECOND: [EOL]             return chrono.millisOfSecond(); [EOL]         default: [EOL]             throw new IndexOutOfBoundsException("Invalid index: " + index); [EOL]     } [EOL] }
public boolean isSupported(DurationFieldType type) { [EOL]     if (type == null) { [EOL]         return false; [EOL]     } [EOL]     DurationField field = type.getField(getChronology()); [EOL]     if (TIME_DURATION_TYPES.contains(type) || field.getUnitMillis() < getChronology().days().getUnitMillis()) { [EOL]         return field.isSupported(); [EOL]     } [EOL]     return false; [EOL] }
public boolean isSupported(DurationFieldType type) { [EOL]     if (type == null) { [EOL]         return false; [EOL]     } [EOL]     DurationField field = type.getField(getChronology()); [EOL]     if (TIME_DURATION_TYPES.contains(type) || field.getUnitMillis() < getChronology().days().getUnitMillis()) { [EOL]         return field.isSupported(); [EOL]     } [EOL]     return false; [EOL] }
public boolean isSupported(DurationFieldType type) { [EOL]     if (type == null) { [EOL]         return false; [EOL]     } [EOL]     DurationField field = type.getField(getChronology()); [EOL]     if (TIME_DURATION_TYPES.contains(type) || field.getUnitMillis() < getChronology().days().getUnitMillis()) { [EOL]         return field.isSupported(); [EOL]     } [EOL]     return false; [EOL] }
public boolean isSupported(DurationFieldType type) { [EOL]     if (type == null) { [EOL]         return false; [EOL]     } [EOL]     DurationField field = type.getField(getChronology()); [EOL]     if (TIME_DURATION_TYPES.contains(type) || field.getUnitMillis() < getChronology().days().getUnitMillis()) { [EOL]         return field.isSupported(); [EOL]     } [EOL]     return false; [EOL] }
public boolean equals(Object partial) { [EOL]     if (this == partial) { [EOL]         return true; [EOL]     } [EOL]     if (partial instanceof LocalTime) { [EOL]         LocalTime other = (LocalTime) partial; [EOL]         if (iChronology.equals(other.iChronology)) { [EOL]             return iLocalMillis == other.iLocalMillis; [EOL]         } [EOL]     } [EOL]     return super.equals(partial); [EOL] }
public boolean equals(Object partial) { [EOL]     if (this == partial) { [EOL]         return true; [EOL]     } [EOL]     if (partial instanceof LocalTime) { [EOL]         LocalTime other = (LocalTime) partial; [EOL]         if (iChronology.equals(other.iChronology)) { [EOL]             return iLocalMillis == other.iLocalMillis; [EOL]         } [EOL]     } [EOL]     return super.equals(partial); [EOL] }
public boolean equals(Object partial) { [EOL]     if (this == partial) { [EOL]         return true; [EOL]     } [EOL]     if (partial instanceof LocalTime) { [EOL]         LocalTime other = (LocalTime) partial; [EOL]         if (iChronology.equals(other.iChronology)) { [EOL]             return iLocalMillis == other.iLocalMillis; [EOL]         } [EOL]     } [EOL]     return super.equals(partial); [EOL] }
public boolean equals(Object partial) { [EOL]     if (this == partial) { [EOL]         return true; [EOL]     } [EOL]     if (partial instanceof LocalTime) { [EOL]         LocalTime other = (LocalTime) partial; [EOL]         if (iChronology.equals(other.iChronology)) { [EOL]             return iLocalMillis == other.iLocalMillis; [EOL]         } [EOL]     } [EOL]     return super.equals(partial); [EOL] }
public boolean equals(Object partial) { [EOL]     if (this == partial) { [EOL]         return true; [EOL]     } [EOL]     if (partial instanceof LocalTime) { [EOL]         LocalTime other = (LocalTime) partial; [EOL]         if (iChronology.equals(other.iChronology)) { [EOL]             return iLocalMillis == other.iLocalMillis; [EOL]         } [EOL]     } [EOL]     return super.equals(partial); [EOL] }
public LocalTime withFieldAdded(DurationFieldType fieldType, int amount) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("Field must not be null"); [EOL]     } [EOL]     if (isSupported(fieldType) == false) { [EOL]         throw new IllegalArgumentException("Field '" + fieldType + "' is not supported"); [EOL]     } [EOL]     if (amount == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = fieldType.getField(getChronology()).add(getLocalMillis(), amount); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalTime withFieldAdded(DurationFieldType fieldType, int amount) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("Field must not be null"); [EOL]     } [EOL]     if (isSupported(fieldType) == false) { [EOL]         throw new IllegalArgumentException("Field '" + fieldType + "' is not supported"); [EOL]     } [EOL]     if (amount == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = fieldType.getField(getChronology()).add(getLocalMillis(), amount); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalTime withFieldAdded(DurationFieldType fieldType, int amount) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("Field must not be null"); [EOL]     } [EOL]     if (isSupported(fieldType) == false) { [EOL]         throw new IllegalArgumentException("Field '" + fieldType + "' is not supported"); [EOL]     } [EOL]     if (amount == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = fieldType.getField(getChronology()).add(getLocalMillis(), amount); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalTime withFieldAdded(DurationFieldType fieldType, int amount) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("Field must not be null"); [EOL]     } [EOL]     if (isSupported(fieldType) == false) { [EOL]         throw new IllegalArgumentException("Field '" + fieldType + "' is not supported"); [EOL]     } [EOL]     if (amount == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = fieldType.getField(getChronology()).add(getLocalMillis(), amount); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalTime plusMinutes(int minutes) { [EOL]     if (minutes == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().minutes().add(getLocalMillis(), minutes); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalTime plusMinutes(int minutes) { [EOL]     if (minutes == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().minutes().add(getLocalMillis(), minutes); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalTime plusMinutes(int minutes) { [EOL]     if (minutes == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().minutes().add(getLocalMillis(), minutes); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalTime plusSeconds(int seconds) { [EOL]     if (seconds == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().seconds().add(getLocalMillis(), seconds); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalTime plusSeconds(int seconds) { [EOL]     if (seconds == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().seconds().add(getLocalMillis(), seconds); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalTime plusSeconds(int seconds) { [EOL]     if (seconds == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().seconds().add(getLocalMillis(), seconds); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalTime minusMinutes(int minutes) { [EOL]     if (minutes == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().minutes().subtract(getLocalMillis(), minutes); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalTime minusMinutes(int minutes) { [EOL]     if (minutes == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().minutes().subtract(getLocalMillis(), minutes); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalTime minusMinutes(int minutes) { [EOL]     if (minutes == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().minutes().subtract(getLocalMillis(), minutes); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalTime minusSeconds(int seconds) { [EOL]     if (seconds == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().seconds().subtract(getLocalMillis(), seconds); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalTime minusSeconds(int seconds) { [EOL]     if (seconds == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().seconds().subtract(getLocalMillis(), seconds); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalTime minusSeconds(int seconds) { [EOL]     if (seconds == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().seconds().subtract(getLocalMillis(), seconds); [EOL]     return withLocalMillis(instant); [EOL] }
public long set(long millis, int value) { [EOL]     FieldUtils.verifyValueBounds(this, value, iMinValue, getMaximumValue()); [EOL]     if (value <= iSkip) { [EOL]         if (value == iSkip) { [EOL]             throw new IllegalFieldValueException(DateTimeFieldType.year(), Integer.valueOf(value), null, null); [EOL]         } [EOL]         value++; [EOL]     } [EOL]     return super.set(millis, value); [EOL] }
public long set(long millis, int value) { [EOL]     FieldUtils.verifyValueBounds(this, value, iMinValue, getMaximumValue()); [EOL]     if (value <= iSkip) { [EOL]         if (value == iSkip) { [EOL]             throw new IllegalFieldValueException(DateTimeFieldType.year(), Integer.valueOf(value), null, null); [EOL]         } [EOL]         value++; [EOL]     } [EOL]     return super.set(millis, value); [EOL] }
public long set(long millis, int value) { [EOL]     FieldUtils.verifyValueBounds(this, value, iMinValue, getMaximumValue()); [EOL]     if (value <= iSkip) { [EOL]         if (value == iSkip) { [EOL]             throw new IllegalFieldValueException(DateTimeFieldType.year(), Integer.valueOf(value), null, null); [EOL]         } [EOL]         value++; [EOL]     } [EOL]     return super.set(millis, value); [EOL] }
public long set(long millis, int value) { [EOL]     FieldUtils.verifyValueBounds(this, value, iMinValue, getMaximumValue()); [EOL]     if (value <= iSkip) { [EOL]         if (value == iSkip) { [EOL]             throw new IllegalFieldValueException(DateTimeFieldType.year(), Integer.valueOf(value), null, null); [EOL]         } [EOL]         value++; [EOL]     } [EOL]     return super.set(millis, value); [EOL] }
public static DurationFieldType weeks() { [EOL]     return WEEKS_TYPE; [EOL] }
public boolean isSupported(Chronology chronology) { [EOL]     return getField(chronology).isSupported(); [EOL] }
public boolean isSupported(Chronology chronology) { [EOL]     return getField(chronology).isSupported(); [EOL] }
public String toString() { [EOL]     return getName(); [EOL] }
@Override [EOL] public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof StandardDurationFieldType) { [EOL]         return iOrdinal == ((StandardDurationFieldType) obj).iOrdinal; [EOL]     } [EOL]     return false; [EOL] }
@Override [EOL] public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof StandardDurationFieldType) { [EOL]         return iOrdinal == ((StandardDurationFieldType) obj).iOrdinal; [EOL]     } [EOL]     return false; [EOL] }
@Override [EOL] public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof StandardDurationFieldType) { [EOL]         return iOrdinal == ((StandardDurationFieldType) obj).iOrdinal; [EOL]     } [EOL]     return false; [EOL] }
@Override [EOL] public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof StandardDurationFieldType) { [EOL]         return iOrdinal == ((StandardDurationFieldType) obj).iOrdinal; [EOL]     } [EOL]     return false; [EOL] }
@Override [EOL] public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof StandardDurationFieldType) { [EOL]         return iOrdinal == ((StandardDurationFieldType) obj).iOrdinal; [EOL]     } [EOL]     return false; [EOL] }
public DurationField getField(Chronology chronology) { [EOL]     chronology = DateTimeUtils.getChronology(chronology); [EOL]     switch(iOrdinal) { [EOL]         case ERAS: [EOL]             return chronology.eras(); [EOL]         case CENTURIES: [EOL]             return chronology.centuries(); [EOL]         case WEEKYEARS: [EOL]             return chronology.weekyears(); [EOL]         case YEARS: [EOL]             return chronology.years(); [EOL]         case MONTHS: [EOL]             return chronology.months(); [EOL]         case WEEKS: [EOL]             return chronology.weeks(); [EOL]         case DAYS: [EOL]             return chronology.days(); [EOL]         case HALFDAYS: [EOL]             return chronology.halfdays(); [EOL]         case HOURS: [EOL]             return chronology.hours(); [EOL]         case MINUTES: [EOL]             return chronology.minutes(); [EOL]         case SECONDS: [EOL]             return chronology.seconds(); [EOL]         case MILLIS: [EOL]             return chronology.millis(); [EOL]         default: [EOL]             throw new InternalError(); [EOL]     } [EOL] }
public DurationField getField(Chronology chronology) { [EOL]     chronology = DateTimeUtils.getChronology(chronology); [EOL]     switch(iOrdinal) { [EOL]         case ERAS: [EOL]             return chronology.eras(); [EOL]         case CENTURIES: [EOL]             return chronology.centuries(); [EOL]         case WEEKYEARS: [EOL]             return chronology.weekyears(); [EOL]         case YEARS: [EOL]             return chronology.years(); [EOL]         case MONTHS: [EOL]             return chronology.months(); [EOL]         case WEEKS: [EOL]             return chronology.weeks(); [EOL]         case DAYS: [EOL]             return chronology.days(); [EOL]         case HALFDAYS: [EOL]             return chronology.halfdays(); [EOL]         case HOURS: [EOL]             return chronology.hours(); [EOL]         case MINUTES: [EOL]             return chronology.minutes(); [EOL]         case SECONDS: [EOL]             return chronology.seconds(); [EOL]         case MILLIS: [EOL]             return chronology.millis(); [EOL]         default: [EOL]             throw new InternalError(); [EOL]     } [EOL] }
public DurationField getField(Chronology chronology) { [EOL]     chronology = DateTimeUtils.getChronology(chronology); [EOL]     switch(iOrdinal) { [EOL]         case ERAS: [EOL]             return chronology.eras(); [EOL]         case CENTURIES: [EOL]             return chronology.centuries(); [EOL]         case WEEKYEARS: [EOL]             return chronology.weekyears(); [EOL]         case YEARS: [EOL]             return chronology.years(); [EOL]         case MONTHS: [EOL]             return chronology.months(); [EOL]         case WEEKS: [EOL]             return chronology.weeks(); [EOL]         case DAYS: [EOL]             return chronology.days(); [EOL]         case HALFDAYS: [EOL]             return chronology.halfdays(); [EOL]         case HOURS: [EOL]             return chronology.hours(); [EOL]         case MINUTES: [EOL]             return chronology.minutes(); [EOL]         case SECONDS: [EOL]             return chronology.seconds(); [EOL]         case MILLIS: [EOL]             return chronology.millis(); [EOL]         default: [EOL]             throw new InternalError(); [EOL]     } [EOL] }
public DurationField getField(Chronology chronology) { [EOL]     chronology = DateTimeUtils.getChronology(chronology); [EOL]     switch(iOrdinal) { [EOL]         case ERAS: [EOL]             return chronology.eras(); [EOL]         case CENTURIES: [EOL]             return chronology.centuries(); [EOL]         case WEEKYEARS: [EOL]             return chronology.weekyears(); [EOL]         case YEARS: [EOL]             return chronology.years(); [EOL]         case MONTHS: [EOL]             return chronology.months(); [EOL]         case WEEKS: [EOL]             return chronology.weeks(); [EOL]         case DAYS: [EOL]             return chronology.days(); [EOL]         case HALFDAYS: [EOL]             return chronology.halfdays(); [EOL]         case HOURS: [EOL]             return chronology.hours(); [EOL]         case MINUTES: [EOL]             return chronology.minutes(); [EOL]         case SECONDS: [EOL]             return chronology.seconds(); [EOL]         case MILLIS: [EOL]             return chronology.millis(); [EOL]         default: [EOL]             throw new InternalError(); [EOL]     } [EOL] }
public DurationField getField(Chronology chronology) { [EOL]     chronology = DateTimeUtils.getChronology(chronology); [EOL]     switch(iOrdinal) { [EOL]         case ERAS: [EOL]             return chronology.eras(); [EOL]         case CENTURIES: [EOL]             return chronology.centuries(); [EOL]         case WEEKYEARS: [EOL]             return chronology.weekyears(); [EOL]         case YEARS: [EOL]             return chronology.years(); [EOL]         case MONTHS: [EOL]             return chronology.months(); [EOL]         case WEEKS: [EOL]             return chronology.weeks(); [EOL]         case DAYS: [EOL]             return chronology.days(); [EOL]         case HALFDAYS: [EOL]             return chronology.halfdays(); [EOL]         case HOURS: [EOL]             return chronology.hours(); [EOL]         case MINUTES: [EOL]             return chronology.minutes(); [EOL]         case SECONDS: [EOL]             return chronology.seconds(); [EOL]         case MILLIS: [EOL]             return chronology.millis(); [EOL]         default: [EOL]             throw new InternalError(); [EOL]     } [EOL] }
public DurationField getField(Chronology chronology) { [EOL]     chronology = DateTimeUtils.getChronology(chronology); [EOL]     switch(iOrdinal) { [EOL]         case ERAS: [EOL]             return chronology.eras(); [EOL]         case CENTURIES: [EOL]             return chronology.centuries(); [EOL]         case WEEKYEARS: [EOL]             return chronology.weekyears(); [EOL]         case YEARS: [EOL]             return chronology.years(); [EOL]         case MONTHS: [EOL]             return chronology.months(); [EOL]         case WEEKS: [EOL]             return chronology.weeks(); [EOL]         case DAYS: [EOL]             return chronology.days(); [EOL]         case HALFDAYS: [EOL]             return chronology.halfdays(); [EOL]         case HOURS: [EOL]             return chronology.hours(); [EOL]         case MINUTES: [EOL]             return chronology.minutes(); [EOL]         case SECONDS: [EOL]             return chronology.seconds(); [EOL]         case MILLIS: [EOL]             return chronology.millis(); [EOL]         default: [EOL]             throw new InternalError(); [EOL]     } [EOL] }
public DurationField getField(Chronology chronology) { [EOL]     chronology = DateTimeUtils.getChronology(chronology); [EOL]     switch(iOrdinal) { [EOL]         case ERAS: [EOL]             return chronology.eras(); [EOL]         case CENTURIES: [EOL]             return chronology.centuries(); [EOL]         case WEEKYEARS: [EOL]             return chronology.weekyears(); [EOL]         case YEARS: [EOL]             return chronology.years(); [EOL]         case MONTHS: [EOL]             return chronology.months(); [EOL]         case WEEKS: [EOL]             return chronology.weeks(); [EOL]         case DAYS: [EOL]             return chronology.days(); [EOL]         case HALFDAYS: [EOL]             return chronology.halfdays(); [EOL]         case HOURS: [EOL]             return chronology.hours(); [EOL]         case MINUTES: [EOL]             return chronology.minutes(); [EOL]         case SECONDS: [EOL]             return chronology.seconds(); [EOL]         case MILLIS: [EOL]             return chronology.millis(); [EOL]         default: [EOL]             throw new InternalError(); [EOL]     } [EOL] }
public DurationField getField(Chronology chronology) { [EOL]     chronology = DateTimeUtils.getChronology(chronology); [EOL]     switch(iOrdinal) { [EOL]         case ERAS: [EOL]             return chronology.eras(); [EOL]         case CENTURIES: [EOL]             return chronology.centuries(); [EOL]         case WEEKYEARS: [EOL]             return chronology.weekyears(); [EOL]         case YEARS: [EOL]             return chronology.years(); [EOL]         case MONTHS: [EOL]             return chronology.months(); [EOL]         case WEEKS: [EOL]             return chronology.weeks(); [EOL]         case DAYS: [EOL]             return chronology.days(); [EOL]         case HALFDAYS: [EOL]             return chronology.halfdays(); [EOL]         case HOURS: [EOL]             return chronology.hours(); [EOL]         case MINUTES: [EOL]             return chronology.minutes(); [EOL]         case SECONDS: [EOL]             return chronology.seconds(); [EOL]         case MILLIS: [EOL]             return chronology.millis(); [EOL]         default: [EOL]             throw new InternalError(); [EOL]     } [EOL] }
public DurationField getField(Chronology chronology) { [EOL]     chronology = DateTimeUtils.getChronology(chronology); [EOL]     switch(iOrdinal) { [EOL]         case ERAS: [EOL]             return chronology.eras(); [EOL]         case CENTURIES: [EOL]             return chronology.centuries(); [EOL]         case WEEKYEARS: [EOL]             return chronology.weekyears(); [EOL]         case YEARS: [EOL]             return chronology.years(); [EOL]         case MONTHS: [EOL]             return chronology.months(); [EOL]         case WEEKS: [EOL]             return chronology.weeks(); [EOL]         case DAYS: [EOL]             return chronology.days(); [EOL]         case HALFDAYS: [EOL]             return chronology.halfdays(); [EOL]         case HOURS: [EOL]             return chronology.hours(); [EOL]         case MINUTES: [EOL]             return chronology.minutes(); [EOL]         case SECONDS: [EOL]             return chronology.seconds(); [EOL]         case MILLIS: [EOL]             return chronology.millis(); [EOL]         default: [EOL]             throw new InternalError(); [EOL]     } [EOL] }
public DurationField getField(Chronology chronology) { [EOL]     chronology = DateTimeUtils.getChronology(chronology); [EOL]     switch(iOrdinal) { [EOL]         case ERAS: [EOL]             return chronology.eras(); [EOL]         case CENTURIES: [EOL]             return chronology.centuries(); [EOL]         case WEEKYEARS: [EOL]             return chronology.weekyears(); [EOL]         case YEARS: [EOL]             return chronology.years(); [EOL]         case MONTHS: [EOL]             return chronology.months(); [EOL]         case WEEKS: [EOL]             return chronology.weeks(); [EOL]         case DAYS: [EOL]             return chronology.days(); [EOL]         case HALFDAYS: [EOL]             return chronology.halfdays(); [EOL]         case HOURS: [EOL]             return chronology.hours(); [EOL]         case MINUTES: [EOL]             return chronology.minutes(); [EOL]         case SECONDS: [EOL]             return chronology.seconds(); [EOL]         case MILLIS: [EOL]             return chronology.millis(); [EOL]         default: [EOL]             throw new InternalError(); [EOL]     } [EOL] }
public DurationField getField(Chronology chronology) { [EOL]     chronology = DateTimeUtils.getChronology(chronology); [EOL]     switch(iOrdinal) { [EOL]         case ERAS: [EOL]             return chronology.eras(); [EOL]         case CENTURIES: [EOL]             return chronology.centuries(); [EOL]         case WEEKYEARS: [EOL]             return chronology.weekyears(); [EOL]         case YEARS: [EOL]             return chronology.years(); [EOL]         case MONTHS: [EOL]             return chronology.months(); [EOL]         case WEEKS: [EOL]             return chronology.weeks(); [EOL]         case DAYS: [EOL]             return chronology.days(); [EOL]         case HALFDAYS: [EOL]             return chronology.halfdays(); [EOL]         case HOURS: [EOL]             return chronology.hours(); [EOL]         case MINUTES: [EOL]             return chronology.minutes(); [EOL]         case SECONDS: [EOL]             return chronology.seconds(); [EOL]         case MILLIS: [EOL]             return chronology.millis(); [EOL]         default: [EOL]             throw new InternalError(); [EOL]     } [EOL] }
public DurationField getField(Chronology chronology) { [EOL]     chronology = DateTimeUtils.getChronology(chronology); [EOL]     switch(iOrdinal) { [EOL]         case ERAS: [EOL]             return chronology.eras(); [EOL]         case CENTURIES: [EOL]             return chronology.centuries(); [EOL]         case WEEKYEARS: [EOL]             return chronology.weekyears(); [EOL]         case YEARS: [EOL]             return chronology.years(); [EOL]         case MONTHS: [EOL]             return chronology.months(); [EOL]         case WEEKS: [EOL]             return chronology.weeks(); [EOL]         case DAYS: [EOL]             return chronology.days(); [EOL]         case HALFDAYS: [EOL]             return chronology.halfdays(); [EOL]         case HOURS: [EOL]             return chronology.hours(); [EOL]         case MINUTES: [EOL]             return chronology.minutes(); [EOL]         case SECONDS: [EOL]             return chronology.seconds(); [EOL]         case MILLIS: [EOL]             return chronology.millis(); [EOL]         default: [EOL]             throw new InternalError(); [EOL]     } [EOL] }
public DurationField getField(Chronology chronology) { [EOL]     chronology = DateTimeUtils.getChronology(chronology); [EOL]     switch(iOrdinal) { [EOL]         case ERAS: [EOL]             return chronology.eras(); [EOL]         case CENTURIES: [EOL]             return chronology.centuries(); [EOL]         case WEEKYEARS: [EOL]             return chronology.weekyears(); [EOL]         case YEARS: [EOL]             return chronology.years(); [EOL]         case MONTHS: [EOL]             return chronology.months(); [EOL]         case WEEKS: [EOL]             return chronology.weeks(); [EOL]         case DAYS: [EOL]             return chronology.days(); [EOL]         case HALFDAYS: [EOL]             return chronology.halfdays(); [EOL]         case HOURS: [EOL]             return chronology.hours(); [EOL]         case MINUTES: [EOL]             return chronology.minutes(); [EOL]         case SECONDS: [EOL]             return chronology.seconds(); [EOL]         case MILLIS: [EOL]             return chronology.millis(); [EOL]         default: [EOL]             throw new InternalError(); [EOL]     } [EOL] }
private Object readResolve() { [EOL]     switch(iOrdinal) { [EOL]         case ERAS: [EOL]             return ERAS_TYPE; [EOL]         case CENTURIES: [EOL]             return CENTURIES_TYPE; [EOL]         case WEEKYEARS: [EOL]             return WEEKYEARS_TYPE; [EOL]         case YEARS: [EOL]             return YEARS_TYPE; [EOL]         case MONTHS: [EOL]             return MONTHS_TYPE; [EOL]         case WEEKS: [EOL]             return WEEKS_TYPE; [EOL]         case DAYS: [EOL]             return DAYS_TYPE; [EOL]         case HALFDAYS: [EOL]             return HALFDAYS_TYPE; [EOL]         case HOURS: [EOL]             return HOURS_TYPE; [EOL]         case MINUTES: [EOL]             return MINUTES_TYPE; [EOL]         case SECONDS: [EOL]             return SECONDS_TYPE; [EOL]         case MILLIS: [EOL]             return MILLIS_TYPE; [EOL]         default: [EOL]             return this; [EOL]     } [EOL] }
private Object readResolve() { [EOL]     switch(iOrdinal) { [EOL]         case ERAS: [EOL]             return ERAS_TYPE; [EOL]         case CENTURIES: [EOL]             return CENTURIES_TYPE; [EOL]         case WEEKYEARS: [EOL]             return WEEKYEARS_TYPE; [EOL]         case YEARS: [EOL]             return YEARS_TYPE; [EOL]         case MONTHS: [EOL]             return MONTHS_TYPE; [EOL]         case WEEKS: [EOL]             return WEEKS_TYPE; [EOL]         case DAYS: [EOL]             return DAYS_TYPE; [EOL]         case HALFDAYS: [EOL]             return HALFDAYS_TYPE; [EOL]         case HOURS: [EOL]             return HOURS_TYPE; [EOL]         case MINUTES: [EOL]             return MINUTES_TYPE; [EOL]         case SECONDS: [EOL]             return SECONDS_TYPE; [EOL]         case MILLIS: [EOL]             return MILLIS_TYPE; [EOL]         default: [EOL]             return this; [EOL]     } [EOL] }
private Object readResolve() { [EOL]     switch(iOrdinal) { [EOL]         case ERAS: [EOL]             return ERAS_TYPE; [EOL]         case CENTURIES: [EOL]             return CENTURIES_TYPE; [EOL]         case WEEKYEARS: [EOL]             return WEEKYEARS_TYPE; [EOL]         case YEARS: [EOL]             return YEARS_TYPE; [EOL]         case MONTHS: [EOL]             return MONTHS_TYPE; [EOL]         case WEEKS: [EOL]             return WEEKS_TYPE; [EOL]         case DAYS: [EOL]             return DAYS_TYPE; [EOL]         case HALFDAYS: [EOL]             return HALFDAYS_TYPE; [EOL]         case HOURS: [EOL]             return HOURS_TYPE; [EOL]         case MINUTES: [EOL]             return MINUTES_TYPE; [EOL]         case SECONDS: [EOL]             return SECONDS_TYPE; [EOL]         case MILLIS: [EOL]             return MILLIS_TYPE; [EOL]         default: [EOL]             return this; [EOL]     } [EOL] }
private Object readResolve() { [EOL]     switch(iOrdinal) { [EOL]         case ERAS: [EOL]             return ERAS_TYPE; [EOL]         case CENTURIES: [EOL]             return CENTURIES_TYPE; [EOL]         case WEEKYEARS: [EOL]             return WEEKYEARS_TYPE; [EOL]         case YEARS: [EOL]             return YEARS_TYPE; [EOL]         case MONTHS: [EOL]             return MONTHS_TYPE; [EOL]         case WEEKS: [EOL]             return WEEKS_TYPE; [EOL]         case DAYS: [EOL]             return DAYS_TYPE; [EOL]         case HALFDAYS: [EOL]             return HALFDAYS_TYPE; [EOL]         case HOURS: [EOL]             return HOURS_TYPE; [EOL]         case MINUTES: [EOL]             return MINUTES_TYPE; [EOL]         case SECONDS: [EOL]             return SECONDS_TYPE; [EOL]         case MILLIS: [EOL]             return MILLIS_TYPE; [EOL]         default: [EOL]             return this; [EOL]     } [EOL] }
private Object readResolve() { [EOL]     switch(iOrdinal) { [EOL]         case ERAS: [EOL]             return ERAS_TYPE; [EOL]         case CENTURIES: [EOL]             return CENTURIES_TYPE; [EOL]         case WEEKYEARS: [EOL]             return WEEKYEARS_TYPE; [EOL]         case YEARS: [EOL]             return YEARS_TYPE; [EOL]         case MONTHS: [EOL]             return MONTHS_TYPE; [EOL]         case WEEKS: [EOL]             return WEEKS_TYPE; [EOL]         case DAYS: [EOL]             return DAYS_TYPE; [EOL]         case HALFDAYS: [EOL]             return HALFDAYS_TYPE; [EOL]         case HOURS: [EOL]             return HOURS_TYPE; [EOL]         case MINUTES: [EOL]             return MINUTES_TYPE; [EOL]         case SECONDS: [EOL]             return SECONDS_TYPE; [EOL]         case MILLIS: [EOL]             return MILLIS_TYPE; [EOL]         default: [EOL]             return this; [EOL]     } [EOL] }
private Object readResolve() { [EOL]     switch(iOrdinal) { [EOL]         case ERAS: [EOL]             return ERAS_TYPE; [EOL]         case CENTURIES: [EOL]             return CENTURIES_TYPE; [EOL]         case WEEKYEARS: [EOL]             return WEEKYEARS_TYPE; [EOL]         case YEARS: [EOL]             return YEARS_TYPE; [EOL]         case MONTHS: [EOL]             return MONTHS_TYPE; [EOL]         case WEEKS: [EOL]             return WEEKS_TYPE; [EOL]         case DAYS: [EOL]             return DAYS_TYPE; [EOL]         case HALFDAYS: [EOL]             return HALFDAYS_TYPE; [EOL]         case HOURS: [EOL]             return HOURS_TYPE; [EOL]         case MINUTES: [EOL]             return MINUTES_TYPE; [EOL]         case SECONDS: [EOL]             return SECONDS_TYPE; [EOL]         case MILLIS: [EOL]             return MILLIS_TYPE; [EOL]         default: [EOL]             return this; [EOL]     } [EOL] }
private Object readResolve() { [EOL]     switch(iOrdinal) { [EOL]         case ERAS: [EOL]             return ERAS_TYPE; [EOL]         case CENTURIES: [EOL]             return CENTURIES_TYPE; [EOL]         case WEEKYEARS: [EOL]             return WEEKYEARS_TYPE; [EOL]         case YEARS: [EOL]             return YEARS_TYPE; [EOL]         case MONTHS: [EOL]             return MONTHS_TYPE; [EOL]         case WEEKS: [EOL]             return WEEKS_TYPE; [EOL]         case DAYS: [EOL]             return DAYS_TYPE; [EOL]         case HALFDAYS: [EOL]             return HALFDAYS_TYPE; [EOL]         case HOURS: [EOL]             return HOURS_TYPE; [EOL]         case MINUTES: [EOL]             return MINUTES_TYPE; [EOL]         case SECONDS: [EOL]             return SECONDS_TYPE; [EOL]         case MILLIS: [EOL]             return MILLIS_TYPE; [EOL]         default: [EOL]             return this; [EOL]     } [EOL] }
private Object readResolve() { [EOL]     switch(iOrdinal) { [EOL]         case ERAS: [EOL]             return ERAS_TYPE; [EOL]         case CENTURIES: [EOL]             return CENTURIES_TYPE; [EOL]         case WEEKYEARS: [EOL]             return WEEKYEARS_TYPE; [EOL]         case YEARS: [EOL]             return YEARS_TYPE; [EOL]         case MONTHS: [EOL]             return MONTHS_TYPE; [EOL]         case WEEKS: [EOL]             return WEEKS_TYPE; [EOL]         case DAYS: [EOL]             return DAYS_TYPE; [EOL]         case HALFDAYS: [EOL]             return HALFDAYS_TYPE; [EOL]         case HOURS: [EOL]             return HOURS_TYPE; [EOL]         case MINUTES: [EOL]             return MINUTES_TYPE; [EOL]         case SECONDS: [EOL]             return SECONDS_TYPE; [EOL]         case MILLIS: [EOL]             return MILLIS_TYPE; [EOL]         default: [EOL]             return this; [EOL]     } [EOL] }
private Object readResolve() { [EOL]     switch(iOrdinal) { [EOL]         case ERAS: [EOL]             return ERAS_TYPE; [EOL]         case CENTURIES: [EOL]             return CENTURIES_TYPE; [EOL]         case WEEKYEARS: [EOL]             return WEEKYEARS_TYPE; [EOL]         case YEARS: [EOL]             return YEARS_TYPE; [EOL]         case MONTHS: [EOL]             return MONTHS_TYPE; [EOL]         case WEEKS: [EOL]             return WEEKS_TYPE; [EOL]         case DAYS: [EOL]             return DAYS_TYPE; [EOL]         case HALFDAYS: [EOL]             return HALFDAYS_TYPE; [EOL]         case HOURS: [EOL]             return HOURS_TYPE; [EOL]         case MINUTES: [EOL]             return MINUTES_TYPE; [EOL]         case SECONDS: [EOL]             return SECONDS_TYPE; [EOL]         case MILLIS: [EOL]             return MILLIS_TYPE; [EOL]         default: [EOL]             return this; [EOL]     } [EOL] }
private Object readResolve() { [EOL]     switch(iOrdinal) { [EOL]         case ERAS: [EOL]             return ERAS_TYPE; [EOL]         case CENTURIES: [EOL]             return CENTURIES_TYPE; [EOL]         case WEEKYEARS: [EOL]             return WEEKYEARS_TYPE; [EOL]         case YEARS: [EOL]             return YEARS_TYPE; [EOL]         case MONTHS: [EOL]             return MONTHS_TYPE; [EOL]         case WEEKS: [EOL]             return WEEKS_TYPE; [EOL]         case DAYS: [EOL]             return DAYS_TYPE; [EOL]         case HALFDAYS: [EOL]             return HALFDAYS_TYPE; [EOL]         case HOURS: [EOL]             return HOURS_TYPE; [EOL]         case MINUTES: [EOL]             return MINUTES_TYPE; [EOL]         case SECONDS: [EOL]             return SECONDS_TYPE; [EOL]         case MILLIS: [EOL]             return MILLIS_TYPE; [EOL]         default: [EOL]             return this; [EOL]     } [EOL] }
private Object readResolve() { [EOL]     switch(iOrdinal) { [EOL]         case ERAS: [EOL]             return ERAS_TYPE; [EOL]         case CENTURIES: [EOL]             return CENTURIES_TYPE; [EOL]         case WEEKYEARS: [EOL]             return WEEKYEARS_TYPE; [EOL]         case YEARS: [EOL]             return YEARS_TYPE; [EOL]         case MONTHS: [EOL]             return MONTHS_TYPE; [EOL]         case WEEKS: [EOL]             return WEEKS_TYPE; [EOL]         case DAYS: [EOL]             return DAYS_TYPE; [EOL]         case HALFDAYS: [EOL]             return HALFDAYS_TYPE; [EOL]         case HOURS: [EOL]             return HOURS_TYPE; [EOL]         case MINUTES: [EOL]             return MINUTES_TYPE; [EOL]         case SECONDS: [EOL]             return SECONDS_TYPE; [EOL]         case MILLIS: [EOL]             return MILLIS_TYPE; [EOL]         default: [EOL]             return this; [EOL]     } [EOL] }
private Object readResolve() { [EOL]     switch(iOrdinal) { [EOL]         case ERAS: [EOL]             return ERAS_TYPE; [EOL]         case CENTURIES: [EOL]             return CENTURIES_TYPE; [EOL]         case WEEKYEARS: [EOL]             return WEEKYEARS_TYPE; [EOL]         case YEARS: [EOL]             return YEARS_TYPE; [EOL]         case MONTHS: [EOL]             return MONTHS_TYPE; [EOL]         case WEEKS: [EOL]             return WEEKS_TYPE; [EOL]         case DAYS: [EOL]             return DAYS_TYPE; [EOL]         case HALFDAYS: [EOL]             return HALFDAYS_TYPE; [EOL]         case HOURS: [EOL]             return HOURS_TYPE; [EOL]         case MINUTES: [EOL]             return MINUTES_TYPE; [EOL]         case SECONDS: [EOL]             return SECONDS_TYPE; [EOL]         case MILLIS: [EOL]             return MILLIS_TYPE; [EOL]         default: [EOL]             return this; [EOL]     } [EOL] }
private Object readResolve() { [EOL]     switch(iOrdinal) { [EOL]         case ERAS: [EOL]             return ERAS_TYPE; [EOL]         case CENTURIES: [EOL]             return CENTURIES_TYPE; [EOL]         case WEEKYEARS: [EOL]             return WEEKYEARS_TYPE; [EOL]         case YEARS: [EOL]             return YEARS_TYPE; [EOL]         case MONTHS: [EOL]             return MONTHS_TYPE; [EOL]         case WEEKS: [EOL]             return WEEKS_TYPE; [EOL]         case DAYS: [EOL]             return DAYS_TYPE; [EOL]         case HALFDAYS: [EOL]             return HALFDAYS_TYPE; [EOL]         case HOURS: [EOL]             return HOURS_TYPE; [EOL]         case MINUTES: [EOL]             return MINUTES_TYPE; [EOL]         case SECONDS: [EOL]             return SECONDS_TYPE; [EOL]         case MILLIS: [EOL]             return MILLIS_TYPE; [EOL]         default: [EOL]             return this; [EOL]     } [EOL] }
public long getUnitMillis() { [EOL]     return 0; [EOL] }
public static MutableDateTime now() { [EOL]     return new MutableDateTime(); [EOL] }
public static MutableDateTime now(DateTimeZone zone) { [EOL]     if (zone == null) { [EOL]         throw new NullPointerException("Zone must not be null"); [EOL]     } [EOL]     return new MutableDateTime(zone); [EOL] }
public static MutableDateTime now(DateTimeZone zone) { [EOL]     if (zone == null) { [EOL]         throw new NullPointerException("Zone must not be null"); [EOL]     } [EOL]     return new MutableDateTime(zone); [EOL] }
public MutableDateTime(Object instant, DateTimeZone zone) { [EOL]     super(instant, zone); [EOL] }
public MutableDateTime(Object instant, DateTimeZone zone) { [EOL]     super(instant, zone); [EOL] }
public MutableDateTime(Object instant, DateTimeZone zone) { [EOL]     super(instant, zone); [EOL] }
public MutableDateTime(Object instant, DateTimeZone zone) { [EOL]     super(instant, zone); [EOL] }
public void set(DateTimeFieldType type, int value) { [EOL]     if (type == null) { [EOL]         throw new IllegalArgumentException("Field must not be null"); [EOL]     } [EOL]     setMillis(type.getField(getChronology()).set(getMillis(), value)); [EOL] }
public void add(DurationFieldType type, int amount) { [EOL]     if (type == null) { [EOL]         throw new IllegalArgumentException("Field must not be null"); [EOL]     } [EOL]     if (amount != 0) { [EOL]         setMillis(type.getField(getChronology()).add(getMillis(), amount)); [EOL]     } [EOL] }
public void add(DurationFieldType type, int amount) { [EOL]     if (type == null) { [EOL]         throw new IllegalArgumentException("Field must not be null"); [EOL]     } [EOL]     if (amount != 0) { [EOL]         setMillis(type.getField(getChronology()).add(getMillis(), amount)); [EOL]     } [EOL] }
public void add(DurationFieldType type, int amount) { [EOL]     if (type == null) { [EOL]         throw new IllegalArgumentException("Field must not be null"); [EOL]     } [EOL]     if (amount != 0) { [EOL]         setMillis(type.getField(getChronology()).add(getMillis(), amount)); [EOL]     } [EOL] }
public void setWeekyear(final int weekyear) { [EOL]     setMillis(getChronology().weekyear().set(getMillis(), weekyear)); [EOL] }
public void setWeekyear(final int weekyear) { [EOL]     setMillis(getChronology().weekyear().set(getMillis(), weekyear)); [EOL] }
public void setDayOfMonth(final int dayOfMonth) { [EOL]     setMillis(getChronology().dayOfMonth().set(getMillis(), dayOfMonth)); [EOL] }
public void setDayOfMonth(final int dayOfMonth) { [EOL]     setMillis(getChronology().dayOfMonth().set(getMillis(), dayOfMonth)); [EOL] }
public void setMinuteOfDay(final int minuteOfDay) { [EOL]     setMillis(getChronology().minuteOfDay().set(getMillis(), minuteOfDay)); [EOL] }
public void setMinuteOfDay(final int minuteOfDay) { [EOL]     setMillis(getChronology().minuteOfDay().set(getMillis(), minuteOfDay)); [EOL] }
public void setMinuteOfDay(final int minuteOfDay) { [EOL]     setMillis(getChronology().minuteOfDay().set(getMillis(), minuteOfDay)); [EOL] }
public void setMillisOfDay(final int millisOfDay) { [EOL]     setMillis(getChronology().millisOfDay().set(getMillis(), millisOfDay)); [EOL] }
public void setMillisOfDay(final int millisOfDay) { [EOL]     setMillis(getChronology().millisOfDay().set(getMillis(), millisOfDay)); [EOL] }
public void setMillisOfSecond(final int millisOfSecond) { [EOL]     setMillis(getChronology().millisOfSecond().set(getMillis(), millisOfSecond)); [EOL] }
public void setMillisOfSecond(final int millisOfSecond) { [EOL]     setMillis(getChronology().millisOfSecond().set(getMillis(), millisOfSecond)); [EOL] }
public void setMillisOfSecond(final int millisOfSecond) { [EOL]     setMillis(getChronology().millisOfSecond().set(getMillis(), millisOfSecond)); [EOL] }
public void setDate(final int year, final int monthOfYear, final int dayOfMonth) { [EOL]     Chronology c = getChronology(); [EOL]     long instantMidnight = c.getDateTimeMillis(year, monthOfYear, dayOfMonth, 0); [EOL]     setDate(instantMidnight); [EOL] }
public void setDate(final int year, final int monthOfYear, final int dayOfMonth) { [EOL]     Chronology c = getChronology(); [EOL]     long instantMidnight = c.getDateTimeMillis(year, monthOfYear, dayOfMonth, 0); [EOL]     setDate(instantMidnight); [EOL] }
public void setTime(final int hour, final int minuteOfHour, final int secondOfMinute, final int millisOfSecond) { [EOL]     long instant = getChronology().getDateTimeMillis(getMillis(), hour, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]     setMillis(instant); [EOL] }
public void setTime(final int hour, final int minuteOfHour, final int secondOfMinute, final int millisOfSecond) { [EOL]     long instant = getChronology().getDateTimeMillis(getMillis(), hour, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]     setMillis(instant); [EOL] }
public Property yearOfCentury() { [EOL]     return new Property(this, getChronology().yearOfCentury()); [EOL] }
public Property dayOfYear() { [EOL]     return new Property(this, getChronology().dayOfYear()); [EOL] }
public Property minuteOfDay() { [EOL]     return new Property(this, getChronology().minuteOfDay()); [EOL] }
public Property minuteOfHour() { [EOL]     return new Property(this, getChronology().minuteOfHour()); [EOL] }
public Property secondOfDay() { [EOL]     return new Property(this, getChronology().secondOfDay()); [EOL] }
public Property millisOfDay() { [EOL]     return new Property(this, getChronology().millisOfDay()); [EOL] }
public MutableDateTime copy() { [EOL]     return (MutableDateTime) clone(); [EOL] }
private void writeObject(ObjectOutputStream oos) throws IOException { [EOL]     oos.writeObject(iInstant); [EOL]     oos.writeObject(iField.getType()); [EOL] }
private void readObject(ObjectInputStream oos) throws IOException, ClassNotFoundException { [EOL]     iInstant = (MutableDateTime) oos.readObject(); [EOL]     DateTimeFieldType type = (DateTimeFieldType) oos.readObject(); [EOL]     iField = type.getField(iInstant.getChronology()); [EOL] }
public MutableDateTime addWrapField(int value) { [EOL]     iInstant.setMillis(getField().addWrapField(iInstant.getMillis(), value)); [EOL]     return iInstant; [EOL] }
public MutableDateTime addWrapField(int value) { [EOL]     iInstant.setMillis(getField().addWrapField(iInstant.getMillis(), value)); [EOL]     return iInstant; [EOL] }
public MutableDateTime addWrapField(int value) { [EOL]     iInstant.setMillis(getField().addWrapField(iInstant.getMillis(), value)); [EOL]     return iInstant; [EOL] }
public MutableDateTime addWrapField(int value) { [EOL]     iInstant.setMillis(getField().addWrapField(iInstant.getMillis(), value)); [EOL]     return iInstant; [EOL] }
public MutableDateTime roundCeiling() { [EOL]     iInstant.setMillis(getField().roundCeiling(iInstant.getMillis())); [EOL]     return iInstant; [EOL] }
public MutableDateTime roundHalfFloor() { [EOL]     iInstant.setMillis(getField().roundHalfFloor(iInstant.getMillis())); [EOL]     return iInstant; [EOL] }
public MutableDateTime roundHalfFloor() { [EOL]     iInstant.setMillis(getField().roundHalfFloor(iInstant.getMillis())); [EOL]     return iInstant; [EOL] }
public MutableDateTime roundHalfFloor() { [EOL]     iInstant.setMillis(getField().roundHalfFloor(iInstant.getMillis())); [EOL]     return iInstant; [EOL] }
public MutableDateTime roundHalfFloor() { [EOL]     iInstant.setMillis(getField().roundHalfFloor(iInstant.getMillis())); [EOL]     return iInstant; [EOL] }
public static Hours hours(int hours) { [EOL]     switch(hours) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case 4: [EOL]             return FOUR; [EOL]         case 5: [EOL]             return FIVE; [EOL]         case 6: [EOL]             return SIX; [EOL]         case 7: [EOL]             return SEVEN; [EOL]         case 8: [EOL]             return EIGHT; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Hours(hours); [EOL]     } [EOL] }
public static Hours hours(int hours) { [EOL]     switch(hours) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case 4: [EOL]             return FOUR; [EOL]         case 5: [EOL]             return FIVE; [EOL]         case 6: [EOL]             return SIX; [EOL]         case 7: [EOL]             return SEVEN; [EOL]         case 8: [EOL]             return EIGHT; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Hours(hours); [EOL]     } [EOL] }
public static Hours hours(int hours) { [EOL]     switch(hours) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case 4: [EOL]             return FOUR; [EOL]         case 5: [EOL]             return FIVE; [EOL]         case 6: [EOL]             return SIX; [EOL]         case 7: [EOL]             return SEVEN; [EOL]         case 8: [EOL]             return EIGHT; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Hours(hours); [EOL]     } [EOL] }
public static Hours hours(int hours) { [EOL]     switch(hours) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case 4: [EOL]             return FOUR; [EOL]         case 5: [EOL]             return FIVE; [EOL]         case 6: [EOL]             return SIX; [EOL]         case 7: [EOL]             return SEVEN; [EOL]         case 8: [EOL]             return EIGHT; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Hours(hours); [EOL]     } [EOL] }
public static Hours hours(int hours) { [EOL]     switch(hours) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case 4: [EOL]             return FOUR; [EOL]         case 5: [EOL]             return FIVE; [EOL]         case 6: [EOL]             return SIX; [EOL]         case 7: [EOL]             return SEVEN; [EOL]         case 8: [EOL]             return EIGHT; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Hours(hours); [EOL]     } [EOL] }
public static Hours hours(int hours) { [EOL]     switch(hours) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case 4: [EOL]             return FOUR; [EOL]         case 5: [EOL]             return FIVE; [EOL]         case 6: [EOL]             return SIX; [EOL]         case 7: [EOL]             return SEVEN; [EOL]         case 8: [EOL]             return EIGHT; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Hours(hours); [EOL]     } [EOL] }
public static Hours hours(int hours) { [EOL]     switch(hours) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case 4: [EOL]             return FOUR; [EOL]         case 5: [EOL]             return FIVE; [EOL]         case 6: [EOL]             return SIX; [EOL]         case 7: [EOL]             return SEVEN; [EOL]         case 8: [EOL]             return EIGHT; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Hours(hours); [EOL]     } [EOL] }
public static Hours hours(int hours) { [EOL]     switch(hours) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case 4: [EOL]             return FOUR; [EOL]         case 5: [EOL]             return FIVE; [EOL]         case 6: [EOL]             return SIX; [EOL]         case 7: [EOL]             return SEVEN; [EOL]         case 8: [EOL]             return EIGHT; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Hours(hours); [EOL]     } [EOL] }
public static Hours hours(int hours) { [EOL]     switch(hours) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case 4: [EOL]             return FOUR; [EOL]         case 5: [EOL]             return FIVE; [EOL]         case 6: [EOL]             return SIX; [EOL]         case 7: [EOL]             return SEVEN; [EOL]         case 8: [EOL]             return EIGHT; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Hours(hours); [EOL]     } [EOL] }
public static Hours hours(int hours) { [EOL]     switch(hours) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case 4: [EOL]             return FOUR; [EOL]         case 5: [EOL]             return FIVE; [EOL]         case 6: [EOL]             return SIX; [EOL]         case 7: [EOL]             return SEVEN; [EOL]         case 8: [EOL]             return EIGHT; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Hours(hours); [EOL]     } [EOL] }
public static Hours hours(int hours) { [EOL]     switch(hours) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case 4: [EOL]             return FOUR; [EOL]         case 5: [EOL]             return FIVE; [EOL]         case 6: [EOL]             return SIX; [EOL]         case 7: [EOL]             return SEVEN; [EOL]         case 8: [EOL]             return EIGHT; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Hours(hours); [EOL]     } [EOL] }
public static Hours hours(int hours) { [EOL]     switch(hours) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case 4: [EOL]             return FOUR; [EOL]         case 5: [EOL]             return FIVE; [EOL]         case 6: [EOL]             return SIX; [EOL]         case 7: [EOL]             return SEVEN; [EOL]         case 8: [EOL]             return EIGHT; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Hours(hours); [EOL]     } [EOL] }
public static Hours hoursBetween(ReadablePartial start, ReadablePartial end) { [EOL]     if (start instanceof LocalTime && end instanceof LocalTime) { [EOL]         Chronology chrono = DateTimeUtils.getChronology(start.getChronology()); [EOL]         int hours = chrono.hours().getDifference(((LocalTime) end).getLocalMillis(), ((LocalTime) start).getLocalMillis()); [EOL]         return Hours.hours(hours); [EOL]     } [EOL]     int amount = BaseSingleFieldPeriod.between(start, end, ZERO); [EOL]     return Hours.hours(amount); [EOL] }
public static Hours hoursBetween(ReadablePartial start, ReadablePartial end) { [EOL]     if (start instanceof LocalTime && end instanceof LocalTime) { [EOL]         Chronology chrono = DateTimeUtils.getChronology(start.getChronology()); [EOL]         int hours = chrono.hours().getDifference(((LocalTime) end).getLocalMillis(), ((LocalTime) start).getLocalMillis()); [EOL]         return Hours.hours(hours); [EOL]     } [EOL]     int amount = BaseSingleFieldPeriod.between(start, end, ZERO); [EOL]     return Hours.hours(amount); [EOL] }
private Hours(int hours) { [EOL]     super(hours); [EOL] }
public PeriodType getPeriodType() { [EOL]     return PeriodType.hours(); [EOL] }
public Days toStandardDays() { [EOL]     return Days.days(getValue() / DateTimeConstants.HOURS_PER_DAY); [EOL] }
public Duration toStandardDuration() { [EOL]     long hours = getValue(); [EOL]     return new Duration(hours * DateTimeConstants.MILLIS_PER_HOUR); [EOL] }
public Duration toStandardDuration() { [EOL]     long hours = getValue(); [EOL]     return new Duration(hours * DateTimeConstants.MILLIS_PER_HOUR); [EOL] }
public Duration toStandardDuration() { [EOL]     long hours = getValue(); [EOL]     return new Duration(hours * DateTimeConstants.MILLIS_PER_HOUR); [EOL] }
public boolean isGreaterThan(Hours other) { [EOL]     if (other == null) { [EOL]         return getValue() > 0; [EOL]     } [EOL]     return getValue() > other.getValue(); [EOL] }
ConverterSet remove(Converter converter, Converter[] removed) { [EOL]     Converter[] converters = iConverters; [EOL]     int length = converters.length; [EOL]     for (int i = 0; i < length; i++) { [EOL]         if (converter.equals(converters[i])) { [EOL]             return remove(i, removed); [EOL]         } [EOL]     } [EOL]     if (removed != null) { [EOL]         removed[0] = null; [EOL]     } [EOL]     return this; [EOL] }
ConverterSet remove(Converter converter, Converter[] removed) { [EOL]     Converter[] converters = iConverters; [EOL]     int length = converters.length; [EOL]     for (int i = 0; i < length; i++) { [EOL]         if (converter.equals(converters[i])) { [EOL]             return remove(i, removed); [EOL]         } [EOL]     } [EOL]     if (removed != null) { [EOL]         removed[0] = null; [EOL]     } [EOL]     return this; [EOL] }
private static Converter selectSlow(ConverterSet set, Class<?> type) { [EOL]     Converter[] converters = set.iConverters; [EOL]     int length = converters.length; [EOL]     Converter converter; [EOL]     for (int i = length; --i >= 0; ) { [EOL]         converter = converters[i]; [EOL]         Class<?> supportedType = converter.getSupportedType(); [EOL]         if (supportedType == type) { [EOL]             return converter; [EOL]         } [EOL]         if (supportedType == null || (type != null && !supportedType.isAssignableFrom(type))) { [EOL]             set = set.remove(i, null); [EOL]             converters = set.iConverters; [EOL]             length = converters.length; [EOL]         } [EOL]     } [EOL]     if (type == null || length == 0) { [EOL]         return null; [EOL]     } [EOL]     if (length == 1) { [EOL]         return converters[0]; [EOL]     } [EOL]     for (int i = length; --i >= 0; ) { [EOL]         converter = converters[i]; [EOL]         Class<?> supportedType = converter.getSupportedType(); [EOL]         for (int j = length; --j >= 0; ) { [EOL]             if (j != i && converters[j].getSupportedType().isAssignableFrom(supportedType)) { [EOL]                 set = set.remove(j, null); [EOL]                 converters = set.iConverters; [EOL]                 length = converters.length; [EOL]                 i = length - 1; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (length == 1) { [EOL]         return converters[0]; [EOL]     } [EOL]     StringBuilder msg = new StringBuilder(); [EOL]     msg.append("Unable to find best converter for type \""); [EOL]     msg.append(type.getName()); [EOL]     msg.append("\" from remaining set: "); [EOL]     for (int i = 0; i < length; i++) { [EOL]         converter = converters[i]; [EOL]         Class<?> supportedType = converter.getSupportedType(); [EOL]         msg.append(converter.getClass().getName()); [EOL]         msg.append('['); [EOL]         msg.append(supportedType == null ? null : supportedType.getName()); [EOL]         msg.append("], "); [EOL]     } [EOL]     throw new IllegalStateException(msg.toString()); [EOL] }
public DateTimeParser toParser() { [EOL]     Object f = getFormatter(); [EOL]     if (isParser(f)) { [EOL]         return (DateTimeParser) f; [EOL]     } [EOL]     throw new UnsupportedOperationException("Parsing is not supported"); [EOL] }
public boolean canBuildParser() { [EOL]     return isParser(getFormatter()); [EOL] }
public DateTimeFormatterBuilder append(DateTimePrinter printer, DateTimeParser parser) { [EOL]     checkPrinter(printer); [EOL]     checkParser(parser); [EOL]     return append0(printer, parser); [EOL] }
public DateTimeFormatterBuilder append(DateTimePrinter printer, DateTimeParser parser) { [EOL]     checkPrinter(printer); [EOL]     checkParser(parser); [EOL]     return append0(printer, parser); [EOL] }
public DateTimeFormatterBuilder append(DateTimePrinter printer, DateTimeParser parser) { [EOL]     checkPrinter(printer); [EOL]     checkParser(parser); [EOL]     return append0(printer, parser); [EOL] }
private void checkPrinter(DateTimePrinter printer) { [EOL]     if (printer == null) { [EOL]         throw new IllegalArgumentException("No printer supplied"); [EOL]     } [EOL] }
private void checkPrinter(DateTimePrinter printer) { [EOL]     if (printer == null) { [EOL]         throw new IllegalArgumentException("No printer supplied"); [EOL]     } [EOL] }
public DateTimeFormatterBuilder appendText(DateTimeFieldType fieldType) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("Field type must not be null"); [EOL]     } [EOL]     return append0(new TextField(fieldType, false)); [EOL] }
public DateTimeFormatterBuilder appendText(DateTimeFieldType fieldType) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("Field type must not be null"); [EOL]     } [EOL]     return append0(new TextField(fieldType, false)); [EOL] }
public DateTimeFormatterBuilder appendTwoDigitWeekyear(int pivot) { [EOL]     return appendTwoDigitWeekyear(pivot, false); [EOL] }
public DateTimeFormatterBuilder appendTwoDigitWeekyear(int pivot) { [EOL]     return appendTwoDigitWeekyear(pivot, false); [EOL] }
public DateTimeFormatterBuilder appendTwoDigitWeekyear(int pivot, boolean lenientParse) { [EOL]     return append0(new TwoDigitYear(DateTimeFieldType.weekyear(), pivot, lenientParse)); [EOL] }
public DateTimeFormatterBuilder appendTwoDigitWeekyear(int pivot, boolean lenientParse) { [EOL]     return append0(new TwoDigitYear(DateTimeFieldType.weekyear(), pivot, lenientParse)); [EOL] }
public DateTimeFormatterBuilder appendYearOfEra(int minDigits, int maxDigits) { [EOL]     return appendDecimal(DateTimeFieldType.yearOfEra(), minDigits, maxDigits); [EOL] }
public DateTimeFormatterBuilder appendYearOfEra(int minDigits, int maxDigits) { [EOL]     return appendDecimal(DateTimeFieldType.yearOfEra(), minDigits, maxDigits); [EOL] }
public int parseInto(DateTimeParserBucket bucket, String text, int position) { [EOL]     if (text.regionMatches(true, position, iValue, 0, iValue.length())) { [EOL]         return position + iValue.length(); [EOL]     } [EOL]     return ~position; [EOL] }
public int parseInto(DateTimeParserBucket bucket, String text, int position) { [EOL]     if (text.regionMatches(true, position, iValue, 0, iValue.length())) { [EOL]         return position + iValue.length(); [EOL]     } [EOL]     return ~position; [EOL] }
public int parseInto(DateTimeParserBucket bucket, String text, int position) { [EOL]     if (text.regionMatches(true, position, iValue, 0, iValue.length())) { [EOL]         return position + iValue.length(); [EOL]     } [EOL]     return ~position; [EOL] }
public int parseInto(DateTimeParserBucket bucket, String text, int position) { [EOL]     if (text.regionMatches(true, position, iValue, 0, iValue.length())) { [EOL]         return position + iValue.length(); [EOL]     } [EOL]     return ~position; [EOL] }
public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) { [EOL]     if (partial.isSupported(iFieldType)) { [EOL]         try { [EOL]             FormatUtils.appendPaddedInteger(buf, partial.get(iFieldType), iMinPrintedDigits); [EOL]         } catch (RuntimeException e) { [EOL]             appendUnknownString(buf, iMinPrintedDigits); [EOL]         } [EOL]     } else { [EOL]         appendUnknownString(buf, iMinPrintedDigits); [EOL]     } [EOL] }
public int parseInto(DateTimeParserBucket bucket, String text, int position) { [EOL]     int limit = text.length() - position; [EOL]     if (!iLenientParse) { [EOL]         limit = Math.min(2, limit); [EOL]         if (limit < 2) { [EOL]             return ~position; [EOL]         } [EOL]     } else { [EOL]         boolean hasSignChar = false; [EOL]         boolean negative = false; [EOL]         int length = 0; [EOL]         while (length < limit) { [EOL]             char c = text.charAt(position + length); [EOL]             if (length == 0 && (c == '-' || c == '+')) { [EOL]                 hasSignChar = true; [EOL]                 negative = c == '-'; [EOL]                 if (negative) { [EOL]                     length++; [EOL]                 } else { [EOL]                     position++; [EOL]                     limit--; [EOL]                 } [EOL]                 continue; [EOL]             } [EOL]             if (c < '0' || c > '9') { [EOL]                 break; [EOL]             } [EOL]             length++; [EOL]         } [EOL]         if (length == 0) { [EOL]             return ~position; [EOL]         } [EOL]         if (hasSignChar || length != 2) { [EOL]             int value; [EOL]             if (length >= 9) { [EOL]                 value = Integer.parseInt(text.substring(position, position += length)); [EOL]             } else { [EOL]                 int i = position; [EOL]                 if (negative) { [EOL]                     i++; [EOL]                 } [EOL]                 try { [EOL]                     value = text.charAt(i++) - '0'; [EOL]                 } catch (StringIndexOutOfBoundsException e) { [EOL]                     return ~position; [EOL]                 } [EOL]                 position += length; [EOL]                 while (i < position) { [EOL]                     value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0'; [EOL]                 } [EOL]                 if (negative) { [EOL]                     value = -value; [EOL]                 } [EOL]             } [EOL]             bucket.saveField(iType, value); [EOL]             return position; [EOL]         } [EOL]     } [EOL]     int year; [EOL]     char c = text.charAt(position); [EOL]     if (c < '0' || c > '9') { [EOL]         return ~position; [EOL]     } [EOL]     year = c - '0'; [EOL]     c = text.charAt(position + 1); [EOL]     if (c < '0' || c > '9') { [EOL]         return ~position; [EOL]     } [EOL]     year = ((year << 3) + (year << 1)) + c - '0'; [EOL]     int pivot = iPivot; [EOL]     if (bucket.getPivotYear() != null) { [EOL]         pivot = bucket.getPivotYear().intValue(); [EOL]     } [EOL]     int low = pivot - 50; [EOL]     int t; [EOL]     if (low >= 0) { [EOL]         t = low % 100; [EOL]     } else { [EOL]         t = 99 + ((low + 1) % 100); [EOL]     } [EOL]     year += low + ((year < t) ? 100 : 0) - t; [EOL]     bucket.saveField(iType, year); [EOL]     return position + 2; [EOL] }
public int parseInto(DateTimeParserBucket bucket, String text, int position) { [EOL]     int limit = text.length() - position; [EOL]     if (!iLenientParse) { [EOL]         limit = Math.min(2, limit); [EOL]         if (limit < 2) { [EOL]             return ~position; [EOL]         } [EOL]     } else { [EOL]         boolean hasSignChar = false; [EOL]         boolean negative = false; [EOL]         int length = 0; [EOL]         while (length < limit) { [EOL]             char c = text.charAt(position + length); [EOL]             if (length == 0 && (c == '-' || c == '+')) { [EOL]                 hasSignChar = true; [EOL]                 negative = c == '-'; [EOL]                 if (negative) { [EOL]                     length++; [EOL]                 } else { [EOL]                     position++; [EOL]                     limit--; [EOL]                 } [EOL]                 continue; [EOL]             } [EOL]             if (c < '0' || c > '9') { [EOL]                 break; [EOL]             } [EOL]             length++; [EOL]         } [EOL]         if (length == 0) { [EOL]             return ~position; [EOL]         } [EOL]         if (hasSignChar || length != 2) { [EOL]             int value; [EOL]             if (length >= 9) { [EOL]                 value = Integer.parseInt(text.substring(position, position += length)); [EOL]             } else { [EOL]                 int i = position; [EOL]                 if (negative) { [EOL]                     i++; [EOL]                 } [EOL]                 try { [EOL]                     value = text.charAt(i++) - '0'; [EOL]                 } catch (StringIndexOutOfBoundsException e) { [EOL]                     return ~position; [EOL]                 } [EOL]                 position += length; [EOL]                 while (i < position) { [EOL]                     value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0'; [EOL]                 } [EOL]                 if (negative) { [EOL]                     value = -value; [EOL]                 } [EOL]             } [EOL]             bucket.saveField(iType, value); [EOL]             return position; [EOL]         } [EOL]     } [EOL]     int year; [EOL]     char c = text.charAt(position); [EOL]     if (c < '0' || c > '9') { [EOL]         return ~position; [EOL]     } [EOL]     year = c - '0'; [EOL]     c = text.charAt(position + 1); [EOL]     if (c < '0' || c > '9') { [EOL]         return ~position; [EOL]     } [EOL]     year = ((year << 3) + (year << 1)) + c - '0'; [EOL]     int pivot = iPivot; [EOL]     if (bucket.getPivotYear() != null) { [EOL]         pivot = bucket.getPivotYear().intValue(); [EOL]     } [EOL]     int low = pivot - 50; [EOL]     int t; [EOL]     if (low >= 0) { [EOL]         t = low % 100; [EOL]     } else { [EOL]         t = 99 + ((low + 1) % 100); [EOL]     } [EOL]     year += low + ((year < t) ? 100 : 0) - t; [EOL]     bucket.saveField(iType, year); [EOL]     return position + 2; [EOL] }
public int parseInto(DateTimeParserBucket bucket, String text, int position) { [EOL]     int limit = text.length() - position; [EOL]     if (!iLenientParse) { [EOL]         limit = Math.min(2, limit); [EOL]         if (limit < 2) { [EOL]             return ~position; [EOL]         } [EOL]     } else { [EOL]         boolean hasSignChar = false; [EOL]         boolean negative = false; [EOL]         int length = 0; [EOL]         while (length < limit) { [EOL]             char c = text.charAt(position + length); [EOL]             if (length == 0 && (c == '-' || c == '+')) { [EOL]                 hasSignChar = true; [EOL]                 negative = c == '-'; [EOL]                 if (negative) { [EOL]                     length++; [EOL]                 } else { [EOL]                     position++; [EOL]                     limit--; [EOL]                 } [EOL]                 continue; [EOL]             } [EOL]             if (c < '0' || c > '9') { [EOL]                 break; [EOL]             } [EOL]             length++; [EOL]         } [EOL]         if (length == 0) { [EOL]             return ~position; [EOL]         } [EOL]         if (hasSignChar || length != 2) { [EOL]             int value; [EOL]             if (length >= 9) { [EOL]                 value = Integer.parseInt(text.substring(position, position += length)); [EOL]             } else { [EOL]                 int i = position; [EOL]                 if (negative) { [EOL]                     i++; [EOL]                 } [EOL]                 try { [EOL]                     value = text.charAt(i++) - '0'; [EOL]                 } catch (StringIndexOutOfBoundsException e) { [EOL]                     return ~position; [EOL]                 } [EOL]                 position += length; [EOL]                 while (i < position) { [EOL]                     value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0'; [EOL]                 } [EOL]                 if (negative) { [EOL]                     value = -value; [EOL]                 } [EOL]             } [EOL]             bucket.saveField(iType, value); [EOL]             return position; [EOL]         } [EOL]     } [EOL]     int year; [EOL]     char c = text.charAt(position); [EOL]     if (c < '0' || c > '9') { [EOL]         return ~position; [EOL]     } [EOL]     year = c - '0'; [EOL]     c = text.charAt(position + 1); [EOL]     if (c < '0' || c > '9') { [EOL]         return ~position; [EOL]     } [EOL]     year = ((year << 3) + (year << 1)) + c - '0'; [EOL]     int pivot = iPivot; [EOL]     if (bucket.getPivotYear() != null) { [EOL]         pivot = bucket.getPivotYear().intValue(); [EOL]     } [EOL]     int low = pivot - 50; [EOL]     int t; [EOL]     if (low >= 0) { [EOL]         t = low % 100; [EOL]     } else { [EOL]         t = 99 + ((low + 1) % 100); [EOL]     } [EOL]     year += low + ((year < t) ? 100 : 0) - t; [EOL]     bucket.saveField(iType, year); [EOL]     return position + 2; [EOL] }
public int parseInto(DateTimeParserBucket bucket, String text, int position) { [EOL]     int limit = text.length() - position; [EOL]     if (!iLenientParse) { [EOL]         limit = Math.min(2, limit); [EOL]         if (limit < 2) { [EOL]             return ~position; [EOL]         } [EOL]     } else { [EOL]         boolean hasSignChar = false; [EOL]         boolean negative = false; [EOL]         int length = 0; [EOL]         while (length < limit) { [EOL]             char c = text.charAt(position + length); [EOL]             if (length == 0 && (c == '-' || c == '+')) { [EOL]                 hasSignChar = true; [EOL]                 negative = c == '-'; [EOL]                 if (negative) { [EOL]                     length++; [EOL]                 } else { [EOL]                     position++; [EOL]                     limit--; [EOL]                 } [EOL]                 continue; [EOL]             } [EOL]             if (c < '0' || c > '9') { [EOL]                 break; [EOL]             } [EOL]             length++; [EOL]         } [EOL]         if (length == 0) { [EOL]             return ~position; [EOL]         } [EOL]         if (hasSignChar || length != 2) { [EOL]             int value; [EOL]             if (length >= 9) { [EOL]                 value = Integer.parseInt(text.substring(position, position += length)); [EOL]             } else { [EOL]                 int i = position; [EOL]                 if (negative) { [EOL]                     i++; [EOL]                 } [EOL]                 try { [EOL]                     value = text.charAt(i++) - '0'; [EOL]                 } catch (StringIndexOutOfBoundsException e) { [EOL]                     return ~position; [EOL]                 } [EOL]                 position += length; [EOL]                 while (i < position) { [EOL]                     value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0'; [EOL]                 } [EOL]                 if (negative) { [EOL]                     value = -value; [EOL]                 } [EOL]             } [EOL]             bucket.saveField(iType, value); [EOL]             return position; [EOL]         } [EOL]     } [EOL]     int year; [EOL]     char c = text.charAt(position); [EOL]     if (c < '0' || c > '9') { [EOL]         return ~position; [EOL]     } [EOL]     year = c - '0'; [EOL]     c = text.charAt(position + 1); [EOL]     if (c < '0' || c > '9') { [EOL]         return ~position; [EOL]     } [EOL]     year = ((year << 3) + (year << 1)) + c - '0'; [EOL]     int pivot = iPivot; [EOL]     if (bucket.getPivotYear() != null) { [EOL]         pivot = bucket.getPivotYear().intValue(); [EOL]     } [EOL]     int low = pivot - 50; [EOL]     int t; [EOL]     if (low >= 0) { [EOL]         t = low % 100; [EOL]     } else { [EOL]         t = 99 + ((low + 1) % 100); [EOL]     } [EOL]     year += low + ((year < t) ? 100 : 0) - t; [EOL]     bucket.saveField(iType, year); [EOL]     return position + 2; [EOL] }
TextField(DateTimeFieldType fieldType, boolean isShort) { [EOL]     super(); [EOL]     iFieldType = fieldType; [EOL]     iShort = isShort; [EOL] }
TextField(DateTimeFieldType fieldType, boolean isShort) { [EOL]     super(); [EOL]     iFieldType = fieldType; [EOL]     iShort = isShort; [EOL] }
public int estimatePrintedLength() { [EOL]     return iShort ? 6 : 20; [EOL] }
public int estimatePrintedLength() { [EOL]     return iShort ? 6 : 20; [EOL] }
public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) { [EOL]     try { [EOL]         buf.append(print(instant, chrono, locale)); [EOL]     } catch (RuntimeException e) { [EOL]         buf.append('\ufffd'); [EOL]     } [EOL] }
public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) { [EOL]     try { [EOL]         buf.append(print(instant, chrono, locale)); [EOL]     } catch (RuntimeException e) { [EOL]         buf.append('\ufffd'); [EOL]     } [EOL] }
public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) { [EOL]     try { [EOL]         buf.append(print(partial, locale)); [EOL]     } catch (RuntimeException e) { [EOL]         buf.append('\ufffd'); [EOL]     } [EOL] }
public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) { [EOL]     try { [EOL]         buf.append(print(partial, locale)); [EOL]     } catch (RuntimeException e) { [EOL]         buf.append('\ufffd'); [EOL]     } [EOL] }
private String print(long instant, Chronology chrono, Locale locale) { [EOL]     DateTimeField field = iFieldType.getField(chrono); [EOL]     if (iShort) { [EOL]         return field.getAsShortText(instant, locale); [EOL]     } else { [EOL]         return field.getAsText(instant, locale); [EOL]     } [EOL] }
private String print(long instant, Chronology chrono, Locale locale) { [EOL]     DateTimeField field = iFieldType.getField(chrono); [EOL]     if (iShort) { [EOL]         return field.getAsShortText(instant, locale); [EOL]     } else { [EOL]         return field.getAsText(instant, locale); [EOL]     } [EOL] }
private String print(ReadablePartial partial, Locale locale) { [EOL]     if (partial.isSupported(iFieldType)) { [EOL]         DateTimeField field = iFieldType.getField(partial.getChronology()); [EOL]         if (iShort) { [EOL]             return field.getAsShortText(partial, locale); [EOL]         } else { [EOL]             return field.getAsText(partial, locale); [EOL]         } [EOL]     } else { [EOL]         return "\ufffd"; [EOL]     } [EOL] }
private String print(ReadablePartial partial, Locale locale) { [EOL]     if (partial.isSupported(iFieldType)) { [EOL]         DateTimeField field = iFieldType.getField(partial.getChronology()); [EOL]         if (iShort) { [EOL]             return field.getAsShortText(partial, locale); [EOL]         } else { [EOL]             return field.getAsText(partial, locale); [EOL]         } [EOL]     } else { [EOL]         return "\ufffd"; [EOL]     } [EOL] }
private String print(ReadablePartial partial, Locale locale) { [EOL]     if (partial.isSupported(iFieldType)) { [EOL]         DateTimeField field = iFieldType.getField(partial.getChronology()); [EOL]         if (iShort) { [EOL]             return field.getAsShortText(partial, locale); [EOL]         } else { [EOL]             return field.getAsText(partial, locale); [EOL]         } [EOL]     } else { [EOL]         return "\ufffd"; [EOL]     } [EOL] }
@SuppressWarnings("unchecked") [EOL] public int parseInto(DateTimeParserBucket bucket, String text, int position) { [EOL]     Locale locale = bucket.getLocale(); [EOL]     Set<String> validValues = null; [EOL]     int maxLength = 0; [EOL]     synchronized (cParseCache) { [EOL]         Map<DateTimeFieldType, Object[]> innerMap = cParseCache.get(locale); [EOL]         if (innerMap == null) { [EOL]             innerMap = new HashMap<DateTimeFieldType, Object[]>(); [EOL]             cParseCache.put(locale, innerMap); [EOL]         } [EOL]         Object[] array = innerMap.get(iFieldType); [EOL]         if (array == null) { [EOL]             validValues = new HashSet<String>(32); [EOL]             MutableDateTime dt = new MutableDateTime(0L, DateTimeZone.UTC); [EOL]             Property property = dt.property(iFieldType); [EOL]             int min = property.getMinimumValueOverall(); [EOL]             int max = property.getMaximumValueOverall(); [EOL]             if (max - min > 32) { [EOL]                 return ~position; [EOL]             } [EOL]             maxLength = property.getMaximumTextLength(locale); [EOL]             for (int i = min; i <= max; i++) { [EOL]                 property.set(i); [EOL]                 validValues.add(property.getAsShortText(locale)); [EOL]                 validValues.add(property.getAsShortText(locale).toLowerCase(locale)); [EOL]                 validValues.add(property.getAsShortText(locale).toUpperCase(locale)); [EOL]                 validValues.add(property.getAsText(locale)); [EOL]                 validValues.add(property.getAsText(locale).toLowerCase(locale)); [EOL]                 validValues.add(property.getAsText(locale).toUpperCase(locale)); [EOL]             } [EOL]             if ("en".equals(locale.getLanguage()) && iFieldType == DateTimeFieldType.era()) { [EOL]                 validValues.add("BCE"); [EOL]                 validValues.add("bce"); [EOL]                 validValues.add("CE"); [EOL]                 validValues.add("ce"); [EOL]                 maxLength = 3; [EOL]             } [EOL]             array = new Object[] { validValues, Integer.valueOf(maxLength) }; [EOL]             innerMap.put(iFieldType, array); [EOL]         } else { [EOL]             validValues = (Set<String>) array[0]; [EOL]             maxLength = ((Integer) array[1]).intValue(); [EOL]         } [EOL]     } [EOL]     int limit = Math.min(text.length(), position + maxLength); [EOL]     for (int i = limit; i > position; i--) { [EOL]         String match = text.substring(position, i); [EOL]         if (validValues.contains(match)) { [EOL]             bucket.saveField(iFieldType, match, locale); [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return ~position; [EOL] }
@SuppressWarnings("unchecked") [EOL] public int parseInto(DateTimeParserBucket bucket, String text, int position) { [EOL]     Locale locale = bucket.getLocale(); [EOL]     Set<String> validValues = null; [EOL]     int maxLength = 0; [EOL]     synchronized (cParseCache) { [EOL]         Map<DateTimeFieldType, Object[]> innerMap = cParseCache.get(locale); [EOL]         if (innerMap == null) { [EOL]             innerMap = new HashMap<DateTimeFieldType, Object[]>(); [EOL]             cParseCache.put(locale, innerMap); [EOL]         } [EOL]         Object[] array = innerMap.get(iFieldType); [EOL]         if (array == null) { [EOL]             validValues = new HashSet<String>(32); [EOL]             MutableDateTime dt = new MutableDateTime(0L, DateTimeZone.UTC); [EOL]             Property property = dt.property(iFieldType); [EOL]             int min = property.getMinimumValueOverall(); [EOL]             int max = property.getMaximumValueOverall(); [EOL]             if (max - min > 32) { [EOL]                 return ~position; [EOL]             } [EOL]             maxLength = property.getMaximumTextLength(locale); [EOL]             for (int i = min; i <= max; i++) { [EOL]                 property.set(i); [EOL]                 validValues.add(property.getAsShortText(locale)); [EOL]                 validValues.add(property.getAsShortText(locale).toLowerCase(locale)); [EOL]                 validValues.add(property.getAsShortText(locale).toUpperCase(locale)); [EOL]                 validValues.add(property.getAsText(locale)); [EOL]                 validValues.add(property.getAsText(locale).toLowerCase(locale)); [EOL]                 validValues.add(property.getAsText(locale).toUpperCase(locale)); [EOL]             } [EOL]             if ("en".equals(locale.getLanguage()) && iFieldType == DateTimeFieldType.era()) { [EOL]                 validValues.add("BCE"); [EOL]                 validValues.add("bce"); [EOL]                 validValues.add("CE"); [EOL]                 validValues.add("ce"); [EOL]                 maxLength = 3; [EOL]             } [EOL]             array = new Object[] { validValues, Integer.valueOf(maxLength) }; [EOL]             innerMap.put(iFieldType, array); [EOL]         } else { [EOL]             validValues = (Set<String>) array[0]; [EOL]             maxLength = ((Integer) array[1]).intValue(); [EOL]         } [EOL]     } [EOL]     int limit = Math.min(text.length(), position + maxLength); [EOL]     for (int i = limit; i > position; i--) { [EOL]         String match = text.substring(position, i); [EOL]         if (validValues.contains(match)) { [EOL]             bucket.saveField(iFieldType, match, locale); [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return ~position; [EOL] }
@SuppressWarnings("unchecked") [EOL] public int parseInto(DateTimeParserBucket bucket, String text, int position) { [EOL]     Locale locale = bucket.getLocale(); [EOL]     Set<String> validValues = null; [EOL]     int maxLength = 0; [EOL]     synchronized (cParseCache) { [EOL]         Map<DateTimeFieldType, Object[]> innerMap = cParseCache.get(locale); [EOL]         if (innerMap == null) { [EOL]             innerMap = new HashMap<DateTimeFieldType, Object[]>(); [EOL]             cParseCache.put(locale, innerMap); [EOL]         } [EOL]         Object[] array = innerMap.get(iFieldType); [EOL]         if (array == null) { [EOL]             validValues = new HashSet<String>(32); [EOL]             MutableDateTime dt = new MutableDateTime(0L, DateTimeZone.UTC); [EOL]             Property property = dt.property(iFieldType); [EOL]             int min = property.getMinimumValueOverall(); [EOL]             int max = property.getMaximumValueOverall(); [EOL]             if (max - min > 32) { [EOL]                 return ~position; [EOL]             } [EOL]             maxLength = property.getMaximumTextLength(locale); [EOL]             for (int i = min; i <= max; i++) { [EOL]                 property.set(i); [EOL]                 validValues.add(property.getAsShortText(locale)); [EOL]                 validValues.add(property.getAsShortText(locale).toLowerCase(locale)); [EOL]                 validValues.add(property.getAsShortText(locale).toUpperCase(locale)); [EOL]                 validValues.add(property.getAsText(locale)); [EOL]                 validValues.add(property.getAsText(locale).toLowerCase(locale)); [EOL]                 validValues.add(property.getAsText(locale).toUpperCase(locale)); [EOL]             } [EOL]             if ("en".equals(locale.getLanguage()) && iFieldType == DateTimeFieldType.era()) { [EOL]                 validValues.add("BCE"); [EOL]                 validValues.add("bce"); [EOL]                 validValues.add("CE"); [EOL]                 validValues.add("ce"); [EOL]                 maxLength = 3; [EOL]             } [EOL]             array = new Object[] { validValues, Integer.valueOf(maxLength) }; [EOL]             innerMap.put(iFieldType, array); [EOL]         } else { [EOL]             validValues = (Set<String>) array[0]; [EOL]             maxLength = ((Integer) array[1]).intValue(); [EOL]         } [EOL]     } [EOL]     int limit = Math.min(text.length(), position + maxLength); [EOL]     for (int i = limit; i > position; i--) { [EOL]         String match = text.substring(position, i); [EOL]         if (validValues.contains(match)) { [EOL]             bucket.saveField(iFieldType, match, locale); [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return ~position; [EOL] }
@SuppressWarnings("unchecked") [EOL] public int parseInto(DateTimeParserBucket bucket, String text, int position) { [EOL]     Locale locale = bucket.getLocale(); [EOL]     Set<String> validValues = null; [EOL]     int maxLength = 0; [EOL]     synchronized (cParseCache) { [EOL]         Map<DateTimeFieldType, Object[]> innerMap = cParseCache.get(locale); [EOL]         if (innerMap == null) { [EOL]             innerMap = new HashMap<DateTimeFieldType, Object[]>(); [EOL]             cParseCache.put(locale, innerMap); [EOL]         } [EOL]         Object[] array = innerMap.get(iFieldType); [EOL]         if (array == null) { [EOL]             validValues = new HashSet<String>(32); [EOL]             MutableDateTime dt = new MutableDateTime(0L, DateTimeZone.UTC); [EOL]             Property property = dt.property(iFieldType); [EOL]             int min = property.getMinimumValueOverall(); [EOL]             int max = property.getMaximumValueOverall(); [EOL]             if (max - min > 32) { [EOL]                 return ~position; [EOL]             } [EOL]             maxLength = property.getMaximumTextLength(locale); [EOL]             for (int i = min; i <= max; i++) { [EOL]                 property.set(i); [EOL]                 validValues.add(property.getAsShortText(locale)); [EOL]                 validValues.add(property.getAsShortText(locale).toLowerCase(locale)); [EOL]                 validValues.add(property.getAsShortText(locale).toUpperCase(locale)); [EOL]                 validValues.add(property.getAsText(locale)); [EOL]                 validValues.add(property.getAsText(locale).toLowerCase(locale)); [EOL]                 validValues.add(property.getAsText(locale).toUpperCase(locale)); [EOL]             } [EOL]             if ("en".equals(locale.getLanguage()) && iFieldType == DateTimeFieldType.era()) { [EOL]                 validValues.add("BCE"); [EOL]                 validValues.add("bce"); [EOL]                 validValues.add("CE"); [EOL]                 validValues.add("ce"); [EOL]                 maxLength = 3; [EOL]             } [EOL]             array = new Object[] { validValues, Integer.valueOf(maxLength) }; [EOL]             innerMap.put(iFieldType, array); [EOL]         } else { [EOL]             validValues = (Set<String>) array[0]; [EOL]             maxLength = ((Integer) array[1]).intValue(); [EOL]         } [EOL]     } [EOL]     int limit = Math.min(text.length(), position + maxLength); [EOL]     for (int i = limit; i > position; i--) { [EOL]         String match = text.substring(position, i); [EOL]         if (validValues.contains(match)) { [EOL]             bucket.saveField(iFieldType, match, locale); [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return ~position; [EOL] }
protected void printTo(StringBuffer buf, Writer out, long instant, Chronology chrono) throws IOException { [EOL]     DateTimeField field = iFieldType.getField(chrono); [EOL]     int minDigits = iMinDigits; [EOL]     long fraction; [EOL]     try { [EOL]         fraction = field.remainder(instant); [EOL]     } catch (RuntimeException e) { [EOL]         if (buf != null) { [EOL]             appendUnknownString(buf, minDigits); [EOL]         } else { [EOL]             printUnknownString(out, minDigits); [EOL]         } [EOL]         return; [EOL]     } [EOL]     if (fraction == 0) { [EOL]         if (buf != null) { [EOL]             while (--minDigits >= 0) { [EOL]                 buf.append('0'); [EOL]             } [EOL]         } else { [EOL]             while (--minDigits >= 0) { [EOL]                 out.write('0'); [EOL]             } [EOL]         } [EOL]         return; [EOL]     } [EOL]     String str; [EOL]     long[] fractionData = getFractionData(fraction, field); [EOL]     long scaled = fractionData[0]; [EOL]     int maxDigits = (int) fractionData[1]; [EOL]     if ((scaled & 0x7fffffff) == scaled) { [EOL]         str = Integer.toString((int) scaled); [EOL]     } else { [EOL]         str = Long.toString(scaled); [EOL]     } [EOL]     int length = str.length(); [EOL]     int digits = maxDigits; [EOL]     while (length < digits) { [EOL]         if (buf != null) { [EOL]             buf.append('0'); [EOL]         } else { [EOL]             out.write('0'); [EOL]         } [EOL]         minDigits--; [EOL]         digits--; [EOL]     } [EOL]     if (minDigits < digits) { [EOL]         while (minDigits < digits) { [EOL]             if (length <= 1 || str.charAt(length - 1) != '0') { [EOL]                 break; [EOL]             } [EOL]             digits--; [EOL]             length--; [EOL]         } [EOL]         if (length < str.length()) { [EOL]             if (buf != null) { [EOL]                 for (int i = 0; i < length; i++) { [EOL]                     buf.append(str.charAt(i)); [EOL]                 } [EOL]             } else { [EOL]                 for (int i = 0; i < length; i++) { [EOL]                     out.write(str.charAt(i)); [EOL]                 } [EOL]             } [EOL]             return; [EOL]         } [EOL]     } [EOL]     if (buf != null) { [EOL]         buf.append(str); [EOL]     } else { [EOL]         out.write(str); [EOL]     } [EOL] }
private long[] getFractionData(long fraction, DateTimeField field) { [EOL]     long rangeMillis = field.getDurationField().getUnitMillis(); [EOL]     long scalar; [EOL]     int maxDigits = iMaxDigits; [EOL]     while (true) { [EOL]         switch(maxDigits) { [EOL]             default: [EOL]                 scalar = 1L; [EOL]                 break; [EOL]             case 1: [EOL]                 scalar = 10L; [EOL]                 break; [EOL]             case 2: [EOL]                 scalar = 100L; [EOL]                 break; [EOL]             case 3: [EOL]                 scalar = 1000L; [EOL]                 break; [EOL]             case 4: [EOL]                 scalar = 10000L; [EOL]                 break; [EOL]             case 5: [EOL]                 scalar = 100000L; [EOL]                 break; [EOL]             case 6: [EOL]                 scalar = 1000000L; [EOL]                 break; [EOL]             case 7: [EOL]                 scalar = 10000000L; [EOL]                 break; [EOL]             case 8: [EOL]                 scalar = 100000000L; [EOL]                 break; [EOL]             case 9: [EOL]                 scalar = 1000000000L; [EOL]                 break; [EOL]             case 10: [EOL]                 scalar = 10000000000L; [EOL]                 break; [EOL]             case 11: [EOL]                 scalar = 100000000000L; [EOL]                 break; [EOL]             case 12: [EOL]                 scalar = 1000000000000L; [EOL]                 break; [EOL]             case 13: [EOL]                 scalar = 10000000000000L; [EOL]                 break; [EOL]             case 14: [EOL]                 scalar = 100000000000000L; [EOL]                 break; [EOL]             case 15: [EOL]                 scalar = 1000000000000000L; [EOL]                 break; [EOL]             case 16: [EOL]                 scalar = 10000000000000000L; [EOL]                 break; [EOL]             case 17: [EOL]                 scalar = 100000000000000000L; [EOL]                 break; [EOL]             case 18: [EOL]                 scalar = 1000000000000000000L; [EOL]                 break; [EOL]         } [EOL]         if (((rangeMillis * scalar) / scalar) == rangeMillis) { [EOL]             break; [EOL]         } [EOL]         maxDigits--; [EOL]     } [EOL]     return new long[] { fraction * scalar / rangeMillis, maxDigits }; [EOL] }
private long[] getFractionData(long fraction, DateTimeField field) { [EOL]     long rangeMillis = field.getDurationField().getUnitMillis(); [EOL]     long scalar; [EOL]     int maxDigits = iMaxDigits; [EOL]     while (true) { [EOL]         switch(maxDigits) { [EOL]             default: [EOL]                 scalar = 1L; [EOL]                 break; [EOL]             case 1: [EOL]                 scalar = 10L; [EOL]                 break; [EOL]             case 2: [EOL]                 scalar = 100L; [EOL]                 break; [EOL]             case 3: [EOL]                 scalar = 1000L; [EOL]                 break; [EOL]             case 4: [EOL]                 scalar = 10000L; [EOL]                 break; [EOL]             case 5: [EOL]                 scalar = 100000L; [EOL]                 break; [EOL]             case 6: [EOL]                 scalar = 1000000L; [EOL]                 break; [EOL]             case 7: [EOL]                 scalar = 10000000L; [EOL]                 break; [EOL]             case 8: [EOL]                 scalar = 100000000L; [EOL]                 break; [EOL]             case 9: [EOL]                 scalar = 1000000000L; [EOL]                 break; [EOL]             case 10: [EOL]                 scalar = 10000000000L; [EOL]                 break; [EOL]             case 11: [EOL]                 scalar = 100000000000L; [EOL]                 break; [EOL]             case 12: [EOL]                 scalar = 1000000000000L; [EOL]                 break; [EOL]             case 13: [EOL]                 scalar = 10000000000000L; [EOL]                 break; [EOL]             case 14: [EOL]                 scalar = 100000000000000L; [EOL]                 break; [EOL]             case 15: [EOL]                 scalar = 1000000000000000L; [EOL]                 break; [EOL]             case 16: [EOL]                 scalar = 10000000000000000L; [EOL]                 break; [EOL]             case 17: [EOL]                 scalar = 100000000000000000L; [EOL]                 break; [EOL]             case 18: [EOL]                 scalar = 1000000000000000000L; [EOL]                 break; [EOL]         } [EOL]         if (((rangeMillis * scalar) / scalar) == rangeMillis) { [EOL]             break; [EOL]         } [EOL]         maxDigits--; [EOL]     } [EOL]     return new long[] { fraction * scalar / rangeMillis, maxDigits }; [EOL] }
private long[] getFractionData(long fraction, DateTimeField field) { [EOL]     long rangeMillis = field.getDurationField().getUnitMillis(); [EOL]     long scalar; [EOL]     int maxDigits = iMaxDigits; [EOL]     while (true) { [EOL]         switch(maxDigits) { [EOL]             default: [EOL]                 scalar = 1L; [EOL]                 break; [EOL]             case 1: [EOL]                 scalar = 10L; [EOL]                 break; [EOL]             case 2: [EOL]                 scalar = 100L; [EOL]                 break; [EOL]             case 3: [EOL]                 scalar = 1000L; [EOL]                 break; [EOL]             case 4: [EOL]                 scalar = 10000L; [EOL]                 break; [EOL]             case 5: [EOL]                 scalar = 100000L; [EOL]                 break; [EOL]             case 6: [EOL]                 scalar = 1000000L; [EOL]                 break; [EOL]             case 7: [EOL]                 scalar = 10000000L; [EOL]                 break; [EOL]             case 8: [EOL]                 scalar = 100000000L; [EOL]                 break; [EOL]             case 9: [EOL]                 scalar = 1000000000L; [EOL]                 break; [EOL]             case 10: [EOL]                 scalar = 10000000000L; [EOL]                 break; [EOL]             case 11: [EOL]                 scalar = 100000000000L; [EOL]                 break; [EOL]             case 12: [EOL]                 scalar = 1000000000000L; [EOL]                 break; [EOL]             case 13: [EOL]                 scalar = 10000000000000L; [EOL]                 break; [EOL]             case 14: [EOL]                 scalar = 100000000000000L; [EOL]                 break; [EOL]             case 15: [EOL]                 scalar = 1000000000000000L; [EOL]                 break; [EOL]             case 16: [EOL]                 scalar = 10000000000000000L; [EOL]                 break; [EOL]             case 17: [EOL]                 scalar = 100000000000000000L; [EOL]                 break; [EOL]             case 18: [EOL]                 scalar = 1000000000000000000L; [EOL]                 break; [EOL]         } [EOL]         if (((rangeMillis * scalar) / scalar) == rangeMillis) { [EOL]             break; [EOL]         } [EOL]         maxDigits--; [EOL]     } [EOL]     return new long[] { fraction * scalar / rangeMillis, maxDigits }; [EOL] }
private long[] getFractionData(long fraction, DateTimeField field) { [EOL]     long rangeMillis = field.getDurationField().getUnitMillis(); [EOL]     long scalar; [EOL]     int maxDigits = iMaxDigits; [EOL]     while (true) { [EOL]         switch(maxDigits) { [EOL]             default: [EOL]                 scalar = 1L; [EOL]                 break; [EOL]             case 1: [EOL]                 scalar = 10L; [EOL]                 break; [EOL]             case 2: [EOL]                 scalar = 100L; [EOL]                 break; [EOL]             case 3: [EOL]                 scalar = 1000L; [EOL]                 break; [EOL]             case 4: [EOL]                 scalar = 10000L; [EOL]                 break; [EOL]             case 5: [EOL]                 scalar = 100000L; [EOL]                 break; [EOL]             case 6: [EOL]                 scalar = 1000000L; [EOL]                 break; [EOL]             case 7: [EOL]                 scalar = 10000000L; [EOL]                 break; [EOL]             case 8: [EOL]                 scalar = 100000000L; [EOL]                 break; [EOL]             case 9: [EOL]                 scalar = 1000000000L; [EOL]                 break; [EOL]             case 10: [EOL]                 scalar = 10000000000L; [EOL]                 break; [EOL]             case 11: [EOL]                 scalar = 100000000000L; [EOL]                 break; [EOL]             case 12: [EOL]                 scalar = 1000000000000L; [EOL]                 break; [EOL]             case 13: [EOL]                 scalar = 10000000000000L; [EOL]                 break; [EOL]             case 14: [EOL]                 scalar = 100000000000000L; [EOL]                 break; [EOL]             case 15: [EOL]                 scalar = 1000000000000000L; [EOL]                 break; [EOL]             case 16: [EOL]                 scalar = 10000000000000000L; [EOL]                 break; [EOL]             case 17: [EOL]                 scalar = 100000000000000000L; [EOL]                 break; [EOL]             case 18: [EOL]                 scalar = 1000000000000000000L; [EOL]                 break; [EOL]         } [EOL]         if (((rangeMillis * scalar) / scalar) == rangeMillis) { [EOL]             break; [EOL]         } [EOL]         maxDigits--; [EOL]     } [EOL]     return new long[] { fraction * scalar / rangeMillis, maxDigits }; [EOL] }
private long[] getFractionData(long fraction, DateTimeField field) { [EOL]     long rangeMillis = field.getDurationField().getUnitMillis(); [EOL]     long scalar; [EOL]     int maxDigits = iMaxDigits; [EOL]     while (true) { [EOL]         switch(maxDigits) { [EOL]             default: [EOL]                 scalar = 1L; [EOL]                 break; [EOL]             case 1: [EOL]                 scalar = 10L; [EOL]                 break; [EOL]             case 2: [EOL]                 scalar = 100L; [EOL]                 break; [EOL]             case 3: [EOL]                 scalar = 1000L; [EOL]                 break; [EOL]             case 4: [EOL]                 scalar = 10000L; [EOL]                 break; [EOL]             case 5: [EOL]                 scalar = 100000L; [EOL]                 break; [EOL]             case 6: [EOL]                 scalar = 1000000L; [EOL]                 break; [EOL]             case 7: [EOL]                 scalar = 10000000L; [EOL]                 break; [EOL]             case 8: [EOL]                 scalar = 100000000L; [EOL]                 break; [EOL]             case 9: [EOL]                 scalar = 1000000000L; [EOL]                 break; [EOL]             case 10: [EOL]                 scalar = 10000000000L; [EOL]                 break; [EOL]             case 11: [EOL]                 scalar = 100000000000L; [EOL]                 break; [EOL]             case 12: [EOL]                 scalar = 1000000000000L; [EOL]                 break; [EOL]             case 13: [EOL]                 scalar = 10000000000000L; [EOL]                 break; [EOL]             case 14: [EOL]                 scalar = 100000000000000L; [EOL]                 break; [EOL]             case 15: [EOL]                 scalar = 1000000000000000L; [EOL]                 break; [EOL]             case 16: [EOL]                 scalar = 10000000000000000L; [EOL]                 break; [EOL]             case 17: [EOL]                 scalar = 100000000000000000L; [EOL]                 break; [EOL]             case 18: [EOL]                 scalar = 1000000000000000000L; [EOL]                 break; [EOL]         } [EOL]         if (((rangeMillis * scalar) / scalar) == rangeMillis) { [EOL]             break; [EOL]         } [EOL]         maxDigits--; [EOL]     } [EOL]     return new long[] { fraction * scalar / rangeMillis, maxDigits }; [EOL] }
private long[] getFractionData(long fraction, DateTimeField field) { [EOL]     long rangeMillis = field.getDurationField().getUnitMillis(); [EOL]     long scalar; [EOL]     int maxDigits = iMaxDigits; [EOL]     while (true) { [EOL]         switch(maxDigits) { [EOL]             default: [EOL]                 scalar = 1L; [EOL]                 break; [EOL]             case 1: [EOL]                 scalar = 10L; [EOL]                 break; [EOL]             case 2: [EOL]                 scalar = 100L; [EOL]                 break; [EOL]             case 3: [EOL]                 scalar = 1000L; [EOL]                 break; [EOL]             case 4: [EOL]                 scalar = 10000L; [EOL]                 break; [EOL]             case 5: [EOL]                 scalar = 100000L; [EOL]                 break; [EOL]             case 6: [EOL]                 scalar = 1000000L; [EOL]                 break; [EOL]             case 7: [EOL]                 scalar = 10000000L; [EOL]                 break; [EOL]             case 8: [EOL]                 scalar = 100000000L; [EOL]                 break; [EOL]             case 9: [EOL]                 scalar = 1000000000L; [EOL]                 break; [EOL]             case 10: [EOL]                 scalar = 10000000000L; [EOL]                 break; [EOL]             case 11: [EOL]                 scalar = 100000000000L; [EOL]                 break; [EOL]             case 12: [EOL]                 scalar = 1000000000000L; [EOL]                 break; [EOL]             case 13: [EOL]                 scalar = 10000000000000L; [EOL]                 break; [EOL]             case 14: [EOL]                 scalar = 100000000000000L; [EOL]                 break; [EOL]             case 15: [EOL]                 scalar = 1000000000000000L; [EOL]                 break; [EOL]             case 16: [EOL]                 scalar = 10000000000000000L; [EOL]                 break; [EOL]             case 17: [EOL]                 scalar = 100000000000000000L; [EOL]                 break; [EOL]             case 18: [EOL]                 scalar = 1000000000000000000L; [EOL]                 break; [EOL]         } [EOL]         if (((rangeMillis * scalar) / scalar) == rangeMillis) { [EOL]             break; [EOL]         } [EOL]         maxDigits--; [EOL]     } [EOL]     return new long[] { fraction * scalar / rangeMillis, maxDigits }; [EOL] }
public int parseInto(DateTimeParserBucket bucket, String text, int position) { [EOL]     int limit = text.length() - position; [EOL]     zeroOffset: if (iZeroOffsetParseText != null) { [EOL]         if (iZeroOffsetParseText.length() == 0) { [EOL]             if (limit > 0) { [EOL]                 char c = text.charAt(position); [EOL]                 if (c == '-' || c == '+') { [EOL]                     break zeroOffset; [EOL]                 } [EOL]             } [EOL]             bucket.setOffset(Integer.valueOf(0)); [EOL]             return position; [EOL]         } [EOL]         if (text.regionMatches(true, position, iZeroOffsetParseText, 0, iZeroOffsetParseText.length())) { [EOL]             bucket.setOffset(Integer.valueOf(0)); [EOL]             return position + iZeroOffsetParseText.length(); [EOL]         } [EOL]     } [EOL]     if (limit <= 1) { [EOL]         return ~position; [EOL]     } [EOL]     boolean negative; [EOL]     char c = text.charAt(position); [EOL]     if (c == '-') { [EOL]         negative = true; [EOL]     } else if (c == '+') { [EOL]         negative = false; [EOL]     } else { [EOL]         return ~position; [EOL]     } [EOL]     limit--; [EOL]     position++; [EOL]     if (digitCount(text, position, 2) < 2) { [EOL]         return ~position; [EOL]     } [EOL]     int offset; [EOL]     int hours = FormatUtils.parseTwoDigits(text, position); [EOL]     if (hours > 23) { [EOL]         return ~position; [EOL]     } [EOL]     offset = hours * DateTimeConstants.MILLIS_PER_HOUR; [EOL]     limit -= 2; [EOL]     position += 2; [EOL]     parse: { [EOL]         if (limit <= 0) { [EOL]             break parse; [EOL]         } [EOL]         boolean expectSeparators; [EOL]         c = text.charAt(position); [EOL]         if (c == ':') { [EOL]             expectSeparators = true; [EOL]             limit--; [EOL]             position++; [EOL]         } else if (c >= '0' && c <= '9') { [EOL]             expectSeparators = false; [EOL]         } else { [EOL]             break parse; [EOL]         } [EOL]         int count = digitCount(text, position, 2); [EOL]         if (count == 0 && !expectSeparators) { [EOL]             break parse; [EOL]         } else if (count < 2) { [EOL]             return ~position; [EOL]         } [EOL]         int minutes = FormatUtils.parseTwoDigits(text, position); [EOL]         if (minutes > 59) { [EOL]             return ~position; [EOL]         } [EOL]         offset += minutes * DateTimeConstants.MILLIS_PER_MINUTE; [EOL]         limit -= 2; [EOL]         position += 2; [EOL]         if (limit <= 0) { [EOL]             break parse; [EOL]         } [EOL]         if (expectSeparators) { [EOL]             if (text.charAt(position) != ':') { [EOL]                 break parse; [EOL]             } [EOL]             limit--; [EOL]             position++; [EOL]         } [EOL]         count = digitCount(text, position, 2); [EOL]         if (count == 0 && !expectSeparators) { [EOL]             break parse; [EOL]         } else if (count < 2) { [EOL]             return ~position; [EOL]         } [EOL]         int seconds = FormatUtils.parseTwoDigits(text, position); [EOL]         if (seconds > 59) { [EOL]             return ~position; [EOL]         } [EOL]         offset += seconds * DateTimeConstants.MILLIS_PER_SECOND; [EOL]         limit -= 2; [EOL]         position += 2; [EOL]         if (limit <= 0) { [EOL]             break parse; [EOL]         } [EOL]         if (expectSeparators) { [EOL]             if (text.charAt(position) != '.' && text.charAt(position) != ',') { [EOL]                 break parse; [EOL]             } [EOL]             limit--; [EOL]             position++; [EOL]         } [EOL]         count = digitCount(text, position, 3); [EOL]         if (count == 0 && !expectSeparators) { [EOL]             break parse; [EOL]         } else if (count < 1) { [EOL]             return ~position; [EOL]         } [EOL]         offset += (text.charAt(position++) - '0') * 100; [EOL]         if (count > 1) { [EOL]             offset += (text.charAt(position++) - '0') * 10; [EOL]             if (count > 2) { [EOL]                 offset += text.charAt(position++) - '0'; [EOL]             } [EOL]         } [EOL]     } [EOL]     bucket.setOffset(Integer.valueOf(negative ? -offset : offset)); [EOL]     return position; [EOL] }
public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) { [EOL]     DateTimePrinter[] elements = iPrinters; [EOL]     if (elements == null) { [EOL]         throw new UnsupportedOperationException(); [EOL]     } [EOL]     if (locale == null) { [EOL]         locale = Locale.getDefault(); [EOL]     } [EOL]     int len = elements.length; [EOL]     for (int i = 0; i < len; i++) { [EOL]         elements[i].printTo(buf, partial, locale); [EOL]     } [EOL] }
public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) { [EOL]     DateTimePrinter[] elements = iPrinters; [EOL]     if (elements == null) { [EOL]         throw new UnsupportedOperationException(); [EOL]     } [EOL]     if (locale == null) { [EOL]         locale = Locale.getDefault(); [EOL]     } [EOL]     int len = elements.length; [EOL]     for (int i = 0; i < len; i++) { [EOL]         elements[i].printTo(buf, partial, locale); [EOL]     } [EOL] }
public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) { [EOL]     DateTimePrinter[] elements = iPrinters; [EOL]     if (elements == null) { [EOL]         throw new UnsupportedOperationException(); [EOL]     } [EOL]     if (locale == null) { [EOL]         locale = Locale.getDefault(); [EOL]     } [EOL]     int len = elements.length; [EOL]     for (int i = 0; i < len; i++) { [EOL]         elements[i].printTo(buf, partial, locale); [EOL]     } [EOL] }
public int parseInto(DateTimeParserBucket bucket, String text, int position) { [EOL]     DateTimeParser[] parsers = iParsers; [EOL]     int length = parsers.length; [EOL]     final Object originalState = bucket.saveState(); [EOL]     boolean isOptional = false; [EOL]     int bestValidPos = position; [EOL]     Object bestValidState = null; [EOL]     int bestInvalidPos = position; [EOL]     for (int i = 0; i < length; i++) { [EOL]         DateTimeParser parser = parsers[i]; [EOL]         if (parser == null) { [EOL]             if (bestValidPos <= position) { [EOL]                 return position; [EOL]             } [EOL]             isOptional = true; [EOL]             break; [EOL]         } [EOL]         int parsePos = parser.parseInto(bucket, text, position); [EOL]         if (parsePos >= position) { [EOL]             if (parsePos > bestValidPos) { [EOL]                 if (parsePos >= text.length() || (i + 1) >= length || parsers[i + 1] == null) { [EOL]                     return parsePos; [EOL]                 } [EOL]                 bestValidPos = parsePos; [EOL]                 bestValidState = bucket.saveState(); [EOL]             } [EOL]         } else { [EOL]             if (parsePos < 0) { [EOL]                 parsePos = ~parsePos; [EOL]                 if (parsePos > bestInvalidPos) { [EOL]                     bestInvalidPos = parsePos; [EOL]                 } [EOL]             } [EOL]         } [EOL]         bucket.restoreState(originalState); [EOL]     } [EOL]     if (bestValidPos > position || (bestValidPos == position && isOptional)) { [EOL]         if (bestValidState != null) { [EOL]             bucket.restoreState(bestValidState); [EOL]         } [EOL]         return bestValidPos; [EOL]     } [EOL]     return ~bestInvalidPos; [EOL] }
public TimeOfDay(long instant) { [EOL]     super(instant); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public TimeOfDay(Object instant) { [EOL]     super(instant, null, ISODateTimeFormat.timeParser()); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology) { [EOL]     this(hourOfDay, minuteOfHour, secondOfMinute, 0, chronology); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology) { [EOL]     this(hourOfDay, minuteOfHour, secondOfMinute, 0, chronology); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology) { [EOL]     this(hourOfDay, minuteOfHour, secondOfMinute, 0, chronology); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology) { [EOL]     this(hourOfDay, minuteOfHour, secondOfMinute, 0, chronology); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology) { [EOL]     this(hourOfDay, minuteOfHour, secondOfMinute, 0, chronology); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology) { [EOL]     this(hourOfDay, minuteOfHour, secondOfMinute, 0, chronology); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public TimeOfDay withField(DateTimeFieldType fieldType, int value) { [EOL]     int index = indexOfSupported(fieldType); [EOL]     if (value == getValue(index)) { [EOL]         return this; [EOL]     } [EOL]     int[] newValues = getValues(); [EOL]     newValues = getField(index).set(this, index, newValues, value); [EOL]     return new TimeOfDay(this, newValues); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public DateTime toDateTimeToday() { [EOL]     return toDateTimeToday(null); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public DateTime toDateTimeToday() { [EOL]     return toDateTimeToday(null); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public TimeOfDay withHourOfDay(int hour) { [EOL]     int[] newValues = getValues(); [EOL]     newValues = getChronology().hourOfDay().set(this, HOUR_OF_DAY, newValues, hour); [EOL]     return new TimeOfDay(this, newValues); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public TimeOfDay withMinuteOfHour(int minute) { [EOL]     int[] newValues = getValues(); [EOL]     newValues = getChronology().minuteOfHour().set(this, MINUTE_OF_HOUR, newValues, minute); [EOL]     return new TimeOfDay(this, newValues); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public TimeOfDay withSecondOfMinute(int second) { [EOL]     int[] newValues = getValues(); [EOL]     newValues = getChronology().secondOfMinute().set(this, SECOND_OF_MINUTE, newValues, second); [EOL]     return new TimeOfDay(this, newValues); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public TimeOfDay withMillisOfSecond(int millis) { [EOL]     int[] newValues = getValues(); [EOL]     newValues = getChronology().millisOfSecond().set(this, MILLIS_OF_SECOND, newValues, millis); [EOL]     return new TimeOfDay(this, newValues); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public TimeOfDay withMillisOfSecond(int millis) { [EOL]     int[] newValues = getValues(); [EOL]     newValues = getChronology().millisOfSecond().set(this, MILLIS_OF_SECOND, newValues, millis); [EOL]     return new TimeOfDay(this, newValues); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public TimeOfDay withMillisOfSecond(int millis) { [EOL]     int[] newValues = getValues(); [EOL]     newValues = getChronology().millisOfSecond().set(this, MILLIS_OF_SECOND, newValues, millis); [EOL]     return new TimeOfDay(this, newValues); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public Property millisOfSecond() { [EOL]     return new Property(this, MILLIS_OF_SECOND); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public TimeOfDay getTimeOfDay() { [EOL]     return iTimeOfDay; [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public int get() { [EOL]     return iTimeOfDay.getValue(iFieldIndex); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public TimeOfDay addToCopy(int valueToAdd) { [EOL]     int[] newValues = iTimeOfDay.getValues(); [EOL]     newValues = getField().addWrapPartial(iTimeOfDay, iFieldIndex, newValues, valueToAdd); [EOL]     return new TimeOfDay(iTimeOfDay, newValues); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
protected AbstractInterval() { [EOL]     super(); [EOL] }
protected void checkInterval(long start, long end) { [EOL]     if (end < start) { [EOL]         throw new IllegalArgumentException("The end instant must be greater or equal to the start"); [EOL]     } [EOL] }
protected void checkInterval(long start, long end) { [EOL]     if (end < start) { [EOL]         throw new IllegalArgumentException("The end instant must be greater or equal to the start"); [EOL]     } [EOL] }
protected void checkInterval(long start, long end) { [EOL]     if (end < start) { [EOL]         throw new IllegalArgumentException("The end instant must be greater or equal to the start"); [EOL]     } [EOL] }
public boolean isBefore(ReadableInterval interval) { [EOL]     if (interval == null) { [EOL]         return isBeforeNow(); [EOL]     } [EOL]     return isBefore(interval.getStartMillis()); [EOL] }
public boolean isBefore(ReadableInterval interval) { [EOL]     if (interval == null) { [EOL]         return isBeforeNow(); [EOL]     } [EOL]     return isBefore(interval.getStartMillis()); [EOL] }
public boolean isBefore(ReadableInterval interval) { [EOL]     if (interval == null) { [EOL]         return isBeforeNow(); [EOL]     } [EOL]     return isBefore(interval.getStartMillis()); [EOL] }
public long toDurationMillis() { [EOL]     return FieldUtils.safeAdd(getEndMillis(), -getStartMillis()); [EOL] }
public Duration toDuration() { [EOL]     long durMillis = toDurationMillis(); [EOL]     if (durMillis == 0) { [EOL]         return Duration.ZERO; [EOL]     } else { [EOL]         return new Duration(durMillis); [EOL]     } [EOL] }
public Duration toDuration() { [EOL]     long durMillis = toDurationMillis(); [EOL]     if (durMillis == 0) { [EOL]         return Duration.ZERO; [EOL]     } else { [EOL]         return new Duration(durMillis); [EOL]     } [EOL] }
public Period toPeriod() { [EOL]     return new Period(getStartMillis(), getEndMillis(), getChronology()); [EOL] }
public boolean equals(Object readableInterval) { [EOL]     if (this == readableInterval) { [EOL]         return true; [EOL]     } [EOL]     if (readableInterval instanceof ReadableInterval == false) { [EOL]         return false; [EOL]     } [EOL]     ReadableInterval other = (ReadableInterval) readableInterval; [EOL]     return getStartMillis() == other.getStartMillis() && getEndMillis() == other.getEndMillis() && FieldUtils.equals(getChronology(), other.getChronology()); [EOL] }
public int hashCode() { [EOL]     long start = getStartMillis(); [EOL]     long end = getEndMillis(); [EOL]     int result = 97; [EOL]     result = 31 * result + ((int) (start ^ (start >>> 32))); [EOL]     result = 31 * result + ((int) (end ^ (end >>> 32))); [EOL]     result = 31 * result + getChronology().hashCode(); [EOL]     return result; [EOL] }
protected AbstractPeriod() { [EOL]     super(); [EOL] }
public int size() { [EOL]     return getPeriodType().size(); [EOL] }
public DurationFieldType getFieldType(int index) { [EOL]     return getPeriodType().getFieldType(index); [EOL] }
public boolean isSupported(DurationFieldType type) { [EOL]     return getPeriodType().isSupported(type); [EOL] }
public boolean isSupported(DurationFieldType type) { [EOL]     return getPeriodType().isSupported(type); [EOL] }
public MutablePeriod(long duration, PeriodType type) { [EOL]     super(duration, type, null); [EOL] }
public MutablePeriod(long duration, PeriodType type) { [EOL]     super(duration, type, null); [EOL] }
public MutablePeriod(long duration, PeriodType type) { [EOL]     super(duration, type, null); [EOL] }
public MutablePeriod(long duration, PeriodType type, Chronology chronology) { [EOL]     super(duration, type, chronology); [EOL] }
public MutablePeriod(long duration, PeriodType type, Chronology chronology) { [EOL]     super(duration, type, chronology); [EOL] }
public MutablePeriod(long duration, PeriodType type, Chronology chronology) { [EOL]     super(duration, type, chronology); [EOL] }
public MutablePeriod(long startInstant, long endInstant, Chronology chrono) { [EOL]     super(startInstant, endInstant, null, chrono); [EOL] }
public MutablePeriod(long startInstant, long endInstant, Chronology chrono) { [EOL]     super(startInstant, endInstant, null, chrono); [EOL] }
public MutablePeriod(ReadableInstant startInstant, ReadableInstant endInstant) { [EOL]     super(startInstant, endInstant, null); [EOL] }
public MutablePeriod(ReadableInstant startInstant, ReadableInstant endInstant) { [EOL]     super(startInstant, endInstant, null); [EOL] }
public MutablePeriod(ReadableInstant startInstant, ReadableInstant endInstant) { [EOL]     super(startInstant, endInstant, null); [EOL] }
public MutablePeriod(ReadableInstant startInstant, ReadableInstant endInstant) { [EOL]     super(startInstant, endInstant, null); [EOL] }
public MutablePeriod(ReadableInstant startInstant, ReadableDuration duration, PeriodType type) { [EOL]     super(startInstant, duration, type); [EOL] }
public MutablePeriod(ReadableInstant startInstant, ReadableDuration duration, PeriodType type) { [EOL]     super(startInstant, duration, type); [EOL] }
public MutablePeriod(Object period) { [EOL]     super(period, null, null); [EOL] }
public MutablePeriod(Object period, PeriodType type) { [EOL]     super(period, type, null); [EOL] }
public MutablePeriod(Object period, PeriodType type) { [EOL]     super(period, type, null); [EOL] }
public void setPeriod(ReadablePeriod period) { [EOL]     super.setPeriod(period); [EOL] }
public void setPeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis) { [EOL]     super.setPeriod(years, months, weeks, days, hours, minutes, seconds, millis); [EOL] }
public void setPeriod(ReadableInstant start, ReadableInstant end) { [EOL]     if (start == end) { [EOL]         setPeriod(0L); [EOL]     } else { [EOL]         long startMillis = DateTimeUtils.getInstantMillis(start); [EOL]         long endMillis = DateTimeUtils.getInstantMillis(end); [EOL]         Chronology chrono = DateTimeUtils.getIntervalChronology(start, end); [EOL]         setPeriod(startMillis, endMillis, chrono); [EOL]     } [EOL] }
public void setPeriod(ReadableInstant start, ReadableInstant end) { [EOL]     if (start == end) { [EOL]         setPeriod(0L); [EOL]     } else { [EOL]         long startMillis = DateTimeUtils.getInstantMillis(start); [EOL]         long endMillis = DateTimeUtils.getInstantMillis(end); [EOL]         Chronology chrono = DateTimeUtils.getIntervalChronology(start, end); [EOL]         setPeriod(startMillis, endMillis, chrono); [EOL]     } [EOL] }
public void addDays(int days) { [EOL]     super.addField(DurationFieldType.days(), days); [EOL] }
public void addDays(int days) { [EOL]     super.addField(DurationFieldType.days(), days); [EOL] }
public void addDays(int days) { [EOL]     super.addField(DurationFieldType.days(), days); [EOL] }
public void addMinutes(int minutes) { [EOL]     super.addField(DurationFieldType.minutes(), minutes); [EOL] }
public void addMinutes(int minutes) { [EOL]     super.addField(DurationFieldType.minutes(), minutes); [EOL] }
public void addMinutes(int minutes) { [EOL]     super.addField(DurationFieldType.minutes(), minutes); [EOL] }
public PreciseDurationDateTimeField(DateTimeFieldType type, DurationField unit) { [EOL]     super(type); [EOL]     if (!unit.isPrecise()) { [EOL]         throw new IllegalArgumentException("Unit duration field must be precise"); [EOL]     } [EOL]     iUnitMillis = unit.getUnitMillis(); [EOL]     if (iUnitMillis < 1) { [EOL]         throw new IllegalArgumentException("The unit milliseconds must be at least 1"); [EOL]     } [EOL]     iUnitField = unit; [EOL] }
public PreciseDurationDateTimeField(DateTimeFieldType type, DurationField unit) { [EOL]     super(type); [EOL]     if (!unit.isPrecise()) { [EOL]         throw new IllegalArgumentException("Unit duration field must be precise"); [EOL]     } [EOL]     iUnitMillis = unit.getUnitMillis(); [EOL]     if (iUnitMillis < 1) { [EOL]         throw new IllegalArgumentException("The unit milliseconds must be at least 1"); [EOL]     } [EOL]     iUnitField = unit; [EOL] }
public PreciseDurationDateTimeField(DateTimeFieldType type, DurationField unit) { [EOL]     super(type); [EOL]     if (!unit.isPrecise()) { [EOL]         throw new IllegalArgumentException("Unit duration field must be precise"); [EOL]     } [EOL]     iUnitMillis = unit.getUnitMillis(); [EOL]     if (iUnitMillis < 1) { [EOL]         throw new IllegalArgumentException("The unit milliseconds must be at least 1"); [EOL]     } [EOL]     iUnitField = unit; [EOL] }
public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) { [EOL]     if (minuendInstant < subtrahendInstant) { [EOL]         return -iChronology.getYearDifference(subtrahendInstant, minuendInstant); [EOL]     } [EOL]     return iChronology.getYearDifference(minuendInstant, subtrahendInstant); [EOL] }
public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) { [EOL]     if (minuendInstant < subtrahendInstant) { [EOL]         return -iChronology.getYearDifference(subtrahendInstant, minuendInstant); [EOL]     } [EOL]     return iChronology.getYearDifference(minuendInstant, subtrahendInstant); [EOL] }
public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) { [EOL]     if (minuendInstant < subtrahendInstant) { [EOL]         return -iChronology.getYearDifference(subtrahendInstant, minuendInstant); [EOL]     } [EOL]     return iChronology.getYearDifference(minuendInstant, subtrahendInstant); [EOL] }
public DateTimeParserBucket(long instantLocal, Chronology chrono, Locale locale, Integer pivotYear, int defaultYear) { [EOL]     super(); [EOL]     chrono = DateTimeUtils.getChronology(chrono); [EOL]     iMillis = instantLocal; [EOL]     iZone = chrono.getZone(); [EOL]     iChrono = chrono.withUTC(); [EOL]     iLocale = (locale == null ? Locale.getDefault() : locale); [EOL]     iPivotYear = pivotYear; [EOL]     iDefaultYear = defaultYear; [EOL] }
public DateTimeParserBucket(long instantLocal, Chronology chrono, Locale locale, Integer pivotYear, int defaultYear) { [EOL]     super(); [EOL]     chrono = DateTimeUtils.getChronology(chrono); [EOL]     iMillis = instantLocal; [EOL]     iZone = chrono.getZone(); [EOL]     iChrono = chrono.withUTC(); [EOL]     iLocale = (locale == null ? Locale.getDefault() : locale); [EOL]     iPivotYear = pivotYear; [EOL]     iDefaultYear = defaultYear; [EOL] }
public DateTimeParserBucket(long instantLocal, Chronology chrono, Locale locale, Integer pivotYear, int defaultYear) { [EOL]     super(); [EOL]     chrono = DateTimeUtils.getChronology(chrono); [EOL]     iMillis = instantLocal; [EOL]     iZone = chrono.getZone(); [EOL]     iChrono = chrono.withUTC(); [EOL]     iLocale = (locale == null ? Locale.getDefault() : locale); [EOL]     iPivotYear = pivotYear; [EOL]     iDefaultYear = defaultYear; [EOL] }
public Chronology getChronology() { [EOL]     return iChrono; [EOL] }
public DateTimeZone getZone() { [EOL]     return iZone; [EOL] }
public Integer getOffsetInteger() { [EOL]     return iOffset; [EOL] }
public void setOffset(Integer offset) { [EOL]     iSavedState = null; [EOL]     iOffset = offset; [EOL] }
public void setOffset(Integer offset) { [EOL]     iSavedState = null; [EOL]     iOffset = offset; [EOL] }
public void saveField(DateTimeField field, int value) { [EOL]     saveField(new SavedField(field, value)); [EOL] }
public void saveField(DateTimeFieldType fieldType, int value) { [EOL]     saveField(new SavedField(fieldType.getField(iChrono), value)); [EOL] }
public void saveField(DateTimeFieldType fieldType, int value) { [EOL]     saveField(new SavedField(fieldType.getField(iChrono), value)); [EOL] }
private void saveField(SavedField field) { [EOL]     SavedField[] savedFields = iSavedFields; [EOL]     int savedFieldsCount = iSavedFieldsCount; [EOL]     if (savedFieldsCount == savedFields.length || iSavedFieldsShared) { [EOL]         SavedField[] newArray = new SavedField[savedFieldsCount == savedFields.length ? savedFieldsCount * 2 : savedFields.length]; [EOL]         System.arraycopy(savedFields, 0, newArray, 0, savedFieldsCount); [EOL]         iSavedFields = savedFields = newArray; [EOL]         iSavedFieldsShared = false; [EOL]     } [EOL]     iSavedState = null; [EOL]     savedFields[savedFieldsCount] = field; [EOL]     iSavedFieldsCount = savedFieldsCount + 1; [EOL] }
private void saveField(SavedField field) { [EOL]     SavedField[] savedFields = iSavedFields; [EOL]     int savedFieldsCount = iSavedFieldsCount; [EOL]     if (savedFieldsCount == savedFields.length || iSavedFieldsShared) { [EOL]         SavedField[] newArray = new SavedField[savedFieldsCount == savedFields.length ? savedFieldsCount * 2 : savedFields.length]; [EOL]         System.arraycopy(savedFields, 0, newArray, 0, savedFieldsCount); [EOL]         iSavedFields = savedFields = newArray; [EOL]         iSavedFieldsShared = false; [EOL]     } [EOL]     iSavedState = null; [EOL]     savedFields[savedFieldsCount] = field; [EOL]     iSavedFieldsCount = savedFieldsCount + 1; [EOL] }
private void saveField(SavedField field) { [EOL]     SavedField[] savedFields = iSavedFields; [EOL]     int savedFieldsCount = iSavedFieldsCount; [EOL]     if (savedFieldsCount == savedFields.length || iSavedFieldsShared) { [EOL]         SavedField[] newArray = new SavedField[savedFieldsCount == savedFields.length ? savedFieldsCount * 2 : savedFields.length]; [EOL]         System.arraycopy(savedFields, 0, newArray, 0, savedFieldsCount); [EOL]         iSavedFields = savedFields = newArray; [EOL]         iSavedFieldsShared = false; [EOL]     } [EOL]     iSavedState = null; [EOL]     savedFields[savedFieldsCount] = field; [EOL]     iSavedFieldsCount = savedFieldsCount + 1; [EOL] }
public Object saveState() { [EOL]     if (iSavedState == null) { [EOL]         iSavedState = new SavedState(); [EOL]     } [EOL]     return iSavedState; [EOL] }
public boolean restoreState(Object savedState) { [EOL]     if (savedState instanceof SavedState) { [EOL]         if (((SavedState) savedState).restoreState(this)) { [EOL]             iSavedState = savedState; [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public boolean restoreState(Object savedState) { [EOL]     if (savedState instanceof SavedState) { [EOL]         if (((SavedState) savedState).restoreState(this)) { [EOL]             iSavedState = savedState; [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public boolean restoreState(Object savedState) { [EOL]     if (savedState instanceof SavedState) { [EOL]         if (((SavedState) savedState).restoreState(this)) { [EOL]             iSavedState = savedState; [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public long computeMillis(boolean resetFields, String text) { [EOL]     SavedField[] savedFields = iSavedFields; [EOL]     int count = iSavedFieldsCount; [EOL]     if (iSavedFieldsShared) { [EOL]         iSavedFields = savedFields = (SavedField[]) iSavedFields.clone(); [EOL]         iSavedFieldsShared = false; [EOL]     } [EOL]     sort(savedFields, count); [EOL]     if (count > 0) { [EOL]         DurationField months = DurationFieldType.months().getField(iChrono); [EOL]         DurationField days = DurationFieldType.days().getField(iChrono); [EOL]         DurationField first = savedFields[0].iField.getDurationField(); [EOL]         if (compareReverse(first, months) >= 0 && compareReverse(first, days) <= 0) { [EOL]             saveField(DateTimeFieldType.year(), iDefaultYear); [EOL]             return computeMillis(resetFields, text); [EOL]         } [EOL]     } [EOL]     long millis = iMillis; [EOL]     try { [EOL]         for (int i = 0; i < count; i++) { [EOL]             millis = savedFields[i].set(millis, resetFields); [EOL]         } [EOL]         if (resetFields) { [EOL]             for (int i = 0; i < count; i++) { [EOL]                 millis = savedFields[i].set(millis, i == (count - 1)); [EOL]             } [EOL]         } [EOL]     } catch (IllegalFieldValueException e) { [EOL]         if (text != null) { [EOL]             e.prependMessage("Cannot parse \"" + text + '"'); [EOL]         } [EOL]         throw e; [EOL]     } [EOL]     if (iOffset != null) { [EOL]         millis -= iOffset; [EOL]     } else if (iZone != null) { [EOL]         int offset = iZone.getOffsetFromLocal(millis); [EOL]         millis -= offset; [EOL]         if (offset != iZone.getOffset(millis)) { [EOL]             String message = "Illegal instant due to time zone offset transition (" + iZone + ')'; [EOL]             if (text != null) { [EOL]                 message = "Cannot parse \"" + text + "\": " + message; [EOL]             } [EOL]             throw new IllegalInstantException(message); [EOL]         } [EOL]     } [EOL]     return millis; [EOL] }
private static void sort(SavedField[] array, int high) { [EOL]     if (high > 10) { [EOL]         Arrays.sort(array, 0, high); [EOL]     } else { [EOL]         for (int i = 0; i < high; i++) { [EOL]             for (int j = i; j > 0 && (array[j - 1]).compareTo(array[j]) > 0; j--) { [EOL]                 SavedField t = array[j]; [EOL]                 array[j] = array[j - 1]; [EOL]                 array[j - 1] = t; [EOL]             } [EOL]         } [EOL]     } [EOL] }
private static void sort(SavedField[] array, int high) { [EOL]     if (high > 10) { [EOL]         Arrays.sort(array, 0, high); [EOL]     } else { [EOL]         for (int i = 0; i < high; i++) { [EOL]             for (int j = i; j > 0 && (array[j - 1]).compareTo(array[j]) > 0; j--) { [EOL]                 SavedField t = array[j]; [EOL]                 array[j] = array[j - 1]; [EOL]                 array[j - 1] = t; [EOL]             } [EOL]         } [EOL]     } [EOL] }
SavedState() { [EOL]     this.iZone = DateTimeParserBucket.this.iZone; [EOL]     this.iOffset = DateTimeParserBucket.this.iOffset; [EOL]     this.iSavedFields = DateTimeParserBucket.this.iSavedFields; [EOL]     this.iSavedFieldsCount = DateTimeParserBucket.this.iSavedFieldsCount; [EOL] }
boolean restoreState(DateTimeParserBucket enclosing) { [EOL]     if (enclosing != DateTimeParserBucket.this) { [EOL]         return false; [EOL]     } [EOL]     enclosing.iZone = this.iZone; [EOL]     enclosing.iOffset = this.iOffset; [EOL]     enclosing.iSavedFields = this.iSavedFields; [EOL]     if (this.iSavedFieldsCount < enclosing.iSavedFieldsCount) { [EOL]         enclosing.iSavedFieldsShared = true; [EOL]     } [EOL]     enclosing.iSavedFieldsCount = this.iSavedFieldsCount; [EOL]     return true; [EOL] }
boolean restoreState(DateTimeParserBucket enclosing) { [EOL]     if (enclosing != DateTimeParserBucket.this) { [EOL]         return false; [EOL]     } [EOL]     enclosing.iZone = this.iZone; [EOL]     enclosing.iOffset = this.iOffset; [EOL]     enclosing.iSavedFields = this.iSavedFields; [EOL]     if (this.iSavedFieldsCount < enclosing.iSavedFieldsCount) { [EOL]         enclosing.iSavedFieldsShared = true; [EOL]     } [EOL]     enclosing.iSavedFieldsCount = this.iSavedFieldsCount; [EOL]     return true; [EOL] }
boolean restoreState(DateTimeParserBucket enclosing) { [EOL]     if (enclosing != DateTimeParserBucket.this) { [EOL]         return false; [EOL]     } [EOL]     enclosing.iZone = this.iZone; [EOL]     enclosing.iOffset = this.iOffset; [EOL]     enclosing.iSavedFields = this.iSavedFields; [EOL]     if (this.iSavedFieldsCount < enclosing.iSavedFieldsCount) { [EOL]         enclosing.iSavedFieldsShared = true; [EOL]     } [EOL]     enclosing.iSavedFieldsCount = this.iSavedFieldsCount; [EOL]     return true; [EOL] }
SavedField(DateTimeField field, int value) { [EOL]     iField = field; [EOL]     iValue = value; [EOL]     iText = null; [EOL]     iLocale = null; [EOL] }
SavedField(DateTimeField field, int value) { [EOL]     iField = field; [EOL]     iValue = value; [EOL]     iText = null; [EOL]     iLocale = null; [EOL] }
long set(long millis, boolean reset) { [EOL]     if (iText == null) { [EOL]         millis = iField.set(millis, iValue); [EOL]     } else { [EOL]         millis = iField.set(millis, iText, iLocale); [EOL]     } [EOL]     if (reset) { [EOL]         millis = iField.roundFloor(millis); [EOL]     } [EOL]     return millis; [EOL] }
long set(long millis, boolean reset) { [EOL]     if (iText == null) { [EOL]         millis = iField.set(millis, iValue); [EOL]     } else { [EOL]         millis = iField.set(millis, iText, iLocale); [EOL]     } [EOL]     if (reset) { [EOL]         millis = iField.roundFloor(millis); [EOL]     } [EOL]     return millis; [EOL] }
long set(long millis, boolean reset) { [EOL]     if (iText == null) { [EOL]         millis = iField.set(millis, iValue); [EOL]     } else { [EOL]         millis = iField.set(millis, iText, iLocale); [EOL]     } [EOL]     if (reset) { [EOL]         millis = iField.roundFloor(millis); [EOL]     } [EOL]     return millis; [EOL] }
long set(long millis, boolean reset) { [EOL]     if (iText == null) { [EOL]         millis = iField.set(millis, iValue); [EOL]     } else { [EOL]         millis = iField.set(millis, iText, iLocale); [EOL]     } [EOL]     if (reset) { [EOL]         millis = iField.roundFloor(millis); [EOL]     } [EOL]     return millis; [EOL] }
public int compareTo(SavedField obj) { [EOL]     DateTimeField other = obj.iField; [EOL]     int result = compareReverse(iField.getRangeDurationField(), other.getRangeDurationField()); [EOL]     if (result != 0) { [EOL]         return result; [EOL]     } [EOL]     return compareReverse(iField.getDurationField(), other.getDurationField()); [EOL] }
public int compareTo(SavedField obj) { [EOL]     DateTimeField other = obj.iField; [EOL]     int result = compareReverse(iField.getRangeDurationField(), other.getRangeDurationField()); [EOL]     if (result != 0) { [EOL]         return result; [EOL]     } [EOL]     return compareReverse(iField.getDurationField(), other.getDurationField()); [EOL] }
public int compareTo(SavedField obj) { [EOL]     DateTimeField other = obj.iField; [EOL]     int result = compareReverse(iField.getRangeDurationField(), other.getRangeDurationField()); [EOL]     if (result != 0) { [EOL]         return result; [EOL]     } [EOL]     return compareReverse(iField.getDurationField(), other.getDurationField()); [EOL] }
static int compareReverse(DurationField a, DurationField b) { [EOL]     if (a == null || !a.isSupported()) { [EOL]         if (b == null || !b.isSupported()) { [EOL]             return 0; [EOL]         } [EOL]         return -1; [EOL]     } [EOL]     if (b == null || !b.isSupported()) { [EOL]         return 1; [EOL]     } [EOL]     return -a.compareTo(b); [EOL] }
static int compareReverse(DurationField a, DurationField b) { [EOL]     if (a == null || !a.isSupported()) { [EOL]         if (b == null || !b.isSupported()) { [EOL]             return 0; [EOL]         } [EOL]         return -1; [EOL]     } [EOL]     if (b == null || !b.isSupported()) { [EOL]         return 1; [EOL]     } [EOL]     return -a.compareTo(b); [EOL] }
static int compareReverse(DurationField a, DurationField b) { [EOL]     if (a == null || !a.isSupported()) { [EOL]         if (b == null || !b.isSupported()) { [EOL]             return 0; [EOL]         } [EOL]         return -1; [EOL]     } [EOL]     if (b == null || !b.isSupported()) { [EOL]         return 1; [EOL]     } [EOL]     return -a.compareTo(b); [EOL] }
static int compareReverse(DurationField a, DurationField b) { [EOL]     if (a == null || !a.isSupported()) { [EOL]         if (b == null || !b.isSupported()) { [EOL]             return 0; [EOL]         } [EOL]         return -1; [EOL]     } [EOL]     if (b == null || !b.isSupported()) { [EOL]         return 1; [EOL]     } [EOL]     return -a.compareTo(b); [EOL] }
static int compareReverse(DurationField a, DurationField b) { [EOL]     if (a == null || !a.isSupported()) { [EOL]         if (b == null || !b.isSupported()) { [EOL]             return 0; [EOL]         } [EOL]         return -1; [EOL]     } [EOL]     if (b == null || !b.isSupported()) { [EOL]         return 1; [EOL]     } [EOL]     return -a.compareTo(b); [EOL] }
static int compareReverse(DurationField a, DurationField b) { [EOL]     if (a == null || !a.isSupported()) { [EOL]         if (b == null || !b.isSupported()) { [EOL]             return 0; [EOL]         } [EOL]         return -1; [EOL]     } [EOL]     if (b == null || !b.isSupported()) { [EOL]         return 1; [EOL]     } [EOL]     return -a.compareTo(b); [EOL] }
public long roundHalfCeiling(long instant) { [EOL]     return getWrappedField().roundHalfCeiling(instant); [EOL] }
public int getOffset() { [EOL]     return iOffset; [EOL] }
BasicFixedMonthChronology(Chronology base, Object param, int minDaysInFirstWeek) { [EOL]     super(base, param, minDaysInFirstWeek); [EOL] }
long getYearDifference(long minuendInstant, long subtrahendInstant) { [EOL]     int minuendYear = getYear(minuendInstant); [EOL]     int subtrahendYear = getYear(subtrahendInstant); [EOL]     long minuendRem = minuendInstant - getYearMillis(minuendYear); [EOL]     long subtrahendRem = subtrahendInstant - getYearMillis(subtrahendYear); [EOL]     int difference = minuendYear - subtrahendYear; [EOL]     if (minuendRem < subtrahendRem) { [EOL]         difference--; [EOL]     } [EOL]     return difference; [EOL] }
long getYearDifference(long minuendInstant, long subtrahendInstant) { [EOL]     int minuendYear = getYear(minuendInstant); [EOL]     int subtrahendYear = getYear(subtrahendInstant); [EOL]     long minuendRem = minuendInstant - getYearMillis(minuendYear); [EOL]     long subtrahendRem = subtrahendInstant - getYearMillis(subtrahendYear); [EOL]     int difference = minuendYear - subtrahendYear; [EOL]     if (minuendRem < subtrahendRem) { [EOL]         difference--; [EOL]     } [EOL]     return difference; [EOL] }
long getYearDifference(long minuendInstant, long subtrahendInstant) { [EOL]     int minuendYear = getYear(minuendInstant); [EOL]     int subtrahendYear = getYear(subtrahendInstant); [EOL]     long minuendRem = minuendInstant - getYearMillis(minuendYear); [EOL]     long subtrahendRem = subtrahendInstant - getYearMillis(subtrahendYear); [EOL]     int difference = minuendYear - subtrahendYear; [EOL]     if (minuendRem < subtrahendRem) { [EOL]         difference--; [EOL]     } [EOL]     return difference; [EOL] }
long getYearDifference(long minuendInstant, long subtrahendInstant) { [EOL]     int minuendYear = getYear(minuendInstant); [EOL]     int subtrahendYear = getYear(subtrahendInstant); [EOL]     long minuendRem = minuendInstant - getYearMillis(minuendYear); [EOL]     long subtrahendRem = subtrahendInstant - getYearMillis(subtrahendYear); [EOL]     int difference = minuendYear - subtrahendYear; [EOL]     if (minuendRem < subtrahendRem) { [EOL]         difference--; [EOL]     } [EOL]     return difference; [EOL] }
long getYearDifference(long minuendInstant, long subtrahendInstant) { [EOL]     int minuendYear = getYear(minuendInstant); [EOL]     int subtrahendYear = getYear(subtrahendInstant); [EOL]     long minuendRem = minuendInstant - getYearMillis(minuendYear); [EOL]     long subtrahendRem = subtrahendInstant - getYearMillis(subtrahendYear); [EOL]     int difference = minuendYear - subtrahendYear; [EOL]     if (minuendRem < subtrahendRem) { [EOL]         difference--; [EOL]     } [EOL]     return difference; [EOL] }
public int get(long instant) { [EOL]     return iChronology.getWeekOfWeekyear(instant); [EOL] }
public DurationField getRangeDurationField() { [EOL]     return iChronology.weekyears(); [EOL] }
protected int getMaximumValueForSet(long instant, int value) { [EOL]     return value > 52 ? getMaximumValue(instant) : 52; [EOL] }
public long getDateTimeMillis(long instant, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) throws IllegalArgumentException { [EOL]     Chronology base; [EOL]     if ((base = iBase) != null && (iBaseFlags & 1) == 1) { [EOL]         return base.getDateTimeMillis(instant, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]     } [EOL]     return super.getDateTimeMillis(instant, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL] }
public long getDateTimeMillis(long instant, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) throws IllegalArgumentException { [EOL]     Chronology base; [EOL]     if ((base = iBase) != null && (iBaseFlags & 1) == 1) { [EOL]         return base.getDateTimeMillis(instant, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]     } [EOL]     return super.getDateTimeMillis(instant, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL] }
public long getDateTimeMillis(long instant, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) throws IllegalArgumentException { [EOL]     Chronology base; [EOL]     if ((base = iBase) != null && (iBaseFlags & 1) == 1) { [EOL]         return base.getDateTimeMillis(instant, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]     } [EOL]     return super.getDateTimeMillis(instant, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL] }
public final DurationField minutes() { [EOL]     return iMinutes; [EOL] }
public final DurationField hours() { [EOL]     return iHours; [EOL] }
public Hours toStandardHours() { [EOL]     return Hours.hours(FieldUtils.safeMultiply(getValue(), DateTimeConstants.HOURS_PER_DAY)); [EOL] }
public Hours toStandardHours() { [EOL]     return Hours.hours(FieldUtils.safeMultiply(getValue(), DateTimeConstants.HOURS_PER_DAY)); [EOL] }
public Hours toStandardHours() { [EOL]     return Hours.hours(FieldUtils.safeMultiply(getValue(), DateTimeConstants.HOURS_PER_DAY)); [EOL] }
public int getDays() { [EOL]     return getValue(); [EOL] }
public Days plus(Days days) { [EOL]     if (days == null) { [EOL]         return this; [EOL]     } [EOL]     return plus(days.getValue()); [EOL] }
public Days plus(Days days) { [EOL]     if (days == null) { [EOL]         return this; [EOL]     } [EOL]     return plus(days.getValue()); [EOL] }
public int get(long instant) { [EOL]     int year = getWrappedField().get(instant); [EOL]     if (year <= 0) { [EOL]         year = 1 - year; [EOL]     } [EOL]     return year; [EOL] }
public int get(long instant) { [EOL]     int year = getWrappedField().get(instant); [EOL]     if (year <= 0) { [EOL]         year = 1 - year; [EOL]     } [EOL]     return year; [EOL] }
public int get(long instant) { [EOL]     int year = getWrappedField().get(instant); [EOL]     if (year <= 0) { [EOL]         year = 1 - year; [EOL]     } [EOL]     return year; [EOL] }
public static MonthDay now() { [EOL]     return new MonthDay(); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public static MonthDay now() { [EOL]     return new MonthDay(); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public static MonthDay now() { [EOL]     return new MonthDay(); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public static MonthDay now() { [EOL]     return new MonthDay(); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public static MonthDay now() { [EOL]     return new MonthDay(); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public static MonthDay now() { [EOL]     return new MonthDay(); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public static MonthDay now() { [EOL]     return new MonthDay(); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public static MonthDay now() { [EOL]     return new MonthDay(); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public static MonthDay now() { [EOL]     return new MonthDay(); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public static MonthDay now() { [EOL]     return new MonthDay(); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public static MonthDay now() { [EOL]     return new MonthDay(); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay(Chronology chronology) { [EOL]     super(chronology); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay(Chronology chronology) { [EOL]     super(chronology); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay(Chronology chronology) { [EOL]     super(chronology); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay(Chronology chronology) { [EOL]     super(chronology); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay(Chronology chronology) { [EOL]     super(chronology); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay(Chronology chronology) { [EOL]     super(chronology); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay(Chronology chronology) { [EOL]     super(chronology); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay(Chronology chronology) { [EOL]     super(chronology); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay(Chronology chronology) { [EOL]     super(chronology); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay(long instant) { [EOL]     super(instant); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay(long instant) { [EOL]     super(instant); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay(long instant) { [EOL]     super(instant); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay(long instant) { [EOL]     super(instant); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay(long instant) { [EOL]     super(instant); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay(long instant) { [EOL]     super(instant); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay(long instant) { [EOL]     super(instant); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay(long instant) { [EOL]     super(instant); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay(long instant) { [EOL]     super(instant); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay(long instant) { [EOL]     super(instant); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay(long instant) { [EOL]     super(instant); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay(long instant) { [EOL]     super(instant); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay(long instant) { [EOL]     super(instant); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay(long instant) { [EOL]     super(instant); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay(long instant) { [EOL]     super(instant); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay(long instant) { [EOL]     super(instant); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay(long instant) { [EOL]     super(instant); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay(long instant) { [EOL]     super(instant); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay(long instant) { [EOL]     super(instant); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
MonthDay(MonthDay partial, Chronology chrono) { [EOL]     super(partial, chrono); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
MonthDay(MonthDay partial, Chronology chrono) { [EOL]     super(partial, chrono); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
MonthDay(MonthDay partial, Chronology chrono) { [EOL]     super(partial, chrono); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
MonthDay(MonthDay partial, Chronology chrono) { [EOL]     super(partial, chrono); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
MonthDay(MonthDay partial, Chronology chrono) { [EOL]     super(partial, chrono); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
MonthDay(MonthDay partial, Chronology chrono) { [EOL]     super(partial, chrono); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
MonthDay(MonthDay partial, Chronology chrono) { [EOL]     super(partial, chrono); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
MonthDay(MonthDay partial, Chronology chrono) { [EOL]     super(partial, chrono); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
MonthDay(MonthDay partial, Chronology chrono) { [EOL]     super(partial, chrono); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
MonthDay(MonthDay partial, Chronology chrono) { [EOL]     super(partial, chrono); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public DateTimeFieldType[] getFieldTypes() { [EOL]     return (DateTimeFieldType[]) FIELD_TYPES.clone(); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay withChronologyRetainFields(Chronology newChronology) { [EOL]     newChronology = DateTimeUtils.getChronology(newChronology); [EOL]     newChronology = newChronology.withUTC(); [EOL]     if (newChronology == getChronology()) { [EOL]         return this; [EOL]     } else { [EOL]         MonthDay newMonthDay = new MonthDay(this, newChronology); [EOL]         newChronology.validate(newMonthDay, getValues()); [EOL]         return newMonthDay; [EOL]     } [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay withChronologyRetainFields(Chronology newChronology) { [EOL]     newChronology = DateTimeUtils.getChronology(newChronology); [EOL]     newChronology = newChronology.withUTC(); [EOL]     if (newChronology == getChronology()) { [EOL]         return this; [EOL]     } else { [EOL]         MonthDay newMonthDay = new MonthDay(this, newChronology); [EOL]         newChronology.validate(newMonthDay, getValues()); [EOL]         return newMonthDay; [EOL]     } [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay withField(DateTimeFieldType fieldType, int value) { [EOL]     int index = indexOfSupported(fieldType); [EOL]     if (value == getValue(index)) { [EOL]         return this; [EOL]     } [EOL]     int[] newValues = getValues(); [EOL]     newValues = getField(index).set(this, index, newValues, value); [EOL]     return new MonthDay(this, newValues); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay withField(DateTimeFieldType fieldType, int value) { [EOL]     int index = indexOfSupported(fieldType); [EOL]     if (value == getValue(index)) { [EOL]         return this; [EOL]     } [EOL]     int[] newValues = getValues(); [EOL]     newValues = getField(index).set(this, index, newValues, value); [EOL]     return new MonthDay(this, newValues); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay withField(DateTimeFieldType fieldType, int value) { [EOL]     int index = indexOfSupported(fieldType); [EOL]     if (value == getValue(index)) { [EOL]         return this; [EOL]     } [EOL]     int[] newValues = getValues(); [EOL]     newValues = getField(index).set(this, index, newValues, value); [EOL]     return new MonthDay(this, newValues); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay minusMonths(int months) { [EOL]     return withFieldAdded(DurationFieldType.months(), FieldUtils.safeNegate(months)); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay minusDays(int days) { [EOL]     return withFieldAdded(DurationFieldType.days(), FieldUtils.safeNegate(days)); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public String toString(String pattern, Locale locale) throws IllegalArgumentException { [EOL]     if (pattern == null) { [EOL]         return toString(); [EOL]     } [EOL]     return DateTimeFormat.forPattern(pattern).withLocale(locale).print(this); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public String toString(String pattern, Locale locale) throws IllegalArgumentException { [EOL]     if (pattern == null) { [EOL]         return toString(); [EOL]     } [EOL]     return DateTimeFormat.forPattern(pattern).withLocale(locale).print(this); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public String toString(String pattern, Locale locale) throws IllegalArgumentException { [EOL]     if (pattern == null) { [EOL]         return toString(); [EOL]     } [EOL]     return DateTimeFormat.forPattern(pattern).withLocale(locale).print(this); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay addToCopy(int valueToAdd) { [EOL]     int[] newValues = iBase.getValues(); [EOL]     newValues = getField().add(iBase, iFieldIndex, newValues, valueToAdd); [EOL]     return new MonthDay(iBase, newValues); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay setCopy(String text, Locale locale) { [EOL]     int[] newValues = iBase.getValues(); [EOL]     newValues = getField().set(iBase, iFieldIndex, newValues, text, locale); [EOL]     return new MonthDay(iBase, newValues); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay setCopy(String text, Locale locale) { [EOL]     int[] newValues = iBase.getValues(); [EOL]     newValues = getField().set(iBase, iFieldIndex, newValues, text, locale); [EOL]     return new MonthDay(iBase, newValues); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay setCopy(String text, Locale locale) { [EOL]     int[] newValues = iBase.getValues(); [EOL]     newValues = getField().set(iBase, iFieldIndex, newValues, text, locale); [EOL]     return new MonthDay(iBase, newValues); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay setCopy(String text) { [EOL]     return setCopy(text, null); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay setCopy(String text) { [EOL]     return setCopy(text, null); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay setCopy(String text) { [EOL]     return setCopy(text, null); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay setCopy(String text) { [EOL]     return setCopy(text, null); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay setCopy(String text) { [EOL]     return setCopy(text, null); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay setCopy(String text) { [EOL]     return setCopy(text, null); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay setCopy(String text) { [EOL]     return setCopy(text, null); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay setCopy(String text) { [EOL]     return setCopy(text, null); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay setCopy(String text) { [EOL]     return setCopy(text, null); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay setCopy(String text) { [EOL]     return setCopy(text, null); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay setCopy(String text) { [EOL]     return setCopy(text, null); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay setCopy(String text) { [EOL]     return setCopy(text, null); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay setCopy(String text) { [EOL]     return setCopy(text, null); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay setCopy(String text) { [EOL]     return setCopy(text, null); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay setCopy(String text) { [EOL]     return setCopy(text, null); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay setCopy(String text) { [EOL]     return setCopy(text, null); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay setCopy(String text) { [EOL]     return setCopy(text, null); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
@SuppressWarnings("deprecation") [EOL] public static LocalDateTime fromDateFields(Date date) { [EOL]     if (date == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     if (date.getTime() < 0) { [EOL]         GregorianCalendar cal = new GregorianCalendar(); [EOL]         cal.setTime(date); [EOL]         return fromCalendarFields(cal); [EOL]     } [EOL]     return new LocalDateTime(date.getYear() + 1900, date.getMonth() + 1, date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), (((int) (date.getTime() % 1000)) + 1000) % 1000); [EOL] }
@SuppressWarnings("deprecation") [EOL] public static LocalDateTime fromDateFields(Date date) { [EOL]     if (date == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     if (date.getTime() < 0) { [EOL]         GregorianCalendar cal = new GregorianCalendar(); [EOL]         cal.setTime(date); [EOL]         return fromCalendarFields(cal); [EOL]     } [EOL]     return new LocalDateTime(date.getYear() + 1900, date.getMonth() + 1, date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), (((int) (date.getTime() % 1000)) + 1000) % 1000); [EOL] }
@SuppressWarnings("deprecation") [EOL] public static LocalDateTime fromDateFields(Date date) { [EOL]     if (date == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     if (date.getTime() < 0) { [EOL]         GregorianCalendar cal = new GregorianCalendar(); [EOL]         cal.setTime(date); [EOL]         return fromCalendarFields(cal); [EOL]     } [EOL]     return new LocalDateTime(date.getYear() + 1900, date.getMonth() + 1, date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), (((int) (date.getTime() % 1000)) + 1000) % 1000); [EOL] }
public LocalDateTime(Object instant, DateTimeZone zone) { [EOL]     PartialConverter converter = ConverterManager.getInstance().getPartialConverter(instant); [EOL]     Chronology chronology = converter.getChronology(instant, zone); [EOL]     chronology = DateTimeUtils.getChronology(chronology); [EOL]     iChronology = chronology.withUTC(); [EOL]     int[] values = converter.getPartialValues(this, instant, chronology, ISODateTimeFormat.localDateOptionalTimeParser()); [EOL]     iLocalMillis = iChronology.getDateTimeMillis(values[0], values[1], values[2], values[3]); [EOL] }
public LocalDateTime(Object instant, DateTimeZone zone) { [EOL]     PartialConverter converter = ConverterManager.getInstance().getPartialConverter(instant); [EOL]     Chronology chronology = converter.getChronology(instant, zone); [EOL]     chronology = DateTimeUtils.getChronology(chronology); [EOL]     iChronology = chronology.withUTC(); [EOL]     int[] values = converter.getPartialValues(this, instant, chronology, ISODateTimeFormat.localDateOptionalTimeParser()); [EOL]     iLocalMillis = iChronology.getDateTimeMillis(values[0], values[1], values[2], values[3]); [EOL] }
public LocalDateTime(Object instant, DateTimeZone zone) { [EOL]     PartialConverter converter = ConverterManager.getInstance().getPartialConverter(instant); [EOL]     Chronology chronology = converter.getChronology(instant, zone); [EOL]     chronology = DateTimeUtils.getChronology(chronology); [EOL]     iChronology = chronology.withUTC(); [EOL]     int[] values = converter.getPartialValues(this, instant, chronology, ISODateTimeFormat.localDateOptionalTimeParser()); [EOL]     iLocalMillis = iChronology.getDateTimeMillis(values[0], values[1], values[2], values[3]); [EOL] }
public LocalDateTime(Object instant, DateTimeZone zone) { [EOL]     PartialConverter converter = ConverterManager.getInstance().getPartialConverter(instant); [EOL]     Chronology chronology = converter.getChronology(instant, zone); [EOL]     chronology = DateTimeUtils.getChronology(chronology); [EOL]     iChronology = chronology.withUTC(); [EOL]     int[] values = converter.getPartialValues(this, instant, chronology, ISODateTimeFormat.localDateOptionalTimeParser()); [EOL]     iLocalMillis = iChronology.getDateTimeMillis(values[0], values[1], values[2], values[3]); [EOL] }
public LocalDateTime(Object instant, Chronology chronology) { [EOL]     PartialConverter converter = ConverterManager.getInstance().getPartialConverter(instant); [EOL]     chronology = converter.getChronology(instant, chronology); [EOL]     chronology = DateTimeUtils.getChronology(chronology); [EOL]     iChronology = chronology.withUTC(); [EOL]     int[] values = converter.getPartialValues(this, instant, chronology, ISODateTimeFormat.localDateOptionalTimeParser()); [EOL]     iLocalMillis = iChronology.getDateTimeMillis(values[0], values[1], values[2], values[3]); [EOL] }
public LocalDateTime(Object instant, Chronology chronology) { [EOL]     PartialConverter converter = ConverterManager.getInstance().getPartialConverter(instant); [EOL]     chronology = converter.getChronology(instant, chronology); [EOL]     chronology = DateTimeUtils.getChronology(chronology); [EOL]     iChronology = chronology.withUTC(); [EOL]     int[] values = converter.getPartialValues(this, instant, chronology, ISODateTimeFormat.localDateOptionalTimeParser()); [EOL]     iLocalMillis = iChronology.getDateTimeMillis(values[0], values[1], values[2], values[3]); [EOL] }
public LocalDateTime(Object instant, Chronology chronology) { [EOL]     PartialConverter converter = ConverterManager.getInstance().getPartialConverter(instant); [EOL]     chronology = converter.getChronology(instant, chronology); [EOL]     chronology = DateTimeUtils.getChronology(chronology); [EOL]     iChronology = chronology.withUTC(); [EOL]     int[] values = converter.getPartialValues(this, instant, chronology, ISODateTimeFormat.localDateOptionalTimeParser()); [EOL]     iLocalMillis = iChronology.getDateTimeMillis(values[0], values[1], values[2], values[3]); [EOL] }
public LocalDateTime(int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour) { [EOL]     this(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, 0, 0, ISOChronology.getInstanceUTC()); [EOL] }
public LocalDateTime(int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute) { [EOL]     this(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, 0, ISOChronology.getInstanceUTC()); [EOL] }
public int getValue(int index) { [EOL]     switch(index) { [EOL]         case YEAR: [EOL]             return getChronology().year().get(getLocalMillis()); [EOL]         case MONTH_OF_YEAR: [EOL]             return getChronology().monthOfYear().get(getLocalMillis()); [EOL]         case DAY_OF_MONTH: [EOL]             return getChronology().dayOfMonth().get(getLocalMillis()); [EOL]         case MILLIS_OF_DAY: [EOL]             return getChronology().millisOfDay().get(getLocalMillis()); [EOL]         default: [EOL]             throw new IndexOutOfBoundsException("Invalid index: " + index); [EOL]     } [EOL] }
public int getValue(int index) { [EOL]     switch(index) { [EOL]         case YEAR: [EOL]             return getChronology().year().get(getLocalMillis()); [EOL]         case MONTH_OF_YEAR: [EOL]             return getChronology().monthOfYear().get(getLocalMillis()); [EOL]         case DAY_OF_MONTH: [EOL]             return getChronology().dayOfMonth().get(getLocalMillis()); [EOL]         case MILLIS_OF_DAY: [EOL]             return getChronology().millisOfDay().get(getLocalMillis()); [EOL]         default: [EOL]             throw new IndexOutOfBoundsException("Invalid index: " + index); [EOL]     } [EOL] }
public int getValue(int index) { [EOL]     switch(index) { [EOL]         case YEAR: [EOL]             return getChronology().year().get(getLocalMillis()); [EOL]         case MONTH_OF_YEAR: [EOL]             return getChronology().monthOfYear().get(getLocalMillis()); [EOL]         case DAY_OF_MONTH: [EOL]             return getChronology().dayOfMonth().get(getLocalMillis()); [EOL]         case MILLIS_OF_DAY: [EOL]             return getChronology().millisOfDay().get(getLocalMillis()); [EOL]         default: [EOL]             throw new IndexOutOfBoundsException("Invalid index: " + index); [EOL]     } [EOL] }
public int getValue(int index) { [EOL]     switch(index) { [EOL]         case YEAR: [EOL]             return getChronology().year().get(getLocalMillis()); [EOL]         case MONTH_OF_YEAR: [EOL]             return getChronology().monthOfYear().get(getLocalMillis()); [EOL]         case DAY_OF_MONTH: [EOL]             return getChronology().dayOfMonth().get(getLocalMillis()); [EOL]         case MILLIS_OF_DAY: [EOL]             return getChronology().millisOfDay().get(getLocalMillis()); [EOL]         default: [EOL]             throw new IndexOutOfBoundsException("Invalid index: " + index); [EOL]     } [EOL] }
public int getValue(int index) { [EOL]     switch(index) { [EOL]         case YEAR: [EOL]             return getChronology().year().get(getLocalMillis()); [EOL]         case MONTH_OF_YEAR: [EOL]             return getChronology().monthOfYear().get(getLocalMillis()); [EOL]         case DAY_OF_MONTH: [EOL]             return getChronology().dayOfMonth().get(getLocalMillis()); [EOL]         case MILLIS_OF_DAY: [EOL]             return getChronology().millisOfDay().get(getLocalMillis()); [EOL]         default: [EOL]             throw new IndexOutOfBoundsException("Invalid index: " + index); [EOL]     } [EOL] }
public int get(DateTimeFieldType type) { [EOL]     if (type == null) { [EOL]         throw new IllegalArgumentException("The DateTimeFieldType must not be null"); [EOL]     } [EOL]     return type.getField(getChronology()).get(getLocalMillis()); [EOL] }
public boolean isSupported(DurationFieldType type) { [EOL]     if (type == null) { [EOL]         return false; [EOL]     } [EOL]     return type.getField(getChronology()).isSupported(); [EOL] }
public boolean isSupported(DurationFieldType type) { [EOL]     if (type == null) { [EOL]         return false; [EOL]     } [EOL]     return type.getField(getChronology()).isSupported(); [EOL] }
public boolean isSupported(DurationFieldType type) { [EOL]     if (type == null) { [EOL]         return false; [EOL]     } [EOL]     return type.getField(getChronology()).isSupported(); [EOL] }
public DateTime toDateTime(DateTimeZone zone) { [EOL]     zone = DateTimeUtils.getZone(zone); [EOL]     Chronology chrono = iChronology.withZone(zone); [EOL]     return new DateTime(getYear(), getMonthOfYear(), getDayOfMonth(), getHourOfDay(), getMinuteOfHour(), getSecondOfMinute(), getMillisOfSecond(), chrono); [EOL] }
public DateTime toDateTime(DateTimeZone zone) { [EOL]     zone = DateTimeUtils.getZone(zone); [EOL]     Chronology chrono = iChronology.withZone(zone); [EOL]     return new DateTime(getYear(), getMonthOfYear(), getDayOfMonth(), getHourOfDay(), getMinuteOfHour(), getSecondOfMinute(), getMillisOfSecond(), chrono); [EOL] }
public LocalDateTime plus(ReadablePeriod period) { [EOL]     return withPeriodAdded(period, 1); [EOL] }
public LocalDateTime plus(ReadablePeriod period) { [EOL]     return withPeriodAdded(period, 1); [EOL] }
public LocalDateTime plusDays(int days) { [EOL]     if (days == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().days().add(getLocalMillis(), days); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalDateTime plusDays(int days) { [EOL]     if (days == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().days().add(getLocalMillis(), days); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalDateTime plusDays(int days) { [EOL]     if (days == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().days().add(getLocalMillis(), days); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalDateTime minusYears(int years) { [EOL]     if (years == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().years().subtract(getLocalMillis(), years); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalDateTime minusYears(int years) { [EOL]     if (years == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().years().subtract(getLocalMillis(), years); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalDateTime minusYears(int years) { [EOL]     if (years == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().years().subtract(getLocalMillis(), years); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalDateTime minusMinutes(int minutes) { [EOL]     if (minutes == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().minutes().subtract(getLocalMillis(), minutes); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalDateTime minusMinutes(int minutes) { [EOL]     if (minutes == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().minutes().subtract(getLocalMillis(), minutes); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalDateTime minusMinutes(int minutes) { [EOL]     if (minutes == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().minutes().subtract(getLocalMillis(), minutes); [EOL]     return withLocalMillis(instant); [EOL] }
public int getEra() { [EOL]     return getChronology().era().get(getLocalMillis()); [EOL] }
public int getCenturyOfEra() { [EOL]     return getChronology().centuryOfEra().get(getLocalMillis()); [EOL] }
public int getYearOfEra() { [EOL]     return getChronology().yearOfEra().get(getLocalMillis()); [EOL] }
public int getYearOfCentury() { [EOL]     return getChronology().yearOfCentury().get(getLocalMillis()); [EOL] }
public int getWeekyear() { [EOL]     return getChronology().weekyear().get(getLocalMillis()); [EOL] }
public int getWeekOfWeekyear() { [EOL]     return getChronology().weekOfWeekyear().get(getLocalMillis()); [EOL] }
public int getDayOfYear() { [EOL]     return getChronology().dayOfYear().get(getLocalMillis()); [EOL] }
public int getDayOfWeek() { [EOL]     return getChronology().dayOfWeek().get(getLocalMillis()); [EOL] }
public int getMillisOfDay() { [EOL]     return getChronology().millisOfDay().get(getLocalMillis()); [EOL] }
public LocalDateTime withEra(int era) { [EOL]     return withLocalMillis(getChronology().era().set(getLocalMillis(), era)); [EOL] }
public LocalDateTime withEra(int era) { [EOL]     return withLocalMillis(getChronology().era().set(getLocalMillis(), era)); [EOL] }
public LocalDateTime withCenturyOfEra(int centuryOfEra) { [EOL]     return withLocalMillis(getChronology().centuryOfEra().set(getLocalMillis(), centuryOfEra)); [EOL] }
public LocalDateTime withCenturyOfEra(int centuryOfEra) { [EOL]     return withLocalMillis(getChronology().centuryOfEra().set(getLocalMillis(), centuryOfEra)); [EOL] }
public LocalDateTime withCenturyOfEra(int centuryOfEra) { [EOL]     return withLocalMillis(getChronology().centuryOfEra().set(getLocalMillis(), centuryOfEra)); [EOL] }
public LocalDateTime withYearOfEra(int yearOfEra) { [EOL]     return withLocalMillis(getChronology().yearOfEra().set(getLocalMillis(), yearOfEra)); [EOL] }
public LocalDateTime withYearOfEra(int yearOfEra) { [EOL]     return withLocalMillis(getChronology().yearOfEra().set(getLocalMillis(), yearOfEra)); [EOL] }
public LocalDateTime withYearOfCentury(int yearOfCentury) { [EOL]     return withLocalMillis(getChronology().yearOfCentury().set(getLocalMillis(), yearOfCentury)); [EOL] }
public LocalDateTime withYearOfCentury(int yearOfCentury) { [EOL]     return withLocalMillis(getChronology().yearOfCentury().set(getLocalMillis(), yearOfCentury)); [EOL] }
public LocalDateTime withYear(int year) { [EOL]     return withLocalMillis(getChronology().year().set(getLocalMillis(), year)); [EOL] }
public LocalDateTime withYear(int year) { [EOL]     return withLocalMillis(getChronology().year().set(getLocalMillis(), year)); [EOL] }
public LocalDateTime withWeekyear(int weekyear) { [EOL]     return withLocalMillis(getChronology().weekyear().set(getLocalMillis(), weekyear)); [EOL] }
public LocalDateTime withWeekyear(int weekyear) { [EOL]     return withLocalMillis(getChronology().weekyear().set(getLocalMillis(), weekyear)); [EOL] }
public LocalDateTime withWeekyear(int weekyear) { [EOL]     return withLocalMillis(getChronology().weekyear().set(getLocalMillis(), weekyear)); [EOL] }
public LocalDateTime withMonthOfYear(int monthOfYear) { [EOL]     return withLocalMillis(getChronology().monthOfYear().set(getLocalMillis(), monthOfYear)); [EOL] }
public LocalDateTime withMonthOfYear(int monthOfYear) { [EOL]     return withLocalMillis(getChronology().monthOfYear().set(getLocalMillis(), monthOfYear)); [EOL] }
public LocalDateTime withMonthOfYear(int monthOfYear) { [EOL]     return withLocalMillis(getChronology().monthOfYear().set(getLocalMillis(), monthOfYear)); [EOL] }
public LocalDateTime withWeekOfWeekyear(int weekOfWeekyear) { [EOL]     return withLocalMillis(getChronology().weekOfWeekyear().set(getLocalMillis(), weekOfWeekyear)); [EOL] }
public LocalDateTime withWeekOfWeekyear(int weekOfWeekyear) { [EOL]     return withLocalMillis(getChronology().weekOfWeekyear().set(getLocalMillis(), weekOfWeekyear)); [EOL] }
public LocalDateTime withWeekOfWeekyear(int weekOfWeekyear) { [EOL]     return withLocalMillis(getChronology().weekOfWeekyear().set(getLocalMillis(), weekOfWeekyear)); [EOL] }
public LocalDateTime withDayOfYear(int dayOfYear) { [EOL]     return withLocalMillis(getChronology().dayOfYear().set(getLocalMillis(), dayOfYear)); [EOL] }
public LocalDateTime withDayOfYear(int dayOfYear) { [EOL]     return withLocalMillis(getChronology().dayOfYear().set(getLocalMillis(), dayOfYear)); [EOL] }
public LocalDateTime withDayOfYear(int dayOfYear) { [EOL]     return withLocalMillis(getChronology().dayOfYear().set(getLocalMillis(), dayOfYear)); [EOL] }
public LocalDateTime withDayOfMonth(int dayOfMonth) { [EOL]     return withLocalMillis(getChronology().dayOfMonth().set(getLocalMillis(), dayOfMonth)); [EOL] }
public LocalDateTime withDayOfMonth(int dayOfMonth) { [EOL]     return withLocalMillis(getChronology().dayOfMonth().set(getLocalMillis(), dayOfMonth)); [EOL] }
public LocalDateTime withDayOfWeek(int dayOfWeek) { [EOL]     return withLocalMillis(getChronology().dayOfWeek().set(getLocalMillis(), dayOfWeek)); [EOL] }
public LocalDateTime withDayOfWeek(int dayOfWeek) { [EOL]     return withLocalMillis(getChronology().dayOfWeek().set(getLocalMillis(), dayOfWeek)); [EOL] }
public LocalDateTime withDayOfWeek(int dayOfWeek) { [EOL]     return withLocalMillis(getChronology().dayOfWeek().set(getLocalMillis(), dayOfWeek)); [EOL] }
public LocalDateTime withHourOfDay(int hour) { [EOL]     return withLocalMillis(getChronology().hourOfDay().set(getLocalMillis(), hour)); [EOL] }
public LocalDateTime withHourOfDay(int hour) { [EOL]     return withLocalMillis(getChronology().hourOfDay().set(getLocalMillis(), hour)); [EOL] }
public LocalDateTime withHourOfDay(int hour) { [EOL]     return withLocalMillis(getChronology().hourOfDay().set(getLocalMillis(), hour)); [EOL] }
public LocalDateTime withMinuteOfHour(int minute) { [EOL]     return withLocalMillis(getChronology().minuteOfHour().set(getLocalMillis(), minute)); [EOL] }
public LocalDateTime withMinuteOfHour(int minute) { [EOL]     return withLocalMillis(getChronology().minuteOfHour().set(getLocalMillis(), minute)); [EOL] }
public LocalDateTime withMinuteOfHour(int minute) { [EOL]     return withLocalMillis(getChronology().minuteOfHour().set(getLocalMillis(), minute)); [EOL] }
public LocalDateTime withSecondOfMinute(int second) { [EOL]     return withLocalMillis(getChronology().secondOfMinute().set(getLocalMillis(), second)); [EOL] }
public LocalDateTime withMillisOfSecond(int millis) { [EOL]     return withLocalMillis(getChronology().millisOfSecond().set(getLocalMillis(), millis)); [EOL] }
public LocalDateTime withMillisOfSecond(int millis) { [EOL]     return withLocalMillis(getChronology().millisOfSecond().set(getLocalMillis(), millis)); [EOL] }
public LocalDateTime withMillisOfSecond(int millis) { [EOL]     return withLocalMillis(getChronology().millisOfSecond().set(getLocalMillis(), millis)); [EOL] }
public LocalDateTime withMillisOfDay(int millis) { [EOL]     return withLocalMillis(getChronology().millisOfDay().set(getLocalMillis(), millis)); [EOL] }
public LocalDateTime withMillisOfDay(int millis) { [EOL]     return withLocalMillis(getChronology().millisOfDay().set(getLocalMillis(), millis)); [EOL] }
public LocalDateTime withMillisOfDay(int millis) { [EOL]     return withLocalMillis(getChronology().millisOfDay().set(getLocalMillis(), millis)); [EOL] }
public Property hourOfDay() { [EOL]     return new Property(this, getChronology().hourOfDay()); [EOL] }
public String toString(String pattern, Locale locale) throws IllegalArgumentException { [EOL]     if (pattern == null) { [EOL]         return toString(); [EOL]     } [EOL]     return DateTimeFormat.forPattern(pattern).withLocale(locale).print(this); [EOL] }
public String toString(String pattern, Locale locale) throws IllegalArgumentException { [EOL]     if (pattern == null) { [EOL]         return toString(); [EOL]     } [EOL]     return DateTimeFormat.forPattern(pattern).withLocale(locale).print(this); [EOL] }
public DateTimeField getField() { [EOL]     return iField; [EOL] }
protected long getMillis() { [EOL]     return iInstant.getLocalMillis(); [EOL] }
protected Chronology getChronology() { [EOL]     return iInstant.getChronology(); [EOL] }
public LocalDateTime setCopy(int value) { [EOL]     return iInstant.withLocalMillis(iField.set(iInstant.getLocalMillis(), value)); [EOL] }
public LocalDateTime setCopy(int value) { [EOL]     return iInstant.withLocalMillis(iField.set(iInstant.getLocalMillis(), value)); [EOL] }
public LocalDateTime withMaximumValue() { [EOL]     return setCopy(getMaximumValue()); [EOL] }
public LocalDateTime withMinimumValue() { [EOL]     return setCopy(getMinimumValue()); [EOL] }
public Chronology getChronology(Object object, Chronology chrono) { [EOL]     if (chrono != null) { [EOL]         return chrono; [EOL]     } [EOL]     Calendar cal = (Calendar) object; [EOL]     DateTimeZone zone = null; [EOL]     try { [EOL]         zone = DateTimeZone.forTimeZone(cal.getTimeZone()); [EOL]     } catch (IllegalArgumentException ex) { [EOL]         zone = DateTimeZone.getDefault(); [EOL]     } [EOL]     return getChronology(cal, zone); [EOL] }
public Chronology getChronology(Object object, Chronology chrono) { [EOL]     if (chrono != null) { [EOL]         return chrono; [EOL]     } [EOL]     Calendar cal = (Calendar) object; [EOL]     DateTimeZone zone = null; [EOL]     try { [EOL]         zone = DateTimeZone.forTimeZone(cal.getTimeZone()); [EOL]     } catch (IllegalArgumentException ex) { [EOL]         zone = DateTimeZone.getDefault(); [EOL]     } [EOL]     return getChronology(cal, zone); [EOL] }
public Chronology getChronology(Object object, Chronology chrono) { [EOL]     if (chrono != null) { [EOL]         return chrono; [EOL]     } [EOL]     Calendar cal = (Calendar) object; [EOL]     DateTimeZone zone = null; [EOL]     try { [EOL]         zone = DateTimeZone.forTimeZone(cal.getTimeZone()); [EOL]     } catch (IllegalArgumentException ex) { [EOL]         zone = DateTimeZone.getDefault(); [EOL]     } [EOL]     return getChronology(cal, zone); [EOL] }
public Chronology getChronology(Object object, DateTimeZone zone) { [EOL]     if (object.getClass().getName().endsWith(".BuddhistCalendar")) { [EOL]         return BuddhistChronology.getInstance(zone); [EOL]     } else if (object instanceof GregorianCalendar) { [EOL]         GregorianCalendar gc = (GregorianCalendar) object; [EOL]         long cutover = gc.getGregorianChange().getTime(); [EOL]         if (cutover == Long.MIN_VALUE) { [EOL]             return GregorianChronology.getInstance(zone); [EOL]         } else if (cutover == Long.MAX_VALUE) { [EOL]             return JulianChronology.getInstance(zone); [EOL]         } else { [EOL]             return GJChronology.getInstance(zone, cutover, 4); [EOL]         } [EOL]     } else { [EOL]         return ISOChronology.getInstance(zone); [EOL]     } [EOL] }
public Chronology getChronology(Object object, DateTimeZone zone) { [EOL]     if (object.getClass().getName().endsWith(".BuddhistCalendar")) { [EOL]         return BuddhistChronology.getInstance(zone); [EOL]     } else if (object instanceof GregorianCalendar) { [EOL]         GregorianCalendar gc = (GregorianCalendar) object; [EOL]         long cutover = gc.getGregorianChange().getTime(); [EOL]         if (cutover == Long.MIN_VALUE) { [EOL]             return GregorianChronology.getInstance(zone); [EOL]         } else if (cutover == Long.MAX_VALUE) { [EOL]             return JulianChronology.getInstance(zone); [EOL]         } else { [EOL]             return GJChronology.getInstance(zone, cutover, 4); [EOL]         } [EOL]     } else { [EOL]         return ISOChronology.getInstance(zone); [EOL]     } [EOL] }
public Chronology getChronology(Object object, DateTimeZone zone) { [EOL]     if (object.getClass().getName().endsWith(".BuddhistCalendar")) { [EOL]         return BuddhistChronology.getInstance(zone); [EOL]     } else if (object instanceof GregorianCalendar) { [EOL]         GregorianCalendar gc = (GregorianCalendar) object; [EOL]         long cutover = gc.getGregorianChange().getTime(); [EOL]         if (cutover == Long.MIN_VALUE) { [EOL]             return GregorianChronology.getInstance(zone); [EOL]         } else if (cutover == Long.MAX_VALUE) { [EOL]             return JulianChronology.getInstance(zone); [EOL]         } else { [EOL]             return GJChronology.getInstance(zone, cutover, 4); [EOL]         } [EOL]     } else { [EOL]         return ISOChronology.getInstance(zone); [EOL]     } [EOL] }
public Chronology getChronology(Object object, DateTimeZone zone) { [EOL]     if (object.getClass().getName().endsWith(".BuddhistCalendar")) { [EOL]         return BuddhistChronology.getInstance(zone); [EOL]     } else if (object instanceof GregorianCalendar) { [EOL]         GregorianCalendar gc = (GregorianCalendar) object; [EOL]         long cutover = gc.getGregorianChange().getTime(); [EOL]         if (cutover == Long.MIN_VALUE) { [EOL]             return GregorianChronology.getInstance(zone); [EOL]         } else if (cutover == Long.MAX_VALUE) { [EOL]             return JulianChronology.getInstance(zone); [EOL]         } else { [EOL]             return GJChronology.getInstance(zone, cutover, 4); [EOL]         } [EOL]     } else { [EOL]         return ISOChronology.getInstance(zone); [EOL]     } [EOL] }
public Chronology getChronology(Object object, DateTimeZone zone) { [EOL]     if (object.getClass().getName().endsWith(".BuddhistCalendar")) { [EOL]         return BuddhistChronology.getInstance(zone); [EOL]     } else if (object instanceof GregorianCalendar) { [EOL]         GregorianCalendar gc = (GregorianCalendar) object; [EOL]         long cutover = gc.getGregorianChange().getTime(); [EOL]         if (cutover == Long.MIN_VALUE) { [EOL]             return GregorianChronology.getInstance(zone); [EOL]         } else if (cutover == Long.MAX_VALUE) { [EOL]             return JulianChronology.getInstance(zone); [EOL]         } else { [EOL]             return GJChronology.getInstance(zone, cutover, 4); [EOL]         } [EOL]     } else { [EOL]         return ISOChronology.getInstance(zone); [EOL]     } [EOL] }
public long getInstantMillis(Object object, Chronology chrono) { [EOL]     Calendar calendar = (Calendar) object; [EOL]     return calendar.getTime().getTime(); [EOL] }
public long getInstantMillis(Object object, Chronology chrono) { [EOL]     Calendar calendar = (Calendar) object; [EOL]     return calendar.getTime().getTime(); [EOL] }
public final DurationField getWrappedField() { [EOL]     return iField; [EOL] }
public boolean isPrecise() { [EOL]     return iField.isPrecise(); [EOL] }
public boolean isPrecise() { [EOL]     return iField.isPrecise(); [EOL] }
public DateTimeFormatter withZone(DateTimeZone zone) { [EOL]     if (iZone == zone) { [EOL]         return this; [EOL]     } [EOL]     return new DateTimeFormatter(iPrinter, iParser, iLocale, false, iChrono, zone, iPivotYear, iDefaultYear); [EOL] }
public DateTimeFormatter withZone(DateTimeZone zone) { [EOL]     if (iZone == zone) { [EOL]         return this; [EOL]     } [EOL]     return new DateTimeFormatter(iPrinter, iParser, iLocale, false, iChrono, zone, iPivotYear, iDefaultYear); [EOL] }
public int parseInto(ReadWritableInstant instant, String text, int position) { [EOL]     DateTimeParser parser = requireParser(); [EOL]     if (instant == null) { [EOL]         throw new IllegalArgumentException("Instant must not be null"); [EOL]     } [EOL]     long instantMillis = instant.getMillis(); [EOL]     Chronology chrono = instant.getChronology(); [EOL]     int defaultYear = DateTimeUtils.getChronology(chrono).year().get(instantMillis); [EOL]     long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis); [EOL]     chrono = selectChronology(chrono); [EOL]     DateTimeParserBucket bucket = new DateTimeParserBucket(instantLocal, chrono, iLocale, iPivotYear, defaultYear); [EOL]     int newPos = parser.parseInto(bucket, text, position); [EOL]     instant.setMillis(bucket.computeMillis(false, text)); [EOL]     if (iOffsetParsed && bucket.getOffsetInteger() != null) { [EOL]         int parsedOffset = bucket.getOffsetInteger(); [EOL]         DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset); [EOL]         chrono = chrono.withZone(parsedZone); [EOL]     } else if (bucket.getZone() != null) { [EOL]         chrono = chrono.withZone(bucket.getZone()); [EOL]     } [EOL]     instant.setChronology(chrono); [EOL]     if (iZone != null) { [EOL]         instant.setZone(iZone); [EOL]     } [EOL]     return newPos; [EOL] }
public int parseInto(ReadWritableInstant instant, String text, int position) { [EOL]     DateTimeParser parser = requireParser(); [EOL]     if (instant == null) { [EOL]         throw new IllegalArgumentException("Instant must not be null"); [EOL]     } [EOL]     long instantMillis = instant.getMillis(); [EOL]     Chronology chrono = instant.getChronology(); [EOL]     int defaultYear = DateTimeUtils.getChronology(chrono).year().get(instantMillis); [EOL]     long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis); [EOL]     chrono = selectChronology(chrono); [EOL]     DateTimeParserBucket bucket = new DateTimeParserBucket(instantLocal, chrono, iLocale, iPivotYear, defaultYear); [EOL]     int newPos = parser.parseInto(bucket, text, position); [EOL]     instant.setMillis(bucket.computeMillis(false, text)); [EOL]     if (iOffsetParsed && bucket.getOffsetInteger() != null) { [EOL]         int parsedOffset = bucket.getOffsetInteger(); [EOL]         DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset); [EOL]         chrono = chrono.withZone(parsedZone); [EOL]     } else if (bucket.getZone() != null) { [EOL]         chrono = chrono.withZone(bucket.getZone()); [EOL]     } [EOL]     instant.setChronology(chrono); [EOL]     if (iZone != null) { [EOL]         instant.setZone(iZone); [EOL]     } [EOL]     return newPos; [EOL] }
public int parseInto(ReadWritableInstant instant, String text, int position) { [EOL]     DateTimeParser parser = requireParser(); [EOL]     if (instant == null) { [EOL]         throw new IllegalArgumentException("Instant must not be null"); [EOL]     } [EOL]     long instantMillis = instant.getMillis(); [EOL]     Chronology chrono = instant.getChronology(); [EOL]     int defaultYear = DateTimeUtils.getChronology(chrono).year().get(instantMillis); [EOL]     long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis); [EOL]     chrono = selectChronology(chrono); [EOL]     DateTimeParserBucket bucket = new DateTimeParserBucket(instantLocal, chrono, iLocale, iPivotYear, defaultYear); [EOL]     int newPos = parser.parseInto(bucket, text, position); [EOL]     instant.setMillis(bucket.computeMillis(false, text)); [EOL]     if (iOffsetParsed && bucket.getOffsetInteger() != null) { [EOL]         int parsedOffset = bucket.getOffsetInteger(); [EOL]         DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset); [EOL]         chrono = chrono.withZone(parsedZone); [EOL]     } else if (bucket.getZone() != null) { [EOL]         chrono = chrono.withZone(bucket.getZone()); [EOL]     } [EOL]     instant.setChronology(chrono); [EOL]     if (iZone != null) { [EOL]         instant.setZone(iZone); [EOL]     } [EOL]     return newPos; [EOL] }
public int parseInto(ReadWritableInstant instant, String text, int position) { [EOL]     DateTimeParser parser = requireParser(); [EOL]     if (instant == null) { [EOL]         throw new IllegalArgumentException("Instant must not be null"); [EOL]     } [EOL]     long instantMillis = instant.getMillis(); [EOL]     Chronology chrono = instant.getChronology(); [EOL]     int defaultYear = DateTimeUtils.getChronology(chrono).year().get(instantMillis); [EOL]     long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis); [EOL]     chrono = selectChronology(chrono); [EOL]     DateTimeParserBucket bucket = new DateTimeParserBucket(instantLocal, chrono, iLocale, iPivotYear, defaultYear); [EOL]     int newPos = parser.parseInto(bucket, text, position); [EOL]     instant.setMillis(bucket.computeMillis(false, text)); [EOL]     if (iOffsetParsed && bucket.getOffsetInteger() != null) { [EOL]         int parsedOffset = bucket.getOffsetInteger(); [EOL]         DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset); [EOL]         chrono = chrono.withZone(parsedZone); [EOL]     } else if (bucket.getZone() != null) { [EOL]         chrono = chrono.withZone(bucket.getZone()); [EOL]     } [EOL]     instant.setChronology(chrono); [EOL]     if (iZone != null) { [EOL]         instant.setZone(iZone); [EOL]     } [EOL]     return newPos; [EOL] }
public LocalDateTime parseLocalDateTime(String text) { [EOL]     DateTimeParser parser = requireParser(); [EOL]     Chronology chrono = selectChronology(null).withUTC(); [EOL]     DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear); [EOL]     int newPos = parser.parseInto(bucket, text, 0); [EOL]     if (newPos >= 0) { [EOL]         if (newPos >= text.length()) { [EOL]             long millis = bucket.computeMillis(true, text); [EOL]             if (bucket.getOffsetInteger() != null) { [EOL]                 int parsedOffset = bucket.getOffsetInteger(); [EOL]                 DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset); [EOL]                 chrono = chrono.withZone(parsedZone); [EOL]             } else if (bucket.getZone() != null) { [EOL]                 chrono = chrono.withZone(bucket.getZone()); [EOL]             } [EOL]             return new LocalDateTime(millis, chrono); [EOL]         } [EOL]     } else { [EOL]         newPos = ~newPos; [EOL]     } [EOL]     throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos)); [EOL] }
public LocalDateTime parseLocalDateTime(String text) { [EOL]     DateTimeParser parser = requireParser(); [EOL]     Chronology chrono = selectChronology(null).withUTC(); [EOL]     DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear); [EOL]     int newPos = parser.parseInto(bucket, text, 0); [EOL]     if (newPos >= 0) { [EOL]         if (newPos >= text.length()) { [EOL]             long millis = bucket.computeMillis(true, text); [EOL]             if (bucket.getOffsetInteger() != null) { [EOL]                 int parsedOffset = bucket.getOffsetInteger(); [EOL]                 DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset); [EOL]                 chrono = chrono.withZone(parsedZone); [EOL]             } else if (bucket.getZone() != null) { [EOL]                 chrono = chrono.withZone(bucket.getZone()); [EOL]             } [EOL]             return new LocalDateTime(millis, chrono); [EOL]         } [EOL]     } else { [EOL]         newPos = ~newPos; [EOL]     } [EOL]     throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos)); [EOL] }
public LocalDateTime parseLocalDateTime(String text) { [EOL]     DateTimeParser parser = requireParser(); [EOL]     Chronology chrono = selectChronology(null).withUTC(); [EOL]     DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear); [EOL]     int newPos = parser.parseInto(bucket, text, 0); [EOL]     if (newPos >= 0) { [EOL]         if (newPos >= text.length()) { [EOL]             long millis = bucket.computeMillis(true, text); [EOL]             if (bucket.getOffsetInteger() != null) { [EOL]                 int parsedOffset = bucket.getOffsetInteger(); [EOL]                 DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset); [EOL]                 chrono = chrono.withZone(parsedZone); [EOL]             } else if (bucket.getZone() != null) { [EOL]                 chrono = chrono.withZone(bucket.getZone()); [EOL]             } [EOL]             return new LocalDateTime(millis, chrono); [EOL]         } [EOL]     } else { [EOL]         newPos = ~newPos; [EOL]     } [EOL]     throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos)); [EOL] }
public LocalDateTime parseLocalDateTime(String text) { [EOL]     DateTimeParser parser = requireParser(); [EOL]     Chronology chrono = selectChronology(null).withUTC(); [EOL]     DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear); [EOL]     int newPos = parser.parseInto(bucket, text, 0); [EOL]     if (newPos >= 0) { [EOL]         if (newPos >= text.length()) { [EOL]             long millis = bucket.computeMillis(true, text); [EOL]             if (bucket.getOffsetInteger() != null) { [EOL]                 int parsedOffset = bucket.getOffsetInteger(); [EOL]                 DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset); [EOL]                 chrono = chrono.withZone(parsedZone); [EOL]             } else if (bucket.getZone() != null) { [EOL]                 chrono = chrono.withZone(bucket.getZone()); [EOL]             } [EOL]             return new LocalDateTime(millis, chrono); [EOL]         } [EOL]     } else { [EOL]         newPos = ~newPos; [EOL]     } [EOL]     throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos)); [EOL] }
public void validate(ReadablePartial partial, int[] values) { [EOL]     int size = partial.size(); [EOL]     for (int i = 0; i < size; i++) { [EOL]         int value = values[i]; [EOL]         DateTimeField field = partial.getField(i); [EOL]         if (value < field.getMinimumValue()) { [EOL]             throw new IllegalFieldValueException(field.getType(), Integer.valueOf(value), Integer.valueOf(field.getMinimumValue()), null); [EOL]         } [EOL]         if (value > field.getMaximumValue()) { [EOL]             throw new IllegalFieldValueException(field.getType(), Integer.valueOf(value), null, Integer.valueOf(field.getMaximumValue())); [EOL]         } [EOL]     } [EOL]     for (int i = 0; i < size; i++) { [EOL]         int value = values[i]; [EOL]         DateTimeField field = partial.getField(i); [EOL]         if (value < field.getMinimumValue(partial, values)) { [EOL]             throw new IllegalFieldValueException(field.getType(), Integer.valueOf(value), Integer.valueOf(field.getMinimumValue(partial, values)), null); [EOL]         } [EOL]         if (value > field.getMaximumValue(partial, values)) { [EOL]             throw new IllegalFieldValueException(field.getType(), Integer.valueOf(value), null, Integer.valueOf(field.getMaximumValue(partial, values))); [EOL]         } [EOL]     } [EOL] }
public void validate(ReadablePartial partial, int[] values) { [EOL]     int size = partial.size(); [EOL]     for (int i = 0; i < size; i++) { [EOL]         int value = values[i]; [EOL]         DateTimeField field = partial.getField(i); [EOL]         if (value < field.getMinimumValue()) { [EOL]             throw new IllegalFieldValueException(field.getType(), Integer.valueOf(value), Integer.valueOf(field.getMinimumValue()), null); [EOL]         } [EOL]         if (value > field.getMaximumValue()) { [EOL]             throw new IllegalFieldValueException(field.getType(), Integer.valueOf(value), null, Integer.valueOf(field.getMaximumValue())); [EOL]         } [EOL]     } [EOL]     for (int i = 0; i < size; i++) { [EOL]         int value = values[i]; [EOL]         DateTimeField field = partial.getField(i); [EOL]         if (value < field.getMinimumValue(partial, values)) { [EOL]             throw new IllegalFieldValueException(field.getType(), Integer.valueOf(value), Integer.valueOf(field.getMinimumValue(partial, values)), null); [EOL]         } [EOL]         if (value > field.getMaximumValue(partial, values)) { [EOL]             throw new IllegalFieldValueException(field.getType(), Integer.valueOf(value), null, Integer.valueOf(field.getMaximumValue(partial, values))); [EOL]         } [EOL]     } [EOL] }
public void validate(ReadablePartial partial, int[] values) { [EOL]     int size = partial.size(); [EOL]     for (int i = 0; i < size; i++) { [EOL]         int value = values[i]; [EOL]         DateTimeField field = partial.getField(i); [EOL]         if (value < field.getMinimumValue()) { [EOL]             throw new IllegalFieldValueException(field.getType(), Integer.valueOf(value), Integer.valueOf(field.getMinimumValue()), null); [EOL]         } [EOL]         if (value > field.getMaximumValue()) { [EOL]             throw new IllegalFieldValueException(field.getType(), Integer.valueOf(value), null, Integer.valueOf(field.getMaximumValue())); [EOL]         } [EOL]     } [EOL]     for (int i = 0; i < size; i++) { [EOL]         int value = values[i]; [EOL]         DateTimeField field = partial.getField(i); [EOL]         if (value < field.getMinimumValue(partial, values)) { [EOL]             throw new IllegalFieldValueException(field.getType(), Integer.valueOf(value), Integer.valueOf(field.getMinimumValue(partial, values)), null); [EOL]         } [EOL]         if (value > field.getMaximumValue(partial, values)) { [EOL]             throw new IllegalFieldValueException(field.getType(), Integer.valueOf(value), null, Integer.valueOf(field.getMaximumValue(partial, values))); [EOL]         } [EOL]     } [EOL] }
public void validate(ReadablePartial partial, int[] values) { [EOL]     int size = partial.size(); [EOL]     for (int i = 0; i < size; i++) { [EOL]         int value = values[i]; [EOL]         DateTimeField field = partial.getField(i); [EOL]         if (value < field.getMinimumValue()) { [EOL]             throw new IllegalFieldValueException(field.getType(), Integer.valueOf(value), Integer.valueOf(field.getMinimumValue()), null); [EOL]         } [EOL]         if (value > field.getMaximumValue()) { [EOL]             throw new IllegalFieldValueException(field.getType(), Integer.valueOf(value), null, Integer.valueOf(field.getMaximumValue())); [EOL]         } [EOL]     } [EOL]     for (int i = 0; i < size; i++) { [EOL]         int value = values[i]; [EOL]         DateTimeField field = partial.getField(i); [EOL]         if (value < field.getMinimumValue(partial, values)) { [EOL]             throw new IllegalFieldValueException(field.getType(), Integer.valueOf(value), Integer.valueOf(field.getMinimumValue(partial, values)), null); [EOL]         } [EOL]         if (value > field.getMaximumValue(partial, values)) { [EOL]             throw new IllegalFieldValueException(field.getType(), Integer.valueOf(value), null, Integer.valueOf(field.getMaximumValue(partial, values))); [EOL]         } [EOL]     } [EOL] }
public void validate(ReadablePartial partial, int[] values) { [EOL]     int size = partial.size(); [EOL]     for (int i = 0; i < size; i++) { [EOL]         int value = values[i]; [EOL]         DateTimeField field = partial.getField(i); [EOL]         if (value < field.getMinimumValue()) { [EOL]             throw new IllegalFieldValueException(field.getType(), Integer.valueOf(value), Integer.valueOf(field.getMinimumValue()), null); [EOL]         } [EOL]         if (value > field.getMaximumValue()) { [EOL]             throw new IllegalFieldValueException(field.getType(), Integer.valueOf(value), null, Integer.valueOf(field.getMaximumValue())); [EOL]         } [EOL]     } [EOL]     for (int i = 0; i < size; i++) { [EOL]         int value = values[i]; [EOL]         DateTimeField field = partial.getField(i); [EOL]         if (value < field.getMinimumValue(partial, values)) { [EOL]             throw new IllegalFieldValueException(field.getType(), Integer.valueOf(value), Integer.valueOf(field.getMinimumValue(partial, values)), null); [EOL]         } [EOL]         if (value > field.getMaximumValue(partial, values)) { [EOL]             throw new IllegalFieldValueException(field.getType(), Integer.valueOf(value), null, Integer.valueOf(field.getMaximumValue(partial, values))); [EOL]         } [EOL]     } [EOL] }
public void validate(ReadablePartial partial, int[] values) { [EOL]     int size = partial.size(); [EOL]     for (int i = 0; i < size; i++) { [EOL]         int value = values[i]; [EOL]         DateTimeField field = partial.getField(i); [EOL]         if (value < field.getMinimumValue()) { [EOL]             throw new IllegalFieldValueException(field.getType(), Integer.valueOf(value), Integer.valueOf(field.getMinimumValue()), null); [EOL]         } [EOL]         if (value > field.getMaximumValue()) { [EOL]             throw new IllegalFieldValueException(field.getType(), Integer.valueOf(value), null, Integer.valueOf(field.getMaximumValue())); [EOL]         } [EOL]     } [EOL]     for (int i = 0; i < size; i++) { [EOL]         int value = values[i]; [EOL]         DateTimeField field = partial.getField(i); [EOL]         if (value < field.getMinimumValue(partial, values)) { [EOL]             throw new IllegalFieldValueException(field.getType(), Integer.valueOf(value), Integer.valueOf(field.getMinimumValue(partial, values)), null); [EOL]         } [EOL]         if (value > field.getMaximumValue(partial, values)) { [EOL]             throw new IllegalFieldValueException(field.getType(), Integer.valueOf(value), null, Integer.valueOf(field.getMaximumValue(partial, values))); [EOL]         } [EOL]     } [EOL] }
public int[] get(ReadablePartial partial, long instant) { [EOL]     int size = partial.size(); [EOL]     int[] values = new int[size]; [EOL]     for (int i = 0; i < size; i++) { [EOL]         values[i] = partial.getFieldType(i).getField(this).get(instant); [EOL]     } [EOL]     return values; [EOL] }
public int[] get(ReadablePartial partial, long instant) { [EOL]     int size = partial.size(); [EOL]     int[] values = new int[size]; [EOL]     for (int i = 0; i < size; i++) { [EOL]         values[i] = partial.getFieldType(i).getField(this).get(instant); [EOL]     } [EOL]     return values; [EOL] }
public int[] get(ReadablePeriod period, long startInstant, long endInstant) { [EOL]     int size = period.size(); [EOL]     int[] values = new int[size]; [EOL]     if (startInstant != endInstant) { [EOL]         for (int i = 0; i < size; i++) { [EOL]             DurationField field = period.getFieldType(i).getField(this); [EOL]             int value = field.getDifference(endInstant, startInstant); [EOL]             startInstant = field.add(startInstant, value); [EOL]             values[i] = value; [EOL]         } [EOL]     } [EOL]     return values; [EOL] }
public DurationFieldType getType() { [EOL]     return DurationFieldType.millis(); [EOL] }
public long getValueAsLong(long duration) { [EOL]     return duration; [EOL] }
public int getDifference(long minuendInstant, long subtrahendInstant) { [EOL]     return FieldUtils.safeToInt(FieldUtils.safeSubtract(minuendInstant, subtrahendInstant)); [EOL] }
public int getDifference(long minuendInstant, long subtrahendInstant) { [EOL]     return FieldUtils.safeToInt(FieldUtils.safeSubtract(minuendInstant, subtrahendInstant)); [EOL] }
public int getDifference(long minuendInstant, long subtrahendInstant) { [EOL]     return FieldUtils.safeToInt(FieldUtils.safeSubtract(minuendInstant, subtrahendInstant)); [EOL] }
public int getDifference(long minuendInstant, long subtrahendInstant) { [EOL]     return FieldUtils.safeToInt(FieldUtils.safeSubtract(minuendInstant, subtrahendInstant)); [EOL] }
public int getDifference(long minuendInstant, long subtrahendInstant) { [EOL]     return FieldUtils.safeToInt(FieldUtils.safeSubtract(minuendInstant, subtrahendInstant)); [EOL] }
public boolean equals(Object obj) { [EOL]     if (obj instanceof MillisDurationField) { [EOL]         return getUnitMillis() == ((MillisDurationField) obj).getUnitMillis(); [EOL]     } [EOL]     return false; [EOL] }
public boolean equals(Object obj) { [EOL]     if (obj instanceof MillisDurationField) { [EOL]         return getUnitMillis() == ((MillisDurationField) obj).getUnitMillis(); [EOL]     } [EOL]     return false; [EOL] }
public boolean equals(Object obj) { [EOL]     if (obj instanceof MillisDurationField) { [EOL]         return getUnitMillis() == ((MillisDurationField) obj).getUnitMillis(); [EOL]     } [EOL]     return false; [EOL] }
private Object readResolve() { [EOL]     return INSTANCE; [EOL] }
public static DateTimeFieldType millisOfSecond() { [EOL]     return MILLIS_OF_SECOND_TYPE; [EOL] }
public static DateTimeFieldType millisOfDay() { [EOL]     return MILLIS_OF_DAY_TYPE; [EOL] }
public static DateTimeFieldType secondOfMinute() { [EOL]     return SECOND_OF_MINUTE_TYPE; [EOL] }
public static DateTimeFieldType secondOfDay() { [EOL]     return SECOND_OF_DAY_TYPE; [EOL] }
public static DateTimeFieldType minuteOfHour() { [EOL]     return MINUTE_OF_HOUR_TYPE; [EOL] }
public static DateTimeFieldType minuteOfDay() { [EOL]     return MINUTE_OF_DAY_TYPE; [EOL] }
public static DateTimeFieldType hourOfDay() { [EOL]     return HOUR_OF_DAY_TYPE; [EOL] }
public static DateTimeFieldType clockhourOfDay() { [EOL]     return CLOCKHOUR_OF_DAY_TYPE; [EOL] }
public static DateTimeFieldType hourOfHalfday() { [EOL]     return HOUR_OF_HALFDAY_TYPE; [EOL] }
public static DateTimeFieldType clockhourOfHalfday() { [EOL]     return CLOCKHOUR_OF_HALFDAY_TYPE; [EOL] }
public static DateTimeFieldType halfdayOfDay() { [EOL]     return HALFDAY_OF_DAY_TYPE; [EOL] }
public static DateTimeFieldType dayOfWeek() { [EOL]     return DAY_OF_WEEK_TYPE; [EOL] }
public static DateTimeFieldType dayOfMonth() { [EOL]     return DAY_OF_MONTH_TYPE; [EOL] }
public static DateTimeFieldType dayOfYear() { [EOL]     return DAY_OF_YEAR_TYPE; [EOL] }
public static DateTimeFieldType weekOfWeekyear() { [EOL]     return WEEK_OF_WEEKYEAR_TYPE; [EOL] }
public static DateTimeFieldType weekyear() { [EOL]     return WEEKYEAR_TYPE; [EOL] }
public static DateTimeFieldType monthOfYear() { [EOL]     return MONTH_OF_YEAR_TYPE; [EOL] }
public static DateTimeFieldType year() { [EOL]     return YEAR_TYPE; [EOL] }
public static DateTimeFieldType yearOfEra() { [EOL]     return YEAR_OF_ERA_TYPE; [EOL] }
public static DateTimeFieldType era() { [EOL]     return ERA_TYPE; [EOL] }
@Override [EOL] public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof StandardDateTimeFieldType) { [EOL]         return iOrdinal == ((StandardDateTimeFieldType) obj).iOrdinal; [EOL]     } [EOL]     return false; [EOL] }
@Override [EOL] public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof StandardDateTimeFieldType) { [EOL]         return iOrdinal == ((StandardDateTimeFieldType) obj).iOrdinal; [EOL]     } [EOL]     return false; [EOL] }
@Override [EOL] public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof StandardDateTimeFieldType) { [EOL]         return iOrdinal == ((StandardDateTimeFieldType) obj).iOrdinal; [EOL]     } [EOL]     return false; [EOL] }
@Override [EOL] public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof StandardDateTimeFieldType) { [EOL]         return iOrdinal == ((StandardDateTimeFieldType) obj).iOrdinal; [EOL]     } [EOL]     return false; [EOL] }
@Override [EOL] public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof StandardDateTimeFieldType) { [EOL]         return iOrdinal == ((StandardDateTimeFieldType) obj).iOrdinal; [EOL]     } [EOL]     return false; [EOL] }
@Override [EOL] public int hashCode() { [EOL]     return (1 << iOrdinal); [EOL] }
@Override [EOL] public int hashCode() { [EOL]     return (1 << iOrdinal); [EOL] }
@Override [EOL] public int hashCode() { [EOL]     return (1 << iOrdinal); [EOL] }
public DateTimeField getField(Chronology chronology) { [EOL]     chronology = DateTimeUtils.getChronology(chronology); [EOL]     switch(iOrdinal) { [EOL]         case ERA: [EOL]             return chronology.era(); [EOL]         case YEAR_OF_ERA: [EOL]             return chronology.yearOfEra(); [EOL]         case CENTURY_OF_ERA: [EOL]             return chronology.centuryOfEra(); [EOL]         case YEAR_OF_CENTURY: [EOL]             return chronology.yearOfCentury(); [EOL]         case YEAR: [EOL]             return chronology.year(); [EOL]         case DAY_OF_YEAR: [EOL]             return chronology.dayOfYear(); [EOL]         case MONTH_OF_YEAR: [EOL]             return chronology.monthOfYear(); [EOL]         case DAY_OF_MONTH: [EOL]             return chronology.dayOfMonth(); [EOL]         case WEEKYEAR_OF_CENTURY: [EOL]             return chronology.weekyearOfCentury(); [EOL]         case WEEKYEAR: [EOL]             return chronology.weekyear(); [EOL]         case WEEK_OF_WEEKYEAR: [EOL]             return chronology.weekOfWeekyear(); [EOL]         case DAY_OF_WEEK: [EOL]             return chronology.dayOfWeek(); [EOL]         case HALFDAY_OF_DAY: [EOL]             return chronology.halfdayOfDay(); [EOL]         case HOUR_OF_HALFDAY: [EOL]             return chronology.hourOfHalfday(); [EOL]         case CLOCKHOUR_OF_HALFDAY: [EOL]             return chronology.clockhourOfHalfday(); [EOL]         case CLOCKHOUR_OF_DAY: [EOL]             return chronology.clockhourOfDay(); [EOL]         case HOUR_OF_DAY: [EOL]             return chronology.hourOfDay(); [EOL]         case MINUTE_OF_DAY: [EOL]             return chronology.minuteOfDay(); [EOL]         case MINUTE_OF_HOUR: [EOL]             return chronology.minuteOfHour(); [EOL]         case SECOND_OF_DAY: [EOL]             return chronology.secondOfDay(); [EOL]         case SECOND_OF_MINUTE: [EOL]             return chronology.secondOfMinute(); [EOL]         case MILLIS_OF_DAY: [EOL]             return chronology.millisOfDay(); [EOL]         case MILLIS_OF_SECOND: [EOL]             return chronology.millisOfSecond(); [EOL]         default: [EOL]             throw new InternalError(); [EOL]     } [EOL] }
private Object readResolve() { [EOL]     switch(iOrdinal) { [EOL]         case ERA: [EOL]             return ERA_TYPE; [EOL]         case YEAR_OF_ERA: [EOL]             return YEAR_OF_ERA_TYPE; [EOL]         case CENTURY_OF_ERA: [EOL]             return CENTURY_OF_ERA_TYPE; [EOL]         case YEAR_OF_CENTURY: [EOL]             return YEAR_OF_CENTURY_TYPE; [EOL]         case YEAR: [EOL]             return YEAR_TYPE; [EOL]         case DAY_OF_YEAR: [EOL]             return DAY_OF_YEAR_TYPE; [EOL]         case MONTH_OF_YEAR: [EOL]             return MONTH_OF_YEAR_TYPE; [EOL]         case DAY_OF_MONTH: [EOL]             return DAY_OF_MONTH_TYPE; [EOL]         case WEEKYEAR_OF_CENTURY: [EOL]             return WEEKYEAR_OF_CENTURY_TYPE; [EOL]         case WEEKYEAR: [EOL]             return WEEKYEAR_TYPE; [EOL]         case WEEK_OF_WEEKYEAR: [EOL]             return WEEK_OF_WEEKYEAR_TYPE; [EOL]         case DAY_OF_WEEK: [EOL]             return DAY_OF_WEEK_TYPE; [EOL]         case HALFDAY_OF_DAY: [EOL]             return HALFDAY_OF_DAY_TYPE; [EOL]         case HOUR_OF_HALFDAY: [EOL]             return HOUR_OF_HALFDAY_TYPE; [EOL]         case CLOCKHOUR_OF_HALFDAY: [EOL]             return CLOCKHOUR_OF_HALFDAY_TYPE; [EOL]         case CLOCKHOUR_OF_DAY: [EOL]             return CLOCKHOUR_OF_DAY_TYPE; [EOL]         case HOUR_OF_DAY: [EOL]             return HOUR_OF_DAY_TYPE; [EOL]         case MINUTE_OF_DAY: [EOL]             return MINUTE_OF_DAY_TYPE; [EOL]         case MINUTE_OF_HOUR: [EOL]             return MINUTE_OF_HOUR_TYPE; [EOL]         case SECOND_OF_DAY: [EOL]             return SECOND_OF_DAY_TYPE; [EOL]         case SECOND_OF_MINUTE: [EOL]             return SECOND_OF_MINUTE_TYPE; [EOL]         case MILLIS_OF_DAY: [EOL]             return MILLIS_OF_DAY_TYPE; [EOL]         case MILLIS_OF_SECOND: [EOL]             return MILLIS_OF_SECOND_TYPE; [EOL]         default: [EOL]             return this; [EOL]     } [EOL] }
private Object readResolve() { [EOL]     switch(iOrdinal) { [EOL]         case ERA: [EOL]             return ERA_TYPE; [EOL]         case YEAR_OF_ERA: [EOL]             return YEAR_OF_ERA_TYPE; [EOL]         case CENTURY_OF_ERA: [EOL]             return CENTURY_OF_ERA_TYPE; [EOL]         case YEAR_OF_CENTURY: [EOL]             return YEAR_OF_CENTURY_TYPE; [EOL]         case YEAR: [EOL]             return YEAR_TYPE; [EOL]         case DAY_OF_YEAR: [EOL]             return DAY_OF_YEAR_TYPE; [EOL]         case MONTH_OF_YEAR: [EOL]             return MONTH_OF_YEAR_TYPE; [EOL]         case DAY_OF_MONTH: [EOL]             return DAY_OF_MONTH_TYPE; [EOL]         case WEEKYEAR_OF_CENTURY: [EOL]             return WEEKYEAR_OF_CENTURY_TYPE; [EOL]         case WEEKYEAR: [EOL]             return WEEKYEAR_TYPE; [EOL]         case WEEK_OF_WEEKYEAR: [EOL]             return WEEK_OF_WEEKYEAR_TYPE; [EOL]         case DAY_OF_WEEK: [EOL]             return DAY_OF_WEEK_TYPE; [EOL]         case HALFDAY_OF_DAY: [EOL]             return HALFDAY_OF_DAY_TYPE; [EOL]         case HOUR_OF_HALFDAY: [EOL]             return HOUR_OF_HALFDAY_TYPE; [EOL]         case CLOCKHOUR_OF_HALFDAY: [EOL]             return CLOCKHOUR_OF_HALFDAY_TYPE; [EOL]         case CLOCKHOUR_OF_DAY: [EOL]             return CLOCKHOUR_OF_DAY_TYPE; [EOL]         case HOUR_OF_DAY: [EOL]             return HOUR_OF_DAY_TYPE; [EOL]         case MINUTE_OF_DAY: [EOL]             return MINUTE_OF_DAY_TYPE; [EOL]         case MINUTE_OF_HOUR: [EOL]             return MINUTE_OF_HOUR_TYPE; [EOL]         case SECOND_OF_DAY: [EOL]             return SECOND_OF_DAY_TYPE; [EOL]         case SECOND_OF_MINUTE: [EOL]             return SECOND_OF_MINUTE_TYPE; [EOL]         case MILLIS_OF_DAY: [EOL]             return MILLIS_OF_DAY_TYPE; [EOL]         case MILLIS_OF_SECOND: [EOL]             return MILLIS_OF_SECOND_TYPE; [EOL]         default: [EOL]             return this; [EOL]     } [EOL] }
private Object readResolve() { [EOL]     switch(iOrdinal) { [EOL]         case ERA: [EOL]             return ERA_TYPE; [EOL]         case YEAR_OF_ERA: [EOL]             return YEAR_OF_ERA_TYPE; [EOL]         case CENTURY_OF_ERA: [EOL]             return CENTURY_OF_ERA_TYPE; [EOL]         case YEAR_OF_CENTURY: [EOL]             return YEAR_OF_CENTURY_TYPE; [EOL]         case YEAR: [EOL]             return YEAR_TYPE; [EOL]         case DAY_OF_YEAR: [EOL]             return DAY_OF_YEAR_TYPE; [EOL]         case MONTH_OF_YEAR: [EOL]             return MONTH_OF_YEAR_TYPE; [EOL]         case DAY_OF_MONTH: [EOL]             return DAY_OF_MONTH_TYPE; [EOL]         case WEEKYEAR_OF_CENTURY: [EOL]             return WEEKYEAR_OF_CENTURY_TYPE; [EOL]         case WEEKYEAR: [EOL]             return WEEKYEAR_TYPE; [EOL]         case WEEK_OF_WEEKYEAR: [EOL]             return WEEK_OF_WEEKYEAR_TYPE; [EOL]         case DAY_OF_WEEK: [EOL]             return DAY_OF_WEEK_TYPE; [EOL]         case HALFDAY_OF_DAY: [EOL]             return HALFDAY_OF_DAY_TYPE; [EOL]         case HOUR_OF_HALFDAY: [EOL]             return HOUR_OF_HALFDAY_TYPE; [EOL]         case CLOCKHOUR_OF_HALFDAY: [EOL]             return CLOCKHOUR_OF_HALFDAY_TYPE; [EOL]         case CLOCKHOUR_OF_DAY: [EOL]             return CLOCKHOUR_OF_DAY_TYPE; [EOL]         case HOUR_OF_DAY: [EOL]             return HOUR_OF_DAY_TYPE; [EOL]         case MINUTE_OF_DAY: [EOL]             return MINUTE_OF_DAY_TYPE; [EOL]         case MINUTE_OF_HOUR: [EOL]             return MINUTE_OF_HOUR_TYPE; [EOL]         case SECOND_OF_DAY: [EOL]             return SECOND_OF_DAY_TYPE; [EOL]         case SECOND_OF_MINUTE: [EOL]             return SECOND_OF_MINUTE_TYPE; [EOL]         case MILLIS_OF_DAY: [EOL]             return MILLIS_OF_DAY_TYPE; [EOL]         case MILLIS_OF_SECOND: [EOL]             return MILLIS_OF_SECOND_TYPE; [EOL]         default: [EOL]             return this; [EOL]     } [EOL] }
private Object readResolve() { [EOL]     switch(iOrdinal) { [EOL]         case ERA: [EOL]             return ERA_TYPE; [EOL]         case YEAR_OF_ERA: [EOL]             return YEAR_OF_ERA_TYPE; [EOL]         case CENTURY_OF_ERA: [EOL]             return CENTURY_OF_ERA_TYPE; [EOL]         case YEAR_OF_CENTURY: [EOL]             return YEAR_OF_CENTURY_TYPE; [EOL]         case YEAR: [EOL]             return YEAR_TYPE; [EOL]         case DAY_OF_YEAR: [EOL]             return DAY_OF_YEAR_TYPE; [EOL]         case MONTH_OF_YEAR: [EOL]             return MONTH_OF_YEAR_TYPE; [EOL]         case DAY_OF_MONTH: [EOL]             return DAY_OF_MONTH_TYPE; [EOL]         case WEEKYEAR_OF_CENTURY: [EOL]             return WEEKYEAR_OF_CENTURY_TYPE; [EOL]         case WEEKYEAR: [EOL]             return WEEKYEAR_TYPE; [EOL]         case WEEK_OF_WEEKYEAR: [EOL]             return WEEK_OF_WEEKYEAR_TYPE; [EOL]         case DAY_OF_WEEK: [EOL]             return DAY_OF_WEEK_TYPE; [EOL]         case HALFDAY_OF_DAY: [EOL]             return HALFDAY_OF_DAY_TYPE; [EOL]         case HOUR_OF_HALFDAY: [EOL]             return HOUR_OF_HALFDAY_TYPE; [EOL]         case CLOCKHOUR_OF_HALFDAY: [EOL]             return CLOCKHOUR_OF_HALFDAY_TYPE; [EOL]         case CLOCKHOUR_OF_DAY: [EOL]             return CLOCKHOUR_OF_DAY_TYPE; [EOL]         case HOUR_OF_DAY: [EOL]             return HOUR_OF_DAY_TYPE; [EOL]         case MINUTE_OF_DAY: [EOL]             return MINUTE_OF_DAY_TYPE; [EOL]         case MINUTE_OF_HOUR: [EOL]             return MINUTE_OF_HOUR_TYPE; [EOL]         case SECOND_OF_DAY: [EOL]             return SECOND_OF_DAY_TYPE; [EOL]         case SECOND_OF_MINUTE: [EOL]             return SECOND_OF_MINUTE_TYPE; [EOL]         case MILLIS_OF_DAY: [EOL]             return MILLIS_OF_DAY_TYPE; [EOL]         case MILLIS_OF_SECOND: [EOL]             return MILLIS_OF_SECOND_TYPE; [EOL]         default: [EOL]             return this; [EOL]     } [EOL] }
private Object readResolve() { [EOL]     switch(iOrdinal) { [EOL]         case ERA: [EOL]             return ERA_TYPE; [EOL]         case YEAR_OF_ERA: [EOL]             return YEAR_OF_ERA_TYPE; [EOL]         case CENTURY_OF_ERA: [EOL]             return CENTURY_OF_ERA_TYPE; [EOL]         case YEAR_OF_CENTURY: [EOL]             return YEAR_OF_CENTURY_TYPE; [EOL]         case YEAR: [EOL]             return YEAR_TYPE; [EOL]         case DAY_OF_YEAR: [EOL]             return DAY_OF_YEAR_TYPE; [EOL]         case MONTH_OF_YEAR: [EOL]             return MONTH_OF_YEAR_TYPE; [EOL]         case DAY_OF_MONTH: [EOL]             return DAY_OF_MONTH_TYPE; [EOL]         case WEEKYEAR_OF_CENTURY: [EOL]             return WEEKYEAR_OF_CENTURY_TYPE; [EOL]         case WEEKYEAR: [EOL]             return WEEKYEAR_TYPE; [EOL]         case WEEK_OF_WEEKYEAR: [EOL]             return WEEK_OF_WEEKYEAR_TYPE; [EOL]         case DAY_OF_WEEK: [EOL]             return DAY_OF_WEEK_TYPE; [EOL]         case HALFDAY_OF_DAY: [EOL]             return HALFDAY_OF_DAY_TYPE; [EOL]         case HOUR_OF_HALFDAY: [EOL]             return HOUR_OF_HALFDAY_TYPE; [EOL]         case CLOCKHOUR_OF_HALFDAY: [EOL]             return CLOCKHOUR_OF_HALFDAY_TYPE; [EOL]         case CLOCKHOUR_OF_DAY: [EOL]             return CLOCKHOUR_OF_DAY_TYPE; [EOL]         case HOUR_OF_DAY: [EOL]             return HOUR_OF_DAY_TYPE; [EOL]         case MINUTE_OF_DAY: [EOL]             return MINUTE_OF_DAY_TYPE; [EOL]         case MINUTE_OF_HOUR: [EOL]             return MINUTE_OF_HOUR_TYPE; [EOL]         case SECOND_OF_DAY: [EOL]             return SECOND_OF_DAY_TYPE; [EOL]         case SECOND_OF_MINUTE: [EOL]             return SECOND_OF_MINUTE_TYPE; [EOL]         case MILLIS_OF_DAY: [EOL]             return MILLIS_OF_DAY_TYPE; [EOL]         case MILLIS_OF_SECOND: [EOL]             return MILLIS_OF_SECOND_TYPE; [EOL]         default: [EOL]             return this; [EOL]     } [EOL] }
private Object readResolve() { [EOL]     switch(iOrdinal) { [EOL]         case ERA: [EOL]             return ERA_TYPE; [EOL]         case YEAR_OF_ERA: [EOL]             return YEAR_OF_ERA_TYPE; [EOL]         case CENTURY_OF_ERA: [EOL]             return CENTURY_OF_ERA_TYPE; [EOL]         case YEAR_OF_CENTURY: [EOL]             return YEAR_OF_CENTURY_TYPE; [EOL]         case YEAR: [EOL]             return YEAR_TYPE; [EOL]         case DAY_OF_YEAR: [EOL]             return DAY_OF_YEAR_TYPE; [EOL]         case MONTH_OF_YEAR: [EOL]             return MONTH_OF_YEAR_TYPE; [EOL]         case DAY_OF_MONTH: [EOL]             return DAY_OF_MONTH_TYPE; [EOL]         case WEEKYEAR_OF_CENTURY: [EOL]             return WEEKYEAR_OF_CENTURY_TYPE; [EOL]         case WEEKYEAR: [EOL]             return WEEKYEAR_TYPE; [EOL]         case WEEK_OF_WEEKYEAR: [EOL]             return WEEK_OF_WEEKYEAR_TYPE; [EOL]         case DAY_OF_WEEK: [EOL]             return DAY_OF_WEEK_TYPE; [EOL]         case HALFDAY_OF_DAY: [EOL]             return HALFDAY_OF_DAY_TYPE; [EOL]         case HOUR_OF_HALFDAY: [EOL]             return HOUR_OF_HALFDAY_TYPE; [EOL]         case CLOCKHOUR_OF_HALFDAY: [EOL]             return CLOCKHOUR_OF_HALFDAY_TYPE; [EOL]         case CLOCKHOUR_OF_DAY: [EOL]             return CLOCKHOUR_OF_DAY_TYPE; [EOL]         case HOUR_OF_DAY: [EOL]             return HOUR_OF_DAY_TYPE; [EOL]         case MINUTE_OF_DAY: [EOL]             return MINUTE_OF_DAY_TYPE; [EOL]         case MINUTE_OF_HOUR: [EOL]             return MINUTE_OF_HOUR_TYPE; [EOL]         case SECOND_OF_DAY: [EOL]             return SECOND_OF_DAY_TYPE; [EOL]         case SECOND_OF_MINUTE: [EOL]             return SECOND_OF_MINUTE_TYPE; [EOL]         case MILLIS_OF_DAY: [EOL]             return MILLIS_OF_DAY_TYPE; [EOL]         case MILLIS_OF_SECOND: [EOL]             return MILLIS_OF_SECOND_TYPE; [EOL]         default: [EOL]             return this; [EOL]     } [EOL] }
private Object readResolve() { [EOL]     switch(iOrdinal) { [EOL]         case ERA: [EOL]             return ERA_TYPE; [EOL]         case YEAR_OF_ERA: [EOL]             return YEAR_OF_ERA_TYPE; [EOL]         case CENTURY_OF_ERA: [EOL]             return CENTURY_OF_ERA_TYPE; [EOL]         case YEAR_OF_CENTURY: [EOL]             return YEAR_OF_CENTURY_TYPE; [EOL]         case YEAR: [EOL]             return YEAR_TYPE; [EOL]         case DAY_OF_YEAR: [EOL]             return DAY_OF_YEAR_TYPE; [EOL]         case MONTH_OF_YEAR: [EOL]             return MONTH_OF_YEAR_TYPE; [EOL]         case DAY_OF_MONTH: [EOL]             return DAY_OF_MONTH_TYPE; [EOL]         case WEEKYEAR_OF_CENTURY: [EOL]             return WEEKYEAR_OF_CENTURY_TYPE; [EOL]         case WEEKYEAR: [EOL]             return WEEKYEAR_TYPE; [EOL]         case WEEK_OF_WEEKYEAR: [EOL]             return WEEK_OF_WEEKYEAR_TYPE; [EOL]         case DAY_OF_WEEK: [EOL]             return DAY_OF_WEEK_TYPE; [EOL]         case HALFDAY_OF_DAY: [EOL]             return HALFDAY_OF_DAY_TYPE; [EOL]         case HOUR_OF_HALFDAY: [EOL]             return HOUR_OF_HALFDAY_TYPE; [EOL]         case CLOCKHOUR_OF_HALFDAY: [EOL]             return CLOCKHOUR_OF_HALFDAY_TYPE; [EOL]         case CLOCKHOUR_OF_DAY: [EOL]             return CLOCKHOUR_OF_DAY_TYPE; [EOL]         case HOUR_OF_DAY: [EOL]             return HOUR_OF_DAY_TYPE; [EOL]         case MINUTE_OF_DAY: [EOL]             return MINUTE_OF_DAY_TYPE; [EOL]         case MINUTE_OF_HOUR: [EOL]             return MINUTE_OF_HOUR_TYPE; [EOL]         case SECOND_OF_DAY: [EOL]             return SECOND_OF_DAY_TYPE; [EOL]         case SECOND_OF_MINUTE: [EOL]             return SECOND_OF_MINUTE_TYPE; [EOL]         case MILLIS_OF_DAY: [EOL]             return MILLIS_OF_DAY_TYPE; [EOL]         case MILLIS_OF_SECOND: [EOL]             return MILLIS_OF_SECOND_TYPE; [EOL]         default: [EOL]             return this; [EOL]     } [EOL] }
private Object readResolve() { [EOL]     switch(iOrdinal) { [EOL]         case ERA: [EOL]             return ERA_TYPE; [EOL]         case YEAR_OF_ERA: [EOL]             return YEAR_OF_ERA_TYPE; [EOL]         case CENTURY_OF_ERA: [EOL]             return CENTURY_OF_ERA_TYPE; [EOL]         case YEAR_OF_CENTURY: [EOL]             return YEAR_OF_CENTURY_TYPE; [EOL]         case YEAR: [EOL]             return YEAR_TYPE; [EOL]         case DAY_OF_YEAR: [EOL]             return DAY_OF_YEAR_TYPE; [EOL]         case MONTH_OF_YEAR: [EOL]             return MONTH_OF_YEAR_TYPE; [EOL]         case DAY_OF_MONTH: [EOL]             return DAY_OF_MONTH_TYPE; [EOL]         case WEEKYEAR_OF_CENTURY: [EOL]             return WEEKYEAR_OF_CENTURY_TYPE; [EOL]         case WEEKYEAR: [EOL]             return WEEKYEAR_TYPE; [EOL]         case WEEK_OF_WEEKYEAR: [EOL]             return WEEK_OF_WEEKYEAR_TYPE; [EOL]         case DAY_OF_WEEK: [EOL]             return DAY_OF_WEEK_TYPE; [EOL]         case HALFDAY_OF_DAY: [EOL]             return HALFDAY_OF_DAY_TYPE; [EOL]         case HOUR_OF_HALFDAY: [EOL]             return HOUR_OF_HALFDAY_TYPE; [EOL]         case CLOCKHOUR_OF_HALFDAY: [EOL]             return CLOCKHOUR_OF_HALFDAY_TYPE; [EOL]         case CLOCKHOUR_OF_DAY: [EOL]             return CLOCKHOUR_OF_DAY_TYPE; [EOL]         case HOUR_OF_DAY: [EOL]             return HOUR_OF_DAY_TYPE; [EOL]         case MINUTE_OF_DAY: [EOL]             return MINUTE_OF_DAY_TYPE; [EOL]         case MINUTE_OF_HOUR: [EOL]             return MINUTE_OF_HOUR_TYPE; [EOL]         case SECOND_OF_DAY: [EOL]             return SECOND_OF_DAY_TYPE; [EOL]         case SECOND_OF_MINUTE: [EOL]             return SECOND_OF_MINUTE_TYPE; [EOL]         case MILLIS_OF_DAY: [EOL]             return MILLIS_OF_DAY_TYPE; [EOL]         case MILLIS_OF_SECOND: [EOL]             return MILLIS_OF_SECOND_TYPE; [EOL]         default: [EOL]             return this; [EOL]     } [EOL] }
private Object readResolve() { [EOL]     switch(iOrdinal) { [EOL]         case ERA: [EOL]             return ERA_TYPE; [EOL]         case YEAR_OF_ERA: [EOL]             return YEAR_OF_ERA_TYPE; [EOL]         case CENTURY_OF_ERA: [EOL]             return CENTURY_OF_ERA_TYPE; [EOL]         case YEAR_OF_CENTURY: [EOL]             return YEAR_OF_CENTURY_TYPE; [EOL]         case YEAR: [EOL]             return YEAR_TYPE; [EOL]         case DAY_OF_YEAR: [EOL]             return DAY_OF_YEAR_TYPE; [EOL]         case MONTH_OF_YEAR: [EOL]             return MONTH_OF_YEAR_TYPE; [EOL]         case DAY_OF_MONTH: [EOL]             return DAY_OF_MONTH_TYPE; [EOL]         case WEEKYEAR_OF_CENTURY: [EOL]             return WEEKYEAR_OF_CENTURY_TYPE; [EOL]         case WEEKYEAR: [EOL]             return WEEKYEAR_TYPE; [EOL]         case WEEK_OF_WEEKYEAR: [EOL]             return WEEK_OF_WEEKYEAR_TYPE; [EOL]         case DAY_OF_WEEK: [EOL]             return DAY_OF_WEEK_TYPE; [EOL]         case HALFDAY_OF_DAY: [EOL]             return HALFDAY_OF_DAY_TYPE; [EOL]         case HOUR_OF_HALFDAY: [EOL]             return HOUR_OF_HALFDAY_TYPE; [EOL]         case CLOCKHOUR_OF_HALFDAY: [EOL]             return CLOCKHOUR_OF_HALFDAY_TYPE; [EOL]         case CLOCKHOUR_OF_DAY: [EOL]             return CLOCKHOUR_OF_DAY_TYPE; [EOL]         case HOUR_OF_DAY: [EOL]             return HOUR_OF_DAY_TYPE; [EOL]         case MINUTE_OF_DAY: [EOL]             return MINUTE_OF_DAY_TYPE; [EOL]         case MINUTE_OF_HOUR: [EOL]             return MINUTE_OF_HOUR_TYPE; [EOL]         case SECOND_OF_DAY: [EOL]             return SECOND_OF_DAY_TYPE; [EOL]         case SECOND_OF_MINUTE: [EOL]             return SECOND_OF_MINUTE_TYPE; [EOL]         case MILLIS_OF_DAY: [EOL]             return MILLIS_OF_DAY_TYPE; [EOL]         case MILLIS_OF_SECOND: [EOL]             return MILLIS_OF_SECOND_TYPE; [EOL]         default: [EOL]             return this; [EOL]     } [EOL] }
private Object readResolve() { [EOL]     switch(iOrdinal) { [EOL]         case ERA: [EOL]             return ERA_TYPE; [EOL]         case YEAR_OF_ERA: [EOL]             return YEAR_OF_ERA_TYPE; [EOL]         case CENTURY_OF_ERA: [EOL]             return CENTURY_OF_ERA_TYPE; [EOL]         case YEAR_OF_CENTURY: [EOL]             return YEAR_OF_CENTURY_TYPE; [EOL]         case YEAR: [EOL]             return YEAR_TYPE; [EOL]         case DAY_OF_YEAR: [EOL]             return DAY_OF_YEAR_TYPE; [EOL]         case MONTH_OF_YEAR: [EOL]             return MONTH_OF_YEAR_TYPE; [EOL]         case DAY_OF_MONTH: [EOL]             return DAY_OF_MONTH_TYPE; [EOL]         case WEEKYEAR_OF_CENTURY: [EOL]             return WEEKYEAR_OF_CENTURY_TYPE; [EOL]         case WEEKYEAR: [EOL]             return WEEKYEAR_TYPE; [EOL]         case WEEK_OF_WEEKYEAR: [EOL]             return WEEK_OF_WEEKYEAR_TYPE; [EOL]         case DAY_OF_WEEK: [EOL]             return DAY_OF_WEEK_TYPE; [EOL]         case HALFDAY_OF_DAY: [EOL]             return HALFDAY_OF_DAY_TYPE; [EOL]         case HOUR_OF_HALFDAY: [EOL]             return HOUR_OF_HALFDAY_TYPE; [EOL]         case CLOCKHOUR_OF_HALFDAY: [EOL]             return CLOCKHOUR_OF_HALFDAY_TYPE; [EOL]         case CLOCKHOUR_OF_DAY: [EOL]             return CLOCKHOUR_OF_DAY_TYPE; [EOL]         case HOUR_OF_DAY: [EOL]             return HOUR_OF_DAY_TYPE; [EOL]         case MINUTE_OF_DAY: [EOL]             return MINUTE_OF_DAY_TYPE; [EOL]         case MINUTE_OF_HOUR: [EOL]             return MINUTE_OF_HOUR_TYPE; [EOL]         case SECOND_OF_DAY: [EOL]             return SECOND_OF_DAY_TYPE; [EOL]         case SECOND_OF_MINUTE: [EOL]             return SECOND_OF_MINUTE_TYPE; [EOL]         case MILLIS_OF_DAY: [EOL]             return MILLIS_OF_DAY_TYPE; [EOL]         case MILLIS_OF_SECOND: [EOL]             return MILLIS_OF_SECOND_TYPE; [EOL]         default: [EOL]             return this; [EOL]     } [EOL] }
private Object readResolve() { [EOL]     switch(iOrdinal) { [EOL]         case ERA: [EOL]             return ERA_TYPE; [EOL]         case YEAR_OF_ERA: [EOL]             return YEAR_OF_ERA_TYPE; [EOL]         case CENTURY_OF_ERA: [EOL]             return CENTURY_OF_ERA_TYPE; [EOL]         case YEAR_OF_CENTURY: [EOL]             return YEAR_OF_CENTURY_TYPE; [EOL]         case YEAR: [EOL]             return YEAR_TYPE; [EOL]         case DAY_OF_YEAR: [EOL]             return DAY_OF_YEAR_TYPE; [EOL]         case MONTH_OF_YEAR: [EOL]             return MONTH_OF_YEAR_TYPE; [EOL]         case DAY_OF_MONTH: [EOL]             return DAY_OF_MONTH_TYPE; [EOL]         case WEEKYEAR_OF_CENTURY: [EOL]             return WEEKYEAR_OF_CENTURY_TYPE; [EOL]         case WEEKYEAR: [EOL]             return WEEKYEAR_TYPE; [EOL]         case WEEK_OF_WEEKYEAR: [EOL]             return WEEK_OF_WEEKYEAR_TYPE; [EOL]         case DAY_OF_WEEK: [EOL]             return DAY_OF_WEEK_TYPE; [EOL]         case HALFDAY_OF_DAY: [EOL]             return HALFDAY_OF_DAY_TYPE; [EOL]         case HOUR_OF_HALFDAY: [EOL]             return HOUR_OF_HALFDAY_TYPE; [EOL]         case CLOCKHOUR_OF_HALFDAY: [EOL]             return CLOCKHOUR_OF_HALFDAY_TYPE; [EOL]         case CLOCKHOUR_OF_DAY: [EOL]             return CLOCKHOUR_OF_DAY_TYPE; [EOL]         case HOUR_OF_DAY: [EOL]             return HOUR_OF_DAY_TYPE; [EOL]         case MINUTE_OF_DAY: [EOL]             return MINUTE_OF_DAY_TYPE; [EOL]         case MINUTE_OF_HOUR: [EOL]             return MINUTE_OF_HOUR_TYPE; [EOL]         case SECOND_OF_DAY: [EOL]             return SECOND_OF_DAY_TYPE; [EOL]         case SECOND_OF_MINUTE: [EOL]             return SECOND_OF_MINUTE_TYPE; [EOL]         case MILLIS_OF_DAY: [EOL]             return MILLIS_OF_DAY_TYPE; [EOL]         case MILLIS_OF_SECOND: [EOL]             return MILLIS_OF_SECOND_TYPE; [EOL]         default: [EOL]             return this; [EOL]     } [EOL] }
private Object readResolve() { [EOL]     switch(iOrdinal) { [EOL]         case ERA: [EOL]             return ERA_TYPE; [EOL]         case YEAR_OF_ERA: [EOL]             return YEAR_OF_ERA_TYPE; [EOL]         case CENTURY_OF_ERA: [EOL]             return CENTURY_OF_ERA_TYPE; [EOL]         case YEAR_OF_CENTURY: [EOL]             return YEAR_OF_CENTURY_TYPE; [EOL]         case YEAR: [EOL]             return YEAR_TYPE; [EOL]         case DAY_OF_YEAR: [EOL]             return DAY_OF_YEAR_TYPE; [EOL]         case MONTH_OF_YEAR: [EOL]             return MONTH_OF_YEAR_TYPE; [EOL]         case DAY_OF_MONTH: [EOL]             return DAY_OF_MONTH_TYPE; [EOL]         case WEEKYEAR_OF_CENTURY: [EOL]             return WEEKYEAR_OF_CENTURY_TYPE; [EOL]         case WEEKYEAR: [EOL]             return WEEKYEAR_TYPE; [EOL]         case WEEK_OF_WEEKYEAR: [EOL]             return WEEK_OF_WEEKYEAR_TYPE; [EOL]         case DAY_OF_WEEK: [EOL]             return DAY_OF_WEEK_TYPE; [EOL]         case HALFDAY_OF_DAY: [EOL]             return HALFDAY_OF_DAY_TYPE; [EOL]         case HOUR_OF_HALFDAY: [EOL]             return HOUR_OF_HALFDAY_TYPE; [EOL]         case CLOCKHOUR_OF_HALFDAY: [EOL]             return CLOCKHOUR_OF_HALFDAY_TYPE; [EOL]         case CLOCKHOUR_OF_DAY: [EOL]             return CLOCKHOUR_OF_DAY_TYPE; [EOL]         case HOUR_OF_DAY: [EOL]             return HOUR_OF_DAY_TYPE; [EOL]         case MINUTE_OF_DAY: [EOL]             return MINUTE_OF_DAY_TYPE; [EOL]         case MINUTE_OF_HOUR: [EOL]             return MINUTE_OF_HOUR_TYPE; [EOL]         case SECOND_OF_DAY: [EOL]             return SECOND_OF_DAY_TYPE; [EOL]         case SECOND_OF_MINUTE: [EOL]             return SECOND_OF_MINUTE_TYPE; [EOL]         case MILLIS_OF_DAY: [EOL]             return MILLIS_OF_DAY_TYPE; [EOL]         case MILLIS_OF_SECOND: [EOL]             return MILLIS_OF_SECOND_TYPE; [EOL]         default: [EOL]             return this; [EOL]     } [EOL] }
private Object readResolve() { [EOL]     switch(iOrdinal) { [EOL]         case ERA: [EOL]             return ERA_TYPE; [EOL]         case YEAR_OF_ERA: [EOL]             return YEAR_OF_ERA_TYPE; [EOL]         case CENTURY_OF_ERA: [EOL]             return CENTURY_OF_ERA_TYPE; [EOL]         case YEAR_OF_CENTURY: [EOL]             return YEAR_OF_CENTURY_TYPE; [EOL]         case YEAR: [EOL]             return YEAR_TYPE; [EOL]         case DAY_OF_YEAR: [EOL]             return DAY_OF_YEAR_TYPE; [EOL]         case MONTH_OF_YEAR: [EOL]             return MONTH_OF_YEAR_TYPE; [EOL]         case DAY_OF_MONTH: [EOL]             return DAY_OF_MONTH_TYPE; [EOL]         case WEEKYEAR_OF_CENTURY: [EOL]             return WEEKYEAR_OF_CENTURY_TYPE; [EOL]         case WEEKYEAR: [EOL]             return WEEKYEAR_TYPE; [EOL]         case WEEK_OF_WEEKYEAR: [EOL]             return WEEK_OF_WEEKYEAR_TYPE; [EOL]         case DAY_OF_WEEK: [EOL]             return DAY_OF_WEEK_TYPE; [EOL]         case HALFDAY_OF_DAY: [EOL]             return HALFDAY_OF_DAY_TYPE; [EOL]         case HOUR_OF_HALFDAY: [EOL]             return HOUR_OF_HALFDAY_TYPE; [EOL]         case CLOCKHOUR_OF_HALFDAY: [EOL]             return CLOCKHOUR_OF_HALFDAY_TYPE; [EOL]         case CLOCKHOUR_OF_DAY: [EOL]             return CLOCKHOUR_OF_DAY_TYPE; [EOL]         case HOUR_OF_DAY: [EOL]             return HOUR_OF_DAY_TYPE; [EOL]         case MINUTE_OF_DAY: [EOL]             return MINUTE_OF_DAY_TYPE; [EOL]         case MINUTE_OF_HOUR: [EOL]             return MINUTE_OF_HOUR_TYPE; [EOL]         case SECOND_OF_DAY: [EOL]             return SECOND_OF_DAY_TYPE; [EOL]         case SECOND_OF_MINUTE: [EOL]             return SECOND_OF_MINUTE_TYPE; [EOL]         case MILLIS_OF_DAY: [EOL]             return MILLIS_OF_DAY_TYPE; [EOL]         case MILLIS_OF_SECOND: [EOL]             return MILLIS_OF_SECOND_TYPE; [EOL]         default: [EOL]             return this; [EOL]     } [EOL] }
private Object readResolve() { [EOL]     switch(iOrdinal) { [EOL]         case ERA: [EOL]             return ERA_TYPE; [EOL]         case YEAR_OF_ERA: [EOL]             return YEAR_OF_ERA_TYPE; [EOL]         case CENTURY_OF_ERA: [EOL]             return CENTURY_OF_ERA_TYPE; [EOL]         case YEAR_OF_CENTURY: [EOL]             return YEAR_OF_CENTURY_TYPE; [EOL]         case YEAR: [EOL]             return YEAR_TYPE; [EOL]         case DAY_OF_YEAR: [EOL]             return DAY_OF_YEAR_TYPE; [EOL]         case MONTH_OF_YEAR: [EOL]             return MONTH_OF_YEAR_TYPE; [EOL]         case DAY_OF_MONTH: [EOL]             return DAY_OF_MONTH_TYPE; [EOL]         case WEEKYEAR_OF_CENTURY: [EOL]             return WEEKYEAR_OF_CENTURY_TYPE; [EOL]         case WEEKYEAR: [EOL]             return WEEKYEAR_TYPE; [EOL]         case WEEK_OF_WEEKYEAR: [EOL]             return WEEK_OF_WEEKYEAR_TYPE; [EOL]         case DAY_OF_WEEK: [EOL]             return DAY_OF_WEEK_TYPE; [EOL]         case HALFDAY_OF_DAY: [EOL]             return HALFDAY_OF_DAY_TYPE; [EOL]         case HOUR_OF_HALFDAY: [EOL]             return HOUR_OF_HALFDAY_TYPE; [EOL]         case CLOCKHOUR_OF_HALFDAY: [EOL]             return CLOCKHOUR_OF_HALFDAY_TYPE; [EOL]         case CLOCKHOUR_OF_DAY: [EOL]             return CLOCKHOUR_OF_DAY_TYPE; [EOL]         case HOUR_OF_DAY: [EOL]             return HOUR_OF_DAY_TYPE; [EOL]         case MINUTE_OF_DAY: [EOL]             return MINUTE_OF_DAY_TYPE; [EOL]         case MINUTE_OF_HOUR: [EOL]             return MINUTE_OF_HOUR_TYPE; [EOL]         case SECOND_OF_DAY: [EOL]             return SECOND_OF_DAY_TYPE; [EOL]         case SECOND_OF_MINUTE: [EOL]             return SECOND_OF_MINUTE_TYPE; [EOL]         case MILLIS_OF_DAY: [EOL]             return MILLIS_OF_DAY_TYPE; [EOL]         case MILLIS_OF_SECOND: [EOL]             return MILLIS_OF_SECOND_TYPE; [EOL]         default: [EOL]             return this; [EOL]     } [EOL] }
private Object readResolve() { [EOL]     switch(iOrdinal) { [EOL]         case ERA: [EOL]             return ERA_TYPE; [EOL]         case YEAR_OF_ERA: [EOL]             return YEAR_OF_ERA_TYPE; [EOL]         case CENTURY_OF_ERA: [EOL]             return CENTURY_OF_ERA_TYPE; [EOL]         case YEAR_OF_CENTURY: [EOL]             return YEAR_OF_CENTURY_TYPE; [EOL]         case YEAR: [EOL]             return YEAR_TYPE; [EOL]         case DAY_OF_YEAR: [EOL]             return DAY_OF_YEAR_TYPE; [EOL]         case MONTH_OF_YEAR: [EOL]             return MONTH_OF_YEAR_TYPE; [EOL]         case DAY_OF_MONTH: [EOL]             return DAY_OF_MONTH_TYPE; [EOL]         case WEEKYEAR_OF_CENTURY: [EOL]             return WEEKYEAR_OF_CENTURY_TYPE; [EOL]         case WEEKYEAR: [EOL]             return WEEKYEAR_TYPE; [EOL]         case WEEK_OF_WEEKYEAR: [EOL]             return WEEK_OF_WEEKYEAR_TYPE; [EOL]         case DAY_OF_WEEK: [EOL]             return DAY_OF_WEEK_TYPE; [EOL]         case HALFDAY_OF_DAY: [EOL]             return HALFDAY_OF_DAY_TYPE; [EOL]         case HOUR_OF_HALFDAY: [EOL]             return HOUR_OF_HALFDAY_TYPE; [EOL]         case CLOCKHOUR_OF_HALFDAY: [EOL]             return CLOCKHOUR_OF_HALFDAY_TYPE; [EOL]         case CLOCKHOUR_OF_DAY: [EOL]             return CLOCKHOUR_OF_DAY_TYPE; [EOL]         case HOUR_OF_DAY: [EOL]             return HOUR_OF_DAY_TYPE; [EOL]         case MINUTE_OF_DAY: [EOL]             return MINUTE_OF_DAY_TYPE; [EOL]         case MINUTE_OF_HOUR: [EOL]             return MINUTE_OF_HOUR_TYPE; [EOL]         case SECOND_OF_DAY: [EOL]             return SECOND_OF_DAY_TYPE; [EOL]         case SECOND_OF_MINUTE: [EOL]             return SECOND_OF_MINUTE_TYPE; [EOL]         case MILLIS_OF_DAY: [EOL]             return MILLIS_OF_DAY_TYPE; [EOL]         case MILLIS_OF_SECOND: [EOL]             return MILLIS_OF_SECOND_TYPE; [EOL]         default: [EOL]             return this; [EOL]     } [EOL] }
private Object readResolve() { [EOL]     switch(iOrdinal) { [EOL]         case ERA: [EOL]             return ERA_TYPE; [EOL]         case YEAR_OF_ERA: [EOL]             return YEAR_OF_ERA_TYPE; [EOL]         case CENTURY_OF_ERA: [EOL]             return CENTURY_OF_ERA_TYPE; [EOL]         case YEAR_OF_CENTURY: [EOL]             return YEAR_OF_CENTURY_TYPE; [EOL]         case YEAR: [EOL]             return YEAR_TYPE; [EOL]         case DAY_OF_YEAR: [EOL]             return DAY_OF_YEAR_TYPE; [EOL]         case MONTH_OF_YEAR: [EOL]             return MONTH_OF_YEAR_TYPE; [EOL]         case DAY_OF_MONTH: [EOL]             return DAY_OF_MONTH_TYPE; [EOL]         case WEEKYEAR_OF_CENTURY: [EOL]             return WEEKYEAR_OF_CENTURY_TYPE; [EOL]         case WEEKYEAR: [EOL]             return WEEKYEAR_TYPE; [EOL]         case WEEK_OF_WEEKYEAR: [EOL]             return WEEK_OF_WEEKYEAR_TYPE; [EOL]         case DAY_OF_WEEK: [EOL]             return DAY_OF_WEEK_TYPE; [EOL]         case HALFDAY_OF_DAY: [EOL]             return HALFDAY_OF_DAY_TYPE; [EOL]         case HOUR_OF_HALFDAY: [EOL]             return HOUR_OF_HALFDAY_TYPE; [EOL]         case CLOCKHOUR_OF_HALFDAY: [EOL]             return CLOCKHOUR_OF_HALFDAY_TYPE; [EOL]         case CLOCKHOUR_OF_DAY: [EOL]             return CLOCKHOUR_OF_DAY_TYPE; [EOL]         case HOUR_OF_DAY: [EOL]             return HOUR_OF_DAY_TYPE; [EOL]         case MINUTE_OF_DAY: [EOL]             return MINUTE_OF_DAY_TYPE; [EOL]         case MINUTE_OF_HOUR: [EOL]             return MINUTE_OF_HOUR_TYPE; [EOL]         case SECOND_OF_DAY: [EOL]             return SECOND_OF_DAY_TYPE; [EOL]         case SECOND_OF_MINUTE: [EOL]             return SECOND_OF_MINUTE_TYPE; [EOL]         case MILLIS_OF_DAY: [EOL]             return MILLIS_OF_DAY_TYPE; [EOL]         case MILLIS_OF_SECOND: [EOL]             return MILLIS_OF_SECOND_TYPE; [EOL]         default: [EOL]             return this; [EOL]     } [EOL] }
private Object readResolve() { [EOL]     switch(iOrdinal) { [EOL]         case ERA: [EOL]             return ERA_TYPE; [EOL]         case YEAR_OF_ERA: [EOL]             return YEAR_OF_ERA_TYPE; [EOL]         case CENTURY_OF_ERA: [EOL]             return CENTURY_OF_ERA_TYPE; [EOL]         case YEAR_OF_CENTURY: [EOL]             return YEAR_OF_CENTURY_TYPE; [EOL]         case YEAR: [EOL]             return YEAR_TYPE; [EOL]         case DAY_OF_YEAR: [EOL]             return DAY_OF_YEAR_TYPE; [EOL]         case MONTH_OF_YEAR: [EOL]             return MONTH_OF_YEAR_TYPE; [EOL]         case DAY_OF_MONTH: [EOL]             return DAY_OF_MONTH_TYPE; [EOL]         case WEEKYEAR_OF_CENTURY: [EOL]             return WEEKYEAR_OF_CENTURY_TYPE; [EOL]         case WEEKYEAR: [EOL]             return WEEKYEAR_TYPE; [EOL]         case WEEK_OF_WEEKYEAR: [EOL]             return WEEK_OF_WEEKYEAR_TYPE; [EOL]         case DAY_OF_WEEK: [EOL]             return DAY_OF_WEEK_TYPE; [EOL]         case HALFDAY_OF_DAY: [EOL]             return HALFDAY_OF_DAY_TYPE; [EOL]         case HOUR_OF_HALFDAY: [EOL]             return HOUR_OF_HALFDAY_TYPE; [EOL]         case CLOCKHOUR_OF_HALFDAY: [EOL]             return CLOCKHOUR_OF_HALFDAY_TYPE; [EOL]         case CLOCKHOUR_OF_DAY: [EOL]             return CLOCKHOUR_OF_DAY_TYPE; [EOL]         case HOUR_OF_DAY: [EOL]             return HOUR_OF_DAY_TYPE; [EOL]         case MINUTE_OF_DAY: [EOL]             return MINUTE_OF_DAY_TYPE; [EOL]         case MINUTE_OF_HOUR: [EOL]             return MINUTE_OF_HOUR_TYPE; [EOL]         case SECOND_OF_DAY: [EOL]             return SECOND_OF_DAY_TYPE; [EOL]         case SECOND_OF_MINUTE: [EOL]             return SECOND_OF_MINUTE_TYPE; [EOL]         case MILLIS_OF_DAY: [EOL]             return MILLIS_OF_DAY_TYPE; [EOL]         case MILLIS_OF_SECOND: [EOL]             return MILLIS_OF_SECOND_TYPE; [EOL]         default: [EOL]             return this; [EOL]     } [EOL] }
private Object readResolve() { [EOL]     switch(iOrdinal) { [EOL]         case ERA: [EOL]             return ERA_TYPE; [EOL]         case YEAR_OF_ERA: [EOL]             return YEAR_OF_ERA_TYPE; [EOL]         case CENTURY_OF_ERA: [EOL]             return CENTURY_OF_ERA_TYPE; [EOL]         case YEAR_OF_CENTURY: [EOL]             return YEAR_OF_CENTURY_TYPE; [EOL]         case YEAR: [EOL]             return YEAR_TYPE; [EOL]         case DAY_OF_YEAR: [EOL]             return DAY_OF_YEAR_TYPE; [EOL]         case MONTH_OF_YEAR: [EOL]             return MONTH_OF_YEAR_TYPE; [EOL]         case DAY_OF_MONTH: [EOL]             return DAY_OF_MONTH_TYPE; [EOL]         case WEEKYEAR_OF_CENTURY: [EOL]             return WEEKYEAR_OF_CENTURY_TYPE; [EOL]         case WEEKYEAR: [EOL]             return WEEKYEAR_TYPE; [EOL]         case WEEK_OF_WEEKYEAR: [EOL]             return WEEK_OF_WEEKYEAR_TYPE; [EOL]         case DAY_OF_WEEK: [EOL]             return DAY_OF_WEEK_TYPE; [EOL]         case HALFDAY_OF_DAY: [EOL]             return HALFDAY_OF_DAY_TYPE; [EOL]         case HOUR_OF_HALFDAY: [EOL]             return HOUR_OF_HALFDAY_TYPE; [EOL]         case CLOCKHOUR_OF_HALFDAY: [EOL]             return CLOCKHOUR_OF_HALFDAY_TYPE; [EOL]         case CLOCKHOUR_OF_DAY: [EOL]             return CLOCKHOUR_OF_DAY_TYPE; [EOL]         case HOUR_OF_DAY: [EOL]             return HOUR_OF_DAY_TYPE; [EOL]         case MINUTE_OF_DAY: [EOL]             return MINUTE_OF_DAY_TYPE; [EOL]         case MINUTE_OF_HOUR: [EOL]             return MINUTE_OF_HOUR_TYPE; [EOL]         case SECOND_OF_DAY: [EOL]             return SECOND_OF_DAY_TYPE; [EOL]         case SECOND_OF_MINUTE: [EOL]             return SECOND_OF_MINUTE_TYPE; [EOL]         case MILLIS_OF_DAY: [EOL]             return MILLIS_OF_DAY_TYPE; [EOL]         case MILLIS_OF_SECOND: [EOL]             return MILLIS_OF_SECOND_TYPE; [EOL]         default: [EOL]             return this; [EOL]     } [EOL] }
private Object readResolve() { [EOL]     switch(iOrdinal) { [EOL]         case ERA: [EOL]             return ERA_TYPE; [EOL]         case YEAR_OF_ERA: [EOL]             return YEAR_OF_ERA_TYPE; [EOL]         case CENTURY_OF_ERA: [EOL]             return CENTURY_OF_ERA_TYPE; [EOL]         case YEAR_OF_CENTURY: [EOL]             return YEAR_OF_CENTURY_TYPE; [EOL]         case YEAR: [EOL]             return YEAR_TYPE; [EOL]         case DAY_OF_YEAR: [EOL]             return DAY_OF_YEAR_TYPE; [EOL]         case MONTH_OF_YEAR: [EOL]             return MONTH_OF_YEAR_TYPE; [EOL]         case DAY_OF_MONTH: [EOL]             return DAY_OF_MONTH_TYPE; [EOL]         case WEEKYEAR_OF_CENTURY: [EOL]             return WEEKYEAR_OF_CENTURY_TYPE; [EOL]         case WEEKYEAR: [EOL]             return WEEKYEAR_TYPE; [EOL]         case WEEK_OF_WEEKYEAR: [EOL]             return WEEK_OF_WEEKYEAR_TYPE; [EOL]         case DAY_OF_WEEK: [EOL]             return DAY_OF_WEEK_TYPE; [EOL]         case HALFDAY_OF_DAY: [EOL]             return HALFDAY_OF_DAY_TYPE; [EOL]         case HOUR_OF_HALFDAY: [EOL]             return HOUR_OF_HALFDAY_TYPE; [EOL]         case CLOCKHOUR_OF_HALFDAY: [EOL]             return CLOCKHOUR_OF_HALFDAY_TYPE; [EOL]         case CLOCKHOUR_OF_DAY: [EOL]             return CLOCKHOUR_OF_DAY_TYPE; [EOL]         case HOUR_OF_DAY: [EOL]             return HOUR_OF_DAY_TYPE; [EOL]         case MINUTE_OF_DAY: [EOL]             return MINUTE_OF_DAY_TYPE; [EOL]         case MINUTE_OF_HOUR: [EOL]             return MINUTE_OF_HOUR_TYPE; [EOL]         case SECOND_OF_DAY: [EOL]             return SECOND_OF_DAY_TYPE; [EOL]         case SECOND_OF_MINUTE: [EOL]             return SECOND_OF_MINUTE_TYPE; [EOL]         case MILLIS_OF_DAY: [EOL]             return MILLIS_OF_DAY_TYPE; [EOL]         case MILLIS_OF_SECOND: [EOL]             return MILLIS_OF_SECOND_TYPE; [EOL]         default: [EOL]             return this; [EOL]     } [EOL] }
private Object readResolve() { [EOL]     switch(iOrdinal) { [EOL]         case ERA: [EOL]             return ERA_TYPE; [EOL]         case YEAR_OF_ERA: [EOL]             return YEAR_OF_ERA_TYPE; [EOL]         case CENTURY_OF_ERA: [EOL]             return CENTURY_OF_ERA_TYPE; [EOL]         case YEAR_OF_CENTURY: [EOL]             return YEAR_OF_CENTURY_TYPE; [EOL]         case YEAR: [EOL]             return YEAR_TYPE; [EOL]         case DAY_OF_YEAR: [EOL]             return DAY_OF_YEAR_TYPE; [EOL]         case MONTH_OF_YEAR: [EOL]             return MONTH_OF_YEAR_TYPE; [EOL]         case DAY_OF_MONTH: [EOL]             return DAY_OF_MONTH_TYPE; [EOL]         case WEEKYEAR_OF_CENTURY: [EOL]             return WEEKYEAR_OF_CENTURY_TYPE; [EOL]         case WEEKYEAR: [EOL]             return WEEKYEAR_TYPE; [EOL]         case WEEK_OF_WEEKYEAR: [EOL]             return WEEK_OF_WEEKYEAR_TYPE; [EOL]         case DAY_OF_WEEK: [EOL]             return DAY_OF_WEEK_TYPE; [EOL]         case HALFDAY_OF_DAY: [EOL]             return HALFDAY_OF_DAY_TYPE; [EOL]         case HOUR_OF_HALFDAY: [EOL]             return HOUR_OF_HALFDAY_TYPE; [EOL]         case CLOCKHOUR_OF_HALFDAY: [EOL]             return CLOCKHOUR_OF_HALFDAY_TYPE; [EOL]         case CLOCKHOUR_OF_DAY: [EOL]             return CLOCKHOUR_OF_DAY_TYPE; [EOL]         case HOUR_OF_DAY: [EOL]             return HOUR_OF_DAY_TYPE; [EOL]         case MINUTE_OF_DAY: [EOL]             return MINUTE_OF_DAY_TYPE; [EOL]         case MINUTE_OF_HOUR: [EOL]             return MINUTE_OF_HOUR_TYPE; [EOL]         case SECOND_OF_DAY: [EOL]             return SECOND_OF_DAY_TYPE; [EOL]         case SECOND_OF_MINUTE: [EOL]             return SECOND_OF_MINUTE_TYPE; [EOL]         case MILLIS_OF_DAY: [EOL]             return MILLIS_OF_DAY_TYPE; [EOL]         case MILLIS_OF_SECOND: [EOL]             return MILLIS_OF_SECOND_TYPE; [EOL]         default: [EOL]             return this; [EOL]     } [EOL] }
private Object readResolve() { [EOL]     switch(iOrdinal) { [EOL]         case ERA: [EOL]             return ERA_TYPE; [EOL]         case YEAR_OF_ERA: [EOL]             return YEAR_OF_ERA_TYPE; [EOL]         case CENTURY_OF_ERA: [EOL]             return CENTURY_OF_ERA_TYPE; [EOL]         case YEAR_OF_CENTURY: [EOL]             return YEAR_OF_CENTURY_TYPE; [EOL]         case YEAR: [EOL]             return YEAR_TYPE; [EOL]         case DAY_OF_YEAR: [EOL]             return DAY_OF_YEAR_TYPE; [EOL]         case MONTH_OF_YEAR: [EOL]             return MONTH_OF_YEAR_TYPE; [EOL]         case DAY_OF_MONTH: [EOL]             return DAY_OF_MONTH_TYPE; [EOL]         case WEEKYEAR_OF_CENTURY: [EOL]             return WEEKYEAR_OF_CENTURY_TYPE; [EOL]         case WEEKYEAR: [EOL]             return WEEKYEAR_TYPE; [EOL]         case WEEK_OF_WEEKYEAR: [EOL]             return WEEK_OF_WEEKYEAR_TYPE; [EOL]         case DAY_OF_WEEK: [EOL]             return DAY_OF_WEEK_TYPE; [EOL]         case HALFDAY_OF_DAY: [EOL]             return HALFDAY_OF_DAY_TYPE; [EOL]         case HOUR_OF_HALFDAY: [EOL]             return HOUR_OF_HALFDAY_TYPE; [EOL]         case CLOCKHOUR_OF_HALFDAY: [EOL]             return CLOCKHOUR_OF_HALFDAY_TYPE; [EOL]         case CLOCKHOUR_OF_DAY: [EOL]             return CLOCKHOUR_OF_DAY_TYPE; [EOL]         case HOUR_OF_DAY: [EOL]             return HOUR_OF_DAY_TYPE; [EOL]         case MINUTE_OF_DAY: [EOL]             return MINUTE_OF_DAY_TYPE; [EOL]         case MINUTE_OF_HOUR: [EOL]             return MINUTE_OF_HOUR_TYPE; [EOL]         case SECOND_OF_DAY: [EOL]             return SECOND_OF_DAY_TYPE; [EOL]         case SECOND_OF_MINUTE: [EOL]             return SECOND_OF_MINUTE_TYPE; [EOL]         case MILLIS_OF_DAY: [EOL]             return MILLIS_OF_DAY_TYPE; [EOL]         case MILLIS_OF_SECOND: [EOL]             return MILLIS_OF_SECOND_TYPE; [EOL]         default: [EOL]             return this; [EOL]     } [EOL] }
private Object readResolve() { [EOL]     switch(iOrdinal) { [EOL]         case ERA: [EOL]             return ERA_TYPE; [EOL]         case YEAR_OF_ERA: [EOL]             return YEAR_OF_ERA_TYPE; [EOL]         case CENTURY_OF_ERA: [EOL]             return CENTURY_OF_ERA_TYPE; [EOL]         case YEAR_OF_CENTURY: [EOL]             return YEAR_OF_CENTURY_TYPE; [EOL]         case YEAR: [EOL]             return YEAR_TYPE; [EOL]         case DAY_OF_YEAR: [EOL]             return DAY_OF_YEAR_TYPE; [EOL]         case MONTH_OF_YEAR: [EOL]             return MONTH_OF_YEAR_TYPE; [EOL]         case DAY_OF_MONTH: [EOL]             return DAY_OF_MONTH_TYPE; [EOL]         case WEEKYEAR_OF_CENTURY: [EOL]             return WEEKYEAR_OF_CENTURY_TYPE; [EOL]         case WEEKYEAR: [EOL]             return WEEKYEAR_TYPE; [EOL]         case WEEK_OF_WEEKYEAR: [EOL]             return WEEK_OF_WEEKYEAR_TYPE; [EOL]         case DAY_OF_WEEK: [EOL]             return DAY_OF_WEEK_TYPE; [EOL]         case HALFDAY_OF_DAY: [EOL]             return HALFDAY_OF_DAY_TYPE; [EOL]         case HOUR_OF_HALFDAY: [EOL]             return HOUR_OF_HALFDAY_TYPE; [EOL]         case CLOCKHOUR_OF_HALFDAY: [EOL]             return CLOCKHOUR_OF_HALFDAY_TYPE; [EOL]         case CLOCKHOUR_OF_DAY: [EOL]             return CLOCKHOUR_OF_DAY_TYPE; [EOL]         case HOUR_OF_DAY: [EOL]             return HOUR_OF_DAY_TYPE; [EOL]         case MINUTE_OF_DAY: [EOL]             return MINUTE_OF_DAY_TYPE; [EOL]         case MINUTE_OF_HOUR: [EOL]             return MINUTE_OF_HOUR_TYPE; [EOL]         case SECOND_OF_DAY: [EOL]             return SECOND_OF_DAY_TYPE; [EOL]         case SECOND_OF_MINUTE: [EOL]             return SECOND_OF_MINUTE_TYPE; [EOL]         case MILLIS_OF_DAY: [EOL]             return MILLIS_OF_DAY_TYPE; [EOL]         case MILLIS_OF_SECOND: [EOL]             return MILLIS_OF_SECOND_TYPE; [EOL]         default: [EOL]             return this; [EOL]     } [EOL] }
private Object readResolve() { [EOL]     switch(iOrdinal) { [EOL]         case ERA: [EOL]             return ERA_TYPE; [EOL]         case YEAR_OF_ERA: [EOL]             return YEAR_OF_ERA_TYPE; [EOL]         case CENTURY_OF_ERA: [EOL]             return CENTURY_OF_ERA_TYPE; [EOL]         case YEAR_OF_CENTURY: [EOL]             return YEAR_OF_CENTURY_TYPE; [EOL]         case YEAR: [EOL]             return YEAR_TYPE; [EOL]         case DAY_OF_YEAR: [EOL]             return DAY_OF_YEAR_TYPE; [EOL]         case MONTH_OF_YEAR: [EOL]             return MONTH_OF_YEAR_TYPE; [EOL]         case DAY_OF_MONTH: [EOL]             return DAY_OF_MONTH_TYPE; [EOL]         case WEEKYEAR_OF_CENTURY: [EOL]             return WEEKYEAR_OF_CENTURY_TYPE; [EOL]         case WEEKYEAR: [EOL]             return WEEKYEAR_TYPE; [EOL]         case WEEK_OF_WEEKYEAR: [EOL]             return WEEK_OF_WEEKYEAR_TYPE; [EOL]         case DAY_OF_WEEK: [EOL]             return DAY_OF_WEEK_TYPE; [EOL]         case HALFDAY_OF_DAY: [EOL]             return HALFDAY_OF_DAY_TYPE; [EOL]         case HOUR_OF_HALFDAY: [EOL]             return HOUR_OF_HALFDAY_TYPE; [EOL]         case CLOCKHOUR_OF_HALFDAY: [EOL]             return CLOCKHOUR_OF_HALFDAY_TYPE; [EOL]         case CLOCKHOUR_OF_DAY: [EOL]             return CLOCKHOUR_OF_DAY_TYPE; [EOL]         case HOUR_OF_DAY: [EOL]             return HOUR_OF_DAY_TYPE; [EOL]         case MINUTE_OF_DAY: [EOL]             return MINUTE_OF_DAY_TYPE; [EOL]         case MINUTE_OF_HOUR: [EOL]             return MINUTE_OF_HOUR_TYPE; [EOL]         case SECOND_OF_DAY: [EOL]             return SECOND_OF_DAY_TYPE; [EOL]         case SECOND_OF_MINUTE: [EOL]             return SECOND_OF_MINUTE_TYPE; [EOL]         case MILLIS_OF_DAY: [EOL]             return MILLIS_OF_DAY_TYPE; [EOL]         case MILLIS_OF_SECOND: [EOL]             return MILLIS_OF_SECOND_TYPE; [EOL]         default: [EOL]             return this; [EOL]     } [EOL] }
private Object readResolve() { [EOL]     switch(iOrdinal) { [EOL]         case ERA: [EOL]             return ERA_TYPE; [EOL]         case YEAR_OF_ERA: [EOL]             return YEAR_OF_ERA_TYPE; [EOL]         case CENTURY_OF_ERA: [EOL]             return CENTURY_OF_ERA_TYPE; [EOL]         case YEAR_OF_CENTURY: [EOL]             return YEAR_OF_CENTURY_TYPE; [EOL]         case YEAR: [EOL]             return YEAR_TYPE; [EOL]         case DAY_OF_YEAR: [EOL]             return DAY_OF_YEAR_TYPE; [EOL]         case MONTH_OF_YEAR: [EOL]             return MONTH_OF_YEAR_TYPE; [EOL]         case DAY_OF_MONTH: [EOL]             return DAY_OF_MONTH_TYPE; [EOL]         case WEEKYEAR_OF_CENTURY: [EOL]             return WEEKYEAR_OF_CENTURY_TYPE; [EOL]         case WEEKYEAR: [EOL]             return WEEKYEAR_TYPE; [EOL]         case WEEK_OF_WEEKYEAR: [EOL]             return WEEK_OF_WEEKYEAR_TYPE; [EOL]         case DAY_OF_WEEK: [EOL]             return DAY_OF_WEEK_TYPE; [EOL]         case HALFDAY_OF_DAY: [EOL]             return HALFDAY_OF_DAY_TYPE; [EOL]         case HOUR_OF_HALFDAY: [EOL]             return HOUR_OF_HALFDAY_TYPE; [EOL]         case CLOCKHOUR_OF_HALFDAY: [EOL]             return CLOCKHOUR_OF_HALFDAY_TYPE; [EOL]         case CLOCKHOUR_OF_DAY: [EOL]             return CLOCKHOUR_OF_DAY_TYPE; [EOL]         case HOUR_OF_DAY: [EOL]             return HOUR_OF_DAY_TYPE; [EOL]         case MINUTE_OF_DAY: [EOL]             return MINUTE_OF_DAY_TYPE; [EOL]         case MINUTE_OF_HOUR: [EOL]             return MINUTE_OF_HOUR_TYPE; [EOL]         case SECOND_OF_DAY: [EOL]             return SECOND_OF_DAY_TYPE; [EOL]         case SECOND_OF_MINUTE: [EOL]             return SECOND_OF_MINUTE_TYPE; [EOL]         case MILLIS_OF_DAY: [EOL]             return MILLIS_OF_DAY_TYPE; [EOL]         case MILLIS_OF_SECOND: [EOL]             return MILLIS_OF_SECOND_TYPE; [EOL]         default: [EOL]             return this; [EOL]     } [EOL] }
public Duration toDuration() { [EOL]     return new Duration(getMillis()); [EOL] }
public Duration toDuration() { [EOL]     return new Duration(getMillis()); [EOL] }
public Duration toDuration() { [EOL]     return new Duration(getMillis()); [EOL] }
@ToString [EOL] public String toString() { [EOL]     long millis = getMillis(); [EOL]     StringBuffer buf = new StringBuffer(); [EOL]     buf.append("PT"); [EOL]     boolean negative = (millis < 0); [EOL]     FormatUtils.appendUnpaddedInteger(buf, millis); [EOL]     while (buf.length() < (negative ? 7 : 6)) { [EOL]         buf.insert(negative ? 3 : 2, "0"); [EOL]     } [EOL]     if ((millis / 1000) * 1000 == millis) { [EOL]         buf.setLength(buf.length() - 3); [EOL]     } else { [EOL]         buf.insert(buf.length() - 3, "."); [EOL]     } [EOL]     buf.append('S'); [EOL]     return buf.toString(); [EOL] }
public long getDurationMillis(Object object) { [EOL]     return (((ReadableInterval) object)).toDurationMillis(); [EOL] }
public long getDurationMillis(Object object) { [EOL]     return (((ReadableInterval) object)).toDurationMillis(); [EOL] }
private GJLocaleSymbols(Locale locale) { [EOL]     iLocale = new WeakReference<Locale>(locale); [EOL]     DateFormatSymbols dfs = DateTimeUtils.getDateFormatSymbols(locale); [EOL]     iEras = dfs.getEras(); [EOL]     iDaysOfWeek = realignDaysOfWeek(dfs.getWeekdays()); [EOL]     iShortDaysOfWeek = realignDaysOfWeek(dfs.getShortWeekdays()); [EOL]     iMonths = realignMonths(dfs.getMonths()); [EOL]     iShortMonths = realignMonths(dfs.getShortMonths()); [EOL]     iHalfday = dfs.getAmPmStrings(); [EOL]     Integer[] integers = new Integer[13]; [EOL]     for (int i = 0; i < 13; i++) { [EOL]         integers[i] = Integer.valueOf(i); [EOL]     } [EOL]     iParseEras = new TreeMap<String, Integer>(String.CASE_INSENSITIVE_ORDER); [EOL]     addSymbols(iParseEras, iEras, integers); [EOL]     if ("en".equals(locale.getLanguage())) { [EOL]         iParseEras.put("BCE", integers[0]); [EOL]         iParseEras.put("CE", integers[1]); [EOL]     } [EOL]     iParseDaysOfWeek = new TreeMap<String, Integer>(String.CASE_INSENSITIVE_ORDER); [EOL]     addSymbols(iParseDaysOfWeek, iDaysOfWeek, integers); [EOL]     addSymbols(iParseDaysOfWeek, iShortDaysOfWeek, integers); [EOL]     addNumerals(iParseDaysOfWeek, 1, 7, integers); [EOL]     iParseMonths = new TreeMap<String, Integer>(String.CASE_INSENSITIVE_ORDER); [EOL]     addSymbols(iParseMonths, iMonths, integers); [EOL]     addSymbols(iParseMonths, iShortMonths, integers); [EOL]     addNumerals(iParseMonths, 1, 12, integers); [EOL]     iMaxEraLength = maxLength(iEras); [EOL]     iMaxDayOfWeekLength = maxLength(iDaysOfWeek); [EOL]     iMaxShortDayOfWeekLength = maxLength(iShortDaysOfWeek); [EOL]     iMaxMonthLength = maxLength(iMonths); [EOL]     iMaxShortMonthLength = maxLength(iShortMonths); [EOL]     iMaxHalfdayLength = maxLength(iHalfday); [EOL] }
private GJLocaleSymbols(Locale locale) { [EOL]     iLocale = new WeakReference<Locale>(locale); [EOL]     DateFormatSymbols dfs = DateTimeUtils.getDateFormatSymbols(locale); [EOL]     iEras = dfs.getEras(); [EOL]     iDaysOfWeek = realignDaysOfWeek(dfs.getWeekdays()); [EOL]     iShortDaysOfWeek = realignDaysOfWeek(dfs.getShortWeekdays()); [EOL]     iMonths = realignMonths(dfs.getMonths()); [EOL]     iShortMonths = realignMonths(dfs.getShortMonths()); [EOL]     iHalfday = dfs.getAmPmStrings(); [EOL]     Integer[] integers = new Integer[13]; [EOL]     for (int i = 0; i < 13; i++) { [EOL]         integers[i] = Integer.valueOf(i); [EOL]     } [EOL]     iParseEras = new TreeMap<String, Integer>(String.CASE_INSENSITIVE_ORDER); [EOL]     addSymbols(iParseEras, iEras, integers); [EOL]     if ("en".equals(locale.getLanguage())) { [EOL]         iParseEras.put("BCE", integers[0]); [EOL]         iParseEras.put("CE", integers[1]); [EOL]     } [EOL]     iParseDaysOfWeek = new TreeMap<String, Integer>(String.CASE_INSENSITIVE_ORDER); [EOL]     addSymbols(iParseDaysOfWeek, iDaysOfWeek, integers); [EOL]     addSymbols(iParseDaysOfWeek, iShortDaysOfWeek, integers); [EOL]     addNumerals(iParseDaysOfWeek, 1, 7, integers); [EOL]     iParseMonths = new TreeMap<String, Integer>(String.CASE_INSENSITIVE_ORDER); [EOL]     addSymbols(iParseMonths, iMonths, integers); [EOL]     addSymbols(iParseMonths, iShortMonths, integers); [EOL]     addNumerals(iParseMonths, 1, 12, integers); [EOL]     iMaxEraLength = maxLength(iEras); [EOL]     iMaxDayOfWeekLength = maxLength(iDaysOfWeek); [EOL]     iMaxShortDayOfWeekLength = maxLength(iShortDaysOfWeek); [EOL]     iMaxMonthLength = maxLength(iMonths); [EOL]     iMaxShortMonthLength = maxLength(iShortMonths); [EOL]     iMaxHalfdayLength = maxLength(iHalfday); [EOL] }
public boolean equals(Object readableInstant) { [EOL]     if (this == readableInstant) { [EOL]         return true; [EOL]     } [EOL]     if (readableInstant instanceof ReadableInstant == false) { [EOL]         return false; [EOL]     } [EOL]     ReadableInstant otherInstant = (ReadableInstant) readableInstant; [EOL]     return getMillis() == otherInstant.getMillis() && FieldUtils.equals(getChronology(), otherInstant.getChronology()); [EOL] }
public boolean equals(Object readableInstant) { [EOL]     if (this == readableInstant) { [EOL]         return true; [EOL]     } [EOL]     if (readableInstant instanceof ReadableInstant == false) { [EOL]         return false; [EOL]     } [EOL]     ReadableInstant otherInstant = (ReadableInstant) readableInstant; [EOL]     return getMillis() == otherInstant.getMillis() && FieldUtils.equals(getChronology(), otherInstant.getChronology()); [EOL] }
public boolean equals(Object readableInstant) { [EOL]     if (this == readableInstant) { [EOL]         return true; [EOL]     } [EOL]     if (readableInstant instanceof ReadableInstant == false) { [EOL]         return false; [EOL]     } [EOL]     ReadableInstant otherInstant = (ReadableInstant) readableInstant; [EOL]     return getMillis() == otherInstant.getMillis() && FieldUtils.equals(getChronology(), otherInstant.getChronology()); [EOL] }
public boolean equals(Object readableInstant) { [EOL]     if (this == readableInstant) { [EOL]         return true; [EOL]     } [EOL]     if (readableInstant instanceof ReadableInstant == false) { [EOL]         return false; [EOL]     } [EOL]     ReadableInstant otherInstant = (ReadableInstant) readableInstant; [EOL]     return getMillis() == otherInstant.getMillis() && FieldUtils.equals(getChronology(), otherInstant.getChronology()); [EOL] }
public boolean equals(Object readableInstant) { [EOL]     if (this == readableInstant) { [EOL]         return true; [EOL]     } [EOL]     if (readableInstant instanceof ReadableInstant == false) { [EOL]         return false; [EOL]     } [EOL]     ReadableInstant otherInstant = (ReadableInstant) readableInstant; [EOL]     return getMillis() == otherInstant.getMillis() && FieldUtils.equals(getChronology(), otherInstant.getChronology()); [EOL] }
public int hashCode() { [EOL]     return ((int) (getMillis() ^ (getMillis() >>> 32))) + (getChronology().hashCode()); [EOL] }
public String toString(DateTimeFormatter formatter) { [EOL]     if (formatter == null) { [EOL]         return toString(); [EOL]     } [EOL]     return formatter.print(this); [EOL] }
public String toString(DateTimeFormatter formatter) { [EOL]     if (formatter == null) { [EOL]         return toString(); [EOL]     } [EOL]     return formatter.print(this); [EOL] }
@Override [EOL] public DurationField getRangeDurationField() { [EOL]     if (iRangeDurationField != null) { [EOL]         return iRangeDurationField; [EOL]     } [EOL]     return super.getRangeDurationField(); [EOL] }
@Override [EOL] public DurationField getRangeDurationField() { [EOL]     if (iRangeDurationField != null) { [EOL]         return iRangeDurationField; [EOL]     } [EOL]     return super.getRangeDurationField(); [EOL] }
public static MutableInterval parse(String str) { [EOL]     return new MutableInterval(str); [EOL] }
public static MutableInterval parse(String str) { [EOL]     return new MutableInterval(str); [EOL] }
public static MutableInterval parse(String str) { [EOL]     return new MutableInterval(str); [EOL] }
public MutableInterval(ReadablePeriod period, ReadableInstant end) { [EOL]     super(period, end); [EOL] }
public MutableInterval(ReadablePeriod period, ReadableInstant end) { [EOL]     super(period, end); [EOL] }
public MutableInterval(ReadablePeriod period, ReadableInstant end) { [EOL]     super(period, end); [EOL] }
public void setInterval(ReadableInterval interval) { [EOL]     if (interval == null) { [EOL]         throw new IllegalArgumentException("Interval must not be null"); [EOL]     } [EOL]     long startMillis = interval.getStartMillis(); [EOL]     long endMillis = interval.getEndMillis(); [EOL]     Chronology chrono = interval.getChronology(); [EOL]     super.setInterval(startMillis, endMillis, chrono); [EOL] }
public void setInterval(ReadableInterval interval) { [EOL]     if (interval == null) { [EOL]         throw new IllegalArgumentException("Interval must not be null"); [EOL]     } [EOL]     long startMillis = interval.getStartMillis(); [EOL]     long endMillis = interval.getEndMillis(); [EOL]     Chronology chrono = interval.getChronology(); [EOL]     super.setInterval(startMillis, endMillis, chrono); [EOL] }
public void setStart(ReadableInstant start) { [EOL]     long startMillis = DateTimeUtils.getInstantMillis(start); [EOL]     super.setInterval(startMillis, getEndMillis(), getChronology()); [EOL] }
public void setStart(ReadableInstant start) { [EOL]     long startMillis = DateTimeUtils.getInstantMillis(start); [EOL]     super.setInterval(startMillis, getEndMillis(), getChronology()); [EOL] }
public void setEndMillis(long endInstant) { [EOL]     super.setInterval(getStartMillis(), endInstant, getChronology()); [EOL] }
public void setEndMillis(long endInstant) { [EOL]     super.setInterval(getStartMillis(), endInstant, getChronology()); [EOL] }
public void setDurationAfterStart(ReadableDuration duration) { [EOL]     long durationMillis = DateTimeUtils.getDurationMillis(duration); [EOL]     setEndMillis(FieldUtils.safeAdd(getStartMillis(), durationMillis)); [EOL] }
public void setDurationAfterStart(ReadableDuration duration) { [EOL]     long durationMillis = DateTimeUtils.getDurationMillis(duration); [EOL]     setEndMillis(FieldUtils.safeAdd(getStartMillis(), durationMillis)); [EOL] }
public DateMidnight() { [EOL]     super(); [EOL] }
public DateMidnight withChronology(Chronology newChronology) { [EOL]     return (newChronology == getChronology() ? this : new DateMidnight(getMillis(), newChronology)); [EOL] }
public DateMidnight withChronology(Chronology newChronology) { [EOL]     return (newChronology == getChronology() ? this : new DateMidnight(getMillis(), newChronology)); [EOL] }
public DateMidnight withField(DateTimeFieldType fieldType, int value) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("Field must not be null"); [EOL]     } [EOL]     long instant = fieldType.getField(getChronology()).set(getMillis(), value); [EOL]     return withMillis(instant); [EOL] }
public DateMidnight withField(DateTimeFieldType fieldType, int value) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("Field must not be null"); [EOL]     } [EOL]     long instant = fieldType.getField(getChronology()).set(getMillis(), value); [EOL]     return withMillis(instant); [EOL] }
public DateMidnight withFieldAdded(DurationFieldType fieldType, int amount) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("Field must not be null"); [EOL]     } [EOL]     if (amount == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = fieldType.getField(getChronology()).add(getMillis(), amount); [EOL]     return withMillis(instant); [EOL] }
public DateMidnight withFieldAdded(DurationFieldType fieldType, int amount) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("Field must not be null"); [EOL]     } [EOL]     if (amount == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = fieldType.getField(getChronology()).add(getMillis(), amount); [EOL]     return withMillis(instant); [EOL] }
public DateMidnight withFieldAdded(DurationFieldType fieldType, int amount) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("Field must not be null"); [EOL]     } [EOL]     if (amount == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = fieldType.getField(getChronology()).add(getMillis(), amount); [EOL]     return withMillis(instant); [EOL] }
public DateMidnight plusWeeks(int weeks) { [EOL]     if (weeks == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().weeks().add(getMillis(), weeks); [EOL]     return withMillis(instant); [EOL] }
public DateMidnight plusWeeks(int weeks) { [EOL]     if (weeks == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().weeks().add(getMillis(), weeks); [EOL]     return withMillis(instant); [EOL] }
public DateMidnight plusWeeks(int weeks) { [EOL]     if (weeks == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().weeks().add(getMillis(), weeks); [EOL]     return withMillis(instant); [EOL] }
public DateMidnight minus(ReadableDuration duration) { [EOL]     return withDurationAdded(duration, -1); [EOL] }
public DateMidnight minus(ReadableDuration duration) { [EOL]     return withDurationAdded(duration, -1); [EOL] }
public DateMidnight minus(ReadablePeriod period) { [EOL]     return withPeriodAdded(period, -1); [EOL] }
public DateMidnight minus(ReadablePeriod period) { [EOL]     return withPeriodAdded(period, -1); [EOL] }
protected BasePartial(long instant) { [EOL]     this(instant, null); [EOL] }
protected BasePartial(long instant, Chronology chronology) { [EOL]     super(); [EOL]     chronology = DateTimeUtils.getChronology(chronology); [EOL]     iChronology = chronology.withUTC(); [EOL]     iValues = chronology.get(this, instant); [EOL] }
protected BasePartial(long instant, Chronology chronology) { [EOL]     super(); [EOL]     chronology = DateTimeUtils.getChronology(chronology); [EOL]     iChronology = chronology.withUTC(); [EOL]     iValues = chronology.get(this, instant); [EOL] }
protected BasePartial(int[] values, Chronology chronology) { [EOL]     super(); [EOL]     chronology = DateTimeUtils.getChronology(chronology); [EOL]     iChronology = chronology.withUTC(); [EOL]     chronology.validate(this, values); [EOL]     iValues = values; [EOL] }
protected BasePartial(int[] values, Chronology chronology) { [EOL]     super(); [EOL]     chronology = DateTimeUtils.getChronology(chronology); [EOL]     iChronology = chronology.withUTC(); [EOL]     chronology.validate(this, values); [EOL]     iValues = values; [EOL] }
public int getValue(int index) { [EOL]     return iValues[index]; [EOL] }
protected void setValue(int index, int value) { [EOL]     DateTimeField field = getField(index); [EOL]     int[] values = field.set(this, index, iValues, value); [EOL]     System.arraycopy(values, 0, iValues, 0, iValues.length); [EOL] }
protected void setValue(int index, int value) { [EOL]     DateTimeField field = getField(index); [EOL]     int[] values = field.set(this, index, iValues, value); [EOL]     System.arraycopy(values, 0, iValues, 0, iValues.length); [EOL] }
protected void setValues(int[] values) { [EOL]     getChronology().validate(this, values); [EOL]     System.arraycopy(values, 0, iValues, 0, iValues.length); [EOL] }
