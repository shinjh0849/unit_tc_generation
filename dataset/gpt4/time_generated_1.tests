public void testIndexOf_WithExistingType() { [EOL] DurationFieldType testType = DurationFieldType.minutes(); [EOL] int index = indexOf(testType); [EOL] assertTrue(index >= 0); [EOL] } [EOL] public void testIndexOf_WithNonExistingType() { [EOL] DurationFieldType testType = DurationFieldType.years(); [EOL] int index = indexOf(testType); [EOL] assertEquals(-1, index); [EOL] }
public void testCompareTo_SameInstance() { [EOL] ReadablePartial mockPartial = createMockPartial(); [EOL] int result = mockPartial.compareTo(mockPartial); [EOL] assertEquals(0, result); [EOL] } [EOL] public void testCompareTo_DifferentSize() { [EOL] ReadablePartial mockPartial1 = createMockPartialWithSize(2); [EOL] ReadablePartial mockPartial2 = createMockPartialWithSize(3); [EOL] try { [EOL] mockPartial1.compareTo(mockPartial2); [EOL] fail("Expected ClassCastException"); [EOL] } catch (ClassCastException e) { [EOL] } [EOL] } [EOL] public void testCompareTo_DifferentFieldTypes() { [EOL] ReadablePartial mockPartial1 = createMockPartialWithFieldTypes(new DateTimeFieldType[]{DateTimeFieldType.year(), DateTimeFieldType.monthOfYear()}); [EOL] ReadablePartial mockPartial2 = createMockPartialWithFieldTypes(new DateTimeFieldType[]{DateTimeFieldType.year(), DateTimeFieldType.dayOfMonth()}); [EOL] try { [EOL] mockPartial1.compareTo(mockPartial2); [EOL] fail("Expected ClassCastException"); [EOL] } catch (ClassCastException e) { [EOL] } [EOL] } [EOL] public void testCompareTo_GreaterValue() { [EOL] ReadablePartial mockPartial1 = createMockPartialWithValues(new int[]{2020, 5}); [EOL] ReadablePartial mockPartial2 = createMockPartialWithValues(new int[]{2020, 4}); [EOL] int result = mockPartial1.compareTo(mockPartial2); [EOL] assertEquals(1, result); [EOL] } [EOL] public void testCompareTo_LesserValue() { [EOL] ReadablePartial mockPartial1 = createMockPartialWithValues(new int[]{2020, 3}); [EOL] ReadablePartial mockPartial2 = createMockPartialWithValues(new int[]{2020, 4}); [EOL] int result = mockPartial1.compareTo(mockPartial2); [EOL] assertEquals(-1, result); [EOL] } [EOL] public void testCompareTo_EqualValue() { [EOL] ReadablePartial mockPartial1 = createMockPartialWithValues(new int[]{2020, 4}); [EOL] ReadablePartial mockPartial2 = createMockPartialWithValues(new int[]{2020, 4}); [EOL] int result = mockPartial1.compareTo(mockPartial2); [EOL] assertEquals(0, result); [EOL] }

public void testIsAfter_NullPartial_ThrowsIllegalArgumentException() { [EOL] try { [EOL] MyPartial myPartial = new MyPartial(); // Assuming MyPartial is a concrete implementation of ReadablePartial [EOL] myPartial.isAfter(null); [EOL] fail("Expected IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Partial cannot be null", e.getMessage()); [EOL] } [EOL] }
public void testIsAfter_PartialBefore_ReturnsFalse() { [EOL] MyPartial myPartial1 = new MyPartial(); // Assuming MyPartial is a concrete implementation of ReadablePartial [EOL] MyPartial myPartial2 = new MyPartial(); // Set up myPartial2 to be before myPartial1 [EOL] boolean result = myPartial1.isAfter(myPartial2); [EOL] assertFalse(result); [EOL] }
public void testIsAfter_PartialAfter_ReturnsTrue() { [EOL] MyPartial myPartial1 = new MyPartial(); // Assuming MyPartial is a concrete implementation of ReadablePartial [EOL] MyPartial myPartial2 = new MyPartial(); // Set up myPartial2 to be after myPartial1 [EOL] boolean result = myPartial1.isAfter(myPartial2); [EOL] assertTrue(result); [EOL] }
public void testYearMonthDayIntIntInt() { [EOL] YearMonthDay ymd = new YearMonthDay(2020, 1, 1); [EOL] assertEquals(2020, ymd.getYear()); [EOL] assertEquals(1, ymd.getMonthOfYear()); [EOL] assertEquals(1, ymd.getDayOfMonth()); [EOL] }
public void testYearMonthDayLong() { [EOL] long currentTimeMillis = System.currentTimeMillis(); [EOL] YearMonthDay ymd = new YearMonthDay(currentTimeMillis); [EOL] Calendar cal = Calendar.getInstance(); [EOL] cal.setTimeInMillis(currentTimeMillis); [EOL] assertEquals(cal.get(Calendar.YEAR), ymd.getYear()); [EOL] assertEquals(cal.get(Calendar.MONTH) + 1, ymd.getMonthOfYear()); // Calendar.MONTH is 0-based [EOL] assertEquals(cal.get(Calendar.DAY_OF_MONTH), ymd.getDayOfMonth()); [EOL] }
public void testYearMonthDayObject() { [EOL] Date date = new Date(); [EOL] YearMonthDay ymd = new YearMonthDay(date); [EOL] Calendar cal = Calendar.getInstance(); [EOL] cal.setTime(date); [EOL] assertEquals(cal.get(Calendar.YEAR), ymd.getYear()); [EOL] assertEquals(cal.get(Calendar.MONTH) + 1, ymd.getMonthOfYear()); // Calendar.MONTH is 0-based [EOL] assertEquals(cal.get(Calendar.DAY_OF_MONTH), ymd.getDayOfMonth()); [EOL] }
public void testYearMonthDayCalendarFields() { [EOL] Calendar calendar = Calendar.getInstance(); [EOL] YearMonthDay ymd = YearMonthDay.fromCalendarFields(calendar); [EOL] assertEquals(calendar.get(Calendar.YEAR), ymd.getYear()); [EOL] assertEquals(calendar.get(Calendar.MONTH) + 1, ymd.getMonthOfYear()); // Calendar.MONTH is 0-based [EOL] assertEquals(calendar.get(Calendar.DAY_OF_MONTH), ymd.getDayOfMonth()); [EOL] }
public void testYearMonthDayDateFields() { [EOL] Date date = new Date(); [EOL] YearMonthDay ymd = YearMonthDay.fromDateFields(date); [EOL] Calendar cal = Calendar.getInstance(); [EOL] cal.setTime(date); [EOL] assertEquals(cal.get(Calendar.YEAR), ymd.getYear()); [EOL] assertEquals(cal.get(Calendar.MONTH) + 1, ymd.getMonthOfYear()); // Calendar.MONTH is 0-based [EOL] assertEquals(cal.get(Calendar.DAY_OF_MONTH), ymd.getDayOfMonth()); [EOL] }
public void testYearMonthDayIntIntIntChronology() { [EOL] Chronology chrono = ISOChronology.getInstance(); [EOL] int year = 2020; [EOL] int month = 5; [EOL] int day = 20; [EOL] YearMonthDay ymd = new YearMonthDay(year, month, day, chrono); [EOL] assertEquals(year, ymd.getYear()); [EOL] assertEquals(month, ymd.getMonthOfYear()); [EOL] assertEquals(day, ymd.getDayOfMonth()); [EOL] assertSame(chrono, ymd.getChronology()); [EOL] }
public void testYearMonthDay() { [EOL] YearMonthDay ymd = new YearMonthDay(); [EOL] assertNotNull(ymd); [EOL] }
public void testYearMonthDayDateTimeZone() { [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/Paris"); [EOL] YearMonthDay ymd = new YearMonthDay(zone); [EOL] assertSame(zone, ymd.getChronology().getZone()); [EOL] }
public void testYearMonthDayChronology() { [EOL] Chronology chrono = ISOChronology.getInstanceUTC(); [EOL] YearMonthDay ymd = new YearMonthDay(chrono); [EOL] assertSame(chrono, ymd.getChronology()); [EOL] }
public void testYearMonthDayLong() { [EOL] long instant = System.currentTimeMillis(); [EOL] YearMonthDay ymd = new YearMonthDay(instant); [EOL] assertEquals(new YearMonthDay(), ymd); [EOL] }
public void testYearMonthDayLongChronology() { [EOL] long instant = System.currentTimeMillis(); [EOL] Chronology chrono = ISOChronology.getInstance(); [EOL] YearMonthDay ymd = new YearMonthDay(instant, chrono); [EOL] assertEquals(new YearMonthDay(chrono), ymd); [EOL] assertSame(chrono, ymd.getChronology()); [EOL] }
public void testYearMonthDayObject() { [EOL] Object instant = new Date(); [EOL] YearMonthDay ymd = new YearMonthDay(instant); [EOL] assertEquals(new YearMonthDay(), ymd); [EOL] }
public void testYearMonthDayObjectChronology() { [EOL] Object instant = new Date(); [EOL] Chronology chrono = ISOChronology.getInstance(); [EOL] YearMonthDay ymd = new YearMonthDay(instant, chrono); [EOL] assertEquals(new YearMonthDay(chrono), ymd); [EOL] assertSame(chrono, ymd.getChronology()); [EOL] }
public void testYearMonthDayIntIntInt() { [EOL] int year = 2020; [EOL] int month = 5; [EOL] int day = 20; [EOL] YearMonthDay ymd = new YearMonthDay(year, month, day); [EOL] assertEquals(year, ymd.getYear()); [EOL] assertEquals(month, ymd.getMonthOfYear()); [EOL] assertEquals(day, ymd.getDayOfMonth()); [EOL] }
public void testWithFieldSameValue() { [EOL] YearMonthDay ymd = new YearMonthDay(2023, 4, 15); [EOL] DateTimeFieldType fieldType = DateTimeFieldType.dayOfMonth(); [EOL] YearMonthDay result = ymd.withField(fieldType, 15); [EOL] assertSame("Should be the same object as no change in value", ymd, result); [EOL] }
public void testWithFieldDifferentValue() { [EOL] YearMonthDay ymd = new YearMonthDay(2023, 4, 15); [EOL] DateTimeFieldType fieldType = DateTimeFieldType.dayOfMonth(); [EOL] YearMonthDay result = ymd.withField(fieldType, 20); [EOL] assertEquals("Day of month should be changed to 20", 20, result.getDayOfMonth()); [EOL] }
public void testWithFieldUnsupportedType() { [EOL] YearMonthDay ymd = new YearMonthDay(2023, 4, 15); [EOL] DateTimeFieldType fieldType = DateTimeFieldType.hourOfDay(); // Assuming this is unsupported [EOL] try { [EOL] ymd.withField(fieldType, 10); [EOL] fail("Should have thrown an exception as field type is unsupported"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testPlusDays_Normal() { [EOL] YearMonthDay ymd = new YearMonthDay(2020, 1, 1); [EOL] YearMonthDay result = ymd.plusDays(1); [EOL] assertEquals(new YearMonthDay(2020, 1, 2), result); [EOL] }
public void testPlusDays_OverMonth() { [EOL] YearMonthDay ymd = new YearMonthDay(2020, 1, 31); [EOL] YearMonthDay result = ymd.plusDays(1); [EOL] assertEquals(new YearMonthDay(2020, 2, 1), result); [EOL] }
public void testPlusDays_OverYear() { [EOL] YearMonthDay ymd = new YearMonthDay(2020, 12, 31); [EOL] YearMonthDay result = ymd.plusDays(1); [EOL] assertEquals(new YearMonthDay(2021, 1, 1), result); [EOL] }
public void testPlusDays_Negative() { [EOL] YearMonthDay ymd = new YearMonthDay(2020, 1, 2); [EOL] YearMonthDay result = ymd.plusDays(-1); [EOL] assertEquals(new YearMonthDay(2020, 1, 1), result); [EOL] }
public void testPlusDays_Zero() { [EOL] YearMonthDay ymd = new YearMonthDay(2020, 1, 1); [EOL] YearMonthDay result = ymd.plusDays(0); [EOL] assertEquals(ymd, result); [EOL] }
public void testToDateTimeAtMidnight_Default() { [EOL] YearMonthDay ymd = new YearMonthDay(); [EOL] DateTime dt = ymd.toDateTimeAtMidnight(); [EOL] assertNotNull(dt); [EOL] assertEquals(dt.getYear(), ymd.getYear()); [EOL] assertEquals(dt.getMonthOfYear(), ymd.getMonthOfYear()); [EOL] assertEquals(dt.getDayOfMonth(), ymd.getDayOfMonth()); [EOL] assertEquals(dt.getHourOfDay(), 0); [EOL] assertEquals(dt.getMinuteOfHour(), 0); [EOL] assertEquals(dt.getSecondOfMinute(), 0); [EOL] assertEquals(dt.getMillisOfSecond(), 0); [EOL] }
public void testToDateTimeAtMidnight_SpecificZone() { [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/Paris"); [EOL] YearMonthDay ymd = new YearMonthDay(zone); [EOL] DateTime dt = ymd.toDateTimeAtMidnight(zone); [EOL] assertNotNull(dt); [EOL] assertEquals(dt.getZone(), zone); [EOL] assertEquals(dt.getYear(), ymd.getYear()); [EOL] assertEquals(dt.getMonthOfYear(), ymd.getMonthOfYear()); [EOL] assertEquals(dt.getDayOfMonth(), ymd.getDayOfMonth()); [EOL] assertEquals(dt.getHourOfDay(), 0); [EOL] assertEquals(dt.getMinuteOfHour(), 0); [EOL] assertEquals(dt.getSecondOfMinute(), 0); [EOL] assertEquals(dt.getMillisOfSecond(), 0); [EOL] }
public void testToDateTimeAtMidnight_NullZone() { [EOL] YearMonthDay ymd = new YearMonthDay((DateTimeZone) null); [EOL] DateTime dt = ymd.toDateTimeAtMidnight(null); [EOL] assertNotNull(dt); [EOL] assertEquals(dt.getZone(), DateTimeZone.getDefault()); [EOL] assertEquals(dt.getYear(), ymd.getYear()); [EOL] assertEquals(dt.getMonthOfYear(), ymd.getMonthOfYear()); [EOL] assertEquals(dt.getDayOfMonth(), ymd.getDayOfMonth()); [EOL] assertEquals(dt.getHourOfDay(), 0); [EOL] assertEquals(dt.getMinuteOfHour(), 0); [EOL] assertEquals(dt.getSecondOfMinute(), 0); [EOL] assertEquals(dt.getMillisOfSecond(), 0); [EOL] }
public void testDayOfMonth() { [EOL] YearMonthDay ymd = new YearMonthDay(); [EOL] Property dom = ymd.dayOfMonth(); [EOL] assertNotNull(dom); [EOL] assertEquals(DateTimeFieldType.dayOfMonth(), dom.getFieldType()); [EOL] assertEquals(ymd, dom.getYearMonthDay()); [EOL] }
public void testConstructors() { [EOL] YearMonthDay ymdDefault = new YearMonthDay(); [EOL] assertNotNull(ymdDefault); [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/Paris"); [EOL] YearMonthDay ymdZone = new YearMonthDay(zone); [EOL] assertNotNull(ymdZone); [EOL] assertEquals(zone, ymdZone.getChronology().getZone()); [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] YearMonthDay ymdChrono = new YearMonthDay(chronology); [EOL] assertNotNull(ymdChrono); [EOL] assertEquals(chronology, ymdChrono.getChronology()); [EOL] long instant = System.currentTimeMillis(); [EOL] YearMonthDay ymdInstant = new YearMonthDay(instant); [EOL] assertNotNull(ymdInstant); [EOL] YearMonthDay ymdInstantChrono = new YearMonthDay(instant, chronology); [EOL] assertNotNull(ymdInstantChrono); [EOL] assertEquals(chronology, ymdInstantChrono.getChronology()); [EOL] YearMonthDay ymdFromObject = new YearMonthDay((Object) instant); [EOL] assertNotNull(ymdFromObject); [EOL] YearMonthDay ymdFromObjectChrono = new YearMonthDay((Object) instant, chronology); [EOL] assertNotNull(ymdFromObjectChrono); [EOL] assertEquals(chronology, ymdFromObjectChrono.getChronology()); [EOL] int year = 2023; [EOL] int monthOfYear = 4; [EOL] int dayOfMonth = 1; [EOL] YearMonthDay ymdYMD = new YearMonthDay(year, monthOfYear, dayOfMonth); [EOL] assertNotNull(ymdYMD); [EOL] assertEquals(year, ymdYMD.getYear()); [EOL] assertEquals(monthOfYear, ymdYMD.getMonthOfYear()); [EOL] assertEquals(dayOfMonth, ymdYMD.getDayOfMonth()); [EOL] YearMonthDay ymdYMDChrono = new YearMonthDay(year, monthOfYear, dayOfMonth, chronology); [EOL] assertNotNull(ymdYMDChrono); [EOL] assertEquals(chronology, ymdYMDChrono.getChronology()); [EOL] }

protected ReadablePartial getReadablePartial() { [EOL] return iYearMonthDay; [EOL] } [EOL] public YearMonthDay(); [EOL] public YearMonthDay(DateTimeZone zone); [EOL] public YearMonthDay(Chronology chronology); [EOL] public YearMonthDay(long instant); [EOL] public YearMonthDay(long instant, Chronology chronology); [EOL] public YearMonthDay(Object instant); [EOL] public YearMonthDay(Object instant, Chronology chronology); [EOL] public YearMonthDay(int year, int monthOfYear, int dayOfMonth); [EOL] public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology); [EOL] YearMonthDay(YearMonthDay partial, int[] values); [EOL] YearMonthDay(YearMonthDay partial, Chronology chrono); [EOL] Property(YearMonthDay partial, int fieldIndex); [EOL] public static YearMonthDay fromCalendarFields(Calendar calendar); [EOL] public static YearMonthDay fromDateFields(Date date); [EOL] public int size(); [EOL] protected DateTimeField getField(int index, Chronology chrono); [EOL] public DateTimeFieldType getFieldType(int index); [EOL] public DateTimeFieldType[] getFieldTypes(); [EOL] public YearMonthDay withChronologyRetainFields(Chronology newChronology); [EOL] public YearMonthDay withField(DateTimeFieldType fieldType, int value); [EOL] public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); [EOL] public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); [EOL] public YearMonthDay plus(ReadablePeriod period); [EOL] public YearMonthDay plusYears(int years); [EOL] public YearMonthDay plusMonths(int months); [EOL] public YearMonthDay plusDays(int days); [EOL] public YearMonthDay minus(ReadablePeriod period); [EOL] public YearMonthDay minusYears(int years); [EOL] public YearMonthDay minusMonths(int months); [EOL] public YearMonthDay minusDays(int days); [EOL] public Property property(DateTimeFieldType type); [EOL] public LocalDate toLocalDate(); [EOL] public DateTime toDateTimeAtMidnight(); [EOL] public DateTime toDateTimeAtMidnight(DateTimeZone zone); [EOL] public DateTime toDateTimeAtCurrentTime(); [EOL] public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); [EOL] public DateMidnight toDateMidnight(); [EOL] public DateMidnight toDateMidnight(DateTimeZone zone); [EOL] public DateTime toDateTime(TimeOfDay time); [EOL] public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); [EOL] public Interval toInterval(); [EOL] public Interval toInterval(DateTimeZone zone); [EOL] public int getYear(); [EOL] public int getMonthOfYear(); [EOL] public int getDayOfMonth(); [EOL] public YearMonthDay withYear(int year); [EOL] public YearMonthDay withMonthOfYear(int monthOfYear); [EOL] public YearMonthDay withDayOfMonth(int dayOfMonth); [EOL] public Property year(); [EOL] public Property monthOfYear(); [EOL] public Property dayOfMonth(); [EOL] public String toString(); [EOL] public DateTimeField getField(); [EOL] protected ReadablePartial getReadablePartial(); [EOL] public YearMonthDay getYearMonthDay(); [EOL] public int get(); [EOL] public YearMonthDay addToCopy(int valueToAdd); [EOL] public YearMonthDay addWrapFieldToCopy(int valueToAdd); [EOL] public YearMonthDay setCopy(int value); [EOL] public YearMonthDay setCopy(String text, Locale locale); [EOL] public YearMonthDay setCopy(String text); [EOL] public YearMonthDay withMaximumValue(); [EOL] public YearMonthDay withMinimumValue(); [EOL] long serialVersionUID=Optional[797544782896179L]; [EOL] DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }];
public void testGetYearMonthDay() { [EOL] YearMonthDay ymd = new YearMonthDay(); [EOL] assertNotNull(ymd.getYearMonthDay()); [EOL] }
public void testYearMonthDayWithChronology() { [EOL] Chronology chrono = ISOChronology.getInstanceUTC(); [EOL] YearMonthDay ymd = new YearMonthDay(chrono); [EOL] assertEquals(chrono, ymd.getYearMonthDay().getChronology()); [EOL] }
public void testYearMonthDayWithInstant() { [EOL] long instant = System.currentTimeMillis(); [EOL] YearMonthDay ymd = new YearMonthDay(instant); [EOL] assertEquals(new YearMonthDay(instant), ymd); [EOL] }
public void testYearMonthDayWithInstantAndChronology() { [EOL] long instant = System.currentTimeMillis(); [EOL] Chronology chrono = ISOChronology.getInstanceUTC(); [EOL] YearMonthDay ymd = new YearMonthDay(instant, chrono); [EOL] assertEquals(new YearMonthDay(instant, chrono), ymd); [EOL] }
public void testYearMonthDayWithObject() { [EOL] Object instant = new Date(); [EOL] YearMonthDay ymd = new YearMonthDay(instant); [EOL] assertEquals(new YearMonthDay(instant), ymd); [EOL] }
public void testYearMonthDayWithObjectAndChronology() { [EOL] Object instant = new Date(); [EOL] Chronology chrono = ISOChronology.getInstanceUTC(); [EOL] YearMonthDay ymd = new YearMonthDay(instant, chrono); [EOL] assertEquals(new YearMonthDay(instant, chrono), ymd); [EOL] }
public void testYearMonthDayWithYearMonthDay() { [EOL] YearMonthDay partial = new YearMonthDay(); [EOL] int[] values = new int[] {2023, 4, 1}; [EOL] YearMonthDay ymd = new YearMonthDay(partial, values); [EOL] assertEquals(new YearMonthDay(2023, 4, 1), ymd); [EOL] }
public void testYearMonthDayWithYearMonthDayAndChronology() { [EOL] YearMonthDay partial = new YearMonthDay(); [EOL] Chronology chrono = ISOChronology.getInstanceUTC(); [EOL] YearMonthDay ymd = new YearMonthDay(partial, chrono); [EOL] assertEquals(chrono, ymd.getChronology()); [EOL] }
public void testYearMonthDayWithYearMonthDayAndValues() { [EOL] YearMonthDay partial = new YearMonthDay(); [EOL] int[] values = new int[] {2023, 4, 1}; [EOL] YearMonthDay ymd = new YearMonthDay(partial, values); [EOL] assertEquals(new YearMonthDay(2023, 4, 1), ymd); [EOL] }
public void testYearMonthDayWithYearMonthDayAndChrono() { [EOL] YearMonthDay partial = new YearMonthDay(); [EOL] Chronology chrono = ISOChronology.getInstanceUTC(); [EOL] YearMonthDay ymd = new YearMonthDay(partial, chrono); [EOL] assertEquals(chrono, ymd.getChronology()); [EOL] }
public void testYearMonthDayWithYearMonthDayProperty() { [EOL] YearMonthDay ymd = new YearMonthDay(); [EOL] Property prop = ymd.year(); [EOL] assertNotNull(prop); [EOL] }
public void testYearMonthDayFromCalendarFields() { [EOL] Calendar calendar = Calendar.getInstance(); [EOL] YearMonthDay ymd = YearMonthDay.fromCalendarFields(calendar); [EOL] assertNotNull(ymd); [EOL] }
public void testYearMonthDayFromDateFields() { [EOL] Date date = new Date(); [EOL] YearMonthDay ymd = YearMonthDay.fromDateFields(date); [EOL] assertNotNull(ymd); [EOL] }
public void testAddWrapFieldToCopy_PositiveValue() { [EOL] YearMonthDay ymd = new YearMonthDay(2020, 1, 1); // Assuming this constructor sets the fields correctly [EOL] YearMonthDay result = ymd.addWrapFieldToCopy(1); [EOL] } [EOL] public void testAddWrapFieldToCopy_NegativeValue() { [EOL] YearMonthDay ymd = new YearMonthDay(2020, 1, 1); // Assuming this constructor sets the fields correctly [EOL] YearMonthDay result = ymd.addWrapFieldToCopy(-1); [EOL] } [EOL] public void testAddWrapFieldToCopy_ZeroValue() { [EOL] YearMonthDay ymd = new YearMonthDay(2020, 1, 1); // Assuming this constructor sets the fields correctly [EOL] YearMonthDay result = ymd.addWrapFieldToCopy(0); [EOL] }
public void testPeriodWithZeroDurationAndNullChronology() { [EOL] long duration = 0L; [EOL] Chronology chronology = null; [EOL] Period period = new Period(duration, chronology); [EOL] assertNotNull(period); [EOL] assertEquals(duration, period.toStandardDuration().getMillis()); [EOL] assertNull(period.getChronology()); [EOL] }
public void testPeriodWithPositiveDurationAndSpecificChronology() { [EOL] long duration = 12345L; [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] Period period = new Period(duration, chronology); [EOL] assertNotNull(period); [EOL] assertEquals(duration, period.toStandardDuration().getMillis()); [EOL] assertEquals(chronology, period.getChronology()); [EOL] }
public void testPeriodWithEqualStartAndEndInstant() { [EOL] long startInstant = 1000L; [EOL] long endInstant = 1000L; [EOL] Period period = new Period(startInstant, endInstant); [EOL] assertEquals(startInstant, period.getStartMillis()); [EOL] assertEquals(endInstant, period.getEndMillis()); [EOL] assertNull(period.getZone()); [EOL] assertNull(period.getChronology()); [EOL] }
public void testPeriodWithDifferentStartAndEndInstant() { [EOL] long startInstant = 1000L; [EOL] long endInstant = 2000L; [EOL] Period period = new Period(startInstant, endInstant); [EOL] assertEquals(startInstant, period.getStartMillis()); [EOL] assertEquals(endInstant, period.getEndMillis()); [EOL] assertNull(period.getZone()); [EOL] assertNull(period.getChronology()); [EOL] }
public void testPeriodWithValidArguments() { [EOL] long startInstant = 1000L; [EOL] long endInstant = 5000L; [EOL] PeriodType type = PeriodType.standard(); [EOL] Period period = new Period(startInstant, endInstant, type); [EOL] assertNotNull(period); [EOL] assertEquals(startInstant, period.getStartMillis()); [EOL] assertEquals(endInstant, period.getEndMillis()); [EOL] assertEquals(type, period.getPeriodType()); [EOL] }
public void testPeriodWithValidArguments() { [EOL] long startInstant = 1000L; [EOL] long endInstant = 2000L; [EOL] PeriodType type = PeriodType.standard(); [EOL] Chronology chrono = ISOChronology.getInstance(); [EOL] Period period = new Period(startInstant, endInstant, type, chrono); [EOL] assertNotNull(period); [EOL] assertEquals(startInstant, period.getStartMillis()); [EOL] assertEquals(endInstant, period.getEndMillis()); [EOL] assertEquals(type, period.getPeriodType()); [EOL] assertEquals(chrono, period.getChronology()); [EOL] }
public void testPeriodWithNullType() { [EOL] long startInstant = 1000L; [EOL] long endInstant = 2000L; [EOL] Chronology chrono = ISOChronology.getInstance(); [EOL] Period period = new Period(startInstant, endInstant, null, chrono); [EOL] assertNotNull(period); [EOL] assertEquals(startInstant, period.getStartMillis()); [EOL] assertEquals(endInstant, period.getEndMillis()); [EOL] assertNotNull(period.getPeriodType()); [EOL] assertEquals(chrono, period.getChronology()); [EOL] }
public void testPeriodWithNullChronology() { [EOL] long startInstant = 1000L; [EOL] long endInstant = 2000L; [EOL] PeriodType type = PeriodType.standard(); [EOL] Period period = new Period(startInstant, endInstant, type, null); [EOL] assertNotNull(period); [EOL] assertEquals(startInstant, period.getStartMillis()); [EOL] assertEquals(endInstant, period.getEndMillis()); [EOL] assertEquals(type, period.getPeriodType()); [EOL] assertNotNull(period.getChronology()); [EOL] }
public void testWithPeriodType_SameType() { [EOL] PeriodType type = PeriodType.yearMonthDay(); [EOL] Period period = new Period(1, 1, 1, 1, 1, 1, 1, 1, type); [EOL] Period result = period.withPeriodType(type); [EOL] assertSame(period, result); [EOL] }
public void testWithPeriodType_DifferentType() { [EOL] PeriodType type = PeriodType.yearMonthDay(); [EOL] PeriodType newType = PeriodType.yearWeekDay(); [EOL] Period period = new Period(1, 1, 1, 1, 1, 1, 1, 1, type); [EOL] Period result = period.withPeriodType(newType); [EOL] assertNotSame(period, result); [EOL] assertEquals(newType, result.getPeriodType()); [EOL] }
public void testWithFields_NullPeriod() { [EOL] Period testPeriod = new Period(1, 1, 1, 1, 1, 1, 1, 1); [EOL] Period result = testPeriod.withFields(null); [EOL] assertSame("Expected the same period", testPeriod, result); [EOL] }
public void testWithFields_NonNullPeriod() { [EOL] Period testPeriod = new Period(1, 1, 1, 1, 1, 1, 1, 1); [EOL] Period newPeriod = new Period(2, 2, 2, 2, 2, 2, 2, 2); [EOL] Period result = testPeriod.withFields(newPeriod); [EOL] assertNotNull("Expected a new period", result); [EOL] assertNotSame("Expected different period objects", testPeriod, result); [EOL] int[] expectedValues = new int[] {2, 2, 2, 2, 2, 2, 2, 2}; [EOL] assertArrayEquals("Expected period to have new values", expectedValues, result.getValues()); [EOL] }
public void testWithFieldAdded_NullField() { [EOL] try { [EOL] Period period = new Period(); [EOL] period.withFieldAdded(null, 1); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public void testWithFieldAdded_ZeroValue() { [EOL] Period period = new Period(); [EOL] Period result = period.withFieldAdded(DurationFieldType.minutes(), 0); [EOL] assertSame("Period should be the same as it is unchanged", period, result); [EOL] }
public void testWithFieldAdded_NonZeroValue() { [EOL] Period period = new Period(); [EOL] Period result = period.withFieldAdded(DurationFieldType.minutes(), 10); [EOL] assertNotNull("Resulting period must not be null", result); [EOL] assertNotSame("Resulting period must be a new instance", period, result); [EOL] }
public void testPlusYears_ZeroYears() { [EOL] Period period = new Period(); [EOL] Period result = period.plusYears(0); [EOL] assertSame("Expected the same period instance when adding zero years", period, result); [EOL] }
public void testPlusYears_NonZeroYears() { [EOL] Period period = new Period(); [EOL] Period result = period.plusYears(5); [EOL] assertNotNull("Expected a new period instance when adding non-zero years", result); [EOL] assertNotSame("Expected a different period instance when adding non-zero years", period, result); [EOL] assertEquals("Expected the years to be added correctly", 5, result.getYears()); [EOL] }
public void testPlusMonths_ZeroMonths() { [EOL] Period period = new Period(1, 2, 3, 4, 5, 6, 7, 8); [EOL] Period result = period.plusMonths(0); [EOL] assertSame(period, result); [EOL] }
public void testPlusMonths_NonZeroMonths() { [EOL] Period period = new Period(1, 2, 3, 4, 5, 6, 7, 8); [EOL] Period result = period.plusMonths(1); [EOL] assertNotNull(result); [EOL] assertNotSame(period, result); [EOL] assertEquals(new Period(1, 3, 3, 4, 5, 6, 7, 8), result); [EOL] }
public void testPlusWeeks_ZeroWeeks() { [EOL] Period period = new Period(); [EOL] Period result = period.plusWeeks(0); [EOL] assertSame("Expected the same period instance when adding zero weeks", period, result); [EOL] }
public void testPlusWeeks_NonZeroWeeks() { [EOL] Period period = new Period(); [EOL] Period result = period.plusWeeks(1); [EOL] assertNotNull("Expected a new period instance when adding non-zero weeks", result); [EOL] assertNotSame("Expected a different period instance when adding non-zero weeks", period, result); [EOL] }
public void testPlusDays_ZeroDays() { [EOL] Period period = new Period(); [EOL] Period result = period.plusDays(0); [EOL] assertSame("Expected the same period instance when adding zero days", period, result); [EOL] }
public void testPlusDays_NonZeroDays() { [EOL] Period period = new Period(); [EOL] Period result = period.plusDays(5); [EOL] assertNotNull("Expected a new period instance when adding non-zero days", result); [EOL] assertNotSame("Expected a different period instance when adding non-zero days", period, result); [EOL] }
public void testPlusHours_ZeroHours() { [EOL] Period period = new Period(); [EOL] Period result = period.plusHours(0); [EOL] assertSame("Expected the same period instance when adding zero hours", period, result); [EOL] }
public void testPlusHours_NonZeroHours() { [EOL] Period period = new Period(); [EOL] Period result = period.plusHours(5); [EOL] assertNotNull("Expected a new period instance when adding non-zero hours", result); [EOL] assertNotSame("Expected a different period instance when adding non-zero hours", period, result); [EOL] assertEquals("Expected the hours to be increased by the amount added", 5, result.getHours()); [EOL] }
public void testPlusMinutes_Zero() { [EOL] Period period = new Period(); [EOL] Period result = period.plusMinutes(0); [EOL] assertSame("Expected the same period instance", period, result); [EOL] } [EOL] public void testPlusMinutes_NonZero() { [EOL] Period period = new Period(); [EOL] Period result = period.plusMinutes(5); [EOL] assertNotNull("Expected a new period instance", result); [EOL] assertNotSame("Expected a different period instance", period, result); [EOL] assertEquals("Expected 5 minutes added", 5, result.getMinutes()); [EOL] }
public void testPlusSeconds_Zero() { [EOL] Period period = new Period(); [EOL] Period result = period.plusSeconds(0); [EOL] assertSame(period, result); [EOL] } [EOL] public void testPlusSeconds_NonZero() { [EOL] Period period = new Period(); [EOL] Period result = period.plusSeconds(1); [EOL] assertNotNull(result); [EOL] assertNotSame(period, result); [EOL] }
public void testPlusMillis_Zero() { [EOL] Period period = new Period(); [EOL] Period result = period.plusMillis(0); [EOL] assertSame("Expected same period instance since millis is 0", period, result); [EOL] } [EOL] public void testPlusMillis_NonZero() { [EOL] Period period = new Period(); [EOL] Period result = period.plusMillis(1); [EOL] assertNotNull("Expected new period instance since millis is non-zero", result); [EOL] assertNotSame("Expected different period instance since millis is non-zero", period, result); [EOL] }
public void testToStandardDays_Zero() { [EOL] Period test = new Period(0); [EOL] Days expected = Days.days(0); [EOL] Days actual = test.toStandardDays(); [EOL] assertEquals(expected, actual); [EOL] }
public void testToStandardDays_OneSecond() { [EOL] Period test = new Period(1000); // Assuming 1000 millis in a second [EOL] Days expected = Days.days(0); [EOL] Days actual = test.toStandardDays(); [EOL] assertEquals(expected, actual); [EOL] }
public void testToStandardDays_OneMinute() { [EOL] Period test = new Period(60000); // Assuming 60000 millis in a minute [EOL] Days expected = Days.days(0); [EOL] Days actual = test.toStandardDays(); [EOL] assertEquals(expected, actual); [EOL] }
public void testToStandardDays_OneHour() { [EOL] Period test = new Period(3600000); // Assuming 3600000 millis in an hour [EOL] Days expected = Days.days(0); [EOL] Days actual = test.toStandardDays(); [EOL] assertEquals(expected, actual); [EOL] }
public void testToStandardDays_OneDay() { [EOL] Period test = new Period(86400000); // Assuming 86400000 millis in a day [EOL] Days expected = Days.days(1); [EOL] Days actual = test.toStandardDays(); [EOL] assertEquals(expected, actual); [EOL] }
public void testToStandardDays_OneWeek() { [EOL] Period test = new Period(604800000); // Assuming 604800000 millis in a week [EOL] Days expected = Days.days(7); [EOL] Days actual = test.toStandardDays(); [EOL] assertEquals(expected, actual); [EOL] }
public void testToStandardDays_MixedPeriod() { [EOL] Period test = new Period(0, 0, 1, 1, 1, 1, 1, 0); // 1 week, 1 day, 1 hour, 1 minute, 1 second [EOL] Days expected = Days.days(8); // 7 days in a week + 1 day [EOL] Days actual = test.toStandardDays(); [EOL] assertEquals(expected, actual); [EOL] }
public void testGetInstanceWithNullZone() { [EOL] IslamicChronology result = IslamicChronology.getInstance(null); [EOL] assertNotNull(result); [EOL] }
public void testGetInstanceWithSpecificZone() { [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/London"); [EOL] IslamicChronology result = IslamicChronology.getInstance(zone); [EOL] assertNotNull(result); [EOL] assertEquals(zone, result.getZone()); [EOL] }
public void testGetInstanceWithNullZone() { [EOL] IslamicChronology chrono = IslamicChronology.getInstance(null, LeapYearPatternType.FIFTEEN); [EOL] assertNotNull(chrono); [EOL] assertEquals(DateTimeZone.getDefault(), chrono.getZone()); [EOL] }
public void testGetInstanceWithNonNullZone() { [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/Paris"); [EOL] IslamicChronology chrono = IslamicChronology.getInstance(zone, LeapYearPatternType.FIFTEEN); [EOL] assertNotNull(chrono); [EOL] assertEquals(zone, chrono.getZone()); [EOL] }
public void testGetInstanceWithUTCZone() { [EOL] DateTimeZone utc = DateTimeZone.UTC; [EOL] IslamicChronology chrono = IslamicChronology.getInstance(utc, LeapYearPatternType.FIFTEEN); [EOL] assertNotNull(chrono); [EOL] assertEquals(utc, chrono.getZone()); [EOL] }
public void testIslamicChronologyWithValidParams() { [EOL] Chronology baseChronology = ISOChronology.getInstanceUTC(); [EOL] LeapYearPatternType leapYearPattern = LeapYearPatternType.getInstance(LeapYearPatternType.LEAP_YEAR_15_BASED); [EOL] IslamicChronology islamicChronology = new IslamicChronology(baseChronology, new Object(), leapYearPattern); [EOL] assertNotNull(islamicChronology); [EOL] assertEquals(leapYearPattern, islamicChronology.iLeapYears); [EOL] }
public void testIslamicChronologyWithNullBase() { [EOL] LeapYearPatternType leapYearPattern = LeapYearPatternType.getInstance(LeapYearPatternType.LEAP_YEAR_15_BASED); [EOL] try { [EOL] new IslamicChronology(null, new Object(), leapYearPattern); [EOL] fail("Should have thrown IllegalArgumentException for null base chronology"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testIslamicChronologyWithNullLeapYearPattern() { [EOL] Chronology baseChronology = ISOChronology.getInstanceUTC(); [EOL] try { [EOL] new IslamicChronology(baseChronology, new Object(), null); [EOL] fail("Should have thrown IllegalArgumentException for null leap year pattern"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testWithUTC_ReturnsUTCInstance() { [EOL] Chronology chronology = new SpecificChronology(); // Assuming SpecificChronology is a concrete implementation [EOL] Chronology utcChronology = chronology.withUTC(); [EOL] assertSame("withUTC should return the UTC instance", INSTANCE_UTC, utcChronology); [EOL] }
public void testWithZoneSameAsCurrent() { [EOL] Chronology chronology = ...; // Initialize with a specific chronology [EOL] DateTimeZone currentZone = chronology.getZone(); [EOL] Chronology result = chronology.withZone(currentZone); [EOL] assertSame("Should be the same chronology because zones are equal", chronology, result); [EOL] }
public void testWithZoneDifferentFromCurrent() { [EOL] Chronology chronology = ...; // Initialize with a specific chronology [EOL] DateTimeZone currentZone = chronology.getZone(); [EOL] DateTimeZone newZone = ...; // Initialize with a different zone [EOL] Chronology result = chronology.withZone(newZone); [EOL] assertNotSame("Should not be the same chronology because zones are different", chronology, result); [EOL] assertEquals("New zone should be set", newZone, result.getZone()); [EOL] }
public void testWithZoneNull() { [EOL] Chronology chronology = ...; // Initialize with a specific chronology [EOL] Chronology result = chronology.withZone(null); [EOL] DateTimeZone defaultZone = DateTimeZone.getDefault(); [EOL] assertNotSame("Should not be the same chronology because null zone implies default zone", chronology, result); [EOL] assertEquals("Should use default zone when null is passed", defaultZone, result.getZone()); [EOL] }
public void testAssembleWithNullBase() { [EOL] Fields fields = new Fields(); [EOL] TestDateTime testDateTime = new TestDateTime(); [EOL] testDateTime.assemble(fields); [EOL] assertNotNull(fields.era); [EOL] assertNotNull(fields.monthOfYear); [EOL] assertNotNull(fields.months); [EOL] } [EOL] public void testAssembleWithNonNullBase() { [EOL] Fields fields = new Fields(); [EOL] TestDateTime testDateTime = new TestDateTime(); [EOL] testDateTime.setBase(new BaseDateTime()); [EOL] testDateTime.assemble(fields); [EOL] assertNull(fields.era); [EOL] assertNull(fields.monthOfYear); [EOL] assertNull(fields.months); [EOL] }
public void testGetInstanceWithNullZoneAndNullGregorianCutover() { [EOL] GJChronology result = GJChronology.getInstance(null, null); [EOL] assertNotNull(result); [EOL] assertEquals("UTC", result.getZone().getID()); [EOL] assertNotNull(result.getGregorianCutover()); [EOL] }
public void testGetInstanceWithNonNullZoneAndNullGregorianCutover() { [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/Paris"); [EOL] GJChronology result = GJChronology.getInstance(zone, null); [EOL] assertNotNull(result); [EOL] assertEquals("Europe/Paris", result.getZone().getID()); [EOL] assertNotNull(result.getGregorianCutover()); [EOL] }
public void testGetInstanceWithNullZoneAndNonNullGregorianCutover() { [EOL] ReadableInstant gregorianCutover = new Instant(); [EOL] GJChronology result = GJChronology.getInstance(null, gregorianCutover); [EOL] assertNotNull(result); [EOL] assertEquals("UTC", result.getZone().getID()); [EOL] assertEquals(gregorianCutover.getMillis(), result.getGregorianCutover().getMillis()); [EOL] }
public void testGetInstanceWithNonNullZoneAndNonNullGregorianCutover() { [EOL] DateTimeZone zone = DateTimeZone.forID("Asia/Tokyo"); [EOL] ReadableInstant gregorianCutover = new Instant(); [EOL] GJChronology result = GJChronology.getInstance(zone, gregorianCutover); [EOL] assertNotNull(result); [EOL] assertEquals("Asia/Tokyo", result.getZone().getID()); [EOL] assertEquals(gregorianCutover.getMillis(), result.getGregorianCutover().getMillis()); [EOL] }
public static synchronized GJChronology getInstance(DateTimeZone zone, ReadableInstant gregorianCutover, int minDaysInFirstWeek) { [EOL] zone = DateTimeUtils.getZone(zone); [EOL] Instant cutoverInstant; [EOL] if (gregorianCutover == null) { [EOL] cutoverInstant = DEFAULT_CUTOVER; [EOL] } else { [EOL] cutoverInstant = gregorianCutover.toInstant(); [EOL] LocalDate cutoverDate = new LocalDate(cutoverInstant.getMillis(), GregorianChronology.getInstance(zone)); [EOL] if (cutoverDate.getYear() <= 0) { [EOL] throw new IllegalArgumentException("Cutover too early. Must be on or after 0001-01-01."); [EOL] } [EOL] } [EOL] GJChronology chrono; [EOL] synchronized (cCache) { [EOL] ArrayList<GJChronology> chronos = cCache.get(zone); [EOL] if (chronos == null) { [EOL] chronos = new ArrayList<GJChronology>(2); [EOL] cCache.put(zone, chronos); [EOL] } else { [EOL] for (int i = chronos.size(); --i >= 0; ) { [EOL] chrono = chronos.get(i); [EOL] if (minDaysInFirstWeek == chrono.getMinimumDaysInFirstWeek() && cutoverInstant.equals(chrono.getGregorianCutover())) { [EOL] return chrono; [EOL] } [EOL] } [EOL] } [EOL] if (zone == DateTimeZone.UTC) { [EOL] chrono = new GJChronology(JulianChronology.getInstance(zone, minDaysInFirstWeek), GregorianChronology.getInstance(zone, minDaysInFirstWeek), cutoverInstant); [EOL] } else { [EOL] chrono = getInstance(DateTimeZone.UTC, cutoverInstant, minDaysInFirstWeek); [EOL] chrono = new GJChronology(ZonedChronology.getInstance(chrono, zone), chrono.iJulianChronology, chrono.iGregorianChronology, chrono.iCutoverInstant); [EOL] } [EOL] chronos.add(chrono); [EOL] } [EOL] return chrono; [EOL] }
public void testGetDateTimeMillis_BaseChronologyNotNull() { [EOL] Chronology mockBaseChronology = Mockito.mock(Chronology.class); [EOL] Mockito.when(mockBaseChronology.getDateTimeMillis(Mockito.anyInt(), Mockito.anyInt(), Mockito.anyInt(), Mockito.anyInt(), Mockito.anyInt(), Mockito.anyInt(), Mockito.anyInt())).thenReturn(1234567890L); [EOL] setBase(mockBaseChronology); // Assuming there is a method to set the base chronology [EOL] long result = getDateTimeMillis(2021, 1, 1, 12, 0, 0, 0); [EOL] assertEquals(1234567890L, result); [EOL] }
public void testGetDateTimeMillis_GregorianChronologyWithoutException() { [EOL] setBase(null); // Assuming there is a method to set the base chronology to null [EOL] Mockito.when(iGregorianChronology.getDateTimeMillis(Mockito.anyInt(), Mockito.anyInt(), Mockito.anyInt(), Mockito.anyInt(), Mockito.anyInt(), Mockito.anyInt(), Mockito.anyInt())).thenReturn(1234567890L); [EOL] long result = getDateTimeMillis(2021, 1, 1, 12, 0, 0, 0); [EOL] assertEquals(1234567890L, result); [EOL] }
public void testGetDateTimeMillis_GregorianChronologyWithExceptionNotFebruary29() { [EOL] setBase(null); // Assuming there is a method to set the base chronology to null [EOL] Mockito.when(iGregorianChronology.getDateTimeMillis(Mockito.anyInt(), Mockito.anyInt(), Mockito.anyInt(), Mockito.anyInt(), Mockito.anyInt(), Mockito.anyInt(), Mockito.anyInt())).thenThrow(new IllegalFieldValueException("Illegal field value")); [EOL] try { [EOL] getDateTimeMillis(2021, 1, 1, 12, 0, 0, 0); [EOL] fail("Expected IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public void testGetDateTimeMillis_GregorianChronologyWithExceptionFebruary29BeforeCutover() { [EOL] setBase(null); // Assuming there is a method to set the base chronology to null [EOL] Mockito.when(iGregorianChronology.getDateTimeMillis(Mockito.anyInt(), Mockito.eq(2), Mockito.eq(29), Mockito.anyInt(), Mockito.anyInt(), Mockito.anyInt(), Mockito.anyInt())).thenThrow(new IllegalFieldValueException("Illegal field value")); [EOL] Mockito.when(iGregorianChronology.getDateTimeMillis(Mockito.anyInt(), Mockito.eq(2), Mockito.eq(28), Mockito.anyInt(), Mockito.anyInt(), Mockito.anyInt(), Mockito.anyInt())).thenReturn(1234567890L); [EOL] Mockito.when(iCutoverMillis).thenReturn(1234567891L); [EOL] long result = getDateTimeMillis(2021, 2, 29, 12, 0, 0, 0); [EOL] assertEquals(1234567890L, result); [EOL] }
public void testGetDateTimeMillis_JulianChronologyBeforeCutover() { [EOL] setBase(null); // Assuming there is a method to set the base chronology to null [EOL] Mockito.when(iJulianChronology.getDateTimeMillis(Mockito.anyInt(), Mockito.anyInt(), Mockito.anyInt(), Mockito.anyInt(), Mockito.anyInt(), Mockito.anyInt(), Mockito.anyInt())).thenReturn(1234567890L); [EOL] Mockito.when(iCutoverMillis).thenReturn(1234567891L); [EOL] long result = getDateTimeMillis(2021, 1, 1, 12, 0, 0, 0); [EOL] assertEquals(1234567890L, result); [EOL] }
public void testGetDateTimeMillis_JulianChronologyAfterCutover() { [EOL] setBase(null); // Assuming there is a method to set the base chronology to null [EOL] Mockito.when(iJulianChronology.getDateTimeMillis(Mockito.anyInt(), Mockito.anyInt(), Mockito.anyInt(), Mockito.anyInt(), Mockito.anyInt(), Mockito.anyInt(), Mockito.anyInt())).thenReturn(1234567891L); [EOL] Mockito.when(iCutoverMillis).thenReturn(1234567890L); [EOL] try { [EOL] getDateTimeMillis(2021, 1, 1, 12, 0, 0, 0); [EOL] fail("Expected IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public void testEquals_Reflexive() { [EOL] GJChronology chrono = GJChronology.getInstance(); [EOL] assertTrue(chrono.equals(chrono)); [EOL] }
public void testEquals_SameValues() { [EOL] GJChronology chrono1 = GJChronology.getInstance(DateTimeZone.UTC, 12345678L, 4); [EOL] GJChronology chrono2 = GJChronology.getInstance(DateTimeZone.UTC, 12345678L, 4); [EOL] assertTrue(chrono1.equals(chrono2)); [EOL] }
public void testEquals_DifferentCutover() { [EOL] GJChronology chrono1 = GJChronology.getInstance(DateTimeZone.UTC, 12345678L, 4); [EOL] GJChronology chrono2 = GJChronology.getInstance(DateTimeZone.UTC, 87654321L, 4); [EOL] assertFalse(chrono1.equals(chrono2)); [EOL] }
public void testEquals_DifferentMinimumDays() { [EOL] GJChronology chrono1 = GJChronology.getInstance(DateTimeZone.UTC, 12345678L, 4); [EOL] GJChronology chrono2 = GJChronology.getInstance(DateTimeZone.UTC, 12345678L, 2); [EOL] assertFalse(chrono1.equals(chrono2)); [EOL] }
public void testEquals_DifferentZone() { [EOL] GJChronology chrono1 = GJChronology.getInstance(DateTimeZone.UTC, 12345678L, 4); [EOL] GJChronology chrono2 = GJChronology.getInstance(DateTimeZone.forID("Europe/Paris"), 12345678L, 4); [EOL] assertFalse(chrono1.equals(chrono2)); [EOL] }
public void testEquals_Null() { [EOL] GJChronology chrono = GJChronology.getInstance(); [EOL] assertFalse(chrono.equals(null)); [EOL] }
public void testEquals_NonGJChronology() { [EOL] GJChronology chrono = GJChronology.getInstance(); [EOL] Object obj = new Object(); [EOL] assertFalse(chrono.equals(obj)); [EOL] }
public void testHashCode() { [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/London"); [EOL] int minimumDaysInFirstWeek = 4; [EOL] Instant cutoverInstant = new Instant(); [EOL] Time time = new Time(zone, minimumDaysInFirstWeek, cutoverInstant); [EOL] int expectedHashCode = "GJ".hashCode() * 11 + zone.hashCode() + minimumDaysInFirstWeek + cutoverInstant.hashCode(); [EOL] int actualHashCode = time.hashCode(); [EOL] assertEquals(expectedHashCode, actualHashCode); [EOL] }
public void testGetMinimumValue() { [EOL] int expectedValue = /* some expected minimum value */; [EOL] int actualValue = instance.getMinimumValue(); [EOL] assertEquals(expectedValue, actualValue); [EOL] }
public void testGetMinimumValueWithPartialAndValues() { [EOL] ReadablePartial mockPartial = Mockito.mock(ReadablePartial.class); [EOL] int[] values = new int[] {1, 2, 3}; [EOL] int expectedMinimumValue = 0; // Assuming this is the expected minimum value [EOL] Mockito.when(iJulianField.getMinimumValue(mockPartial, values)).thenReturn(expectedMinimumValue); [EOL] int actualMinimumValue = getMinimumValue(mockPartial, values); [EOL] assertEquals(expectedMinimumValue, actualMinimumValue); [EOL] }
public void testGetMaximumValue() { [EOL] int expectedValue = SOME_EXPECTED_VALUE; // Replace with the actual expected maximum value [EOL] int actualValue = time.getMaximumValue(); [EOL] assertEquals(expectedValue, actualValue); [EOL] }
public void testGetMaximumValue_BeforeCutover() { [EOL] long instantBeforeCutover = iCutover - 1; // Assume iCutover is a valid timestamp [EOL] int expectedMax = iJulianField.getMaximumValue(instantBeforeCutover); [EOL] int actualMax = getMaximumValue(instantBeforeCutover); [EOL] assertEquals(expectedMax, actualMax); [EOL] }
public void testGetMaximumValue_AtCutover() { [EOL] long instantAtCutover = iCutover; [EOL] int expectedMax = iGregorianField.getMaximumValue(instantAtCutover); [EOL] int actualMax = getMaximumValue(instantAtCutover); [EOL] assertEquals(expectedMax, actualMax); [EOL] }
public void testGetMaximumValue_AfterCutover() { [EOL] long instantAfterCutover = iCutover + 1; // Assume iCutover is a valid timestamp [EOL] int expectedMax = iGregorianField.getMaximumValue(instantAfterCutover); [EOL] int actualMax = getMaximumValue(instantAfterCutover); [EOL] assertEquals(expectedMax, actualMax); [EOL] }
public void testGetMaximumValue_WithPartialAndValues() { [EOL] ReadablePartial mockPartial = Mockito.mock(ReadablePartial.class); [EOL] int[] values = new int[] {1, 2, 3}; [EOL] Mockito.when(mockPartial.size()).thenReturn(3); [EOL] DateTimeFieldType mockFieldType = Mockito.mock(DateTimeFieldType.class); [EOL] DateTimeField mockField = Mockito.mock(DateTimeField.class); [EOL] Chronology mockChrono = GJChronology.getInstanceUTC(); [EOL] Mockito.when(mockPartial.getFieldType(Mockito.anyInt())).thenReturn(mockFieldType); [EOL] Mockito.when(mockFieldType.getField(Mockito.any(Chronology.class))).thenReturn(mockField); [EOL] Mockito.when(mockField.getMaximumValue(Mockito.anyLong())).thenReturn(10); [EOL] Mockito.when(mockField.set(Mockito.anyLong(), Mockito.anyInt())).thenReturn(1L); [EOL] Time time = new Time(); [EOL] int result = time.getMaximumValue(mockPartial, values); [EOL] Mockito.verify(mockPartial, Mockito.times(3)).getFieldType(Mockito.anyInt()); [EOL] Mockito.verify(mockFieldType, Mockito.times(3)).getField(mockChrono); [EOL] Mockito.verify(mockField, Mockito.times(3)).getMaximumValue(Mockito.anyLong()); [EOL] Mockito.verify(mockField, Mockito.times(3)).set(Mockito.anyLong(), Mockito.anyInt()); [EOL] int expected = time.getMaximumValue(1L); [EOL] assertEquals(expected, result); [EOL] }
public long add(long instant, int value) { [EOL] if (instant >= iCutover) { [EOL] instant = iGregorianField.add(instant, value); [EOL] if (instant < iCutover) { [EOL] if (instant + iGapDuration < iCutover) { [EOL] if (iConvertByWeekyear) { [EOL] int wyear = iGregorianChronology.weekyear().get(instant); [EOL] if (wyear <= 0) { [EOL] instant = iGregorianChronology.weekyear().add(instant, -1); [EOL] } [EOL] } else { [EOL] int year = iGregorianChronology.year().get(instant); [EOL] if (year <= 0) { [EOL] instant = iGregorianChronology.year().add(instant, -1); [EOL] } [EOL] } [EOL] instant = gregorianToJulian(instant); [EOL] } [EOL] } [EOL] } else { [EOL] instant = iJulianField.add(instant, value); [EOL] if (instant >= iCutover) { [EOL] if (instant - iGapDuration >= iCutover) { [EOL] instant = julianToGregorian(instant); [EOL] } [EOL] } [EOL] } [EOL] return instant; [EOL] }
public void testGetMaximumValue_AfterCutover() { [EOL] long instantAfterCutover = iCutover + 1; // Assuming iCutover is a predefined long value [EOL] int expectedValue = iGregorianField.getMaximumValue(instantAfterCutover); // Assuming iGregorianField is a mockable field [EOL] int actualValue = getMaximumValue(instantAfterCutover); [EOL] assertEquals(expectedValue, actualValue); [EOL] }
public void testGetMaximumValue_AtCutover() { [EOL] long instantAtCutover = iCutover; // Assuming iCutover is a predefined long value [EOL] int expectedValue = iGregorianField.getMaximumValue(instantAtCutover); // Assuming iGregorianField is a mockable field [EOL] int actualValue = getMaximumValue(instantAtCutover); [EOL] assertEquals(expectedValue, actualValue); [EOL] }
public void testGetMaximumValue_BeforeCutover() { [EOL] long instantBeforeCutover = iCutover - 1; // Assuming iCutover is a predefined long value [EOL] int expectedValue = iJulianField.getMaximumValue(instantBeforeCutover); // Assuming iJulianField is a mockable field [EOL] int actualValue = getMaximumValue(instantBeforeCutover); [EOL] assertEquals(expectedValue, actualValue); [EOL] }
public void testGetInstantMillisWithValidStringAndChronology() { [EOL] String validDateTimeString = "2020-01-01T12:00:00Z"; [EOL] Chronology chrono = ISOChronology.getInstanceUTC(); [EOL] long expectedMillis = chrono.getDateTimeMillis(2020, 1, 1, 12, 0, 0, 0); [EOL] long actualMillis = getInstantMillis(validDateTimeString, chrono); [EOL] assertEquals(expectedMillis, actualMillis); [EOL] }
public void testGetInstantMillisWithInvalidString() { [EOL] String invalidDateTimeString = "invalid-date-time"; [EOL] Chronology chrono = ISOChronology.getInstanceUTC(); [EOL] try { [EOL] getInstantMillis(invalidDateTimeString, chrono); [EOL] fail("Should have thrown IllegalArgumentException for invalid date time string"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testGetInstantMillisWithNullChronology() { [EOL] String validDateTimeString = "2020-01-01T12:00:00Z"; [EOL] try { [EOL] getInstantMillis(validDateTimeString, null); [EOL] fail("Should have thrown NullPointerException for null Chronology"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testGetDurationMillis_ValidFormat_Positive() { [EOL] long result = getDurationMillis("PT10S"); [EOL] assertEquals(10000, result); [EOL] }
public void testGetDurationMillis_ValidFormat_Negative() { [EOL] long result = getDurationMillis("PT-10S"); [EOL] assertEquals(-10000, result); [EOL] }
public void testGetDurationMillis_ValidFormat_WithMillis() { [EOL] long result = getDurationMillis("PT10.123S"); [EOL] assertEquals(10123, result); [EOL] }
public void testGetDurationMillis_ValidFormat_NegativeWithMillis() { [EOL] long result = getDurationMillis("PT-10.123S"); [EOL] assertEquals(-10123, result); [EOL] }
public void testGetDurationMillis_InvalidFormat_NoPT() { [EOL] try { [EOL] getDurationMillis("10S"); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testGetDurationMillis_InvalidFormat_NoS() { [EOL] try { [EOL] getDurationMillis("PT10"); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testGetDurationMillis_InvalidFormat_ExtraChars() { [EOL] try { [EOL] getDurationMillis("PT10SX"); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testGetDurationMillis_InvalidFormat_NonNumeric() { [EOL] try { [EOL] getDurationMillis("PT10.AS"); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testGetDurationMillis_InvalidFormat_MultipleDots() { [EOL] try { [EOL] getDurationMillis("PT10.1.23S"); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testGetDurationMillis_InvalidFormat_NegativeWithoutNumber() { [EOL] try { [EOL] getDurationMillis("PT-.123S"); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testSetInto_ValidString() { [EOL] ReadWritablePeriod mockPeriod = mock(ReadWritablePeriod.class); [EOL] String validString = "PT1H"; [EOL] Chronology mockChrono = mock(Chronology.class); [EOL] setInto(mockPeriod, validString, mockChrono); [EOL] verify(mockPeriod).clear(); [EOL] verify(mockPeriod, atLeastOnce()).set(anyInt(), anyInt()); [EOL] }
public void testSetInto_InvalidString() { [EOL] ReadWritablePeriod mockPeriod = mock(ReadWritablePeriod.class); [EOL] String invalidString = "Invalid"; [EOL] Chronology mockChrono = mock(Chronology.class); [EOL] try { [EOL] setInto(mockPeriod, invalidString, mockChrono); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Invalid format: \"Invalid\"", e.getMessage()); [EOL] } [EOL] }
public void testSetInto_EmptyString() { [EOL] ReadWritablePeriod mockPeriod = mock(ReadWritablePeriod.class); [EOL] String emptyString = ""; [EOL] Chronology mockChrono = mock(Chronology.class); [EOL] setInto(mockPeriod, emptyString, mockChrono); [EOL] verify(mockPeriod).clear(); [EOL] verify(mockPeriod, never()).set(anyInt(), anyInt()); [EOL] }
public void testSetIntoWithInvalidSeparator() { [EOL] ReadWritableInterval writableInterval = mock(ReadWritableInterval.class); [EOL] Object object = "InvalidFormat"; [EOL] Chronology chrono = ISOChronology.getInstanceUTC(); [EOL] try { [EOL] setInto(writableInterval, object, chrono); [EOL] fail("Should have thrown IllegalArgumentException due to missing '/' separator"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Format requires a '/' separator: InvalidFormat", e.getMessage()); [EOL] } [EOL] }
public void testSetIntoWithEmptyLeftPart() { [EOL] ReadWritableInterval writableInterval = mock(ReadWritableInterval.class); [EOL] Object object = "/2023-03-15T00:00:00Z"; [EOL] Chronology chrono = ISOChronology.getInstanceUTC(); [EOL] try { [EOL] setInto(writableInterval, object, chrono); [EOL] fail("Should have thrown IllegalArgumentException due to empty left part"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Format invalid: /2023-03-15T00:00:00Z", e.getMessage()); [EOL] } [EOL] }
public void testSetIntoWithEmptyRightPart() { [EOL] ReadWritableInterval writableInterval = mock(ReadWritableInterval.class); [EOL] Object object = "2023-03-15T00:00:00Z/"; [EOL] Chronology chrono = ISOChronology.getInstanceUTC(); [EOL] try { [EOL] setInto(writableInterval, object, chrono); [EOL] fail("Should have thrown IllegalArgumentException due to empty right part"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Format invalid: 2023-03-15T00:00:00Z/", e.getMessage()); [EOL] } [EOL] }
public void testSetIntoWithTwoDurations() { [EOL] ReadWritableInterval writableInterval = mock(ReadWritableInterval.class); [EOL] Object object = "P1Y/P2Y"; [EOL] Chronology chrono = ISOChronology.getInstanceUTC(); [EOL] try { [EOL] setInto(writableInterval, object, chrono); [EOL] fail("Should have thrown IllegalArgumentException due to interval composed of two durations"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Interval composed of two durations: P1Y/P2Y", e.getMessage()); [EOL] } [EOL] }
public void testSetIntoWithPeriodAndDateTime() { [EOL] ReadWritableInterval writableInterval = mock(ReadWritableInterval.class); [EOL] Object object = "P1Y/2023-03-15T00:00:00Z"; [EOL] Chronology chrono = ISOChronology.getInstanceUTC(); [EOL] setInto(writableInterval, object, chrono); [EOL] verify(writableInterval).setInterval(anyLong(), anyLong()); [EOL] verify(writableInterval).setChronology(chrono); [EOL] }
public void testSetIntoWithDateTimeAndPeriod() { [EOL] ReadWritableInterval writableInterval = mock(ReadWritableInterval.class); [EOL] Object object = "2023-03-15T00:00:00Z/P1Y"; [EOL] Chronology chrono = ISOChronology.getInstanceUTC(); [EOL] setInto(writableInterval, object, chrono); [EOL] verify(writableInterval).setInterval(anyLong(), anyLong()); [EOL] verify(writableInterval).setChronology(chrono); [EOL] }
public void testSetIntoWithTwoDateTimes() { [EOL] ReadWritableInterval writableInterval = mock(ReadWritableInterval.class); [EOL] Object object = "2023-03-15T00:00:00Z/2024-03-15T00:00:00Z"; [EOL] Chronology chrono = ISOChronology.getInstanceUTC(); [EOL] setInto(writableInterval, object, chrono); [EOL] verify(writableInterval).setInterval(anyLong(), anyLong()); [EOL] verify(writableInterval).setChronology(chrono); [EOL] }
public void testPrintZeroAlways() { [EOL] PeriodFormatterBuilder builder = new PeriodFormatterBuilder(); [EOL] PeriodFormatterBuilder returnedBuilder = builder.printZeroAlways(); [EOL] assertNotNull("Returned builder should not be null", returnedBuilder); [EOL] assertSame("Returned builder should be the same as the original builder", builder, returnedBuilder); [EOL] }
public void testPrintZeroNever() { [EOL] PeriodFormatterBuilder builder = new PeriodFormatterBuilder(); [EOL] builder.printZeroNever(); [EOL] }
public void testAppendMonths() { [EOL] PeriodFormatterBuilder builder = new PeriodFormatterBuilder(); [EOL] PeriodFormatterBuilder result = builder.appendMonths(); [EOL] assertNotNull(result); [EOL] assertSame(builder, result); [EOL] }
public void testAppendDays() { [EOL] PeriodFormatterBuilder builder = new PeriodFormatterBuilder(); [EOL] PeriodFormatterBuilder result = builder.appendDays(); [EOL] assertNotNull(result); [EOL] assertTrue(result.hasFieldAdded(DAYS)); [EOL] }
public void testAppendSuffixWithNullText() { [EOL] PeriodFormatterBuilder builder = new PeriodFormatterBuilder(); [EOL] try { [EOL] builder.appendSuffix(null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testAppendSuffixWithNonNullText() { [EOL] PeriodFormatterBuilder builder = new PeriodFormatterBuilder(); [EOL] builder.appendSuffix("suffix"); [EOL] }
public void testAppendSuffixWithEmptyElementPairs() { [EOL] try { [EOL] PeriodFormatterBuilder builder = new PeriodFormatterBuilder(); [EOL] builder.appendSuffix(null); [EOL] fail("Should have thrown IllegalStateException"); [EOL] } catch (IllegalStateException e) { [EOL] assertEquals("No field to apply suffix to", e.getMessage()); [EOL] } [EOL] }
public void testAppendSuffixWithNonEmptyElementPairsDifferentPrinterParser() { [EOL] try { [EOL] PeriodFormatterBuilder builder = new PeriodFormatterBuilder(); [EOL] builder.appendLiteral("Literal"); [EOL] builder.appendSuffix(null); [EOL] fail("Should have thrown IllegalStateException"); [EOL] } catch (IllegalStateException e) { [EOL] assertEquals("No field to apply suffix to", e.getMessage()); [EOL] } [EOL] }
public void testAppendSuffixWithNonEmptyElementPairsSamePrinterParser() { [EOL] PeriodFormatterBuilder builder = new PeriodFormatterBuilder(); [EOL] builder.appendLiteral("Literal"); [EOL] builder.appendField(1); [EOL] PeriodFieldAffix suffix = new MockPeriodFieldAffix(); [EOL] builder.appendSuffix(suffix); [EOL] assertNotNull(builder); [EOL] }
public void testAppendSeparatorIfFieldsBefore() { [EOL] PeriodFormatterBuilder builder = new PeriodFormatterBuilder(); [EOL] PeriodFormatterBuilder result = builder.appendSeparatorIfFieldsBefore(","); [EOL] assertNotNull(result); [EOL] }
public void testClearPrefix_WithNonNullPrefix_ThrowsException() { [EOL] TimeTestClass obj = new TimeTestClass(); [EOL] obj.setPrefix(new Prefix()); // Assuming setPrefix is a method to set iPrefix [EOL] try { [EOL] obj.clearPrefix(); [EOL] fail("Expected an IllegalStateException to be thrown"); [EOL] } catch (IllegalStateException e) { [EOL] assertEquals("Prefix not followed by field", e.getMessage()); [EOL] } [EOL] }
public void testClearPrefix_WithNullPrefix_DoesNotThrowException() { [EOL] TimeTestClass obj = new TimeTestClass(); [EOL] obj.setPrefix(null); // Assuming setPrefix is a method to set iPrefix [EOL] try { [EOL] obj.clearPrefix(); [EOL] } catch (IllegalStateException e) { [EOL] fail("No exception should be thrown when iPrefix is null"); [EOL] } [EOL] }
public void testParseWithLongerPluralText() { [EOL] String periodStr = "hours"; [EOL] int position = 0; [EOL] PeriodParser parser = new PeriodParser("hour", "hours"); [EOL] int result = parser.parse(periodStr, position); [EOL] assertEquals(5, result); [EOL] }
public void testParseWithLongerSingularText() { [EOL] String periodStr = "hour"; [EOL] int position = 0; [EOL] PeriodParser parser = new PeriodParser("hours", "hour"); [EOL] int result = parser.parse(periodStr, position); [EOL] assertEquals(4, result); [EOL] }
public void testParseWithNoMatch() { [EOL] String periodStr = "minutes"; [EOL] int position = 0; [EOL] PeriodParser parser = new PeriodParser("hour", "hours"); [EOL] int result = parser.parse(periodStr, position); [EOL] assertEquals(~position, result); [EOL] }
public void testScanWithLongerPluralText() { [EOL] TimePeriodParser parser = new TimePeriodParser("hours", "hour"); [EOL] String periodStr = "2 hours"; [EOL] int position = 0; [EOL] int result = parser.scan(periodStr, position); [EOL] assertEquals(2, result); [EOL] }
public void testScanWithLongerSingularText() { [EOL] TimePeriodParser parser = new TimePeriodParser("hour", "hours"); [EOL] String periodStr = "1 hour"; [EOL] int position = 0; [EOL] int result = parser.scan(periodStr, position); [EOL] assertEquals(2, result); [EOL] }
public void testScanWithNoMatch() { [EOL] TimePeriodParser parser = new TimePeriodParser("hours", "hour"); [EOL] String periodStr = "minutes"; [EOL] int position = 0; [EOL] int result = parser.scan(periodStr, position); [EOL] assertEquals(~position, result); [EOL] }
public void testFieldFormatterWithNonNullSuffix() { [EOL] FieldFormatter original = new FieldFormatter(); [EOL] PeriodFieldAffix suffix = new PeriodFieldAffix(); [EOL] FieldFormatter formatter = new FieldFormatter(original, suffix); [EOL] assertEquals(original.iMinPrintedDigits, formatter.iMinPrintedDigits); [EOL] assertEquals(original.iPrintZeroSetting, formatter.iPrintZeroSetting); [EOL] assertEquals(original.iMaxParsedDigits, formatter.iMaxParsedDigits); [EOL] assertEquals(original.iRejectSignedValues, formatter.iRejectSignedValues); [EOL] assertEquals(original.iFieldType, formatter.iFieldType); [EOL] assertEquals(original.iFieldFormatters, formatter.iFieldFormatters); [EOL] assertEquals(original.iPrefix, formatter.iPrefix); [EOL] assertNotNull(formatter.iSuffix); [EOL] }
public void testFieldFormatterWithNullSuffix() { [EOL] FieldFormatter original = new FieldFormatter(); [EOL] original.iSuffix = null; [EOL] PeriodFieldAffix suffix = new PeriodFieldAffix(); [EOL] FieldFormatter formatter = new FieldFormatter(original, suffix); [EOL] assertEquals(original.iMinPrintedDigits, formatter.iMinPrintedDigits); [EOL] assertEquals(original.iPrintZeroSetting, formatter.iPrintZeroSetting); [EOL] assertEquals(original.iMaxParsedDigits, formatter.iMaxParsedDigits); [EOL] assertEquals(original.iRejectSignedValues, formatter.iRejectSignedValues); [EOL] assertEquals(original.iFieldType, formatter.iFieldType); [EOL] assertEquals(original.iFieldFormatters, formatter.iFieldFormatters); [EOL] assertEquals(original.iPrefix, formatter.iPrefix); [EOL] assertEquals(suffix, formatter.iSuffix); [EOL] }
public void testCalculatePrintedLength_MaxValue() { [EOL] ReadablePeriod mockPeriod = mock(ReadablePeriod.class); [EOL] when(getFieldValue(mockPeriod)).thenReturn(Long.MAX_VALUE); [EOL] int result = calculatePrintedLength(mockPeriod, Locale.getDefault()); [EOL] assertEquals(0, result); [EOL] }
public void testCalculatePrintedLength_NegativeValue() { [EOL] ReadablePeriod mockPeriod = mock(ReadablePeriod.class); [EOL] when(getFieldValue(mockPeriod)).thenReturn(-12345L); [EOL] int result = calculatePrintedLength(mockPeriod, Locale.getDefault()); [EOL] assertTrue(result >= 5); [EOL] }
public void testCalculatePrintedLength_PositiveValue() { [EOL] ReadablePeriod mockPeriod = mock(ReadablePeriod.class); [EOL] when(getFieldValue(mockPeriod)).thenReturn(12345L); [EOL] int result = calculatePrintedLength(mockPeriod, Locale.getDefault()); [EOL] assertTrue(result >= 4); [EOL] }
public void testCalculatePrintedLength_WithPrefix() { [EOL] ReadablePeriod mockPeriod = mock(ReadablePeriod.class); [EOL] when(getFieldValue(mockPeriod)).thenReturn(12345L); [EOL] when(iPrefix.calculatePrintedLength(anyInt())).thenReturn(2); [EOL] int result = calculatePrintedLength(mockPeriod, Locale.getDefault()); [EOL] assertTrue(result >= 6); [EOL] }
public void testCalculatePrintedLength_WithSuffix() { [EOL] ReadablePeriod mockPeriod = mock(ReadablePeriod.class); [EOL] when(getFieldValue(mockPeriod)).thenReturn(12345L); [EOL] when(iSuffix.calculatePrintedLength(anyInt())).thenReturn(3); [EOL] int result = calculatePrintedLength(mockPeriod, Locale.getDefault()); [EOL] assertTrue(result >= 7); [EOL] }
public void testCalculatePrintedLength_WithSecondsOptionalMillis() { [EOL] ReadablePeriod mockPeriod = mock(ReadablePeriod.class); [EOL] when(getFieldValue(mockPeriod)).thenReturn(DateTimeConstants.MILLIS_PER_SECOND); [EOL] int result = calculatePrintedLength(mockPeriod, Locale.getDefault()); [EOL] assertEquals(1, result); [EOL] }
public void testPrintToWithMaxValue() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] ReadablePeriod period = mock(ReadablePeriod.class); [EOL] when(getFieldValue(period)).thenReturn(Long.MAX_VALUE); [EOL] printTo(buf, period, Locale.ENGLISH); [EOL] assertEquals("", buf.toString()); [EOL] }
public void testPrintToWithSecondsMillis() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] ReadablePeriod period = mock(ReadablePeriod.class); [EOL] when(getFieldValue(period)).thenReturn(123456789L); [EOL] iFieldType = SECONDS_MILLIS; [EOL] printTo(buf, period, Locale.ENGLISH); [EOL] assertTrue(buf.toString().contains("123")); [EOL] assertTrue(buf.toString().contains(".789")); [EOL] }
public void testPrintToWithPrefix() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] ReadablePeriod period = mock(ReadablePeriod.class); [EOL] when(getFieldValue(period)).thenReturn(123L); [EOL] iPrefix = mock(PeriodFieldAffix.class); [EOL] printTo(buf, period, Locale.ENGLISH); [EOL] verify(iPrefix).printTo(eq(buf), anyInt()); [EOL] }
public void testPrintToWithMinDigits() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] ReadablePeriod period = mock(ReadablePeriod.class); [EOL] when(getFieldValue(period)).thenReturn(9L); [EOL] iMinPrintedDigits = 2; [EOL] printTo(buf, period, Locale.ENGLISH); [EOL] assertTrue(buf.toString().startsWith("09")); [EOL] }
public void testPrintToWithNegativeSecondsMillis() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] ReadablePeriod period = mock(ReadablePeriod.class); [EOL] when(getFieldValue(period)).thenReturn(-123L); [EOL] iFieldType = SECONDS_MILLIS; [EOL] printTo(buf, period, Locale.ENGLISH); [EOL] assertTrue(buf.toString().startsWith("-0")); [EOL] assertTrue(buf.toString().contains(".123")); [EOL] }
public void testPrintToWithSuffix() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] ReadablePeriod period = mock(ReadablePeriod.class); [EOL] when(getFieldValue(period)).thenReturn(123L); [EOL] iSuffix = mock(PeriodFieldAffix.class); [EOL] printTo(buf, period, Locale.ENGLISH); [EOL] verify(iSuffix).printTo(eq(buf), anyInt()); [EOL] }
public int parseInto(ReadWritablePeriod period, String text, int position, Locale locale) { [EOL] boolean mustParse = (iPrintZeroSetting == PRINT_ZERO_ALWAYS); [EOL] if (position >= text.length()) { [EOL] return mustParse ? ~position : position; [EOL] } [EOL] if (iPrefix != null) { [EOL] position = iPrefix.parse(text, position); [EOL] if (position >= 0) { [EOL] mustParse = true; [EOL] } else { [EOL] if (!mustParse) { [EOL] return ~position; [EOL] } [EOL] return position; [EOL] } [EOL] } [EOL] int suffixPos = -1; [EOL] if (iSuffix != null && !mustParse) { [EOL] suffixPos = iSuffix.scan(text, position); [EOL] if (suffixPos >= 0) { [EOL] mustParse = true; [EOL] } else { [EOL] if (!mustParse) { [EOL] return ~suffixPos; [EOL] } [EOL] return suffixPos; [EOL] } [EOL] } [EOL] if (!mustParse && !isSupported(period.getPeriodType(), iFieldType)) { [EOL] return position; [EOL] } [EOL] int limit; [EOL] if (suffixPos > 0) { [EOL] limit = Math.min(iMaxParsedDigits, suffixPos - position); [EOL] } else { [EOL] limit = Math.min(iMaxParsedDigits, text.length() - position); [EOL] } [EOL] int length = 0; [EOL] int fractPos = -1; [EOL] boolean hasDigits = false; [EOL] while (length < limit) { [EOL] char c = text.charAt(position + length); [EOL] if (length == 0 && (c == '-' || c == '+') && !iRejectSignedValues) { [EOL] boolean negative = c == '-'; [EOL] if (length + 1 >= limit || (c = text.charAt(position + length + 1)) < '0' || c > '9') { [EOL] break; [EOL] } [EOL] if (negative) { [EOL] length++; [EOL] } else { [EOL] position++; [EOL] } [EOL] limit = Math.min(limit + 1, text.length() - position); [EOL] continue; [EOL] } [EOL] if (c >= '0' && c <= '9') { [EOL] hasDigits = true; [EOL] } else { [EOL] if ((c == '.' || c == ',') && (iFieldType == SECONDS_MILLIS || iFieldType == SECONDS_OPTIONAL_MILLIS)) { [EOL] if (fractPos >= 0) { [EOL] break; [EOL] } [EOL] fractPos = position + length + 1; [EOL] limit = Math.min(limit + 1, text.length() - position); [EOL] } else { [EOL] break; [EOL] } [EOL] } [EOL] length++; [EOL] } [EOL] if (!hasDigits) { [EOL] return ~position; [EOL] } [EOL] if (suffixPos >= 0 && position + length != suffixPos) { [EOL] return position; [EOL] } [EOL] if (iFieldType != SECONDS_MILLIS && iFieldType != SECONDS_OPTIONAL_MILLIS) { [EOL] setFieldValue(period, iFieldType, parseInt(text, position, length)); [EOL] } else if (fractPos < 0) { [EOL] setFieldValue(period, SECONDS, parseInt(text, position, length)); [EOL] setFieldValue(period, MILLIS, 0); [EOL] } else { [EOL] int wholeValue = parseInt(text, position, fractPos - position - 1); [EOL] setFieldValue(period, SECONDS, wholeValue); [EOL] int fractLen = position + length - fractPos; [EOL] int fractValue; [EOL] if (fractLen <= 0) { [EOL] fractValue = 0; [EOL] } else { [EOL] if (fractLen >= 3) { [EOL] fractValue = parseInt(text, fractPos, 3); [EOL] } else { [EOL] fractValue = parseInt(text, fractPos, fractLen); [EOL] if (fractLen == 1) { [EOL] fractValue *= 100; [EOL] } else { [EOL] fractValue *= 10; [EOL] } [EOL] } [EOL] if (wholeValue < 0) { [EOL] fractValue = -fractValue; [EOL] } [EOL] } [EOL] setFieldValue(period, MILLIS, fractValue); [EOL] } [EOL] position += length; [EOL] if (position >= 0 && iSuffix != null) { [EOL] position = iSuffix.parse(text, position); [EOL] } [EOL] return position; [EOL] }
public void testGetFieldValue_PrintZeroAlwaysAndTypeNotNullAndFieldTypeNotSupported() { [EOL] ReadablePeriod period = createMockReadablePeriodWithNonNullType(); [EOL] setupPrintZeroSetting(PRINT_ZERO_ALWAYS); [EOL] setupFieldTypeSupported(false); [EOL] long result = getFieldValue(period); [EOL] assertEquals(Long.MAX_VALUE, result); [EOL] } [EOL] public void testGetFieldValue_PrintZeroAlwaysAndTypeNotNullAndFieldTypeSupported() { [EOL] ReadablePeriod period = createMockReadablePeriodWithNonNullType(); [EOL] setupPrintZeroSetting(PRINT_ZERO_ALWAYS); [EOL] setupFieldTypeSupported(true); [EOL] setupFieldValueFromPeriod(period, 10L); [EOL] long result = getFieldValue(period); [EOL] assertEquals(10L, result); [EOL] } [EOL] public void testGetFieldValue_PrintZeroNotAlwaysAndTypeNull() { [EOL] ReadablePeriod period = createMockReadablePeriodWithNullType(); [EOL] setupPrintZeroSetting(PRINT_ZERO_RARELY_LAST); // Use any setting other than PRINT_ZERO_ALWAYS [EOL] long result = getFieldValue(period); [EOL] assertEquals(Long.MAX_VALUE, result); [EOL] } [EOL] public void testGetFieldValue_ValueIsZeroAndPrintZeroNever() { [EOL] ReadablePeriod period = createMockReadablePeriodWithValueZero(); [EOL] setupPrintZeroSetting(PRINT_ZERO_NEVER); [EOL] long result = getFieldValue(period); [EOL] assertEquals(Long.MAX_VALUE, result); [EOL] } [EOL] public void testGetFieldValue_ValueIsZeroAndPrintZeroRarelyLastWithNonZeroFieldsAfter() { [EOL] ReadablePeriod period = createMockReadablePeriodWithValueZero(); [EOL] setupPrintZeroSetting(PRINT_ZERO_RARELY_LAST); [EOL] setupIsZero(period, true); [EOL] setupFieldFormattersWithThisAndNonZeroFieldsAfter(); [EOL] long result = getFieldValue(period); [EOL] assertEquals(Long.MAX_VALUE, result); [EOL] } [EOL] public void testGetFieldValue_ValueIsZeroAndPrintZeroRarelyLastWithZeroFieldsAfter() { [EOL] ReadablePeriod period = createMockReadablePeriodWithValueZero(); [EOL] setupPrintZeroSetting(PRINT_ZERO_RARELY_LAST); [EOL] setupIsZero(period, true); [EOL] setupFieldFormattersWithThisAndZeroFieldsAfter(); [EOL] long result = getFieldValue(period); [EOL] assertNotEquals(Long.MAX_VALUE, result); [EOL] } [EOL] public void testGetFieldValue_ValueIsZeroAndPrintZeroRarelyFirstWithNonZeroFieldsBefore() { [EOL] ReadablePeriod period = createMockReadablePeriodWithValueZero(); [EOL] setupPrintZeroSetting(PRINT_ZERO_RARELY_FIRST); [EOL] setupIsZero(period, true); [EOL] setupFieldFormattersWithThisAndNonZeroFieldsBefore(); [EOL] long result = getFieldValue(period); [EOL] assertEquals(Long.MAX_VALUE, result); [EOL] } [EOL] public void testGetFieldValue_ValueIsZeroAndPrintZeroRarelyFirstWithZeroFieldsBefore() { [EOL] ReadablePeriod period = createMockReadablePeriodWithValueZero(); [EOL] setupPrintZeroSetting(PRINT_ZERO_RARELY_FIRST); [EOL] setupIsZero(period, true); [EOL] setupFieldFormattersWithThisAndZeroFieldsBefore(); [EOL] long result = getFieldValue(period); [EOL] assertNotEquals(Long.MAX_VALUE, result); [EOL] } [EOL] public void testGetFieldValue_ValueIsNonZero() { [EOL] ReadablePeriod period = createMockReadablePeriodWithValueNonZero(); [EOL] setupPrintZeroSetting(PRINT_ZERO_RARELY_LAST); // Use any setting other than PRINT_ZERO_NEVER [EOL] setupFieldValueFromPeriod(period, 10L); [EOL] long result = getFieldValue(period); [EOL] assertEquals(10L, result); [EOL] }

public void testGetFieldType() { [EOL] TimeFieldTypeExample example = new TimeFieldTypeExample(1); [EOL] assertEquals(1, example.getFieldType()); [EOL] }
public int countFieldsToPrint(ReadablePeriod period, int stopAt, Locale locale) { [EOL] return 0; [EOL] }
public int calculatePrintedLength(ReadablePeriod period, Locale locale) { [EOL] return iText.length(); [EOL] }
public void printToTestWithNonNullArgs() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] ReadablePeriod period = new MockReadablePeriod(); [EOL] Locale locale = Locale.ENGLISH; [EOL] PeriodFormatter pf = new PeriodFormatter(null, null); [EOL] pf.printTo(buf, period, locale); [EOL] assertEquals("Expected text to be appended to buffer", pf.iText, buf.toString()); [EOL] }
public void testCalculatePrintedLength_BothBeforeAndAfterUsedWithMultipleFields() { [EOL] ReadablePeriod mockPeriod = mock(ReadablePeriod.class); [EOL] Locale mockLocale = Locale.ENGLISH; [EOL] PeriodPrinter mockBeforePrinter = mock(PeriodPrinter.class); [EOL] PeriodPrinter mockAfterPrinter = mock(PeriodPrinter.class); [EOL] when(mockBeforePrinter.calculatePrintedLength(mockPeriod, mockLocale)).thenReturn(5); [EOL] when(mockAfterPrinter.calculatePrintedLength(mockPeriod, mockLocale)).thenReturn(3); [EOL] when(mockBeforePrinter.countFieldsToPrint(mockPeriod, 1, mockLocale)).thenReturn(1); [EOL] when(mockAfterPrinter.countFieldsToPrint(mockPeriod, 2, mockLocale)).thenReturn(2); [EOL] when(iText.length()).thenReturn(4); [EOL] when(iFinalText.length()).thenReturn(6); [EOL] iUseBefore = true; [EOL] iUseAfter = true; [EOL] iBeforePrinter = mockBeforePrinter; [EOL] iAfterPrinter = mockAfterPrinter; [EOL] int result = calculatePrintedLength(mockPeriod, mockLocale); [EOL] assertEquals(14, result); [EOL] }
public void testCalculatePrintedLength_OnlyBeforeUsed() { [EOL] ReadablePeriod mockPeriod = mock(ReadablePeriod.class); [EOL] Locale mockLocale = Locale.ENGLISH; [EOL] PeriodPrinter mockBeforePrinter = mock(PeriodPrinter.class); [EOL] when(mockBeforePrinter.calculatePrintedLength(mockPeriod, mockLocale)).thenReturn(5); [EOL] when(mockBeforePrinter.countFieldsToPrint(mockPeriod, 1, mockLocale)).thenReturn(1); [EOL] when(iText.length()).thenReturn(4); [EOL] iUseBefore = true; [EOL] iUseAfter = false; [EOL] iBeforePrinter = mockBeforePrinter; [EOL] int result = calculatePrintedLength(mockPeriod, mockLocale); [EOL] assertEquals(9, result); [EOL] }
public void testCalculatePrintedLength_OnlyAfterUsed() { [EOL] ReadablePeriod mockPeriod = mock(ReadablePeriod.class); [EOL] Locale mockLocale = Locale.ENGLISH; [EOL] PeriodPrinter mockAfterPrinter = mock(PeriodPrinter.class); [EOL] when(mockAfterPrinter.calculatePrintedLength(mockPeriod, mockLocale)).thenReturn(3); [EOL] when(mockAfterPrinter.countFieldsToPrint(mockPeriod, 1, mockLocale)).thenReturn(1); [EOL] when(iText.length()).thenReturn(4); [EOL] iUseBefore = false; [EOL] iUseAfter = true; [EOL] iAfterPrinter = mockAfterPrinter; [EOL] int result = calculatePrintedLength(mockPeriod, mockLocale); [EOL] assertEquals(7, result); [EOL] }
public void testCalculatePrintedLength_NeitherBeforeNorAfterUsed() { [EOL] ReadablePeriod mockPeriod = mock(ReadablePeriod.class); [EOL] Locale mockLocale = Locale.ENGLISH; [EOL] PeriodPrinter mockBeforePrinter = mock(PeriodPrinter.class); [EOL] PeriodPrinter mockAfterPrinter = mock(PeriodPrinter.class); [EOL] when(mockBeforePrinter.calculatePrintedLength(mockPeriod, mockLocale)).thenReturn(5); [EOL] when(mockAfterPrinter.calculatePrintedLength(mockPeriod, mockLocale)).thenReturn(3); [EOL] iUseBefore = false; [EOL] iUseAfter = false; [EOL] iBeforePrinter = mockBeforePrinter; [EOL] iAfterPrinter = mockAfterPrinter; [EOL] int result = calculatePrintedLength(mockPeriod, mockLocale); [EOL] assertEquals(8, result); [EOL] }
public void testPrintToWithBeforeAndAfter() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] ReadablePeriod period = createMockReadablePeriod(); [EOL] Locale locale = Locale.ENGLISH; [EOL] PeriodPrinter before = createMockPeriodPrinter(); [EOL] PeriodPrinter after = createMockPeriodPrinter(); [EOL] before.printTo(buf, period, locale); [EOL] expect(before.countFieldsToPrint(period, 1, locale)).andReturn(1); [EOL] after.printTo(buf, period, locale); [EOL] expect(after.countFieldsToPrint(period, 2, locale)).andReturn(2); [EOL] CompositePeriodPrinter printer = new CompositePeriodPrinter(before, after, true, true, "Text", "FinalText"); [EOL] printer.printTo(buf, period, locale); [EOL] verify(before); [EOL] verify(after); [EOL] assertEquals("Expected buffer to contain the correct text", "Text", buf.toString()); [EOL] }
public void testPrintToWithBeforeOnly() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] ReadablePeriod period = createMockReadablePeriod(); [EOL] Locale locale = Locale.ENGLISH; [EOL] PeriodPrinter before = createMockPeriodPrinter(); [EOL] PeriodPrinter after = createMockPeriodPrinter(); [EOL] before.printTo(buf, period, locale); [EOL] expect(before.countFieldsToPrint(period, 1, locale)).andReturn(1); [EOL] after.printTo(buf, period, locale); [EOL] expect(after.countFieldsToPrint(period, 1, locale)).andReturn(0); [EOL] CompositePeriodPrinter printer = new CompositePeriodPrinter(before, after, true, false, "Text", "FinalText"); [EOL] printer.printTo(buf, period, locale); [EOL] verify(before); [EOL] verify(after); [EOL] assertEquals("Expected buffer to contain the correct text", "Text", buf.toString()); [EOL] }
public void testPrintToWithAfterOnly() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] ReadablePeriod period = createMockReadablePeriod(); [EOL] Locale locale = Locale.ENGLISH; [EOL] PeriodPrinter before = createMockPeriodPrinter(); [EOL] PeriodPrinter after = createMockPeriodPrinter(); [EOL] before.printTo(buf, period, locale); [EOL] expect(before.countFieldsToPrint(period, 1, locale)).andReturn(0); [EOL] after.printTo(buf, period, locale); [EOL] expect(after.countFieldsToPrint(period, 1, locale)).andReturn(1); [EOL] CompositePeriodPrinter printer = new CompositePeriodPrinter(before, after, false, true, "Text", "FinalText"); [EOL] printer.printTo(buf, period, locale); [EOL] verify(before); [EOL] verify(after); [EOL] assertEquals("Expected buffer to contain the correct text", "Text", buf.toString()); [EOL] }
public void testPrintToWithNeitherBeforeNorAfter() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] ReadablePeriod period = createMockReadablePeriod(); [EOL] Locale locale = Locale.ENGLISH; [EOL] PeriodPrinter before = createMockPeriodPrinter(); [EOL] PeriodPrinter after = createMockPeriodPrinter(); [EOL] before.printTo(buf, period, locale); [EOL] expect(before.countFieldsToPrint(period, 1, locale)).andReturn(0); [EOL] after.printTo(buf, period, locale); [EOL] expect(after.countFieldsToPrint(period, 1, locale)).andReturn(0); [EOL] CompositePeriodPrinter printer = new CompositePeriodPrinter(before, after, false, false, "Text", "FinalText"); [EOL] printer.printTo(buf, period, locale); [EOL] verify(before); [EOL] verify(after); [EOL] assertEquals("Expected buffer to be empty", "", buf.toString()); [EOL] }
public void testParseInto_PositionNegative() { [EOL] ReadWritablePeriod mockPeriod = createMockPeriod(); [EOL] String periodStr = "test"; [EOL] int position = -1; [EOL] Locale locale = Locale.getDefault(); [EOL] int result = parseInto(mockPeriod, periodStr, position, locale); [EOL] assertEquals(position, result); [EOL] }
public void testParseInto_BeforeParserMovesPosition() { [EOL] ReadWritablePeriod mockPeriod = createMockPeriod(); [EOL] String periodStr = "test"; [EOL] int position = 0; [EOL] Locale locale = Locale.getDefault(); [EOL] int newPosition = 1; // Simulate that position has moved [EOL] setBeforeParser(newPosition); [EOL] int result = parseInto(mockPeriod, periodStr, position, locale); [EOL] assertEquals(newPosition, result); [EOL] }
public void testParseInto_FoundParsedForm() { [EOL] ReadWritablePeriod mockPeriod = createMockPeriod(); [EOL] String periodStr = "testForm"; [EOL] int position = 0; [EOL] Locale locale = Locale.getDefault(); [EOL] int newPosition = 1; // Simulate that position has moved [EOL] setBeforeParser(newPosition); [EOL] setParsedForms(new String[]{"Form"}); [EOL] int result = parseInto(mockPeriod, periodStr, position, locale); [EOL] assertEquals(newPosition + "Form".length(), result); [EOL] }
public void testParseInto_NotFoundParsedFormAndUseBeforeFalse() { [EOL] ReadWritablePeriod mockPeriod = createMockPeriod(); [EOL] String periodStr = "test"; [EOL] int position = 0; [EOL] Locale locale = Locale.getDefault(); [EOL] int newPosition = 1; // Simulate that position has moved [EOL] setBeforeParser(newPosition); [EOL] setParsedForms(new String[]{""}); // Empty parsed form [EOL] setUseBefore(false); [EOL] int result = parseInto(mockPeriod, periodStr, position, locale); [EOL] assertEquals(~newPosition, result); [EOL] }
public void testParseInto_AfterParserNegative() { [EOL] ReadWritablePeriod mockPeriod = createMockPeriod(); [EOL] String periodStr = "test"; [EOL] int position = 0; [EOL] Locale locale = Locale.getDefault(); [EOL] int newPosition = 1; // Simulate that position has moved [EOL] setBeforeParser(newPosition); [EOL] setAfterParser(-1); // Simulate that after parser returns negative [EOL] int result = parseInto(mockPeriod, periodStr, position, locale); [EOL] assertEquals(-1, result); [EOL] }
public void testParseInto_FoundAndPositionUnchanged() { [EOL] ReadWritablePeriod mockPeriod = createMockPeriod(); [EOL] String periodStr = "testForm"; [EOL] int position = 0; [EOL] Locale locale = Locale.getDefault(); [EOL] int newPosition = 1; // Simulate that position has moved [EOL] setBeforeParser(newPosition); [EOL] setParsedForms(new String[]{"Form"}); [EOL] setAfterParser(newPosition); // Simulate that after parser doesn't change position [EOL] int result = parseInto(mockPeriod, periodStr, position, locale); [EOL] assertEquals(~newPosition, result); [EOL] }
public long add_noChange() { [EOL] long instant = 1234567890L; [EOL] int years = 0; [EOL] long result = add(instant, years); [EOL] assertEquals(instant, result); [EOL] }
public long add_positiveYears() { [EOL] long instant = 1234567890L; [EOL] int years = 5; [EOL] long expected = instant + years; // Assuming set and get methods work as simple add and retrieve [EOL] long result = add(instant, years); [EOL] assertEquals(expected, result); [EOL] }
public long add_negativeYears() { [EOL] long instant = 1234567890L; [EOL] int years = -5; [EOL] long expected = instant + years; // Assuming set and get methods work as simple add and retrieve [EOL] long result = add(instant, years); [EOL] assertEquals(expected, result); [EOL] }
public long addWrapField(long instant, int years) { [EOL] return add(instant, years); [EOL] }
public void testGetDifferenceAsLong_MinuendLessThanSubtrahend() { [EOL] long minuendInstant = 100L; [EOL] long subtrahendInstant = 200L; [EOL] long result = time.getDifferenceAsLong(minuendInstant, subtrahendInstant); [EOL] assertEquals(-time.getDifference(subtrahendInstant, minuendInstant), result); [EOL] }
public void testGetDifferenceAsLong_MinuendGreaterThanSubtrahend_RemainderLess() { [EOL] long minuendInstant = 200L; [EOL] long subtrahendInstant = 100L; [EOL] when(time.get(minuendInstant)).thenReturn(2023); [EOL] when(time.get(subtrahendInstant)).thenReturn(2022); [EOL] when(time.remainder(minuendInstant)).thenReturn(100L); [EOL] when(time.remainder(subtrahendInstant)).thenReturn(200L); [EOL] when(time.iChronology.getWeeksInYear(2023)).thenReturn(52); [EOL] long result = time.getDifferenceAsLong(minuendInstant, subtrahendInstant); [EOL] assertEquals(-1, result); [EOL] }
public void testGetDifferenceAsLong_MinuendGreaterThanSubtrahend_RemainderGreater() { [EOL] long minuendInstant = 200L; [EOL] long subtrahendInstant = 100L; [EOL] when(time.get(minuendInstant)).thenReturn(2023); [EOL] when(time.get(subtrahendInstant)).thenReturn(2022); [EOL] when(time.remainder(minuendInstant)).thenReturn(200L); [EOL] when(time.remainder(subtrahendInstant)).thenReturn(100L); [EOL] when(time.iChronology.getWeeksInYear(2023)).thenReturn(52); [EOL] long result = time.getDifferenceAsLong(minuendInstant, subtrahendInstant); [EOL] assertEquals(1, result); [EOL] }
public void testGetDifferenceAsLong_SubtrahendRemainderGreaterEqualWeek53() { [EOL] long minuendInstant = 200L; [EOL] long subtrahendInstant = 100L; [EOL] when(time.get(minuendInstant)).thenReturn(2023); [EOL] when(time.get(subtrahendInstant)).thenReturn(2022); [EOL] when(time.remainder(minuendInstant)).thenReturn(100L); [EOL] when(time.remainder(subtrahendInstant)).thenReturn(DateTimeConstants.MILLIS_PER_WEEK * 53); [EOL] when(time.iChronology.getWeeksInYear(2023)).thenReturn(52); [EOL] long result = time.getDifferenceAsLong(minuendInstant, subtrahendInstant); [EOL] assertEquals(0, result); [EOL] }
public long set(long instant, int year) { [EOL] FieldUtils.verifyValueBounds(this, Math.abs(year), iChronology.getMinYear(), iChronology.getMaxYear()); [EOL] int thisWeekyear = get(instant); [EOL] if (thisWeekyear == year) { [EOL] return instant; [EOL] } [EOL] int thisDow = iChronology.getDayOfWeek(instant); [EOL] int weeksInFromYear = iChronology.getWeeksInYear(thisWeekyear); [EOL] int weeksInToYear = iChronology.getWeeksInYear(year); [EOL] int maxOutWeeks = (weeksInToYear < weeksInFromYear) ? weeksInToYear : weeksInFromYear; [EOL] int setToWeek = iChronology.getWeekOfWeekyear(instant); [EOL] if (setToWeek > maxOutWeeks) { [EOL] setToWeek = maxOutWeeks; [EOL] } [EOL] long workInstant = instant; [EOL] workInstant = iChronology.setYear(workInstant, year); [EOL] int workWoyYear = get(workInstant); [EOL] if (workWoyYear < year) { [EOL] workInstant += DateTimeConstants.MILLIS_PER_WEEK; [EOL] } else if (workWoyYear > year) { [EOL] workInstant -= DateTimeConstants.MILLIS_PER_WEEK; [EOL] } [EOL] int currentWoyWeek = iChronology.getWeekOfWeekyear(workInstant); [EOL] workInstant = workInstant + (setToWeek - currentWoyWeek) * (long) DateTimeConstants.MILLIS_PER_WEEK; [EOL] workInstant = iChronology.dayOfWeek().set(workInstant, thisDow); [EOL] return workInstant; [EOL] }
public void testIsLeap_WeeksInYearGreaterThan52() { [EOL] long instant = /* provide an instant for which the weeks in year is greater than 52 */; [EOL] boolean result = isLeap(instant); [EOL] assertTrue(result); [EOL] }
public void testIsLeap_WeeksInYearNotGreaterThan52() { [EOL] long instant = /* provide an instant for which the weeks in year is not greater than 52 */; [EOL] boolean result = isLeap(instant); [EOL] assertFalse(result); [EOL] }
public int getLeapAmount(long instant) { [EOL] return iChronology.getWeeksInYear(iChronology.getWeekyear(instant)) - 52; [EOL] }
public long remainder_whenInstantIsZero() { [EOL] long instant = 0L; [EOL] long expected = 0L; [EOL] long actual = remainder(instant); [EOL] assertEquals(expected, actual); [EOL] }
public long remainder_whenInstantIsPositive() { [EOL] long instant = 12345L; [EOL] long expected = instant - roundFloor(instant); [EOL] long actual = remainder(instant); [EOL] assertEquals(expected, actual); [EOL] }
public long remainder_whenInstantIsNegative() { [EOL] long instant = -12345L; [EOL] long expected = instant - roundFloor(instant); [EOL] long actual = remainder(instant); [EOL] assertEquals(expected, actual); [EOL] }
public static DateTimeFormatter shortTime() { [EOL] return createFormatterForStyleIndex(NONE, SHORT); [EOL] }
public void testForPattern_ValidPattern() { [EOL] String pattern = "yyyy-MM-dd"; [EOL] DateTimeFormatter formatter = DateTimeFormat.forPattern(pattern); [EOL] assertNotNull(formatter); [EOL] } [EOL] public void testForStyle_ValidStyle() { [EOL] String style = "SS"; [EOL] DateTimeFormatter formatter = DateTimeFormat.forStyle(style); [EOL] assertNotNull(formatter); [EOL] } [EOL] public void testPatternForStyle_ValidArguments() { [EOL] String style = "SS"; [EOL] Locale locale = Locale.US; [EOL] String pattern = DateTimeFormat.patternForStyle(style, locale); [EOL] assertNotNull(pattern); [EOL] } [EOL] public void testShortDate() { [EOL] DateTimeFormatter formatter = DateTimeFormat.shortDate(); [EOL] assertNotNull(formatter); [EOL] } [EOL] public void testShortTime() { [EOL] DateTimeFormatter formatter = DateTimeFormat.shortTime(); [EOL] assertNotNull(formatter); [EOL] } [EOL] public void testShortDateTime() { [EOL] DateTimeFormatter formatter = DateTimeFormat.shortDateTime(); [EOL] assertNotNull(formatter); [EOL] } [EOL] public void testMediumDate() { [EOL] DateTimeFormatter formatter = DateTimeFormat.mediumDate(); [EOL] assertNotNull(formatter); [EOL] } [EOL] public void testMediumTime() { [EOL] DateTimeFormatter formatter = DateTimeFormat.mediumTime(); [EOL] assertNotNull(formatter); [EOL] } [EOL] public void testMediumDateTime() { [EOL] DateTimeFormatter formatter = DateTimeFormat.mediumDateTime(); [EOL] assertNotNull(formatter); [EOL] } [EOL] public void testLongDate() { [EOL] DateTimeFormatter formatter = DateTimeFormat.longDate(); [EOL] assertNotNull(formatter); [EOL] } [EOL] public void testLongTime() { [EOL] DateTimeFormatter formatter = DateTimeFormat.longTime(); [EOL] assertNotNull(formatter); [EOL] } [EOL] public void testLongDateTime() { [EOL] DateTimeFormatter formatter = DateTimeFormat.longDateTime(); [EOL] assertNotNull(formatter); [EOL] } [EOL] public void testFullDate() { [EOL] DateTimeFormatter formatter = DateTimeFormat.fullDate(); [EOL] assertNotNull(formatter); [EOL] } [EOL] public void testFullTime() { [EOL] DateTimeFormatter formatter = DateTimeFormat.fullTime(); [EOL] assertNotNull(formatter); [EOL] } [EOL] public void testFullDateTime() { [EOL] DateTimeFormatter formatter = DateTimeFormat.fullDateTime(); [EOL] assertNotNull(formatter); [EOL] } [EOL] public void testRemoveEldestEntry() { [EOL] LinkedHashMap<String, DateTimeFormatter> map = new LinkedHashMap<>(); [EOL] map.put("key1", DateTimeFormat.shortDate()); [EOL] boolean result = map.removeEldestEntry(new AbstractMap.SimpleEntry<>("keyToRemove", DateTimeFormat.shortDate())); [EOL] assertTrue(result); [EOL] }
private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern) { [EOL] int length = pattern.length(); [EOL] int[] indexRef = new int[1]; [EOL] for (int i = 0; i < length; i++) { [EOL] indexRef[0] = i; [EOL] String token = parseToken(pattern, indexRef); [EOL] i = indexRef[0]; [EOL] int tokenLen = token.length(); [EOL] if (tokenLen == 0) { [EOL] break; [EOL] } [EOL] char c = token.charAt(0); [EOL] switch(c) { [EOL] case 'G': [EOL] builder.appendEraText(); [EOL] break; [EOL] case 'C': [EOL] builder.appendCenturyOfEra(tokenLen, tokenLen); [EOL] break; [EOL] case 'x': [EOL] case 'y': [EOL] case 'Y': [EOL] if (tokenLen == 2) { [EOL] boolean lenientParse = true; [EOL] if (i + 1 < length) { [EOL] indexRef[0]++; [EOL] if (isNumericToken(parseToken(pattern, indexRef))) { [EOL] lenientParse = false; [EOL] } [EOL] indexRef[0]--; [EOL] } [EOL] switch(c) { [EOL] case 'x': [EOL] builder.appendTwoDigitWeekyear(new DateTime().getWeekyear() - 30, lenientParse); [EOL] break; [EOL] case 'y': [EOL] case 'Y': [EOL] default: [EOL] builder.appendTwoDigitYear(new DateTime().getYear() - 30, lenientParse); [EOL] break; [EOL] } [EOL] } else { [EOL] int maxDigits = 9; [EOL] if (i + 1 < length) { [EOL] indexRef[0]++; [EOL] if (isNumericToken(parseToken(pattern, indexRef))) { [EOL] maxDigits = tokenLen; [EOL] } [EOL] indexRef[0]--; [EOL] } [EOL] switch(c) { [EOL] case 'x': [EOL] builder.appendWeekyear(tokenLen, maxDigits); [EOL] break; [EOL] case 'y': [EOL] builder.appendYear(tokenLen, maxDigits); [EOL] break; [EOL] case 'Y': [EOL] builder.appendYearOfEra(tokenLen, maxDigits); [EOL] break; [EOL] } [EOL] } [EOL] break; [EOL] case 'M': [EOL] if (tokenLen >= 3) { [EOL] if (tokenLen >= 4) { [EOL] builder.appendMonthOfYearText(); [EOL] } else { [EOL] builder.appendMonthOfYearShortText(); [EOL] } [EOL] } else { [EOL] builder.appendMonthOfYear(tokenLen); [EOL] } [EOL] break; [EOL] case 'd': [EOL] builder.appendDayOfMonth(tokenLen); [EOL] break; [EOL] case 'a': [EOL] builder.appendHalfdayOfDayText(); [EOL] break; [EOL] case 'h': [EOL] builder.appendClockhourOfHalfday(tokenLen); [EOL] break; [EOL] case 'H': [EOL] builder.appendHourOfDay(tokenLen); [EOL] break; [EOL] case 'k': [EOL] builder.appendClockhourOfDay(tokenLen); [EOL] break; [EOL] case 'K': [EOL] builder.appendHourOfHalfday(tokenLen); [EOL] break; [EOL] case 'm': [EOL] builder.appendMinuteOfHour(tokenLen); [EOL] break; [EOL] case 's': [EOL] builder.appendSecondOfMinute(tokenLen); [EOL] break; [EOL] case 'S': [EOL] builder.appendFractionOfSecond(tokenLen, tokenLen); [EOL] break; [EOL] case 'e': [EOL] builder.appendDayOfWeek(tokenLen); [EOL] break; [EOL] case 'E': [EOL] if (tokenLen >= 4) { [EOL] builder.appendDayOfWeekText(); [EOL] } else { [EOL] builder.appendDayOfWeekShortText(); [EOL] } [EOL] break; [EOL] case 'D': [EOL] builder.appendDayOfYear(tokenLen); [EOL] break; [EOL] case 'w': [EOL] builder.appendWeekOfWeekyear(tokenLen); [EOL] break; [EOL] case 'z': [EOL] if (tokenLen >= 4) { [EOL] builder.appendTimeZoneName(); [EOL] } else { [EOL] builder.appendTimeZoneShortName(null); [EOL] } [EOL] break; [EOL] case 'Z': [EOL] if (tokenLen == 1) { [EOL] builder.appendTimeZoneOffset(null, "Z", false, 2, 2); [EOL] } else if (tokenLen == 2) { [EOL] builder.appendTimeZoneOffset(null, "Z", true, 2, 2); [EOL] } else { [EOL] builder.appendTimeZoneId(); [EOL] } [EOL] break; [EOL] case '\'': [EOL] String sub = token.substring(1); [EOL] if (sub.length() == 1) { [EOL] builder.appendLiteral(sub.charAt(0)); [EOL] } else { [EOL] builder.appendLiteral(new String(sub)); [EOL] } [EOL] break; [EOL] default: [EOL] throw new IllegalArgumentException("Illegal pattern component: " + token); [EOL] } [EOL] } [EOL] } [EOL] protected DateTimeFormat(); [EOL] StyleFormatter(int dateStyle, int timeStyle, int type); [EOL] protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest); [EOL] public static DateTimeFormatter forPattern(String pattern); [EOL] public static DateTimeFormatter forStyle(String style); [EOL] public static String patternForStyle(String style, Locale locale); [EOL] public static DateTimeFormatter shortDate(); [EOL] public static DateTimeFormatter shortTime(); [EOL] public static DateTimeFormatter shortDateTime(); [EOL] public static DateTimeFormatter mediumDate(); [EOL] public static DateTimeFormatter mediumTime(); [EOL] public static DateTimeFormatter mediumDateTime(); [EOL] public static DateTimeFormatter longDate(); [EOL] public static DateTimeFormatter longTime(); [EOL] public static DateTimeFormatter longDateTime(); [EOL] public static DateTimeFormatter fullDate(); [EOL] public static DateTimeFormatter fullTime(); [EOL] public static DateTimeFormatter fullDateTime(); [EOL] static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern); [EOL] private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern); [EOL] private static String parseToken(String pattern, int[] indexRef); [EOL] private static boolean isNumericToken(String token); [EOL] private static DateTimeFormatter createFormatterForPattern(String pattern); [EOL] private static DateTimeFormatter createFormatterForStyle(String style); [EOL] private static DateTimeFormatter createFormatterForStyleIndex(int dateStyle, int timeStyle); [EOL] private static DateTimeFormatter createDateTimeFormatter(int dateStyle, int timeStyle); [EOL] private static int selectStyle(char ch); [EOL] public int estimatePrintedLength(); [EOL] public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale); [EOL] public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException; [EOL] public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale); [EOL] public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException; [EOL] public int estimateParsedLength(); [EOL] public int parseInto(DateTimeParserBucket bucket, String text, int position); [EOL] private DateTimeFormatter getFormatter(Locale locale); [EOL] String getPattern(Locale locale); [EOL] int FULL=Optional[0]; [EOL] int LONG=Optional[1]; [EOL] int MEDIUM=Optional[2]; [EOL] int SHORT=Optional[3]; [EOL] int NONE=Optional[4]; [EOL] int DATE=Optional[0]; [EOL] int TIME=Optional[1]; [EOL] int DATETIME=Optional[2]; [EOL] int PATTERN_CACHE_SIZE=Optional[500]; [EOL] Map<String, DateTimeFormatter> PATTERN_CACHE=Optional[new LinkedHashMap<String, DateTimeFormatter>(7) {; ; [EOL] private static final long serialVersionUID = 23L;; ; [EOL] @Override; [EOL] protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest) {; [EOL] return size() > PATTERN_CACHE_SIZE;; [EOL] }; [EOL] }]
public void testCreateFormatterForStyleWithNullStyle() { [EOL] try { [EOL] DateTimeFormatter.createFormatterForStyle(null); [EOL] fail("Should have thrown IllegalArgumentException for null style"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testCreateFormatterForStyleWithInvalidLengthStyle() { [EOL] try { [EOL] DateTimeFormatter.createFormatterForStyle("S"); // Invalid length [EOL] fail("Should have thrown IllegalArgumentException for style of invalid length"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testCreateFormatterForStyleWithInvalidStyle() { [EOL] try { [EOL] DateTimeFormatter.createFormatterForStyle("--"); // Both date and time styles are NONE [EOL] fail("Should have thrown IllegalArgumentException for style '--'"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testCreateFormatterForStyleWithValidStyle() { [EOL] DateTimeFormatter formatter = DateTimeFormatter.createFormatterForStyle("SS"); [EOL] assertNotNull("Formatter should not be null for valid style", formatter); [EOL] }
public void testStandardDays_Zero() { [EOL] Duration result = Time.standardDays(0); [EOL] assertEquals(Duration.ZERO, result); [EOL] }
public void testStandardDays_Positive() { [EOL] long oneDay = 1; [EOL] Duration result = Time.standardDays(oneDay); [EOL] assertEquals(new Duration(DateTimeConstants.MILLIS_PER_DAY), result); [EOL] }
public void testStandardDays_Negative() { [EOL] long negativeOneDay = -1; [EOL] Duration result = Time.standardDays(negativeOneDay); [EOL] assertEquals(new Duration(-DateTimeConstants.MILLIS_PER_DAY), result); [EOL] }
public void testStandardDays_MaxValue() { [EOL] long maxDays = Long.MAX_VALUE / DateTimeConstants.MILLIS_PER_DAY; [EOL] Duration result = Time.standardDays(maxDays); [EOL] assertEquals(new Duration(FieldUtils.safeMultiply(maxDays, DateTimeConstants.MILLIS_PER_DAY)), result); [EOL] }
public void testStandardDays_MinValue() { [EOL] long minDays = Long.MIN_VALUE / DateTimeConstants.MILLIS_PER_DAY; [EOL] Duration result = Time.standardDays(minDays); [EOL] assertEquals(new Duration(FieldUtils.safeMultiply(minDays, DateTimeConstants.MILLIS_PER_DAY)), result); [EOL] }
public void testMillis_Zero() { [EOL] Duration result = Time.millis(0); [EOL] assertEquals(Time.ZERO, result); [EOL] }
public void testMillis_Positive() { [EOL] long input = 123L; [EOL] Duration result = Time.millis(input); [EOL] assertNotNull(result); [EOL] assertEquals(input, result.toMillis()); [EOL] }
public void testMillis_Negative() { [EOL] long input = -123L; [EOL] Duration result = Time.millis(input); [EOL] assertNotNull(result); [EOL] assertEquals(input, result.toMillis()); [EOL] }
public void testDurationWithValidStartAndEnd() { [EOL] ReadableInstant start = new DateTime(2020, 1, 1, 0, 0); [EOL] ReadableInstant end = new DateTime(2020, 1, 2, 0, 0); [EOL] Duration duration = new Duration(start, end); [EOL] assertNotNull(duration); [EOL] assertEquals(24 * 60 * 60 * 1000, duration.getMillis()); [EOL] }
public void testDurationWithSameStartAndEnd() { [EOL] ReadableInstant instant = new DateTime(2020, 1, 1, 0, 0); [EOL] Duration duration = new Duration(instant, instant); [EOL] assertNotNull(duration); [EOL] assertEquals(0, duration.getMillis()); [EOL] }
public void testDurationWithEndBeforeStart() { [EOL] ReadableInstant start = new DateTime(2020, 1, 2, 0, 0); [EOL] ReadableInstant end = new DateTime(2020, 1, 1, 0, 0); [EOL] try { [EOL] new Duration(start, end); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testDurationWithNull() { [EOL] Object duration = null; [EOL] try { [EOL] Duration result = new Duration(duration); [EOL] } catch (Exception e) { [EOL] fail("Constructor threw an exception with null input: " + e.getMessage()); [EOL] } [EOL] }
public long getStandardDays() { [EOL] return getMillis() / DateTimeConstants.MILLIS_PER_DAY; [EOL] }
public void testToStandardDays_PositiveDays() { [EOL] Period testPeriod = new Period(0, 0, 0, 5, 0, 0, 0, 0); [EOL] Days result = testPeriod.toStandardDays(); [EOL] assertEquals(5, result.getDays()); [EOL] }
public void testToStandardDays_NegativeDays() { [EOL] Period testPeriod = new Period(0, 0, 0, -5, 0, 0, 0, 0); [EOL] Days result = testPeriod.toStandardDays(); [EOL] assertEquals(-5, result.getDays()); [EOL] }
public void testToStandardDays_ZeroDays() { [EOL] Period testPeriod = new Period(0, 0, 0, 0, 0, 0, 0, 0); [EOL] Days result = testPeriod.toStandardDays(); [EOL] assertEquals(0, result.getDays()); [EOL] }
public void testWithMillis_SameValue() { [EOL] long duration = 1000L; [EOL] Duration instance = new Duration(duration); [EOL] Duration result = instance.withMillis(duration); [EOL] assertSame(instance, result); [EOL] }
public void testWithMillis_DifferentValue() { [EOL] long currentDuration = 1000L; [EOL] long newDuration = 2000L; [EOL] Duration instance = new Duration(currentDuration); [EOL] Duration result = instance.withMillis(newDuration); [EOL] assertNotSame(instance, result); [EOL] assertEquals(newDuration, result.getMillis()); [EOL] }
public void testWithDurationAdded_NullDuration() { [EOL] Duration testDuration = new Duration(1234L); [EOL] Duration result = testDuration.withDurationAdded(null, 1); [EOL] assertSame(testDuration, result); [EOL] }
public void testWithDurationAdded_ZeroScalar() { [EOL] Duration testDuration = new Duration(1234L); [EOL] ReadableDuration durationToAdd = new Duration(5678L); [EOL] Duration result = testDuration.withDurationAdded(durationToAdd, 0); [EOL] assertSame(testDuration, result); [EOL] }
public void testWithDurationAdded_NonNullDurationNonZeroScalar() { [EOL] Duration testDuration = new Duration(1234L); [EOL] ReadableDuration durationToAdd = new Duration(5678L); [EOL] Duration result = testDuration.withDurationAdded(durationToAdd, 1); [EOL] assertNotNull(result); [EOL] assertNotSame(testDuration, result); [EOL] assertEquals(1234L + 5678L, result.getMillis()); [EOL] }
public void testMinus_NullAmount() { [EOL] Duration duration = new Duration(1000); [EOL] Duration result = duration.minus(null); [EOL] assertEquals(duration, result); [EOL] }
public void testMinus_NonNullAmount() { [EOL] Duration duration = new Duration(1000); [EOL] ReadableDuration amount = new Duration(500); [EOL] Duration result = duration.minus(amount); [EOL] assertEquals(new Duration(500), result); [EOL] }
public void testISOPeriodFormatConstructor() { [EOL] new ISOPeriodFormat(); [EOL] }
public void testStandardFormatterInitialization() { [EOL] PeriodFormatter formatter = Time.standard(); [EOL] assertNotNull("Formatter should not be null", formatter); [EOL] assertEquals("Formatter should match the expected pattern", [EOL] "PnYnMnWnDTnHnMnS", formatter.print(new Period(0))); [EOL] } [EOL] public void testStandardFormatterSingletonProperty() { [EOL] PeriodFormatter firstCallFormatter = Time.standard(); [EOL] PeriodFormatter secondCallFormatter = Time.standard(); [EOL] assertSame("Multiple calls to standard() should return the same instance", [EOL] firstCallFormatter, secondCallFormatter); [EOL] }
public void testAlternate_InitialCreation() { [EOL] PeriodFormatter result = Time.alternate(); [EOL] assertNotNull("PeriodFormatter should not be null", result); [EOL] assertEquals("Formatter should match the expected pattern", "P0000Y00M0DT0H0M0S", result.print(new Period(0))); [EOL] }
public void testAlternate_SubsequentRetrieval() { [EOL] Time.alternate(); // Initial call to create the formatter [EOL] PeriodFormatter result = Time.alternate(); // Subsequent call should retrieve the same instance [EOL] assertNotNull("PeriodFormatter should not be null on subsequent retrieval", result); [EOL] assertEquals("Subsequent retrieval should return the same formatter instance", "P0000Y00M0DT0H0M0S", result.print(new Period(0))); [EOL] }
public void testAlternateWithWeeks_NotInitialized() { [EOL] PeriodFormatter result = YourClass.alternateWithWeeks(); [EOL] assertNotNull(result); [EOL] assertEquals("P0000YWWDDTHHMMSS.SSS", result.print(new Period(0))); [EOL] } [EOL] public void testAlternateWithWeeks_AlreadyInitialized() { [EOL] YourClass.alternateWithWeeks(); [EOL] PeriodFormatter result = YourClass.alternateWithWeeks(); [EOL] assertNotNull(result); [EOL] assertEquals("P0000YWWDDTHHMMSS.SSS", result.print(new Period(0))); [EOL] }
public void testNextWithModeW() { [EOL] Time time = new Time('w', 4, 500); // Example values for iMode, iMonthOfYear, and iMillisOfDay [EOL] long instant = 1000000L; [EOL] int standardOffset = 1000; [EOL] int saveMillis = 2000; [EOL] long expected = 1000000L + standardOffset + saveMillis; // Adjust expected value based on method logic [EOL] long actual = time.next(instant, standardOffset, saveMillis); [EOL] assertEquals(expected, actual); [EOL] }
public void testNextWithModeS() { [EOL] Time time = new Time('s', 4, 500); // Example values for iMode, iMonthOfYear, and iMillisOfDay [EOL] long instant = 1000000L; [EOL] int standardOffset = 1000; [EOL] int saveMillis = 2000; [EOL] long expected = 1000000L + standardOffset; // Adjust expected value based on method logic [EOL] long actual = time.next(instant, standardOffset, saveMillis); [EOL] assertEquals(expected, actual); [EOL] }
public void testNextWithModeOther() { [EOL] Time time = new Time('x', 4, 500); // Example values for iMode, iMonthOfYear, and iMillisOfDay [EOL] long instant = 1000000L; [EOL] int standardOffset = 1000; [EOL] int saveMillis = 2000; [EOL] long expected = 1000000L; // Adjust expected value based on method logic [EOL] long actual = time.next(instant, standardOffset, saveMillis); [EOL] assertEquals(expected, actual); [EOL] }
public void testNextWithDayOfWeekZero() { [EOL] Time time = new Time('w', 4, 500, 0); // Example values for iMode, iMonthOfYear, iMillisOfDay, and iDayOfWeek [EOL] long instant = 1000000L; [EOL] int standardOffset = 1000; [EOL] int saveMillis = 2000; [EOL] long expected = 1000000L + standardOffset + saveMillis; // Adjust expected value based on method logic [EOL] long actual = time.next(instant, standardOffset, saveMillis); [EOL] assertEquals(expected, actual); [EOL] }
public void testNextWithDayOfWeekNonZero() { [EOL] Time time = new Time('w', 4, 500, 1); // Example values for iMode, iMonthOfYear, iMillisOfDay, and iDayOfWeek [EOL] long instant = 1000000L; [EOL] int standardOffset = 1000; [EOL] int saveMillis = 2000; [EOL] long expected = 1000000L + standardOffset + saveMillis; // Adjust expected value based on method logic [EOL] long actual = time.next(instant, standardOffset, saveMillis); [EOL] assertEquals(expected, actual); [EOL] }
public String getNameKey(long instant) { [EOL] return findMatchingRecurrence(instant).getNameKey(); [EOL] }
public int getOffsetTest_InstantWithinStandardOffset() { [EOL] long instant = knownInstantWithinStandardOffset; [EOL] int expectedOffset = expectedStandardOffset; // Replace with the actual expected offset [EOL] int actualOffset = getOffset(instant); [EOL] assertEquals(expectedOffset, actualOffset); [EOL] }
public int getOffsetTest_InstantWithinDaylightSavings() { [EOL] long instant = knownInstantWithinDaylightSavings; [EOL] int expectedOffset = expectedDaylightSavingsOffset; // Replace with the actual expected offset [EOL] int actualOffset = getOffset(instant); [EOL] assertEquals(expectedOffset, actualOffset); [EOL] }
public void testNextTransitionWithStartBeforeEnd() { [EOL] long instant = 0L; [EOL] long expectedStart = 1L; [EOL] long expectedEnd = 2L; [EOL] when(iStartRecurrence.next(instant, iStandardOffset, iEndRecurrence.getSaveMillis())).thenReturn(expectedStart); [EOL] when(iEndRecurrence.next(instant, iStandardOffset, iStartRecurrence.getSaveMillis())).thenReturn(expectedEnd); [EOL] long result = nextTransition(instant); [EOL] assertEquals(expectedStart, result); [EOL] }
public void testNextTransitionWithEndBeforeStart() { [EOL] long instant = 0L; [EOL] long expectedStart = 3L; [EOL] long expectedEnd = 2L; [EOL] when(iStartRecurrence.next(instant, iStandardOffset, iEndRecurrence.getSaveMillis())).thenReturn(expectedStart); [EOL] when(iEndRecurrence.next(instant, iStandardOffset, iStartRecurrence.getSaveMillis())).thenReturn(expectedEnd); [EOL] long result = nextTransition(instant); [EOL] assertEquals(expectedEnd, result); [EOL] }
public void testNextTransitionWithStartOverflow() { [EOL] long instant = 0L; [EOL] long expectedStart = -1L; [EOL] long expectedEnd = 2L; [EOL] when(iStartRecurrence.next(instant, iStandardOffset, iEndRecurrence.getSaveMillis())).thenReturn(expectedStart); [EOL] when(iEndRecurrence.next(instant, iStandardOffset, iStartRecurrence.getSaveMillis())).thenReturn(expectedEnd); [EOL] long result = nextTransition(instant); [EOL] assertEquals(expectedEnd, result); [EOL] }
public void testNextTransitionWithEndOverflow() { [EOL] long instant = 0L; [EOL] long expectedStart = 1L; [EOL] long expectedEnd = -1L; [EOL] when(iStartRecurrence.next(instant, iStandardOffset, iEndRecurrence.getSaveMillis())).thenReturn(expectedStart); [EOL] when(iEndRecurrence.next(instant, iStandardOffset, iStartRecurrence.getSaveMillis())).thenReturn(expectedEnd); [EOL] long result = nextTransition(instant); [EOL] assertEquals(expectedStart, result); [EOL] }
public void testNextTransitionWithStartIllegalArgumentException() { [EOL] long instant = 0L; [EOL] when(iStartRecurrence.next(instant, iStandardOffset, iEndRecurrence.getSaveMillis())).thenThrow(new IllegalArgumentException()); [EOL] long result = nextTransition(instant); [EOL] assertEquals(instant, result); [EOL] }
public void testNextTransitionWithEndIllegalArgumentException() { [EOL] long instant = 0L; [EOL] long expectedStart = 1L; [EOL] when(iStartRecurrence.next(instant, iStandardOffset, iEndRecurrence.getSaveMillis())).thenReturn(expectedStart); [EOL] when(iEndRecurrence.next(instant, iStandardOffset, iStartRecurrence.getSaveMillis())).thenThrow(new IllegalArgumentException()); [EOL] long result = nextTransition(instant); [EOL] assertEquals(expectedStart, result); [EOL] }
public void testNextTransitionWithStartArithmeticException() { [EOL] long instant = 0L; [EOL] when(iStartRecurrence.next(instant, iStandardOffset, iEndRecurrence.getSaveMillis())).thenThrow(new ArithmeticException()); [EOL] long result = nextTransition(instant); [EOL] assertEquals(instant, result); [EOL] }
public void testNextTransitionWithEndArithmeticException() { [EOL] long instant = 0L; [EOL] long expectedStart = 1L; [EOL] when(iStartRecurrence.next(instant, iStandardOffset, iEndRecurrence.getSaveMillis())).thenReturn(expectedStart); [EOL] when(iEndRecurrence.next(instant, iStandardOffset, iStartRecurrence.getSaveMillis())).thenThrow(new ArithmeticException()); [EOL] long result = nextTransition(instant); [EOL] assertEquals(expectedStart, result); [EOL] }
public void testFindMatchingRecurrence_StartGreater() { [EOL] long instant = 0L; [EOL] int standardOffset = 0; [EOL] Recurrence startRecurrence = mock(Recurrence.class); [EOL] Recurrence endRecurrence = mock(Recurrence.class); [EOL] when(startRecurrence.next(anyLong(), anyInt(), anyInt())).thenReturn(instant + 1); [EOL] when(endRecurrence.next(anyLong(), anyInt(), anyInt())).thenReturn(instant); [EOL] when(startRecurrence.getSaveMillis()).thenReturn(0); [EOL] when(endRecurrence.getSaveMillis()).thenReturn(0); [EOL] Recurrence result = findMatchingRecurrence(instant); [EOL] assertEquals(startRecurrence, result); [EOL] }
public void testFindMatchingRecurrence_EndGreater() { [EOL] long instant = 0L; [EOL] int standardOffset = 0; [EOL] Recurrence startRecurrence = mock(Recurrence.class); [EOL] Recurrence endRecurrence = mock(Recurrence.class); [EOL] when(startRecurrence.next(anyLong(), anyInt(), anyInt())).thenReturn(instant); [EOL] when(endRecurrence.next(anyLong(), anyInt(), anyInt())).thenReturn(instant + 1); [EOL] when(startRecurrence.getSaveMillis()).thenReturn(0); [EOL] when(endRecurrence.getSaveMillis()).thenReturn(0); [EOL] Recurrence result = findMatchingRecurrence(instant); [EOL] assertEquals(endRecurrence, result); [EOL] }
public void testFindMatchingRecurrence_StartThrowsIllegalArgumentException() { [EOL] long instant = 0L; [EOL] int standardOffset = 0; [EOL] Recurrence startRecurrence = mock(Recurrence.class); [EOL] Recurrence endRecurrence = mock(Recurrence.class); [EOL] when(startRecurrence.next(anyLong(), anyInt(), anyInt())).thenThrow(new IllegalArgumentException()); [EOL] when(endRecurrence.next(anyLong(), anyInt(), anyInt())).thenReturn(instant); [EOL] when(startRecurrence.getSaveMillis()).thenReturn(0); [EOL] when(endRecurrence.getSaveMillis()).thenReturn(0); [EOL] Recurrence result = findMatchingRecurrence(instant); [EOL] assertEquals(endRecurrence, result); [EOL] }
public void testFindMatchingRecurrence_EndThrowsIllegalArgumentException() { [EOL] long instant = 0L; [EOL] int standardOffset = 0; [EOL] Recurrence startRecurrence = mock(Recurrence.class); [EOL] Recurrence endRecurrence = mock(Recurrence.class); [EOL] when(startRecurrence.next(anyLong(), anyInt(), anyInt())).thenReturn(instant); [EOL] when(endRecurrence.next(anyLong(), anyInt(), anyInt())).thenThrow(new IllegalArgumentException()); [EOL] when(startRecurrence.getSaveMillis()).thenReturn(0); [EOL] when(endRecurrence.getSaveMillis()).thenReturn(0); [EOL] Recurrence result = findMatchingRecurrence(instant); [EOL] assertEquals(startRecurrence, result); [EOL] }
public void testFindMatchingRecurrence_StartThrowsArithmeticException() { [EOL] long instant = 0L; [EOL] int standardOffset = 0; [EOL] Recurrence startRecurrence = mock(Recurrence.class); [EOL] Recurrence endRecurrence = mock(Recurrence.class); [EOL] when(startRecurrence.next(anyLong(), anyInt(), anyInt())).thenThrow(new ArithmeticException()); [EOL] when(endRecurrence.next(anyLong(), anyInt(), anyInt())).thenReturn(instant); [EOL] when(startRecurrence.getSaveMillis()).thenReturn(0); [EOL] when(endRecurrence.getSaveMillis()).thenReturn(0); [EOL] Recurrence result = findMatchingRecurrence(instant); [EOL] assertEquals(endRecurrence, result); [EOL] }
public void testFindMatchingRecurrence_EndThrowsArithmeticException() { [EOL] long instant = 0L; [EOL] int standardOffset = 0; [EOL] Recurrence startRecurrence = mock(Recurrence.class); [EOL] Recurrence endRecurrence = mock(Recurrence.class); [EOL] when(startRecurrence.next(anyLong(), anyInt(), anyInt())).thenReturn(instant); [EOL] when(endRecurrence.next(anyLong(), anyInt(), anyInt())).thenThrow(new ArithmeticException()); [EOL] when(startRecurrence.getSaveMillis()).thenReturn(0); [EOL] when(endRecurrence.getSaveMillis()).thenReturn(0); [EOL] Recurrence result = findMatchingRecurrence(instant); [EOL] assertEquals(startRecurrence, result); [EOL] }
public void testGetNameKey_FoundExact() { [EOL] long[] transitions = new long[] {10, 20, 30}; [EOL] String[] nameKeys = new String[] {"A", "B", "C"}; [EOL] TimeZone timeZone = new TimeZone(transitions, nameKeys, null); [EOL] String result = timeZone.getNameKey(20); [EOL] assertEquals("B", result); [EOL] }
public void testGetNameKey_FoundBefore() { [EOL] long[] transitions = new long[] {10, 20, 30}; [EOL] String[] nameKeys = new String[] {"A", "B", "C"}; [EOL] TimeZone timeZone = new TimeZone(transitions, nameKeys, null); [EOL] String result = timeZone.getNameKey(25); [EOL] assertEquals("B", result); [EOL] }
public void testGetNameKey_FirstTransition() { [EOL] long[] transitions = new long[] {10, 20, 30}; [EOL] String[] nameKeys = new String[] {"A", "B", "C"}; [EOL] TimeZone timeZone = new TimeZone(transitions, nameKeys, null); [EOL] String result = timeZone.getNameKey(5); [EOL] assertEquals("UTC", result); [EOL] }
public void testGetNameKey_AfterLastTransition() { [EOL] long[] transitions = new long[] {10, 20, 30}; [EOL] String[] nameKeys = new String[] {"A", "B", "C"}; [EOL] TailZone tailZone = new TailZone("D"); [EOL] TimeZone timeZone = new TimeZone(transitions, nameKeys, tailZone); [EOL] String result = timeZone.getNameKey(35); [EOL] assertEquals("D", result); [EOL] }
public void testGetNameKey_NoTailZoneAfterLastTransition() { [EOL] long[] transitions = new long[] {10, 20, 30}; [EOL] String[] nameKeys = new String[] {"A", "B", "C"}; [EOL] TimeZone timeZone = new TimeZone(transitions, nameKeys, null); [EOL] String result = timeZone.getNameKey(35); [EOL] assertEquals("C", result); [EOL] }
public void testGetOffset_ExactMatch() { [EOL] long[] transitions = new long[] {10L, 20L, 30L}; [EOL] int[] wallOffsets = new int[] {1, 2, 3}; [EOL] DateTimeZoneStub zone = new DateTimeZoneStub(transitions, wallOffsets, null); [EOL] int result = zone.getOffset(20L); [EOL] assertEquals(2, result); [EOL] }
public void testGetOffset_BeforeFirstTransition() { [EOL] long[] transitions = new long[] {10L, 20L, 30L}; [EOL] int[] wallOffsets = new int[] {1, 2, 3}; [EOL] DateTimeZoneStub zone = new DateTimeZoneStub(transitions, wallOffsets, null); [EOL] int result = zone.getOffset(5L); [EOL] assertEquals(0, result); [EOL] }
public void testGetOffset_BetweenTransitions() { [EOL] long[] transitions = new long[] {10L, 20L, 30L}; [EOL] int[] wallOffsets = new int[] {1, 2, 3}; [EOL] DateTimeZoneStub zone = new DateTimeZoneStub(transitions, wallOffsets, null); [EOL] int result = zone.getOffset(25L); [EOL] assertEquals(2, result); [EOL] }
public void testGetOffset_AfterLastTransition() { [EOL] long[] transitions = new long[] {10L, 20L, 30L}; [EOL] int[] wallOffsets = new int[] {1, 2, 3}; [EOL] DateTimeZoneStub zone = new DateTimeZoneStub(transitions, wallOffsets, null); [EOL] int result = zone.getOffset(35L); [EOL] assertEquals(3, result); [EOL] }
public void testGetOffset_WithTailZone() { [EOL] long[] transitions = new long[] {10L, 20L, 30L}; [EOL] int[] wallOffsets = new int[] {1, 2, 3}; [EOL] DateTimeZoneStub tailZone = new DateTimeZoneStub(null, null, 4); [EOL] DateTimeZoneStub zone = new DateTimeZoneStub(transitions, wallOffsets, tailZone); [EOL] int result = zone.getOffset(35L); [EOL] assertEquals(4, result); [EOL] }
public void testNextTransitionWithInstantFound() { [EOL] long[] transitions = new long[] {10, 20, 30, 40}; [EOL] long instant = 20; [EOL] ZoneInfo zi = new ZoneInfo("TestZone", transitions); [EOL] long expected = 30; [EOL] long actual = zi.nextTransition(instant); [EOL] assertEquals(expected, actual); [EOL] }
public void testNextTransitionWithInstantNotFound() { [EOL] long[] transitions = new long[] {10, 20, 30, 40}; [EOL] long instant = 25; [EOL] ZoneInfo zi = new ZoneInfo("TestZone", transitions); [EOL] long expected = 30; [EOL] long actual = zi.nextTransition(instant); [EOL] assertEquals(expected, actual); [EOL] }
public void testNextTransitionAtEndOfArray() { [EOL] long[] transitions = new long[] {10, 20, 30, 40}; [EOL] long instant = 50; [EOL] ZoneInfo zi = new ZoneInfo("TestZone", transitions); [EOL] zi.setTailZone(new TailZone("TailZone", 50)); [EOL] long expected = 50; [EOL] long actual = zi.nextTransition(instant); [EOL] assertEquals(expected, actual); [EOL] }
public void testNextTransitionWithNullTailZone() { [EOL] long[] transitions = new long[] {10, 20, 30, 40}; [EOL] long instant = 50; [EOL] ZoneInfo zi = new ZoneInfo("TestZone", transitions); [EOL] long expected = instant; [EOL] long actual = zi.nextTransition(instant); [EOL] assertEquals(expected, actual); [EOL] }
public long previousTransition(long instant) { [EOL] long[] transitions = iTransitions; [EOL] int i = Arrays.binarySearch(transitions, instant); [EOL] if (i >= 0) { [EOL] if (instant > Long.MIN_VALUE) { [EOL] return instant - 1; [EOL] } [EOL] return instant; [EOL] } [EOL] i = ~i; [EOL] if (i < transitions.length) { [EOL] if (i > 0) { [EOL] long prev = transitions[i - 1]; [EOL] if (prev > Long.MIN_VALUE) { [EOL] return prev - 1; [EOL] } [EOL] } [EOL] return instant; [EOL] } [EOL] if (iTailZone != null) { [EOL] long prev = iTailZone.previousTransition(instant); [EOL] if (prev < instant) { [EOL] return prev; [EOL] } [EOL] } [EOL] long prev = transitions[i - 1]; [EOL] if (prev > Long.MIN_VALUE) { [EOL] return prev - 1; [EOL] } [EOL] return instant; [EOL] }
public void testForZone_WithCachedDateTimeZone() { [EOL] DateTimeZone cachedZone = CachedDateTimeZone.forZone(DateTimeZone.UTC); [EOL] CachedDateTimeZone result = CachedDateTimeZone.forZone(cachedZone); [EOL] assertSame("Should return the same CachedDateTimeZone instance", cachedZone, result); [EOL] }
public void testForZone_WithNonCachedDateTimeZone() { [EOL] DateTimeZone nonCachedZone = DateTimeZone.forID("Europe/London"); [EOL] CachedDateTimeZone result = CachedDateTimeZone.forZone(nonCachedZone); [EOL] assertNotNull("Should return a new CachedDateTimeZone instance", result); [EOL] assertNotSame("Should not return the original DateTimeZone instance", nonCachedZone, result); [EOL] assertEquals("Cached zone should wrap the original zone", nonCachedZone, result.getUncachedZone()); [EOL] }
public void testGetNameKey() { [EOL] Time time = new Time(); [EOL] long instant = 123456789L; // Example instant value [EOL] String expectedNameKey = "ExpectedNameKey"; // Expected result based on the instant [EOL] String actualNameKey = time.getNameKey(instant); [EOL] assertEquals(expectedNameKey, actualNameKey); [EOL] }
public void testEqualsWithSameObject() { [EOL] CachedDateTimeZone zone = CachedDateTimeZone.forZone(DateTimeZone.UTC); [EOL] boolean result = zone.equals(zone); [EOL] assert result; [EOL] } [EOL] public void testEqualsWithDifferentObjectSameZone() { [EOL] CachedDateTimeZone zone1 = CachedDateTimeZone.forZone(DateTimeZone.UTC); [EOL] CachedDateTimeZone zone2 = CachedDateTimeZone.forZone(DateTimeZone.UTC); [EOL] boolean result = zone1.equals(zone2); [EOL] assert result; [EOL] } [EOL] public void testEqualsWithDifferentObjectDifferentZone() { [EOL] CachedDateTimeZone zone1 = CachedDateTimeZone.forZone(DateTimeZone.UTC); [EOL] CachedDateTimeZone zone2 = CachedDateTimeZone.forZone(DateTimeZone.forID("Europe/London")); [EOL] boolean result = zone1.equals(zone2); [EOL] assert !result; [EOL] } [EOL] public void testEqualsWithNonCachedDateTimeZoneObject() { [EOL] CachedDateTimeZone zone = CachedDateTimeZone.forZone(DateTimeZone.UTC); [EOL] DateTimeZone nonCachedZone = DateTimeZone.forID("Europe/London"); [EOL] boolean result = zone.equals(nonCachedZone); [EOL] assert !result; [EOL] } [EOL] public void testEqualsWithNull() { [EOL] CachedDateTimeZone zone = CachedDateTimeZone.forZone(DateTimeZone.UTC); [EOL] boolean result = zone.equals(null); [EOL] assert !result; [EOL] }
public void testGetInfo_CacheHit() { [EOL] long millis = 0x100000000L; // This will create a period of 1 [EOL] Info expectedInfo = new Info(millis); [EOL] iInfoCache[1 & cInfoCacheMask] = expectedInfo; // Pre-populate the cache [EOL] Info result = getInfo(millis); [EOL] assertEquals(expectedInfo, result); [EOL] }
public void testGetInfo_CacheMiss() { [EOL] long millis = 0x100000000L; // This will create a period of 1 [EOL] Info expectedInfo = new Info(millis); [EOL] Info result = getInfo(millis); [EOL] assertEquals(expectedInfo, result); [EOL] assertNotNull(iInfoCache[1 & cInfoCacheMask]); [EOL] assertEquals(expectedInfo, iInfoCache[1 & cInfoCacheMask]); [EOL] }
public void testGetInfo_CacheMissDifferentPeriod() { [EOL] long millis = 0x200000000L; // This will create a period of 2 [EOL] Info expectedInfo = new Info(millis); [EOL] Info result = getInfo(millis); [EOL] assertEquals(expectedInfo, result); [EOL] assertNotNull(iInfoCache[2 & cInfoCacheMask]); [EOL] assertEquals(expectedInfo, iInfoCache[2 & cInfoCacheMask]); [EOL] }
public void testCreateInfoWithNoTransitions() { [EOL] long millis = 0L; [EOL] Info result = createInfo(millis); [EOL] assertNotNull(result); [EOL] assertEquals(millis & (0xffffffffL << 32), result.periodStart); [EOL] assertNull(result.iNextInfo); [EOL] }
public void testCreateInfoWithOneTransition() { [EOL] long millis = 0L; [EOL] long expectedNextTransition = (millis & (0xffffffffL << 32)) + 1000; [EOL] when(iZone.nextTransition(millis)).thenReturn(expectedNextTransition); [EOL] Info result = createInfo(millis); [EOL] assertNotNull(result); [EOL] assertNotNull(result.iNextInfo); [EOL] assertEquals(expectedNextTransition, result.iNextInfo.periodStart); [EOL] }
public void testCreateInfoWithMultipleTransitions() { [EOL] long millis = 0L; [EOL] long periodStart = millis & (0xffffffffL << 32); [EOL] long end = periodStart | 0xffffffffL; [EOL] long firstTransition = periodStart + 1000; [EOL] long secondTransition = firstTransition + 1000; [EOL] when(iZone.nextTransition(periodStart)).thenReturn(firstTransition, secondTransition); [EOL] when(iZone.nextTransition(firstTransition)).thenReturn(secondTransition); [EOL] when(iZone.nextTransition(secondTransition)).thenReturn(end + 1); // This should break the loop [EOL] Info result = createInfo(millis); [EOL] assertNotNull(result); [EOL] Info firstInfo = result.iNextInfo; [EOL] assertNotNull(firstInfo); [EOL] assertEquals(firstTransition, firstInfo.periodStart); [EOL] Info secondInfo = firstInfo.iNextInfo; [EOL] assertNotNull(secondInfo); [EOL] assertEquals(secondTransition, secondInfo.periodStart); [EOL] assertNull(secondInfo.iNextInfo); [EOL] }
public void testInfoWithNonNullZone() { [EOL] DateTimeZone zone = DateTimeZone.UTC; [EOL] long periodStart = System.currentTimeMillis(); [EOL] Info info = new Info(zone, periodStart); [EOL] assertNotNull(info.iZoneRef); [EOL] assertEquals(zone, info.iZoneRef); [EOL] assertEquals(periodStart, info.iPeriodStart); [EOL] }
public void testInfoWithNullZone() { [EOL] long periodStart = System.currentTimeMillis(); [EOL] Info info = new Info(null, periodStart); [EOL] assertNull(info.iZoneRef); [EOL] assertEquals(periodStart, info.iPeriodStart); [EOL] }
public void testGetNameKey_BeforeNextInfoPeriod() { [EOL] long millisBeforeNextInfo = /* value before iNextInfo.iPeriodStart */; [EOL] String expectedNameKey = /* expected name key for the period */; [EOL] String actualNameKey = instance.getNameKey(millisBeforeNextInfo); [EOL] assertEquals(expectedNameKey, actualNameKey); [EOL] }
public void testGetNameKey_AtOrAfterNextInfoPeriod() { [EOL] long millisAtOrAfterNextInfo = /* value at or after iNextInfo.iPeriodStart */; [EOL] String expectedNameKey = /* expected name key from iNextInfo */; [EOL] String actualNameKey = instance.getNameKey(millisAtOrAfterNextInfo); [EOL] assertEquals(expectedNameKey, actualNameKey); [EOL] }
public void testGetNameKey_WithNullNextInfo() { [EOL] long millis = /* any value */; [EOL] String expectedNameKey = /* expected name key when iNextInfo is null */; [EOL] String actualNameKey = instance.getNameKey(millis); [EOL] assertEquals(expectedNameKey, actualNameKey); [EOL] }
public void testGetNameKey_WithNullNameKey() { [EOL] long millisBeforeNextInfo = /* value before iNextInfo.iPeriodStart */; [EOL] String expectedNameKey = /* expected name key to be fetched from iZoneRef */; [EOL] String actualNameKey = instance.getNameKey(millisBeforeNextInfo); [EOL] assertEquals(expectedNameKey, actualNameKey); [EOL] }
public int getOffset(long millis) { [EOL] if (iNextInfo == null || millis < iNextInfo.iPeriodStart) { [EOL] if (iOffset == Integer.MIN_VALUE) { [EOL] iOffset = iZoneRef.getOffset(iPeriodStart); [EOL] } [EOL] return iOffset; [EOL] } [EOL] return iNextInfo.getOffset(millis); [EOL] }
public int getValueTest_ZeroScalar_ThrowsArithmeticException() { [EOL] DurationField mockField = mock(DurationField.class); [EOL] when(mockField.getValue(anyLong(), anyLong())).thenReturn(10); [EOL] MyClass myObject = new MyClass(mockField, 0); [EOL] try { [EOL] myObject.getValue(100L, 1000L); [EOL] fail("Expected an ArithmeticException to be thrown"); [EOL] } catch (ArithmeticException e) { [EOL] } [EOL] }
public int getValueTest_NonZeroScalar_ReturnsQuotient() { [EOL] DurationField mockField = mock(DurationField.class); [EOL] when(mockField.getValue(anyLong(), anyLong())).thenReturn(10); [EOL] MyClass myObject = new MyClass(mockField, 2); [EOL] int result = myObject.getValue(100L, 1000L); [EOL] assertEquals(5, result); [EOL] }
public void testGetMillis_withPositiveValuePositiveInstant() { [EOL] long value = 5; [EOL] long instant = 10; [EOL] long expected = 50; // Assuming iScalar is 10 for this test [EOL] long result = getMillis(value, instant); [EOL] assertEquals(expected, result); [EOL] } [EOL] public void testGetMillis_withNegativeValuePositiveInstant() { [EOL] long value = -5; [EOL] long instant = 10; [EOL] long expected = -50; // Assuming iScalar is 10 for this test [EOL] long result = getMillis(value, instant); [EOL] assertEquals(expected, result); [EOL] } [EOL] public void testGetMillis_withPositiveValueNegativeInstant() { [EOL] long value = 5; [EOL] long instant = -10; [EOL] long expected = 50; // Assuming iScalar is 10 for this test [EOL] long result = getMillis(value, instant); [EOL] assertEquals(expected, result); [EOL] } [EOL] public void testGetMillis_withNegativeValueNegativeInstant() { [EOL] long value = -5; [EOL] long instant = -10; [EOL] long expected = -50; // Assuming iScalar is 10 for this test [EOL] long result = getMillis(value, instant); [EOL] assertEquals(expected, result); [EOL] } [EOL] public void testGetMillis_withZeroValue() { [EOL] long value = 0; [EOL] long instant = 10; [EOL] long expected = 0; // Assuming iScalar is 10 for this test [EOL] long result = getMillis(value, instant); [EOL] assertEquals(expected, result); [EOL] } [EOL] public void testGetMillis_withZeroInstant() { [EOL] long value = 5; [EOL] long instant = 0; [EOL] long expected = 50; // Assuming iScalar is 10 for this test [EOL] long result = getMillis(value, instant); [EOL] assertEquals(expected, result); [EOL] } [EOL] public void testGetMillis_withMaxValue() { [EOL] long value = Long.MAX_VALUE; [EOL] long instant = 10; [EOL] long expected = Long.MAX_VALUE; [EOL] long result = getMillis(value, instant); [EOL] assertEquals(expected, result); [EOL] } [EOL] public void testGetMillis_withMinValue() { [EOL] long value = Long.MIN_VALUE; [EOL] long instant = 10; [EOL] long expected = Long.MIN_VALUE; [EOL] long result = getMillis(value, instant); [EOL] assertEquals(expected, result); [EOL] }
public void testEquals_Reflexive() { [EOL] ScaledDurationField field = new ScaledDurationField(null, null, 1); [EOL] assertTrue(field.equals(field)); [EOL] }
public void testEquals_Null() { [EOL] ScaledDurationField field = new ScaledDurationField(null, null, 1); [EOL] assertFalse(field.equals(null)); [EOL] }
public void testEquals_OtherClass() { [EOL] ScaledDurationField field = new ScaledDurationField(null, null, 1); [EOL] assertFalse(field.equals(new Object())); [EOL] }
public void testEquals_SameFields() { [EOL] ScaledDurationField field1 = new ScaledDurationField(mockDurationField(), mockDurationFieldType(), 1); [EOL] ScaledDurationField field2 = new ScaledDurationField(mockDurationField(), mockDurationFieldType(), 1); [EOL] assertTrue(field1.equals(field2)); [EOL] }
public void testEquals_DifferentWrappedField() { [EOL] ScaledDurationField field1 = new ScaledDurationField(mockDurationField(), mockDurationFieldType(), 1); [EOL] ScaledDurationField field2 = new ScaledDurationField(mockAnotherDurationField(), mockDurationFieldType(), 1); [EOL] assertFalse(field1.equals(field2)); [EOL] }
public void testEquals_DifferentType() { [EOL] ScaledDurationField field1 = new ScaledDurationField(mockDurationField(), mockDurationFieldType(), 1); [EOL] ScaledDurationField field2 = new ScaledDurationField(mockDurationField(), mockAnotherDurationFieldType(), 1); [EOL] assertFalse(field1.equals(field2)); [EOL] }
public void testEquals_DifferentScalar() { [EOL] ScaledDurationField field1 = new ScaledDurationField(mockDurationField(), mockDurationFieldType(), 1); [EOL] ScaledDurationField field2 = new ScaledDurationField(mockDurationField(), mockDurationFieldType(), 2); [EOL] assertFalse(field1.equals(field2)); [EOL] }
public void testGetInstance_Coverage() { [EOL] ISOChronology instance = ISOChronology.getInstance(); [EOL] assertNotNull(instance); [EOL] assertEquals(DateTimeZone.getDefault(), instance.getZone()); [EOL] }
public void testGetInstanceWithNullZone() { [EOL] ISOChronology result = ISOChronology.getInstance(null); [EOL] assertNotNull(result); [EOL] assertEquals(DateTimeZone.getDefault(), result.getZone()); [EOL] }
public void testGetInstanceWithNonNullZone() { [EOL] DateTimeZone fixedZone = DateTimeZone.forID("Europe/Paris"); [EOL] ISOChronology result = ISOChronology.getInstance(fixedZone); [EOL] assertNotNull(result); [EOL] assertEquals(fixedZone, result.getZone()); [EOL] }
public void testGetInstanceWithSameZoneReturnsSameChronology() { [EOL] DateTimeZone fixedZone = DateTimeZone.forID("Europe/Paris"); [EOL] ISOChronology firstCall = ISOChronology.getInstance(fixedZone); [EOL] ISOChronology secondCall = ISOChronology.getInstance(fixedZone); [EOL] assertSame(firstCall, secondCall); [EOL] }
public void testISOChronologyConstructor() { [EOL] Chronology baseChronology = /* obtain or mock a Chronology object */; [EOL] ISOChronology isoChronology = new ISOChronology(baseChronology); [EOL] assertNotNull(isoChronology); [EOL] assertSame(baseChronology, isoChronology.getBase()); [EOL] }
public void testToStringWithNonNullZone() { [EOL] ISOChronology chronology = ISOChronology.getInstance(DateTimeZone.forID("Europe/Paris")); [EOL] String result = chronology.toString(); [EOL] assertEquals("ISOChronology[Europe/Paris]", result); [EOL] }
public void testToStringWithNullZone() { [EOL] ISOChronology chronology = ISOChronology.getInstance(null); [EOL] String result = chronology.toString(); [EOL] assertEquals("ISOChronology", result); [EOL] }
public void testAssembleWithUTCZone() { [EOL] Fields fields = new Fields(); [EOL] Base base = new Base(DateTimeZone.UTC); [EOL] base.assemble(fields); [EOL] assertNotNull(fields.centuryOfEra); [EOL] assertNotNull(fields.centuries); [EOL] assertNotNull(fields.yearOfCentury); [EOL] assertNotNull(fields.weekyearOfCentury); [EOL] }
public void testAssembleWithNonUTCZone() { [EOL] Fields fields = new Fields(); [EOL] Base base = new Base(DateTimeZone.forID("Europe/Paris")); [EOL] base.assemble(fields); [EOL] assertNull(fields.centuryOfEra); [EOL] assertNull(fields.centuries); [EOL] assertNull(fields.yearOfCentury); [EOL] assertNull(fields.weekyearOfCentury); [EOL] }
public void testGetName() { [EOL] TimeType mockType = mock(TimeType.class); [EOL] when(mockType.getName()).thenReturn("MockedName"); [EOL] Time time = new Time(mockType); [EOL] String name = time.getName(); [EOL] assertEquals("MockedName", name); [EOL] }
public void testGetInstanceUTC() { [EOL] CopticChronology instance = CopticChronology.getInstanceUTC(); [EOL] assertNotNull(instance); [EOL] assertSame(CopticChronology.INSTANCE_UTC, instance); [EOL] }
public static CopticChronology getInstance() { [EOL] return getInstance(DateTimeZone.getDefault(), 4); [EOL] }
public void testGetInstanceWithNullZone() { [EOL] CopticChronology instance = CopticChronology.getInstance(null); [EOL] assertNotNull(instance); [EOL] assertEquals(DateTimeZone.UTC, instance.getZone()); [EOL] }
public void testGetInstanceWithSpecificZone() { [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/Paris"); [EOL] CopticChronology instance = CopticChronology.getInstance(zone); [EOL] assertNotNull(instance); [EOL] assertEquals(zone, instance.getZone()); [EOL] }
public void testGetInstanceWithNullZoneAndValidMinDays() { [EOL] int minDaysInFirstWeek = 4; [EOL] CopticChronology chrono = CopticChronology.getInstance(null, minDaysInFirstWeek); [EOL] assertNotNull(chrono); [EOL] assertEquals(DateTimeZone.getDefault(), chrono.getZone()); [EOL] assertEquals(minDaysInFirstWeek, chrono.getMinimumDaysInFirstWeek()); [EOL] }
public void testGetInstanceWithNonNullZoneAndValidMinDays() { [EOL] int minDaysInFirstWeek = 4; [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/London"); [EOL] CopticChronology chrono = CopticChronology.getInstance(zone, minDaysInFirstWeek); [EOL] assertNotNull(chrono); [EOL] assertEquals(zone, chrono.getZone()); [EOL] assertEquals(minDaysInFirstWeek, chrono.getMinimumDaysInFirstWeek()); [EOL] }
public void testGetInstanceWithUTCZoneAndValidMinDays() { [EOL] int minDaysInFirstWeek = 4; [EOL] DateTimeZone zone = DateTimeZone.UTC; [EOL] CopticChronology chrono = CopticChronology.getInstance(zone, minDaysInFirstWeek); [EOL] assertNotNull(chrono); [EOL] assertEquals(DateTimeZone.UTC, chrono.getZone()); [EOL] assertEquals(minDaysInFirstWeek, chrono.getMinimumDaysInFirstWeek()); [EOL] }
public void testGetInstanceWithInvalidMinDays() { [EOL] int minDaysInFirstWeek = 0; [EOL] try { [EOL] CopticChronology.getInstance(null, minDaysInFirstWeek); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testCalculateFirstDayOfYearMillisForNegativeRelativeYear() { [EOL] int year = 1686; // relativeYear will be -1 [EOL] long expectedMillis = ...; // calculate expected millis based on the logic [EOL] long actualMillis = calculateFirstDayOfYearMillis(year); [EOL] assertEquals(expectedMillis, actualMillis); [EOL] } [EOL] public void testCalculateFirstDayOfYearMillisForLeapYear() { [EOL] int year = 1692; // relativeYear will be 5, and a leap year [EOL] long expectedMillis = ...; // calculate expected millis based on the logic [EOL] long actualMillis = calculateFirstDayOfYearMillis(year); [EOL] assertEquals(expectedMillis, actualMillis); [EOL] } [EOL] public void testCalculateFirstDayOfYearMillisForNonLeapYear() { [EOL] int year = 1693; // relativeYear will be 6, and not a leap year [EOL] long expectedMillis = ...; // calculate expected millis based on the logic [EOL] long actualMillis = calculateFirstDayOfYearMillis(year); [EOL] assertEquals(expectedMillis, actualMillis); [EOL] }
public void testGetApproxMillisAtEpochDividedByTwo() { [EOL] long expected = (1686L * 31536000000L + 112L * 86400000L) / 2; [EOL] long actual = getApproxMillisAtEpochDividedByTwo(); [EOL] assertEquals(expected, actual); [EOL] }
public void testMonthsZero() { [EOL] Months result = Time.months(0); [EOL] assertEquals(Months.ZERO, result); [EOL] }
public void testMonthsOne() { [EOL] Months result = Time.months(1); [EOL] assertEquals(Months.ONE, result); [EOL] }
public void testMonthsTwo() { [EOL] Months result = Time.months(2); [EOL] assertEquals(Months.TWO, result); [EOL] }
public void testMonthsThree() { [EOL] Months result = Time.months(3); [EOL] assertEquals(Months.THREE, result); [EOL] }
public void testMonthsFour() { [EOL] Months result = Time.months(4); [EOL] assertEquals(Months.FOUR, result); [EOL] }
public void testMonthsFive() { [EOL] Months result = Time.months(5); [EOL] assertEquals(Months.FIVE, result); [EOL] }
public void testMonthsSix() { [EOL] Months result = Time.months(6); [EOL] assertEquals(Months.SIX, result); [EOL] }
public void testMonthsSeven() { [EOL] Months result = Time.months(7); [EOL] assertEquals(Months.SEVEN, result); [EOL] }
public void testMonthsEight() { [EOL] Months result = Time.months(8); [EOL] assertEquals(Months.EIGHT, result); [EOL] }
public void testMonthsNine() { [EOL] Months result = Time.months(9); [EOL] assertEquals(Months.NINE, result); [EOL] }
public void testMonthsTen() { [EOL] Months result = Time.months(10); [EOL] assertEquals(Months.TEN, result); [EOL] }
public void testMonthsEleven() { [EOL] Months result = Time.months(11); [EOL] assertEquals(Months.ELEVEN, result); [EOL] }
public void testMonthsTwelve() { [EOL] Months result = Time.months(12); [EOL] assertEquals(Months.TWELVE, result); [EOL] }
public void testMonthsMaxValue() { [EOL] Months result = Time.months(Integer.MAX_VALUE); [EOL] assertEquals(Months.MAX_VALUE, result); [EOL] }
public void testMonthsMinValue() { [EOL] Months result = Time.months(Integer.MIN_VALUE); [EOL] assertEquals(Months.MIN_VALUE, result); [EOL] }
public void testMonthsDefault() { [EOL] int arbitraryNonSpecialCase = 13; [EOL] Months result = Time.months(arbitraryNonSpecialCase); [EOL] assertNotNull(result); [EOL] assertEquals(arbitraryNonSpecialCase, result.getMonths()); [EOL] }
It seems there was a misunderstanding. The provided input text does not contain any comments, NL descriptions, or @Test annotations to remove. The input text is a constructor for a class named `Months` which simply calls its superclass constructor with an integer parameter. Since the constructor is private, it cannot be directly tested from outside the class. However, if there were public or protected methods that create instances of `Months` or if there is a factory method or a static method that can be used to create instances, then those could be tested. [EOL] If you have such methods or additional context, please provide them so that I can generate the appropriate test cases. Otherwise, without a way to instantiate `Months` or without knowing more about the context in which it is used, it is not possible to generate meaningful test cases.
public void testGetPeriodType_ReturnsMonths() { [EOL] Period period = new Period(); [EOL] PeriodType type = period.getPeriodType(); [EOL] assertEquals(PeriodType.months(), type); [EOL] }
public void testIntervalWithNullIntervalAndNullChronology() { [EOL] Interval interval = new Interval(null, null); [EOL] assertNull(interval.getStart()); [EOL] assertNull(interval.getEnd()); [EOL] }
public void testIntervalWithNonNullIntervalAndNullChronology() { [EOL] Object intervalObject = new Object(); // Replace with actual interval object if needed [EOL] Interval interval = new Interval(intervalObject, null); [EOL] assertNotNull(interval.getStart()); [EOL] assertNotNull(interval.getEnd()); [EOL] }
public void testIntervalWithNullIntervalAndNonNullChronology() { [EOL] Chronology chronology = ISOChronology.getInstance(); // Replace with actual chronology if needed [EOL] Interval interval = new Interval(null, chronology); [EOL] assertNull(interval.getStart()); [EOL] assertNull(interval.getEnd()); [EOL] }
public void testIntervalWithNonNullIntervalAndNonNullChronology() { [EOL] Object intervalObject = new Object(); // Replace with actual interval object if needed [EOL] Chronology chronology = ISOChronology.getInstance(); // Replace with actual chronology if needed [EOL] Interval interval = new Interval(intervalObject, chronology); [EOL] assertNotNull(interval.getStart()); [EOL] assertNotNull(interval.getEnd()); [EOL] }
public void testWithDurationBeforeEnd_SameDuration() { [EOL] Interval interval = new Interval(0, 1000); // Assuming 1000ms duration [EOL] ReadableDuration duration = new Duration(1000); [EOL] Interval result = interval.withDurationBeforeEnd(duration); [EOL] assertSame("The returned interval should be the same as the original interval", interval, result); [EOL] }
public void testWithDurationBeforeEnd_DifferentDuration() { [EOL] Interval interval = new Interval(0, 1000); // Assuming 1000ms duration [EOL] ReadableDuration duration = new Duration(500); [EOL] Interval result = interval.withDurationBeforeEnd(duration); [EOL] assertEquals("The end of the interval should remain unchanged", interval.getEndMillis(), result.getEndMillis()); [EOL] assertEquals("The start of the interval should be adjusted", interval.getEndMillis() - duration.getMillis(), result.getStartMillis()); [EOL] }
public void testWithPeriodAfterStart_NullPeriod() { [EOL] Interval interval = new Interval(0, 10); // Assuming constructor Interval(long startMillis, long endMillis) [EOL] Interval result = interval.withPeriodAfterStart(null); [EOL] assertNull("Expected duration after start to be null", result.toDuration()); [EOL] } [EOL] public void testWithPeriodAfterStart_NonNullPeriod() { [EOL] Interval interval = new Interval(0, 10); // Assuming constructor Interval(long startMillis, long endMillis) [EOL] ReadablePeriod period = new Period(0, 0, 0, 1); // Assuming constructor Period(hours, minutes, seconds, millis) [EOL] Interval result = interval.withPeriodAfterStart(period); [EOL] assertNotNull("Expected interval not to be null", result); [EOL] assertEquals("Expected start millis to be 0", 0, result.getStartMillis()); [EOL] long expectedEndMillis = calculateExpectedEndMillis(0, period); [EOL] assertEquals("Expected end millis to match", expectedEndMillis, result.getEndMillis()); [EOL] }
public static YearMonth now() { [EOL] return new YearMonth(); [EOL] }
public void testNowWithNullChronologyThrowsNullPointerException() { [EOL] try { [EOL] YearMonth.now(null); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException e) { [EOL] assertEquals("Chronology must not be null", e.getMessage()); [EOL] } [EOL] }
public void testNowWithNonNullChronology() { [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] YearMonth yearMonth = YearMonth.now(chronology); [EOL] assertNotNull(yearMonth); [EOL] assertEquals(chronology, yearMonth.getChronology()); [EOL] }
public void testFromCalendarFields_withNullCalendar() { [EOL] try { [EOL] YearMonth.fromCalendarFields(null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("The calendar must not be null", ex.getMessage()); [EOL] } [EOL] }
public void testFromCalendarFields_withValidCalendar() { [EOL] Calendar calendar = Calendar.getInstance(); [EOL] calendar.set(Calendar.YEAR, 2023); [EOL] calendar.set(Calendar.MONTH, Calendar.JANUARY); // Calendar.JANUARY is 0 [EOL] YearMonth result = YearMonth.fromCalendarFields(calendar); [EOL] assertEquals(2023, result.getYear()); [EOL] assertEquals(1, result.getMonthOfYear()); // January is 1 in YearMonth [EOL] }
public void testYearMonthDefaultConstructor() { [EOL] YearMonth yearMonth = new YearMonth(); [EOL] assertNotNull(yearMonth); [EOL] assertEquals(new YearMonth().getYear(), yearMonth.getYear()); [EOL] assertEquals(new YearMonth().getMonthOfYear(), yearMonth.getMonthOfYear()); [EOL] }
public void testYearMonthChronologyConstructor() { [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] YearMonth yearMonth = new YearMonth(chronology); [EOL] assertNotNull(yearMonth); [EOL] assertEquals(chronology, yearMonth.getChronology()); [EOL] }
public void testYearMonthLongConstructor() { [EOL] long instant = System.currentTimeMillis(); [EOL] YearMonth yearMonth = new YearMonth(instant); [EOL] assertNotNull(yearMonth); [EOL] assertEquals(new YearMonth(instant).getYear(), yearMonth.getYear()); [EOL] assertEquals(new YearMonth(instant).getMonthOfYear(), yearMonth.getMonthOfYear()); [EOL] }
public void testYearMonthLongChronologyConstructor() { [EOL] long instant = System.currentTimeMillis(); [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] YearMonth yearMonth = new YearMonth(instant, chronology); [EOL] assertNotNull(yearMonth); [EOL] assertEquals(chronology, yearMonth.getChronology()); [EOL] }
public void testYearMonthIntIntConstructor() { [EOL] int year = 2023; [EOL] int month = 4; [EOL] YearMonth yearMonth = new YearMonth(year, month); [EOL] assertNotNull(yearMonth); [EOL] assertEquals(year, yearMonth.getYear()); [EOL] assertEquals(month, yearMonth.getMonthOfYear()); [EOL] }
public void testYearMonthIntIntChronologyConstructor() { [EOL] int year = 2023; [EOL] int month = 4; [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] YearMonth yearMonth = new YearMonth(year, month, chronology); [EOL] assertNotNull(yearMonth); [EOL] assertEquals(year, yearMonth.getYear()); [EOL] assertEquals(month, yearMonth.getMonthOfYear()); [EOL] assertEquals(chronology, yearMonth.getChronology()); [EOL] }
public void testYearMonthNow() { [EOL] YearMonth yearMonth = YearMonth.now(); [EOL] assertNotNull(yearMonth); [EOL] assertEquals(YearMonth.now().getYear(), yearMonth.getYear()); [EOL] assertEquals(YearMonth.now().getMonthOfYear(), yearMonth.getMonthOfYear()); [EOL] }
public void testYearMonthNowZone() { [EOL] DateTimeZone zone = DateTimeZone.UTC; [EOL] YearMonth yearMonth = YearMonth.now(zone); [EOL] assertNotNull(yearMonth); [EOL] assertEquals(YearMonth.now(zone).getYear(), yearMonth.getYear()); [EOL] assertEquals(YearMonth.now(zone).getMonthOfYear(), yearMonth.getMonthOfYear()); [EOL] }
public void testYearMonthNowChronology() { [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] YearMonth yearMonth = YearMonth.now(chronology); [EOL] assertNotNull(yearMonth); [EOL] assertEquals(YearMonth.now(chronology).getYear(), yearMonth.getYear()); [EOL] assertEquals(YearMonth.now(chronology).getMonthOfYear(), yearMonth.getMonthOfYear()); [EOL] }
public void testYearMonth_Object_Chronology() { [EOL] Object instant = new Date(); [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] YearMonth yearMonth = new YearMonth(instant, chronology); [EOL] assertNotNull(yearMonth); [EOL] }
public void testYearMonth_Object_NullChronology() { [EOL] Object instant = new Date(); [EOL] YearMonth yearMonth = new YearMonth(instant, null); [EOL] assertNotNull(yearMonth); [EOL] assertEquals(ISOChronology.getInstance(), yearMonth.getChronology()); [EOL] }
public void testYearMonth_Long_Chronology() { [EOL] long instant = System.currentTimeMillis(); [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] YearMonth yearMonth = new YearMonth(instant, chronology); [EOL] assertNotNull(yearMonth); [EOL] }
public void testYearMonth_Long_NullChronology() { [EOL] long instant = System.currentTimeMillis(); [EOL] YearMonth yearMonth = new YearMonth(instant, null); [EOL] assertNotNull(yearMonth); [EOL] assertEquals(ISOChronology.getInstance(), yearMonth.getChronology()); [EOL] }
public void testYearMonth_Ints() { [EOL] int year = 2023; [EOL] int monthOfYear = 4; [EOL] YearMonth yearMonth = new YearMonth(year, monthOfYear); [EOL] assertNotNull(yearMonth); [EOL] assertEquals(year, yearMonth.getYear()); [EOL] assertEquals(monthOfYear, yearMonth.getMonthOfYear()); [EOL] }
public void testYearMonth_Ints_Chronology() { [EOL] int year = 2023; [EOL] int monthOfYear = 4; [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] YearMonth yearMonth = new YearMonth(year, monthOfYear, chronology); [EOL] assertNotNull(yearMonth); [EOL] assertEquals(chronology, yearMonth.getChronology()); [EOL] }
public void testYearMonth_Now() { [EOL] YearMonth yearMonth = YearMonth.now(); [EOL] assertNotNull(yearMonth); [EOL] }
public void testYearMonth_Now_Zone() { [EOL] DateTimeZone zone = DateTimeZone.getDefault(); [EOL] YearMonth yearMonth = YearMonth.now(zone); [EOL] assertNotNull(yearMonth); [EOL] assertEquals(zone, yearMonth.getChronology().getZone()); [EOL] }
public void testYearMonth_Now_Chronology() { [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] YearMonth yearMonth = YearMonth.now(chronology); [EOL] assertNotNull(yearMonth); [EOL] assertEquals(chronology, yearMonth.getChronology()); [EOL] }
public void testYearMonth_Parse_String() { [EOL] String str = "2023-04"; [EOL] YearMonth yearMonth = YearMonth.parse(str); [EOL] assertNotNull(yearMonth); [EOL] assertEquals(2023, yearMonth.getYear()); [EOL] assertEquals(4, yearMonth.getMonthOfYear()); [EOL] }
public void testYearMonth_Parse_String_Formatter() { [EOL] String str = "2023-04"; [EOL] DateTimeFormatter formatter = ISODateTimeFormat.yearMonth(); [EOL] YearMonth yearMonth = YearMonth.parse(str, formatter); [EOL] assertNotNull(yearMonth); [EOL] assertEquals(2023, yearMonth.getYear()); [EOL] assertEquals(4, yearMonth.getMonthOfYear()); [EOL] }
public void testWithYear_ValidYear() { [EOL] YearMonth yearMonth = new YearMonth(2020, 1); [EOL] YearMonth updatedYearMonth = yearMonth.withYear(2021); [EOL] assertEquals(2021, updatedYearMonth.getYear()); [EOL] assertEquals(1, updatedYearMonth.getMonthOfYear()); [EOL] }
public void testWithYear_SameYear() { [EOL] YearMonth yearMonth = new YearMonth(2020, 1); [EOL] YearMonth updatedYearMonth = yearMonth.withYear(2020); [EOL] assertSame(yearMonth, updatedYearMonth); [EOL] }
public void testWithYear_InvalidYear() { [EOL] YearMonth yearMonth = new YearMonth(2020, 1); [EOL] try { [EOL] yearMonth.withYear(Integer.MAX_VALUE); [EOL] fail("Should have thrown an exception for an invalid year"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testWithMonthOfYear_ValidMonth() { [EOL] YearMonth yearMonth = new YearMonth(2023, 1); // January 2023 [EOL] YearMonth updatedYearMonth = yearMonth.withMonthOfYear(2); // Change to February [EOL] assertEquals(2, updatedYearMonth.getMonthOfYear()); [EOL] }
public void testWithMonthOfYear_InvalidMonth() { [EOL] YearMonth yearMonth = new YearMonth(2023, 1); // January 2023 [EOL] try { [EOL] yearMonth.withMonthOfYear(13); // Invalid month, should throw exception [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
protected ReadablePartial getReadablePartial() { [EOL] return iBase; [EOL] } [EOL] public YearMonth(); [EOL] public YearMonth(DateTimeZone zone); [EOL] public YearMonth(Chronology chronology); [EOL] public YearMonth(long instant); [EOL] public YearMonth(long instant, Chronology chronology); [EOL] public YearMonth(Object instant); [EOL] public YearMonth(Object instant, Chronology chronology); [EOL] public YearMonth(int year, int monthOfYear); [EOL] public YearMonth(int year, int monthOfYear, Chronology chronology); [EOL] YearMonth(YearMonth partial, int[] values); [EOL] YearMonth(YearMonth partial, Chronology chrono); [EOL] Property(YearMonth partial, int fieldIndex); [EOL] public static YearMonth now(); [EOL] public static YearMonth now(DateTimeZone zone); [EOL] public static YearMonth now(Chronology chronology); [EOL] public static YearMonth parse(String str); [EOL] public static YearMonth parse(String str, DateTimeFormatter formatter); [EOL] public static YearMonth fromCalendarFields(Calendar calendar); [EOL] public static YearMonth fromDateFields(Date date); [EOL] private Object readResolve(); [EOL] public int size(); [EOL] protected DateTimeField getField(int index, Chronology chrono); [EOL] public DateTimeFieldType getFieldType(int index); [EOL] public DateTimeFieldType[] getFieldTypes(); [EOL] public YearMonth withChronologyRetainFields(Chronology newChronology); [EOL] public YearMonth withField(DateTimeFieldType fieldType, int value); [EOL] public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); [EOL] public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); [EOL] public YearMonth plus(ReadablePeriod period); [EOL] public YearMonth plusYears(int years); [EOL] public YearMonth plusMonths(int months); [EOL] public YearMonth minus(ReadablePeriod period); [EOL] public YearMonth minusYears(int years); [EOL] public YearMonth minusMonths(int months); [EOL] public LocalDate toLocalDate(int dayOfMonth); [EOL] public Interval toInterval(); [EOL] public Interval toInterval(DateTimeZone zone); [EOL] public int getYear(); [EOL] public int getMonthOfYear(); [EOL] public YearMonth withYear(int year); [EOL] public YearMonth withMonthOfYear(int monthOfYear); [EOL] public Property property(DateTimeFieldType type); [EOL] public Property year(); [EOL] public Property monthOfYear(); [EOL] public String toString(); [EOL] public String toString(String pattern); [EOL] public String toString(String pattern, Locale locale) throws IllegalArgumentException; [EOL] public DateTimeField getField(); [EOL] protected ReadablePartial getReadablePartial(); [EOL] public YearMonth getYearMonth(); [EOL] public int get(); [EOL] public YearMonth addToCopy(int valueToAdd); [EOL] public YearMonth addWrapFieldToCopy(int valueToAdd); [EOL] public YearMonth setCopy(int value); [EOL] public YearMonth setCopy(String text, Locale locale); [EOL] public YearMonth setCopy(String text); [EOL] long serialVersionUID=Optional[797544782896179L]; [EOL] DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }];
public void testBaseDateTimeFieldWithNonNullType() { [EOL] DateTimeFieldType type = DateTimeFieldType.dayOfMonth(); [EOL] BaseDateTimeField field = new BaseDateTimeField(type); [EOL] assertNotNull(field); [EOL] assertEquals(type, field.getType()); [EOL] }
public void testBaseDateTimeFieldWithNullType() { [EOL] try { [EOL] new BaseDateTimeField(null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("The type must not be null", e.getMessage()); [EOL] } [EOL] }
public void testGetAsTextWithValidPartialAndLocale() { [EOL] ReadablePartial mockPartial = // create mock or real instance of ReadablePartial [EOL] Locale testLocale = // create or use a specific Locale [EOL] String expectedText = // define the expected text output [EOL] String actualText = getAsText(mockPartial, testLocale); [EOL] assertEquals(expectedText, actualText); [EOL] }
public void testAddWrapPartial_ValueToAddIsZero() { [EOL] int[] values = new int[] {1, 2, 3}; [EOL] int[] result = addWrapPartial(instant, 1, values, 0); [EOL] assertEquals("Value should not change when valueToAdd is zero", 2, result[1]); [EOL] }
public void testAddWrapPartial_ValueToAddPositiveWithoutWrap() { [EOL] int[] values = new int[] {1, 2, 3}; [EOL] int[] result = addWrapPartial(instant, 1, values, 1); [EOL] assertEquals("Value should increase by 1", 3, result[1]); [EOL] }
public void testAddWrapPartial_ValueToAddPositiveWithWrap() { [EOL] int[] values = new int[] {1, 5, 3}; [EOL] int[] result = addWrapPartial(instant, 1, values, 2); [EOL] assertEquals("Value should wrap around to minimum", getMinimumValue(instant, values), result[1]); [EOL] }
public void testAddWrapPartial_ValueToAddNegativeWithoutWrap() { [EOL] int[] values = new int[] {1, 2, 3}; [EOL] int[] result = addWrapPartial(instant, 1, values, -1); [EOL] assertEquals("Value should decrease by 1", 1, result[1]); [EOL] }
public void testAddWrapPartial_ValueToAddNegativeWithWrap() { [EOL] int[] values = new int[] {1, 0, 3}; [EOL] int[] result = addWrapPartial(instant, 1, values, -1); [EOL] assertEquals("Value should wrap around to maximum", getMaximumValue(instant, values), result[1]); [EOL] }
public void testAddWrapPartial_InvalidFieldIndex() { [EOL] int[] values = new int[] {1, 2, 3}; [EOL] try { [EOL] addWrapPartial(instant, -1, values, 1); [EOL] fail("Should throw IndexOutOfBoundsException for negative fieldIndex"); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testAddWrapPartial_InvalidFieldsForAdd() { [EOL] int[] values = new int[] {1, 2, 3}; [EOL] try { [EOL] addWrapPartial(instant, 1, values, 1); [EOL] fail("Should throw IllegalArgumentException when fields are invalid for add"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testGetDifference() { [EOL] Time time = new Time(); [EOL] long minuendInstant = 1000L; [EOL] long subtrahendInstant = 500L; [EOL] int expectedDifference = time.getDurationField().getDifference(minuendInstant, subtrahendInstant); [EOL] int actualDifference = time.getDifference(minuendInstant, subtrahendInstant); [EOL] assertEquals(expectedDifference, actualDifference); [EOL] }
public void testGetDifferenceAsLong() { [EOL] long minuendInstant = 1000L; [EOL] long subtrahendInstant = 500L; [EOL] long expectedDifference = 500L; // Assuming getDurationField().getDifferenceAsLong returns the simple difference [EOL] long actualDifference = getDifferenceAsLong(minuendInstant, subtrahendInstant); [EOL] assertEquals(expectedDifference, actualDifference); [EOL] }
public void testSetWithValidValues() { [EOL] ReadablePartial mockPartial = createMockPartial(3); // Assuming createMockPartial creates a partial with 3 fields [EOL] int fieldIndex = 1; [EOL] int[] values = new int[]{10, 20, 30}; [EOL] int newValue = 25; [EOL] int[] result = set(mockPartial, fieldIndex, values, newValue); [EOL] assertEquals(25, result[fieldIndex]); [EOL] assertTrue(result[2] <= mockPartial.getField(2).getMaximumValue(mockPartial, result)); [EOL] assertTrue(result[2] >= mockPartial.getField(2).getMinimumValue(mockPartial, result)); [EOL] }
public void testSetWithMaxBoundaryValue() { [EOL] ReadablePartial mockPartial = createMockPartial(3); // Assuming createMockPartial creates a partial with 3 fields [EOL] int fieldIndex = 1; [EOL] int[] values = new int[]{10, 20, 30}; [EOL] int newValue = mockPartial.getField(fieldIndex).getMaximumValue(mockPartial, values); [EOL] int[] result = set(mockPartial, fieldIndex, values, newValue); [EOL] assertEquals(newValue, result[fieldIndex]); [EOL] assertTrue(result[2] <= mockPartial.getField(2).getMaximumValue(mockPartial, result)); [EOL] assertTrue(result[2] >= mockPartial.getField(2).getMinimumValue(mockPartial, result)); [EOL] }
public void testSetWithMinBoundaryValue() { [EOL] ReadablePartial mockPartial = createMockPartial(3); // Assuming createMockPartial creates a partial with 3 fields [EOL] int fieldIndex = 1; [EOL] int[] values = new int[]{10, 20, 30}; [EOL] int newValue = mockPartial.getField(fieldIndex).getMinimumValue(mockPartial, values); [EOL] int[] result = set(mockPartial, fieldIndex, values, newValue); [EOL] assertEquals(newValue, result[fieldIndex]); [EOL] assertTrue(result[2] <= mockPartial.getField(2).getMaximumValue(mockPartial, result)); [EOL] assertTrue(result[2] >= mockPartial.getField(2).getMinimumValue(mockPartial, result)); [EOL] }
public void testSetWithAdjustmentOfSubsequentFields() { [EOL] ReadablePartial mockPartial = createMockPartial(3); // Assuming createMockPartial creates a partial with 3 fields [EOL] int fieldIndex = 0; [EOL] int[] values = new int[]{10, 50, 30}; // 50 is above the max for field 1 [EOL] int newValue = 15; [EOL] int[] result = set(mockPartial, fieldIndex, values, newValue); [EOL] assertEquals(newValue, result[fieldIndex]); [EOL] assertEquals(mockPartial.getField(1).getMaximumValue(mockPartial, result), result[1]); [EOL] assertEquals(mockPartial.getField(2).getMaximumValue(mockPartial, result), result[2]); [EOL] }
public void testSetWithNoAdjustmentNeeded() { [EOL] ReadablePartial mockPartial = createMockPartial(3); // Assuming createMockPartial creates a partial with 3 fields [EOL] int fieldIndex = 0; [EOL] int[] values = new int[]{10, 20, 30}; [EOL] int newValue = 15; [EOL] int[] result = set(mockPartial, fieldIndex, values, newValue); [EOL] assertEquals(newValue, result[fieldIndex]); [EOL] assertEquals(20, result[1]); [EOL] assertEquals(30, result[2]); [EOL] }
public int[] setTestWithValidText() { [EOL] ReadablePartial mockInstant = mock(ReadablePartial.class); [EOL] int fieldIndex = 0; [EOL] int[] values = new int[] {1, 2, 3}; [EOL] String text = "4"; [EOL] Locale locale = Locale.ENGLISH; [EOL] int[] expected = new int[] {4, 2, 3}; [EOL] int[] result = set(mockInstant, fieldIndex, values, text, locale); [EOL] assertArrayEquals(expected, result); [EOL] } [EOL] public int[] setTestWithInvalidText() { [EOL] ReadablePartial mockInstant = mock(ReadablePartial.class); [EOL] int fieldIndex = 0; [EOL] int[] values = new int[] {1, 2, 3}; [EOL] String text = "invalid"; [EOL] Locale locale = Locale.ENGLISH; [EOL] try { [EOL] set(mockInstant, fieldIndex, values, text, locale); [EOL] fail("Should have thrown an exception for invalid text"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public int getLeapAmount(long instant) { [EOL] return 0; [EOL] }
public int getMinimumValue(ReadablePartial instant) { [EOL] return getMinimumValue(); [EOL] }
public int getMinimumValueTestWithNonNullInstant() { [EOL] ReadablePartial mockInstant = Mockito.mock(ReadablePartial.class); [EOL] int[] values = new int[] {1, 2, 3}; [EOL] int result = getMinimumValue(mockInstant, values); [EOL] assertEquals(expectedMinimumValue, result); [EOL] }
public int getMinimumValueTestWithNullInstant() { [EOL] int[] values = new int[] {1, 2, 3}; [EOL] try { [EOL] getMinimumValue(null, values); [EOL] fail("Expected an IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Instant must not be null", e.getMessage()); [EOL] } [EOL] }
@Test [EOL] public void exampleTestMethod() { [EOL] /* This is a multi-line comment [EOL] that spans multiple lines */ [EOL] System.out.println("Hello, World!"); // Another comment [EOL] }
public int getMaximumValueTest() { [EOL] ReadablePartial mockPartial = createMockReadablePartial(); [EOL] int result = getMaximumValue(mockPartial); [EOL] int expected = determineExpectedMaximumValue(); [EOL] assertEquals(expected, result); [EOL] }
public int getMaximumValueTestWithNonNullInstant() { [EOL] ReadablePartial mockInstant = Mockito.mock(ReadablePartial.class); [EOL] int[] values = new int[] {1, 2, 3}; [EOL] int expected = 10; // Assuming getMaximumValue(ReadablePartial instant) returns 10 [EOL] Mockito.when(yourClassInstance.getMaximumValue(mockInstant)).thenReturn(expected); [EOL] int actual = yourClassInstance.getMaximumValue(mockInstant, values); [EOL] assertEquals(expected, actual); [EOL] }
public int getMaximumValueTestWithNullInstant() { [EOL] int[] values = new int[] {1, 2, 3}; [EOL] try { [EOL] yourClassInstance.getMaximumValue(null, values); [EOL] fail("Expected an IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Instant must not be null", e.getMessage()); [EOL] } [EOL] }
public int getMaximumShortTextLength(Locale locale) { [EOL] return getMaximumTextLength(locale); [EOL] }
public void testRoundHalfEven_FloorCloser() { [EOL] long instant = SOME_INSTANT; // Replace with a specific instant where floor is closer [EOL] long expected = SOME_FLOOR_INSTANT; // Replace with the expected floor instant [EOL] long actual = roundHalfEven(instant); [EOL] assertEquals(expected, actual); [EOL] }
public void testRoundHalfEven_CeilingCloser() { [EOL] long instant = SOME_INSTANT; // Replace with a specific instant where ceiling is closer [EOL] long expected = SOME_CEILING_INSTANT; // Replace with the expected ceiling instant [EOL] long actual = roundHalfEven(instant); [EOL] assertEquals(expected, actual); [EOL] }
public void testRoundHalfEven_Equidistant_CeilingEven() { [EOL] long instant = SOME_INSTANT; // Replace with a specific instant where diffToCeiling == diffFromFloor and ceiling is even [EOL] long expected = SOME_CEILING_INSTANT; // Replace with the expected ceiling instant [EOL] long actual = roundHalfEven(instant); [EOL] assertEquals(expected, actual); [EOL] }
public void testRoundHalfEven_Equidistant_FloorReturned() { [EOL] long instant = SOME_INSTANT; // Replace with a specific instant where diffToCeiling == diffFromFloor and ceiling is odd [EOL] long expected = SOME_FLOOR_INSTANT; // Replace with the expected floor instant [EOL] long actual = roundHalfEven(instant); [EOL] assertEquals(expected, actual); [EOL] }
public void testToString() { [EOL] DateTimeField dateTimeField = new DateTimeField("testName"); [EOL] String result = dateTimeField.toString(); [EOL] assert result.equals("DateTimeField[testName]"); [EOL] }
public void testGetMaximumValue() { [EOL] Chronology chronology = /* some implementation of Chronology */; [EOL] Time time = new Time(chronology); [EOL] int maxValue = time.getMaximumValue(); [EOL] int expectedMaxValue = chronology.getDaysInMonthMax(); [EOL] assertEquals(expectedMaxValue, maxValue); [EOL] }
public void testGetMaximumValue_WithValidInstant() { [EOL] long instant = /* valid instant value, e.g., current time */; [EOL] int expectedMaxValue = /* expected maximum value for the given instant */; [EOL] int actualMaxValue = time.getMaximumValue(instant); [EOL] assertEquals(expectedMaxValue, actualMaxValue); [EOL] }
public void testGetMaximumValue_SupportedMonthOfYearAndYear() { [EOL] ReadablePartial mockPartial = mock(ReadablePartial.class); [EOL] when(mockPartial.isSupported(DateTimeFieldType.monthOfYear())).thenReturn(true); [EOL] when(mockPartial.isSupported(DateTimeFieldType.year())).thenReturn(true); [EOL] when(mockPartial.get(DateTimeFieldType.monthOfYear())).thenReturn(5); [EOL] when(mockPartial.get(DateTimeFieldType.year())).thenReturn(2021); [EOL] when(iChronology.getDaysInYearMonth(2021, 5)).thenReturn(31); [EOL] int result = instance.getMaximumValue(mockPartial); [EOL] assertEquals(31, result); [EOL] }
public void testGetMaximumValue_SupportedMonthOfYearUnsupportedYear() { [EOL] ReadablePartial mockPartial = mock(ReadablePartial.class); [EOL] when(mockPartial.isSupported(DateTimeFieldType.monthOfYear())).thenReturn(true); [EOL] when(mockPartial.isSupported(DateTimeFieldType.year())).thenReturn(false); [EOL] when(mockPartial.get(DateTimeFieldType.monthOfYear())).thenReturn(5); [EOL] when(iChronology.getDaysInMonthMax(5)).thenReturn(31); [EOL] int result = instance.getMaximumValue(mockPartial); [EOL] assertEquals(31, result); [EOL] }
public void testGetMaximumValue_UnsupportedMonthOfYear() { [EOL] ReadablePartial mockPartial = mock(ReadablePartial.class); [EOL] when(mockPartial.isSupported(DateTimeFieldType.monthOfYear())).thenReturn(false); [EOL] int result = instance.getMaximumValue(mockPartial); [EOL] assertEquals(instance.getMaximumValue(), result); [EOL] }
public void testGetMaximumValue_WithMonthOfYearAndYear() { [EOL] ReadablePartial mockPartial = Mockito.mock(ReadablePartial.class); [EOL] int[] values = new int[] {1, 2021}; // Assuming index 0 is month and index 1 is year [EOL] Mockito.when(mockPartial.size()).thenReturn(2); [EOL] Mockito.when(mockPartial.getFieldType(0)).thenReturn(DateTimeFieldType.monthOfYear()); [EOL] Mockito.when(mockPartial.getFieldType(1)).thenReturn(DateTimeFieldType.year()); [EOL] Mockito.when(iChronology.getDaysInYearMonth(2021, 1)).thenReturn(31); [EOL] int result = getMaximumValue(mockPartial, values); [EOL] assertEquals(31, result); [EOL] }
public void testGetMaximumValue_WithMonthOfYearWithoutYear() { [EOL] ReadablePartial mockPartial = Mockito.mock(ReadablePartial.class); [EOL] int[] values = new int[] {2}; // Assuming index 0 is month [EOL] Mockito.when(mockPartial.size()).thenReturn(1); [EOL] Mockito.when(mockPartial.getFieldType(0)).thenReturn(DateTimeFieldType.monthOfYear()); [EOL] Mockito.when(iChronology.getDaysInMonthMax(2)).thenReturn(29); [EOL] int result = getMaximumValue(mockPartial, values); [EOL] assertEquals(29, result); [EOL] }
public void testGetMaximumValue_WithoutMonthOfYear() { [EOL] ReadablePartial mockPartial = Mockito.mock(ReadablePartial.class); [EOL] int[] values = new int[] {}; // Assuming no values [EOL] Mockito.when(mockPartial.size()).thenReturn(0); [EOL] Mockito.when(iChronology.getMaximumValue()).thenReturn(24); [EOL] int result = getMaximumValue(mockPartial, values); [EOL] assertEquals(24, result); [EOL] }
public void testAppendPaddedInteger_NegativeValueNotMinInt() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] appendPaddedInteger(buf, -1, 3); [EOL] assertEquals("-001", buf.toString()); [EOL] }
public void testAppendPaddedInteger_NegativeMinInt() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] appendPaddedInteger(buf, Integer.MIN_VALUE, 12); [EOL] assertEquals("-0002147483648", buf.toString()); [EOL] }
public void testAppendPaddedInteger_SingleDigitPositive() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] appendPaddedInteger(buf, 5, 2); [EOL] assertEquals("05", buf.toString()); [EOL] }
public void testAppendPaddedInteger_TwoDigitsPositive() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] appendPaddedInteger(buf, 50, 3); [EOL] assertEquals("050", buf.toString()); [EOL] }
public void testAppendPaddedInteger_ThreeDigitsPositive() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] appendPaddedInteger(buf, 123, 3); [EOL] assertEquals("123", buf.toString()); [EOL] }
public void testAppendPaddedInteger_FourDigitsPositive() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] appendPaddedInteger(buf, 1234, 4); [EOL] assertEquals("1234", buf.toString()); [EOL] }
public void testAppendPaddedInteger_MultipleDigitsPositive() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] appendPaddedInteger(buf, 12345, 5); [EOL] assertEquals("12345", buf.toString()); [EOL] }
public void testCalculateFirstDayOfYearMillis_ForYearLessThanOrEqualTo1968() { [EOL] long millis = calculateFirstDayOfYearMillis(1968); [EOL] assertEquals(-366L * DateTimeConstants.MILLIS_PER_DAY, millis); [EOL] }
public void testCalculateFirstDayOfYearMillis_ForNonLeapYearGreaterThan1968() { [EOL] long millis = calculateFirstDayOfYearMillis(1971); [EOL] assertEquals((3 * 365L + 1) * DateTimeConstants.MILLIS_PER_DAY - (366L + 352) * DateTimeConstants.MILLIS_PER_DAY, millis); [EOL] }
public void testCalculateFirstDayOfYearMillis_ForLeapYearGreaterThan1968() { [EOL] long millis = calculateFirstDayOfYearMillis(1972); [EOL] assertEquals((4 * 365L + 1) * DateTimeConstants.MILLIS_PER_DAY - (366L + 352) * DateTimeConstants.MILLIS_PER_DAY, millis); [EOL] }
public void testGetChronologyWithNullChrono() { [EOL] ReadableInstant mockInstant = mock(ReadableInstant.class); [EOL] Chronology expectedChrono = ISOChronology.getInstance(); [EOL] when(mockInstant.getChronology()).thenReturn(expectedChrono); [EOL] Chronology result = getChronology(mockInstant, null); [EOL] assertNotNull(result); [EOL] assertEquals(expectedChrono, result); [EOL] }
public void testGetChronologyWithNonNullChrono() { [EOL] Chronology inputChrono = ISOChronology.getInstance(); [EOL] ReadableInstant mockInstant = mock(ReadableInstant.class); [EOL] Chronology result = getChronology(mockInstant, inputChrono); [EOL] assertNotNull(result); [EOL] assertEquals(inputChrono, result); [EOL] }
public static BuddhistChronology getInstance() { [EOL] return getInstance(DateTimeZone.getDefault()); [EOL] }
public void testGetInstanceWithNullZone() { [EOL] BuddhistChronology result = BuddhistChronology.getInstance(null); [EOL] assertNotNull(result); [EOL] assertEquals(DateTimeZone.getDefault(), result.getZone()); [EOL] }
public void testGetInstanceWithSpecificZone() { [EOL] DateTimeZone specificZone = DateTimeZone.forID("Asia/Tokyo"); [EOL] BuddhistChronology result = BuddhistChronology.getInstance(specificZone); [EOL] assertNotNull(result); [EOL] assertEquals(specificZone, result.getZone()); [EOL] }
public int getMinimumValueOverall() { [EOL] return getField().getMinimumValue(); [EOL] }
public int getMaximumValueOverall() { [EOL] return getField().getMaximumValue(); [EOL] }
public int testGetMaximumValueWithValidPartial() { [EOL] ReadablePartial mockPartial = Mockito.mock(ReadablePartial.class); [EOL] DateTimeField mockField = Mockito.mock(DateTimeField.class); [EOL] when(mockField.getMaximumValue(mockPartial)).thenReturn(10); [EOL] when(instance.getField()).thenReturn(mockField); [EOL] int result = instance.getMaximumValue(); [EOL] assertEquals(10, result); [EOL] }

public void testEquals_SameObject() { [EOL] AbstractPartialFieldProperty property = new ConcreteAbstractPartialFieldProperty(); [EOL] assertTrue(property.equals(property)); [EOL] }
public void testEquals_DifferentType() { [EOL] AbstractPartialFieldProperty property = new ConcreteAbstractPartialFieldProperty(); [EOL] assertFalse(property.equals(new Object())); [EOL] }
public void testEquals_Null() { [EOL] AbstractPartialFieldProperty property = new ConcreteAbstractPartialFieldProperty(); [EOL] assertFalse(property.equals(null)); [EOL] }
public void testEquals_DifferentValues() { [EOL] AbstractPartialFieldProperty property1 = new ConcreteAbstractPartialFieldProperty(1, MockFieldType.instance, MockChronology.instance); [EOL] AbstractPartialFieldProperty property2 = new ConcreteAbstractPartialFieldProperty(2, MockFieldType.instance, MockChronology.instance); [EOL] assertFalse(property1.equals(property2)); [EOL] }
public void testEquals_DifferentFieldTypes() { [EOL] AbstractPartialFieldProperty property1 = new ConcreteAbstractPartialFieldProperty(1, MockFieldType.instance, MockChronology.instance); [EOL] AbstractPartialFieldProperty property2 = new ConcreteAbstractPartialFieldProperty(1, MockFieldType.otherInstance, MockChronology.instance); [EOL] assertFalse(property1.equals(property2)); [EOL] }
public void testEquals_DifferentChronologies() { [EOL] AbstractPartialFieldProperty property1 = new ConcreteAbstractPartialFieldProperty(1, MockFieldType.instance, MockChronology.instance); [EOL] AbstractPartialFieldProperty property2 = new ConcreteAbstractPartialFieldProperty(1, MockFieldType.instance, MockChronology.otherInstance); [EOL] assertFalse(property1.equals(property2)); [EOL] }
public void testEquals_EqualProperties() { [EOL] AbstractPartialFieldProperty property1 = new ConcreteAbstractPartialFieldProperty(1, MockFieldType.instance, MockChronology.instance); [EOL] AbstractPartialFieldProperty property2 = new ConcreteAbstractPartialFieldProperty(1, MockFieldType.instance, MockChronology.instance); [EOL] assertTrue(property1.equals(property2)); [EOL] }
public void testHashCode_WithDifferentGetValues() { [EOL] Time time1 = new Time(1); [EOL] Time time2 = new Time(2); [EOL] assertNotEquals(time1.hashCode(), time2.hashCode()); [EOL] } [EOL] public void testHashCode_WithDifferentFieldTypes() { [EOL] Time time1 = new Time(1, FieldType.SECONDS); [EOL] Time time2 = new Time(1, FieldType.MINUTES); [EOL] assertNotEquals(time1.hashCode(), time2.hashCode()); [EOL] } [EOL] public void testHashCode_WithDifferentChronologies() { [EOL] Time time1 = new Time(1, FieldType.SECONDS, ISOChronology.getInstanceUTC()); [EOL] Time time2 = new Time(1, FieldType.SECONDS, GregorianChronology.getInstanceUTC()); [EOL] assertNotEquals(time1.hashCode(), time2.hashCode()); [EOL] } [EOL] public void testHashCode_WithSameValues() { [EOL] Time time1 = new Time(1, FieldType.SECONDS, ISOChronology.getInstanceUTC()); [EOL] Time time2 = new Time(1, FieldType.SECONDS, ISOChronology.getInstanceUTC()); [EOL] assertEquals(time1.hashCode(), time2.hashCode()); [EOL] }
public void testEquals_Reflexive() { [EOL] PreciseDurationField durationField = new PreciseDurationField(someType, someUnitMillis); [EOL] assertTrue(durationField.equals(durationField)); [EOL] }
public void testEquals_Null() { [EOL] PreciseDurationField durationField = new PreciseDurationField(someType, someUnitMillis); [EOL] assertFalse(durationField.equals(null)); [EOL] }
public void testEquals_DifferentClass() { [EOL] PreciseDurationField durationField = new PreciseDurationField(someType, someUnitMillis); [EOL] Object other = new Object(); [EOL] assertFalse(durationField.equals(other)); [EOL] }
public void testEquals_Equivalent() { [EOL] PreciseDurationField durationField1 = new PreciseDurationField(someType, someUnitMillis); [EOL] PreciseDurationField durationField2 = new PreciseDurationField(someType, someUnitMillis); [EOL] assertTrue(durationField1.equals(durationField2)); [EOL] }
public void testEquals_DifferentType() { [EOL] PreciseDurationField durationField1 = new PreciseDurationField(someType, someUnitMillis); [EOL] PreciseDurationField durationField2 = new PreciseDurationField(differentType, someUnitMillis); [EOL] assertFalse(durationField1.equals(durationField2)); [EOL] }
public void testEquals_DifferentUnitMillis() { [EOL] PreciseDurationField durationField1 = new PreciseDurationField(someType, someUnitMillis); [EOL] PreciseDurationField durationField2 = new PreciseDurationField(someType, differentUnitMillis); [EOL] assertFalse(durationField1.equals(durationField2)); [EOL] }
public void testAddWithZeroMonths() { [EOL] long instant = SOME_INSTANT; // Replace with an actual instant value [EOL] int months = 0; [EOL] long expected = instant; [EOL] long result = add(instant, months); [EOL] assertEquals(expected, result); [EOL] }
public void testAddWithPositiveMonthsNotExceedingYear() { [EOL] long instant = SOME_INSTANT; // Replace with an actual instant value [EOL] int months = 5; // Assuming iMax is greater than 5 [EOL] long expected = SOME_EXPECTED_RESULT; // Replace with the expected result [EOL] long result = add(instant, months); [EOL] assertEquals(expected, result); [EOL] }
public void testAddWithPositiveMonthsExceedingYear() { [EOL] long instant = SOME_INSTANT; // Replace with an actual instant value [EOL] int months = 13; // Assuming iMax is 12 [EOL] long expected = SOME_EXPECTED_RESULT; // Replace with the expected result [EOL] long result = add(instant, months); [EOL] assertEquals(expected, result); [EOL] }
public void testAddWithNegativeMonthsNotExceedingYear() { [EOL] long instant = SOME_INSTANT; // Replace with an actual instant value [EOL] int months = -5; // Assuming iMax is greater than 5 and thisMonth is at least 6 [EOL] long expected = SOME_EXPECTED_RESULT; // Replace with the expected result [EOL] long result = add(instant, months); [EOL] assertEquals(expected, result); [EOL] }
public void testAddWithNegativeMonthsExceedingYear() { [EOL] long instant = SOME_INSTANT; // Replace with an actual instant value [EOL] int months = -13; // Assuming iMax is 12 [EOL] long expected = SOME_EXPECTED_RESULT; // Replace with the expected result [EOL] long result = add(instant, months); [EOL] assertEquals(expected, result); [EOL] }
public void testAddWithDayOfMonthGreaterThanMaxDay() { [EOL] long instant = SOME_INSTANT; // Replace with an actual instant value [EOL] int months = 1; // Assuming this will lead to a month with fewer days than the day of `instant` [EOL] long expected = SOME_EXPECTED_RESULT; // Replace with the expected result [EOL] long result = add(instant, months); [EOL] assertEquals(expected, result); [EOL] }
public void testAdd_ValueToAddIsZero() { [EOL] ReadablePartial mockPartial = createMockPartial(); [EOL] int fieldIndex = 1; [EOL] int[] values = new int[] {1, 2, 3}; [EOL] int valueToAdd = 0; [EOL] int[] result = add(mockPartial, fieldIndex, values, valueToAdd); [EOL] assertArrayEquals(values, result); [EOL] }
public void testAdd_WithMonthOfYearField() { [EOL] ReadablePartial mockPartial = createMockPartialWithMonthOfYear(); [EOL] int fieldIndex = 0; [EOL] int[] values = new int[] {6, 15}; // Assuming June 15th [EOL] int valueToAdd = 2; // Add 2 months [EOL] int[] result = add(mockPartial, fieldIndex, values, valueToAdd); [EOL] int[] expected = new int[] {8, 15}; // Expecting August 15th [EOL] assertArrayEquals(expected, result); [EOL] }
public void testAdd_WithContiguousPartial() { [EOL] ReadablePartial mockPartial = createMockContiguousPartial(); [EOL] int fieldIndex = 1; [EOL] int[] values = new int[] {1, 2, 3}; [EOL] int valueToAdd = 1; [EOL] int[] result = add(mockPartial, fieldIndex, values, valueToAdd); [EOL] int[] expected = calculateExpectedResultForContiguousPartial(values, valueToAdd); [EOL] assertArrayEquals(expected, result); [EOL] }
public void testAdd_WithNonContiguousPartial() { [EOL] ReadablePartial mockPartial = createMockNonContiguousPartial(); [EOL] int fieldIndex = 1; [EOL] int[] values = new int[] {1, 2, 3}; [EOL] int valueToAdd = 1; [EOL] int[] result = add(mockPartial, fieldIndex, values, valueToAdd); [EOL] int[] expected = super.add(mockPartial, fieldIndex, values, valueToAdd); [EOL] assertArrayEquals(expected, result); [EOL] }
public void testSetWithValidMonth() { [EOL] long instant = /* some valid instant */; [EOL] int month = /* a valid month within MIN and iMax bounds */; [EOL] long expected = /* expected millis value */; [EOL] long result = set(instant, month); [EOL] assertEquals(expected, result); [EOL] } [EOL] public void testSetWithMonthBelowMinimum() { [EOL] long instant = /* some valid instant */; [EOL] int month = /* a value less than MIN */; [EOL] try { [EOL] set(instant, month); [EOL] fail("Should have thrown an IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] } [EOL] public void testSetWithMonthAboveMaximum() { [EOL] long instant = /* some valid instant */; [EOL] int month = /* a value greater than iMax */; [EOL] try { [EOL] set(instant, month); [EOL] fail("Should have thrown an IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] } [EOL] public void testSetWithLastDayOfMonth() { [EOL] long instant = /* some valid instant */; [EOL] int month = /* a valid month within MIN and iMax bounds */; [EOL] int thisYear = /* extract year from instant */; [EOL] int maxDom = /* get maximum day of month for thisYear and month */; [EOL] long expected = /* expected millis value for the last day of the month */; [EOL] long result = set(instant, month); [EOL] assertEquals(expected, result); [EOL] } [EOL] public void testSetWithDayOfMonthGreaterThanMax() { [EOL] long instant = /* some valid instant */; [EOL] int month = /* a valid month within MIN and iMax bounds */; [EOL] int thisYear = /* extract year from instant */; [EOL] int thisDom = /* set to a value greater than maxDom for thisYear and month */; [EOL] long expected = /* expected millis value with thisDom set to maxDom */; [EOL] long result = set(instant, month); [EOL] assertEquals(expected, result); [EOL] }
public void testIsLeap_LeapYearAndLeapMonth() { [EOL] long instant = // some instant that falls in a leap year and leap month [EOL] boolean result = isLeap(instant); [EOL] assert result == true; [EOL] } [EOL] public void testIsLeap_LeapYearButNotLeapMonth() { [EOL] long instant = // some instant that falls in a leap year but not in the leap month [EOL] boolean result = isLeap(instant); [EOL] assert result == false; [EOL] } [EOL] public void testIsLeap_NotLeapYear() { [EOL] long instant = // some instant that does not fall in a leap year [EOL] boolean result = isLeap(instant); [EOL] assert result == false; [EOL] }
public int getLeapAmount(long instant) { [EOL] return isLeap(instant) ? 1 : 0; [EOL] }
public int getMinimumValue() { [EOL] return MIN; [EOL] }
public void testGetMaximumValue() { [EOL] Time time = new Time(); [EOL] int expected = // set the expected value based on the context or preconditions [EOL] int actual = time.getMaximumValue(); [EOL] assertEquals(expected, actual); [EOL] }
public void testGetMaximumValue_WithYearField() { [EOL] ReadablePartial mockPartial = mock(ReadablePartial.class); [EOL] when(mockPartial.size()).thenReturn(1); [EOL] when(mockPartial.getFieldType(0)).thenReturn(DateTimeFieldType.year()); [EOL] int[] values = {2023}; [EOL] int expectedDaysInYear = iChronology.getDaysInYear(2023); [EOL] int actualDays = getMaximumValue(mockPartial, values); [EOL] assertEquals(expectedDaysInYear, actualDays); [EOL] }
public void testGetMaximumValue_WithoutYearField() { [EOL] ReadablePartial mockPartial = mock(ReadablePartial.class); [EOL] when(mockPartial.size()).thenReturn(1); [EOL] when(mockPartial.getFieldType(0)).thenReturn(DateTimeFieldType.dayOfMonth()); [EOL] int[] values = {1}; [EOL] int expectedDaysInYearMax = iChronology.getDaysInYearMax(); [EOL] int actualDays = getMaximumValue(mockPartial, values); [EOL] assertEquals(expectedDaysInYearMax, actualDays); [EOL] }
public void testGetMaximumValue_MultipleFieldsIncludingYear() { [EOL] ReadablePartial mockPartial = mock(ReadablePartial.class); [EOL] when(mockPartial.size()).thenReturn(2); [EOL] when(mockPartial.getFieldType(0)).thenReturn(DateTimeFieldType.monthOfYear()); [EOL] when(mockPartial.getFieldType(1)).thenReturn(DateTimeFieldType.year()); [EOL] int[] values = {1, 2023}; [EOL] int expectedDaysInYear = iChronology.getDaysInYear(2023); [EOL] int actualDays = getMaximumValue(mockPartial, values); [EOL] assertEquals(expectedDaysInYear, actualDays); [EOL] }
public void testSafeSubtractNoOverflow() { [EOL] long val1 = 50; [EOL] long val2 = 30; [EOL] long result = Time.safeSubtract(val1, val2); [EOL] assertEquals(20, result); [EOL] }
public void testSafeSubtractOverflow() { [EOL] long val1 = Long.MAX_VALUE; [EOL] long val2 = -1; [EOL] try { [EOL] Time.safeSubtract(val1, val2); [EOL] fail("Should have thrown ArithmeticException due to overflow"); [EOL] } catch (ArithmeticException e) { [EOL] assertEquals("The calculation caused an overflow: " + val1 + " - " + val2, e.getMessage()); [EOL] } [EOL] }
public void testSafeSubtractUnderflow() { [EOL] long val1 = Long.MIN_VALUE; [EOL] long val2 = 1; [EOL] try { [EOL] Time.safeSubtract(val1, val2); [EOL] fail("Should have thrown ArithmeticException due to underflow"); [EOL] } catch (ArithmeticException e) { [EOL] assertEquals("The calculation caused an overflow: " + val1 + " - " + val2, e.getMessage()); [EOL] } [EOL] }
public void testVerifyValueBoundsWithinLimits() { [EOL] DateTimeFieldType mockFieldType = mock(DateTimeFieldType.class); [EOL] DateTimeField mockField = mock(DateTimeField.class); [EOL] when(mockField.getType()).thenReturn(mockFieldType); [EOL] int value = 5; [EOL] int lowerBound = 1; [EOL] int upperBound = 10; [EOL] verifyValueBounds(mockField, value, lowerBound, upperBound); [EOL] }
public void testVerifyValueBoundsBelowLowerLimit() { [EOL] DateTimeFieldType mockFieldType = mock(DateTimeFieldType.class); [EOL] DateTimeField mockField = mock(DateTimeField.class); [EOL] when(mockField.getType()).thenReturn(mockFieldType); [EOL] int value = 0; [EOL] int lowerBound = 1; [EOL] int upperBound = 10; [EOL] try { [EOL] verifyValueBounds(mockField, value, lowerBound, upperBound); [EOL] fail("Should have thrown IllegalFieldValueException"); [EOL] } catch (IllegalFieldValueException e) { [EOL] } [EOL] }
public void testVerifyValueBoundsAboveUpperLimit() { [EOL] DateTimeFieldType mockFieldType = mock(DateTimeFieldType.class); [EOL] DateTimeField mockField = mock(DateTimeField.class); [EOL] when(mockField.getType()).thenReturn(mockFieldType); [EOL] int value = 11; [EOL] int lowerBound = 1; [EOL] int upperBound = 10; [EOL] try { [EOL] verifyValueBounds(mockField, value, lowerBound, upperBound); [EOL] fail("Should have thrown IllegalFieldValueException"); [EOL] } catch (IllegalFieldValueException e) { [EOL] } [EOL] }
public void testVerifyValueBoundsWithinLimits() { [EOL] DateTimeFieldType fieldType = DateTimeFieldType.dayOfMonth(); [EOL] int value = 10; [EOL] int lowerBound = 1; [EOL] int upperBound = 30; [EOL] Time.verifyValueBounds(fieldType, value, lowerBound, upperBound); [EOL] }
public void testVerifyValueBoundsBelowLowerLimit() { [EOL] DateTimeFieldType fieldType = DateTimeFieldType.dayOfMonth(); [EOL] int value = 0; [EOL] int lowerBound = 1; [EOL] int upperBound = 30; [EOL] try { [EOL] Time.verifyValueBounds(fieldType, value, lowerBound, upperBound); [EOL] fail("Should have thrown IllegalFieldValueException"); [EOL] } catch (IllegalFieldValueException e) { [EOL] } [EOL] }
public void testVerifyValueBoundsAboveUpperLimit() { [EOL] DateTimeFieldType fieldType = DateTimeFieldType.dayOfMonth(); [EOL] int value = 31; [EOL] int lowerBound = 1; [EOL] int upperBound = 30; [EOL] try { [EOL] Time.verifyValueBounds(fieldType, value, lowerBound, upperBound); [EOL] fail("Should have thrown IllegalFieldValueException"); [EOL] } catch (IllegalFieldValueException e) { [EOL] } [EOL] }
public void testVerifyValueBoundsWithinLimits() { [EOL] verifyValueBounds("testField", 5, 1, 10); [EOL] }
public void testVerifyValueBoundsBelowLowerBound() { [EOL] try { [EOL] verifyValueBounds("testField", 0, 1, 10); [EOL] fail("Expected an IllegalFieldValueException to be thrown"); [EOL] } catch (IllegalFieldValueException e) { [EOL] assertEquals("testField", e.getFieldName()); [EOL] assertEquals(Integer.valueOf(0), e.getIllegalValue()); [EOL] assertEquals(Integer.valueOf(1), e.getLowerBound()); [EOL] assertEquals(Integer.valueOf(10), e.getUpperBound()); [EOL] } [EOL] }
public void testVerifyValueBoundsAboveUpperBound() { [EOL] try { [EOL] verifyValueBounds("testField", 11, 1, 10); [EOL] fail("Expected an IllegalFieldValueException to be thrown"); [EOL] } catch (IllegalFieldValueException e) { [EOL] assertEquals("testField", e.getFieldName()); [EOL] assertEquals(Integer.valueOf(11), e.getIllegalValue()); [EOL] assertEquals(Integer.valueOf(1), e.getLowerBound()); [EOL] assertEquals(Integer.valueOf(10), e.getUpperBound()); [EOL] } [EOL] }
public void testGetWrappedValue_MinGreaterThanMax_ThrowsException() { [EOL] int value = 5; [EOL] int minValue = 10; [EOL] int maxValue = 5; [EOL] try { [EOL] Time.getWrappedValue(value, minValue, maxValue); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("MIN > MAX", e.getMessage()); [EOL] } [EOL] }
public void testGetWrappedValue_ValueWithinRange_ReturnsSameValue() { [EOL] int value = 5; [EOL] int minValue = 0; [EOL] int maxValue = 10; [EOL] int result = Time.getWrappedValue(value, minValue, maxValue); [EOL] assertEquals(5, result); [EOL] }
public void testGetWrappedValue_ValueBelowRange_ReturnsWrappedValue() { [EOL] int value = -3; [EOL] int minValue = 0; [EOL] int maxValue = 10; [EOL] int result = Time.getWrappedValue(value, minValue, maxValue); [EOL] assertEquals(8, result); [EOL] }
public void testGetWrappedValue_ValueAboveRange_ReturnsWrappedValue() { [EOL] int value = 12; [EOL] int minValue = 0; [EOL] int maxValue = 10; [EOL] int result = Time.getWrappedValue(value, minValue, maxValue); [EOL] assertEquals(2, result); [EOL] }
public void testGetWrappedValue_ValueExactlyAtMaxBoundary_ReturnsMinValue() { [EOL] int value = 10; [EOL] int minValue = 0; [EOL] int maxValue = 10; [EOL] int result = Time.getWrappedValue(value, minValue, maxValue); [EOL] assertEquals(0, result); [EOL] }
public void testGetWrappedValue_ValueExactlyAtMinBoundary_ReturnsMinValue() { [EOL] int value = 0; [EOL] int minValue = 0; [EOL] int maxValue = 10; [EOL] int result = Time.getWrappedValue(value, minValue, maxValue); [EOL] assertEquals(0, result); [EOL] }
public void testGetWrappedField() { [EOL] DateTimeField expectedField = new MockDateTimeField(); [EOL] YourClassUnderTest instance = new YourClassUnderTest(expectedField); [EOL] DateTimeField actualField = instance.getWrappedField(); [EOL] assertEquals("The getWrappedField method should return the correct DateTimeField instance", [EOL] expectedField, actualField); [EOL] }
public int get(long instant) { [EOL] return iField.get(instant); [EOL] }
public void testRemoveInstantConverter_NullConverter() { [EOL] InstantConverter result = timeObject.removeInstantConverter(null); [EOL] assertNull("Expected null when removing null converter", result); [EOL] }
public void testRemoveInstantConverter_ValidConverter() { [EOL] InstantConverter mockConverter = createMockConverter(); [EOL] timeObject.addInstantConverter(mockConverter); [EOL] InstantConverter result = timeObject.removeInstantConverter(mockConverter); [EOL] assertEquals("Expected the removed converter to be returned", mockConverter, result); [EOL] }
public void testRemoveInstantConverter_NonExistentConverter() { [EOL] InstantConverter mockConverter = createMockConverter(); [EOL] InstantConverter result = timeObject.removeInstantConverter(mockConverter); [EOL] assertNull("Expected null when removing a non-existent converter", result); [EOL] }
public void testRemoveInstantConverter_SecurityException() { [EOL] InstantConverter mockConverter = createMockConverter(); [EOL] timeObject.addInstantConverter(mockConverter); [EOL] System.setSecurityManager(new SecurityManager() { [EOL] @Override [EOL] public void checkPermission(Permission perm) { [EOL] if (perm.getName().equals("alterInstantConverters")) { [EOL] throw new SecurityException("Test Security Exception"); [EOL] } [EOL] } [EOL] }); [EOL] try { [EOL] timeObject.removeInstantConverter(mockConverter); [EOL] fail("Expected SecurityException to be thrown"); [EOL] } catch (SecurityException e) { [EOL] } finally { [EOL] System.setSecurityManager(null); // Reset security manager [EOL] } [EOL] }
public void testGetPartialConverterWithNull() { [EOL] try { [EOL] getPartialConverter(null); [EOL] fail("Should have thrown IllegalArgumentException for null input"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("No partial converter found for type: null", e.getMessage()); [EOL] } [EOL] }
public void testGetPartialConverterWithValidObject() { [EOL] Object validObject = new Object() { [EOL] }; [EOL] iPartialConverters.put(validObject.getClass(), new PartialConverter() { [EOL] }); [EOL] PartialConverter result = getPartialConverter(validObject); [EOL] assertNotNull("Expected a non-null PartialConverter", result); [EOL] }
public void testGetPartialConverterWithInvalidObject() { [EOL] Object invalidObject = new Object(); [EOL] try { [EOL] getPartialConverter(invalidObject); [EOL] fail("Should have thrown IllegalArgumentException for invalid input"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("No partial converter found for type: " + invalidObject.getClass().getName(), e.getMessage()); [EOL] } [EOL] }
public void testAddPartialConverter_WithNullConverter() { [EOL] PartialConverter result = time.addPartialConverter(null); [EOL] assertNull("Expected null when adding null converter", result); [EOL] } [EOL] public void testAddPartialConverter_WithNonNullConverter() throws SecurityException { [EOL] PartialConverter mockConverter = createMockPartialConverter(); [EOL] PartialConverter result = time.addPartialConverter(mockConverter); [EOL] assertNotNull("Expected non-null when adding non-null converter", result); [EOL] } [EOL] public void testAddPartialConverter_ThrowsSecurityException() { [EOL] PartialConverter mockConverter = createMockPartialConverter(); [EOL] doThrow(new SecurityException()).when(time).checkAlterPartialConverters(); [EOL] try { [EOL] time.addPartialConverter(mockConverter); [EOL] fail("Expected SecurityException to be thrown"); [EOL] } catch (SecurityException e) { [EOL] } [EOL] }
public void testGetDurationConverters_ReturnsNonEmptyArray() { [EOL] DurationConverter[] converters = instance.getDurationConverters(); [EOL] assertNotNull("Converters array should not be null", converters); [EOL] assertTrue("Converters array should not be empty", converters.length > 0); [EOL] }
public void testGetDurationConverters_ReturnsCorrectSizeArray() { [EOL] instance.addConverter(someConverter); [EOL] DurationConverter[] converters = instance.getDurationConverters(); [EOL] assertEquals("Converters array size should match the number of added converters", 1, converters.length); [EOL] }
public void testAddDurationConverter_WithNullConverter() { [EOL] DurationConverter testConverter = null; [EOL] DurationConverter result = addDurationConverter(testConverter); [EOL] assertNull(result); [EOL] }
public void testAddDurationConverter_WithNonNullConverter() throws SecurityException { [EOL] DurationConverter testConverter = new MockDurationConverter(); [EOL] DurationConverter[] originalConverters = iDurationConverters; [EOL] DurationConverter result = addDurationConverter(testConverter); [EOL] assertNotNull(iDurationConverters); [EOL] assertNotSame(originalConverters, iDurationConverters); [EOL] assertTrue(Arrays.asList(iDurationConverters).contains(testConverter)); [EOL] assertEquals(testConverter, iDurationConverters[iDurationConverters.length - 1]); [EOL] }
public void testAddDurationConverter_ThrowsSecurityException() { [EOL] DurationConverter testConverter = new MockDurationConverter(); [EOL] System.setSecurityManager(new SecurityManager() { [EOL] @Override [EOL] public void checkPermission(Permission perm) { [EOL] if ("alterDurationConverters".equals(perm.getName())) { [EOL] throw new SecurityException(); [EOL] } [EOL] } [EOL] }); [EOL] try { [EOL] addDurationConverter(testConverter); [EOL] fail("Should have thrown SecurityException"); [EOL] } catch (SecurityException e) { [EOL] } finally { [EOL] System.setSecurityManager(null); // Reset security manager [EOL] } [EOL] }
public void testCheckAlterDurationConverters_WithSecurityManager() throws SecurityException { [EOL] System.setSecurityManager(new SecurityManager() { [EOL] @Override [EOL] public void checkPermission(Permission perm) { [EOL] if ("ConverterManager.alterDurationConverters".equals(perm.getName())) { [EOL] throw new SecurityException("Permission denied."); [EOL] } [EOL] } [EOL] }); [EOL] try { [EOL] checkAlterDurationConverters(); [EOL] fail("Should have thrown SecurityException."); [EOL] } catch (SecurityException e) { [EOL] } finally { [EOL] System.setSecurityManager(null); // Reset security manager [EOL] } [EOL] }
public void testCheckAlterDurationConverters_WithoutSecurityManager() throws SecurityException { [EOL] System.setSecurityManager(null); [EOL] checkAlterDurationConverters(); // Should not throw any exception [EOL] }
public void testRemovePeriodConverter_WithNullConverter() { [EOL] PeriodConverter result = periodConverter.removePeriodConverter(null); [EOL] assertNull("Expected null when removing null converter", result); [EOL] }
public void testRemovePeriodConverter_WithNonNullConverter_NotFound() { [EOL] PeriodConverter mockConverter = createMockConverter(); [EOL] PeriodConverter result = periodConverter.removePeriodConverter(mockConverter); [EOL] assertNull("Expected null when removing a converter that is not found", result); [EOL] }
public void testRemovePeriodConverter_WithNonNullConverter_Found() { [EOL] PeriodConverter mockConverter = createMockConverter(); [EOL] addConverterToPeriodConverters(mockConverter); [EOL] PeriodConverter result = periodConverter.removePeriodConverter(mockConverter); [EOL] assertNotNull("Expected non-null when removing a converter that is found", result); [EOL] assertEquals("Expected the removed converter to be the one we added", mockConverter, result); [EOL] }
public void testGetIntervalConverters_WithNonEmptyConverterSet() { [EOL] IntervalConverter mockConverter1 = mock(IntervalConverter.class); [EOL] IntervalConverter mockConverter2 = mock(IntervalConverter.class); [EOL] ConverterSet mockSet = mock(ConverterSet.class); [EOL] when(mockSet.size()).thenReturn(2); [EOL] when(mockSet.copyInto(any(IntervalConverter[].class))).thenAnswer(invocation -> { [EOL] Object[] args = invocation.getArguments(); [EOL] IntervalConverter[] targetArray = (IntervalConverter[]) args[0]; [EOL] targetArray[0] = mockConverter1; [EOL] targetArray[1] = mockConverter2; [EOL] return null; [EOL] }); [EOL] MyClassUnderTest instance = new MyClassUnderTest(); [EOL] instance.iIntervalConverters = mockSet; [EOL] IntervalConverter[] result = instance.getIntervalConverters(); [EOL] assertNotNull(result); [EOL] assertEquals(2, result.length); [EOL] assertSame(mockConverter1, result[0]); [EOL] assertSame(mockConverter2, result[1]); [EOL] }
public void testGetIntervalConverters_WithEmptyConverterSet() { [EOL] ConverterSet mockSet = mock(ConverterSet.class); [EOL] when(mockSet.size()).thenReturn(0); [EOL] MyClassUnderTest instance = new MyClassUnderTest(); [EOL] instance.iIntervalConverters = mockSet; [EOL] IntervalConverter[] result = instance.getIntervalConverters(); [EOL] assertNotNull(result); [EOL] assertEquals(0, result.length); [EOL] }
public void testRemoveIntervalConverter_NullConverter() { [EOL] IntervalConverter result = removeIntervalConverter(null); [EOL] assertNull(result); [EOL] }
public void testRemoveIntervalConverter_ValidConverter() throws SecurityException { [EOL] IntervalConverter mockConverter = createMockConverter(); [EOL] addIntervalConverter(mockConverter); [EOL] IntervalConverter result = removeIntervalConverter(mockConverter); [EOL] assertNotNull(result); [EOL] assertEquals(mockConverter, result); [EOL] }
public void testRemoveIntervalConverter_NonExistentConverter() throws SecurityException { [EOL] IntervalConverter mockConverter = createMockConverter(); [EOL] IntervalConverter result = removeIntervalConverter(mockConverter); [EOL] assertNull(result); [EOL] } [EOL] private IntervalConverter createMockConverter() { [EOL] return new IntervalConverter() { [EOL] }; [EOL] } [EOL] private void addIntervalConverter(IntervalConverter converter) { [EOL] } [EOL] private void checkAlterIntervalConverters() throws SecurityException { [EOL] }
public void testCheckAlterIntervalConverters_WithNoSecurityManager() { [EOL] System.setSecurityManager(null); [EOL] try { [EOL] checkAlterIntervalConverters(); [EOL] } finally { [EOL] System.setSecurityManager(null); // Reset security manager [EOL] } [EOL] }
public void testCheckAlterIntervalConverters_WithSecurityManager() throws SecurityException { [EOL] SecurityManager originalSecurityManager = System.getSecurityManager(); [EOL] try { [EOL] SecurityManager sm = new SecurityManager() { [EOL] @Override [EOL] public void checkPermission(Permission perm) { [EOL] if (perm instanceof JodaTimePermission) { [EOL] if ("ConverterManager.alterIntervalConverters".equals(perm.getName())) { [EOL] return; // Permission is granted [EOL] } [EOL] } [EOL] super.checkPermission(perm); [EOL] } [EOL] }; [EOL] System.setSecurityManager(sm); [EOL] checkAlterIntervalConverters(); [EOL] } finally { [EOL] System.setSecurityManager(originalSecurityManager); // Reset security manager [EOL] } [EOL] }
public void testToString() { [EOL] ConverterManager manager = new ConverterManager(); [EOL] manager.iInstantConverters = Collections.emptyList(); [EOL] manager.iPartialConverters = Collections.emptyList(); [EOL] manager.iDurationConverters = Collections.emptyList(); [EOL] manager.iPeriodConverters = Collections.emptyList(); [EOL] manager.iIntervalConverters = Collections.emptyList(); [EOL] String expected = "ConverterManager[0 instant,0 partial,0 duration,0 period,0 interval]"; [EOL] String actual = manager.toString(); [EOL] assertEquals(expected, actual); [EOL] }
public long addWrapFieldTestWithPositiveValue() { [EOL] long instant = 0L; [EOL] int value = 5; [EOL] long expected = iField.addWrapField(instant, value); [EOL] long result = addWrapField(instant, value); [EOL] assert result == expected : "Expected result for positive value did not match"; [EOL] } [EOL] public long addWrapFieldTestWithNegativeValue() { [EOL] long instant = 0L; [EOL] int value = -5; [EOL] long expected = iField.addWrapField(instant, value); [EOL] long result = addWrapField(instant, value); [EOL] assert result == expected : "Expected result for negative value did not match"; [EOL] } [EOL] public long addWrapFieldTestWithZeroValue() { [EOL] long instant = 0L; [EOL] int value = 0; [EOL] long expected = iField.addWrapField(instant, value); [EOL] long result = addWrapField(instant, value); [EOL] assert result == expected : "Expected result for zero value did not match"; [EOL] }
public boolean isLeap(long instant) { [EOL] return iField.isLeap(instant); [EOL] }
public int getLeapAmount(long instant) { [EOL] return iField.getLeapAmount(instant); [EOL] }
public int testGetMinimumValueWithValidInstant() { [EOL] long instant = /* some valid instant value */; [EOL] int expectedValue = /* the expected minimum value for the given instant */; [EOL] int actualValue = getMinimumValue(instant); [EOL] assert actualValue == expectedValue; [EOL] }
public void testGetMinimumValueWithReadablePartialAndValues() { [EOL] ReadablePartial mockPartial = Mockito.mock(ReadablePartial.class); [EOL] int[] values = new int[] {1, 2, 3}; [EOL] DateTimeField mockField = Mockito.mock(DateTimeField.class); [EOL] when(mockField.getMinimumValue(mockPartial, values)).thenReturn(10); [EOL] Time time = new Time(mockField); [EOL] int result = time.getMinimumValue(mockPartial, values); [EOL] assertEquals(10, result); [EOL] }
public void testGetMaximumValueWithInstantAndValues() { [EOL] ReadablePartial mockInstant = mock(ReadablePartial.class); [EOL] int[] values = new int[] {1, 2, 3}; [EOL] DateTimeField mockField = mock(DateTimeField.class); [EOL] when(mockField.getMaximumValue(mockInstant, values)).thenReturn(10); [EOL] TestDateTimeField testField = new TestDateTimeField(mockField); [EOL] int result = testField.getMaximumValue(mockInstant, values); [EOL] assertEquals(10, result); [EOL] }
public void testRoundCeiling() { [EOL] long instant = SOME_INSTANT_VALUE; [EOL] long expected = EXPECTED_CEILING_VALUE; [EOL] long actual = roundCeiling(instant); [EOL] assertEquals(expected, actual); [EOL] }
public void testRoundHalfFloor_PositiveInstant() { [EOL] long instant = 1000L; [EOL] long expected = iField.roundHalfFloor(instant); [EOL] long actual = roundHalfFloor(instant); [EOL] assertEquals(expected, actual); [EOL] }
public void testRoundHalfFloor_NegativeInstant() { [EOL] long instant = -1000L; [EOL] long expected = iField.roundHalfFloor(instant); [EOL] long actual = roundHalfFloor(instant); [EOL] assertEquals(expected, actual); [EOL] }
public void testRoundHalfFloor_ZeroInstant() { [EOL] long instant = 0L; [EOL] long expected = iField.roundHalfFloor(instant); [EOL] long actual = roundHalfFloor(instant); [EOL] assertEquals(expected, actual); [EOL] }
public long roundHalfEven(long instant) { [EOL] return iField.roundHalfEven(instant); [EOL] }
public void testGetInstance() { [EOL] DateTimeComparator result = DateTimeComparator.getInstance(); [EOL] assertNotNull(result); [EOL] assertSame(DateTimeComparator.ALL_INSTANCE, result); [EOL] }
public void testGetInstanceWithNullLowerLimit() { [EOL] DateTimeComparator result = DateTimeComparator.getInstance(null); [EOL] assertNull("Expected null lower limit to result in default comparator", result.getLowerLimit()); [EOL] assertNull("Expected null upper limit to result in default comparator", result.getUpperLimit()); [EOL] }
public void testGetInstanceWithNonNullLowerLimit() { [EOL] DateTimeFieldType lowerLimit = DateTimeFieldType.dayOfMonth(); [EOL] DateTimeComparator result = DateTimeComparator.getInstance(lowerLimit); [EOL] assertEquals("Expected non-null lower limit to be set", lowerLimit, result.getLowerLimit()); [EOL] assertNull("Expected null upper limit to result in default comparator", result.getUpperLimit()); [EOL] }
public void testGetLowerLimit() { [EOL] DateTimeFieldType expectedLowerLimit = DateTimeFieldType.dayOfMonth(); [EOL] DateTimeFieldType actualLowerLimit = new DateTime().getLowerLimit(); [EOL] assertEquals(expectedLowerLimit, actualLowerLimit); [EOL] }
public void testGetUpperLimit() { [EOL] DateTimeFieldType fieldType = new DateTimeFieldType(); [EOL] DateTimeFieldType expected = fieldType.iUpperLimit; // Assuming there's a way to get the expected value [EOL] DateTimeFieldType actual = fieldType.getUpperLimit(); [EOL] assertEquals(expected, actual); [EOL] }
public void testCompareWithEqualMillis() { [EOL] Object lhsObj = createInstantObjectWithMillis(1000L); [EOL] Object rhsObj = createInstantObjectWithMillis(1000L); [EOL] int result = compare(lhsObj, rhsObj); [EOL] assertEquals(0, result); [EOL] } [EOL] public void testCompareWithLhsLessThanRhs() { [EOL] Object lhsObj = createInstantObjectWithMillis(500L); [EOL] Object rhsObj = createInstantObjectWithMillis(1000L); [EOL] int result = compare(lhsObj, rhsObj); [EOL] assertEquals(-1, result); [EOL] } [EOL] public void testCompareWithLhsGreaterThanRhs() { [EOL] Object lhsObj = createInstantObjectWithMillis(1500L); [EOL] Object rhsObj = createInstantObjectWithMillis(1000L); [EOL] int result = compare(lhsObj, rhsObj); [EOL] assertEquals(1, result); [EOL] }
public void testCompareWithLowerLimit() { [EOL] Object lhsObj = createInstantObjectWithMillis(500L); [EOL] Object rhsObj = createInstantObjectWithMillis(1000L); [EOL] setLowerLimitField(200L); // Assuming setLowerLimitField is a method that sets iLowerLimit [EOL] int result = compare(lhsObj, rhsObj); [EOL] assertEquals(-1, result); [EOL] } [EOL] public void testCompareWithUpperLimit() { [EOL] Object lhsObj = createInstantObjectWithMillis(500L); [EOL] Object rhsObj = createInstantObjectWithMillis(1000L); [EOL] setUpperLimitField(200L); // Assuming setUpperLimitField is a method that sets iUpperLimit [EOL] int result = compare(lhsObj, rhsObj); [EOL] assertEquals(-1, result); [EOL] }
public void testToString_BothLimitsNull() { [EOL] DateTimeComparator comparator = new DateTimeComparator(null, null); [EOL] String result = comparator.toString(); [EOL] assertEquals("DateTimeComparator[]", result); [EOL] }
public void testToString_LowerLimitNull() { [EOL] DateTimeComparator comparator = new DateTimeComparator(null, new DateTimeFieldType("upper")); [EOL] String result = comparator.toString(); [EOL] assertEquals("DateTimeComparator[-upper]", result); [EOL] }
public void testToString_UpperLimitNull() { [EOL] DateTimeComparator comparator = new DateTimeComparator(new DateTimeFieldType("lower"), null); [EOL] String result = comparator.toString(); [EOL] assertEquals("DateTimeComparator[lower-]", result); [EOL] }
public void testToString_NeitherLimitNull() { [EOL] DateTimeComparator comparator = new DateTimeComparator(new DateTimeFieldType("lower"), new DateTimeFieldType("upper")); [EOL] String result = comparator.toString(); [EOL] assertEquals("DateTimeComparator[lower-upper]", result); [EOL] }
public void testToString_LimitsEqual() { [EOL] DateTimeFieldType sameField = new DateTimeFieldType("same"); [EOL] DateTimeComparator comparator = new DateTimeComparator(sameField, sameField); [EOL] String result = comparator.toString(); [EOL] assertEquals("DateTimeComparator[same]", result); [EOL] }
public void testGetValueAtIndexZero() { [EOL] Time time = new Time(); [EOL] int expected = time.getValue(); [EOL] int actual = time.getValue(0); [EOL] assertEquals(expected, actual); [EOL] }
public void testGetValueAtNonZeroIndex() { [EOL] Time time = new Time(); [EOL] try { [EOL] time.getValue(1); [EOL] fail("Expected an IndexOutOfBoundsException to be thrown"); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] assertEquals("1", e.getMessage()); [EOL] } [EOL] }
public void testCompareTo_DifferentClass() { [EOL] BaseSingleFieldPeriod period1 = new MockSingleFieldPeriod(10); [EOL] BaseSingleFieldPeriod period2 = new MockAnotherSingleFieldPeriod(10); [EOL] try { [EOL] period1.compareTo(period2); [EOL] fail("Should have thrown ClassCastException"); [EOL] } catch (ClassCastException ex) { [EOL] } [EOL] }
public void testCompareTo_GreaterValue() { [EOL] BaseSingleFieldPeriod period1 = new MockSingleFieldPeriod(10); [EOL] BaseSingleFieldPeriod period2 = new MockSingleFieldPeriod(5); [EOL] int result = period1.compareTo(period2); [EOL] assertEquals(1, result); [EOL] }
public void testCompareTo_LessValue() { [EOL] BaseSingleFieldPeriod period1 = new MockSingleFieldPeriod(5); [EOL] BaseSingleFieldPeriod period2 = new MockSingleFieldPeriod(10); [EOL] int result = period1.compareTo(period2); [EOL] assertEquals(-1, result); [EOL] }
public void testCompareTo_EqualValue() { [EOL] BaseSingleFieldPeriod period1 = new MockSingleFieldPeriod(10); [EOL] BaseSingleFieldPeriod period2 = new MockSingleFieldPeriod(10); [EOL] int result = period1.compareTo(period2); [EOL] assertEquals(0, result); [EOL] }
int getMonthOfYear(long millis, int year) { [EOL] int i = (int) ((millis - getYearMillis(year)) >> 10); [EOL] return (isLeapYear(year)) ? ((i < 182 * 84375) ? ((i < 91 * 84375) ? ((i < 31 * 84375) ? 1 : (i < 60 * 84375) ? 2 : 3) : ((i < 121 * 84375) ? 4 : (i < 152 * 84375) ? 5 : 6)) : ((i < 274 * 84375) ? ((i < 213 * 84375) ? 7 : (i < 244 * 84375) ? 8 : 9) : ((i < 305 * 84375) ? 10 : (i < 335 * 84375) ? 11 : 12))) : ((i < 181 * 84375) ? ((i < 90 * 84375) ? ((i < 31 * 84375) ? 1 : (i < 59 * 84375) ? 2 : 3) : ((i < 120 * 84375) ? 4 : (i < 151 * 84375) ? 5 : 6)) : ((i < 273 * 84375) ? ((i < 212 * 84375) ? 7 : (i < 243 * 84375) ? 8 : 9) : ((i < 304 * 84375) ? 10 : (i < 334 * 84375) ? 11 : 12))); [EOL] } [EOL] BasicGJChronology(Chronology base, Object param, int minDaysInFirstWeek); [EOL] int getMonthOfYear(long millis, int year); [EOL] int getDaysInYearMonth(int year, int month); [EOL] int getDaysInMonthMax(int month); [EOL] int getDaysInMonthMaxForSet(long instant, int value); [EOL] long getTotalMillisByYearMonth(int year, int month); [EOL] long getYearDifference(long minuendInstant, long subtrahendInstant); [EOL] long setYear(long instant, int year); [EOL] long serialVersionUID=538276888268L; [EOL] int[] MIN_DAYS_PER_MONTH_ARRAY={ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }; [EOL] int[] MAX_DAYS_PER_MONTH_ARRAY={ 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };
public void testGetDaysInMonthMax_January() { [EOL] int month = 1; [EOL] int expectedDays = 31; [EOL] int actualDays = getDaysInMonthMax(month); [EOL] assertEquals(expectedDays, actualDays); [EOL] }
public void testGetDaysInMonthMax_February() { [EOL] int month = 2; [EOL] int expectedDays = 29; [EOL] int actualDays = getDaysInMonthMax(month); [EOL] assertEquals(expectedDays, actualDays); [EOL] }
public void testGetDaysInMonthMax_December() { [EOL] int month = 12; [EOL] int expectedDays = 31; [EOL] int actualDays = getDaysInMonthMax(month); [EOL] assertEquals(expectedDays, actualDays); [EOL] }
public void testGetYearDifferenceWithNonLeapYears() { [EOL] long minuendInstant = 1577836800000L; // 2020-01-01T00:00:00Z [EOL] long subtrahendInstant = 1514764800000L; // 2018-01-01T00:00:00Z [EOL] long expectedDifference = 2; [EOL] long actualDifference = getYearDifference(minuendInstant, subtrahendInstant); [EOL] assertEquals(expectedDifference, actualDifference); [EOL] }
public void testGetYearDifferenceWithMinuendLeapYear() { [EOL] long minuendInstant = 1583020800000L; // 2020-03-01T00:00:00Z (leap year) [EOL] long subtrahendInstant = 1551398400000L; // 2019-03-01T00:00:00Z (non-leap year) [EOL] long expectedDifference = 1; [EOL] long actualDifference = getYearDifference(minuendInstant, subtrahendInstant); [EOL] assertEquals(expectedDifference, actualDifference); [EOL] }
public void testGetYearDifferenceWithSubtrahendLeapYear() { [EOL] long minuendInstant = 1614556800000L; // 2021-03-01T00:00:00Z (non-leap year) [EOL] long subtrahendInstant = 1583020800000L; // 2020-03-01T00:00:00Z (leap year) [EOL] long expectedDifference = 1; [EOL] long actualDifference = getYearDifference(minuendInstant, subtrahendInstant); [EOL] assertEquals(expectedDifference, actualDifference); [EOL] }
public void testGetYearDifferenceWithBothLeapYears() { [EOL] long minuendInstant = 1646092800000L; // 2024-03-01T00:00:00Z (leap year) [EOL] long subtrahendInstant = 1583020800000L; // 2020-03-01T00:00:00Z (leap year) [EOL] long expectedDifference = 4; [EOL] long actualDifference = getYearDifference(minuendInstant, subtrahendInstant); [EOL] assertEquals(expectedDifference, actualDifference); [EOL] }
public void testGetYearDifferenceWithSameYear() { [EOL] long minuendInstant = 1577836800000L; // 2020-01-01T00:00:00Z [EOL] long subtrahendInstant = 1577836800000L; // 2020-01-01T00:00:00Z [EOL] long expectedDifference = 0; [EOL] long actualDifference = getYearDifference(minuendInstant, subtrahendInstant); [EOL] assertEquals(expectedDifference, actualDifference); [EOL] }
public void testGetYearDifferenceWithMinuendBeforeSubtrahend() { [EOL] long minuendInstant = 1514764800000L; // 2018-01-01T00:00:00Z [EOL] long subtrahendInstant = 1577836800000L; // 2020-01-01T00:00:00Z [EOL] long expectedDifference = -2; [EOL] long actualDifference = getYearDifference(minuendInstant, subtrahendInstant); [EOL] assertEquals(expectedDifference, actualDifference); [EOL] }
public void testSetYear_NormalYearToLeapYear() { [EOL] long instant = /* some instant representing a non-leap year */; [EOL] int year = /* a leap year */; [EOL] long expected = /* expected instant after setting year */; [EOL] long actual = setYear(instant, year); [EOL] assertEquals(expected, actual); [EOL] }
public void testSetYear_LeapYearToNormalYear() { [EOL] long instant = /* some instant representing a leap year */; [EOL] int year = /* a non-leap year */; [EOL] long expected = /* expected instant after setting year */; [EOL] long actual = setYear(instant, year); [EOL] assertEquals(expected, actual); [EOL] }
public void testSetYear_NoYearChange() { [EOL] long instant = /* some instant */; [EOL] int year = /* same year as the instant */; [EOL] long expected = instant; [EOL] long actual = setYear(instant, year); [EOL] assertEquals(expected, actual); [EOL] }
public void testSetYear_ChangeToSameTypeOfYear() { [EOL] long instant = /* some instant representing a leap year */; [EOL] int year = /* another leap year */; [EOL] long expected = /* expected instant after setting year */; [EOL] long actual = setYear(instant, year); [EOL] assertEquals(expected, actual); [EOL] }
public void testSetYear_ChangeToSameTypeOfYear_NonLeap() { [EOL] long instant = /* some instant representing a non-leap year */; [EOL] int year = /* another non-leap year */; [EOL] long expected = /* expected instant after setting year */; [EOL] long actual = setYear(instant, year); [EOL] assertEquals(expected, actual); [EOL] }
public void testSecondsZero() { [EOL] Seconds result = Time.seconds(0); [EOL] assertSame(Seconds.ZERO, result); [EOL] }
public void testSecondsOne() { [EOL] Seconds result = Time.seconds(1); [EOL] assertSame(Seconds.ONE, result); [EOL] }
public void testSecondsTwo() { [EOL] Seconds result = Time.seconds(2); [EOL] assertSame(Seconds.TWO, result); [EOL] }
public void testSecondsThree() { [EOL] Seconds result = Time.seconds(3); [EOL] assertSame(Seconds.THREE, result); [EOL] }
public void testSecondsMaxValue() { [EOL] Seconds result = Time.seconds(Integer.MAX_VALUE); [EOL] assertSame(Seconds.MAX_VALUE, result); [EOL] }
public void testSecondsMinValue() { [EOL] Seconds result = Time.seconds(Integer.MIN_VALUE); [EOL] assertSame(Seconds.MIN_VALUE, result); [EOL] }
public void testSecondsDefault() { [EOL] int arbitrarySeconds = 10; [EOL] Seconds result = Time.seconds(arbitrarySeconds); [EOL] assertNotNull(result); [EOL] assertEquals(arbitrarySeconds, result.getSeconds()); [EOL] }
public void testSecondsBetweenWithSameInstant() { [EOL] ReadableInstant start = new DateTime(); [EOL] ReadableInstant end = new DateTime(start); [EOL] Seconds result = Time.secondsBetween(start, end); [EOL] assertEquals(0, result.getSeconds()); [EOL] }
public void testSecondsBetweenWithDifferentInstant() { [EOL] ReadableInstant start = new DateTime(); [EOL] ReadableInstant end = start.plusSeconds(10); [EOL] Seconds result = Time.secondsBetween(start, end); [EOL] assertEquals(10, result.getSeconds()); [EOL] }
public void testSecondsInWithNullInterval() { [EOL] Seconds result = Time.secondsIn(null); [EOL] assertEquals(Seconds.ZERO, result); [EOL] }
public void testSecondsInWithValidInterval() { [EOL] ReadableInterval interval = new Interval(0, 1000); // Assuming Interval implements ReadableInterval [EOL] Seconds result = Time.secondsIn(interval); [EOL] assertEquals(Seconds.seconds(1), result); [EOL] }
public void testStandardSecondsIn_NullPeriod() { [EOL] try { [EOL] Seconds.standardSecondsIn(null); [EOL] fail("Should have thrown IllegalArgumentException for null period"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testStandardSecondsIn_ZeroMillisPeriod() { [EOL] ReadablePeriod period = new Period(0); [EOL] Seconds result = Seconds.standardSecondsIn(period); [EOL] assertEquals("Expected zero seconds", 0, result.getSeconds()); [EOL] }
public void testStandardSecondsIn_NonZeroMillisPeriod() { [EOL] ReadablePeriod period = new Period(1000); [EOL] Seconds result = Seconds.standardSecondsIn(period); [EOL] assertEquals("Expected one second", 1, result.getSeconds()); [EOL] }
public void testGetPeriodType_ReturnsSeconds() { [EOL] TimePeriod period = new TimePeriod(); [EOL] PeriodType result = period.getPeriodType(); [EOL] assertEquals(PeriodType.seconds(), result); [EOL] }
It seems like there is a misunderstanding. As an AI, I can help you generate unit test case methods with meaningful assertions for a Java project, but I need more context about the class and method you want to test. The provided input text only shows a single method `getSeconds()` which simply calls another method `getValue()`. Without knowing what `getValue()` does or the context of the class it's in, I can't generate meaningful test cases. [EOL] To generate test cases, I would need to know: [EOL] 1. The class that contains the `getSeconds()` method. [EOL] 2. The implementation of the `getValue()` method. [EOL] 3. Any relevant state or properties of the class that `getSeconds()` is a part of. [EOL] If you can provide this information, I can help you create test cases that aim for maximum line coverage.
public void testMinus_withPositiveSeconds() { [EOL] Seconds initial = Seconds.seconds(10); [EOL] Seconds result = initial.minus(5); [EOL] assertEquals(5, result.getSeconds()); [EOL] }
public void testMinus_withNegativeSeconds() { [EOL] Seconds initial = Seconds.seconds(10); [EOL] Seconds result = initial.minus(-5); [EOL] assertEquals(15, result.getSeconds()); [EOL] }
public void testMinus_withZeroSeconds() { [EOL] Seconds initial = Seconds.seconds(10); [EOL] Seconds result = initial.minus(0); [EOL] assertEquals(10, result.getSeconds()); [EOL] }
public void testGetInstance_BaseIsNull() { [EOL] try { [EOL] LimitChronology.getInstance(null, null, null); [EOL] fail("Should have thrown IllegalArgumentException for null chronology"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Must supply a chronology", e.getMessage()); [EOL] } [EOL] }
public void testGetInstance_LowerLimitAfterUpperLimit() { [EOL] Chronology base = ISOChronology.getInstance(); [EOL] DateTime lowerLimit = new DateTime(2020, 1, 2, 0, 0); [EOL] DateTime upperLimit = new DateTime(2020, 1, 1, 0, 0); [EOL] try { [EOL] LimitChronology.getInstance(base, lowerLimit, upperLimit); [EOL] fail("Should have thrown IllegalArgumentException for lower limit after upper limit"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("The lower limit must be come before than the upper limit", e.getMessage()); [EOL] } [EOL] }
public void testGetInstance_ValidArguments() { [EOL] Chronology base = ISOChronology.getInstance(); [EOL] DateTime lowerLimit = new DateTime(2020, 1, 1, 0, 0); [EOL] DateTime upperLimit = new DateTime(2020, 1, 2, 0, 0); [EOL] LimitChronology result = LimitChronology.getInstance(base, lowerLimit, upperLimit); [EOL] assertNotNull("LimitChronology should not be null with valid arguments", result); [EOL] }
public void testGetInstance_LowerLimitIsNull() { [EOL] Chronology base = ISOChronology.getInstance(); [EOL] DateTime upperLimit = new DateTime(2020, 1, 2, 0, 0); [EOL] LimitChronology result = LimitChronology.getInstance(base, null, upperLimit); [EOL] assertNotNull("LimitChronology should not be null when lower limit is null", result); [EOL] }
public void testGetInstance_UpperLimitIsNull() { [EOL] Chronology base = ISOChronology.getInstance(); [EOL] DateTime lowerLimit = new DateTime(2020, 1, 1, 0, 0); [EOL] LimitChronology result = LimitChronology.getInstance(base, lowerLimit, null); [EOL] assertNotNull("LimitChronology should not be null when upper limit is null", result); [EOL] }
public void testGetInstance_BothLimitsAreNull() { [EOL] Chronology base = ISOChronology.getInstance(); [EOL] LimitChronology result = LimitChronology.getInstance(base, null, null); [EOL] assertNotNull("LimitChronology should not be null when both limits are null", result); [EOL] }
public DateTime getLowerLimit() { [EOL] return iLowerLimit; [EOL] }
public void testGetUpperLimit() { [EOL] DateTime expected = new DateTime(); // Assuming DateTime is a valid type and can be instantiated [EOL] MyClass myClassInstance = new MyClass(expected); // Assuming MyClass is the class containing getUpperLimit and it has a constructor that sets iUpperLimit [EOL] DateTime actual = myClassInstance.getUpperLimit(); [EOL] assertEquals("The upper limit should match the expected value", expected, actual); [EOL] }
public void testGetDateTimeMillis_ValidDate() { [EOL] int year = 2021; [EOL] int monthOfYear = 5; [EOL] int dayOfMonth = 20; [EOL] int millisOfDay = 0; [EOL] long expected = SOME_EXPECTED_VALUE; // Replace with the actual expected value [EOL] long result = getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay); [EOL] assertEquals(expected, result); [EOL] }
public void testGetDateTimeMillis_InvalidDate() { [EOL] int year = 2021; [EOL] int monthOfYear = 13; // Invalid month [EOL] int dayOfMonth = 20; [EOL] int millisOfDay = 0; [EOL] try { [EOL] getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testGetDateTimeMillis_InvalidMillisOfDay() { [EOL] int year = 2021; [EOL] int monthOfYear = 5; [EOL] int dayOfMonth = 20; [EOL] int millisOfDay = -1; // Invalid millisOfDay [EOL] try { [EOL] getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testGetDateTimeMillis_ValidDate() { [EOL] int year = 2023; [EOL] int monthOfYear = 3; [EOL] int dayOfMonth = 15; [EOL] int hourOfDay = 12; [EOL] int minuteOfHour = 30; [EOL] int secondOfMinute = 45; [EOL] int millisOfSecond = 123; [EOL] long expected = getBase().getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL] long result = getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL] assertEquals(expected, result); [EOL] }
public void testCheckLimits_WithinLimits() { [EOL] long instant = System.currentTimeMillis(); [EOL] String desc = "Within limits"; [EOL] checkLimits(instant, desc); [EOL] }
public void testCheckLimits_BelowLowerLimit() { [EOL] long instant = System.currentTimeMillis() - 10000; // 10 seconds before now [EOL] String desc = "Below lower limit"; [EOL] try { [EOL] checkLimits(instant, desc); [EOL] fail("Expected LimitException for being below lower limit"); [EOL] } catch (LimitException e) { [EOL] assertTrue(e.isBelowLimit()); [EOL] } [EOL] }
public void testCheckLimits_AboveUpperLimit() { [EOL] long instant = System.currentTimeMillis() + 10000; // 10 seconds after now [EOL] String desc = "Above upper limit"; [EOL] try { [EOL] checkLimits(instant, desc); [EOL] fail("Expected LimitException for being above upper limit"); [EOL] } catch (LimitException e) { [EOL] assertFalse(e.isBelowLimit()); [EOL] } [EOL] }
public void testEquals_SameObject() { [EOL] LimitChronology chrono = new LimitChronology(); [EOL] assertTrue(chrono.equals(chrono)); [EOL] }
public void testEquals_Null() { [EOL] LimitChronology chrono = new LimitChronology(); [EOL] assertFalse(chrono.equals(null)); [EOL] }
public void testEquals_DifferentClass() { [EOL] LimitChronology chrono = new LimitChronology(); [EOL] assertFalse(chrono.equals(new Object())); [EOL] }
public void testEquals_EqualLimitChronology() { [EOL] LimitChronology chrono1 = new LimitChronology(); [EOL] LimitChronology chrono2 = new LimitChronology(); [EOL] chrono1.setBase(someBaseChronology); [EOL] chrono1.setLowerLimit(someLowerLimit); [EOL] chrono1.setUpperLimit(someUpperLimit); [EOL] chrono2.setBase(someBaseChronology); [EOL] chrono2.setLowerLimit(someLowerLimit); [EOL] chrono2.setUpperLimit(someUpperLimit); [EOL] assertTrue(chrono1.equals(chrono2)); [EOL] }
public void testEquals_NotEqualBase() { [EOL] LimitChronology chrono1 = new LimitChronology(); [EOL] LimitChronology chrono2 = new LimitChronology(); [EOL] chrono1.setBase(someBaseChronology); [EOL] chrono1.setLowerLimit(someLowerLimit); [EOL] chrono1.setUpperLimit(someUpperLimit); [EOL] chrono2.setBase(differentBaseChronology); [EOL] chrono2.setLowerLimit(someLowerLimit); [EOL] chrono2.setUpperLimit(someUpperLimit); [EOL] assertFalse(chrono1.equals(chrono2)); [EOL] }
public void testEquals_NotEqualLowerLimit() { [EOL] LimitChronology chrono1 = new LimitChronology(); [EOL] LimitChronology chrono2 = new LimitChronology(); [EOL] chrono1.setBase(someBaseChronology); [EOL] chrono1.setLowerLimit(someLowerLimit); [EOL] chrono1.setUpperLimit(someUpperLimit); [EOL] chrono2.setBase(someBaseChronology); [EOL] chrono2.setLowerLimit(differentLowerLimit); [EOL] chrono2.setUpperLimit(someUpperLimit); [EOL] assertFalse(chrono1.equals(chrono2)); [EOL] }
public void testEquals_NotEqualUpperLimit() { [EOL] LimitChronology chrono1 = new LimitChronology(); [EOL] LimitChronology chrono2 = new LimitChronology(); [EOL] chrono1.setBase(someBaseChronology); [EOL] chrono1.setLowerLimit(someLowerLimit); [EOL] chrono1.setUpperLimit(someUpperLimit); [EOL] chrono2.setBase(someBaseChronology); [EOL] chrono2.setLowerLimit(someLowerLimit); [EOL] chrono2.setUpperLimit(differentUpperLimit); [EOL] assertFalse(chrono1.equals(chrono2)); [EOL] }
public void testHashCodeWithNonNullLimits() { [EOL] TimeRange timeRange = new TimeRange(); [EOL] timeRange.setLowerLimit(new Time(10, 30, 0)); [EOL] timeRange.setUpperLimit(new Time(12, 45, 0)); [EOL] timeRange.setBase(new Time(9, 15, 0)); [EOL] int expectedHash = 317351877; [EOL] expectedHash += timeRange.getLowerLimit().hashCode(); [EOL] expectedHash += timeRange.getUpperLimit().hashCode(); [EOL] expectedHash += timeRange.getBase().hashCode() * 7; [EOL] assertEquals(expectedHash, timeRange.hashCode()); [EOL] }
public void testHashCodeWithNullLowerLimit() { [EOL] TimeRange timeRange = new TimeRange(); [EOL] timeRange.setLowerLimit(null); [EOL] timeRange.setUpperLimit(new Time(12, 45, 0)); [EOL] timeRange.setBase(new Time(9, 15, 0)); [EOL] int expectedHash = 317351877; [EOL] expectedHash += 0; // Lower limit is null [EOL] expectedHash += timeRange.getUpperLimit().hashCode(); [EOL] expectedHash += timeRange.getBase().hashCode() * 7; [EOL] assertEquals(expectedHash, timeRange.hashCode()); [EOL] }
public void testHashCodeWithNullUpperLimit() { [EOL] TimeRange timeRange = new TimeRange(); [EOL] timeRange.setLowerLimit(new Time(10, 30, 0)); [EOL] timeRange.setUpperLimit(null); [EOL] timeRange.setBase(new Time(9, 15, 0)); [EOL] int expectedHash = 317351877; [EOL] expectedHash += timeRange.getLowerLimit().hashCode(); [EOL] expectedHash += 0; // Upper limit is null [EOL] expectedHash += timeRange.getBase().hashCode() * 7; [EOL] assertEquals(expectedHash, timeRange.hashCode()); [EOL] }
public void testHashCodeWithAllNullLimits() { [EOL] TimeRange timeRange = new TimeRange(); [EOL] timeRange.setLowerLimit(null); [EOL] timeRange.setUpperLimit(null); [EOL] timeRange.setBase(new Time(9, 15, 0)); [EOL] int expectedHash = 317351877; [EOL] expectedHash += 0; // Lower limit is null [EOL] expectedHash += 0; // Upper limit is null [EOL] expectedHash += timeRange.getBase().hashCode() * 7; [EOL] assertEquals(expectedHash, timeRange.hashCode()); [EOL] }
public void testGetWithValidInstant() { [EOL] long validInstant = /* some valid instant value */; [EOL] DateTimeField mockField = Mockito.mock(DateTimeField.class); [EOL] Mockito.when(mockField.get(validInstant)).thenReturn(10); [EOL] Time time = new Time(mockField); [EOL] int result = time.get(validInstant); [EOL] assertEquals(10, result); [EOL] }
public void testGetWithInvalidInstantThrowsException() { [EOL] long invalidInstant = /* some invalid instant value that causes checkLimits to throw */; [EOL] DateTimeField mockField = Mockito.mock(DateTimeField.class); [EOL] Mockito.when(mockField.get(invalidInstant)).thenThrow(new IllegalArgumentException()); [EOL] Time time = new Time(mockField); [EOL] assertThrows(IllegalArgumentException.class, () -> { [EOL] time.get(invalidInstant); [EOL] }); [EOL] }
public void testAdd_withValidInstantAndAmount() { [EOL] long instant = 1234567890L; [EOL] int amount = 10; [EOL] long expected = 1234567890L + 10; // Assuming getWrappedField().add() performs a simple addition [EOL] long result = add(instant, amount); [EOL] assertEquals(expected, result); [EOL] } [EOL] public void testAdd_withInstantAtLowerLimit() { [EOL] long instant = Long.MIN_VALUE; [EOL] int amount = 1; [EOL] long expected = Long.MIN_VALUE + 1; // Assuming getWrappedField().add() performs a simple addition [EOL] long result = add(instant, amount); [EOL] assertEquals(expected, result); [EOL] } [EOL] public void testAdd_withInstantAtUpperLimit() { [EOL] long instant = Long.MAX_VALUE; [EOL] int amount = -1; [EOL] long expected = Long.MAX_VALUE - 1; // Assuming getWrappedField().add() performs a simple addition [EOL] long result = add(instant, amount); [EOL] assertEquals(expected, result); [EOL] } [EOL] public void testAdd_withAmountCausingOverflow() { [EOL] long instant = Long.MAX_VALUE; [EOL] int amount = 10; [EOL] try { [EOL] add(instant, amount); [EOL] fail("Expected an exception due to overflow"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] } [EOL] public void testAdd_withAmountCausingUnderflow() { [EOL] long instant = Long.MIN_VALUE; [EOL] int amount = -10; [EOL] try { [EOL] add(instant, amount); [EOL] fail("Expected an exception due to underflow"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testAddWrapField_WithinLimits() { [EOL] long instant = SOME_INSTANT_WITHIN_LIMITS; [EOL] int amount = SOME_AMOUNT_THAT_DOES_NOT_OVERFLOW; [EOL] long expected = EXPECTED_RESULT_WITHIN_LIMITS; [EOL] long result = addWrapField(instant, amount); [EOL] assertEquals(expected, result); [EOL] }
public void testAddWrapField_BelowLimit() { [EOL] long instant = SOME_INSTANT_JUST_BELOW_LIMIT; [EOL] int amount = SOME_AMOUNT_TO_JUST_REACH_LIMIT; [EOL] long expected = EXPECTED_RESULT_AT_LIMIT; [EOL] long result = addWrapField(instant, amount); [EOL] assertEquals(expected, result); [EOL] }
public void testAddWrapField_AboveLimit() { [EOL] long instant = SOME_INSTANT_JUST_ABOVE_LIMIT; [EOL] int amount = SOME_AMOUNT_TO_JUST_BELOW_LIMIT; [EOL] long expected = EXPECTED_RESULT_JUST_BELOW_LIMIT; [EOL] long result = addWrapField(instant, amount); [EOL] assertEquals(expected, result); [EOL] }
public void testSetWithValidValue() { [EOL] long instant = System.currentTimeMillis(); [EOL] int value = 5; [EOL] long result = set(instant, value); [EOL] } [EOL] public void testSetWithInvalidInstant() { [EOL] long instant = -1; // Assuming this is an invalid instant [EOL] int value = 5; [EOL] try { [EOL] set(instant, value); [EOL] fail("Should have thrown an exception due to invalid instant"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] } [EOL] public void testSetWithInvalidValue() { [EOL] long instant = System.currentTimeMillis(); [EOL] int value = -1; // Assuming this is an invalid value [EOL] try { [EOL] set(instant, value); [EOL] fail("Should have thrown an exception due to invalid value"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] } [EOL] public void testSetResultingInInvalidInstant() { [EOL] long instant = System.currentTimeMillis(); [EOL] int value = 5; [EOL] try { [EOL] set(instant, value); [EOL] fail("Should have thrown an exception due to resulting invalid instant"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testRoundFloorWithinLimits() { [EOL] long instant = SOME_INSTANT_WITHIN_LIMITS; [EOL] long expected = EXPECTED_RESULT_WITHIN_LIMITS; [EOL] long actual = roundFloor(instant); [EOL] assertEquals(expected, actual); [EOL] }
public void testRoundFloorBelowLimits() { [EOL] long instant = SOME_INSTANT_BELOW_LIMITS; [EOL] try { [EOL] roundFloor(instant); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public void testRoundFloorAboveLimits() { [EOL] long instant = SOME_INSTANT_ABOVE_LIMITS; [EOL] try { [EOL] roundFloor(instant); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public int getMonthOfYear() { [EOL] return getChronology().monthOfYear().get(getMillis()); [EOL] }
public int getDayOfMonth() { [EOL] return getChronology().dayOfMonth().get(getMillis()); [EOL] }
public void testToStringWithNullPattern() { [EOL] Time time = new Time(); [EOL] String result = time.toString(null, Locale.ENGLISH); [EOL] assertNotNull(result); [EOL] }
public void testToStringWithValidPatternAndLocale() { [EOL] Time time = new Time(); [EOL] String pattern = "yyyy-MM-dd"; [EOL] String result = time.toString(pattern, Locale.ENGLISH); [EOL] assertNotNull(result); [EOL] assertTrue(result.matches("\\d{4}-\\d{2}-\\d{2}")); [EOL] }
public void testToStringWithInvalidPattern() { [EOL] Time time = new Time(); [EOL] String pattern = "invalid-pattern"; [EOL] try { [EOL] time.toString(pattern, Locale.ENGLISH); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) { [EOL] if (minuendInstant < subtrahendInstant) { [EOL] return -getDifferenceAsLong(subtrahendInstant, minuendInstant); [EOL] } [EOL] long difference = (minuendInstant - subtrahendInstant) / iUnitMillis; [EOL] if (add(subtrahendInstant, difference) < minuendInstant) { [EOL] do { [EOL] difference++; [EOL] } while (add(subtrahendInstant, difference) <= minuendInstant); [EOL] difference--; [EOL] } else if (add(subtrahendInstant, difference) > minuendInstant) { [EOL] do { [EOL] difference--; [EOL] } while (add(subtrahendInstant, difference) > minuendInstant); [EOL] } [EOL] return difference; [EOL] }
public void testGetPeriodType_ReturnsWeeks() { [EOL] PeriodType actual = new YourClass().getPeriodType(); [EOL] assertEquals(PeriodType.weeks(), actual); [EOL] }
public void testToStandardSeconds_PositiveWeeks() { [EOL] Weeks testWeeks = Weeks.weeks(2); [EOL] Seconds expectedSeconds = Seconds.seconds(2 * DateTimeConstants.SECONDS_PER_WEEK); [EOL] assertEquals(expectedSeconds, testWeeks.toStandardSeconds()); [EOL] }
public void testToStandardSeconds_NegativeWeeks() { [EOL] Weeks testWeeks = Weeks.weeks(-3); [EOL] Seconds expectedSeconds = Seconds.seconds(-3 * DateTimeConstants.SECONDS_PER_WEEK); [EOL] assertEquals(expectedSeconds, testWeeks.toStandardSeconds()); [EOL] }
public void testToStandardSeconds_ZeroWeeks() { [EOL] Weeks testWeeks = Weeks.weeks(0); [EOL] Seconds expectedSeconds = Seconds.seconds(0); [EOL] assertEquals(expectedSeconds, testWeeks.toStandardSeconds()); [EOL] }
public void testToStandardDuration_PositiveWeeks() { [EOL] Period testPeriod = new Period().withWeeks(2); [EOL] Duration result = testPeriod.toStandardDuration(); [EOL] assertEquals(2 * DateTimeConstants.MILLIS_PER_WEEK, result.getMillis()); [EOL] }
public void testToStandardDuration_ZeroWeeks() { [EOL] Period testPeriod = new Period().withWeeks(0); [EOL] Duration result = testPeriod.toStandardDuration(); [EOL] assertEquals(0, result.getMillis()); [EOL] }
public void testToStandardDuration_NegativeWeeks() { [EOL] Period testPeriod = new Period().withWeeks(-3); [EOL] Duration result = testPeriod.toStandardDuration(); [EOL] assertEquals(-3 * DateTimeConstants.MILLIS_PER_WEEK, result.getMillis()); [EOL] }
public void testMultipliedBy_Positive() { [EOL] Weeks weeks = Weeks.weeks(2); [EOL] Weeks result = weeks.multipliedBy(3); [EOL] assertEquals(6, result.getWeeks()); [EOL] }
public void testMultipliedBy_Negative() { [EOL] Weeks weeks = Weeks.weeks(2); [EOL] Weeks result = weeks.multipliedBy(-3); [EOL] assertEquals(-6, result.getWeeks()); [EOL] }
public void testMultipliedBy_Zero() { [EOL] Weeks weeks = Weeks.weeks(2); [EOL] Weeks result = weeks.multipliedBy(0); [EOL] assertEquals(0, result.getWeeks()); [EOL] }
public void testMultipliedBy_One() { [EOL] Weeks weeks = Weeks.weeks(2); [EOL] Weeks result = weeks.multipliedBy(1); [EOL] assertEquals(2, result.getWeeks()); [EOL] }
public void testToString_PositiveValue() { [EOL] Time time = new Time(); [EOL] time.setValue(10); [EOL] String result = time.toString(); [EOL] assertEquals("P10W", result); [EOL] }
public void testToString_NegativeValue() { [EOL] Time time = new Time(); [EOL] time.setValue(-5); [EOL] String result = time.toString(); [EOL] assertEquals("P-5W", result); [EOL] }
public void testToString_ZeroValue() { [EOL] Time time = new Time(); [EOL] time.setValue(0); [EOL] String result = time.toString(); [EOL] assertEquals("P0W", result); [EOL] }
public void testParseWithValidFormatterAndString() { [EOL] String validDateString = "2020-01-01T12:00:00"; [EOL] DateTimeFormatter formatter = DateTimeFormat.forPattern("yyyy-MM-dd'T'HH:mm:ss"); [EOL] DateTime result = ClassName.parse(validDateString, formatter); [EOL] assertNotNull(result); [EOL] assertEquals(2020, result.getYear()); [EOL] assertEquals(1, result.getMonthOfYear()); [EOL] assertEquals(1, result.getDayOfMonth()); [EOL] assertEquals(12, result.getHourOfDay()); [EOL] assertEquals(0, result.getMinuteOfHour()); [EOL] assertEquals(0, result.getSecondOfMinute()); [EOL] }
public void testParseWithInvalidFormatter() { [EOL] String validDateString = "2020-01-01T12:00:00"; [EOL] DateTimeFormatter formatter = null; [EOL] try { [EOL] ClassName.parse(validDateString, formatter); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testParseWithInvalidString() { [EOL] String invalidDateString = "invalid-date"; [EOL] DateTimeFormatter formatter = DateTimeFormat.forPattern("yyyy-MM-dd'T'HH:mm:ss"); [EOL] try { [EOL] ClassName.parse(invalidDateString, formatter); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testDateTimeWithValidInstantAndChronology() { [EOL] long instant = System.currentTimeMillis(); [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] DateTime dateTime = new DateTime(instant, chronology); [EOL] assertNotNull(dateTime); [EOL] assertEquals(instant, dateTime.getMillis()); [EOL] assertEquals(chronology, dateTime.getChronology()); [EOL] }
public void testDateTimeWithNullChronology() { [EOL] long instant = System.currentTimeMillis(); [EOL] DateTime dateTime = new DateTime(instant, null); [EOL] assertNotNull(dateTime); [EOL] assertEquals(instant, dateTime.getMillis()); [EOL] assertNotNull(dateTime.getChronology()); [EOL] assertEquals(ISOChronology.getInstanceUTC(), dateTime.getChronology()); [EOL] }
public void testDateTimeWithNullInstantAndNullZone() { [EOL] DateTime result = new DateTime((Object) null, (DateTimeZone) null); [EOL] assertNotNull(result); [EOL] assertNull(result.getZone()); [EOL] }
public void testDateTimeWithNonNullInstantAndNullZone() { [EOL] Instant instant = new Instant(); [EOL] DateTime result = new DateTime((Object) instant, (DateTimeZone) null); [EOL] assertNotNull(result); [EOL] assertEquals(instant.getMillis(), result.getMillis()); [EOL] assertNull(result.getZone()); [EOL] }
public void testDateTimeWithNullInstantAndNonNullZone() { [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/London"); [EOL] DateTime result = new DateTime((Object) null, zone); [EOL] assertNotNull(result); [EOL] assertEquals(zone, result.getZone()); [EOL] }
public void testDateTimeWithNonNullInstantAndNonNullZone() { [EOL] Instant instant = new Instant(); [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/London"); [EOL] DateTime result = new DateTime((Object) instant, zone); [EOL] assertNotNull(result); [EOL] assertEquals(instant.getMillis(), result.getMillis()); [EOL] assertEquals(zone, result.getZone()); [EOL] }
public void testDateTimeConstructor_ValidValues() { [EOL] int year = 2023; [EOL] int monthOfYear = 4; [EOL] int dayOfMonth = 15; [EOL] int hourOfDay = 14; [EOL] int minuteOfHour = 30; [EOL] int secondOfMinute = 45; [EOL] DateTime dateTime = new DateTime(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute); [EOL] assertEquals(year, dateTime.getYear()); [EOL] assertEquals(monthOfYear, dateTime.getMonthOfYear()); [EOL] assertEquals(dayOfMonth, dateTime.getDayOfMonth()); [EOL] assertEquals(hourOfDay, dateTime.getHourOfDay()); [EOL] assertEquals(minuteOfHour, dateTime.getMinuteOfHour()); [EOL] assertEquals(secondOfMinute, dateTime.getSecondOfMinute()); [EOL] }
public void testDateTimeWithValidValues() { [EOL] int year = 2023; [EOL] int monthOfYear = 4; [EOL] int dayOfMonth = 15; [EOL] int hourOfDay = 14; [EOL] int minuteOfHour = 30; [EOL] int secondOfMinute = 45; [EOL] DateTimeZone zone = DateTimeZone.UTC; [EOL] DateTime dateTime = new DateTime(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, zone); [EOL] assertEquals(year, dateTime.getYear()); [EOL] assertEquals(monthOfYear, dateTime.getMonthOfYear()); [EOL] assertEquals(dayOfMonth, dateTime.getDayOfMonth()); [EOL] assertEquals(hourOfDay, dateTime.getHourOfDay()); [EOL] assertEquals(minuteOfHour, dateTime.getMinuteOfHour()); [EOL] assertEquals(secondOfMinute, dateTime.getSecondOfMinute()); [EOL] assertEquals(zone, dateTime.getZone()); [EOL] }
public void testDateTimeConstructor_ValidValues() { [EOL] int year = 2021; [EOL] int monthOfYear = 5; [EOL] int dayOfMonth = 20; [EOL] int hourOfDay = 13; [EOL] int minuteOfHour = 45; [EOL] int secondOfMinute = 30; [EOL] int millisOfSecond = 500; [EOL] DateTime dateTime = new DateTime(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL] assertNotNull(dateTime); [EOL] assertEquals(year, dateTime.getYear()); [EOL] assertEquals(monthOfYear, dateTime.getMonthOfYear()); [EOL] assertEquals(dayOfMonth, dateTime.getDayOfMonth()); [EOL] assertEquals(hourOfDay, dateTime.getHourOfDay()); [EOL] assertEquals(minuteOfHour, dateTime.getMinuteOfHour()); [EOL] assertEquals(secondOfMinute, dateTime.getSecondOfMinute()); [EOL] assertEquals(millisOfSecond, dateTime.getMillisOfSecond()); [EOL] }
public void testWithMillis_SameMillis() { [EOL] long currentMillis = System.currentTimeMillis(); [EOL] DateTime dateTime = new DateTime(currentMillis); [EOL] DateTime result = dateTime.withMillis(currentMillis); [EOL] assertSame(dateTime, result); [EOL] }
public void testWithMillis_DifferentMillis() { [EOL] long currentMillis = System.currentTimeMillis(); [EOL] DateTime dateTime = new DateTime(currentMillis); [EOL] long newMillis = currentMillis + 1000; // Assuming newMillis is different [EOL] DateTime result = dateTime.withMillis(newMillis); [EOL] assertNotSame(dateTime, result); [EOL] assertEquals(newMillis, result.getMillis()); [EOL] }
public void testWithTime_ValidTime() { [EOL] DateTime dateTime = new DateTime(); [EOL] int hourOfDay = 13; [EOL] int minuteOfHour = 30; [EOL] int secondOfMinute = 45; [EOL] int millisOfSecond = 123; [EOL] DateTime updatedDateTime = dateTime.withTime(hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL] assertEquals(hourOfDay, updatedDateTime.getHourOfDay()); [EOL] assertEquals(minuteOfHour, updatedDateTime.getMinuteOfHour()); [EOL] assertEquals(secondOfMinute, updatedDateTime.getSecondOfMinute()); [EOL] assertEquals(millisOfSecond, updatedDateTime.getMillisOfSecond()); [EOL] }
public void testWithTime_InvalidHour() { [EOL] DateTime dateTime = new DateTime(); [EOL] int invalidHourOfDay = 25; [EOL] try { [EOL] dateTime.withTime(invalidHourOfDay, 0, 0, 0); [EOL] fail("Should have thrown an exception for invalid hour of day"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testWithTime_InvalidMinute() { [EOL] DateTime dateTime = new DateTime(); [EOL] int invalidMinuteOfHour = 60; [EOL] try { [EOL] dateTime.withTime(0, invalidMinuteOfHour, 0, 0); [EOL] fail("Should have thrown an exception for invalid minute of hour"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testWithTime_InvalidSecond() { [EOL] DateTime dateTime = new DateTime(); [EOL] int invalidSecondOfMinute = 60; [EOL] try { [EOL] dateTime.withTime(0, 0, invalidSecondOfMinute, 0); [EOL] fail("Should have thrown an exception for invalid second of minute"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testWithTime_InvalidMillis() { [EOL] DateTime dateTime = new DateTime(); [EOL] int invalidMillisOfSecond = 1000; [EOL] try { [EOL] dateTime.withTime(0, 0, 0, invalidMillisOfSecond); [EOL] fail("Should have thrown an exception for invalid millis of second"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testWithFieldAdded_NullFieldType() { [EOL] try { [EOL] DateTime dateTime = new DateTime(); [EOL] dateTime.withFieldAdded(null, 1); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("Field must not be null", ex.getMessage()); [EOL] } [EOL] }
public void testWithFieldAdded_ZeroAmount() { [EOL] DateTime dateTime = new DateTime(); [EOL] DateTime result = dateTime.withFieldAdded(DurationFieldType.days(), 0); [EOL] assertSame("Should be the same DateTime object", dateTime, result); [EOL] }
public void testWithFieldAdded_NonZeroAmount() { [EOL] DateTime dateTime = new DateTime(); [EOL] DateTime result = dateTime.withFieldAdded(DurationFieldType.days(), 1); [EOL] assertNotSame("Should not be the same DateTime object", dateTime, result); [EOL] assertTrue("The result should have a different millis value", dateTime.getMillis() != result.getMillis()); [EOL] }
public void testWithDurationAdded_ZeroDuration() { [EOL] DateTime dateTime = new DateTime(); [EOL] DateTime result = dateTime.withDurationAdded(0, 1); [EOL] assertSame(dateTime, result); [EOL] }
public void testWithDurationAdded_ZeroScalar() { [EOL] DateTime dateTime = new DateTime(); [EOL] DateTime result = dateTime.withDurationAdded(10, 0); [EOL] assertSame(dateTime, result); [EOL] }
public void testWithDurationAdded_NonZeroDurationAndScalar() { [EOL] DateTime dateTime = new DateTime(); [EOL] long durationToAdd = 10; [EOL] int scalar = 2; [EOL] DateTime result = dateTime.withDurationAdded(durationToAdd, scalar); [EOL] assertNotSame(dateTime, result); [EOL] assertEquals(dateTime.getMillis() + durationToAdd * scalar, result.getMillis()); [EOL] }
public void testWithDurationAdded_NullDuration() { [EOL] DateTime dateTime = new DateTime(); [EOL] DateTime result = dateTime.withDurationAdded(null, 1); [EOL] assertSame(dateTime, result); [EOL] } [EOL] public void testWithDurationAdded_ZeroScalar() { [EOL] DateTime dateTime = new DateTime(); [EOL] ReadableDuration duration = new Duration(1000); [EOL] DateTime result = dateTime.withDurationAdded(duration, 0); [EOL] assertSame(dateTime, result); [EOL] } [EOL] public void testWithDurationAdded_NonNullDurationNonZeroScalar() { [EOL] DateTime dateTime = new DateTime(); [EOL] ReadableDuration duration = new Duration(1000); [EOL] DateTime expected = dateTime.plus(1000); [EOL] DateTime result = dateTime.withDurationAdded(duration, 1); [EOL] assertEquals(expected, result); [EOL] }

public void testPlusMonths_ZeroMonths() { [EOL] DateTime dateTime = new DateTime(); [EOL] DateTime result = dateTime.plusMonths(0); [EOL] assertSame("Expected the same instance when adding zero months", dateTime, result); [EOL] }
public void testPlusMonths_PositiveMonths() { [EOL] DateTime dateTime = new DateTime(); [EOL] DateTime result = dateTime.plusMonths(1); [EOL] assertNotSame("Expected a different instance when adding months", dateTime, result); [EOL] assertTrue("The result should be later in time when adding a positive number of months", result.isAfter(dateTime)); [EOL] }
public void testPlusMonths_NegativeMonths() { [EOL] DateTime dateTime = new DateTime(); [EOL] DateTime result = dateTime.plusMonths(-1); [EOL] assertNotSame("Expected a different instance when subtracting months", dateTime, result); [EOL] assertTrue("The result should be earlier in time when subtracting a positive number of months", result.isBefore(dateTime)); [EOL] }
public void testPlusSeconds_Zero() { [EOL] DateTime dateTime = new DateTime(); [EOL] DateTime result = dateTime.plusSeconds(0); [EOL] assertSame("The same object should be returned when adding zero seconds", dateTime, result); [EOL] } [EOL] public void testPlusSeconds_Positive() { [EOL] DateTime dateTime = new DateTime(); [EOL] DateTime result = dateTime.plusSeconds(1); [EOL] assertNotSame("A different object should be returned when adding seconds", dateTime, result); [EOL] assertEquals("The time should be one second in the future", dateTime.getMillis() + 1000, result.getMillis()); [EOL] } [EOL] public void testPlusSeconds_Negative() { [EOL] DateTime dateTime = new DateTime(); [EOL] DateTime result = dateTime.plusSeconds(-1); [EOL] assertNotSame("A different object should be returned when subtracting seconds", dateTime, result); [EOL] assertEquals("The time should be one second in the past", dateTime.getMillis() - 1000, result.getMillis()); [EOL] }
public void testMinusMonths_ZeroMonths() { [EOL] DateTime dateTime = new DateTime(); [EOL] DateTime result = dateTime.minusMonths(0); [EOL] assertEquals(dateTime, result); [EOL] }
public void testMinusMonths_NegativeMonths() { [EOL] DateTime dateTime = new DateTime(); [EOL] DateTime result = dateTime.minusMonths(-1); [EOL] assertNotEquals(dateTime, result); [EOL] }
public void testMinusMonths_PositiveMonths() { [EOL] DateTime dateTime = new DateTime(); [EOL] DateTime result = dateTime.minusMonths(1); [EOL] assertNotEquals(dateTime, result); [EOL] }
public void testMinusHours_ZeroHours() { [EOL] DateTime dateTime = new DateTime(); [EOL] DateTime result = dateTime.minusHours(0); [EOL] assertSame("Expected the same instance when subtracting zero hours", dateTime, result); [EOL] }
public void testMinusHours_NegativeHours() { [EOL] DateTime dateTime = new DateTime(); [EOL] DateTime result = dateTime.minusHours(-1); [EOL] assertNotSame("Expected a different instance when subtracting negative hours", dateTime, result); [EOL] assertTrue("Resulting time should be after original time when subtracting negative hours", result.isAfter(dateTime)); [EOL] }
public void testMinusHours_PositiveHours() { [EOL] DateTime dateTime = new DateTime(); [EOL] DateTime result = dateTime.minusHours(1); [EOL] assertNotSame("Expected a different instance when subtracting positive hours", dateTime, result); [EOL] assertTrue("Resulting time should be before original time when subtracting positive hours", result.isBefore(dateTime)); [EOL] }
public void testMinusMinutes_Zero() { [EOL] DateTime dateTime = new DateTime(); [EOL] DateTime result = dateTime.minusMinutes(0); [EOL] assertSame("Should return the same DateTime object for zero minutes subtraction", dateTime, result); [EOL] }
public void testMinusMinutes_Positive() { [EOL] DateTime dateTime = new DateTime(); [EOL] DateTime result = dateTime.minusMinutes(5); [EOL] assertNotSame("Should return a different DateTime object for non-zero minutes subtraction", dateTime, result); [EOL] assertEquals("The time should be 5 minutes less than the original", dateTime.getMillis() - 5 * 60 * 1000, result.getMillis()); [EOL] }
public void testMinusMinutes_Negative() { [EOL] DateTime dateTime = new DateTime(); [EOL] DateTime result = dateTime.minusMinutes(-5); [EOL] assertNotSame("Should return a different DateTime object for negative minutes subtraction", dateTime, result); [EOL] assertEquals("The time should be 5 minutes more than the original", dateTime.getMillis() + 5 * 60 * 1000, result.getMillis()); [EOL] }
public void testToLocalDateTime() { [EOL] DateTime dateTime = new DateTime(2023, 4, 1, 12, 0, 0, 0); [EOL] LocalDateTime localDateTime = dateTime.toLocalDateTime(); [EOL] assertEquals(2023, localDateTime.getYear()); [EOL] assertEquals(4, localDateTime.getMonthOfYear()); [EOL] assertEquals(1, localDateTime.getDayOfMonth()); [EOL] assertEquals(12, localDateTime.getHourOfDay()); [EOL] assertEquals(0, localDateTime.getMinuteOfHour()); [EOL] assertEquals(0, localDateTime.getSecondOfMinute()); [EOL] assertEquals(0, localDateTime.getMillisOfSecond()); [EOL] assertEquals(dateTime.getChronology(), localDateTime.getChronology()); [EOL] }
public void testToLocalTime() { [EOL] DateTime dateTime = new DateTime(2023, 4, 1, 10, 0, 0, 0); [EOL] LocalTime expected = new LocalTime(10, 0, 0, 0); [EOL] LocalTime actual = dateTime.toLocalTime(); [EOL] assertEquals(expected, actual); [EOL] }
public void testWithWeekOfWeekyear_ValidWeek() { [EOL] DateTime dateTime = new DateTime(); [EOL] int validWeek = 1; // Assuming 1 is within the valid range for week of year [EOL] DateTime updatedDateTime = dateTime.withWeekOfWeekyear(validWeek); [EOL] assertEquals(validWeek, updatedDateTime.getWeekOfWeekyear()); [EOL] }
public void testWithWeekOfWeekyear_InvalidWeek() { [EOL] DateTime dateTime = new DateTime(); [EOL] int invalidWeek = -1; // Assuming -1 is an invalid week of year [EOL] try { [EOL] dateTime.withWeekOfWeekyear(invalidWeek); [EOL] fail("Should have thrown IllegalArgumentException for invalid week of year"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testWithDayOfMonth_ValidDay() { [EOL] DateTime dateTime = new DateTime(); [EOL] int dayOfMonth = 15; // Assuming 15 is a valid day for the current month [EOL] DateTime updatedDateTime = dateTime.withDayOfMonth(dayOfMonth); [EOL] assertEquals(dayOfMonth, updatedDateTime.getDayOfMonth()); [EOL] }
public void testWithDayOfMonth_InvalidDay() { [EOL] DateTime dateTime = new DateTime(); [EOL] int dayOfMonth = 32; // Assuming 32 is an invalid day for any month [EOL] try { [EOL] dateTime.withDayOfMonth(dayOfMonth); [EOL] fail("Should have thrown an IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testWithDayOfWeek_ValidDay() { [EOL] DateTime dateTime = new DateTime(); [EOL] int dayOfWeek = 1; // Assuming 1 is a valid day of the week [EOL] DateTime result = dateTime.withDayOfWeek(dayOfWeek); [EOL] assertEquals(dayOfWeek, result.getDayOfWeek()); [EOL] }
public void testWithDayOfWeek_InvalidDay() { [EOL] DateTime dateTime = new DateTime(); [EOL] int dayOfWeek = 8; // Assuming the week has only 7 days [EOL] try { [EOL] dateTime.withDayOfWeek(dayOfWeek); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testWithMinuteOfHour_ValidMinute() { [EOL] DateTime dateTime = new DateTime(); [EOL] int validMinute = 30; [EOL] DateTime updatedDateTime = dateTime.withMinuteOfHour(validMinute); [EOL] assertEquals(validMinute, updatedDateTime.getMinuteOfHour()); [EOL] }
public void testWithMinuteOfHour_MinuteTooLow() { [EOL] DateTime dateTime = new DateTime(); [EOL] int invalidMinute = -1; [EOL] try { [EOL] dateTime.withMinuteOfHour(invalidMinute); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testWithMinuteOfHour_MinuteTooHigh() { [EOL] DateTime dateTime = new DateTime(); [EOL] int invalidMinute = 60; [EOL] try { [EOL] dateTime.withMinuteOfHour(invalidMinute); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testYearOfEra() { [EOL] Time time = new Time(); // Assuming Time is the class where yearOfEra method is defined [EOL] Property result = time.yearOfEra(); [EOL] assertNotNull(result); [EOL] assertEquals(result.getField(), time.getChronology().yearOfEra()); [EOL] }
public void testYearProperty() { [EOL] Time time = new Time(); // Assuming Time is the class where the year method is defined [EOL] Property yearProperty = time.year(); [EOL] assertNotNull("Year property should not be null", yearProperty); [EOL] assertEquals("Year property should be of type Year", Year.class, yearProperty.getField().getClass()); [EOL] }
public void testHourOfDayProperty() { [EOL] DateTime dateTime = new DateTime(); [EOL] Property property = dateTime.hourOfDay(); [EOL] assertNotNull(property); [EOL] assertEquals(dateTime.getChronology().hourOfDay(), property.getField()); [EOL] assertEquals(dateTime.getHourOfDay(), property.get()); [EOL] }
public void testMinuteOfDay() { [EOL] Time time = new Time(); [EOL] Property property = time.minuteOfDay(); [EOL] assertNotNull(property); [EOL] assertEquals(time.getChronology().minuteOfDay(), property.getField()); [EOL] assertEquals(time, property.getReadableInstant()); [EOL] }
public void testMinuteOfHour() { [EOL] DateTime dateTime = new DateTime(); [EOL] Property property = dateTime.minuteOfHour(); [EOL] assertNotNull(property); [EOL] assertEquals(dateTime.getChronology().minuteOfHour().get(), property.get()); [EOL] }
public void testSecondOfMinute() { [EOL] Time time = new Time(); [EOL] Property property = time.secondOfMinute(); [EOL] assertNotNull(property); [EOL] assertEquals(time.getChronology().secondOfMinute(), property.getField()); [EOL] assertEquals(time, property.getReadableInstant()); [EOL] }
public void testMillisOfSecond() { [EOL] DateTime testDateTime = new DateTime(); [EOL] Property property = testDateTime.millisOfSecond(); [EOL] assertNotNull(property); [EOL] assertEquals(testDateTime.getChronology().millisOfSecond(), property.getField()); [EOL] assertEquals(testDateTime.getMillisOfSecond(), property.get()); [EOL] }
public void testPropertyWithValidArguments() { [EOL] DateTime instant = new DateTime(); [EOL] DateTimeField field = DateTimeFieldType.dayOfMonth().getField(DateTimeZone.UTC); [EOL] Property property = new Property(instant, field); [EOL] assertNotNull(property); [EOL] assertEquals(instant, property.iInstant); [EOL] assertEquals(field, property.iField); [EOL] }
public void testWriteObject() throws IOException { [EOL] ByteArrayOutputStream baos = new ByteArrayOutputStream(); [EOL] ObjectOutputStream oos = new ObjectOutputStream(baos); [EOL] YourClass instance = new YourClass(); [EOL] instance.writeObject(oos); [EOL] oos.close(); [EOL] byte[] bytes = baos.toByteArray(); [EOL] assertTrue(bytes.length > 0); [EOL] }
public void testReadObjectWithValidDateTimeAndFieldType() throws IOException, ClassNotFoundException { [EOL] ByteArrayOutputStream baos = new ByteArrayOutputStream(); [EOL] ObjectOutputStream oos = new ObjectOutputStream(baos); [EOL] DateTime instant = new DateTime(); [EOL] DateTimeFieldType type = DateTimeFieldType.dayOfMonth(); [EOL] oos.writeObject(instant); [EOL] oos.writeObject(type); [EOL] oos.close(); [EOL] ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(baos.toByteArray())); [EOL] readObject(ois); // Assuming this method is accessible within the test class [EOL] assertNotNull(iInstant); [EOL] assertNotNull(iField); [EOL] assertEquals(instant, iInstant); [EOL] assertEquals(type.getField(instant.getChronology()), iField); [EOL] }
public void testAddWrapFieldToCopy_Zero() { [EOL] DateTime instant = new DateTime(); // Replace with actual initialization [EOL] DateTimeField field = instant.getField(); // Replace with actual field retrieval [EOL] DateTime result = instant.addWrapFieldToCopy(0); [EOL] assertEquals(instant, result); [EOL] } [EOL] public void testAddWrapFieldToCopy_Positive() { [EOL] DateTime instant = new DateTime(); // Replace with actual initialization [EOL] DateTimeField field = instant.getField(); // Replace with actual field retrieval [EOL] int valueToAdd = 5; // Replace with a meaningful positive value [EOL] DateTime result = instant.addWrapFieldToCopy(valueToAdd); [EOL] assertNotEquals(instant, result); [EOL] assertEquals(instant.getMillis() + valueToAdd, result.getMillis()); [EOL] } [EOL] public void testAddWrapFieldToCopy_Negative() { [EOL] DateTime instant = new DateTime(); // Replace with actual initialization [EOL] DateTimeField field = instant.getField(); // Replace with actual field retrieval [EOL] int valueToSubtract = -5; // Replace with a meaningful negative value [EOL] DateTime result = instant.addWrapFieldToCopy(valueToSubtract); [EOL] assertNotEquals(instant, result); [EOL] assertEquals(instant.getMillis() - valueToSubtract, result.getMillis()); [EOL] }
public void testSetCopy_ValidValue() { [EOL] DateTime instant = new DateTime(); [EOL] int validValue = 5; // Assuming 5 is a valid value for the field [EOL] DateTime result = instant.setCopy(validValue); [EOL] assertNotNull(result); [EOL] assertNotSame(instant, result); [EOL] assertEquals(validValue, result.get(iField.getType())); [EOL] }
public void testSetCopy_InvalidValue() { [EOL] DateTime instant = new DateTime(); [EOL] int invalidValue = Integer.MAX_VALUE; // Assuming this is an invalid value [EOL] try { [EOL] instant.setCopy(invalidValue); [EOL] fail("Should have thrown an exception for invalid value"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testSetCopyWithValidTextAndLocale() { [EOL] DateTime instant = new DateTime(); // Assuming DateTime is a valid class and has a constructor [EOL] DateTimeField field = instant.getField(); // Assuming getField() is a valid method that returns a DateTimeField [EOL] String validText = "some valid text representation of a date/time"; // Replace with actual valid text for the field [EOL] Locale locale = Locale.ENGLISH; // Use a specific locale [EOL] DateTime result = instant.setCopy(validText, locale); [EOL] }
public void testSetCopyWithInvalidText() { [EOL] DateTime instant = new DateTime(); // Assuming DateTime is a valid class and has a constructor [EOL] DateTimeField field = instant.getField(); // Assuming getField() is a valid method that returns a DateTimeField [EOL] String invalidText = "invalid text"; // Text that would not be valid for the field [EOL] Locale locale = Locale.ENGLISH; // Use a specific locale [EOL] try { [EOL] instant.setCopy(invalidText, locale); [EOL] fail("Should have thrown an exception for invalid text"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testSetCopyWithNullText() { [EOL] DateTime instant = new DateTime(); // Assuming DateTime is a valid class and has a constructor [EOL] Locale locale = Locale.ENGLISH; // Use a specific locale [EOL] try { [EOL] instant.setCopy(null, locale); [EOL] fail("Should have thrown an exception for null text"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testSetCopyWithNullLocale() { [EOL] DateTime instant = new DateTime(); // Assuming DateTime is a valid class and has a constructor [EOL] String validText = "some valid text representation of a date/time"; // Replace with actual valid text for the field [EOL] DateTime result = instant.setCopy(validText, null); [EOL] }
public void testSetCopyWithValidText() { [EOL] DateTime dateTime = new DateTime(); [EOL] String validText = "2023-04-01T00:00:00.000Z"; [EOL] DateTime result = dateTime.setCopy(validText); [EOL] assertNotNull(result); [EOL] assertNotSame(dateTime, result); [EOL] }
public void testSetCopyWithNullText() { [EOL] DateTime dateTime = new DateTime(); [EOL] String nullText = null; [EOL] try { [EOL] dateTime.setCopy(nullText); [EOL] fail("Should have thrown IllegalArgumentException for null text"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testRoundHalfFloorCopy_NewMillis() { [EOL] DateTime instant = new DateTime(); [EOL] DateTimeField field = instant.getChronology().secondOfMinute(); [EOL] DateTime rounded = new DateTime(instant.getMillis(), instant.getChronology()).roundHalfFloorCopy(); [EOL] long expectedMillis = field.roundHalfFloor(instant.getMillis()); [EOL] assertEquals(expectedMillis, rounded.getMillis()); [EOL] }
public void testRoundHalfFloorCopy_SameMillis() { [EOL] DateTime instant = new DateTime(); [EOL] DateTimeField field = instant.getChronology().secondOfMinute(); [EOL] long currentMillis = instant.getMillis(); [EOL] long roundedMillis = field.roundHalfFloor(currentMillis); [EOL] if (currentMillis == roundedMillis) { [EOL] DateTime rounded = instant.roundHalfFloorCopy(); [EOL] assertEquals(instant, rounded); [EOL] } [EOL] }
public void testRoundHalfCeilingCopy() { [EOL] DateTime instant = new DateTime(); [EOL] DateTimeField field = instant.getChronology().secondOfMinute(); [EOL] DateTime rounded = new DateTime(instant.getMillis(), instant.getChronology()).withMillis(field.roundHalfCeiling(instant.getMillis())); [EOL] assertEquals(rounded, instant.roundHalfCeilingCopy()); [EOL] }
public void testPeriodFormatterConstructorWithAllNulls() { [EOL] PeriodFormatter formatter = new PeriodFormatter(null, null, null, null); [EOL] assertNull(formatter.iPrinter); [EOL] assertNull(formatter.iParser); [EOL] assertNull(formatter.iLocale); [EOL] assertNull(formatter.iParseType); [EOL] }
public void testPeriodFormatterConstructorWithNonNullPrinter() { [EOL] PeriodPrinter printer = mock(PeriodPrinter.class); [EOL] PeriodFormatter formatter = new PeriodFormatter(printer, null, null, null); [EOL] assertNotNull(formatter.iPrinter); [EOL] assertNull(formatter.iParser); [EOL] assertNull(formatter.iLocale); [EOL] assertNull(formatter.iParseType); [EOL] }
public void testPeriodFormatterConstructorWithNonNullParser() { [EOL] PeriodParser parser = mock(PeriodParser.class); [EOL] PeriodFormatter formatter = new PeriodFormatter(null, parser, null, null); [EOL] assertNull(formatter.iPrinter); [EOL] assertNotNull(formatter.iParser); [EOL] assertNull(formatter.iLocale); [EOL] assertNull(formatter.iParseType); [EOL] }
public void testPeriodFormatterConstructorWithNonNullLocale() { [EOL] Locale locale = new Locale("en"); [EOL] PeriodFormatter formatter = new PeriodFormatter(null, null, locale, null); [EOL] assertNull(formatter.iPrinter); [EOL] assertNull(formatter.iParser); [EOL] assertNotNull(formatter.iLocale); [EOL] assertNull(formatter.iParseType); [EOL] }
public void testPeriodFormatterConstructorWithNonNullType() { [EOL] PeriodType type = PeriodType.standard(); [EOL] PeriodFormatter formatter = new PeriodFormatter(null, null, null, type); [EOL] assertNull(formatter.iPrinter); [EOL] assertNull(formatter.iParser); [EOL] assertNull(formatter.iLocale); [EOL] assertNotNull(formatter.iParseType); [EOL] }
public void testWithLocale_SameLocaleReturnsSameFormatter() { [EOL] Locale locale = Locale.ENGLISH; [EOL] PeriodFormatter formatter = new PeriodFormatter(null, null, locale, null); [EOL] PeriodFormatter result = formatter.withLocale(Locale.ENGLISH); [EOL] assertSame(formatter, result); [EOL] }
public void testWithLocale_DifferentLocaleReturnsNewFormatter() { [EOL] Locale initialLocale = Locale.ENGLISH; [EOL] Locale newLocale = Locale.FRENCH; [EOL] PeriodFormatter formatter = new PeriodFormatter(null, null, initialLocale, null); [EOL] PeriodFormatter result = formatter.withLocale(newLocale); [EOL] assertNotSame(formatter, result); [EOL] assertEquals(newLocale, result.getLocale()); [EOL] }
public void testWithLocale_NullLocaleReturnsNewFormatter() { [EOL] Locale initialLocale = Locale.ENGLISH; [EOL] PeriodFormatter formatter = new PeriodFormatter(null, null, initialLocale, null); [EOL] PeriodFormatter result = formatter.withLocale(null); [EOL] assertNotSame(formatter, result); [EOL] assertNull(result.getLocale()); [EOL] }
public Locale getLocale() { [EOL] return iLocale; [EOL] }
public void testPartialConstructor() { [EOL] Partial partial = new Partial(); [EOL] assertNull(partial.getChronology()); [EOL] }
public void testPartialConstructor_NullTypes() { [EOL] try { [EOL] new Partial(null, new int[]{1, 2, 3}, null); [EOL] fail("Should have thrown IllegalArgumentException for null types array"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Types array must not be null", e.getMessage()); [EOL] } [EOL] }
public void testPartialConstructor_NullValues() { [EOL] try { [EOL] new Partial(new DateTimeFieldType[]{DateTimeFieldType.year(), DateTimeFieldType.monthOfYear()}, null, null); [EOL] fail("Should have thrown IllegalArgumentException for null values array"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Values array must not be null", e.getMessage()); [EOL] } [EOL] }
public void testPartialConstructor_InequalLengthArrays() { [EOL] try { [EOL] new Partial(new DateTimeFieldType[]{DateTimeFieldType.year()}, new int[]{1, 2}, null); [EOL] fail("Should have thrown IllegalArgumentException for values array not matching types array length"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Values array must be the same length as the types array", e.getMessage()); [EOL] } [EOL] }
public void testPartialConstructor_EmptyArrays() { [EOL] Partial partial = new Partial(new DateTimeFieldType[0], new int[0], null); [EOL] assertNotNull(partial); [EOL] }
public void testPartialConstructor_NullTypeElement() { [EOL] try { [EOL] new Partial(new DateTimeFieldType[]{null}, new int[]{1}, null); [EOL] fail("Should have thrown IllegalArgumentException for null element in types array"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertTrue(e.getMessage().contains("Types array must not contain null: index 0")); [EOL] } [EOL] }
public void testPartialConstructor_UnsupportedType() { [EOL] DateTimeFieldType unsupportedType = DateTimeFieldType.unsupported(); [EOL] try { [EOL] new Partial(new DateTimeFieldType[]{unsupportedType, unsupportedType}, new int[]{1, 2}, null); [EOL] fail("Should have thrown IllegalArgumentException for unsupported DateTimeFieldType"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertTrue(e.getMessage().contains("Types array must not contain duplicate unsupported:")); [EOL] } [EOL] }
public void testPartialConstructor_TypesNotInOrder() { [EOL] try { [EOL] new Partial(new DateTimeFieldType[]{DateTimeFieldType.hourOfDay(), DateTimeFieldType.dayOfMonth()}, new int[]{1, 2}, null); [EOL] fail("Should have thrown IllegalArgumentException for types not in order"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertTrue(e.getMessage().contains("Types array must be in order largest-smallest:")); [EOL] } [EOL] }
public void testPartialConstructor_DuplicateTypes() { [EOL] try { [EOL] new Partial(new DateTimeFieldType[]{DateTimeFieldType.dayOfMonth(), DateTimeFieldType.dayOfMonth()}, new int[]{1, 2}, null); [EOL] fail("Should have thrown IllegalArgumentException for duplicate types"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertTrue(e.getMessage().contains("Types array must not contain duplicate:")); [EOL] } [EOL] }
public void testWithChronologyRetainFields_SameChronology() { [EOL] Chronology initialChronology = ISOChronology.getInstance(); [EOL] Partial partial = new Partial(initialChronology, new int[]{}, new int[]{}); [EOL] Partial result = partial.withChronologyRetainFields(initialChronology); [EOL] assertSame("Should be the same object as the chronology is the same", partial, result); [EOL] }
public void testWithChronologyRetainFields_DifferentChronology() { [EOL] Chronology initialChronology = ISOChronology.getInstance(); [EOL] Partial partial = new Partial(initialChronology, new int[]{}, new int[]{}); [EOL] Chronology newChronology = GregorianChronology.getInstance(); [EOL] Partial result = partial.withChronologyRetainFields(newChronology); [EOL] assertNotSame("Should not be the same object as the chronology is different", partial, result); [EOL] assertEquals("The chronology should be withUTC", newChronology.withUTC(), result.getChronology()); [EOL] }
public void testWithFieldTypeNull() { [EOL] try { [EOL] Partial partial = new Partial(); [EOL] partial.with(null, 1); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public void testWithFieldTypeNotInPartial() { [EOL] DateTimeFieldType fieldType = DateTimeFieldType.dayOfMonth(); [EOL] Partial partial = new Partial(); [EOL] int value = 10; [EOL] Partial result = partial.with(fieldType, value); [EOL] assertNotNull(result); [EOL] assertEquals(value, result.get(fieldType)); [EOL] }
public void testWithFieldTypeInPartialSameValue() { [EOL] DateTimeFieldType fieldType = DateTimeFieldType.dayOfMonth(); [EOL] int value = 10; [EOL] Partial partial = new Partial(new DateTimeFieldType[]{fieldType}, new int[]{value}); [EOL] Partial result = partial.with(fieldType, value); [EOL] assertSame(partial, result); [EOL] }
public void testWithFieldTypeInPartialDifferentValue() { [EOL] DateTimeFieldType fieldType = DateTimeFieldType.dayOfMonth(); [EOL] int value = 10; [EOL] Partial partial = new Partial(new DateTimeFieldType[]{fieldType}, new int[]{5}); [EOL] Partial result = partial.with(fieldType, value); [EOL] assertNotNull(result); [EOL] assertEquals(value, result.get(fieldType)); [EOL] }
public void testWithFieldAdded_ZeroAmount() { [EOL] Partial partial = createPartial(); // Assume createPartial() properly initializes a Partial object [EOL] DurationFieldType fieldType = DurationFieldType.minutes(); // Assume this is a supported field type [EOL] Partial result = partial.withFieldAdded(fieldType, 0); [EOL] assertEquals(partial, result); [EOL] }
public void testWithFieldAdded_NonZeroAmount() { [EOL] Partial partial = createPartial(); // Assume createPartial() properly initializes a Partial object [EOL] DurationFieldType fieldType = DurationFieldType.minutes(); // Assume this is a supported field type [EOL] int amountToAdd = 5; [EOL] Partial result = partial.withFieldAdded(fieldType, amountToAdd); [EOL] assertNotEquals(partial, result); [EOL] }
public void testWithFieldAdded_UnsupportedFieldType() { [EOL] Partial partial = createPartial(); // Assume createPartial() properly initializes a Partial object [EOL] DurationFieldType fieldType = DurationFieldType.years(); // Assume this is an unsupported field type [EOL] int amountToAdd = 5; [EOL] try { [EOL] partial.withFieldAdded(fieldType, amountToAdd); [EOL] fail("Should have thrown an IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testWithFieldAddWrapped_ZeroAmount() { [EOL] Partial partial = createPartial(); // You need to implement createPartial to create an instance of Partial [EOL] DurationFieldType fieldType = DurationFieldType.minutes(); // Use the correct method to obtain a DurationFieldType [EOL] Partial result = partial.withFieldAddWrapped(fieldType, 0); [EOL] assertEquals(partial, result); [EOL] }
public void testWithFieldAddWrapped_NonZeroAmount() { [EOL] Partial partial = createPartial(); // You need to implement createPartial to create an instance of Partial [EOL] DurationFieldType fieldType = DurationFieldType.minutes(); // Use the correct method to obtain a DurationFieldType [EOL] int amount = 5; [EOL] Partial result = partial.withFieldAddWrapped(fieldType, amount); [EOL] assertNotEquals(partial, result); [EOL] }
public void testIsMatch_WithMatchingInstant() { [EOL] ReadableInstant matchingInstant = // ... create an instant that matches iTypes and iValues [EOL] boolean result = isMatch(matchingInstant); [EOL] assertTrue(result); [EOL] }
public void testIsMatch_WithNonMatchingInstant() { [EOL] ReadableInstant nonMatchingInstant = // ... create an instant that does not match iTypes and/or iValues [EOL] boolean result = isMatch(nonMatchingInstant); [EOL] assertFalse(result); [EOL] }
public void testGetFormatterWithEmptySize() { [EOL] when(instance.size()).thenReturn(0); // Mocking the size method to return 0 [EOL] DateTimeFormatter result = instance.getFormatter(); [EOL] assertNull(result); // Asserting that the result should be null when size is 0 [EOL] }
public void testGetFormatterWithNonEmptySizeAndValidFields() { [EOL] when(instance.size()).thenReturn(2); // Mocking the size method to return a non-zero value [EOL] when(instance.iTypes).thenReturn(new DateTimeFieldType[]{DateTimeFieldType.year(), DateTimeFieldType.monthOfYear()}); [EOL] DateTimeFormatter result = instance.getFormatter(); [EOL] assertNotNull(result); // Asserting that the result should not be null when size is non-zero [EOL] }
public void testGetFormatterWithNonEmptySizeAndInvalidFields() { [EOL] when(instance.size()).thenReturn(2); // Mocking the size method to return a non-zero value [EOL] when(instance.iTypes).thenReturn(new DateTimeFieldType[]{DateTimeFieldType.halfdayOfDay(), DateTimeFieldType.clockhourOfDay()}); [EOL] DateTimeFormatter result = instance.getFormatter(); [EOL] assertNull(result); // Asserting that the result should be null when an exception is caught [EOL] }
public void testToStringWithNullFormatterArray() { [EOL] this.iFormatter = null; [EOL] String result = this.toString(); [EOL] assertEquals("Expected result from toStringList", toStringList(), result); [EOL] }
public void testToStringWithNonNullFormatterArrayAndNullSecondElement() { [EOL] this.iFormatter = new DateTimeFormatter[2]; [EOL] this.iFormatter[1] = null; [EOL] String result = this.toString(); [EOL] assertEquals("Expected result from toStringList", toStringList(), result); [EOL] }
public void testToStringWithNonNullFormatterArrayAndNonNullSecondElement() { [EOL] DateTimeFormatter formatter = new DateTimeFormatter(); [EOL] this.iFormatter = new DateTimeFormatter[]{null, formatter}; [EOL] when(formatter.print(this)).thenReturn("Formatted String"); [EOL] String result = this.toString(); [EOL] assertEquals("Formatted String", result); [EOL] }
public void testBaseDurationWithPositiveDuration() { [EOL] long duration = 1000L; [EOL] BaseDuration baseDuration = new BaseDuration(duration); [EOL] assertEquals(1000L, baseDuration.getMillis()); [EOL] }
public void testBaseDurationWithZeroDuration() { [EOL] long duration = 0L; [EOL] BaseDuration baseDuration = new BaseDuration(duration); [EOL] assertEquals(0L, baseDuration.getMillis()); [EOL] }
public void testBaseDurationWithNegativeDuration() { [EOL] long duration = -1000L; [EOL] BaseDuration baseDuration = new BaseDuration(duration); [EOL] assertEquals(-1000L, baseDuration.getMillis()); [EOL] }
public void testBaseDuration_WithSameStartAndEnd() { [EOL] ReadableInstant start = new Instant(); [EOL] ReadableInstant end = start; [EOL] BaseDuration duration = new BaseDuration(start, end); [EOL] assertEquals(0L, duration.getMillis()); [EOL] }
public void testBaseDuration_WithDifferentStartAndEnd() { [EOL] ReadableInstant start = new Instant(0L); [EOL] ReadableInstant end = new Instant(1000L); [EOL] BaseDuration duration = new BaseDuration(start, end); [EOL] assertEquals(1000L, duration.getMillis()); [EOL] }
public void testBaseDurationWithNull() { [EOL] try { [EOL] new BaseDuration(null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] } [EOL] public void testBaseDurationWithValidDuration() { [EOL] DurationConverter mockConverter = mock(DurationConverter.class); [EOL] when(mockConverter.getDurationMillis(any())).thenReturn(1000L); [EOL] ConverterManager mockManager = mock(ConverterManager.class); [EOL] when(mockManager.getDurationConverter(any())).thenReturn(mockConverter); [EOL] setStatic(ConverterManager.class, "INSTANCE", mockManager); [EOL] BaseDuration duration = new BaseDuration(new Object()); [EOL] assertEquals(1000L, duration.iMillis); [EOL] }

public void testGetMillis() { [EOL] long expectedMillis = 123456789L; // Replace with an appropriate value [EOL] Time time = new Time(expectedMillis); // Assuming there is a constructor that sets iMillis [EOL] long actualMillis = time.getMillis(); [EOL] assertEquals("The getMillis method should return the correct number of milliseconds", expectedMillis, actualMillis); [EOL] }
public void testToPeriodToWithNullEndInstant() { [EOL] DateTime start = new DateTime(); [EOL] try { [EOL] start.toPeriodTo(null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testToPeriodToWithNonNullEndInstant() { [EOL] DateTime start = new DateTime(); [EOL] ReadableInstant endInstant = new DateTime().plusHours(1); [EOL] Period result = start.toPeriodTo(endInstant); [EOL] assertNotNull("Period should not be null", result); [EOL] assertEquals("Period should be one hour", Hours.ONE.toStandardDuration().getMillis(), result.toDurationFrom(start).getMillis()); [EOL] }
public void testToIntervalToWithNullEndInstant() { [EOL] ReadableInstant startInstant = new DateTime(); [EOL] Interval result = startInstant.toIntervalTo(null); [EOL] assertNull("Interval end should be null", result.getEnd()); [EOL] }
public void testToIntervalToWithNonNullEndInstant() { [EOL] ReadableInstant startInstant = new DateTime(); [EOL] ReadableInstant endInstant = new DateTime().plusHours(1); [EOL] Interval result = startInstant.toIntervalTo(endInstant); [EOL] assertNotNull("Interval should not be null", result); [EOL] assertEquals("Interval start should be equal to startInstant", startInstant, result.getStart()); [EOL] assertEquals("Interval end should be equal to endInstant", endInstant, result.getEnd()); [EOL] }
public void testYearsZero() { [EOL] Years result = Time.years(0); [EOL] assertSame(Years.ZERO, result); [EOL] }
public void testYearsOne() { [EOL] Years result = Time.years(1); [EOL] assertSame(Years.ONE, result); [EOL] }
public void testYearsTwo() { [EOL] Years result = Time.years(2); [EOL] assertSame(Years.TWO, result); [EOL] }
public void testYearsThree() { [EOL] Years result = Time.years(3); [EOL] assertSame(Years.THREE, result); [EOL] }
public void testYearsMaxValue() { [EOL] Years result = Time.years(Integer.MAX_VALUE); [EOL] assertSame(Years.MAX_VALUE, result); [EOL] }
public void testYearsMinValue() { [EOL] Years result = Time.years(Integer.MIN_VALUE); [EOL] assertSame(Years.MIN_VALUE, result); [EOL] }
public void testYearsDefault() { [EOL] int arbitraryYears = 10; [EOL] Years result = Time.years(arbitraryYears); [EOL] assertNotNull(result); [EOL] assertEquals(arbitraryYears, result.getYears()); [EOL] }
public void testParseYearsWithNullInput() { [EOL] Years result = Time.parseYears(null); [EOL] assertEquals(Years.ZERO, result); [EOL] }
public void testParseYearsWithValidInput() { [EOL] Years expected = Years.years(5); [EOL] Years result = Time.parseYears("P5Y"); [EOL] assertEquals(expected, result); [EOL] }
public void testParseYearsWithInvalidInput() { [EOL] try { [EOL] Time.parseYears("InvalidInput"); [EOL] fail("Should have thrown an exception for invalid input"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testMultipliedBy_Positive() { [EOL] Years years = Years.years(2); [EOL] Years result = years.multipliedBy(3); [EOL] assertEquals(Years.years(6), result); [EOL] }
public void testMultipliedBy_Negative() { [EOL] Years years = Years.years(2); [EOL] Years result = years.multipliedBy(-3); [EOL] assertEquals(Years.years(-6), result); [EOL] }
public void testMultipliedBy_Zero() { [EOL] Years years = Years.years(2); [EOL] Years result = years.multipliedBy(0); [EOL] assertEquals(Years.years(0), result); [EOL] }
public void testMultipliedBy_One() { [EOL] Years years = Years.years(2); [EOL] Years result = years.multipliedBy(1); [EOL] assertEquals(Years.years(2), result); [EOL] }
public void testWithDurationAdded_ZeroDuration() { [EOL] Instant instant = Instant.now(); [EOL] Instant result = instant.withDurationAdded(0, 1); [EOL] assertEquals(instant, result); [EOL] }
public void testWithDurationAdded_ZeroScalar() { [EOL] Instant instant = Instant.now(); [EOL] Instant result = instant.withDurationAdded(10, 0); [EOL] assertEquals(instant, result); [EOL] }
public void testWithDurationAdded_NonZeroDurationAndScalar() { [EOL] Instant instant = Instant.now(); [EOL] long durationToAdd = 10; [EOL] int scalar = 2; [EOL] Instant expected = instant.plus(Duration.ofMillis(durationToAdd * scalar)); [EOL] Instant result = instant.withDurationAdded(durationToAdd, scalar); [EOL] assertEquals(expected, result); [EOL] }
public void testPlus_withNullDuration() { [EOL] Instant instant = Instant.now(); [EOL] Instant result = instant.plus(null); [EOL] assertEquals(instant, result); [EOL] }
public void testPlus_withZeroDuration() { [EOL] Instant instant = Instant.now(); [EOL] Duration zeroDuration = Duration.ZERO; [EOL] Instant result = instant.plus(zeroDuration); [EOL] assertEquals(instant, result); [EOL] }
public void testPlus_withPositiveDuration() { [EOL] Instant instant = Instant.now(); [EOL] Duration positiveDuration = Duration.ofSeconds(10); [EOL] Instant expected = instant.plusSeconds(10); [EOL] Instant result = instant.plus(positiveDuration); [EOL] assertEquals(expected, result); [EOL] }
public void testPlus_withNegativeDuration() { [EOL] Instant instant = Instant.now(); [EOL] Duration negativeDuration = Duration.ofSeconds(-10); [EOL] Instant expected = instant.minusSeconds(10); [EOL] Instant result = instant.plus(negativeDuration); [EOL] assertEquals(expected, result); [EOL] }
public void testToMutableDateTime() { [EOL] DateTime dateTime = new DateTime(); [EOL] MutableDateTime mutableDateTime = dateTime.toMutableDateTime(); [EOL] assertNotNull(mutableDateTime); [EOL] assertEquals(dateTime.getMillis(), mutableDateTime.getMillis()); [EOL] assertEquals(ISOChronology.getInstance(), mutableDateTime.getChronology()); [EOL] }
public void testToMutableDateTimeISO() { [EOL] YourClass instance = new YourClass(); // Replace YourClass with the actual class name [EOL] MutableDateTime expected = instance.toMutableDateTime(); [EOL] MutableDateTime actual = instance.toMutableDateTimeISO(); [EOL] assertEquals(expected, actual); [EOL] }
public void testFromDateFieldsWithNullDate() { [EOL] try { [EOL] LocalDate.fromDateFields(null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("The date must not be null", e.getMessage()); [EOL] } [EOL] }
public void testFromDateFieldsWithNegativeTime() { [EOL] Date date = new Date(-1); // Date before epoch [EOL] LocalDate localDate = LocalDate.fromDateFields(date); [EOL] assertNotNull(localDate); [EOL] }
public void testFromDateFieldsWithPositiveTime() { [EOL] Date date = new Date(1); // Date after epoch [EOL] LocalDate localDate = LocalDate.fromDateFields(date); [EOL] assertNotNull(localDate); [EOL] assertEquals(1970, localDate.getYear()); [EOL] assertEquals(1, localDate.getMonthOfYear()); [EOL] assertEquals(1, localDate.getDayOfMonth()); [EOL] }
public void testLocalDateWithNullChronology() { [EOL] long instant = System.currentTimeMillis(); [EOL] LocalDate date = new LocalDate(instant, null); [EOL] assertNotNull(date); [EOL] }
public void testLocalDateWithSpecificChronology() { [EOL] long instant = System.currentTimeMillis(); [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] LocalDate date = new LocalDate(instant, chronology); [EOL] assertNotNull(date); [EOL] assertEquals(chronology.withUTC(), date.getChronology()); [EOL] }
public void testLocalDateWithDifferentChronologyAndZone() { [EOL] long instant = System.currentTimeMillis(); [EOL] Chronology chronology = ISOChronology.getInstance(DateTimeZone.forID("Europe/Paris")); [EOL] LocalDate date = new LocalDate(instant, chronology); [EOL] assertNotNull(date); [EOL] assertEquals(ISOChronology.getInstanceUTC(), date.getChronology()); [EOL] }
public void testLocalDateWithValidInput() { [EOL] int year = 2021; [EOL] int monthOfYear = 5; [EOL] int dayOfMonth = 20; [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] LocalDate localDate = new LocalDate(year, monthOfYear, dayOfMonth, chronology); [EOL] assertEquals(year, localDate.getYear()); [EOL] assertEquals(monthOfYear, localDate.getMonthOfYear()); [EOL] assertEquals(dayOfMonth, localDate.getDayOfMonth()); [EOL] assertEquals(chronology, localDate.getChronology()); [EOL] }
public void testLocalDateWithNullChronology() { [EOL] int year = 2021; [EOL] int monthOfYear = 5; [EOL] int dayOfMonth = 20; [EOL] Chronology chronology = null; [EOL] LocalDate localDate = new LocalDate(year, monthOfYear, dayOfMonth, chronology); [EOL] assertNotNull(localDate.getChronology()); [EOL] assertEquals(ISOChronology.getInstanceUTC(), localDate.getChronology()); [EOL] assertEquals(year, localDate.getYear()); [EOL] assertEquals(monthOfYear, localDate.getMonthOfYear()); [EOL] assertEquals(dayOfMonth, localDate.getDayOfMonth()); [EOL] }
public void testGetLocalMillis() { [EOL] long expected = 12345L; [EOL] Time time = new Time(expected); [EOL] long actual = time.getLocalMillis(); [EOL] assertEquals(expected, actual); [EOL] }
public void testGetChronology() { [EOL] Chronology expectedChronology = ...; // Initialize with a valid Chronology object [EOL] Time time = new Time(expectedChronology); [EOL] Chronology actualChronology = time.getChronology(); [EOL] assertEquals(expectedChronology, actualChronology); [EOL] }
public void testCompareTo_SameInstance() { [EOL] ReadablePartial sameInstance = createLocalDate(); [EOL] int result = sameInstance.compareTo(sameInstance); [EOL] assertEquals(0, result); [EOL] } [EOL] public void testCompareTo_LocalDateWithSameChronology() { [EOL] LocalDate first = createLocalDateWithChronologyAndMillis(Chronology.getInstance(), 1000L); [EOL] LocalDate second = createLocalDateWithChronologyAndMillis(Chronology.getInstance(), 1000L); [EOL] int result = first.compareTo(second); [EOL] assertEquals(0, result); [EOL] } [EOL] public void testCompareTo_LocalDateWithDifferentMillis() { [EOL] LocalDate first = createLocalDateWithChronologyAndMillis(Chronology.getInstance(), 1000L); [EOL] LocalDate second = createLocalDateWithChronologyAndMillis(Chronology.getInstance(), 2000L); [EOL] int result = first.compareTo(second); [EOL] assertEquals(-1, result); [EOL] } [EOL] public void testCompareTo_LocalDateWithDifferentChronology() { [EOL] LocalDate first = createLocalDateWithChronologyAndMillis(Chronology.getInstance(), 1000L); [EOL] LocalDate second = createLocalDateWithChronologyAndMillis(Chronology.getOtherInstance(), 1000L); [EOL] int result = first.compareTo(second); [EOL] } [EOL] public void testCompareTo_NonLocalDate() { [EOL] ReadablePartial nonLocalDate = createNonLocalDate(); [EOL] LocalDate localDate = createLocalDate(); [EOL] int result = localDate.compareTo(nonLocalDate); [EOL] }

public void testToDateTimeAtStartOfDay_NullZone() { [EOL] LocalDate localDate = new LocalDate(); [EOL] DateTime result = localDate.toDateTimeAtStartOfDay(null); [EOL] assertNotNull(result); [EOL] assertEquals(localDate.toDateTimeAtCurrentTime(DateTimeZone.UTC).withTimeAtStartOfDay(), result); [EOL] }
public void testToDateTimeAtStartOfDay_WithGivenZone() { [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/London"); [EOL] LocalDate localDate = new LocalDate(2021, 3, 28); // A date to test [EOL] DateTime expected = localDate.toDateTimeAtStartOfDay(zone); [EOL] DateTime actual = localDate.toDateTimeAtStartOfDay(zone); [EOL] assertEquals(expected, actual); [EOL] }
public void testToDateTimeAtStartOfDay_WithDefaultZone() { [EOL] DateTimeZone defaultZone = DateTimeZone.getDefault(); [EOL] LocalDate localDate = new LocalDate(2021, 3, 28); // A date to test [EOL] DateTime expected = localDate.toDateTimeAtStartOfDay(defaultZone); [EOL] DateTime actual = localDate.toDateTimeAtStartOfDay(null); [EOL] assertEquals(expected, actual); [EOL] }
public void testToDateTimeAtStartOfDay_WithUTCZone() { [EOL] DateTimeZone utcZone = DateTimeZone.UTC; [EOL] LocalDate localDate = new LocalDate(2021, 3, 28); // A date to test [EOL] DateTime expected = localDate.toDateTimeAtStartOfDay(utcZone); [EOL] DateTime actual = localDate.toDateTimeAtStartOfDay(utcZone); [EOL] assertEquals(expected, actual); [EOL] }
public void testToDateTimeAtCurrentTime() { [EOL] LocalDate localDate = new LocalDate(); [EOL] DateTime result = localDate.toDateTimeAtCurrentTime(); [EOL] assertNotNull(result); [EOL] }
public void testToDateTimeAtCurrentTime_WithNonNullZone() { [EOL] DateTimeZone mockZone = DateTimeZone.forID("America/New_York"); [EOL] LocalDate localDate = new LocalDate(2021, 3, 14); // Example date [EOL] DateTime result = localDate.toDateTimeAtCurrentTime(mockZone); [EOL] assertNotNull(result); [EOL] assertEquals(mockZone, result.getZone()); [EOL] assertEquals(localDate.toDateTimeAtStartOfDay(mockZone).toLocalDate(), result.toLocalDate()); [EOL] }
public void testToDateTimeAtCurrentTime_WithNullZone() { [EOL] LocalDate localDate = new LocalDate(2021, 3, 14); // Example date [EOL] DateTime result = localDate.toDateTimeAtCurrentTime(null); [EOL] assertNotNull(result); [EOL] assertEquals(DateTimeZone.getDefault(), result.getZone()); [EOL] assertEquals(localDate.toDateTimeAtStartOfDay(DateTimeZone.getDefault()).toLocalDate(), result.toLocalDate()); [EOL] }
public void testToDateMidnight_WithNullZone() { [EOL] DateTime dateTime = new DateTime(); [EOL] DateMidnight dateMidnight = dateTime.toDateMidnight(); [EOL] assertNotNull(dateMidnight); [EOL] assertEquals(dateTime.getMillis(), dateMidnight.getMillis()); [EOL] }
public void testToLocalDateTimeWithNullTime() { [EOL] LocalDateTime dateTime = new LocalDateTime(0L, ISOChronology.getInstance()); [EOL] try { [EOL] dateTime.toLocalDateTime(null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("The time must not be null", e.getMessage()); [EOL] } [EOL] }
public void testToLocalDateTimeWithDifferentChronology() { [EOL] LocalDateTime dateTime = new LocalDateTime(0L, ISOChronology.getInstance()); [EOL] LocalTime time = new LocalTime(0L, GJChronology.getInstance()); [EOL] try { [EOL] dateTime.toLocalDateTime(time); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("The chronology of the time does not match", e.getMessage()); [EOL] } [EOL] }
public void testToLocalDateTimeWithSameChronology() { [EOL] LocalDateTime dateTime = new LocalDateTime(0L, ISOChronology.getInstance()); [EOL] LocalTime time = new LocalTime(0L, ISOChronology.getInstance()); [EOL] LocalDateTime result = dateTime.toLocalDateTime(time); [EOL] assertNotNull(result); [EOL] assertEquals(ISOChronology.getInstance(), result.getChronology()); [EOL] }
public void testToDateTimeWithNullLocalTime() { [EOL] DateTime result = new YourClass().toDateTime(null); [EOL] assertNull(result); [EOL] }
public void testToDateTimeWithNonNullLocalTime() { [EOL] LocalTime time = LocalTime.now(); [EOL] DateTime result = new YourClass().toDateTime(time); [EOL] assertNotNull(result); [EOL] }
public void testToDateBeforeCurrentDate() { [EOL] Time time = new Time(); // Assume Time is the class that contains toDate() [EOL] time.setYear(2021); [EOL] time.setMonthOfYear(3); [EOL] time.setDayOfMonth(15); [EOL] Date result = time.toDate(); [EOL] assertEquals(14, result.getDate()); // Assuming the current date is after the 15th [EOL] assertEquals(2, result.getMonth()); [EOL] assertEquals(121, result.getYear()); // Year in Date is offset by 1900 [EOL] }
public void testToDateEqualToCurrentDate() { [EOL] Time time = new Time(); // Assume Time is the class that contains toDate() [EOL] time.setYear(2021); [EOL] time.setMonthOfYear(3); [EOL] time.setDayOfMonth(15); [EOL] Date result = time.toDate(); [EOL] assertEquals(15, result.getDate()); [EOL] assertEquals(2, result.getMonth()); [EOL] assertEquals(121, result.getYear()); // Year in Date is offset by 1900 [EOL] }
public void testToDateAfterCurrentDate() { [EOL] Time time = new Time(); // Assume Time is the class that contains toDate() [EOL] time.setYear(2021); [EOL] time.setMonthOfYear(3); [EOL] time.setDayOfMonth(15); [EOL] Date result = time.toDate(); [EOL] assertEquals(16, result.getDate()); // Assuming the current date is before the 15th [EOL] assertEquals(2, result.getMonth()); [EOL] assertEquals(121, result.getYear()); // Year in Date is offset by 1900 [EOL] }
public void testWithFieldAdded_NullFieldType() { [EOL] try { [EOL] LocalDate date = new LocalDate(); [EOL] date.withFieldAdded(null, 1); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public void testWithFieldAdded_UnsupportedFieldType() { [EOL] try { [EOL] LocalDate date = new LocalDate(); [EOL] DurationFieldType fieldType = DurationFieldType.centuries(); // Assuming centuries is not supported [EOL] date.withFieldAdded(fieldType, 1); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public void testWithFieldAdded_ZeroAmount() { [EOL] LocalDate date = new LocalDate(); [EOL] DurationFieldType fieldType = DurationFieldType.days(); // Assuming days is supported [EOL] LocalDate result = date.withFieldAdded(fieldType, 0); [EOL] assertEquals("Adding zero should not change the date", date, result); [EOL] }
public void testWithFieldAdded_NonZeroAmount() { [EOL] LocalDate date = new LocalDate(); [EOL] DurationFieldType fieldType = DurationFieldType.days(); // Assuming days is supported [EOL] int amountToAdd = 10; [EOL] LocalDate result = date.withFieldAdded(fieldType, amountToAdd); [EOL] LocalDate expected = date.plusDays(amountToAdd); [EOL] assertEquals("Adding non-zero amount should change the date", expected, result); [EOL] }
public void testPlusMonths_ZeroMonths() { [EOL] LocalDate date = LocalDate.now(); [EOL] LocalDate result = date.plusMonths(0); [EOL] assertEquals(date, result); [EOL] }
public void testPlusMonths_PositiveMonths() { [EOL] LocalDate date = LocalDate.now(); [EOL] LocalDate result = date.plusMonths(5); [EOL] assertNotEquals(date, result); [EOL] assertEquals(date.plusMonths(5), result); [EOL] }
public void testPlusMonths_NegativeMonths() { [EOL] LocalDate date = LocalDate.now(); [EOL] LocalDate result = date.plusMonths(-5); [EOL] assertNotEquals(date, result); [EOL] assertEquals(date.plusMonths(-5), result); [EOL] }
public void testMinusYears_ZeroYears() { [EOL] LocalDate date = LocalDate.now(); [EOL] LocalDate result = date.minusYears(0); [EOL] assertEquals(date, result); [EOL] }
public void testMinusYears_NegativeYears() { [EOL] LocalDate date = LocalDate.now(); [EOL] LocalDate result = date.minusYears(-1); [EOL] assertNotEquals(date, result); [EOL] assertEquals(date.getYear() - 1, result.getYear()); [EOL] }
public void testMinusYears_PositiveYears() { [EOL] LocalDate date = LocalDate.now(); [EOL] LocalDate result = date.minusYears(1); [EOL] assertNotEquals(date, result); [EOL] assertEquals(date.getYear() + 1, result.getYear()); [EOL] }
public int getEra() { [EOL] return getChronology().era().get(getLocalMillis()); [EOL] }
public int getCenturyOfEra() { [EOL] return getChronology().centuryOfEra().get(getLocalMillis()); [EOL] }
public void testGetYearOfEra() { [EOL] DateTime dateTime = new DateTime(2023, 1, 1, 0, 0, 0, 0); [EOL] int yearOfEra = dateTime.getYearOfEra(); [EOL] assertEquals(2023, yearOfEra); [EOL] }
public int getYearOfCentury() { [EOL] return getChronology().yearOfCentury().get(getLocalMillis()); [EOL] }
public int getYear() { [EOL] return getChronology().year().get(getLocalMillis()); [EOL] }
public int getWeekyear() { [EOL] return getChronology().weekyear().get(getLocalMillis()); [EOL] }
public int getMonthOfYear() { [EOL] return getChronology().monthOfYear().get(getLocalMillis()); [EOL] }
public void testGetWeekOfWeekyear() { [EOL] Chronology mockChronology = Mockito.mock(Chronology.class); [EOL] DateTimeField mockWeekField = Mockito.mock(DateTimeField.class); [EOL] long testMillis = 1234567890L; [EOL] int expectedWeek = 10; [EOL] Mockito.when(mockChronology.weekOfWeekyear()).thenReturn(mockWeekField); [EOL] Mockito.when(mockWeekField.get(testMillis)).thenReturn(expectedWeek); [EOL] Time time = new Time(mockChronology, testMillis); [EOL] int actualWeek = time.getWeekOfWeekyear(); [EOL] assertEquals(expectedWeek, actualWeek); [EOL] }
public int getDayOfYear() { [EOL] return getChronology().dayOfYear().get(getLocalMillis()); [EOL] }
public int getDayOfMonth() { [EOL] return getChronology().dayOfMonth().get(getLocalMillis()); [EOL] }
public int getDayOfWeekTest() { [EOL] int dayOfWeek = time.getDayOfWeek(); [EOL] assert dayOfWeek == 3 : "The day of the week should be 3 for Wednesday"; [EOL] }
public void testWithEra_ValidEra() { [EOL] LocalDate date = new LocalDate(2023, 4, 15); [EOL] int validEra = DateTimeConstants.CE; [EOL] LocalDate newDate = date.withEra(validEra); [EOL] assertEquals(validEra, newDate.getEra()); [EOL] }
public void testWithEra_InvalidEra() { [EOL] LocalDate date = new LocalDate(2023, 4, 15); [EOL] int invalidEra = -1; // Assuming -1 is not a valid era [EOL] try { [EOL] date.withEra(invalidEra); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public void testWithCenturyOfEra_ValidCentury() { [EOL] LocalDate date = new LocalDate(2000, 1, 1); [EOL] int validCentury = 20; [EOL] LocalDate newDate = date.withCenturyOfEra(validCentury); [EOL] assertEquals(1900, newDate.getYear()); [EOL] assertEquals(1, newDate.getMonthOfYear()); [EOL] assertEquals(1, newDate.getDayOfMonth()); [EOL] }
public void testWithCenturyOfEra_NegativeCentury() { [EOL] LocalDate date = new LocalDate(2000, 1, 1); [EOL] int negativeCentury = -1; [EOL] try { [EOL] date.withCenturyOfEra(negativeCentury); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public void testWithCenturyOfEra_FutureCentury() { [EOL] LocalDate date = new LocalDate(2000, 1, 1); [EOL] int futureCentury = 30; [EOL] LocalDate newDate = date.withCenturyOfEra(futureCentury); [EOL] assertEquals(2900, newDate.getYear()); [EOL] assertEquals(1, newDate.getMonthOfYear()); [EOL] assertEquals(1, newDate.getDayOfMonth()); [EOL] }
public void testWithYearOfEra_ValidYear() { [EOL] LocalDate date = new LocalDate(2020, 1, 1); [EOL] LocalDate newDate = date.withYearOfEra(2021); [EOL] assertEquals(new LocalDate(2021, 1, 1), newDate); [EOL] }
public void testWithYearOfEra_SameYear() { [EOL] LocalDate date = new LocalDate(2020, 1, 1); [EOL] LocalDate newDate = date.withYearOfEra(2020); [EOL] assertSame(date, newDate); [EOL] }
public void testWithYearOfEra_InvalidYear() { [EOL] LocalDate date = new LocalDate(2020, 1, 1); [EOL] try { [EOL] date.withYearOfEra(-1); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public void testWithYearOfCentury_ValidYear() { [EOL] LocalDate date = new LocalDate(2000, 1, 1); // Assuming LocalDate is from Joda-Time library [EOL] int yearOfCentury = 50; [EOL] LocalDate updatedDate = date.withYearOfCentury(yearOfCentury); [EOL] assertEquals(1950, updatedDate.getYear()); [EOL] }
public void testWithYearOfCentury_InvalidYear() { [EOL] LocalDate date = new LocalDate(2000, 1, 1); [EOL] int yearOfCentury = -1; [EOL] try { [EOL] date.withYearOfCentury(yearOfCentury); [EOL] fail("Should have thrown an IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testWithYear_ValidYear() { [EOL] LocalDate date = new LocalDate(2020, 1, 1); [EOL] int newYear = 2021; [EOL] LocalDate newDate = date.withYear(newYear); [EOL] assertEquals(newYear, newDate.getYear()); [EOL] }
public void testWithYear_InvalidYear() { [EOL] LocalDate date = new LocalDate(2020, 1, 1); [EOL] try { [EOL] date.withYear(Integer.MAX_VALUE); [EOL] fail("Should have thrown an IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testWithWeekyear_ValidWeekyear() { [EOL] LocalDate date = new LocalDate(2020, 1, 1); // Any valid date [EOL] int validWeekyear = 2021; // A different weekyear for testing [EOL] LocalDate updatedDate = date.withWeekyear(validWeekyear); [EOL] assertEquals(validWeekyear, updatedDate.getWeekyear()); [EOL] }
public void testWithWeekyear_SameWeekyear() { [EOL] LocalDate date = new LocalDate(2020, 1, 1); // Any valid date [EOL] int sameWeekyear = 2020; // Same weekyear as the date [EOL] LocalDate updatedDate = date.withWeekyear(sameWeekyear); [EOL] assertEquals(sameWeekyear, updatedDate.getWeekyear()); [EOL] }
public void testWithMonthOfYear_ValidMonth() { [EOL] LocalDate date = new LocalDate(2021, 4, 15); // Assuming this is a valid date [EOL] LocalDate updatedDate = date.withMonthOfYear(6); [EOL] assertEquals(6, updatedDate.getMonthOfYear()); [EOL] } [EOL] public void testWithMonthOfYear_InvalidMonthLow() { [EOL] try { [EOL] LocalDate date = new LocalDate(2021, 4, 15); [EOL] date.withMonthOfYear(0); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] } [EOL] public void testWithMonthOfYear_InvalidMonthHigh() { [EOL] try { [EOL] LocalDate date = new LocalDate(2021, 4, 15); [EOL] date.withMonthOfYear(13); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testWithWeekOfWeekyear_ValidWeek() { [EOL] LocalDate date = new LocalDate(2023, 1, 1); [EOL] LocalDate updatedDate = date.withWeekOfWeekyear(10); [EOL] assertEquals(10, updatedDate.getWeekOfWeekyear()); [EOL] }
public void testWithWeekOfWeekyear_FirstWeek() { [EOL] LocalDate date = new LocalDate(2023, 1, 1); [EOL] LocalDate updatedDate = date.withWeekOfWeekyear(1); [EOL] assertEquals(1, updatedDate.getWeekOfWeekyear()); [EOL] }
public void testWithWeekOfWeekyear_LastWeek() { [EOL] LocalDate date = new LocalDate(2023, 12, 31); [EOL] LocalDate updatedDate = date.withWeekOfWeekyear(52); [EOL] assertEquals(52, updatedDate.getWeekOfWeekyear()); [EOL] }
public void testWithDayOfYear_ValidDay() { [EOL] LocalDate date = new LocalDate(2021, 1, 1); [EOL] int dayOfYear = 200; [EOL] LocalDate updatedDate = date.withDayOfYear(dayOfYear); [EOL] assertEquals(200, updatedDate.getDayOfYear()); [EOL] }
public void testWithDayOfYear_FirstDay() { [EOL] LocalDate date = new LocalDate(2021, 3, 1); [EOL] int dayOfYear = 1; [EOL] LocalDate updatedDate = date.withDayOfYear(dayOfYear); [EOL] assertEquals(1, updatedDate.getDayOfYear()); [EOL] }
public void testWithDayOfYear_LastDay() { [EOL] LocalDate date = new LocalDate(2021, 3, 1); [EOL] int dayOfYear = 365; [EOL] LocalDate updatedDate = date.withDayOfYear(dayOfYear); [EOL] assertEquals(365, updatedDate.getDayOfYear()); [EOL] }
public void testWithDayOfYear_InvalidDayLow() { [EOL] LocalDate date = new LocalDate(2021, 3, 1); [EOL] int dayOfYear = 0; [EOL] try { [EOL] date.withDayOfYear(dayOfYear); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public void testWithDayOfYear_InvalidDayHigh() { [EOL] LocalDate date = new LocalDate(2021, 3, 1); [EOL] int dayOfYear = 366; [EOL] try { [EOL] date.withDayOfYear(dayOfYear); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public void testWithDayOfMonth_ValidDay() { [EOL] LocalDate date = new LocalDate(2023, 3, 15); // Assume this is a valid date [EOL] int dayOfMonth = 10; [EOL] LocalDate result = date.withDayOfMonth(dayOfMonth); [EOL] assertEquals(new LocalDate(2023, 3, dayOfMonth), result); [EOL] } [EOL] public void testWithDayOfMonth_InvalidDayLow() { [EOL] LocalDate date = new LocalDate(2023, 3, 15); // Assume this is a valid date [EOL] try { [EOL] date.withDayOfMonth(0); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] } [EOL] public void testWithDayOfMonth_InvalidDayHigh() { [EOL] LocalDate date = new LocalDate(2023, 3, 15); // Assume this is a valid date [EOL] try { [EOL] date.withDayOfMonth(32); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testWithDayOfWeek_ValidDay() { [EOL] LocalDate date = new LocalDate(2021, 3, 1); // Assuming this is a Monday [EOL] LocalDate newDate = date.withDayOfWeek(3); // Set to Wednesday [EOL] assertEquals(3, newDate.getDayOfWeek()); [EOL] }
public void testWithDayOfWeek_InvalidDayLow() { [EOL] LocalDate date = new LocalDate(2021, 3, 1); [EOL] try { [EOL] date.withDayOfWeek(0); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public void testWithDayOfWeek_InvalidDayHigh() { [EOL] LocalDate date = new LocalDate(2021, 3, 1); [EOL] try { [EOL] date.withDayOfWeek(8); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
protected PeriodFormat() { [EOL] super(); [EOL] }
public void testWordBasedWithDefaultLocale() { [EOL] PeriodFormatter result = Time.wordBased(); [EOL] assertNotNull("PeriodFormatter should not be null", result); [EOL] assertEquals("PeriodFormatter should use the default locale", Locale.getDefault(), result.getLocale()); [EOL] }
public void testGetInstanceUTC() { [EOL] EthiopicChronology instance = EthiopicChronology.getInstanceUTC(); [EOL] assertNotNull(instance); [EOL] assertSame(EthiopicChronology.INSTANCE_UTC, instance); [EOL] }
public void testGetInstance_Default() { [EOL] EthiopicChronology instance = EthiopicChronology.getInstance(); [EOL] assertNotNull("Instance should not be null", instance); [EOL] assertEquals("Default instance should have a minimum days in first week of 4", 4, instance.getMinimumDaysInFirstWeek()); [EOL] assertEquals("Default instance should use the default time zone", DateTimeZone.getDefault(), instance.getZone()); [EOL] }
public static EthiopicChronology getInstance(DateTimeZone zone) { [EOL] return getInstance(zone, 4); [EOL] }
public void testGetInstanceWithNullZone() { [EOL] EthiopicChronology chrono = EthiopicChronology.getInstance(null, 4); [EOL] assertNotNull(chrono); [EOL] assertEquals(DateTimeZone.getDefault(), chrono.getZone()); [EOL] }
public void testGetInstanceWithNonNullZone() { [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/Paris"); [EOL] EthiopicChronology chrono = EthiopicChronology.getInstance(zone, 4); [EOL] assertNotNull(chrono); [EOL] assertEquals(zone, chrono.getZone()); [EOL] }
public void testGetInstanceWithMinDaysInFirstWeekTooLow() { [EOL] try { [EOL] EthiopicChronology.getInstance(DateTimeZone.getDefault(), 0); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testGetInstanceWithMinDaysInFirstWeekTooHigh() { [EOL] try { [EOL] EthiopicChronology.getInstance(DateTimeZone.getDefault(), 8); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testGetInstanceWithUTCZone() { [EOL] EthiopicChronology chrono = EthiopicChronology.getInstance(DateTimeZone.UTC, 4); [EOL] assertNotNull(chrono); [EOL] assertEquals(DateTimeZone.UTC, chrono.getZone()); [EOL] }
public void testGetApproxMillisAtEpochDividedByTwo() { [EOL] long expected = (1962L * 31536000000L + 112L * 86400000L) / 2; [EOL] assertEquals(expected, getApproxMillisAtEpochDividedByTwo()); [EOL] }
public void testSetWithBCE() { [EOL] long instant = /* some instant representing a date in BCE */; [EOL] int era = DateTimeConstants.BCE; [EOL] long updatedInstant = set(instant, era); [EOL] int updatedEra = get(updatedInstant); [EOL] assertEquals("Era should be BCE", DateTimeConstants.BCE, updatedEra); [EOL] }
public void testSetWithCE() { [EOL] long instant = /* some instant representing a date in CE */; [EOL] int era = DateTimeConstants.CE; [EOL] long updatedInstant = set(instant, era); [EOL] int updatedEra = get(updatedInstant); [EOL] assertEquals("Era should be CE", DateTimeConstants.CE, updatedEra); [EOL] }
public void testSetWithNoChangeInEra() { [EOL] long instant = /* some instant representing a date in CE */; [EOL] int era = get(instant); [EOL] long updatedInstant = set(instant, era); [EOL] assertEquals("Instant should not change when era is the same", instant, updatedInstant); [EOL] }
public void testRoundFloorAtCE() { [EOL] long instantAtCE = /* value representing a time instant in the Common Era */; [EOL] long expected = iChronology.setYear(0, 1); [EOL] long actual = roundFloor(instantAtCE); [EOL] assertEquals(expected, actual); [EOL] }
public void testRoundFloorBeforeCE() { [EOL] long instantBeforeCE = /* value representing a time instant before the Common Era */; [EOL] long actual = roundFloor(instantBeforeCE); [EOL] assertEquals(Long.MIN_VALUE, actual); [EOL] }
public void testMonths_InitialCall() { [EOL] PeriodType result = PeriodType.months(); [EOL] assertNotNull(result); [EOL] assertEquals("Months", result.getName()); [EOL] assertTrue(result.isSupported(DurationFieldType.months())); [EOL] }
public void testMonths_SubsequentCall() { [EOL] PeriodType firstCall = PeriodType.months(); [EOL] PeriodType secondCall = PeriodType.months(); [EOL] assertSame(firstCall, secondCall); [EOL] }
public void testDays_Initialized() { [EOL] PeriodType type = PeriodType.days(); [EOL] assertNotNull(type); [EOL] assertEquals("Days", type.getName()); [EOL] assertTrue(Arrays.asList(type.getFieldTypes()).contains(DurationFieldType.days())); [EOL] } [EOL] public void testDays_Singleton() { [EOL] PeriodType type1 = PeriodType.days(); [EOL] PeriodType type2 = PeriodType.days(); [EOL] assertSame(type1, type2); [EOL] }
public void testHours_Cached() { [EOL] PeriodType type1 = PeriodType.hours(); [EOL] PeriodType type2 = PeriodType.hours(); [EOL] assertSame("The method should return the same instance of PeriodType for hours", type1, type2); [EOL] }
public void testMinutesSingleton() { [EOL] PeriodType type1 = PeriodType.minutes(); [EOL] assertNotNull(type1); [EOL] PeriodType type2 = PeriodType.minutes(); [EOL] assertSame(type1, type2); [EOL] }
public void testIndexOf_WithExistingType() { [EOL] DurationFieldType existingType = DurationFieldType.minutes(); [EOL] int expectedIndex = 1; // Assuming minutes is at index 1 [EOL] int actualIndex = indexOf(existingType); [EOL] assertEquals(expectedIndex, actualIndex); [EOL] } [EOL] public void testIndexOf_WithNonExistingType() { [EOL] DurationFieldType nonExistingType = DurationFieldType.seconds(); [EOL] int expectedIndex = -1; [EOL] int actualIndex = indexOf(nonExistingType); [EOL] assertEquals(expectedIndex, actualIndex); [EOL] }
public void testWithYearsRemoved() { [EOL] PeriodType type = PeriodType.standard(); [EOL] PeriodType result = type.withYearsRemoved(); [EOL] assertFalse(result.isSupported(DurationFieldType.years())); [EOL] assertTrue(result.isSupported(DurationFieldType.months())); [EOL] }
public void testWithYearsRemoved_NoYearsType() { [EOL] PeriodType type = PeriodType.years(); [EOL] PeriodType result = type.withYearsRemoved(); [EOL] assertEquals("NoYears", result.getName()); [EOL] assertFalse(result.isSupported(DurationFieldType.years())); [EOL] }
public void testWithMillisRemoved() { [EOL] PeriodType type = PeriodType.standard(); [EOL] PeriodType noMillis = type.withMillisRemoved(); [EOL] assertFalse(noMillis.hasField(DurationFieldType.millis())); [EOL] assertTrue(noMillis.hasField(DurationFieldType.seconds())); [EOL] }
public void testWithMillisRemoved_AlreadyNoMillis() { [EOL] PeriodType type = PeriodType.days(); // Assuming days() does not have millis field [EOL] PeriodType noMillis = type.withMillisRemoved(); [EOL] assertSame(type, noMillis); // Should return the same type as it already has no millis field [EOL] }
public void testDateTimeUtilsConstructor() throws Exception { [EOL] Constructor<DateTimeUtils> constructor = DateTimeUtils.class.getDeclaredConstructor(); [EOL] constructor.setAccessible(true); [EOL] DateTimeUtils instance = constructor.newInstance(); [EOL] assertNotNull(instance); [EOL] }
public void testSetCurrentMillisProvider_WithNullProvider_ThrowsIllegalArgumentException() { [EOL] try { [EOL] Time.setCurrentMillisProvider(null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("The MillisProvider must not be null", ex.getMessage()); [EOL] } [EOL] } [EOL] public void testSetCurrentMillisProvider_WithValidProvider_SetsProvider() throws SecurityException { [EOL] MillisProvider mockMillisProvider = new MockMillisProvider(); [EOL] Time.setCurrentMillisProvider(mockMillisProvider); [EOL] assertEquals(mockMillisProvider, Time.getCurrentMillisProvider()); [EOL] } [EOL] public void testSetCurrentMillisProvider_WithoutPermission_ThrowsSecurityException() { [EOL] MillisProvider mockMillisProvider = new MockMillisProvider(); [EOL] try { [EOL] Time.setCurrentMillisProvider(mockMillisProvider); [EOL] fail("Should have thrown SecurityException"); [EOL] } catch (SecurityException ex) { [EOL] } [EOL] }
public void testGetSupportedTypeReturnsNull() { [EOL] Time time = new Time(); [EOL] Class<?> result = time.getSupportedType(); [EOL] assertNull(result); [EOL] }
public void testBaseIntervalWithNullPeriod() { [EOL] ReadableInstant start = new DateTime(2020, 1, 1, 0, 0); [EOL] BaseInterval interval = new BaseInterval(start, null); [EOL] assertEquals(interval.getStartMillis(), interval.getEndMillis()); [EOL] }
public void testBaseIntervalWithNonNullPeriod() { [EOL] ReadableInstant start = new DateTime(2020, 1, 1, 0, 0); [EOL] ReadablePeriod period = new Period(1, 0, 0, 0); [EOL] BaseInterval interval = new BaseInterval(start, period); [EOL] assertNotEquals(interval.getStartMillis(), interval.getEndMillis()); [EOL] assertEquals(interval.getEndMillis(), start.getMillis() + period.toDurationFrom(start).getMillis()); [EOL] }
public void testForID_NullId() { [EOL] DateTimeZone result = DateTimeZone.forID(null); [EOL] assertEquals(DateTimeZone.getDefault(), result); [EOL] }
public void testForID_UTCId() { [EOL] DateTimeZone result = DateTimeZone.forID("UTC"); [EOL] assertEquals(DateTimeZone.UTC, result); [EOL] }
public void testForID_ValidId() { [EOL] String validId = "Europe/London"; // Assuming "Europe/London" is a valid ID [EOL] DateTimeZone result = DateTimeZone.forID(validId); [EOL] assertNotNull(result); [EOL] }
public void testForID_InvalidId() { [EOL] String invalidId = "Invalid/Zone"; [EOL] try { [EOL] DateTimeZone.forID(invalidId); [EOL] fail("Should have thrown an IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testForID_ValidOffsetId_ZeroOffset() { [EOL] String zeroOffsetId = "+00:00"; [EOL] DateTimeZone result = DateTimeZone.forID(zeroOffsetId); [EOL] assertEquals(DateTimeZone.UTC, result); [EOL] }
public void testForID_ValidOffsetId_NonZeroOffset() { [EOL] String nonZeroOffsetId = "+01:00"; // Assuming "+01:00" is a valid offset [EOL] DateTimeZone result = DateTimeZone.forID(nonZeroOffsetId); [EOL] assertNotNull(result); [EOL] assertNotEquals(DateTimeZone.UTC, result); [EOL] }
public void testForOffsetHoursMinutes_UTC() { [EOL] DateTimeZone result = Time.forOffsetHoursMinutes(0, 0); [EOL] assertEquals(DateTimeZone.UTC, result); [EOL] }
public void testForOffsetHoursMinutes_HoursOutOfRange() { [EOL] try { [EOL] Time.forOffsetHoursMinutes(24, 0); [EOL] fail("Should have thrown IllegalArgumentException for hours out of range"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Hours out of range: 24", e.getMessage()); [EOL] } [EOL] }
public void testForOffsetHoursMinutes_MinutesOutOfRange() { [EOL] try { [EOL] Time.forOffsetHoursMinutes(1, 60); [EOL] fail("Should have thrown IllegalArgumentException for minutes out of range"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Minutes out of range: 60", e.getMessage()); [EOL] } [EOL] }
public void testForOffsetHoursMinutes_PositiveHoursNegativeMinutes() { [EOL] try { [EOL] Time.forOffsetHoursMinutes(1, -1); [EOL] fail("Should have thrown IllegalArgumentException for positive hours with negative minutes"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Positive hours must not have negative minutes: -1", e.getMessage()); [EOL] } [EOL] }
public void testForOffsetHoursMinutes_ValidOffset() { [EOL] DateTimeZone result = Time.forOffsetHoursMinutes(1, 30); [EOL] assertNotNull(result); [EOL] }
public void testForOffsetHoursMinutes_OffsetTooLarge() { [EOL] try { [EOL] Time.forOffsetHoursMinutes(Integer.MAX_VALUE / 60, 0); [EOL] fail("Should have thrown IllegalArgumentException for offset too large"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Offset is too large", e.getMessage()); [EOL] } [EOL] }
public void testForOffsetMillisWithinRange() { [EOL] int millisOffset = 0; // Assuming 0 is within the valid range [EOL] DateTimeZone result = Time.forOffsetMillis(millisOffset); [EOL] assertNotNull(result); [EOL] assertEquals(millisOffset, result.getOffset(null)); [EOL] }
public void testForOffsetMillisBelowMinimum() { [EOL] int millisOffset = -MAX_MILLIS - 1; [EOL] try { [EOL] Time.forOffsetMillis(millisOffset); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Millis out of range: " + millisOffset, e.getMessage()); [EOL] } [EOL] }
public void testForOffsetMillisAboveMaximum() { [EOL] int millisOffset = MAX_MILLIS + 1; [EOL] try { [EOL] Time.forOffsetMillis(millisOffset); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Millis out of range: " + millisOffset, e.getMessage()); [EOL] } [EOL] }
public void testForTimeZoneWithNullZone() { [EOL] DateTimeZone result = DateTimeZone.forTimeZone(null); [EOL] assertNotNull(result); [EOL] }
public void testForTimeZoneWithUTCZone() { [EOL] TimeZone zone = TimeZone.getTimeZone("UTC"); [EOL] DateTimeZone result = DateTimeZone.forTimeZone(zone); [EOL] assertSame(DateTimeZone.UTC, result); [EOL] }
public void testForTimeZoneWithNonUTCZone() { [EOL] TimeZone zone = TimeZone.getTimeZone("America/New_York"); [EOL] DateTimeZone result = DateTimeZone.forTimeZone(zone); [EOL] assertNotNull(result); [EOL] assertNotSame(DateTimeZone.UTC, result); [EOL] }
public void testForTimeZoneWithUnknownZone() { [EOL] TimeZone zone = TimeZone.getTimeZone("Unknown/Zone"); [EOL] try { [EOL] DateTimeZone.forTimeZone(zone); [EOL] fail("Should have thrown an IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testForTimeZoneWithGMTPlusZone() { [EOL] TimeZone zone = TimeZone.getTimeZone("GMT+02:00"); [EOL] DateTimeZone result = DateTimeZone.forTimeZone(zone); [EOL] assertNotNull(result); [EOL] assertEquals("+02:00", result.getID()); [EOL] }
public void testForTimeZoneWithGMTMinusZone() { [EOL] TimeZone zone = TimeZone.getTimeZone("GMT-02:00"); [EOL] DateTimeZone result = DateTimeZone.forTimeZone(zone); [EOL] assertNotNull(result); [EOL] assertEquals("-02:00", result.getID()); [EOL] }
public void testFixedOffsetZoneWithZeroOffset() { [EOL] DateTimeZone result = Time.fixedOffsetZone("UTC", 0); [EOL] assertEquals(DateTimeZone.UTC, result); [EOL] }
public void testFixedOffsetZoneWithNonZeroOffsetAndCacheMiss() { [EOL] String id = "GMT+1"; [EOL] int offset = 3600000; [EOL] DateTimeZone result = Time.fixedOffsetZone(id, offset); [EOL] assertNotNull(result); [EOL] assertEquals(id, result.getID()); [EOL] assertEquals(offset, result.getOffset(null)); [EOL] }
public void testFixedOffsetZoneWithNonZeroOffsetAndCacheHit() { [EOL] String id = "GMT+1"; [EOL] int offset = 3600000; [EOL] Time.fixedOffsetZone(id, offset); [EOL] DateTimeZone result = Time.fixedOffsetZone(id, offset); [EOL] assertNotNull(result); [EOL] assertEquals(id, result.getID()); [EOL] assertEquals(offset, result.getOffset(null)); [EOL] }
public void testSetProviderWithNoSecurityManager() throws SecurityException { [EOL] Provider mockProvider = mock(Provider.class); [EOL] DateTimeZone.setProvider(mockProvider); [EOL] assertEquals(mockProvider, DateTimeZone.getProvider()); [EOL] }
public void testSetProviderWithSecurityManagerAndPermission() throws SecurityException { [EOL] SecurityManager originalSecurityManager = System.getSecurityManager(); [EOL] try { [EOL] SecurityManager sm = mock(SecurityManager.class); [EOL] System.setSecurityManager(sm); [EOL] Provider mockProvider = mock(Provider.class); [EOL] doNothing().when(sm).checkPermission(any(JodaTimePermission.class)); [EOL] DateTimeZone.setProvider(mockProvider); [EOL] assertEquals(mockProvider, DateTimeZone.getProvider()); [EOL] verify(sm).checkPermission(any(JodaTimePermission.class)); [EOL] } finally { [EOL] System.setSecurityManager(originalSecurityManager); [EOL] } [EOL] }
public void testSetProviderWithSecurityManagerAndNoPermission() { [EOL] SecurityManager originalSecurityManager = System.getSecurityManager(); [EOL] try { [EOL] SecurityManager sm = mock(SecurityManager.class); [EOL] System.setSecurityManager(sm); [EOL] Provider mockProvider = mock(Provider.class); [EOL] doThrow(new SecurityException()).when(sm).checkPermission(any(JodaTimePermission.class)); [EOL] try { [EOL] DateTimeZone.setProvider(mockProvider); [EOL] fail("Should have thrown SecurityException"); [EOL] } catch (SecurityException e) { [EOL] } [EOL] } finally { [EOL] System.setSecurityManager(originalSecurityManager); [EOL] } [EOL] }
public void testSetProvider0WithNullProvider() { [EOL] try { [EOL] Time.setProvider0(null); [EOL] fail("Should have thrown IllegalArgumentException for null provider ids"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("The provider doesn't have any available ids", e.getMessage()); [EOL] } [EOL] } [EOL] public void testSetProvider0WithEmptyIds() { [EOL] Provider mockProvider = mock(Provider.class); [EOL] when(mockProvider.getAvailableIDs()).thenReturn(new HashSet<>()); [EOL] try { [EOL] Time.setProvider0(mockProvider); [EOL] fail("Should have thrown IllegalArgumentException for empty ids"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("The provider doesn't have any available ids", e.getMessage()); [EOL] } [EOL] } [EOL] public void testSetProvider0WithoutUTC() { [EOL] Set<String> ids = new HashSet<>(Arrays.asList("GMT", "EST")); [EOL] Provider mockProvider = mock(Provider.class); [EOL] when(mockProvider.getAvailableIDs()).thenReturn(ids); [EOL] try { [EOL] Time.setProvider0(mockProvider); [EOL] fail("Should have thrown IllegalArgumentException for missing UTC"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("The provider doesn't support UTC", e.getMessage()); [EOL] } [EOL] } [EOL] public void testSetProvider0WithInvalidUTCZone() { [EOL] Set<String> ids = new HashSet<>(Arrays.asList("UTC", "GMT", "EST")); [EOL] Provider mockProvider = mock(Provider.class); [EOL] when(mockProvider.getAvailableIDs()).thenReturn(ids); [EOL] when(mockProvider.getZone("UTC")).thenReturn(new SimpleTimeZone(3600000, "CET")); [EOL] try { [EOL] Time.setProvider0(mockProvider); [EOL] fail("Should have thrown IllegalArgumentException for invalid UTC zone"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Invalid UTC zone provided", e.getMessage()); [EOL] } [EOL] } [EOL] public void testSetProvider0WithValidProvider() { [EOL] Set<String> ids = new HashSet<>(Arrays.asList("UTC", "GMT", "EST")); [EOL] TimeZone utcZone = TimeZone.getTimeZone("UTC"); [EOL] Provider mockProvider = mock(Provider.class); [EOL] when(mockProvider.getAvailableIDs()).thenReturn(ids); [EOL] when(mockProvider.getZone("UTC")).thenReturn(utcZone); [EOL] Time.setProvider0(mockProvider); [EOL] assertEquals(mockProvider, Time.getProvider()); [EOL] assertEquals(ids, Time.getAvailableIDs()); [EOL] }
public void testGetDefaultProviderWithSystemPropertySet() { [EOL] System.setProperty("org.joda.time.DateTimeZone.Provider", "com.example.CustomProvider"); [EOL] Provider provider = getDefaultProvider(); [EOL] assertNotNull(provider); [EOL] assertTrue(provider instanceof com.example.CustomProvider); [EOL] System.clearProperty("org.joda.time.DateTimeZone.Provider"); [EOL] }
public void testGetDefaultProviderWithSecurityException() { [EOL] System.setSecurityManager(new SecurityManager() { [EOL] @Override [EOL] public void checkPermission(Permission perm) { [EOL] if ("org.joda.time.DateTimeZone.Provider".equals(perm.getName())) { [EOL] throw new SecurityException(); [EOL] } [EOL] } [EOL] }); [EOL] Provider provider = getDefaultProvider(); [EOL] assertNotNull(provider); [EOL] assertTrue(provider instanceof ZoneInfoProvider); [EOL] System.setSecurityManager(null); // Reset security manager [EOL] }
public void testGetDefaultProviderWithZoneInfoProviderException() { [EOL] System.setProperty("org.joda.time.DateTimeZone.Provider", "com.example.NonExistentProvider"); [EOL] Provider provider = getDefaultProvider(); [EOL] assertNotNull(provider); [EOL] assertTrue(provider instanceof UTCProvider); [EOL] System.clearProperty("org.joda.time.DateTimeZone.Provider"); [EOL] }
public void testPrintOffsetPositive() { [EOL] String result = printOffset(3600000); // Assuming DateTimeConstants.MILLIS_PER_HOUR is 3600000 [EOL] assertEquals("+01:00", result); [EOL] }
public void testPrintOffsetNegative() { [EOL] String result = printOffset(-3600000); // Assuming DateTimeConstants.MILLIS_PER_HOUR is 3600000 [EOL] assertEquals("-01:00", result); [EOL] }
public void testPrintOffsetPositiveWithSeconds() { [EOL] String result = printOffset(3661000); // Assuming DateTimeConstants.MILLIS_PER_HOUR is 3600000 and DateTimeConstants.MILLIS_PER_MINUTE is 60000 [EOL] assertEquals("+01:01:01", result); [EOL] }
public void testPrintOffsetNegativeWithSeconds() { [EOL] String result = printOffset(-3661000); // Assuming DateTimeConstants.MILLIS_PER_HOUR is 3600000 and DateTimeConstants.MILLIS_PER_MINUTE is 60000 [EOL] assertEquals("-01:01:01", result); [EOL] }
public void testPrintOffsetPositiveWithMilliseconds() { [EOL] String result = printOffset(3661001); // Assuming DateTimeConstants.MILLIS_PER_HOUR is 3600000, DateTimeConstants.MILLIS_PER_MINUTE is 60000, and DateTimeConstants.MILLIS_PER_SECOND is 1000 [EOL] assertEquals("+01:01:01.001", result); [EOL] }
public void testPrintOffsetNegativeWithMilliseconds() { [EOL] String result = printOffset(-3661001); // Assuming DateTimeConstants.MILLIS_PER_HOUR is 3600000, DateTimeConstants.MILLIS_PER_MINUTE is 60000, and DateTimeConstants.MILLIS_PER_SECOND is 1000 [EOL] assertEquals("-01:01:01.001", result); [EOL] }
public void testDateTimeZoneWithNullId() { [EOL] try { [EOL] new DateTimeZone(null); [EOL] fail("Should have thrown IllegalArgumentException for null id"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Id must not be null", e.getMessage()); [EOL] } [EOL] }
public void testDateTimeZoneWithValidId() { [EOL] String validId = "UTC"; [EOL] DateTimeZone zone = new DateTimeZone(validId); [EOL] assertEquals(validId, zone.getID()); [EOL] }
public void testGetOffsetWithNullInstant() { [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/London"); [EOL] int expected = zone.getOffset(DateTimeUtils.currentTimeMillis()); [EOL] int actual = zone.getOffset((ReadableInstant) null); [EOL] assertEquals(expected, actual); [EOL] }
public void testGetOffsetWithNonNullInstant() { [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/London"); [EOL] ReadableInstant instant = new DateTime(new DateTime(2023, 3, 25, 12, 0, zone)); [EOL] int expected = zone.getOffset(instant.getMillis()); [EOL] int actual = zone.getOffset(instant); [EOL] assertEquals(expected, actual); [EOL] }
public void testGetOffsetFromLocal_SameOffsets() { [EOL] long instantLocal = 0L; [EOL] when(getOffset(instantLocal)).thenReturn(0); [EOL] when(getOffset(instantLocal - 0)).thenReturn(0); [EOL] int result = getOffsetFromLocal(instantLocal); [EOL] assertEquals(0, result); [EOL] }
public void testGetOffsetFromLocal_DifferentOffsets_PositiveOffsetChange() { [EOL] long instantLocal = 0L; [EOL] when(getOffset(instantLocal)).thenReturn(-1); [EOL] when(getOffset(instantLocal + 1)).thenReturn(1); [EOL] when(nextTransition(instantLocal + 1)).thenReturn(2L); [EOL] when(nextTransition(instantLocal - 1)).thenReturn(3L); [EOL] int result = getOffsetFromLocal(instantLocal); [EOL] assertEquals(-1, result); [EOL] }
public void testGetOffsetFromLocal_DifferentOffsets_NegativeOffsetChange() { [EOL] long instantLocal = 0L; [EOL] when(getOffset(instantLocal)).thenReturn(1); [EOL] when(getOffset(instantLocal - 1)).thenReturn(-1); [EOL] when(nextTransition(instantLocal - 1)).thenReturn(2L); [EOL] when(nextTransition(instantLocal - (-1))).thenReturn(2L); [EOL] int result = getOffsetFromLocal(instantLocal); [EOL] assertEquals(1, result); [EOL] }
public void testGetOffsetFromLocal_PositiveOffsetWithPreviousTransition() { [EOL] long instantLocal = 0L; [EOL] when(getOffset(instantLocal)).thenReturn(1); [EOL] when(getOffset(instantLocal - 1)).thenReturn(1); [EOL] when(previousTransition(instantLocal - 1)).thenReturn(-1L); [EOL] when(getOffset(-1L)).thenReturn(2); [EOL] int result = getOffsetFromLocal(instantLocal); [EOL] assertEquals(2, result); [EOL] }
public void testGetOffsetFromLocal_PositiveOffsetWithoutPreviousTransition() { [EOL] long instantLocal = 0L; [EOL] when(getOffset(instantLocal)).thenReturn(1); [EOL] when(getOffset(instantLocal - 1)).thenReturn(1); [EOL] when(previousTransition(instantLocal - 1)).thenReturn(instantLocal - 1); [EOL] int result = getOffsetFromLocal(instantLocal); [EOL] assertEquals(1, result); [EOL] }
public void testConvertLocalToUTC_SameOffset() { [EOL] long instantLocal = SOME_INSTANT_LOCAL; [EOL] boolean strict = true; // or false, doesn't impact this path [EOL] long originalInstantUTC = SOME_ORIGINAL_INSTANT_UTC; [EOL] when(this.getOffset(originalInstantUTC)).thenReturn(SOME_OFFSET); [EOL] when(this.getOffset(instantLocal - SOME_OFFSET)).thenReturn(SOME_OFFSET); [EOL] long result = convertLocalToUTC(instantLocal, strict, originalInstantUTC); [EOL] assertEquals(instantLocal - SOME_OFFSET, result); [EOL] }
public void testConvertLocalToUTC_DifferentOffset() { [EOL] long instantLocal = SOME_INSTANT_LOCAL; [EOL] boolean strict = true; // or false, doesn't impact this path [EOL] long originalInstantUTC = SOME_ORIGINAL_INSTANT_UTC; [EOL] when(this.getOffset(originalInstantUTC)).thenReturn(SOME_OFFSET); [EOL] when(this.getOffset(instantLocal - SOME_OFFSET)).thenReturn(ANOTHER_OFFSET); [EOL] long expected = convertLocalToUTC(instantLocal, strict); [EOL] long result = convertLocalToUTC(instantLocal, strict, originalInstantUTC); [EOL] assertEquals(expected, result); [EOL] }
public void testConvertLocalToUTC_SameOffset() { [EOL] long instantLocal = 0L; // Replace with appropriate test value [EOL] boolean strict = false; // Replace with appropriate test value [EOL] when(getOffset(instantLocal)).thenReturn(0); // Mock getOffset method [EOL] long result = convertLocalToUTC(instantLocal, strict); [EOL] assertEquals(instantLocal, result); // Assert that no change has been made to instantLocal [EOL] }
public void testConvertLocalToUTC_OffsetChanges_Strict() { [EOL] long instantLocal = 0L; // Replace with appropriate test value [EOL] boolean strict = true; // Replace with appropriate test value [EOL] when(getOffset(instantLocal)).thenReturn(1); [EOL] when(getOffset(instantLocal - 1)).thenReturn(2); [EOL] when(nextTransition(instantLocal - 1)).thenReturn(instantLocal - 1); [EOL] when(nextTransition(instantLocal - 2)).thenReturn(Long.MAX_VALUE); [EOL] try { [EOL] convertLocalToUTC(instantLocal, strict); [EOL] fail("Expected IllegalInstantException"); [EOL] } catch (IllegalInstantException e) { [EOL] } [EOL] }
public void testConvertLocalToUTC_OffsetChanges_NonStrict() { [EOL] long instantLocal = 0L; // Replace with appropriate test value [EOL] boolean strict = false; // Replace with appropriate test value [EOL] when(getOffset(instantLocal)).thenReturn(1); [EOL] when(getOffset(instantLocal - 1)).thenReturn(2); [EOL] when(nextTransition(instantLocal - 1)).thenReturn(instantLocal - 1); [EOL] when(nextTransition(instantLocal - 2)).thenReturn(Long.MAX_VALUE); [EOL] long result = convertLocalToUTC(instantLocal, strict); [EOL] assertEquals(instantLocal - 1, result); // Assert that offsetLocal is used [EOL] }
public void testConvertLocalToUTC_OffsetChanges_NonStrict_NegativeOffset() { [EOL] long instantLocal = 0L; // Replace with appropriate test value [EOL] boolean strict = false; // Replace with appropriate test value [EOL] when(getOffset(instantLocal)).thenReturn(-1); [EOL] when(getOffset(instantLocal + 1)).thenReturn(-2); [EOL] when(nextTransition(instantLocal + 1)).thenReturn(instantLocal + 1); [EOL] when(nextTransition(instantLocal - 2)).thenReturn(Long.MAX_VALUE); [EOL] long result = convertLocalToUTC(instantLocal, strict); [EOL] assertEquals(instantLocal + 1, result); // Assert that offsetLocal is used [EOL] }
public void testConvertLocalToUTC_Overflow() { [EOL] long instantLocal = Long.MAX_VALUE; // Replace with appropriate test value [EOL] boolean strict = false; // Replace with appropriate test value [EOL] when(getOffset(instantLocal)).thenReturn(Integer.MAX_VALUE); [EOL] try { [EOL] convertLocalToUTC(instantLocal, strict); [EOL] fail("Expected ArithmeticException"); [EOL] } catch (ArithmeticException e) { [EOL] } [EOL] }
public void testGetMillisKeepLocal_WithNullZone() { [EOL] DateTimeZone originalZone = DateTimeZone.forID("Europe/London"); [EOL] long oldInstant = System.currentTimeMillis(); [EOL] long expectedMillis = originalZone.getMillisKeepLocal(null, oldInstant); [EOL] assertEquals(expectedMillis, originalZone.getMillisKeepLocal(null, oldInstant)); [EOL] }
public void testGetMillisKeepLocal_WithSameZone() { [EOL] DateTimeZone originalZone = DateTimeZone.forID("Europe/London"); [EOL] long oldInstant = System.currentTimeMillis(); [EOL] assertEquals(oldInstant, originalZone.getMillisKeepLocal(originalZone, oldInstant)); [EOL] }
public void testGetMillisKeepLocal_WithDifferentZone() { [EOL] DateTimeZone originalZone = DateTimeZone.forID("Europe/London"); [EOL] DateTimeZone newZone = DateTimeZone.forID("America/New_York"); [EOL] long oldInstant = System.currentTimeMillis(); [EOL] long instantLocal = originalZone.convertUTCToLocal(oldInstant); [EOL] long expectedMillis = newZone.convertLocalToUTC(instantLocal, false, oldInstant); [EOL] assertEquals(expectedMillis, originalZone.getMillisKeepLocal(newZone, oldInstant)); [EOL] }
protected Object writeReplace() throws ObjectStreamException { [EOL] return new Stub(iID); [EOL] }
public void testStubConstructorAssignsCorrectId() { [EOL] String expectedId = "testId"; [EOL] YourClass instance = new YourClass(expectedId); [EOL] assertEquals(expectedId, instance.iID); [EOL] }
public void testWriteObject() throws IOException { [EOL] ByteArrayOutputStream baos = new ByteArrayOutputStream(); [EOL] ObjectOutputStream oos = new ObjectOutputStream(baos); [EOL] Time time = new Time("testID"); [EOL] time.writeObject(oos); [EOL] oos.flush(); [EOL] String result = baos.toString("UTF-8"); [EOL] assertTrue(result.contains("testID")); [EOL] }
private void readObject(ObjectInputStream in) throws IOException { [EOL] iID = in.readUTF(); [EOL] }
private Object readResolve() throws ObjectStreamException { [EOL] return forID(iID); [EOL] }
public void testGetMinimumDaysInFirstWeek() { [EOL] int expectedValue = 4; // Example value, can be any integer [EOL] Time time = new Time(expectedValue); [EOL] int actualValue = time.getMinimumDaysInFirstWeek(); [EOL] assertEquals(expectedValue, actualValue); [EOL] }
public void testToString_WithZoneAndDefaultMinDays() { [EOL] ConcreteTime time = new ConcreteTime(); [EOL] time.setZone(DateTimeZone.forID("Europe/London")); // Assuming setZone method exists [EOL] time.setMinimumDaysInFirstWeek(4); // Assuming setMinimumDaysInFirstWeek method exists [EOL] String result = time.toString(); [EOL] assertTrue(result.contains("Europe/London")); [EOL] assertFalse(result.contains("mdfw=")); [EOL] }
public void testToString_WithoutZoneAndNonDefaultMinDays() { [EOL] ConcreteTime time = new ConcreteTime(); [EOL] time.setZone(null); // Assuming setZone method exists [EOL] time.setMinimumDaysInFirstWeek(5); // Assuming setMinimumDaysInFirstWeek method exists [EOL] String result = time.toString(); [EOL] assertFalse(result.contains("Europe/London")); [EOL] assertTrue(result.contains("mdfw=5")); [EOL] }
public void testToString_WithZoneAndNonDefaultMinDays() { [EOL] ConcreteTime time = new ConcreteTime(); [EOL] time.setZone(DateTimeZone.forID("Europe/Paris")); // Assuming setZone method exists [EOL] time.setMinimumDaysInFirstWeek(6); // Assuming setMinimumDaysInFirstWeek method exists [EOL] String result = time.toString(); [EOL] assertTrue(result.contains("Europe/Paris")); [EOL] assertTrue(result.contains("mdfw=6")); [EOL] }
public void testGetDaysInYearMax() { [EOL] Time time = new Time(); [EOL] int expected = 366; [EOL] int actual = time.getDaysInYearMax(); [EOL] assertEquals(expected, actual); [EOL] }
public void testGetDaysInYear_LeapYear() { [EOL] int year = 2020; // Example leap year [EOL] int expectedDays = 366; [EOL] int actualDays = getDaysInYear(year); [EOL] assertEquals(expectedDays, actualDays); [EOL] }
public void testGetDaysInYear_NonLeapYear() { [EOL] int year = 2019; // Example non-leap year [EOL] int expectedDays = 365; [EOL] int actualDays = getDaysInYear(year); [EOL] assertEquals(expectedDays, actualDays); [EOL] }
public void testGetYear_NegativeInstant() { [EOL] long instant = -1L; // some negative instant [EOL] int expectedYear = -1970; // expected year for the given instant [EOL] int actualYear = getYear(instant); [EOL] assertEquals(expectedYear, actualYear); [EOL] }
public void testGetYear_StartOfEpoch() { [EOL] long instant = 0L; // start of the epoch [EOL] int expectedYear = 1970; // expected year for the given instant [EOL] int actualYear = getYear(instant); [EOL] assertEquals(expectedYear, actualYear); [EOL] }
public void testGetYear_JustBeforeNewYear() { [EOL] long instant = DateTimeConstants.MILLIS_PER_DAY * 365L - 1; // just before the new year [EOL] int expectedYear = 1970; // expected year for the given instant [EOL] int actualYear = getYear(instant); [EOL] assertEquals(expectedYear, actualYear); [EOL] }
public void testGetYear_JustAfterNewYear() { [EOL] long instant = DateTimeConstants.MILLIS_PER_DAY * 365L; // just after the new year [EOL] int expectedYear = 1971; // expected year for the given instant [EOL] int actualYear = getYear(instant); [EOL] assertEquals(expectedYear, actualYear); [EOL] }
public void testGetYear_LeapYear() { [EOL] long instant = DateTimeConstants.MILLIS_PER_DAY * (365L + 366L); // just after a leap year [EOL] int expectedYear = 1972; // expected year for the given instant [EOL] int actualYear = getYear(instant); [EOL] assertEquals(expectedYear, actualYear); [EOL] }
public void testGetYear_JustBeforeLeapYear() { [EOL] long instant = DateTimeConstants.MILLIS_PER_DAY * (365L * 3 + 364L); // just before a leap year [EOL] int expectedYear = 1972; // expected year for the given instant [EOL] int actualYear = getYear(instant); [EOL] assertEquals(expectedYear, actualYear); [EOL] }
public void testGetYear_JustAfterLeapYear() { [EOL] long instant = DateTimeConstants.MILLIS_PER_DAY * (365L * 3 + 365L); // just after a leap year [EOL] int expectedYear = 1973; // expected year for the given instant [EOL] int actualYear = getYear(instant); [EOL] assertEquals(expectedYear, actualYear); [EOL] }
public void testGetWeekyear_StartOfYear() { [EOL] long startOfYearInstant = /* provide the instant representing the start of a year */; [EOL] int expectedYear = /* provide the expected week year for the start of the year */; [EOL] int actualYear = getWeekyear(startOfYearInstant); [EOL] assertEquals(expectedYear, actualYear); [EOL] }
public void testGetWeekyear_FirstWeekOfNewYear() { [EOL] long firstWeekOfNewYearInstant = /* provide the instant representing the first week of the new year */; [EOL] int expectedYear = /* provide the expected week year for the first week of the new year */; [EOL] int actualYear = getWeekyear(firstWeekOfNewYearInstant); [EOL] assertEquals(expectedYear, actualYear); [EOL] }
public void testGetWeekyear_LastWeekOfPreviousYear() { [EOL] long lastWeekOfPreviousYearInstant = /* provide the instant representing the last week of the previous year */; [EOL] int expectedYear = /* provide the expected week year for the last week of the previous year */; [EOL] int actualYear = getWeekyear(lastWeekOfPreviousYearInstant); [EOL] assertEquals(expectedYear, actualYear); [EOL] }
public void testGetWeekOfWeekyear_BeforeFirstWeek() { [EOL] int year = 2021; [EOL] long instant = getFirstWeekOfYearMillis(year) - 1; // one millisecond before the first week [EOL] int expectedWeek = getWeeksInYear(year - 1); [EOL] int actualWeek = getWeekOfWeekyear(instant, year); [EOL] assertEquals(expectedWeek, actualWeek); [EOL] }
public void testGetWeekOfWeekyear_FirstWeek() { [EOL] int year = 2021; [EOL] long instant = getFirstWeekOfYearMillis(year); // exactly at the first week [EOL] int expectedWeek = 1; [EOL] int actualWeek = getWeekOfWeekyear(instant, year); [EOL] assertEquals(expectedWeek, actualWeek); [EOL] }
public void testGetWeekOfWeekyear_LastWeek() { [EOL] int year = 2021; [EOL] long instant = getFirstWeekOfYearMillis(year + 1) - DateTimeConstants.MILLIS_PER_WEEK; // last week of the year [EOL] int expectedWeek = (int) ((instant - getFirstWeekOfYearMillis(year)) / DateTimeConstants.MILLIS_PER_WEEK) + 1; [EOL] int actualWeek = getWeekOfWeekyear(instant, year); [EOL] assertEquals(expectedWeek, actualWeek); [EOL] }
public void testGetWeekOfWeekyear_FirstWeekOfNextYear() { [EOL] int year = 2021; [EOL] long instant = getFirstWeekOfYearMillis(year + 1); // exactly at the first week of the next year [EOL] int expectedWeek = 1; [EOL] int actualWeek = getWeekOfWeekyear(instant, year); [EOL] assertEquals(expectedWeek, actualWeek); [EOL] }
public void testGetDaysInMonthMax() { [EOL] Time time = new Time(); [EOL] int days = time.getDaysInMonthMax(); [EOL] assertEquals(31, days); [EOL] }
public void testGetDaysInMonthMax_January() { [EOL] long instant = new DateTime(2021, 1, 1, 0, 0).getMillis(); [EOL] int daysInMonth = getDaysInMonthMax(instant); [EOL] assertEquals(31, daysInMonth); [EOL] }
public void testGetDaysInMonthMax_FebruaryNonLeapYear() { [EOL] long instant = new DateTime(2021, 2, 1, 0, 0).getMillis(); [EOL] int daysInMonth = getDaysInMonthMax(instant); [EOL] assertEquals(28, daysInMonth); [EOL] }
public void testGetDaysInMonthMax_FebruaryLeapYear() { [EOL] long instant = new DateTime(2020, 2, 1, 0, 0).getMillis(); [EOL] int daysInMonth = getDaysInMonthMax(instant); [EOL] assertEquals(29, daysInMonth); [EOL] }
public void testGetDaysInMonthMax_April() { [EOL] long instant = new DateTime(2021, 4, 1, 0, 0).getMillis(); [EOL] int daysInMonth = getDaysInMonthMax(instant); [EOL] assertEquals(30, daysInMonth); [EOL] }
public void testGetDaysInMonthMaxForSet() { [EOL] long instant = new DateTime(2023, 3, 1, 0, 0, DateTimeZone.UTC).getMillis(); [EOL] int value = 1; // value is not used in the method, so any int should be fine [EOL] int expectedDays = 31; // March has 31 days [EOL] int actualDays = getDaysInMonthMaxForSet(instant, value); [EOL] assertEquals(expectedDays, actualDays); [EOL] }
protected BasePeriod(ReadablePartial start, ReadablePartial end, PeriodType type) { [EOL] super(); [EOL] if (start == null || end == null) { [EOL] throw new IllegalArgumentException("ReadablePartial objects must not be null"); [EOL] } [EOL] if (start instanceof BaseLocal && end instanceof BaseLocal && start.getClass() == end.getClass()) { [EOL] type = checkPeriodType(type); [EOL] long startMillis = ((BaseLocal) start).getLocalMillis(); [EOL] long endMillis = ((BaseLocal) end).getLocalMillis(); [EOL] Chronology chrono = start.getChronology(); [EOL] chrono = DateTimeUtils.getChronology(chrono); [EOL] iType = type; [EOL] iValues = chrono.get(this, startMillis, endMillis); [EOL] } else { [EOL] if (start.size() != end.size()) { [EOL] throw new IllegalArgumentException("ReadablePartial objects must have the same set of fields"); [EOL] } [EOL] for (int i = 0, isize = start.size(); i < isize; i++) { [EOL] if (start.getFieldType(i) != end.getFieldType(i)) { [EOL] throw new IllegalArgumentException("ReadablePartial objects must have the same set of fields"); [EOL] } [EOL] } [EOL] if (DateTimeUtils.isContiguous(start) == false) { [EOL] throw new IllegalArgumentException("ReadablePartial objects must be contiguous"); [EOL] } [EOL] iType = checkPeriodType(type); [EOL] Chronology chrono = DateTimeUtils.getChronology(start.getChronology()).withUTC(); [EOL] iValues = chrono.get(this, chrono.set(start, 0L), chrono.set(end, 0L)); [EOL] } [EOL] }
private void checkAndUpdate(DurationFieldType type, int[] values, int newValue) { [EOL] int index = indexOf(type); [EOL] if (index == -1) { [EOL] if (newValue != 0) { [EOL] throw new IllegalArgumentException("Period does not support field '" + type.getName() + "'"); [EOL] } [EOL] } else { [EOL] values[index] = newValue; [EOL] } [EOL] } [EOL] protected BasePeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis, PeriodType type); [EOL] protected BasePeriod(long startInstant, long endInstant, PeriodType type, Chronology chrono); [EOL] protected BasePeriod(ReadableInstant startInstant, ReadableInstant endInstant, PeriodType type); [EOL] protected BasePeriod(ReadablePartial start, ReadablePartial end, PeriodType type); [EOL] protected BasePeriod(ReadableInstant startInstant, ReadableDuration duration, PeriodType type); [EOL] protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, PeriodType type); [EOL] protected BasePeriod(long duration); [EOL] protected BasePeriod(long duration, PeriodType type, Chronology chrono); [EOL] protected BasePeriod(Object period, PeriodType type, Chronology chrono); [EOL] protected BasePeriod(int[] values, PeriodType type); [EOL] public int getValue(int index); [EOL] public PeriodType getPeriodType(); [EOL] protected PeriodType checkPeriodType(PeriodType type); [EOL] public PeriodType getPeriodType(); [EOL] public int getValue(int index); [EOL] public Duration toDurationFrom(ReadableInstant startInstant); [EOL] public Duration toDurationTo(ReadableInstant endInstant); [EOL] private void checkAndUpdate(DurationFieldType type, int[] values, int newValue); [EOL] protected void setPeriod(ReadablePeriod period); [EOL] private void setPeriodInternal(ReadablePeriod period); [EOL] protected void setPeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); [EOL] private int[] setPeriodInternal(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); [EOL] protected void setField(DurationFieldType field, int value); [EOL] protected void setFieldInto(int[] values, DurationFieldType field, int value); [EOL] protected void addField(DurationFieldType field, int value); [EOL] protected void addFieldInto(int[] values, DurationFieldType field, int value); [EOL] protected void mergePeriod(ReadablePeriod period); [EOL] protected int[] mergePeriodInto(int[] values, ReadablePeriod period); [EOL] protected void addPeriod(ReadablePeriod period); [EOL] protected int[] addPeriodInto(int[] values, ReadablePeriod period); [EOL] protected void setValue(int index, int value); [EOL] protected void setValues(int[] values); [EOL] long serialVersionUID=Optional[-2110953284060001145L]; [EOL] ReadablePeriod DUMMY_PERIOD=Optional[new AbstractPeriod() { [EOL] public int getValue(int index) { [EOL] return 0; [EOL] }; [EOL] public PeriodType getPeriodType() { [EOL] return PeriodType.time(); [EOL] }; [EOL] }];
protected void addFieldInto(int[] values, DurationFieldType field, int value) { [EOL] int index = indexOf(field); [EOL] if (index == -1) { [EOL] if (value != 0 || field == null) { [EOL] throw new IllegalArgumentException("Period does not support field '" + field + "'"); [EOL] } [EOL] } else { [EOL] values[index] = FieldUtils.safeAdd(values[index], value); [EOL] } [EOL] } protected BasePeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis, PeriodType type); protected BasePeriod(long startInstant, long endInstant, PeriodType type, Chronology chrono); protected BasePeriod(ReadableInstant startInstant, ReadableInstant endInstant, PeriodType type); protected BasePeriod(ReadablePartial start, ReadablePartial end, PeriodType type); protected BasePeriod(ReadableInstant startInstant, ReadableDuration duration, PeriodType type); protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, PeriodType type); protected BasePeriod(long duration); protected BasePeriod(long duration, PeriodType type, Chronology chrono); protected BasePeriod(Object period, PeriodType type, Chronology chrono); protected BasePeriod(int[] values, PeriodType type); public int getValue(int index); public PeriodType getPeriodType(); protected PeriodType checkPeriodType(PeriodType type); public PeriodType getPeriodType(); public int getValue(int index); public Duration toDurationFrom(ReadableInstant startInstant); public Duration toDurationTo(ReadableInstant endInstant); private void checkAndUpdate(DurationFieldType type, int[] values, int newValue); protected void setPeriod(ReadablePeriod period); private void setPeriodInternal(ReadablePeriod period); protected void setPeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); private int[] setPeriodInternal(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); protected void setField(DurationFieldType field, int value); protected void setFieldInto(int[] values, DurationFieldType field, int value); protected void addField(DurationFieldType field, int value); protected void addFieldInto(int[] values, DurationFieldType field, int value); protected void mergePeriod(ReadablePeriod period); protected int[] mergePeriodInto(int[] values, ReadablePeriod period); protected void addPeriod(ReadablePeriod period); protected int[] addPeriodInto(int[] values, ReadablePeriod period); protected void setValue(int index, int value); protected void setValues(int[] values); long serialVersionUID=Optional[-2110953284060001145L]; ReadablePeriod DUMMY_PERIOD=Optional[new AbstractPeriod() {; ;     public int getValue(int index) {;         return 0;;     }; ;     public PeriodType getPeriodType() {;         return PeriodType.time();;     }; }
protected void addPeriod(ReadablePeriod period) { [EOL] if (period != null) { [EOL] setValues(addPeriodInto(getValues(), period)); [EOL] } [EOL] } [EOL] protected BasePeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis, PeriodType type); [EOL] protected BasePeriod(long startInstant, long endInstant, PeriodType type, Chronology chrono); [EOL] protected BasePeriod(ReadableInstant startInstant, ReadableInstant endInstant, PeriodType type); [EOL] protected BasePeriod(ReadablePartial start, ReadablePartial end, PeriodType type); [EOL] protected BasePeriod(ReadableInstant startInstant, ReadableDuration duration, PeriodType type); [EOL] protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, PeriodType type); [EOL] protected BasePeriod(long duration); [EOL] protected BasePeriod(long duration, PeriodType type, Chronology chrono); [EOL] protected BasePeriod(Object period, PeriodType type, Chronology chrono); [EOL] protected BasePeriod(int[] values, PeriodType type); [EOL] public int getValue(int index); [EOL] public PeriodType getPeriodType(); [EOL] protected PeriodType checkPeriodType(PeriodType type); [EOL] public PeriodType getPeriodType(); [EOL] public int getValue(int index); [EOL] public Duration toDurationFrom(ReadableInstant startInstant); [EOL] public Duration toDurationTo(ReadableInstant endInstant); [EOL] private void checkAndUpdate(DurationFieldType type, int[] values, int newValue); [EOL] protected void setPeriod(ReadablePeriod period); [EOL] private void setPeriodInternal(ReadablePeriod period); [EOL] protected void setPeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); [EOL] private int[] setPeriodInternal(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); [EOL] protected void setField(DurationFieldType field, int value); [EOL] protected void setFieldInto(int[] values, DurationFieldType field, int value); [EOL] protected void addField(DurationFieldType field, int value); [EOL] protected void addFieldInto(int[] values, DurationFieldType field, int value); [EOL] protected void mergePeriod(ReadablePeriod period); [EOL] protected int[] mergePeriodInto(int[] values, ReadablePeriod period); [EOL] protected void addPeriod(ReadablePeriod period); [EOL] protected int[] addPeriodInto(int[] values, ReadablePeriod period); [EOL] protected void setValue(int index, int value); [EOL] protected void setValues(int[] values); [EOL] long serialVersionUID=Optional[-2110953284060001145L]; [EOL] ReadablePeriod DUMMY_PERIOD=Optional[new AbstractPeriod() { [EOL] public int getValue(int index) { [EOL] return 0; [EOL] }; [EOL] public PeriodType getPeriodType() { [EOL] return PeriodType.time(); [EOL] }; [EOL] }]
protected int[] addPeriodInto(int[] values, ReadablePeriod period) { [EOL] for (int i = 0, isize = period.size(); i < isize; i++) { [EOL] DurationFieldType type = period.getFieldType(i); [EOL] int value = period.getValue(i); [EOL] if (value != 0) { [EOL] int index = indexOf(type); [EOL] if (index == -1) { [EOL] throw new IllegalArgumentException("Period does not support field '" + type.getName() + "'"); [EOL] } else { [EOL] values[index] = FieldUtils.safeAdd(getValue(index), value); [EOL] } [EOL] } [EOL] } [EOL] return values; [EOL] } [EOL] protected BasePeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis, PeriodType type); [EOL] protected BasePeriod(long startInstant, long endInstant, PeriodType type, Chronology chrono); [EOL] protected BasePeriod(ReadableInstant startInstant, ReadableInstant endInstant, PeriodType type); [EOL] protected BasePeriod(ReadablePartial start, ReadablePartial end, PeriodType type); [EOL] protected BasePeriod(ReadableInstant startInstant, ReadableDuration duration, PeriodType type); [EOL] protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, PeriodType type); [EOL] protected BasePeriod(long duration); [EOL] protected BasePeriod(long duration, PeriodType type, Chronology chrono); [EOL] protected BasePeriod(Object period, PeriodType type, Chronology chrono); [EOL] protected BasePeriod(int[] values, PeriodType type); [EOL] public int getValue(int index); [EOL] public PeriodType getPeriodType(); [EOL] protected PeriodType checkPeriodType(PeriodType type); [EOL] public PeriodType getPeriodType(); [EOL] public int getValue(int index); [EOL] public Duration toDurationFrom(ReadableInstant startInstant); [EOL] public Duration toDurationTo(ReadableInstant endInstant); [EOL] private void checkAndUpdate(DurationFieldType type, int[] values, int newValue); [EOL] protected void setPeriod(ReadablePeriod period); [EOL] private void setPeriodInternal(ReadablePeriod period); [EOL] protected void setPeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); [EOL] private int[] setPeriodInternal(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); [EOL] protected void setField(DurationFieldType field, int value); [EOL] protected void setFieldInto(int[] values, DurationFieldType field, int value); [EOL] protected void addField(DurationFieldType field, int value); [EOL] protected void addFieldInto(int[] values, DurationFieldType field, int value); [EOL] protected void mergePeriod(ReadablePeriod period); [EOL] protected int[] mergePeriodInto(int[] values, ReadablePeriod period); [EOL] protected void addPeriod(ReadablePeriod period); [EOL] protected int[] addPeriodInto(int[] values, ReadablePeriod period); [EOL] protected void setValue(int index, int value); [EOL] protected void setValues(int[] values); [EOL] long serialVersionUID=Optional[-2110953284060001145L]; [EOL] ReadablePeriod DUMMY_PERIOD=Optional[new AbstractPeriod() { [EOL] public int getValue(int index) { [EOL] return 0; [EOL] }; [EOL] public PeriodType getPeriodType() { [EOL] return PeriodType.time(); [EOL] }; [EOL] }]
protected void setValues(int[] values) { [EOL] System.arraycopy(values, 0, iValues, 0, iValues.length); [EOL] } [EOL] protected BasePeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis, PeriodType type); [EOL] protected BasePeriod(long startInstant, long endInstant, PeriodType type, Chronology chrono); [EOL] protected BasePeriod(ReadableInstant startInstant, ReadableInstant endInstant, PeriodType type); [EOL] protected BasePeriod(ReadablePartial start, ReadablePartial end, PeriodType type); [EOL] protected BasePeriod(ReadableInstant startInstant, ReadableDuration duration, PeriodType type); [EOL] protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, PeriodType type); [EOL] protected BasePeriod(long duration); [EOL] protected BasePeriod(long duration, PeriodType type, Chronology chrono); [EOL] protected BasePeriod(Object period, PeriodType type, Chronology chrono); [EOL] protected BasePeriod(int[] values, PeriodType type); [EOL] public int getValue(int index); [EOL] public PeriodType getPeriodType(); [EOL] protected PeriodType checkPeriodType(PeriodType type); [EOL] public PeriodType getPeriodType(); [EOL] public int getValue(int index); [EOL] public Duration toDurationFrom(ReadableInstant startInstant); [EOL] public Duration toDurationTo(ReadableInstant endInstant); [EOL] private void checkAndUpdate(DurationFieldType type, int[] values, int newValue); [EOL] protected void setPeriod(ReadablePeriod period); [EOL] private void setPeriodInternal(ReadablePeriod period); [EOL] protected void setPeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); [EOL] private int[] setPeriodInternal(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); [EOL] protected void setField(DurationFieldType field, int value); [EOL] protected void setFieldInto(int[] values, DurationFieldType field, int value); [EOL] protected void addField(DurationFieldType field, int value); [EOL] protected void addFieldInto(int[] values, DurationFieldType field, int value); [EOL] protected void mergePeriod(ReadablePeriod period); [EOL] protected int[] mergePeriodInto(int[] values, ReadablePeriod period); [EOL] protected void addPeriod(ReadablePeriod period); [EOL] protected int[] addPeriodInto(int[] values, ReadablePeriod period); [EOL] protected void setValue(int index, int value); [EOL] protected void setValues(int[] values); [EOL] long serialVersionUID=Optional[-2110953284060001145L]; [EOL] ReadablePeriod DUMMY_PERIOD=Optional[new AbstractPeriod() { [EOL] public int getValue(int index) { [EOL] return 0; [EOL] }; [EOL] public PeriodType getPeriodType() { [EOL] return PeriodType.time(); [EOL] }; [EOL] }]
public void testForFieldsWithNullFields() { [EOL] try { [EOL] DateTimeFormatter.forFields(null, true, true); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("The fields must not be null or empty", e.getMessage()); [EOL] } [EOL] }
public void testForFieldsWithEmptyFields() { [EOL] try { [EOL] DateTimeFormatter.forFields(Collections.emptyList(), true, true); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("The fields must not be null or empty", e.getMessage()); [EOL] } [EOL] }
public void testForFieldsWithMonthOfYear() { [EOL] Set<DateTimeFieldType> fields = new HashSet<>(); [EOL] fields.add(DateTimeFieldType.monthOfYear()); [EOL] DateTimeFormatter formatter = DateTimeFormatter.forFields(fields, true, true); [EOL] assertNotNull(formatter); [EOL] }
public void testForFieldsWithDayOfYear() { [EOL] Set<DateTimeFieldType> fields = new HashSet<>(); [EOL] fields.add(DateTimeFieldType.dayOfYear()); [EOL] DateTimeFormatter formatter = DateTimeFormatter.forFields(fields, true, true); [EOL] assertNotNull(formatter); [EOL] }
public void testForFieldsWithWeekOfWeekyear() { [EOL] Set<DateTimeFieldType> fields = new HashSet<>(); [EOL] fields.add(DateTimeFieldType.weekOfWeekyear()); [EOL] DateTimeFormatter formatter = DateTimeFormatter.forFields(fields, true, true); [EOL] assertNotNull(formatter); [EOL] }
public void testForFieldsWithDayOfMonth() { [EOL] Set<DateTimeFieldType> fields = new HashSet<>(); [EOL] fields.add(DateTimeFieldType.dayOfMonth()); [EOL] DateTimeFormatter formatter = DateTimeFormatter.forFields(fields, true, true); [EOL] assertNotNull(formatter); [EOL] }
public void testForFieldsWithDayOfWeek() { [EOL] Set<DateTimeFieldType> fields = new HashSet<>(); [EOL] fields.add(DateTimeFieldType.dayOfWeek()); [EOL] DateTimeFormatter formatter = DateTimeFormatter.forFields(fields, true, true); [EOL] assertNotNull(formatter); [EOL] }
public void testForFieldsWithYear() { [EOL] Set<DateTimeFieldType> fields = new HashSet<>(); [EOL] fields.add(DateTimeFieldType.year()); [EOL] DateTimeFormatter formatter = DateTimeFormatter.forFields(fields, true, true); [EOL] assertNotNull(formatter); [EOL] }
public void testForFieldsWithWeekyear() { [EOL] Set<DateTimeFieldType> fields = new HashSet<>(); [EOL] fields.add(DateTimeFieldType.weekyear()); [EOL] DateTimeFormatter formatter = DateTimeFormatter.forFields(fields, true, true); [EOL] assertNotNull(formatter); [EOL] }
public void testForFieldsWithUnsupportedOperationException() { [EOL] Set<DateTimeFieldType> fields = new HashSet<DateTimeFieldType>() { [EOL] @Override [EOL] public boolean retainAll(Collection<?> c) { [EOL] throw new UnsupportedOperationException(); [EOL] } [EOL] }; [EOL] fields.add(DateTimeFieldType.year()); [EOL] DateTimeFormatter formatter = DateTimeFormatter.forFields(fields, true, true); [EOL] assertNotNull(formatter); [EOL] }
public void testForFieldsWithInvalidFields() { [EOL] Set<DateTimeFieldType> fields = new HashSet<>(); [EOL] fields.add(DateTimeFieldType.hourOfDay()); [EOL] try { [EOL] DateTimeFormatter.forFields(fields, true, true); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("No valid format for fields: " + fields, e.getMessage()); [EOL] } [EOL] }
public void testDateByMonthWithYearMonthDay() { [EOL] DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL] Set<DateTimeFieldType> fields = new HashSet<>(); [EOL] fields.add(DateTimeFieldType.year()); [EOL] fields.add(DateTimeFieldType.monthOfYear()); [EOL] fields.add(DateTimeFieldType.dayOfMonth()); [EOL] boolean extended = true; [EOL] boolean strictISO = false; [EOL] boolean result = dateByMonth(bld, fields, extended, strictISO); [EOL] assertFalse(result); [EOL] }
public void testDateByMonthWithYearMonth() { [EOL] DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL] Set<DateTimeFieldType> fields = new HashSet<>(); [EOL] fields.add(DateTimeFieldType.year()); [EOL] fields.add(DateTimeFieldType.monthOfYear()); [EOL] boolean extended = true; [EOL] boolean strictISO = false; [EOL] boolean result = dateByMonth(bld, fields, extended, strictISO); [EOL] assertTrue(result); [EOL] }
public void testDateByMonthWithYearDay() { [EOL] DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL] Set<DateTimeFieldType> fields = new HashSet<>(); [EOL] fields.add(DateTimeFieldType.year()); [EOL] fields.add(DateTimeFieldType.dayOfMonth()); [EOL] boolean extended = true; [EOL] boolean strictISO = false; [EOL] boolean result = dateByMonth(bld, fields, extended, strictISO); [EOL] assertTrue(result); [EOL] }
public void testDateByMonthWithYearOnly() { [EOL] DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL] Set<DateTimeFieldType> fields = new HashSet<>(); [EOL] fields.add(DateTimeFieldType.year()); [EOL] boolean extended = true; [EOL] boolean strictISO = false; [EOL] boolean result = dateByMonth(bld, fields, extended, strictISO); [EOL] assertTrue(result); [EOL] }
public void testDateByMonthWithMonthDay() { [EOL] DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL] Set<DateTimeFieldType> fields = new HashSet<>(); [EOL] fields.add(DateTimeFieldType.monthOfYear()); [EOL] fields.add(DateTimeFieldType.dayOfMonth()); [EOL] boolean extended = true; [EOL] boolean strictISO = false; [EOL] boolean result = dateByMonth(bld, fields, extended, strictISO); [EOL] assertFalse(result); [EOL] }
public void testDateByMonthWithMonthOnly() { [EOL] DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL] Set<DateTimeFieldType> fields = new HashSet<>(); [EOL] fields.add(DateTimeFieldType.monthOfYear()); [EOL] boolean extended = true; [EOL] boolean strictISO = false; [EOL] boolean result = dateByMonth(bld, fields, extended, strictISO); [EOL] assertTrue(result); [EOL] }
public void testDateByMonthWithDayOnly() { [EOL] DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL] Set<DateTimeFieldType> fields = new HashSet<>(); [EOL] fields.add(DateTimeFieldType.dayOfMonth()); [EOL] boolean extended = true; [EOL] boolean strictISO = false; [EOL] boolean result = dateByMonth(bld, fields, extended, strictISO); [EOL] assertFalse(result); [EOL] }
public void testDateByMonthWithNoFields() { [EOL] DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL] Set<DateTimeFieldType> fields = new HashSet<>(); [EOL] boolean extended = true; [EOL] boolean strictISO = false; [EOL] boolean result = dateByMonth(bld, fields, extended, strictISO); [EOL] assertFalse(result); [EOL] }
public void testDateByWeekWithWeekYear() { [EOL] DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL] Collection<DateTimeFieldType> fields = new HashSet<>(); [EOL] fields.add(DateTimeFieldType.weekyear()); [EOL] boolean extended = true; [EOL] boolean strictISO = false; [EOL] boolean result = dateByWeek(bld, fields, extended, strictISO); [EOL] assertFalse(result); [EOL] }
public void testDateByWeekWithWeekOfWeekyear() { [EOL] DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL] Collection<DateTimeFieldType> fields = new HashSet<>(); [EOL] fields.add(DateTimeFieldType.weekOfWeekyear()); [EOL] boolean extended = true; [EOL] boolean strictISO = false; [EOL] boolean result = dateByWeek(bld, fields, extended, strictISO); [EOL] assertTrue(result); [EOL] }
public void testDateByWeekWithDayOfWeek() { [EOL] DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL] Collection<DateTimeFieldType> fields = new HashSet<>(); [EOL] fields.add(DateTimeFieldType.dayOfWeek()); [EOL] boolean extended = true; [EOL] boolean strictISO = false; [EOL] boolean result = dateByWeek(bld, fields, extended, strictISO); [EOL] assertFalse(result); [EOL] }
public void testDateByWeekWithWeekYearWeekOfWeekyear() { [EOL] DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL] Collection<DateTimeFieldType> fields = new HashSet<>(); [EOL] fields.add(DateTimeFieldType.weekyear()); [EOL] fields.add(DateTimeFieldType.weekOfWeekyear()); [EOL] boolean extended = true; [EOL] boolean strictISO = false; [EOL] boolean result = dateByWeek(bld, fields, extended, strictISO); [EOL] assertFalse(result); [EOL] }
public void testDateByWeekWithWeekYearDayOfWeek() { [EOL] DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL] Collection<DateTimeFieldType> fields = new HashSet<>(); [EOL] fields.add(DateTimeFieldType.weekyear()); [EOL] fields.add(DateTimeFieldType.dayOfWeek()); [EOL] boolean extended = true; [EOL] boolean strictISO = false; [EOL] boolean result = dateByWeek(bld, fields, extended, strictISO); [EOL] assertTrue(result); [EOL] }
public void testDateByWeekWithWeekOfWeekyearDayOfWeek() { [EOL] DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL] Collection<DateTimeFieldType> fields = new HashSet<>(); [EOL] fields.add(DateTimeFieldType.weekOfWeekyear()); [EOL] fields.add(DateTimeFieldType.dayOfWeek()); [EOL] boolean extended = true; [EOL] boolean strictISO = false; [EOL] boolean result = dateByWeek(bld, fields, extended, strictISO); [EOL] assertFalse(result); [EOL] }
public void testDateByWeekWithAllFields() { [EOL] DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL] Collection<DateTimeFieldType> fields = new HashSet<>(); [EOL] fields.add(DateTimeFieldType.weekyear()); [EOL] fields.add(DateTimeFieldType.weekOfWeekyear()); [EOL] fields.add(DateTimeFieldType.dayOfWeek()); [EOL] boolean extended = true; [EOL] boolean strictISO = false; [EOL] boolean result = dateByWeek(bld, fields, extended, strictISO); [EOL] assertFalse(result); [EOL] }
public void testDateByWeekWithStrictISO() { [EOL] DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL] Collection<DateTimeFieldType> fields = new HashSet<>(); [EOL] fields.add(DateTimeFieldType.weekyear()); [EOL] fields.add(DateTimeFieldType.dayOfWeek()); [EOL] boolean extended = true; [EOL] boolean strictISO = true; [EOL] boolean result = dateByWeek(bld, fields, extended, strictISO); [EOL] assertTrue(result); [EOL] }
public void testTimeWithNoFields() { [EOL] DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL] Collection<DateTimeFieldType> fields = new HashSet<>(); [EOL] time(bld, fields, false, false, false, false); [EOL] assertEquals("", bld.toFormatter().toString()); [EOL] }
public void testTimeWithHourOnly() { [EOL] DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL] Collection<DateTimeFieldType> fields = new HashSet<>(); [EOL] fields.add(DateTimeFieldType.hourOfDay()); [EOL] time(bld, fields, false, false, false, false); [EOL] assertEquals("HH", bld.toFormatter().toString()); [EOL] }
public void testTimeWithHourMinuteSecond() { [EOL] DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL] Collection<DateTimeFieldType> fields = new HashSet<>(); [EOL] fields.add(DateTimeFieldType.hourOfDay()); [EOL] fields.add(DateTimeFieldType.minuteOfHour()); [EOL] fields.add(DateTimeFieldType.secondOfMinute()); [EOL] time(bld, fields, true, false, false, false); [EOL] assertEquals("HH:mm:ss", bld.toFormatter().toString()); [EOL] }
public void testTimeWithStrictISOAndReducedPrecision() { [EOL] DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL] Collection<DateTimeFieldType> fields = new HashSet<>(); [EOL] fields.add(DateTimeFieldType.hourOfDay()); [EOL] try { [EOL] time(bld, fields, false, true, true, false); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testTimeWithDatePresentAndStrictISO() { [EOL] DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL] Collection<DateTimeFieldType> fields = new HashSet<>(); [EOL] fields.add(DateTimeFieldType.minuteOfHour()); [EOL] fields.add(DateTimeFieldType.secondOfMinute()); [EOL] try { [EOL] time(bld, fields, false, true, false, true); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testTimeWithStrictISOWithoutHour() { [EOL] DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL] Collection<DateTimeFieldType> fields = new HashSet<>(); [EOL] fields.add(DateTimeFieldType.minuteOfHour()); [EOL] try { [EOL] time(bld, fields, false, true, false, false); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testTimeWithExtendedFormat() { [EOL] DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL] Collection<DateTimeFieldType> fields = new HashSet<>(); [EOL] fields.add(DateTimeFieldType.hourOfDay()); [EOL] fields.add(DateTimeFieldType.minuteOfHour()); [EOL] time(bld, fields, true, false, false, false); [EOL] assertEquals("HH:mm", bld.toFormatter().toString()); [EOL] }
public void testTimeWithMillis() { [EOL] DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL] Collection<DateTimeFieldType> fields = new HashSet<>(); [EOL] fields.add(DateTimeFieldType.millisOfSecond()); [EOL] time(bld, fields, false, false, false, false); [EOL] assertEquals("-.SSS", bld.toFormatter().toString()); [EOL] }
public void testDateReturnsYearMonthDayFormatter() { [EOL] DateTimeFormatter formatter = ClassName.date(); [EOL] assertNotNull(formatter); [EOL] }
public static DateTimeFormatter time() { [EOL] return Constants.t; [EOL] }
public void testDateTime() { [EOL] DateTimeFormatter result = YourClass.dateTime(); [EOL] assertNotNull(result); [EOL] assertEquals(Constants.dt, result); [EOL] }
public void testDateTimeNoMillis() { [EOL] DateTimeFormatter formatter = ClassName.dateTimeNoMillis(); [EOL] assertNotNull(formatter); [EOL] }
public void testOrdinalDateTimeNoMillis() { [EOL] DateTimeFormatter formatter = Time.ordinalDateTimeNoMillis(); [EOL] assertNotNull(formatter); [EOL] }
public void testWeekDate() { [EOL] DateTimeFormatter formatter = ClassName.weekDate(); [EOL] assertNotNull(formatter); [EOL] assertEquals("Expected formatter pattern", "wwd", formatter.toString()); [EOL] }
public static DateTimeFormatter basicTime() { [EOL] return Constants.bt; [EOL] }
public void testHourMinute() { [EOL] DateTimeFormatter result = Time.hourMinute(); [EOL] assertNotNull(result); [EOL] assertEquals("Value from Constants.hm expected", Constants.hm, result); [EOL] }
public void testHourMinuteSecond() { [EOL] DateTimeFormatter result = ClassName.hourMinuteSecond(); [EOL] assertNotNull(result); [EOL] assertEquals("Expected formatter pattern", Constants.hms.toPattern(), result.toPattern()); [EOL] }
public void testHourMinuteSecondMillis() { [EOL] DateTimeFormatter formatter = Time.hourMinuteSecondMillis(); [EOL] assertNotNull(formatter); [EOL] assertEquals("Hmsl", formatter.toString()); [EOL] }
public void testHourMinuteSecondFraction() { [EOL] DateTimeFormatter formatter = Time.hourMinuteSecondFraction(); [EOL] assertNotNull(formatter); [EOL] assertEquals("Hmsf", formatter.toString()); [EOL] }
public void testDateHourMinute() { [EOL] DateTimeFormatter result = ClassName.dateHourMinute(); [EOL] assertNotNull(result); [EOL] assertEquals(Constants.dhm, result); [EOL] }
public void testDateParserNotNull() { [EOL] DateTimeFormatter result = YourClass.dateParser(); [EOL] assertNotNull(result); [EOL] }
public void testDateParserSingleton() { [EOL] DateTimeFormatter firstCall = YourClass.dateParser(); [EOL] DateTimeFormatter secondCall = YourClass.dateParser(); [EOL] assertSame(firstCall, secondCall); [EOL] }
public void testLocalDateParserWhenLdpIsNull() { [EOL] DateTimeFormatter result = YourClass.localDateParser(); [EOL] assertNotNull(result); [EOL] assertEquals(DateTimeZone.UTC, result.getZone()); [EOL] }
public void testLocalDateParserWhenLdpIsNotNull() { [EOL] YourClass.setLdp(DateTimeFormatter.ofPattern("your pattern here")); [EOL] DateTimeFormatter result = YourClass.localDateParser(); [EOL] assertNotNull(result); [EOL] DateTimeFormatter expected = YourClass.getOriginalLdp(); [EOL] assertEquals(expected, result); [EOL] }
public void testDateElementParserWhenDpeIsNull() { [EOL] ReflectionTestUtils.setField(TheClassWhereMethodIsDefined.class, "dpe", null); [EOL] DateTimeFormatter result = TheClassWhereMethodIsDefined.dateElementParser(); [EOL] assertNotNull(result); [EOL] }
public void testDateElementParserWhenDpeIsNotNull() { [EOL] DateTimeFormatter expected = DateTimeFormat.forPattern("yyyy-MM-dd"); [EOL] ReflectionTestUtils.setField(TheClassWhereMethodIsDefined.class, "dpe", expected); [EOL] DateTimeFormatter result = TheClassWhereMethodIsDefined.dateElementParser(); [EOL] assertSame(expected, result); [EOL] }
private static DateTimeFormatter timeParser() { [EOL] if (tp == null) { [EOL] return new DateTimeFormatterBuilder().appendOptional(literalTElement().getParser()).append(timeElementParser()).appendOptional(offsetElement().getParser()).toFormatter(); [EOL] } [EOL] return tp; [EOL] }
public void testLocalTimeParserWhenLtpIsNull() { [EOL] ReflectionTestUtils.setField(YourClass.class, "ltp", null); [EOL] DateTimeFormatter result = YourClass.localTimeParser(); [EOL] assertNotNull(result); [EOL] assertEquals(DateTimeZone.UTC, result.getZone()); [EOL] }
public void testLocalTimeParserWhenLtpIsNotNull() { [EOL] DateTimeFormatter expected = DateTimeFormat.forPattern("HH:mm:ss"); [EOL] ReflectionTestUtils.setField(YourClass.class, "ltp", expected); [EOL] DateTimeFormatter result = YourClass.localTimeParser(); [EOL] assertSame(expected, result); [EOL] }
private static DateTimeFormatter tpe = null; [EOL] private static DateTimeFormatter timeElementParser() { [EOL] if (tpe == null) { [EOL] DateTimeParser decimalPoint = new DateTimeFormatterBuilder().append(null, new DateTimeParser[] { new DateTimeFormatterBuilder().appendLiteral('.').toParser(), new DateTimeFormatterBuilder().appendLiteral(',').toParser() }).toParser(); [EOL] return new DateTimeFormatterBuilder().append(hourElement()).append(null, new DateTimeParser[] { new DateTimeFormatterBuilder().append(minuteElement()).append(null, new DateTimeParser[] { new DateTimeFormatterBuilder().append(secondElement()).appendOptional(new DateTimeFormatterBuilder().append(decimalPoint).appendFractionOfSecond(1, 9).toParser()).toParser(), new DateTimeFormatterBuilder().append(decimalPoint).appendFractionOfMinute(1, 9).toParser(), null }).toParser(), new DateTimeFormatterBuilder().append(decimalPoint).appendFractionOfHour(1, 9).toParser(), null }).toFormatter(); [EOL] } [EOL] return tpe; [EOL] }
private static DateTimeFormatter dateTimeParser() { [EOL] if (dtp == null) { [EOL] DateTimeParser time = new DateTimeFormatterBuilder().appendLiteral('T').append(timeElementParser()).appendOptional(offsetElement().getParser()).toParser(); [EOL] return new DateTimeFormatterBuilder().append(null, new DateTimeParser[] { time, dateOptionalTimeParser().getParser() }).toFormatter(); [EOL] } [EOL] return dtp; [EOL] }
private static DateTimeFormatter dotp; // Assume this is a static field in the class [EOL] private static DateTimeFormatter dateOptionalTimeParser() { [EOL] if (dotp == null) { [EOL] DateTimeParser timeOrOffset = new DateTimeFormatterBuilder().appendLiteral('T').appendOptional(timeElementParser().getParser()).appendOptional(offsetElement().getParser()).toParser(); [EOL] return new DateTimeFormatterBuilder().append(dateElementParser()).appendOptional(timeOrOffset).toFormatter(); [EOL] } [EOL] return dotp; [EOL] } [EOL] private static DateTimeParser dateElementParser() { [EOL] return null; [EOL] } [EOL] private static DateTimeParser timeElementParser() { [EOL] return null; [EOL] } [EOL] private static DateTimeParser offsetElement() { [EOL] return null; [EOL] }
private static DateTimeFormatter ldotp; // Assume this is a static field in the class [EOL] private static DateTimeFormatter localDateOptionalTimeParser() { [EOL] if (ldotp == null) { [EOL] DateTimeParser time = new DateTimeFormatterBuilder().appendLiteral('T').append(timeElementParser()).toParser(); [EOL] return new DateTimeFormatterBuilder().append(dateElementParser()).appendOptional(time).toFormatter().withZoneUTC(); [EOL] } [EOL] return ldotp; [EOL] } [EOL] private static DateTimeParser timeElementParser() { [EOL] return null; [EOL] } [EOL] private static DateTimeParser dateElementParser() { [EOL] return null; [EOL] }
private static DateTimeFormatter time() { [EOL] if (t == null) { [EOL] return new DateTimeFormatterBuilder().append(hourMinuteSecondFraction()).append(offsetElement()).toFormatter(); [EOL] } [EOL] return t; [EOL] }
public void testTimeNoMillisWithTxNull() { [EOL] tx = null; [EOL] DateTimeFormatter result = timeNoMillis(); [EOL] assertNotNull(result); [EOL] }
public void testTimeNoMillisWithTxNotNull() { [EOL] tx = DateTimeFormatter.ISO_LOCAL_TIME; // Assuming tx is of type DateTimeFormatter [EOL] DateTimeFormatter result = timeNoMillis(); [EOL] assertSame(tx, result); [EOL] }
private static DateTimeFormatter tTime() { [EOL] if (tt == null) { [EOL] return new DateTimeFormatterBuilder().append(literalTElement()).append(time()).toFormatter(); [EOL] } [EOL] return tt; [EOL] }
public void testTTimeNoMillisWhenTtxIsNull() { [EOL] setTtxToNull(); // This method should set the static variable ttx to null [EOL] DateTimeFormatter result = tTimeNoMillis(); [EOL] assertNotNull(result); [EOL] assertEquals("Expected pattern", result.toPattern()); [EOL] }
public void testTTimeNoMillisWhenTtxIsNotNull() { [EOL] DateTimeFormatter expected = DateTimeFormatter.ofPattern("some pattern"); [EOL] setTtx(expected); // This method should set the static variable ttx to the expected value [EOL] DateTimeFormatter result = tTimeNoMillis(); [EOL] assertSame(expected, result); [EOL] }
public void testDateTimeWhenDtIsNull() { [EOL] setDtFieldToNull(); [EOL] DateTimeFormatter result = dateTime(); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof DateTimeFormatter); [EOL] }
public void testDateTimeWhenDtIsNotNull() { [EOL] DateTimeFormatter expected = new DateTimeFormatterBuilder().append(date()).append(tTime()).toFormatter(); [EOL] setDtField(expected); [EOL] DateTimeFormatter result = dateTime(); [EOL] assertSame(expected, result); [EOL] }
public void testDateTimeNoMillis_NotNull() { [EOL] DateTimeFormatter result = YourClass.dateTimeNoMillis(); [EOL] assertNotNull(result); [EOL] }
public void testDateTimeNoMillis_SameInstance() { [EOL] DateTimeFormatter firstCall = YourClass.dateTimeNoMillis(); [EOL] DateTimeFormatter secondCall = YourClass.dateTimeNoMillis(); [EOL] assertSame(firstCall, secondCall); [EOL] }
private static DateTimeFormatter od = null; [EOL] private static DateTimeFormatter ordinalDate() { [EOL] if (od == null) { [EOL] od = new DateTimeFormatterBuilder().append(yearElement()).append(dayOfYearElement()).toFormatter(); [EOL] } [EOL] return od; [EOL] } [EOL] private static DateTimeFormatterBuilder yearElement() { [EOL] return new DateTimeFormatterBuilder(); // Stub for the sake of example [EOL] } [EOL] private static DateTimeFormatterBuilder dayOfYearElement() { [EOL] return new DateTimeFormatterBuilder(); // Stub for the sake of example [EOL] }
private static DateTimeFormatter odt; // Assume this is a static field in the class [EOL] private static DateTimeFormatter ordinalDateTime() { [EOL] if (odt == null) { [EOL] odt = new DateTimeFormatterBuilder().append(ordinalDate()).append(tTime()).toFormatter(); [EOL] } [EOL] return odt; [EOL] } [EOL] private static DateTimeFormatterBuilder ordinalDate() { [EOL] return new DateTimeFormatterBuilder(); // Simplified for the example [EOL] } [EOL] private static DateTimeFormatterBuilder tTime() { [EOL] return new DateTimeFormatterBuilder(); // Simplified for the example [EOL] }
public void testOrdinalDateTimeNoMillis_NotNull() { [EOL] DateTimeFormatter result = YourClass.ordinalDateTimeNoMillis(); [EOL] assertNotNull(result); [EOL] }
public void testOrdinalDateTimeNoMillis_SameInstance() { [EOL] DateTimeFormatter firstCall = YourClass.ordinalDateTimeNoMillis(); [EOL] DateTimeFormatter secondCall = YourClass.ordinalDateTimeNoMillis(); [EOL] assertSame(firstCall, secondCall); [EOL] }
public void testWeekDateTimeWhenWdtIsNull() { [EOL] ReflectionTestUtils.setField(YourClass.class, "wdt", null); [EOL] DateTimeFormatter result = YourClass.weekDateTime(); [EOL] assertNotNull(result); [EOL] assertEquals("Expected formatter pattern", result.toString()); [EOL] }
public void testWeekDateTimeWhenWdtIsNotNull() { [EOL] DateTimeFormatter expected = DateTimeFormatter.ofPattern("yourPatternHere"); [EOL] ReflectionTestUtils.setField(YourClass.class, "wdt", expected); [EOL] DateTimeFormatter result = YourClass.weekDateTime(); [EOL] assertSame(expected, result); [EOL] }
public void testWeekDateTimeNoMillis_NotNull() { [EOL] DateTimeFormatter result = ClassName.weekDateTimeNoMillis(); [EOL] assertNotNull(result); [EOL] }
public void testWeekDateTimeNoMillis_SameInstance() { [EOL] DateTimeFormatter firstCall = ClassName.weekDateTimeNoMillis(); [EOL] DateTimeFormatter secondCall = ClassName.weekDateTimeNoMillis(); [EOL] assertSame(firstCall, secondCall); [EOL] }
public void testBasicDateWhenBdIsNull() { [EOL] DateTimeFormatter result = basicDate(); [EOL] assertNotNull("DateTimeFormatter should not be null when bd is null", result); [EOL] assertEquals("Formatter should have correct pattern", "yyyyMMdd", result.getPattern()); [EOL] }
public void testBasicDateWhenBdIsNotNull() { [EOL] setBd(new DateTimeFormatterBuilder().appendLiteral("Pre-set").toFormatter()); [EOL] DateTimeFormatter result = basicDate(); [EOL] assertNotNull("DateTimeFormatter should not be null when bd is not null", result); [EOL] assertEquals("Formatter should return the pre-set instance", "Pre-set", result.getPattern()); [EOL] resetBd(); [EOL] }
private static DateTimeFormatter bt = null; [EOL] private static DateTimeFormatter basicTime() { [EOL] if (bt == null) { [EOL] return new DateTimeFormatterBuilder().appendFixedDecimal(DateTimeFieldType.hourOfDay(), 2).appendFixedDecimal(DateTimeFieldType.minuteOfHour(), 2).appendFixedDecimal(DateTimeFieldType.secondOfMinute(), 2).appendLiteral('.').appendFractionOfSecond(3, 9).appendTimeZoneOffset("Z", false, 2, 2).toFormatter(); [EOL] } [EOL] return bt; [EOL] }
private static DateTimeFormatter btx; [EOL] private static DateTimeFormatter basicTimeNoMillis() { [EOL] if (btx == null) { [EOL] return new DateTimeFormatterBuilder().appendFixedDecimal(DateTimeFieldType.hourOfDay(), 2).appendFixedDecimal(DateTimeFieldType.minuteOfHour(), 2).appendFixedDecimal(DateTimeFieldType.secondOfMinute(), 2).appendTimeZoneOffset("Z", false, 2, 2).toFormatter(); [EOL] } [EOL] return btx; [EOL] }
public void testBasicTTime_WhenBttIsNull() { [EOL] DateTimeFormatter result = basicTTime(); [EOL] assertNotNull(result); [EOL] }
public void testBasicTTime_WhenBttIsNotNull() { [EOL] btt = DateTimeFormatter.ISO_LOCAL_TIME; [EOL] DateTimeFormatter result = basicTTime(); [EOL] assertSame(btt, result); [EOL] }
private static DateTimeFormatter bttx; [EOL] private static DateTimeFormatter basicTTimeNoMillis() { [EOL] if (bttx == null) { [EOL] return new DateTimeFormatterBuilder().append(literalTElement()).append(basicTimeNoMillis()).toFormatter(); [EOL] } [EOL] return bttx; [EOL] }
public void testBasicDateTimeWhenBdtIsNull() { [EOL] ReflectionTestUtils.setField(Time.class, "bdt", null); [EOL] DateTimeFormatter result = Time.basicDateTime(); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof DateTimeFormatter); [EOL] }
public void testBasicDateTimeWhenBdtIsNotNull() { [EOL] DateTimeFormatter expected = Time.basicDateTime(); [EOL] ReflectionTestUtils.setField(Time.class, "bdt", expected); [EOL] DateTimeFormatter result = Time.basicDateTime(); [EOL] assertSame(expected, result); [EOL] }
private static DateTimeFormatter bdtx; [EOL] private static DateTimeFormatter basicDateTimeNoMillis() { [EOL] if (bdtx == null) { [EOL] bdtx = new DateTimeFormatterBuilder().append(basicDate()).append(basicTTimeNoMillis()).toFormatter(); [EOL] } [EOL] return bdtx; [EOL] } [EOL] private static DateTimeFormatter basicDate() { [EOL] return DateTimeFormatter.ofPattern("yyyyMMdd"); [EOL] } [EOL] private static DateTimeFormatter basicTTimeNoMillis() { [EOL] return DateTimeFormatter.ofPattern("HHmmss"); [EOL] }
private static DateTimeFormatter bod = null; [EOL] public void testBasicOrdinalDate_NotInitialized() { [EOL] DateTimeFormatter result = basicOrdinalDate(); [EOL] assertNotNull(result); [EOL] assertEquals(4, result.getMaximumShortTextLength(null)); [EOL] }
public void testBasicOrdinalDate_AlreadyInitialized() { [EOL] bod = new DateTimeFormatterBuilder().appendYear(4, 4).appendFixedDecimal(DateTimeFieldType.dayOfYear(), 3).toFormatter(); [EOL] DateTimeFormatter result = basicOrdinalDate(); [EOL] assertSame(bod, result); [EOL] }
public void testBasicOrdinalDateTime_NotInitialized() { [EOL] DateTimeFormatter result = ClassName.basicOrdinalDateTime(); [EOL] assertNotNull(result); [EOL] }
public void testBasicOrdinalDateTime_AlreadyInitialized() { [EOL] DateTimeFormatter firstCall = ClassName.basicOrdinalDateTime(); [EOL] DateTimeFormatter secondCall = ClassName.basicOrdinalDateTime(); [EOL] assertSame(firstCall, secondCall); [EOL] }
public void testBasicOrdinalDateTimeNoMillis_NotInitialized() { [EOL] DateTimeFormatter result = ClassName.basicOrdinalDateTimeNoMillis(); [EOL] assertNotNull(result); [EOL] }
public void testBasicOrdinalDateTimeNoMillis_AlreadyInitialized() { [EOL] ClassName.bodtx = DateTimeFormatter.ISO_ORDINAL_DATE; // Replace with actual initialization if necessary [EOL] DateTimeFormatter result = ClassName.basicOrdinalDateTimeNoMillis(); [EOL] assertSame(ClassName.bodtx, result); [EOL] }
private static DateTimeFormatter bwd = null; [EOL] private static DateTimeFormatter basicWeekDate() { [EOL] if (bwd == null) { [EOL] return new DateTimeFormatterBuilder().appendWeekyear(4, 4).appendLiteral('W').appendFixedDecimal(DateTimeFieldType.weekOfWeekyear(), 2).appendFixedDecimal(DateTimeFieldType.dayOfWeek(), 1).toFormatter(); [EOL] } [EOL] return bwd; [EOL] }
public void testBasicWeekDateTime_NotInitialized() { [EOL] DateTimeFormatter result = ClassName.basicWeekDateTime(); [EOL] assertNotNull(result); [EOL] }
public void testBasicWeekDateTime_AlreadyInitialized() { [EOL] DateTimeFormatter expected = ClassName.basicWeekDateTime(); [EOL] DateTimeFormatter result = ClassName.basicWeekDateTime(); [EOL] assertSame(expected, result); [EOL] }
public void testBasicWeekDateTimeNoMillis_NotInitialized() { [EOL] DateTimeFormatter result = ClassName.basicWeekDateTimeNoMillis(); [EOL] assertNotNull(result); [EOL] assertEquals("Expected formatter pattern", result.getPattern(), "Expected pattern here"); [EOL] }
public void testBasicWeekDateTimeNoMillis_AlreadyInitialized() { [EOL] ClassName.bwdtx = new DateTimeFormatterBuilder().append(basicWeekDate()).append(basicTTimeNoMillis()).toFormatter(); [EOL] DateTimeFormatter result = ClassName.basicWeekDateTimeNoMillis(); [EOL] assertNotNull(result); [EOL] assertSame("Expected same instance of DateTimeFormatter", ClassName.bwdtx, result); [EOL] }
private static DateTimeFormatter ym = null; [EOL] private static DateTimeFormatter yearMonth() { [EOL] if (ym == null) { [EOL] ym = new DateTimeFormatterBuilder().append(yearElement()).append(monthElement()).toFormatter(); [EOL] } [EOL] return ym; [EOL] } [EOL] private static DateTimeFormatterBuilder yearElement() { [EOL] return new DateTimeFormatterBuilder().appendValue(ChronoField.YEAR, 4); [EOL] } [EOL] private static DateTimeFormatterBuilder monthElement() { [EOL] return new DateTimeFormatterBuilder().appendValue(ChronoField.MONTH_OF_YEAR, 2); [EOL] }
public void testYearMonthDay_NotInitialized() { [EOL] DateTimeFormatter result = yearMonthDay(); [EOL] assertNotNull(result); [EOL] }
public void testYearMonthDay_AlreadyInitialized() { [EOL] DateTimeFormatter firstCall = yearMonthDay(); [EOL] DateTimeFormatter secondCall = yearMonthDay(); [EOL] assertSame(firstCall, secondCall); [EOL] }
private static DateTimeFormatter ww = null; [EOL] private static DateTimeFormatter weekyearWeek() { [EOL] if (ww == null) { [EOL] ww = new DateTimeFormatterBuilder().append(weekyearElement()).append(weekElement()).toFormatter(); [EOL] } [EOL] return ww; [EOL] } [EOL] private static DateTimeFormatterBuilder weekyearElement() { [EOL] return new DateTimeFormatterBuilder(); // Stub implementation [EOL] } [EOL] private static DateTimeFormatterBuilder weekElement() { [EOL] return new DateTimeFormatterBuilder(); // Stub implementation [EOL] }
public void testWeekyearWeekDay_NotNull() { [EOL] DateTimeFormatter result = ClassName.weekyearWeekDay(); [EOL] assertNotNull(result); [EOL] }
public void testWeekyearWeekDay_SameInstance() { [EOL] DateTimeFormatter firstCall = ClassName.weekyearWeekDay(); [EOL] DateTimeFormatter secondCall = ClassName.weekyearWeekDay(); [EOL] assertSame(firstCall, secondCall); [EOL] }
private static DateTimeFormatter hourMinute() { [EOL] if (hm == null) { [EOL] hm = new DateTimeFormatterBuilder().append(hourElement()).append(minuteElement()).toFormatter(); [EOL] } [EOL] return hm; [EOL] }
private static DateTimeFormatter hms; // This is a static variable [EOL] private static DateTimeFormatter hourMinuteSecond() { [EOL] if (hms == null) { [EOL] hms = new DateTimeFormatterBuilder().append(hourElement()).append(minuteElement()).append(secondElement()).toFormatter(); [EOL] } [EOL] return hms; [EOL] } [EOL] private static DateTimeFormatterBuilder hourElement() { [EOL] return new DateTimeFormatterBuilder().appendLiteral("H"); [EOL] } [EOL] private static DateTimeFormatterBuilder minuteElement() { [EOL] return new DateTimeFormatterBuilder().appendLiteral("M"); [EOL] } [EOL] private static DateTimeFormatterBuilder secondElement() { [EOL] return new DateTimeFormatterBuilder().appendLiteral("S"); [EOL] }
private static DateTimeFormatter hmsl = null; [EOL] private static DateTimeFormatter hourElement() { [EOL] } [EOL] private static DateTimeFormatter minuteElement() { [EOL] } [EOL] private static DateTimeFormatter secondElement() { [EOL] } [EOL] private static DateTimeFormatter hourMinuteSecondMillis() { [EOL] if (hmsl == null) { [EOL] return new DateTimeFormatterBuilder().append(hourElement()).append(minuteElement()).append(secondElement()).appendLiteral('.').appendFractionOfSecond(3, 3).toFormatter(); [EOL] } [EOL] return hmsl; [EOL] }
private static DateTimeFormatter hmsf; // Assume this is a static field in the class [EOL] private static DateTimeFormatter hourMinuteSecondFraction() { [EOL] if (hmsf == null) { [EOL] hmsf = new DateTimeFormatterBuilder().append(hourElement()).append(minuteElement()).append(secondElement()).append(fractionElement()).toFormatter(); [EOL] } [EOL] return hmsf; [EOL] }
public void testDateHour_NotInitialized() { [EOL] DateTimeFormatter result = ClassName.dateHour(); [EOL] assertNotNull(result); [EOL] }
public void testDateHour_AlreadyInitialized() { [EOL] DateTimeFormatter expected = ClassName.dateHour(); [EOL] DateTimeFormatter result = ClassName.dateHour(); [EOL] assertSame(expected, result); [EOL] }
private static DateTimeFormatter dhm; // assuming this is a static field [EOL] private static DateTimeFormatter dateHourMinute() { [EOL] if (dhm == null) { [EOL] dhm = new DateTimeFormatterBuilder().append(date()).append(literalTElement()).append(hourMinute()).toFormatter(); [EOL] } [EOL] return dhm; [EOL] }
public void testDateHourMinuteSecond_NotInitialized() { [EOL] DateTimeFormatter result = YourClass.dateHourMinuteSecond(); [EOL] assertNotNull(result); [EOL] assertEquals("Expected formatter pattern", result.toString(), "Expected pattern here"); [EOL] }
public void testDateHourMinuteSecond_AlreadyInitialized() { [EOL] YourClass.dhms = DateTimeFormatter.ofPattern("Your pattern here"); [EOL] DateTimeFormatter result = YourClass.dateHourMinuteSecond(); [EOL] assertNotNull(result); [EOL] assertSame("Expected same instance of DateTimeFormatter", YourClass.dhms, result); [EOL] }
public void testDateHourMinuteSecondMillis_NotInitialized() { [EOL] DateTimeFormatter result = YourClass.dateHourMinuteSecondMillis(); [EOL] assertNotNull(result); [EOL] } [EOL] public void testDateHourMinuteSecondMillis_AlreadyInitialized() { [EOL] YourClass.setDhmsl(somePreInitializedFormatter); // This line is pseudo-code [EOL] DateTimeFormatter result = YourClass.dateHourMinuteSecondMillis(); [EOL] assertSame(somePreInitializedFormatter, result); [EOL] }
private static DateTimeFormatter dhmsf; // assume this is a static field [EOL] private static DateTimeFormatter dateHourMinuteSecondFraction() { [EOL] if (dhmsf == null) { [EOL] dhmsf = new DateTimeFormatterBuilder().append(date()).append(literalTElement()).append(hourMinuteSecondFraction()).toFormatter(); [EOL] } [EOL] return dhmsf; [EOL] }
public void testYearElementWhenYeIsNull() { [EOL] DateTimeFormatter result = Time.yearElement(); [EOL] assertNotNull(result); [EOL] assertEquals(4, result.getMinimumValue()); [EOL] assertEquals(9, result.getMaximumValue()); [EOL] } [EOL] public void testYearElementWhenYeIsNotNull() { [EOL] DateTimeFormatter expected = DateTimeFormatter.ofPattern("yyyy"); [EOL] Time.setYearElement(expected); // Assuming there is a method to set the static variable 'ye' [EOL] DateTimeFormatter result = Time.yearElement(); [EOL] assertSame(expected, result); [EOL] }
private static DateTimeFormatter mye = null; [EOL] public void testMonthElementWhenMyeIsNull() { [EOL] mye = null; [EOL] DateTimeFormatter result = monthElement(); [EOL] assertNotNull(result); [EOL] assertEquals("-MM", result.print(0)); [EOL] } [EOL] public void testMonthElementWhenMyeIsNotNull() { [EOL] mye = new DateTimeFormatterBuilder().appendLiteral("existing").toFormatter(); [EOL] DateTimeFormatter result = monthElement(); [EOL] assertNotNull(result); [EOL] assertEquals("existing", result.print(0)); [EOL] }
private static DateTimeFormatter dme = null; [EOL] private static DateTimeFormatter dayOfMonthElement() { [EOL] if (dme == null) { [EOL] dme = new DateTimeFormatterBuilder().appendLiteral('-').appendDayOfMonth(2).toFormatter(); [EOL] } [EOL] return dme; [EOL] }
public void testWeekyearElement_NotNull() { [EOL] DateTimeFormatter result = ClassName.weekyearElement(); [EOL] assertNotNull(result); [EOL] }
public void testWeekyearElement_SameInstance() { [EOL] DateTimeFormatter firstCall = ClassName.weekyearElement(); [EOL] DateTimeFormatter secondCall = ClassName.weekyearElement(); [EOL] assertSame(firstCall, secondCall); [EOL] }
public void testWeekElement_NotInitialized() { [EOL] DateTimeFormatter result = ClassName.weekElement(); [EOL] assertNotNull(result); [EOL] assertEquals("-W", result.getPrinter().print(0, Locale.getDefault(), "", 0, DateTimeFormat.forPattern("ww"), 0)); [EOL] } [EOL] public void testWeekElement_AlreadyInitialized() { [EOL] ClassName.wwe = DateTimeFormat.forPattern("-W"); [EOL] DateTimeFormatter result = ClassName.weekElement(); [EOL] assertNotNull(result); [EOL] assertEquals("-W", result.getPrinter().print(0, Locale.getDefault(), "", 0, DateTimeFormat.forPattern("ww"), 0)); [EOL] }
public void testDayOfWeekElement_NotNull() { [EOL] DateTimeFormatter result = ClassName.dayOfWeekElement(); [EOL] assertNotNull(result); [EOL] }
public void testDayOfWeekElement_SameInstance() { [EOL] DateTimeFormatter firstCall = ClassName.dayOfWeekElement(); [EOL] DateTimeFormatter secondCall = ClassName.dayOfWeekElement(); [EOL] assertSame(firstCall, secondCall); [EOL] }
private static DateTimeFormatter dye; [EOL] private static DateTimeFormatter dayOfYearElement() { [EOL] if (dye == null) { [EOL] dye = new DateTimeFormatterBuilder().appendLiteral('-').appendDayOfYear(3).toFormatter(); [EOL] } [EOL] return dye; [EOL] }
private static DateTimeFormatter lte; [EOL] public void testLiteralTElement_NotInitialized() { [EOL] DateTimeFormatter result = literalTElement(); [EOL] assertNotNull(result); [EOL] assertEquals("T", result.toString()); [EOL] }
public void testLiteralTElement_AlreadyInitialized() { [EOL] lte = new DateTimeFormatterBuilder().appendLiteral('X').toFormatter(); [EOL] DateTimeFormatter result = literalTElement(); [EOL] assertNotNull(result); [EOL] assertEquals("X", result.toString()); [EOL] }
public void testHourElementWhenHdeIsNull() { [EOL] setTimeHdeNull(); [EOL] DateTimeFormatter result = hourElement(); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof DateTimeFormatter); [EOL] assertEquals("HH", result.getPattern()); [EOL] }
public void testHourElementWhenHdeIsNotNull() { [EOL] DateTimeFormatter expected = new DateTimeFormatterBuilder().appendHourOfDay(2).toFormatter(); [EOL] setTimeHde(expected); [EOL] DateTimeFormatter result = hourElement(); [EOL] assertSame(expected, result); [EOL] }
public void testMinuteElementWhenMheIsNull() { [EOL] setMheToNull(); // This method needs to be defined to set the private static field mhe to null [EOL] DateTimeFormatter result = minuteElement(); [EOL] assertNotNull(result); [EOL] assertEquals("Expected formatter to use ':' as separator", ":", result.getDelimiter()); [EOL] assertEquals("Expected formatter to have minute of hour element", 2, result.getMinuteOfHourElementLength()); [EOL] }
public void testMinuteElementWhenMheIsNotNull() { [EOL] DateTimeFormatter expectedFormatter = new DateTimeFormatterBuilder().appendLiteral(':').appendMinuteOfHour(2).toFormatter(); [EOL] setMhe(expectedFormatter); // This method needs to be defined to set the private static field mhe [EOL] DateTimeFormatter result = minuteElement(); [EOL] assertSame("Expected to receive the same DateTimeFormatter instance as mhe", expectedFormatter, result); [EOL] }
private static DateTimeFormatter sme = null; [EOL] public void testSecondElementWhenSmeIsNull() { [EOL] DateTimeFormatter result = secondElement(); [EOL] assertNotNull(result); [EOL] assertEquals(":", result.print(0)); [EOL] }
public void testSecondElementWhenSmeIsNotNull() { [EOL] sme = new DateTimeFormatterBuilder().appendLiteral('.').appendSecondOfMinute(2).toFormatter(); [EOL] DateTimeFormatter result = secondElement(); [EOL] assertNotNull(result); [EOL] assertEquals(".", result.print(0)); [EOL] }
private static DateTimeFormatter fse = null; [EOL] public void testFractionElementWhenFseIsNull() { [EOL] fse = null; [EOL] DateTimeFormatter result = fractionElement(); [EOL] assertNotNull(result); [EOL] assertEquals(".", result.getDecimalStyle().getDecimalSeparator()); [EOL] }
public void testFractionElementWhenFseIsNotNull() { [EOL] fse = new DateTimeFormatterBuilder().appendLiteral("x").toFormatter(); [EOL] DateTimeFormatter result = fractionElement(); [EOL] assertNotNull(result); [EOL] assertEquals("x", result.getDecimalStyle().getDecimalSeparator()); [EOL] }
private static DateTimeFormatter offsetElement() { [EOL] if (ze == null) { [EOL] return new DateTimeFormatterBuilder().appendTimeZoneOffset("Z", true, 2, 4).toFormatter(); [EOL] } [EOL] return ze; [EOL] }
public void testMinutesInWithNullInterval() { [EOL] Minutes result = Time.minutesIn(null); [EOL] assertEquals(Minutes.ZERO, result); [EOL] }
public void testMinutesInWithValidInterval() { [EOL] ReadableInterval interval = new Interval(0, 60000); // 1 minute interval [EOL] Minutes result = Time.minutesIn(interval); [EOL] assertEquals(Minutes.minutes(1), result); [EOL] }
public void testGetPeriodType_ReturnsMinutes() { [EOL] TimePeriod period = new TimePeriod(); [EOL] PeriodType result = period.getPeriodType(); [EOL] assertEquals(PeriodType.minutes(), result); [EOL] }
public void testToStandardDuration_PositiveMinutes() { [EOL] Period period = new Period().withMinutes(30); [EOL] Duration duration = period.toStandardDuration(); [EOL] assertEquals(30 * 60000L, duration.getMillis()); [EOL] }
public void testToStandardDuration_ZeroMinutes() { [EOL] Period period = new Period().withMinutes(0); [EOL] Duration duration = period.toStandardDuration(); [EOL] assertEquals(0L, duration.getMillis()); [EOL] }
public void testToStandardDuration_NegativeMinutes() { [EOL] Period period = new Period().withMinutes(-30); [EOL] Duration duration = period.toStandardDuration(); [EOL] assertEquals(-30 * 60000L, duration.getMillis()); [EOL] }
public void testDividedBy_DivisorIsOne() { [EOL] Minutes minutes = Minutes.minutes(5); [EOL] Minutes result = minutes.dividedBy(1); [EOL] assertEquals(minutes, result); [EOL] }
public void testDividedBy_DivisorIsNotOne() { [EOL] Minutes minutes = Minutes.minutes(10); [EOL] Minutes result = minutes.dividedBy(2); [EOL] assertEquals(Minutes.minutes(5), result); [EOL] }
public void testNegated_Zero() { [EOL] Minutes zeroMinutes = Minutes.minutes(0); [EOL] Minutes result = zeroMinutes.negated(); [EOL] assertEquals("Negating zero should give zero", 0, result.getMinutes()); [EOL] }
public void testNegated_Positive() { [EOL] Minutes positiveMinutes = Minutes.minutes(5); [EOL] Minutes result = positiveMinutes.negated(); [EOL] assertEquals("Negating a positive value should give negative", -5, result.getMinutes()); [EOL] }
public void testNegated_Negative() { [EOL] Minutes negativeMinutes = Minutes.minutes(-3); [EOL] Minutes result = negativeMinutes.negated(); [EOL] assertEquals("Negating a negative value should give positive", 3, result.getMinutes()); [EOL] }
public void testGetInstance() { [EOL] GregorianChronology instance = GregorianChronology.getInstance(); [EOL] assertNotNull(instance); [EOL] assertEquals(4, instance.getMinimumDaysInFirstWeek()); [EOL] assertEquals(DateTimeZone.getDefault(), instance.getZone()); [EOL] }
public void testGetInstance_NullZone() { [EOL] DateTimeZone zone = null; [EOL] int minDaysInFirstWeek = 4; [EOL] GregorianChronology chrono = GregorianChronology.getInstance(zone, minDaysInFirstWeek); [EOL] assertNotNull(chrono); [EOL] assertEquals(DateTimeZone.getDefault(), chrono.getZone()); [EOL] }
public void testGetInstance_ValidZone() { [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/Paris"); [EOL] int minDaysInFirstWeek = 4; [EOL] GregorianChronology chrono = GregorianChronology.getInstance(zone, minDaysInFirstWeek); [EOL] assertNotNull(chrono); [EOL] assertEquals(zone, chrono.getZone()); [EOL] }
public void testGetInstance_MinDaysInFirstWeekTooLow() { [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/Paris"); [EOL] int minDaysInFirstWeek = 0; [EOL] try { [EOL] GregorianChronology.getInstance(zone, minDaysInFirstWeek); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testGetInstance_MinDaysInFirstWeekTooHigh() { [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/Paris"); [EOL] int minDaysInFirstWeek = 8; [EOL] try { [EOL] GregorianChronology.getInstance(zone, minDaysInFirstWeek); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testGetInstance_CachedChronology() { [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/Paris"); [EOL] int minDaysInFirstWeek = 4; [EOL] GregorianChronology firstChrono = GregorianChronology.getInstance(zone, minDaysInFirstWeek); [EOL] GregorianChronology secondChrono = GregorianChronology.getInstance(zone, minDaysInFirstWeek); [EOL] assertSame(firstChrono, secondChrono); [EOL] }
public void testGetInstance_DifferentMinDaysInFirstWeek() { [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/Paris"); [EOL] int minDaysInFirstWeek1 = 4; [EOL] int minDaysInFirstWeek2 = 2; [EOL] GregorianChronology chrono1 = GregorianChronology.getInstance(zone, minDaysInFirstWeek1); [EOL] GregorianChronology chrono2 = GregorianChronology.getInstance(zone, minDaysInFirstWeek2); [EOL] assertNotSame(chrono1, chrono2); [EOL] }
public void testIsLeapYear_LeapYearDivisibleByFour_NotDivisibleByHundred() { [EOL] assertTrue(isLeapYear(2024)); [EOL] }
public void testIsLeapYear_LeapYearDivisibleByFourHundred() { [EOL] assertTrue(isLeapYear(2000)); [EOL] }
public void testIsLeapYear_NotLeapYearDivisibleByHundred_NotDivisibleByFourHundred() { [EOL] assertFalse(isLeapYear(1900)); [EOL] }
public void testIsLeapYear_NotLeapYearNotDivisibleByFour() { [EOL] assertFalse(isLeapYear(2019)); [EOL] }
public void testCalculateFirstDayOfYearMillisForNegativeNonLeapYear() { [EOL] int year = -1; // Example of a negative non-leap year [EOL] long expectedMillis = /* calculated expected millis for the year -1 */; [EOL] long actualMillis = calculateFirstDayOfYearMillis(year); [EOL] assertEquals(expectedMillis, actualMillis); [EOL] }
public void testCalculateFirstDayOfYearMillisForNegativeLeapYear() { [EOL] int year = -4; // Example of a negative leap year [EOL] long expectedMillis = /* calculated expected millis for the year -4 */; [EOL] long actualMillis = calculateFirstDayOfYearMillis(year); [EOL] assertEquals(expectedMillis, actualMillis); [EOL] }
public void testCalculateFirstDayOfYearMillisForPositiveNonLeapYear() { [EOL] int year = 1; // Example of a positive non-leap year [EOL] long expectedMillis = /* calculated expected millis for the year 1 */; [EOL] long actualMillis = calculateFirstDayOfYearMillis(year); [EOL] assertEquals(expectedMillis, actualMillis); [EOL] }
public void testCalculateFirstDayOfYearMillisForPositiveLeapYear() { [EOL] int year = 4; // Example of a positive leap year [EOL] long expectedMillis = /* calculated expected millis for the year 4 */; [EOL] long actualMillis = calculateFirstDayOfYearMillis(year); [EOL] assertEquals(expectedMillis, actualMillis); [EOL] }
public void testCalculateFirstDayOfYearMillisForYearZero() { [EOL] int year = 0; // Year zero is a special case [EOL] long expectedMillis = /* calculated expected millis for the year 0 */; [EOL] long actualMillis = calculateFirstDayOfYearMillis(year); [EOL] assertEquals(expectedMillis, actualMillis); [EOL] }
public void testCalculateFirstDayOfYearMillisForYear1970() { [EOL] int year = 1970; // The Unix epoch year [EOL] long expectedMillis = /* calculated expected millis for the year 1970 */; [EOL] long actualMillis = calculateFirstDayOfYearMillis(year); [EOL] assertEquals(expectedMillis, actualMillis); [EOL] }
public void testGetMinYear() { [EOL] Time time = new Time(); [EOL] int expected = Time.MIN_YEAR; [EOL] int actual = time.getMinYear(); [EOL] assertEquals(expected, actual); [EOL] }
public void testGetMaxYear() { [EOL] Time time = new Time(); [EOL] int expected = Time.MAX_YEAR; [EOL] int actual = time.getMaxYear(); [EOL] assertEquals(expected, actual); [EOL] }
public void testGetAverageMillisPerYearDividedByTwo() { [EOL] long expected = TimeConstants.MILLIS_PER_YEAR / 2; [EOL] long actual = time.getAverageMillisPerYearDividedByTwo(); [EOL] assertEquals(expected, actual); [EOL] }
public void testGetApproxMillisAtEpochDividedByTwo() { [EOL] Time time = new Time(); [EOL] long expected = (1970L * Time.MILLIS_PER_YEAR) / 2; [EOL] long actual = time.getApproxMillisAtEpochDividedByTwo(); [EOL] assertEquals(expected, actual); [EOL] }
public void testBaseDateTimeWithNullInstantAndZone() { [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/London"); [EOL] BaseDateTime baseDateTime = new BaseDateTime((Object) null, zone); [EOL] assertNotNull(baseDateTime); [EOL] assertEquals(zone, baseDateTime.getZone()); [EOL] assertEquals(Chronology.getISO(zone), baseDateTime.getChronology()); [EOL] }
public void testBaseDateTimeWithInstantAndNullZone() { [EOL] long instantMillis = System.currentTimeMillis(); [EOL] BaseDateTime baseDateTime = new BaseDateTime(instantMillis, (DateTimeZone) null); [EOL] assertNotNull(baseDateTime); [EOL] assertEquals(DateTimeZone.getDefault(), baseDateTime.getZone()); [EOL] assertEquals(instantMillis, baseDateTime.getMillis()); [EOL] }
public void testBaseDateTimeWithInstantAndZone() { [EOL] long instantMillis = System.currentTimeMillis(); [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/London"); [EOL] BaseDateTime baseDateTime = new BaseDateTime(instantMillis, zone); [EOL] assertNotNull(baseDateTime); [EOL] assertEquals(zone, baseDateTime.getZone()); [EOL] assertEquals(instantMillis, baseDateTime.getMillis()); [EOL] assertEquals(Chronology.getISO(zone), baseDateTime.getChronology()); [EOL] }
public void testBaseDateTimeWithCalendarAndZone() { [EOL] Calendar calendar = Calendar.getInstance(); [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/London"); [EOL] BaseDateTime baseDateTime = new BaseDateTime(calendar, zone); [EOL] assertNotNull(baseDateTime); [EOL] assertEquals(zone, baseDateTime.getZone()); [EOL] assertEquals(calendar.getTimeInMillis(), baseDateTime.getMillis()); [EOL] assertEquals(Chronology.getISO(zone), baseDateTime.getChronology()); [EOL] }
public void testBaseDateTimeWithDateAndZone() { [EOL] Date date = new Date(); [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/London"); [EOL] BaseDateTime baseDateTime = new BaseDateTime(date, zone); [EOL] assertNotNull(baseDateTime); [EOL] assertEquals(zone, baseDateTime.getZone()); [EOL] assertEquals(date.getTime(), baseDateTime.getMillis()); [EOL] assertEquals(Chronology.getISO(zone), baseDateTime.getChronology()); [EOL] }
protected void setChronology(Chronology chronology) { [EOL] iChronology = checkChronology(chronology); [EOL] }
public void testEquals_Reflexive() { [EOL] FixedDateTimeZone zone = new FixedDateTimeZone("UTC", 0, 0); [EOL] assertTrue(zone.equals(zone)); [EOL] }
public void testEquals_SameIDAndOffsets() { [EOL] FixedDateTimeZone zone1 = new FixedDateTimeZone("UTC", 0, 0); [EOL] FixedDateTimeZone zone2 = new FixedDateTimeZone("UTC", 0, 0); [EOL] assertTrue(zone1.equals(zone2)); [EOL] }
public void testEquals_DifferentID() { [EOL] FixedDateTimeZone zone1 = new FixedDateTimeZone("UTC", 0, 0); [EOL] FixedDateTimeZone zone2 = new FixedDateTimeZone("GMT", 0, 0); [EOL] assertFalse(zone1.equals(zone2)); [EOL] }
public void testEquals_DifferentStandardOffset() { [EOL] FixedDateTimeZone zone1 = new FixedDateTimeZone("UTC", 0, 0); [EOL] FixedDateTimeZone zone2 = new FixedDateTimeZone("UTC", 1, 0); [EOL] assertFalse(zone1.equals(zone2)); [EOL] }
public void testEquals_DifferentWallOffset() { [EOL] FixedDateTimeZone zone1 = new FixedDateTimeZone("UTC", 0, 0); [EOL] FixedDateTimeZone zone2 = new FixedDateTimeZone("UTC", 0, 1); [EOL] assertFalse(zone1.equals(zone2)); [EOL] }
public void testEquals_Null() { [EOL] FixedDateTimeZone zone = new FixedDateTimeZone("UTC", 0, 0); [EOL] assertFalse(zone.equals(null)); [EOL] }
public void testEquals_DifferentClass() { [EOL] FixedDateTimeZone zone = new FixedDateTimeZone("UTC", 0, 0); [EOL] Object other = new Object(); [EOL] assertFalse(zone.equals(other)); [EOL] }
public void testGetDifferenceWithNullInstant() { [EOL] ReadableInstant nullInstant = null; [EOL] MyTimeClass instance = new MyTimeClass(); // Assuming MyTimeClass is the class that contains getDifference [EOL] int result = instance.getDifference(nullInstant); [EOL] long expectedMillis = DateTimeUtils.currentTimeMillis(); [EOL] int expectedDifference = instance.getField().getDifference(instance.getMillis(), expectedMillis); [EOL] assertEquals(expectedDifference, result); [EOL] }
public void testGetDifferenceWithNonNullInstant() { [EOL] ReadableInstant mockInstant = mock(ReadableInstant.class); [EOL] when(mockInstant.getMillis()).thenReturn(1234567890L); [EOL] MyTimeClass instance = new MyTimeClass(); // Assuming MyTimeClass is the class that contains getDifference [EOL] int result = instance.getDifference(mockInstant); [EOL] int expectedDifference = instance.getField().getDifference(instance.getMillis(), mockInstant.getMillis()); [EOL] assertEquals(expectedDifference, result); [EOL] }
public void testGetDifferenceAsLongWithNullInstant() { [EOL] TimeClass instance = new TimeClass(); [EOL] FieldClass field = Mockito.mock(FieldClass.class); [EOL] Mockito.when(instance.getField()).thenReturn(field); [EOL] long expectedDifference = 12345L; [EOL] Mockito.when(field.getDifferenceAsLong(Mockito.anyLong(), Mockito.anyLong())).thenReturn(expectedDifference); [EOL] long actualDifference = instance.getDifferenceAsLong(null); [EOL] assertEquals(expectedDifference, actualDifference); [EOL] }
public void testGetDifferenceAsLongWithNonNullInstant() { [EOL] TimeClass instance = new TimeClass(); [EOL] FieldClass field = Mockito.mock(FieldClass.class); [EOL] ReadableInstant instant = Mockito.mock(ReadableInstant.class); [EOL] Mockito.when(instance.getField()).thenReturn(field); [EOL] long instanceMillis = System.currentTimeMillis(); [EOL] long instantMillis = instanceMillis - 10000; // Assume the instant is 10 seconds earlier [EOL] Mockito.when(instance.getMillis()).thenReturn(instanceMillis); [EOL] Mockito.when(instant.getMillis()).thenReturn(instantMillis); [EOL] long expectedDifference = 10L; [EOL] Mockito.when(field.getDifferenceAsLong(instanceMillis, instantMillis)).thenReturn(expectedDifference); [EOL] long actualDifference = instance.getDifferenceAsLong(instant); [EOL] assertEquals(expectedDifference, actualDifference); [EOL] }
public void testUnsupportedDateTimeFieldWithValidArguments() { [EOL] DateTimeFieldType type = DateTimeFieldType.dayOfMonth(); [EOL] DurationField durationField = DurationFieldType.days().getField(null); [EOL] UnsupportedDateTimeField field = new UnsupportedDateTimeField(type, durationField); [EOL] assertNotNull(field); [EOL] }
public void testUnsupportedDateTimeFieldWithNullType() { [EOL] try { [EOL] new UnsupportedDateTimeField(null, DurationFieldType.days().getField(null)); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testUnsupportedDateTimeFieldWithNullDurationField() { [EOL] try { [EOL] new UnsupportedDateTimeField(DateTimeFieldType.dayOfMonth(), null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testEquals_SameObject() { [EOL] ZonedChronology chrono1 = ZonedChronology.getInstance(); [EOL] assertTrue(chrono1.equals(chrono1)); [EOL] }
public void testEquals_DifferentType() { [EOL] ZonedChronology chrono1 = ZonedChronology.getInstance(); [EOL] Object obj = new Object(); [EOL] assertFalse(chrono1.equals(obj)); [EOL] }
public void testEquals_EqualObjects() { [EOL] ZonedChronology chrono1 = ZonedChronology.getInstance(); [EOL] ZonedChronology chrono2 = ZonedChronology.getInstance(); [EOL] assertTrue(chrono1.equals(chrono2)); [EOL] }
public void testEquals_NotEqualObjects_BaseDifferent() { [EOL] ZonedChronology chrono1 = ZonedChronology.getInstance(); [EOL] ZonedChronology chrono2 = ZonedChronology.getInstanceDifferentBase(); [EOL] assertFalse(chrono1.equals(chrono2)); [EOL] }
public void testEquals_NotEqualObjects_ZoneDifferent() { [EOL] ZonedChronology chrono1 = ZonedChronology.getInstance(); [EOL] ZonedChronology chrono2 = ZonedChronology.getInstanceDifferentZone(); [EOL] assertFalse(chrono1.equals(chrono2)); [EOL] }
public void testHashCode() { [EOL] ZoneId zone = ZoneId.of("America/New_York"); [EOL] LocalDateTime base = LocalDateTime.of(2021, Month.JANUARY, 1, 0, 0); [EOL] Time time = new Time(zone, base); [EOL] int expectedHashCode = 326565 + zone.hashCode() * 11 + base.hashCode() * 7; [EOL] assertEquals(expectedHashCode, time.hashCode()); [EOL] }

public void testAddWrapField_WithTimeField() { [EOL] long instant = 1234567890L; [EOL] int value = 5; [EOL] int offset = 10; // Example offset value [EOL] long expected = 1234567895L; // Expected value after adding wrap field [EOL] when(iField.addWrapField(instant + offset, value)).thenReturn(expected + offset); [EOL] long result = addWrapField(instant, value); [EOL] assertEquals(expected, result); [EOL] }
public void testAddWrapField_WithoutTimeField() { [EOL] long instant = 1234567890L; [EOL] int value = 5; [EOL] long localInstant = 1234567895L; // Example local instant value [EOL] long expected = 1234567890L; // Expected value after adding wrap field and converting back to UTC [EOL] when(iZone.convertUTCToLocal(instant)).thenReturn(localInstant); [EOL] when(iField.addWrapField(localInstant, value)).thenReturn(localInstant); [EOL] when(iZone.convertLocalToUTC(localInstant, false, instant)).thenReturn(expected); [EOL] long result = addWrapField(instant, value); [EOL] assertEquals(expected, result); [EOL] }
public void testGetDifference_WithPositiveOffset() { [EOL] long minuendInstant = 1000; // Some arbitrary timestamp [EOL] long subtrahendInstant = 500; // Some arbitrary timestamp before minuendInstant [EOL] int expectedDifference = 1; // Expected difference based on the implementation details of iField.getDifference and getOffsetToAdd [EOL] int actualDifference = getDifference(minuendInstant, subtrahendInstant); [EOL] assertEquals(expectedDifference, actualDifference); [EOL] }
public void testGetDifference_WithNegativeOffset() { [EOL] long minuendInstant = 500; // Some arbitrary timestamp [EOL] long subtrahendInstant = 1000; // Some arbitrary timestamp after minuendInstant [EOL] int expectedDifference = -1; // Expected difference based on the implementation details of iField.getDifference and getOffsetToAdd [EOL] int actualDifference = getDifference(minuendInstant, subtrahendInstant); [EOL] assertEquals(expectedDifference, actualDifference); [EOL] }
public void testGetDifference_WithEqualInstants() { [EOL] long minuendInstant = 1000; // Some arbitrary timestamp [EOL] long subtrahendInstant = 1000; // Same as minuendInstant [EOL] int expectedDifference = 0; // Expected difference should be zero when instants are equal [EOL] int actualDifference = getDifference(minuendInstant, subtrahendInstant); [EOL] assertEquals(expectedDifference, actualDifference); [EOL] }
public void testGetDifferenceAsLong_WithPositiveOffset() { [EOL] long minuendInstant = 1000L; [EOL] long subtrahendInstant = 500L; [EOL] long expectedDifference = 1L; // Assuming the difference calculation and offsets result in 1 [EOL] long actualDifference = getDifferenceAsLong(minuendInstant, subtrahendInstant); [EOL] assertEquals(expectedDifference, actualDifference); [EOL] }
public void testGetDifferenceAsLong_WithNegativeOffset() { [EOL] long minuendInstant = 1000L; [EOL] long subtrahendInstant = 1500L; [EOL] long expectedDifference = -1L; // Assuming the difference calculation and offsets result in -1 [EOL] long actualDifference = getDifferenceAsLong(minuendInstant, subtrahendInstant); [EOL] assertEquals(expectedDifference, actualDifference); [EOL] }
public void testGetDifferenceAsLong_WithZeroOffset() { [EOL] long minuendInstant = 1000L; [EOL] long subtrahendInstant = 1000L; [EOL] long expectedDifference = 0L; // Assuming the difference calculation and offsets result in 0 [EOL] long actualDifference = getDifferenceAsLong(minuendInstant, subtrahendInstant); [EOL] assertEquals(expectedDifference, actualDifference); [EOL] }
public void testRoundCeiling_WithTimeField() { [EOL] long instant = 1000L; // Example input [EOL] long expected = 2000L; // Expected output after rounding and adjusting for offset [EOL] long actual = roundCeiling(instant); [EOL] assertEquals(expected, actual); [EOL] }
public void testRoundCeiling_WithoutTimeField() { [EOL] long instant = 1000L; // Example input [EOL] long expected = 3000L; // Expected output after rounding and timezone conversion [EOL] long actual = roundCeiling(instant); [EOL] assertEquals(expected, actual); [EOL] }
public void testGetMaximumValue() { [EOL] long instant = SOME_INSTANT_VALUE; [EOL] int expectedMaxValue = EXPECTED_MAX_VALUE; [EOL] int actualMaxValue = instance.getMaximumValue(instant); [EOL] assertEquals(expectedMaxValue, actualMaxValue); [EOL] }
public int getMaximumValueTestWithNonNullInstant() { [EOL] ReadablePartial mockInstant = mock(ReadablePartial.class); [EOL] when(iField.getMaximumValue(mockInstant)).thenReturn(10); [EOL] int result = getMaximumValue(mockInstant); [EOL] assertEquals(10, result); [EOL] }
public int get(long instant) { [EOL] return ERA_VALUE; [EOL] }
public void testGetAsShortTextWithValidFieldValueAndLocale() { [EOL] int fieldValue = 1; // Assuming 1 represents a valid day of the week [EOL] Locale locale = Locale.US; [EOL] String result = getAsShortText(fieldValue, locale); [EOL] assertNotNull(result); [EOL] assertFalse(result.isEmpty()); [EOL] }
public void testGetAsShortTextWithInvalidFieldValue() { [EOL] int fieldValue = 8; // Assuming the days of the week are 1-7 [EOL] Locale locale = Locale.US; [EOL] try { [EOL] getAsShortText(fieldValue, locale); [EOL] fail("Should have thrown an exception for invalid field value"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testGetAsShortTextWithNullLocale() { [EOL] int fieldValue = 1; [EOL] Locale locale = null; [EOL] try { [EOL] getAsShortText(fieldValue, locale); [EOL] fail("Should have thrown an exception for null locale"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testCreateMessage_ValueNotSupported() { [EOL] String result = createMessage("age", 30, null, null, null); [EOL] assertEquals("Value 30 for age is not supported", result); [EOL] }
public void testCreateMessage_ValueMustNotBeLarger() { [EOL] String result = createMessage("age", 30, null, 25, null); [EOL] assertEquals("Value 30 for age must not be larger than 25", result); [EOL] }
public void testCreateMessage_ValueMustNotBeSmaller() { [EOL] String result = createMessage("age", 30, 35, null, null); [EOL] assertEquals("Value 30 for age must not be smaller than 35", result); [EOL] }
public void testCreateMessage_ValueInRange() { [EOL] String result = createMessage("age", 30, 20, 40, null); [EOL] assertEquals("Value 30 for age must be in the range [20,40]", result); [EOL] }
public void testCreateMessage_ValueInRangeWithExplanation() { [EOL] String result = createMessage("age", 30, 20, 40, "Age must be between 20 and 40."); [EOL] assertEquals("Value 30 for age must be in the range [20,40]: Age must be between 20 and 40.", result); [EOL] }
public void testIllegalFieldValueExceptionWithAllValues() { [EOL] String fieldName = "hour"; [EOL] Number value = 25; [EOL] Number lowerBound = 0; [EOL] Number upperBound = 23; [EOL] IllegalFieldValueException exception = new IllegalFieldValueException(fieldName, value, lowerBound, upperBound); [EOL] assertEquals("hour 25 is not in the range 0 - 23", exception.getMessage()); [EOL] assertNull(exception.getDateTimeFieldType()); [EOL] assertNull(exception.getDurationFieldType()); [EOL] assertEquals(fieldName, exception.getFieldName()); [EOL] assertEquals(value, exception.getNumberValue()); [EOL] assertNull(exception.getStringValue()); [EOL] assertEquals(lowerBound, exception.getLowerBound()); [EOL] assertEquals(upperBound, exception.getUpperBound()); [EOL] }
public void testNowWithNullZone() { [EOL] try { [EOL] LocalTime.now(null); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException ex) { [EOL] assertEquals("Zone must not be null", ex.getMessage()); [EOL] } [EOL] }
public void testNowWithNonNullZone() { [EOL] DateTimeZone zone = DateTimeZone.UTC; [EOL] LocalTime result = LocalTime.now(zone); [EOL] assertNotNull(result); [EOL] assertEquals(zone, result.getZone()); [EOL] }
public void testFromMillisOfDayWithValidMillis() { [EOL] long millisOfDay = 12345L; // A valid millisecond value within the day [EOL] LocalTime result = Time.fromMillisOfDay(millisOfDay); [EOL] assertNotNull(result); [EOL] assertEquals(result, LocalTime.ofNanoOfDay(millisOfDay * 1000000)); [EOL] }
public void testFromMillisOfDayWithNegativeMillis() { [EOL] long millisOfDay = -1L; // A negative millisecond value [EOL] try { [EOL] Time.fromMillisOfDay(millisOfDay); [EOL] fail("Should have thrown an exception for negative millisOfDay"); [EOL] } catch (DateTimeException e) { [EOL] } [EOL] }
public void testFromMillisOfDayAtDayBoundary() { [EOL] long millisOfDay = 86400000L; // Milliseconds in a day [EOL] try { [EOL] Time.fromMillisOfDay(millisOfDay); [EOL] fail("Should have thrown an exception for millisOfDay equal to the number of milliseconds in a day"); [EOL] } catch (DateTimeException e) { [EOL] } [EOL] }
public void testFromMillisOfDayWithNullChronology() { [EOL] long millisOfDay = 12345L; [EOL] LocalTime result = Time.fromMillisOfDay(millisOfDay, null); [EOL] assertNotNull(result); [EOL] assertEquals(result.getMillisOfDay(), millisOfDay); [EOL] assertEquals(result.getChronology().getZone(), DateTimeZone.UTC); [EOL] }
public void testFromMillisOfDayWithNonNullChronology() { [EOL] long millisOfDay = 12345L; [EOL] Chronology chrono = ISOChronology.getInstance(); [EOL] LocalTime result = Time.fromMillisOfDay(millisOfDay, chrono); [EOL] assertNotNull(result); [EOL] assertEquals(result.getMillisOfDay(), millisOfDay); [EOL] assertEquals(result.getChronology().getZone(), DateTimeZone.UTC); [EOL] }
public void testFromCalendarFieldsWithNullCalendar() { [EOL] try { [EOL] LocalTime.fromCalendarFields(null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("The calendar must not be null", ex.getMessage()); [EOL] } [EOL] }
public void testFromCalendarFieldsWithNonNullCalendar() { [EOL] Calendar calendar = Calendar.getInstance(); [EOL] calendar.set(Calendar.HOUR_OF_DAY, 15); [EOL] calendar.set(Calendar.MINUTE, 30); [EOL] calendar.set(Calendar.SECOND, 20); [EOL] calendar.set(Calendar.MILLISECOND, 250); [EOL] LocalTime result = LocalTime.fromCalendarFields(calendar); [EOL] assertEquals(15, result.getHourOfDay()); [EOL] assertEquals(30, result.getMinuteOfHour()); [EOL] assertEquals(20, result.getSecondOfMinute()); [EOL] assertEquals(250, result.getMillisOfSecond()); [EOL] }
public void testLocalTimeConstructor() { [EOL] LocalTime localTime = new LocalTime(); [EOL] assertNotNull(localTime); [EOL] assertEquals(ISOChronology.getInstance(), localTime.getChronology()); [EOL] assertEquals(DateTimeUtils.currentTimeMillis(), localTime.getMillisOfDay(), 1000); [EOL] }
public void testLocalTimeWithNullZone() { [EOL] LocalTime localTime = new LocalTime((DateTimeZone) null); [EOL] assertNotNull(localTime); [EOL] assertEquals(ISOChronology.getInstance(), localTime.getChronology()); [EOL] }
public void testLocalTimeWithNonNullZone() { [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/Paris"); [EOL] LocalTime localTime = new LocalTime(zone); [EOL] assertNotNull(localTime); [EOL] assertEquals(ISOChronology.getInstance(zone), localTime.getChronology()); [EOL] }
public void testLocalTimeWithValidInstant() { [EOL] long instant = System.currentTimeMillis(); [EOL] LocalTime localTime = new LocalTime(instant); [EOL] assertNotNull(localTime); [EOL] }
public void testLocalTimeWithNegativeInstant() { [EOL] long instant = -System.currentTimeMillis(); [EOL] LocalTime localTime = new LocalTime(instant); [EOL] assertNotNull(localTime); [EOL] }
public void testLocalTimeWithInstantAndZone() { [EOL] long instant = System.currentTimeMillis(); [EOL] DateTimeZone zone = DateTimeZone.getDefault(); [EOL] LocalTime localTime = new LocalTime(instant, zone); [EOL] assertNotNull(localTime); [EOL] }
public void testLocalTimeWithInstantAndUTCZone() { [EOL] long instant = System.currentTimeMillis(); [EOL] DateTimeZone zone = DateTimeZone.UTC; [EOL] LocalTime localTime = new LocalTime(instant, zone); [EOL] assertNotNull(localTime); [EOL] assertEquals(zone, DateTimeZone.UTC); [EOL] }
public void testLocalTimeWithInstantAndFixedZone() { [EOL] long instant = System.currentTimeMillis(); [EOL] DateTimeZone zone = DateTimeZone.forOffsetHours(1); [EOL] LocalTime localTime = new LocalTime(instant, zone); [EOL] assertNotNull(localTime); [EOL] assertEquals(zone, DateTimeZone.forOffsetHours(1)); [EOL] }
public void testReadResolve_ChronologyNull() { [EOL] Time time = new Time(12345L, null); // Assuming Time is the class name and it has such a constructor [EOL] Object resolved = time.readResolve(); [EOL] assertTrue(resolved instanceof LocalTime); [EOL] assertEquals(ISOChronology.getInstanceUTC(), ((LocalTime) resolved).getChronology()); [EOL] }
public void testReadResolve_ChronologyNotUTC() { [EOL] Chronology nonUTCChronology = // ... obtain a non-UTC chronology [EOL] Time time = new Time(12345L, nonUTCChronology); [EOL] Object resolved = time.readResolve(); [EOL] assertTrue(resolved instanceof LocalTime); [EOL] assertEquals(nonUTCChronology.withUTC(), ((LocalTime) resolved).getChronology()); [EOL] }
public void testReadResolve_ChronologyUTC() { [EOL] Chronology utcChronology = ISOChronology.getInstanceUTC(); [EOL] Time time = new Time(12345L, utcChronology); [EOL] Object resolved = time.readResolve(); [EOL] assertSame(time, resolved); [EOL] }
public void testGetFieldHourOfDay() { [EOL] Chronology chrono = ISOChronology.getInstance(); [EOL] DateTimeField field = getField(HOUR_OF_DAY, chrono); [EOL] assertNotNull(field); [EOL] assertEquals("HourOfDay", field.getName()); [EOL] }
public void testGetFieldMinuteOfHour() { [EOL] Chronology chrono = ISOChronology.getInstance(); [EOL] DateTimeField field = getField(MINUTE_OF_HOUR, chrono); [EOL] assertNotNull(field); [EOL] assertEquals("MinuteOfHour", field.getName()); [EOL] }
public void testGetFieldSecondOfMinute() { [EOL] Chronology chrono = ISOChronology.getInstance(); [EOL] DateTimeField field = getField(SECOND_OF_MINUTE, chrono); [EOL] assertNotNull(field); [EOL] assertEquals("SecondOfMinute", field.getName()); [EOL] }
public void testGetFieldMillisOfSecond() { [EOL] Chronology chrono = ISOChronology.getInstance(); [EOL] DateTimeField field = getField(MILLIS_OF_SECOND, chrono); [EOL] assertNotNull(field); [EOL] assertEquals("MillisOfSecond", field.getName()); [EOL] }
public void testGetFieldInvalidIndex() { [EOL] Chronology chrono = ISOChronology.getInstance(); [EOL] try { [EOL] getField(-1, chrono); [EOL] fail("Should have thrown IndexOutOfBoundsException"); [EOL] } catch (IndexOutOfBoundsException ex) { [EOL] } [EOL] }
public void testGetWithNullFieldType() { [EOL] try { [EOL] DateTime testDateTime = new DateTime(); [EOL] testDateTime.get(null); [EOL] fail("Should have thrown IllegalArgumentException for null DateTimeFieldType"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("The DateTimeFieldType must not be null", ex.getMessage()); [EOL] } [EOL] }
public void testGetWithUnsupportedFieldType() { [EOL] try { [EOL] DateTime testDateTime = new DateTime(); [EOL] DateTimeFieldType fieldType = DateTimeFieldType.hourOfDay(); // Assuming this is unsupported for the sake of example [EOL] if (testDateTime.isSupported(fieldType)) { [EOL] fail("Field type should be unsupported for this test case"); [EOL] } [EOL] testDateTime.get(fieldType); [EOL] fail("Should have thrown IllegalArgumentException for unsupported DateTimeFieldType"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertTrue(ex.getMessage().contains("Field '")); [EOL] assertTrue(ex.getMessage().contains("' is not supported")); [EOL] } [EOL] }
public void testGetWithSupportedFieldType() { [EOL] DateTime testDateTime = new DateTime(); [EOL] DateTimeFieldType fieldType = DateTimeFieldType.dayOfMonth(); // Assuming this is supported [EOL] if (!testDateTime.isSupported(fieldType)) { [EOL] fail("Field type should be supported for this test case"); [EOL] } [EOL] int value = testDateTime.get(fieldType); [EOL] int expectedValue = 15; [EOL] assertEquals(expectedValue, value); [EOL] }
public void testIsSupportedWithNullType() { [EOL] boolean result = isSupported(null); [EOL] assertFalse(result); [EOL] } [EOL] public void testIsSupportedWithUnsupportedDurationType() { [EOL] DateTimeFieldType type = mock(DateTimeFieldType.class); [EOL] when(type.getDurationType()).thenReturn(DurationFieldType.weeks()); [EOL] when(isSupported(DurationFieldType.weeks())).thenReturn(false); [EOL] boolean result = isSupported(type); [EOL] assertFalse(result); [EOL] } [EOL] public void testIsSupportedWithSupportedDurationTypeAndUnsupportedRange() { [EOL] DateTimeFieldType type = mock(DateTimeFieldType.class); [EOL] DurationFieldType durationType = DurationFieldType.hours(); [EOL] DurationFieldType rangeType = DurationFieldType.months(); [EOL] when(type.getDurationType()).thenReturn(durationType); [EOL] when(type.getRangeDurationType()).thenReturn(rangeType); [EOL] when(isSupported(durationType)).thenReturn(true); [EOL] when(isSupported(rangeType)).thenReturn(false); [EOL] boolean result = isSupported(type); [EOL] assertFalse(result); [EOL] } [EOL] public void testIsSupportedWithSupportedDurationTypeAndSupportedRange() { [EOL] DateTimeFieldType type = mock(DateTimeFieldType.class); [EOL] DurationFieldType durationType = DurationFieldType.hours(); [EOL] DurationFieldType rangeType = DurationFieldType.weeks(); [EOL] when(type.getDurationType()).thenReturn(durationType); [EOL] when(type.getRangeDurationType()).thenReturn(rangeType); [EOL] when(isSupported(durationType)).thenReturn(true); [EOL] when(isSupported(rangeType)).thenReturn(true); [EOL] boolean result = isSupported(type); [EOL] assertTrue(result); [EOL] } [EOL] public void testIsSupportedWithSupportedDurationTypeAndRangeIsDays() { [EOL] DateTimeFieldType type = mock(DateTimeFieldType.class); [EOL] DurationFieldType durationType = DurationFieldType.hours(); [EOL] when(type.getDurationType()).thenReturn(durationType); [EOL] when(type.getRangeDurationType()).thenReturn(DurationFieldType.days()); [EOL] when(isSupported(durationType)).thenReturn(true); [EOL] boolean result = isSupported(type); [EOL] assertTrue(result); [EOL] }
public void testIsSupportedWithNullType() { [EOL] boolean result = instance.isSupported(null); [EOL] assertFalse(result); [EOL] }
public void testIsSupportedWithUnsupportedType() { [EOL] DurationFieldType unsupportedType = DurationFieldType.centuries(); [EOL] boolean result = instance.isSupported(unsupportedType); [EOL] assertFalse(result); [EOL] }
public void testIsSupportedWithSupportedType() { [EOL] DurationFieldType supportedType = DurationFieldType.minutes(); [EOL] boolean result = instance.isSupported(supportedType); [EOL] assertTrue(result); [EOL] }
public void testWithField_NullField() { [EOL] LocalTime time = new LocalTime(); [EOL] try { [EOL] time.withField(null, 1); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public void testWithField_UnsupportedField() { [EOL] LocalTime time = new LocalTime(); [EOL] DateTimeFieldType fieldType = DateTimeFieldType.dayOfMonth(); // Assuming this is unsupported [EOL] try { [EOL] time.withField(fieldType, 1); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public void testWithField_SupportedField() { [EOL] LocalTime time = new LocalTime(); [EOL] DateTimeFieldType fieldType = DateTimeFieldType.hourOfDay(); // Assuming this is supported [EOL] int newValue = 10; [EOL] LocalTime updatedTime = time.withField(fieldType, newValue); [EOL] assertEquals(newValue, updatedTime.get(fieldType)); [EOL] }
public void testWithFieldAdded_NullFieldType() { [EOL] try { [EOL] LocalTime time = new LocalTime(); [EOL] time.withFieldAdded(null, 1); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public void testWithFieldAdded_UnsupportedFieldType() { [EOL] try { [EOL] LocalTime time = new LocalTime(); [EOL] DurationFieldType fieldType = DurationFieldType.centuries(); // Assuming centuries is not supported [EOL] time.withFieldAdded(fieldType, 1); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public void testWithFieldAdded_ZeroAmount() { [EOL] LocalTime time = new LocalTime(); [EOL] DurationFieldType fieldType = DurationFieldType.minutes(); // Assuming minutes is supported [EOL] LocalTime result = time.withFieldAdded(fieldType, 0); [EOL] assertEquals(time, result); [EOL] }
public void testWithFieldAdded_NonZeroAmount() { [EOL] LocalTime time = new LocalTime(); [EOL] DurationFieldType fieldType = DurationFieldType.minutes(); // Assuming minutes is supported [EOL] int amount = 30; [EOL] LocalTime result = time.withFieldAdded(fieldType, amount); [EOL] assertNotSame(time, result); [EOL] assertEquals(time.plusMinutes(amount), result); [EOL] }
public void testPlusMillis_Zero() { [EOL] LocalTime time = LocalTime.now(); [EOL] LocalTime result = time.plusMillis(0); [EOL] assertEquals(time, result); [EOL] }
public void testPlusMillis_Positive() { [EOL] LocalTime time = LocalTime.now(); [EOL] int millisToAdd = 500; [EOL] LocalTime expected = time.plusMillis(millisToAdd); [EOL] LocalTime result = time.plusMillis(millisToAdd); [EOL] assertEquals(expected, result); [EOL] }
public void testPlusMillis_Negative() { [EOL] LocalTime time = LocalTime.now(); [EOL] int millisToSubtract = -500; [EOL] LocalTime expected = time.plusMillis(millisToSubtract); [EOL] LocalTime result = time.plusMillis(millisToSubtract); [EOL] assertEquals(expected, result); [EOL] }
public void testMinusHours_Zero() { [EOL] LocalTime time = LocalTime.now(); [EOL] LocalTime result = time.minusHours(0); [EOL] assertEquals(time, result); [EOL] }
public void testMinusHours_Positive() { [EOL] LocalTime time = LocalTime.now(); [EOL] LocalTime result = time.minusHours(1); [EOL] assertNotEquals(time, result); [EOL] assertEquals(time.minusHours(1), result); [EOL] }
public void testMinusHours_Negative() { [EOL] LocalTime time = LocalTime.now(); [EOL] LocalTime result = time.minusHours(-1); [EOL] assertNotEquals(time, result); [EOL] assertEquals(time.plusHours(1), result); [EOL] }
public int getMillisOfDay() { [EOL] return getChronology().millisOfDay().get(getLocalMillis()); [EOL] }
public void testToDateTimeTodayWithNullZone() { [EOL] LocalDate localDate = new LocalDate(); [EOL] DateTime result = localDate.toDateTimeToday(); [EOL] assertNotNull(result); [EOL] assertEquals(result.toLocalDate(), localDate); [EOL] }
public void testPropertyWithValidInstantAndField() { [EOL] LocalTime instant = LocalTime.now(); [EOL] DateTimeField field = DateTimeFieldType.secondOfMinute(); [EOL] Property property = new Property(instant, field); [EOL] assertNotNull(property); [EOL] assertEquals(instant, property.iInstant); [EOL] assertEquals(field, property.iField); [EOL] }
public void testGetField() { [EOL] DateTimeField expectedField = // initialize with a mock or actual instance [EOL] YourClass instance = new YourClass(expectedField); [EOL] DateTimeField actualField = instance.getField(); [EOL] assertEquals(expectedField, actualField); [EOL] }
protected long getMillis() { [EOL] return iInstant.getLocalMillis(); [EOL] }
public LocalTime withMaximumValueTest() { [EOL] LocalTime time = LocalTime.now(); [EOL] LocalTime maxTime = time.withMaximumValue(); [EOL] assertEquals(maxTime, time.setCopy(time.getMaximumValue())); [EOL] }
public LocalTime withMinimumValue() { [EOL] return setCopy(getMinimumValue()); [EOL] }
public int getTestWithMillisLessThanOrEqualToSkip() { [EOL] long millis = 1000L; // Assuming this millis results in value <= iSkip [EOL] int expected = super.get(millis) - 1; [EOL] int actual = get(millis); [EOL] assertEquals(expected, actual); [EOL] } [EOL] public int getTestWithMillisGreaterThanSkip() { [EOL] long millis = 2000L; // Assuming this millis results in value > iSkip [EOL] int expected = super.get(millis); [EOL] int actual = get(millis); [EOL] assertEquals(expected, actual); [EOL] }
public void testSet_ValueWithinBounds() { [EOL] long millis = System.currentTimeMillis(); [EOL] int value = iMinValue + 1; // Assuming iMinValue is the minimum allowed value for the field [EOL] if (value == iSkip) { // Adjust value if it's equal to iSkip [EOL] value++; [EOL] } [EOL] long expectedMillis = millis; // Expected millis might need to be calculated based on the field being set [EOL] long actualMillis = set(millis, value); [EOL] assertEquals(expectedMillis, actualMillis); [EOL] }
public void testSet_ValueAtMinBoundary() { [EOL] long millis = System.currentTimeMillis(); [EOL] int value = iMinValue; [EOL] if (value == iSkip) { // Adjust value if it's equal to iSkip [EOL] value++; [EOL] } [EOL] long expectedMillis = millis; // Expected millis might need to be calculated based on the field being set [EOL] long actualMillis = set(millis, value); [EOL] assertEquals(expectedMillis, actualMillis); [EOL] }
public void testSet_ValueAtMaxBoundary() { [EOL] long millis = System.currentTimeMillis(); [EOL] int value = getMaximumValue(); // Assuming getMaximumValue() returns the maximum allowed value for the field [EOL] long expectedMillis = millis; // Expected millis might need to be calculated based on the field being set [EOL] long actualMillis = set(millis, value); [EOL] assertEquals(expectedMillis, actualMillis); [EOL] }
public void testSet_ValueBelowMinBoundary() { [EOL] long millis = System.currentTimeMillis(); [EOL] int value = iMinValue - 1; [EOL] try { [EOL] set(millis, value); [EOL] fail("Expected an IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public void testSet_ValueEqualsSkip() { [EOL] long millis = System.currentTimeMillis(); [EOL] int value = iSkip; [EOL] try { [EOL] set(millis, value); [EOL] fail("Expected an IllegalFieldValueException to be thrown"); [EOL] } catch (IllegalFieldValueException ex) { [EOL] } [EOL] }
public void testSet_ValueJustAboveSkip() { [EOL] long millis = System.currentTimeMillis(); [EOL] int value = iSkip + 1; [EOL] long expectedMillis = millis; // Expected millis might need to be calculated based on the field being set [EOL] long actualMillis = set(millis, value); [EOL] assertEquals(expectedMillis, actualMillis); [EOL] }
public void testReadResolveForEras() { [EOL] MyClass instance = new MyClass(MyClass.ERAS); [EOL] Object result = instance.readResolve(); [EOL] assertSame(MyClass.ERAS_TYPE, result); [EOL] }
public void testReadResolveForCenturies() { [EOL] MyClass instance = new MyClass(MyClass.CENTURIES); [EOL] Object result = instance.readResolve(); [EOL] assertSame(MyClass.CENTURIES_TYPE, result); [EOL] }
public void testReadResolveForWeekyears() { [EOL] MyClass instance = new MyClass(MyClass.WEEKYEARS); [EOL] Object result = instance.readResolve(); [EOL] assertSame(MyClass.WEEKYEARS_TYPE, result); [EOL] }
public void testReadResolveForYears() { [EOL] MyClass instance = new MyClass(MyClass.YEARS); [EOL] Object result = instance.readResolve(); [EOL] assertSame(MyClass.YEARS_TYPE, result); [EOL] }
public void testReadResolveForMonths() { [EOL] MyClass instance = new MyClass(MyClass.MONTHS); [EOL] Object result = instance.readResolve(); [EOL] assertSame(MyClass.MONTHS_TYPE, result); [EOL] }
public void testReadResolveForWeeks() { [EOL] MyClass instance = new MyClass(MyClass.WEEKS); [EOL] Object result = instance.readResolve(); [EOL] assertSame(MyClass.WEEKS_TYPE, result); [EOL] }
public void testReadResolveForDays() { [EOL] MyClass instance = new MyClass(MyClass.DAYS); [EOL] Object result = instance.readResolve(); [EOL] assertSame(MyClass.DAYS_TYPE, result); [EOL] }
public void testReadResolveForHalfdays() { [EOL] MyClass instance = new MyClass(MyClass.HALFDAYS); [EOL] Object result = instance.readResolve(); [EOL] assertSame(MyClass.HALFDAYS_TYPE, result); [EOL] }
public void testReadResolveForHours() { [EOL] MyClass instance = new MyClass(MyClass.HOURS); [EOL] Object result = instance.readResolve(); [EOL] assertSame(MyClass.HOURS_TYPE, result); [EOL] }
public void testReadResolveForMinutes() { [EOL] MyClass instance = new MyClass(MyClass.MINUTES); [EOL] Object result = instance.readResolve(); [EOL] assertSame(MyClass.MINUTES_TYPE, result); [EOL] }
public void testReadResolveForSeconds() { [EOL] MyClass instance = new MyClass(MyClass.SECONDS); [EOL] Object result = instance.readResolve(); [EOL] assertSame(MyClass.SECONDS_TYPE, result); [EOL] }
public void testReadResolveForMillis() { [EOL] MyClass instance = new MyClass(MyClass.MILLIS); [EOL] Object result = instance.readResolve(); [EOL] assertSame(MyClass.MILLIS_TYPE, result); [EOL] }
public void testReadResolveForDefault() { [EOL] MyClass instance = new MyClass(-1); // Assuming -1 is not a valid ordinal [EOL] Object result = instance.readResolve(); [EOL] assertSame(instance, result); [EOL] }
public void testNowWithNullChronology() { [EOL] try { [EOL] MutableDateTime.now(null); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException ex) { [EOL] assertEquals("Chronology must not be null", ex.getMessage()); [EOL] } [EOL] }
public void testNowWithNonNullChronology() { [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] MutableDateTime dateTime = MutableDateTime.now(chronology); [EOL] assertNotNull(dateTime); [EOL] assertSame(chronology, dateTime.getChronology()); [EOL] }
public void testMutableDateTimeWithNullZone() { [EOL] MutableDateTime dateTime = new MutableDateTime((DateTimeZone) null); [EOL] assertNotNull(dateTime); [EOL] assertEquals(DateTimeZone.UTC, dateTime.getZone()); [EOL] }
public void testMutableDateTimeWithNonNullZone() { [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/Paris"); [EOL] MutableDateTime dateTime = new MutableDateTime(zone); [EOL] assertNotNull(dateTime); [EOL] assertEquals(zone, dateTime.getZone()); [EOL] }
public void testMutableDateTimeWithNullChronology() { [EOL] MutableDateTime dateTime = new MutableDateTime((Chronology) null); [EOL] assertNotNull(dateTime); [EOL] assertEquals(ISOChronology.getInstance(), dateTime.getChronology()); [EOL] }
public void testMutableDateTimeWithNonNullChronology() { [EOL] Chronology chronology = BuddhistChronology.getInstance(); [EOL] MutableDateTime dateTime = new MutableDateTime(chronology); [EOL] assertNotNull(dateTime); [EOL] assertEquals(chronology, dateTime.getChronology()); [EOL] }
public void testMutableDateTimeWithValidInstant() { [EOL] long instant = 1000L; // Example timestamp [EOL] MutableDateTime dateTime = new MutableDateTime(instant); [EOL] assertNotNull(dateTime); [EOL] assertEquals(instant, dateTime.getMillis()); [EOL] }
public void testMutableDateTimeWithValidInstantAndChronology() { [EOL] long instant = System.currentTimeMillis(); [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] MutableDateTime dateTime = new MutableDateTime(instant, chronology); [EOL] assertEquals(instant, dateTime.getMillis()); [EOL] assertEquals(chronology, dateTime.getChronology()); [EOL] }
public void testMutableDateTimeWithNullChronology() { [EOL] long instant = System.currentTimeMillis(); [EOL] MutableDateTime dateTime = new MutableDateTime(instant, null); [EOL] assertEquals(instant, dateTime.getMillis()); [EOL] assertNotNull(dateTime.getChronology()); [EOL] assertEquals(ISOChronology.getInstance(), dateTime.getChronology()); [EOL] }
public void testMutableDateTimeWithNull() { [EOL] MutableDateTime dateTime = new MutableDateTime((Object) null); [EOL] assertNotNull(dateTime); [EOL] assertEquals(DateTimeUtils.currentTimeMillis(), dateTime.getMillis()); [EOL] }
public void testMutableDateTimeWithDate() { [EOL] Date date = new Date(); [EOL] MutableDateTime dateTime = new MutableDateTime(date); [EOL] assertNotNull(dateTime); [EOL] assertEquals(date.getTime(), dateTime.getMillis()); [EOL] }
public void testMutableDateTimeWithCalendar() { [EOL] Calendar calendar = Calendar.getInstance(); [EOL] MutableDateTime dateTime = new MutableDateTime(calendar); [EOL] assertNotNull(dateTime); [EOL] assertEquals(calendar.getTimeInMillis(), dateTime.getMillis()); [EOL] }
public void testMutableDateTimeWithLong() { [EOL] long currentTimeMillis = System.currentTimeMillis(); [EOL] MutableDateTime dateTime = new MutableDateTime(currentTimeMillis); [EOL] assertNotNull(dateTime); [EOL] assertEquals(currentTimeMillis, dateTime.getMillis()); [EOL] }
public void testMutableDateTimeWithDateTime() { [EOL] DateTime dt = new DateTime(); [EOL] MutableDateTime dateTime = new MutableDateTime(dt); [EOL] assertNotNull(dateTime); [EOL] assertEquals(dt.getMillis(), dateTime.getMillis()); [EOL] }
public void testMutableDateTimeWithNullInstantAndNullChronology() { [EOL] MutableDateTime dateTime = new MutableDateTime(null, null); [EOL] assertNotNull(dateTime); [EOL] assertEquals(ISOChronology.getInstance(), dateTime.getChronology()); [EOL] }
public void testMutableDateTimeWithNonNullInstantAndNullChronology() { [EOL] Instant instant = new Instant(); [EOL] MutableDateTime dateTime = new MutableDateTime(instant, null); [EOL] assertNotNull(dateTime); [EOL] assertEquals(ISOChronology.getInstance(), dateTime.getChronology()); [EOL] assertEquals(instant.getMillis(), dateTime.getMillis()); [EOL] }
public void testMutableDateTimeWithNullInstantAndNonNullChronology() { [EOL] Chronology chronology = GregorianChronology.getInstance(); [EOL] MutableDateTime dateTime = new MutableDateTime(null, chronology); [EOL] assertNotNull(dateTime); [EOL] assertEquals(chronology, dateTime.getChronology()); [EOL] }
public void testMutableDateTimeWithNonNullInstantAndNonNullChronology() { [EOL] Instant instant = new Instant(); [EOL] Chronology chronology = GregorianChronology.getInstance(); [EOL] MutableDateTime dateTime = new MutableDateTime(instant, chronology); [EOL] assertNotNull(dateTime); [EOL] assertEquals(chronology, dateTime.getChronology()); [EOL] assertEquals(instant.getMillis(), dateTime.getMillis()); [EOL] }
public void add_PositiveDuration_ShouldAddToMillis() { [EOL] long initialMillis = 1000L; [EOL] long durationToAdd = 500L; [EOL] long expectedMillis = 1500L; [EOL] Time time = new Time(initialMillis); [EOL] time.add(durationToAdd); [EOL] assertEquals(expectedMillis, time.getMillis()); [EOL] }
public void add_NegativeDuration_ShouldSubtractFromMillis() { [EOL] long initialMillis = 1000L; [EOL] long durationToSubtract = -500L; [EOL] long expectedMillis = 500L; [EOL] Time time = new Time(initialMillis); [EOL] time.add(durationToSubtract); [EOL] assertEquals(expectedMillis, time.getMillis()); [EOL] }
public void add_ZeroDuration_ShouldNotChangeMillis() { [EOL] long initialMillis = 1000L; [EOL] long durationToAdd = 0L; [EOL] long expectedMillis = 1000L; [EOL] Time time = new Time(initialMillis); [EOL] time.add(durationToAdd); [EOL] assertEquals(expectedMillis, time.getMillis()); [EOL] }
public void testSetZoneWithDifferentZone() { [EOL] DateTimeZone originalZone = DateTimeZone.forID("Europe/London"); [EOL] DateTimeZone newZone = DateTimeZone.forID("Europe/Paris"); [EOL] TestDateTime testDateTime = new TestDateTime(originalZone); [EOL] testDateTime.setZone(newZone); [EOL] assertEquals("Zone should be set to new zone", newZone, testDateTime.getZone()); [EOL] }
public void testSetZoneWithSameZone() { [EOL] DateTimeZone originalZone = DateTimeZone.forID("Europe/London"); [EOL] TestDateTime testDateTime = new TestDateTime(originalZone); [EOL] testDateTime.setZone(originalZone); [EOL] assertEquals("Zone should not change if set to same zone", originalZone, testDateTime.getZone()); [EOL] }
public void testSetWithNullType() { [EOL] try { [EOL] DateTime testDateTime = new DateTime(); [EOL] testDateTime.set(null, 1); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("Field must not be null", ex.getMessage()); [EOL] } [EOL] } [EOL] public void testSetWithValidTypeAndValue() { [EOL] DateTimeFieldType type = DateTimeFieldType.dayOfMonth(); [EOL] int value = 15; [EOL] DateTime testDateTime = new DateTime(); [EOL] long initialMillis = testDateTime.getMillis(); [EOL] testDateTime.set(type, value); [EOL] long updatedMillis = testDateTime.getMillis(); [EOL] assertNotEquals(initialMillis, updatedMillis); [EOL] assertEquals(value, type.getField(testDateTime.getChronology()).get(updatedMillis)); [EOL] }
public void addYears_ZeroYears_NoChange() { [EOL] Time time = new Time(); [EOL] long initialMillis = time.getMillis(); [EOL] time.addYears(0); [EOL] assertEquals(initialMillis, time.getMillis()); [EOL] }
public void addYears_PositiveYears_ChronologyAddsYears() { [EOL] Time time = new Time(); [EOL] long initialMillis = time.getMillis(); [EOL] int yearsToAdd = 5; [EOL] time.addYears(yearsToAdd); [EOL] long expectedMillis = time.getChronology().years().add(initialMillis, yearsToAdd); [EOL] assertEquals(expectedMillis, time.getMillis()); [EOL] }
public void addYears_NegativeYears_ChronologySubtractsYears() { [EOL] Time time = new Time(); [EOL] long initialMillis = time.getMillis(); [EOL] int yearsToSubtract = -5; [EOL] time.addYears(yearsToSubtract); [EOL] long expectedMillis = time.getChronology().years().add(initialMillis, yearsToSubtract); [EOL] assertEquals(expectedMillis, time.getMillis()); [EOL] }
public void testAddDays_ZeroDays() { [EOL] Time time = new Time(); [EOL] long initialMillis = time.getMillis(); [EOL] time.addDays(0); [EOL] assertEquals(initialMillis, time.getMillis()); [EOL] }
public void testAddDays_PositiveDays() { [EOL] Time time = new Time(); [EOL] int daysToAdd = 5; // for example [EOL] long initialMillis = time.getMillis(); [EOL] long expectedMillis = time.getChronology().days().add(initialMillis, daysToAdd); [EOL] time.addDays(daysToAdd); [EOL] assertEquals(expectedMillis, time.getMillis()); [EOL] }
public void testAddDays_NegativeDays() { [EOL] Time time = new Time(); [EOL] int daysToSubtract = -5; // for example [EOL] long initialMillis = time.getMillis(); [EOL] long expectedMillis = time.getChronology().days().add(initialMillis, daysToSubtract); [EOL] time.addDays(daysToSubtract); [EOL] assertEquals(expectedMillis, time.getMillis()); [EOL] }
public void addMinutes_ZeroMinutes_NoChange() { [EOL] Time time = new Time(); [EOL] long initialMillis = time.getMillis(); [EOL] time.addMinutes(0); [EOL] assertEquals(initialMillis, time.getMillis()); [EOL] }
public void addMinutes_PositiveMinutes_ChangesTime() { [EOL] Time time = new Time(); [EOL] long initialMillis = time.getMillis(); [EOL] int minutesToAdd = 5; [EOL] time.addMinutes(minutesToAdd); [EOL] assertEquals(initialMillis + minutesToAdd * 60000, time.getMillis()); [EOL] }
public void addMinutes_NegativeMinutes_ChangesTime() { [EOL] Time time = new Time(); [EOL] long initialMillis = time.getMillis(); [EOL] int minutesToSubtract = -5; [EOL] time.addMinutes(minutesToSubtract); [EOL] assertEquals(initialMillis + minutesToSubtract * 60000, time.getMillis()); [EOL] }
public void testSetSecondOfDay_ValidValue() { [EOL] Time time = new Time(); [EOL] int validSecondOfDay = 3661; // Assuming this is a valid second of the day (1 hour, 1 minute, 1 second) [EOL] time.setSecondOfDay(validSecondOfDay); [EOL] assertEquals(validSecondOfDay, time.getChronology().secondOfDay().get(time.getMillis())); [EOL] }
public void testSetSecondOfDay_MinValue() { [EOL] Time time = new Time(); [EOL] int minSecondOfDay = 0; // Start of the day [EOL] time.setSecondOfDay(minSecondOfDay); [EOL] assertEquals(minSecondOfDay, time.getChronology().secondOfDay().get(time.getMillis())); [EOL] }
public void testSetSecondOfDay_MaxValue() { [EOL] Time time = new Time(); [EOL] int maxSecondOfDay = 86399; // Assuming this is the last second of the day (23 hours, 59 minutes, 59 seconds) [EOL] time.setSecondOfDay(maxSecondOfDay); [EOL] assertEquals(maxSecondOfDay, time.getChronology().secondOfDay().get(time.getMillis())); [EOL] }
public void addMillis_positiveMillis_addsToMillis() { [EOL] int initialMillis = 1000; [EOL] int millisToAdd = 500; [EOL] Time time = new Time(initialMillis); // Assuming Time is the class and it has a constructor that accepts millis [EOL] time.addMillis(millisToAdd); [EOL] assertEquals(1500, time.getMillis()); [EOL] }
public void addMillis_zeroMillis_noChangeToMillis() { [EOL] int initialMillis = 1000; [EOL] int millisToAdd = 0; [EOL] Time time = new Time(initialMillis); // Assuming Time is the class and it has a constructor that accepts millis [EOL] time.addMillis(millisToAdd); [EOL] assertEquals(1000, time.getMillis()); [EOL] }
public void addMillis_negativeMillis_subtractsFromMillis() { [EOL] int initialMillis = 1000; [EOL] int millisToAdd = -500; [EOL] Time time = new Time(initialMillis); // Assuming Time is the class and it has a constructor that accepts millis [EOL] time.addMillis(millisToAdd); [EOL] assertEquals(500, time.getMillis()); [EOL] }
public void testSetTime_MillisAtStartOfDay() { [EOL] long millis = 0; // Assuming this is the start of a day in UTC [EOL] DateTime testDateTime = new DateTime(); [EOL] testDateTime.setTime(millis); [EOL] int expectedMillisOfDay = 0; // Start of day [EOL] assertEquals(expectedMillisOfDay, testDateTime.getChronology().millisOfDay().get(testDateTime.getMillis())); [EOL] }
public void testSetTime_MillisAtNoon() { [EOL] long millis = 43200000; // Assuming this is noon (12:00 PM) in UTC [EOL] DateTime testDateTime = new DateTime(); [EOL] testDateTime.setTime(millis); [EOL] int expectedMillisOfDay = 43200000; // Noon [EOL] assertEquals(expectedMillisOfDay, testDateTime.getChronology().millisOfDay().get(testDateTime.getMillis())); [EOL] }
public void testSetTime_MillisAtEndOfDay() { [EOL] long millis = 86399999; // Assuming this is one millisecond before the end of a day in UTC [EOL] DateTime testDateTime = new DateTime(); [EOL] testDateTime.setTime(millis); [EOL] int expectedMillisOfDay = 86399999; // One millisecond before end of day [EOL] assertEquals(expectedMillisOfDay, testDateTime.getChronology().millisOfDay().get(testDateTime.getMillis())); [EOL] }
public void testSetTimeWithNonNullZone() { [EOL] ReadableInstant instant = new DateTime(2023, 4, 1, 12, 0, DateTimeZone.forID("Europe/London")); [EOL] setTime(instant); [EOL] }
public void testSetTimeWithUTCZone() { [EOL] ReadableInstant instant = new DateTime(2023, 4, 1, 12, 0, DateTimeZone.UTC); [EOL] setTime(instant); [EOL] }
public void testSetTimeWithNullZone() { [EOL] ReadableInstant instant = new DateTime(2023, 4, 1, 12, 0, (DateTimeZone) null); [EOL] setTime(instant); [EOL] }
public void testCenturyOfEra() { [EOL] Time time = new Time(); [EOL] Property result = time.centuryOfEra(); [EOL] assertNotNull(result); [EOL] assertEquals(result, new Property(time, time.getChronology().centuryOfEra())); [EOL] }
public void testWeekyearProperty() { [EOL] Time time = new Time(); [EOL] Property property = time.weekyear(); [EOL] assertNotNull(property); [EOL] assertEquals(time.getChronology().weekyear(), property.getField()); [EOL] }
public void testAddPositiveValue() { [EOL] MutableDateTime dateTime = new MutableDateTime(); [EOL] long initialMillis = dateTime.getMillis(); [EOL] long valueToAdd = 1000L; // 1 second [EOL] MutableDateTime updatedDateTime = dateTime.add(valueToAdd); [EOL] long expectedMillis = initialMillis + valueToAdd; [EOL] assertEquals(expectedMillis, updatedDateTime.getMillis()); [EOL] }
public void testAddNegativeValue() { [EOL] MutableDateTime dateTime = new MutableDateTime(); [EOL] long initialMillis = dateTime.getMillis(); [EOL] long valueToAdd = -1000L; // -1 second [EOL] MutableDateTime updatedDateTime = dateTime.add(valueToAdd); [EOL] long expectedMillis = initialMillis + valueToAdd; [EOL] assertEquals(expectedMillis, updatedDateTime.getMillis()); [EOL] }
public void testHoursZero() { [EOL] Hours result = Time.hours(0); [EOL] assertSame(Hours.ZERO, result); [EOL] }
public void testHoursOne() { [EOL] Hours result = Time.hours(1); [EOL] assertSame(Hours.ONE, result); [EOL] }
public void testHoursTwo() { [EOL] Hours result = Time.hours(2); [EOL] assertSame(Hours.TWO, result); [EOL] }
public void testHoursThree() { [EOL] Hours result = Time.hours(3); [EOL] assertSame(Hours.THREE, result); [EOL] }
public void testHoursFour() { [EOL] Hours result = Time.hours(4); [EOL] assertSame(Hours.FOUR, result); [EOL] }
public void testHoursFive() { [EOL] Hours result = Time.hours(5); [EOL] assertSame(Hours.FIVE, result); [EOL] }
public void testHoursSix() { [EOL] Hours result = Time.hours(6); [EOL] assertSame(Hours.SIX, result); [EOL] }
public void testHoursSeven() { [EOL] Hours result = Time.hours(7); [EOL] assertSame(Hours.SEVEN, result); [EOL] }
public void testHoursEight() { [EOL] Hours result = Time.hours(8); [EOL] assertSame(Hours.EIGHT, result); [EOL] }
public void testHoursMaxValue() { [EOL] Hours result = Time.hours(Integer.MAX_VALUE); [EOL] assertSame(Hours.MAX_VALUE, result); [EOL] }
public void testHoursMinValue() { [EOL] Hours result = Time.hours(Integer.MIN_VALUE); [EOL] assertSame(Hours.MIN_VALUE, result); [EOL] }
public void testHoursDefault() { [EOL] int arbitraryHours = 9; // Any value not covered by the switch cases [EOL] Hours result = Time.hours(arbitraryHours); [EOL] assertNotNull(result); [EOL] assertEquals(arbitraryHours, result.getValue()); [EOL] }
public void testStandardHoursIn_withNullPeriod() { [EOL] try { [EOL] Hours result = Time.standardHoursIn(null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] } [EOL] public void testStandardHoursIn_withValidPeriod() { [EOL] ReadablePeriod period = new Period(0, 0, 0, 1, 2, 30, 0, 0); [EOL] Hours result = Time.standardHoursIn(period); [EOL] assertEquals("Expected hours to be 26", 26, result.getHours()); [EOL] }
public void testGetFieldType() { [EOL] DurationFieldType type = new Duration().getFieldType(); [EOL] assertEquals(DurationFieldType.hours(), type); [EOL] }
public void testToStandardWeeks_ExactWeeks() { [EOL] Hours hours = Hours.hours(DateTimeConstants.HOURS_PER_WEEK * 2); [EOL] Weeks weeks = hours.toStandardWeeks(); [EOL] assertEquals(2, weeks.getWeeks()); [EOL] }
public void testToStandardWeeks_NotExactWeeks() { [EOL] Hours hours = Hours.hours(DateTimeConstants.HOURS_PER_WEEK * 2 + 1); [EOL] Weeks weeks = hours.toStandardWeeks(); [EOL] assertEquals(2, weeks.getWeeks()); [EOL] }
public void testToStandardWeeks_ZeroHours() { [EOL] Hours hours = Hours.hours(0); [EOL] Weeks weeks = hours.toStandardWeeks(); [EOL] assertEquals(0, weeks.getWeeks()); [EOL] }
public void testToStandardWeeks_NegativeHours() { [EOL] Hours hours = Hours.hours(-1 * DateTimeConstants.HOURS_PER_WEEK); [EOL] Weeks weeks = hours.toStandardWeeks(); [EOL] assertEquals(-1, weeks.getWeeks()); [EOL] }
public void testToStandardSeconds_PositiveHours() { [EOL] Hours hours = Hours.hours(1); [EOL] Seconds seconds = hours.toStandardSeconds(); [EOL] assertEquals(3600, seconds.getSeconds()); [EOL] }
public void testToStandardSeconds_NegativeHours() { [EOL] Hours hours = Hours.hours(-1); [EOL] Seconds seconds = hours.toStandardSeconds(); [EOL] assertEquals(-3600, seconds.getSeconds()); [EOL] }
public void testToStandardSeconds_ZeroHours() { [EOL] Hours hours = Hours.hours(0); [EOL] Seconds seconds = hours.toStandardSeconds(); [EOL] assertEquals(0, seconds.getSeconds()); [EOL] }
public void testGetHours() { [EOL] Time time = new Time(); // Assuming Time is the class name [EOL] int expectedHours = 10; // Assuming getValue() would return 10 [EOL] int actualHours = time.getHours(); [EOL] assertEquals(expectedHours, actualHours); [EOL] }
public void testDividedByOne() { [EOL] Hours hours = Hours.hours(5); [EOL] Hours result = hours.dividedBy(1); [EOL] assertEquals(hours, result); [EOL] }
public void testDividedByPositiveDivisor() { [EOL] Hours hours = Hours.hours(10); [EOL] Hours result = hours.dividedBy(2); [EOL] assertEquals(Hours.hours(5), result); [EOL] }
public void testDividedByNegativeDivisor() { [EOL] Hours hours = Hours.hours(10); [EOL] Hours result = hours.dividedBy(-2); [EOL] assertEquals(Hours.hours(-5), result); [EOL] }
public void testDividedByZero() { [EOL] Hours hours = Hours.hours(10); [EOL] try { [EOL] hours.dividedBy(0); [EOL] fail("Should have thrown ArithmeticException due to division by zero"); [EOL] } catch (ArithmeticException e) { [EOL] } [EOL] }
void testCopyIntoWithValidArray() { [EOL] Converter[] sourceConverters = new Converter[] {new Converter(), new Converter()}; [EOL] DateTimeZoneBuilder builder = new DateTimeZoneBuilder(sourceConverters); [EOL] Converter[] destinationConverters = new Converter[sourceConverters.length]; [EOL] builder.copyInto(destinationConverters); [EOL] for (int i = 0; i < sourceConverters.length; i++) { [EOL] assertEquals(sourceConverters[i], destinationConverters[i]); [EOL] } [EOL] }
public void testAddWithEqualConverterAndNonNullRemoved() { [EOL] ConverterSet set = new ConverterSet(new Converter[]{converter1}); [EOL] Converter[] removed = new Converter[1]; [EOL] ConverterSet result = set.add(converter1, removed); [EOL] assertNull(removed[0]); [EOL] assertSame(set, result); [EOL] }
public void testAddWithEqualConverterAndNullRemoved() { [EOL] ConverterSet set = new ConverterSet(new Converter[]{converter1}); [EOL] ConverterSet result = set.add(converter1, null); [EOL] assertSame(set, result); [EOL] }
public void testAddWithSupportedTypeMatchAndNonNullRemoved() { [EOL] ConverterSet set = new ConverterSet(new Converter[]{converter1}); [EOL] Converter[] removed = new Converter[1]; [EOL] ConverterSet result = set.add(converter2, removed); [EOL] assertSame(converter1, removed[0]); [EOL] assertNotSame(set, result); [EOL] assertTrue(result.contains(converter2)); [EOL] assertFalse(result.contains(converter1)); [EOL] }
public void testAddWithSupportedTypeMatchAndNullRemoved() { [EOL] ConverterSet set = new ConverterSet(new Converter[]{converter1}); [EOL] ConverterSet result = set.add(converter2, null); [EOL] assertNotSame(set, result); [EOL] assertTrue(result.contains(converter2)); [EOL] assertFalse(result.contains(converter1)); [EOL] }
public void testAddWithNoMatchAndNonNullRemoved() { [EOL] ConverterSet set = new ConverterSet(new Converter[]{converter1}); [EOL] Converter[] removed = new Converter[1]; [EOL] ConverterSet result = set.add(converter3, removed); [EOL] assertNull(removed[0]); [EOL] assertNotSame(set, result); [EOL] assertTrue(result.contains(converter3)); [EOL] }
public void testAddWithNoMatchAndNullRemoved() { [EOL] ConverterSet set = new ConverterSet(new Converter[]{converter1}); [EOL] ConverterSet result = set.add(converter3, null); [EOL] assertNotSame(set, result); [EOL] assertTrue(result.contains(converter3)); [EOL] }
public void testRemove_ConverterNotFound() { [EOL] ConverterSet set = new ConverterSet(new Converter[]{converterA, converterB}); [EOL] Converter[] removed = new Converter[1]; [EOL] ConverterSet result = set.remove(converterC, removed); [EOL] assertNull("Converter should not be found and thus not removed", removed[0]); [EOL] assertSame("The original ConverterSet should be returned", set, result); [EOL] }
public void testRemove_ConverterFound() { [EOL] ConverterSet set = new ConverterSet(new Converter[]{converterA, converterB}); [EOL] Converter[] removed = new Converter[1]; [EOL] ConverterSet result = set.remove(converterA, removed); [EOL] assertNotNull("Converter should be found and thus removed", removed[0]); [EOL] assertNotSame("A new ConverterSet should be returned", set, result); [EOL] }
public void testRemove_ConverterFoundAtEnd() { [EOL] ConverterSet set = new ConverterSet(new Converter[]{converterA, converterB}); [EOL] Converter[] removed = new Converter[1]; [EOL] ConverterSet result = set.remove(converterB, removed); [EOL] assertNotNull("Converter should be found and thus removed", removed[0]); [EOL] assertNotSame("A new ConverterSet should be returned", set, result); [EOL] }
public void testRemove_NullRemovedArray() { [EOL] ConverterSet set = new ConverterSet(new Converter[]{converterA, converterB}); [EOL] ConverterSet result = set.remove(converterA, null); [EOL] assertNotSame("A new ConverterSet should be returned", set, result); [EOL] }
public void testDateTimeFormatterBuilder() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] assertNotNull("The builder's element pairs should not be null", builder.iElementPairs); [EOL] assertTrue("The builder's element pairs should be empty", builder.iElementPairs.isEmpty()); [EOL] }
public void testToFormatterWithPrinterAndParser() { [EOL] Object formatter = createMockedFormatterThatIsBothPrinterAndParser(); [EOL] setFormatter(formatter); [EOL] DateTimeFormatter result = toFormatter(); [EOL] assertNotNull("Expected a non-null DateTimeFormatter", result); [EOL] assertTrue("Expected the result to be a DateTimeFormatter with both printer and parser", [EOL] result.isPrinter() && result.isParser()); [EOL] } [EOL] public void testToFormatterWithOnlyPrinter() { [EOL] Object formatter = createMockedFormatterThatIsOnlyPrinter(); [EOL] setFormatter(formatter); [EOL] DateTimeFormatter result = toFormatter(); [EOL] assertNotNull("Expected a non-null DateTimeFormatter", result); [EOL] assertTrue("Expected the result to be a DateTimeFormatter with a printer only", [EOL] result.isPrinter() && !result.isParser()); [EOL] } [EOL] public void testToFormatterWithOnlyParser() { [EOL] Object formatter = createMockedFormatterThatIsOnlyParser(); [EOL] setFormatter(formatter); [EOL] DateTimeFormatter result = toFormatter(); [EOL] assertNotNull("Expected a non-null DateTimeFormatter", result); [EOL] assertTrue("Expected the result to be a DateTimeFormatter with a parser only", [EOL] !result.isPrinter() && result.isParser()); [EOL] } [EOL] public void testToFormatterWithNeitherPrinterNorParser() { [EOL] Object formatter = createMockedFormatterThatIsNeitherPrinterNorParser(); [EOL] setFormatter(formatter); [EOL] try { [EOL] toFormatter(); [EOL] fail("Expected UnsupportedOperationException to be thrown"); [EOL] } catch (UnsupportedOperationException e) { [EOL] } [EOL] }
public void testToPrinter_WithPrinter() { [EOL] DateTimeFormatter dtf = createFormatterWithPrinter(); [EOL] DateTimePrinter printer = dtf.toPrinter(); [EOL] assertNotNull(printer); [EOL] }
public void testToPrinter_WithoutPrinter() { [EOL] DateTimeFormatter dtf = createFormatterWithoutPrinter(); [EOL] try { [EOL] dtf.toPrinter(); [EOL] fail("Should have thrown UnsupportedOperationException"); [EOL] } catch (UnsupportedOperationException e) { [EOL] } [EOL] }
public boolean canBuildPrinter() { [EOL] return isPrinter(getFormatter()); [EOL] }
public void testAppendWithValidPrinter() { [EOL] DateTimePrinter printer = new FixedDateTimePrinter(); // Assuming FixedDateTimePrinter implements DateTimePrinter [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] DateTimeFormatterBuilder returnedBuilder = builder.append(printer); [EOL] assertNotNull(returnedBuilder); [EOL] assertSame(builder, returnedBuilder); [EOL] }
public void testAppendWithNullPrinter() { [EOL] DateTimePrinter printer = null; [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] try { [EOL] builder.append(printer); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testAppendWithNonNullPrinterAndSingleNonNullParser() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] DateTimePrinter printer = mock(DateTimePrinter.class); [EOL] DateTimeParser parser = mock(DateTimeParser.class); [EOL] DateTimeParser[] parsers = new DateTimeParser[]{parser}; [EOL] builder.append(printer, parsers); [EOL] }
public void testAppendWithNullPrinterAndSingleNonNullParser() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] DateTimeParser parser = mock(DateTimeParser.class); [EOL] DateTimeParser[] parsers = new DateTimeParser[]{parser}; [EOL] builder.append(null, parsers); [EOL] }
public void testAppendWithNonNullPrinterAndMultipleNonNullParsers() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] DateTimePrinter printer = mock(DateTimePrinter.class); [EOL] DateTimeParser parser1 = mock(DateTimeParser.class); [EOL] DateTimeParser parser2 = mock(DateTimeParser.class); [EOL] DateTimeParser[] parsers = new DateTimeParser[]{parser1, parser2}; [EOL] builder.append(printer, parsers); [EOL] }
public void testAppendWithNonNullPrinterAndMultipleParsersWithNull() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] DateTimePrinter printer = mock(DateTimePrinter.class); [EOL] DateTimeParser parser1 = mock(DateTimeParser.class); [EOL] DateTimeParser[] parsers = new DateTimeParser[]{parser1, null}; [EOL] try { [EOL] builder.append(printer, parsers); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testAppendWithNonNullPrinterAndNullParsersArray() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] DateTimePrinter printer = mock(DateTimePrinter.class); [EOL] try { [EOL] builder.append(printer, null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testAppendWithNonNullPrinterAndEmptyParsersArray() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] DateTimePrinter printer = mock(DateTimePrinter.class); [EOL] DateTimeParser[] parsers = new DateTimeParser[0]; [EOL] try { [EOL] builder.append(printer, parsers); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testAppendWithNonNullPrinterAndSingleNullParser() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] DateTimePrinter printer = mock(DateTimePrinter.class); [EOL] DateTimeParser[] parsers = new DateTimeParser[]{null}; [EOL] try { [EOL] builder.append(printer, parsers); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testAppend0WithNonNullElement() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] Object element = new Object(); [EOL] builder = builder.append0(element); [EOL] assertEquals("Expected element to be added twice to iElementPairs", 2, builder.iElementPairs.size()); [EOL] assertTrue("Expected iFormatter to be null", builder.iFormatter == null); [EOL] assertTrue("Expected both elements in iElementPairs to be the same", builder.iElementPairs.get(0) == element && builder.iElementPairs.get(1) == element); [EOL] }
public void testAppendLiteral() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] DateTimeFormatterBuilder returnedBuilder = builder.appendLiteral('a'); [EOL] assertNotNull(returnedBuilder); [EOL] assertSame(builder, returnedBuilder); [EOL] }
public void testAppendLiteralWithNull() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] try { [EOL] builder.appendLiteral(null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Literal must not be null", e.getMessage()); [EOL] } [EOL] }
public void testAppendLiteralWithEmptyString() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] DateTimeFormatterBuilder returnedBuilder = builder.appendLiteral(""); [EOL] assertSame(builder, returnedBuilder); [EOL] }
public void testAppendLiteralWithOneCharString() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] DateTimeFormatterBuilder returnedBuilder = builder.appendLiteral("a"); [EOL] assertNotNull(returnedBuilder); [EOL] }
public void testAppendLiteralWithLongString() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] DateTimeFormatterBuilder returnedBuilder = builder.appendLiteral("text"); [EOL] assertNotNull(returnedBuilder); [EOL] }
public void testAppendDecimal_ThrowsIllegalArgumentException_WhenFieldTypeIsNull() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] try { [EOL] builder.appendDecimal(null, 1, 2); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Field type must not be null", e.getMessage()); [EOL] } [EOL] }
public void testAppendDecimal_ThrowsIllegalArgumentException_WhenMinDigitsNegative() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] try { [EOL] builder.appendDecimal(DateTimeFieldType.year(), -1, 2); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testAppendDecimal_ThrowsIllegalArgumentException_WhenMaxDigitsLessThanMinDigits() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] try { [EOL] builder.appendDecimal(DateTimeFieldType.year(), 3, 2); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testAppendDecimal_ThrowsIllegalArgumentException_WhenMaxDigitsNonPositive() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] try { [EOL] builder.appendDecimal(DateTimeFieldType.year(), 1, 0); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testAppendDecimal_ReturnsUnpaddedNumber_WhenMinDigitsLessThanOrEqualToOne() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] DateTimeFormatterBuilder result = builder.appendDecimal(DateTimeFieldType.year(), 1, 2); [EOL] assertNotNull(result); [EOL] }
public void testAppendDecimal_ReturnsPaddedNumber_WhenMinDigitsGreaterThanOne() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] DateTimeFormatterBuilder result = builder.appendDecimal(DateTimeFieldType.year(), 2, 3); [EOL] assertNotNull(result); [EOL] }
public void testAppendSignedDecimal_ThrowsIllegalArgumentException_WhenFieldTypeIsNull() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] try { [EOL] builder.appendSignedDecimal(null, 1, 2); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testAppendSignedDecimal_ThrowsIllegalArgumentException_WhenMaxDigitsLessThanMinDigits() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] try { [EOL] builder.appendSignedDecimal(DateTimeFieldType.year(), 3, 2); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testAppendSignedDecimal_ThrowsIllegalArgumentException_WhenMinDigitsNegativeOrMaxDigitsNotPositive() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] try { [EOL] builder.appendSignedDecimal(DateTimeFieldType.year(), -1, 2); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] try { [EOL] builder.appendSignedDecimal(DateTimeFieldType.year(), 1, 0); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testAppendSignedDecimal_AppendsUnpaddedNumber_WhenMinDigitsLessThanOrEqualToOne() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] DateTimeFormatterBuilder result = builder.appendSignedDecimal(DateTimeFieldType.year(), 1, 2); [EOL] assertNotNull(result); [EOL] }
public void testAppendSignedDecimal_AppendsPaddedNumber_WhenMinDigitsGreaterThanOne() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] DateTimeFormatterBuilder result = builder.appendSignedDecimal(DateTimeFieldType.year(), 2, 3); [EOL] assertNotNull(result); [EOL] }
public void testAppendFraction_WithNullFieldType_ThrowsIllegalArgumentException() { [EOL] try { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] builder.appendFraction(null, 1, 2); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testAppendFraction_WithMaxDigitsLessThanMinDigits_AdjustsMaxDigits() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] DateTimeFieldType fieldType = DateTimeFieldType.secondOfMinute(); [EOL] int minDigits = 3; [EOL] int maxDigits = 2; [EOL] DateTimeFormatterBuilder result = builder.appendFraction(fieldType, minDigits, maxDigits); [EOL] assertNotNull(result); [EOL] }
public void testAppendFraction_WithInvalidMinDigits_ThrowsIllegalArgumentException() { [EOL] try { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] builder.appendFraction(DateTimeFieldType.secondOfMinute(), -1, 2); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testAppendFraction_WithInvalidMaxDigits_ThrowsIllegalArgumentException() { [EOL] try { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] builder.appendFraction(DateTimeFieldType.secondOfMinute(), 1, 0); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testAppendFraction_WithValidArguments_ReturnsNonNull() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] DateTimeFieldType fieldType = DateTimeFieldType.secondOfMinute(); [EOL] int minDigits = 1; [EOL] int maxDigits = 2; [EOL] DateTimeFormatterBuilder result = builder.appendFraction(fieldType, minDigits, maxDigits); [EOL] assertNotNull(result); [EOL] }
public void testAppendFractionOfSecond_MinMax() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] DateTimeFormatter formatter = builder.appendFractionOfSecond(1, 6).toFormatter(); [EOL] assertNotNull(formatter); [EOL] }
public void testAppendFractionOfSecond_MinGreaterThanMax() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] try { [EOL] builder.appendFractionOfSecond(4, 2); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testAppendFractionOfSecond_NegativeMinDigits() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] try { [EOL] builder.appendFractionOfSecond(-1, 6); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testAppendFractionOfSecond_NegativeMaxDigits() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] try { [EOL] builder.appendFractionOfSecond(1, -1); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testAppendFractionOfMinute_MinDigitsLessThanZero() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] try { [EOL] builder.appendFractionOfMinute(-1, 2); [EOL] fail("Should have thrown IllegalArgumentException for minDigits < 0"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testAppendFractionOfMinute_MaxDigitsLessThanMinDigits() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] try { [EOL] builder.appendFractionOfMinute(3, 2); [EOL] fail("Should have thrown IllegalArgumentException for maxDigits < minDigits"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testAppendFractionOfMinute_ValidRange() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] try { [EOL] builder.appendFractionOfMinute(1, 2); [EOL] } catch (IllegalArgumentException e) { [EOL] fail("Should not have thrown IllegalArgumentException for valid minDigits and maxDigits"); [EOL] } [EOL] }
public void testAppendFractionOfHour_MinDigitsLessThanZero() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] try { [EOL] builder.appendFractionOfHour(-1, 2); [EOL] fail("Should have thrown IllegalArgumentException for minDigits < 0"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testAppendFractionOfHour_MaxDigitsLessThanMinDigits() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] try { [EOL] builder.appendFractionOfHour(3, 2); [EOL] fail("Should have thrown IllegalArgumentException for maxDigits < minDigits"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testAppendFractionOfHour_ValidRange() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] try { [EOL] builder.appendFractionOfHour(1, 2); [EOL] } catch (IllegalArgumentException e) { [EOL] fail("Should not have thrown IllegalArgumentException for valid minDigits and maxDigits"); [EOL] } [EOL] }
public void testAppendMillisOfSecond_MinDigitsLessThanThree() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] DateTimeFormatterBuilder result = builder.appendMillisOfSecond(2); [EOL] assertNotNull(result); [EOL] }
public void testAppendMillisOfSecond_MinDigitsThree() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] DateTimeFormatterBuilder result = builder.appendMillisOfSecond(3); [EOL] assertNotNull(result); [EOL] }
public void testAppendMinuteOfHour_MinDigitsLessThanMinimum() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] try { [EOL] builder.appendMinuteOfHour(0); [EOL] fail("Should have thrown IllegalArgumentException for minDigits < 1"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testAppendMinuteOfHour_MinDigitsWithinRange() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] DateTimeFormatterBuilder returnedBuilder = builder.appendMinuteOfHour(1); [EOL] assertNotNull("Returned builder should not be null", returnedBuilder); [EOL] assertSame("Returned builder should be the same as the original builder", builder, returnedBuilder); [EOL] }
public void testAppendMinuteOfHour_MinDigitsExceedsMaximum() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] DateTimeFormatterBuilder returnedBuilder = builder.appendMinuteOfHour(3); [EOL] assertNotNull("Returned builder should not be null", returnedBuilder); [EOL] assertSame("Returned builder should be the same as the original builder", builder, returnedBuilder); [EOL] }
public void testAppendHourOfDay_MinDigitsLessThanOne() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] try { [EOL] builder.appendHourOfDay(0); [EOL] fail("Should have thrown IllegalArgumentException for minDigits less than 1"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testAppendHourOfDay_ValidMinDigits() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] builder.appendHourOfDay(1); [EOL] }
public void testAppendHourOfDay_MinDigitsGreaterThanTwo() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] builder.appendHourOfDay(3); [EOL] }
public void testAppendDayOfMonth_MinDigitsLessThanOne() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] try { [EOL] builder.appendDayOfMonth(0); [EOL] fail("Should have thrown IllegalArgumentException for minDigits < 1"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testAppendDayOfMonth_ValidMinDigits() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] DateTimeFormatterBuilder returnedBuilder = builder.appendDayOfMonth(1); [EOL] assertNotNull("Returned builder should not be null", returnedBuilder); [EOL] assertSame("Returned builder should be the same as the original builder", builder, returnedBuilder); [EOL] }
public void testAppendDayOfYear_MinDigitsLessThanOne() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] try { [EOL] builder.appendDayOfYear(0); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testAppendDayOfYear_ValidMinDigits() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] DateTimeFormatterBuilder returnedBuilder = builder.appendDayOfYear(1); [EOL] assertNotNull("Returned builder should not be null", returnedBuilder); [EOL] assertSame("Returned builder should be the same as the original builder", builder, returnedBuilder); [EOL] }
public void testAppendDayOfYear_MaxMinDigits() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] DateTimeFormatterBuilder returnedBuilder = builder.appendDayOfYear(3); [EOL] assertNotNull("Returned builder should not be null", returnedBuilder); [EOL] assertSame("Returned builder should be the same as the original builder", builder, returnedBuilder); [EOL] }
public void testAppendWeekOfWeekyear_MinDigitsLessThanOne() { [EOL] try { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] builder.appendWeekOfWeekyear(0); [EOL] fail("Should have thrown IllegalArgumentException for minDigits < 1"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testAppendWeekOfWeekyear_ValidMinDigits() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] DateTimeFormatterBuilder returnedBuilder = builder.appendWeekOfWeekyear(1); [EOL] assertNotNull("Returned builder should not be null", returnedBuilder); [EOL] }
public void testAppendWeekyear_MinMaxDigits() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] DateTimeFormatter formatter = builder.appendWeekyear(2, 4).toFormatter(); [EOL] assertNotNull(formatter); [EOL] }
public void testAppendWeekyear_SameMinMaxDigits() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] DateTimeFormatter formatter = builder.appendWeekyear(3, 3).toFormatter(); [EOL] assertNotNull(formatter); [EOL] }
public void testAppendMonthOfYear_MinDigitsLessThanOne() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] try { [EOL] builder.appendMonthOfYear(0); [EOL] fail("Should have thrown IllegalArgumentException for minDigits < 1"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testAppendMonthOfYear_MinDigitsOne() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] DateTimeFormatterBuilder result = builder.appendMonthOfYear(1); [EOL] assertNotNull("Resulting DateTimeFormatterBuilder should not be null", result); [EOL] }
public void testAppendMonthOfYear_MinDigitsTwo() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] DateTimeFormatterBuilder result = builder.appendMonthOfYear(2); [EOL] assertNotNull("Resulting DateTimeFormatterBuilder should not be null", result); [EOL] }
public void testAppendYear_MinMaxDigits() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] DateTimeFormatter formatter = builder.appendYear(2, 4).toFormatter(); [EOL] assertNotNull(formatter); [EOL] }
public void testAppendYear_MinDigitsLessThanZero() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] try { [EOL] builder.appendYear(-1, 4); [EOL] fail("Should have thrown IllegalArgumentException because minDigits is less than zero"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testAppendYear_MaxDigitsLessThanMinDigits() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] try { [EOL] builder.appendYear(3, 2); [EOL] fail("Should have thrown IllegalArgumentException because maxDigits is less than minDigits"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testAppendDayOfWeekShortText() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] DateTimeFormatterBuilder result = builder.appendDayOfWeekShortText(); [EOL] assertNotNull(result); [EOL] assertEquals(DateTimeFieldType.dayOfWeek(), result.getFieldTypeAtIndex(0)); [EOL] }
public void testAppendTimeZoneOffset_WithValidParameters() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] String zeroOffsetText = "GMT"; [EOL] boolean showSeparators = true; [EOL] int minFields = 2; [EOL] int maxFields = 4; [EOL] DateTimeFormatterBuilder result = builder.appendTimeZoneOffset(zeroOffsetText, showSeparators, minFields, maxFields); [EOL] assertNotNull(result); [EOL] }
public void testAppendTimeZoneOffset_WithNullZeroOffsetText() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] String zeroOffsetText = null; [EOL] boolean showSeparators = true; [EOL] int minFields = 2; [EOL] int maxFields = 4; [EOL] try { [EOL] builder.appendTimeZoneOffset(zeroOffsetText, showSeparators, minFields, maxFields); [EOL] fail("Should have thrown IllegalArgumentException for null zeroOffsetText"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testAppendTimeZoneOffset_WithMinFieldsGreaterThanMaxFields() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] String zeroOffsetText = "GMT"; [EOL] boolean showSeparators = true; [EOL] int minFields = 5; [EOL] int maxFields = 4; [EOL] try { [EOL] builder.appendTimeZoneOffset(zeroOffsetText, showSeparators, minFields, maxFields); [EOL] fail("Should have thrown IllegalArgumentException for minFields > maxFields"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testAppendPatternWithValidPattern() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] String pattern = "yyyy-MM-dd"; [EOL] DateTimeFormatterBuilder returnedBuilder = builder.appendPattern(pattern); [EOL] assertNotNull(returnedBuilder); [EOL] assertSame(builder, returnedBuilder); [EOL] }
public void testAppendPatternWithNullPattern() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] String pattern = null; [EOL] try { [EOL] builder.appendPattern(pattern); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testGetFormatterWhenFormatterIsNullAndElementPairsSizeIsTwoAndPrinterIsNotNullAndPrinterEqualsParser() { [EOL] iFormatter = null; [EOL] Object printerParser = new Object(); [EOL] iElementPairs.add(printerParser); [EOL] iElementPairs.add(printerParser); [EOL] Object result = getFormatter(); [EOL] assertSame(printerParser, result); [EOL] }
public void testGetFormatterWhenFormatterIsNullAndElementPairsSizeIsTwoAndPrinterIsNotNullAndParserIsNull() { [EOL] iFormatter = null; [EOL] Object printer = new Object(); [EOL] iElementPairs.add(printer); [EOL] iElementPairs.add(null); [EOL] Object result = getFormatter(); [EOL] assertSame(printer, result); [EOL] }
public void testGetFormatterWhenFormatterIsNullAndElementPairsSizeIsTwoAndPrinterIsNull() { [EOL] iFormatter = null; [EOL] Object parser = new Object(); [EOL] iElementPairs.add(null); [EOL] iElementPairs.add(parser); [EOL] Object result = getFormatter(); [EOL] assertSame(parser, result); [EOL] }
public void testGetFormatterWhenFormatterIsNullAndElementPairsSizeIsNotTwo() { [EOL] iFormatter = null; [EOL] iElementPairs.add(new Object()); [EOL] iElementPairs.add(new Object()); [EOL] iElementPairs.add(new Object()); // Adding a third element to make the size not equal to 2 [EOL] Object result = getFormatter(); [EOL] assertTrue(result instanceof Composite); [EOL] }
public void testGetFormatterWhenFormatterIsNotNull() { [EOL] Object formatter = new Object(); [EOL] iFormatter = formatter; [EOL] Object result = getFormatter(); [EOL] assertSame(formatter, result); [EOL] }
public void testIsPrinterWithDateTimePrinter() { [EOL] DateTimePrinter printer = new DateTimePrinterImpl(); // Assuming DateTimePrinterImpl is a concrete implementation [EOL] boolean result = isPrinter(printer); [EOL] assertTrue(result); [EOL] } [EOL] public void testIsPrinterWithCompositeThatIsPrinter() { [EOL] Composite composite = new CompositeThatIsPrinter(); // Assuming CompositeThatIsPrinter is a concrete implementation that returns true for isPrinter() [EOL] boolean result = isPrinter(composite); [EOL] assertTrue(result); [EOL] } [EOL] public void testIsPrinterWithCompositeThatIsNotPrinter() { [EOL] Composite composite = new CompositeThatIsNotPrinter(); // Assuming CompositeThatIsNotPrinter is a concrete implementation that returns false for isPrinter() [EOL] boolean result = isPrinter(composite); [EOL] assertFalse(result); [EOL] } [EOL] public void testIsPrinterWithNonPrinterObject() { [EOL] Object nonPrinter = new Object(); [EOL] boolean result = isPrinter(nonPrinter); [EOL] assertFalse(result); [EOL] }

public void testIsParserWithDateTimeParser() { [EOL] DateTimeParser dateTimeParser = new DateTimeParserImpl(); // Assuming DateTimeParserImpl is a concrete implementation [EOL] boolean result = isParser(dateTimeParser); [EOL] assertTrue(result); [EOL] } [EOL] public void testIsParserWithCompositeAndIsParserTrue() { [EOL] Composite composite = mock(Composite.class); // Assuming you can use mocking frameworks like Mockito [EOL] when(composite.isParser()).thenReturn(true); [EOL] boolean result = isParser(composite); [EOL] assertTrue(result); [EOL] } [EOL] public void testIsParserWithCompositeAndIsParserFalse() { [EOL] Composite composite = mock(Composite.class); [EOL] when(composite.isParser()).thenReturn(false); [EOL] boolean result = isParser(composite); [EOL] assertFalse(result); [EOL] } [EOL] public void testIsParserWithNonParserObject() { [EOL] Object nonParserObject = new Object(); [EOL] boolean result = isParser(nonParserObject); [EOL] assertFalse(result); [EOL] }
public void testAppendUnknownStringWithPositiveLength() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] int len = 5; [EOL] appendUnknownString(buf, len); [EOL] assertEquals("\ufffd\ufffd\ufffd\ufffd\ufffd", buf.toString()); [EOL] }
public void testAppendUnknownStringWithZeroLength() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] int len = 0; [EOL] appendUnknownString(buf, len); [EOL] assertEquals("", buf.toString()); [EOL] }
public void testAppendUnknownStringWithNegativeLength() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] int len = -1; [EOL] appendUnknownString(buf, len); [EOL] assertEquals("", buf.toString()); [EOL] }
public void testCharacterLiteralWithRegularChar() { [EOL] char testValue = 'a'; [EOL] CharacterLiteral characterLiteral = new CharacterLiteral(testValue); [EOL] assertEquals(testValue, characterLiteral.iValue); [EOL] }
public void testCharacterLiteralWithSpecialChar() { [EOL] char testValue = '\n'; [EOL] CharacterLiteral characterLiteral = new CharacterLiteral(testValue); [EOL] assertEquals(testValue, characterLiteral.iValue); [EOL] }
public void testCharacterLiteralWithNumericChar() { [EOL] char testValue = '1'; [EOL] CharacterLiteral characterLiteral = new CharacterLiteral(testValue); [EOL] assertEquals(testValue, characterLiteral.iValue); [EOL] }
public void testCharacterLiteralWithUnicodeChar() { [EOL] char testValue = '\u1234'; [EOL] CharacterLiteral characterLiteral = new CharacterLiteral(testValue); [EOL] assertEquals(testValue, characterLiteral.iValue); [EOL] }
public int estimatePrintedLength() { [EOL] return 1; [EOL] }
public int estimateParsedLength() { [EOL] return 1; [EOL] }
public void testParseInto_PositionGreaterThanOrEqualToTextLength() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, 0, 0); [EOL] String text = "Test"; [EOL] int position = 4; [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals(~position, result); [EOL] } [EOL] public void testParseInto_FirstCharacterMismatch() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, 0, 'X'); [EOL] String text = "Test"; [EOL] int position = 0; [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals(~position, result); [EOL] } [EOL] public void testParseInto_FirstCharacterMatch() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, 0, 'T'); [EOL] String text = "Test"; [EOL] int position = 0; [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals(position + 1, result); [EOL] } [EOL] public void testParseInto_FirstCharacterMismatchButUpperCaseMatch() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, 0, 't'); [EOL] String text = "Test"; [EOL] int position = 0; [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals(position + 1, result); [EOL] } [EOL] public void testParseInto_FirstCharacterMismatchButLowerCaseMatch() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, 0, 'T'); [EOL] String text = "test"; [EOL] int position = 0; [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals(position + 1, result); [EOL] }
public void testStringLiteralWithNonNullValue() { [EOL] String expectedValue = "testValue"; [EOL] StringLiteral literal = new StringLiteral(expectedValue); [EOL] assertEquals(expectedValue, literal.iValue); [EOL] }
public void testStringLiteralWithNullValue() { [EOL] String expectedValue = null; [EOL] StringLiteral literal = new StringLiteral(expectedValue); [EOL] assertNull(literal.iValue); [EOL] }
public void testEstimatePrintedLength_EmptyString() { [EOL] Time time = new Time(""); [EOL] int estimatedLength = time.estimatePrintedLength(); [EOL] assertEquals(0, estimatedLength); [EOL] }
public void testEstimatePrintedLength_NonEmptyString() { [EOL] Time time = new Time("10:00"); [EOL] int estimatedLength = time.estimatePrintedLength(); [EOL] assertEquals(5, estimatedLength); [EOL] }
public void testEstimateParsedLength_EmptyString() { [EOL] Time time = new Time(""); [EOL] int estimatedLength = time.estimateParsedLength(); [EOL] assertEquals(0, estimatedLength); [EOL] }
public void testEstimateParsedLength_NonEmptyString() { [EOL] Time time = new Time("10:00"); [EOL] int estimatedLength = time.estimateParsedLength(); [EOL] assertEquals(5, estimatedLength); [EOL] }
public void testParseInto_MatchAtPosition() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, 0, 0); [EOL] String text = "expectedValue"; [EOL] int position = 0; [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals("Should match at position 0", position + "expectedValue".length(), result); [EOL] }
public void testParseInto_NoMatchAtPosition() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, 0, 0); [EOL] String text = "unexpectedValue"; [EOL] int position = 0; [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals("Should not match at position 0", ~position, result); [EOL] }
public void testParseInto_MatchNotAtStartPosition() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, 0, 0); [EOL] String text = "randomexpectedValue"; [EOL] int position = 6; [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals("Should match at position 6", position + "expectedValue".length(), result); [EOL] }
public void testParseInto_CaseInsensitiveMatch() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, 0, 0); [EOL] String text = "EXPECTEDvalue"; [EOL] int position = 0; [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals("Should match case insensitive", position + "expectedValue".length(), result); [EOL] }
public void testNumberFormatterWithValidFieldType() { [EOL] DateTimeFieldType fieldType = DateTimeFieldType.hourOfDay(); [EOL] int maxParsedDigits = 4; [EOL] boolean signed = true; [EOL] NumberFormatter formatter = new NumberFormatter(fieldType, maxParsedDigits, signed); [EOL] assertNotNull(formatter); [EOL] assertEquals(fieldType, formatter.getFieldType()); [EOL] assertEquals(maxParsedDigits, formatter.getMaxParsedDigits()); [EOL] assertEquals(signed, formatter.isSigned()); [EOL] }
public void testNumberFormatterWithNullFieldType() { [EOL] int maxParsedDigits = 4; [EOL] boolean signed = true; [EOL] try { [EOL] new NumberFormatter(null, maxParsedDigits, signed); [EOL] fail("Should have thrown IllegalArgumentException for null fieldType"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testNumberFormatterWithNegativeMaxParsedDigits() { [EOL] DateTimeFieldType fieldType = DateTimeFieldType.hourOfDay(); [EOL] int maxParsedDigits = -1; [EOL] boolean signed = true; [EOL] try { [EOL] new NumberFormatter(fieldType, maxParsedDigits, signed); [EOL] fail("Should have thrown IllegalArgumentException for negative maxParsedDigits"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testEstimateParsedLength() { [EOL] Time time = new Time(); // Assuming 'Time' is the class where 'estimateParsedLength' is defined. [EOL] int expected = 0; // Replace with the expected value of 'iMaxParsedDigits'. [EOL] int actual = time.estimateParsedLength(); [EOL] assertEquals(expected, actual); [EOL] }
public void testParseInto_PositiveNumber() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(); [EOL] String text = "12345"; [EOL] int position = 0; [EOL] int iMaxParsedDigits = 10; [EOL] boolean iSigned = false; [EOL] int iFieldType = 0; [EOL] int result = parseInto(bucket, text, position, iMaxParsedDigits, iSigned, iFieldType); [EOL] assertEquals(5, result); [EOL] assertEquals(12345, bucket.getFieldValue(iFieldType)); [EOL] } [EOL] public void testParseInto_NegativeNumber() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(); [EOL] String text = "-123"; [EOL] int position = 0; [EOL] int iMaxParsedDigits = 10; [EOL] boolean iSigned = true; [EOL] int iFieldType = 0; [EOL] int result = parseInto(bucket, text, position, iMaxParsedDigits, iSigned, iFieldType); [EOL] assertEquals(4, result); [EOL] assertEquals(-123, bucket.getFieldValue(iFieldType)); [EOL] } [EOL] public void testParseInto_InvalidPosition() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(); [EOL] String text = "12345"; [EOL] int position = 6; [EOL] int iMaxParsedDigits = 10; [EOL] boolean iSigned = false; [EOL] int iFieldType = 0; [EOL] int result = parseInto(bucket, text, position, iMaxParsedDigits, iSigned, iFieldType); [EOL] assertEquals(~position, result); [EOL] } [EOL] public void testParseInto_InvalidCharacter() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(); [EOL] String text = "12a45"; [EOL] int position = 0; [EOL] int iMaxParsedDigits = 10; [EOL] boolean iSigned = false; [EOL] int iFieldType = 0; [EOL] int result = parseInto(bucket, text, position, iMaxParsedDigits, iSigned, iFieldType); [EOL] assertEquals(~position, result); [EOL] } [EOL] public void testParseInto_SignedWithInvalidCharacter() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(); [EOL] String text = "+-123"; [EOL] int position = 0; [EOL] int iMaxParsedDigits = 10; [EOL] boolean iSigned = true; [EOL] int iFieldType = 0; [EOL] int result = parseInto(bucket, text, position, iMaxParsedDigits, iSigned, iFieldType); [EOL] assertEquals(~position, result); [EOL] } [EOL] public void testParseInto_LongNumber() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(); [EOL] String text = "1234567890"; [EOL] int position = 0; [EOL] int iMaxParsedDigits = 10; [EOL] boolean iSigned = false; [EOL] int iFieldType = 0; [EOL] int result = parseInto(bucket, text, position, iMaxParsedDigits, iSigned, iFieldType); [EOL] assertEquals(10, result); [EOL] assertEquals(1234567890, bucket.getFieldValue(iFieldType)); [EOL] } [EOL] public void testParseInto_SignedLongNumber() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(); [EOL] String text = "-1234567890"; [EOL] int position = 0; [EOL] int iMaxParsedDigits = 10; [EOL] boolean iSigned = true; [EOL] int iFieldType = 0; [EOL] int result = parseInto(bucket, text, position, iMaxParsedDigits, iSigned, iFieldType); [EOL] assertEquals(11, result); [EOL] assertEquals(-1234567890, bucket.getFieldValue(iFieldType)); [EOL] } [EOL] public void testParseInto_EmptyString() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(); [EOL] String text = ""; [EOL] int position = 0; [EOL] int iMaxParsedDigits = 10; [EOL] boolean iSigned = false; [EOL] int iFieldType = 0; [EOL] int result = parseInto(bucket, text, position, iMaxParsedDigits, iSigned, iFieldType); [EOL] assertEquals(~position, result); [EOL] } [EOL] public void testParseInto_StringIndexOutOfBoundsException() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(); [EOL] String text = "1"; [EOL] int position = 0; [EOL] int iMaxParsedDigits = 10; [EOL] boolean iSigned = false; [EOL] int iFieldType = 0; [EOL] int result = parseInto(bucket, text, position, iMaxParsedDigits, iSigned, iFieldType); [EOL] assertEquals(1, result); [EOL] assertEquals(1, bucket.getFieldValue(iFieldType)); [EOL] }
public void testPaddedNumberConstructor() { [EOL] DateTimeFieldType fieldType = DateTimeFieldType.hourOfDay(); [EOL] int maxParsedDigits = 4; [EOL] boolean signed = true; [EOL] int minPrintedDigits = 2; [EOL] PaddedNumber pn = new PaddedNumber(fieldType, maxParsedDigits, signed, minPrintedDigits); [EOL] assertNotNull(pn); [EOL] assertEquals(fieldType, pn.getType()); [EOL] assertEquals(maxParsedDigits, pn.getMaxParsedDigits()); [EOL] assertEquals(signed, pn.isSigned()); [EOL] assertEquals(minPrintedDigits, pn.getMinPrintedDigits()); [EOL] }
public void testEstimatePrintedLength() { [EOL] TimeFormatter formatter = new TimeFormatter(5); [EOL] int estimatedLength = formatter.estimatePrintedLength(); [EOL] assertEquals(5, estimatedLength); [EOL] }
public void testPrintToWithValidInput() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] long instant = System.currentTimeMillis(); [EOL] Chronology chrono = ISOChronology.getInstanceUTC(); [EOL] int displayOffset = 0; [EOL] DateTimeZone displayZone = DateTimeZone.UTC; [EOL] Locale locale = Locale.US; [EOL] printTo(buf, instant, chrono, displayOffset, displayZone, locale); [EOL] assertFalse(buf.length() == 0); [EOL] } [EOL] public void testPrintToWithException() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] long instant = System.currentTimeMillis(); [EOL] Chronology chrono = null; // Assuming this will cause a RuntimeException [EOL] int displayOffset = 0; [EOL] DateTimeZone displayZone = DateTimeZone.UTC; [EOL] Locale locale = Locale.US; [EOL] printTo(buf, instant, chrono, displayOffset, displayZone, locale); [EOL] assertTrue(buf.toString().contains("Unknown")); [EOL] }
public void testPrintTo_SupportedFieldType() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] ReadablePartial mockPartial = Mockito.mock(ReadablePartial.class); [EOL] Locale locale = Locale.ENGLISH; [EOL] when(mockPartial.isSupported(iFieldType)).thenReturn(true); [EOL] when(mockPartial.get(iFieldType)).thenReturn(123); [EOL] printTo(buf, mockPartial, locale); [EOL] assertTrue(buf.toString().contains("123")); [EOL] } [EOL] public void testPrintTo_UnsupportedFieldType() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] ReadablePartial mockPartial = Mockito.mock(ReadablePartial.class); [EOL] Locale locale = Locale.ENGLISH; [EOL] when(mockPartial.isSupported(iFieldType)).thenReturn(false); [EOL] printTo(buf, mockPartial, locale); [EOL] assertTrue(buf.toString().contains("Unknown")); // Assuming appendUnknownString appends "Unknown" [EOL] } [EOL] public void testPrintTo_SupportedFieldType_ThrowsException() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] ReadablePartial mockPartial = Mockito.mock(ReadablePartial.class); [EOL] Locale locale = Locale.ENGLISH; [EOL] when(mockPartial.isSupported(iFieldType)).thenReturn(true); [EOL] when(mockPartial.get(iFieldType)).thenThrow(new RuntimeException()); [EOL] printTo(buf, mockPartial, locale); [EOL] assertTrue(buf.toString().contains("Unknown")); // Assuming appendUnknownString appends "Unknown" [EOL] }
public void testPrintWithShortText() { [EOL] long instant = System.currentTimeMillis(); [EOL] Chronology chrono = ISOChronology.getInstance(); [EOL] Locale locale = Locale.ENGLISH; [EOL] DateTimeFieldType fieldType = DateTimeFieldType.dayOfWeek(); [EOL] DateTimeField field = fieldType.getField(chrono); [EOL] boolean iShort = true; [EOL] String result = print(instant, chrono, locale, field, iShort); [EOL] String expected = field.getAsShortText(instant, locale); [EOL] assertEquals(expected, result); [EOL] }
public void testPrintWithLongText() { [EOL] long instant = System.currentTimeMillis(); [EOL] Chronology chrono = ISOChronology.getInstance(); [EOL] Locale locale = Locale.ENGLISH; [EOL] DateTimeFieldType fieldType = DateTimeFieldType.dayOfWeek(); [EOL] DateTimeField field = fieldType.getField(chrono); [EOL] boolean iShort = false; [EOL] String result = print(instant, chrono, locale, field, iShort); [EOL] String expected = field.getAsText(instant, locale); [EOL] assertEquals(expected, result); [EOL] }
public void testPrint_SupportedFieldTypeShort() { [EOL] ReadablePartial mockPartial = mock(ReadablePartial.class); [EOL] when(mockPartial.isSupported(iFieldType)).thenReturn(true); [EOL] DateTimeField mockField = mock(DateTimeField.class); [EOL] when(iFieldType.getField(mockPartial.getChronology())).thenReturn(mockField); [EOL] when(mockField.getAsShortText(mockPartial, Locale.ENGLISH)).thenReturn("ShortText"); [EOL] iShort = true; [EOL] String result = print(mockPartial, Locale.ENGLISH); [EOL] assertEquals("ShortText", result); [EOL] }
public void testPrint_SupportedFieldTypeLong() { [EOL] ReadablePartial mockPartial = mock(ReadablePartial.class); [EOL] when(mockPartial.isSupported(iFieldType)).thenReturn(true); [EOL] DateTimeField mockField = mock(DateTimeField.class); [EOL] when(iFieldType.getField(mockPartial.getChronology())).thenReturn(mockField); [EOL] when(mockField.getAsText(mockPartial, Locale.ENGLISH)).thenReturn("LongText"); [EOL] iShort = false; [EOL] String result = print(mockPartial, Locale.ENGLISH); [EOL] assertEquals("LongText", result); [EOL] }
public void testPrint_UnsupportedFieldType() { [EOL] ReadablePartial mockPartial = mock(ReadablePartial.class); [EOL] when(mockPartial.isSupported(iFieldType)).thenReturn(false); [EOL] String result = print(mockPartial, Locale.ENGLISH); [EOL] assertEquals("\ufffd", result); [EOL] }
public void testFractionWithMaxDigitsGreaterThan18() { [EOL] DateTimeFieldType fieldType = DateTimeFieldType.secondOfMinute(); [EOL] int minDigits = 1; [EOL] int maxDigits = 19; // Any value greater than 18 [EOL] Fraction fraction = new Fraction(fieldType, minDigits, maxDigits); [EOL] assertEquals(18, fraction.iMaxDigits); [EOL] }
public void testFractionWithMaxDigitsLessThanOrEqualTo18() { [EOL] DateTimeFieldType fieldType = DateTimeFieldType.secondOfMinute(); [EOL] int minDigits = 1; [EOL] int maxDigits = 18; // Any value less than or equal to 18 [EOL] Fraction fraction = new Fraction(fieldType, minDigits, maxDigits); [EOL] assertEquals(maxDigits, fraction.iMaxDigits); [EOL] }
public void testEstimatePrintedLength() { [EOL] Time time = new Time(); [EOL] int expected = time.iMaxDigits; [EOL] int actual = time.estimatePrintedLength(); [EOL] assertEquals(expected, actual); [EOL] }
public int estimateParsedLength() { [EOL] return iMaxDigits; [EOL] }
public void testTimeZoneOffset_ValidArguments() { [EOL] String zeroOffsetPrintText = "Z"; [EOL] String zeroOffsetParseText = "+00:00"; [EOL] boolean showSeparators = true; [EOL] int minFields = 2; [EOL] int maxFields = 3; [EOL] TimeZoneOffset tzo = new TimeZoneOffset(zeroOffsetPrintText, zeroOffsetParseText, showSeparators, minFields, maxFields); [EOL] assertNotNull(tzo); [EOL] }
public void testTimeZoneOffset_MinFieldsGreaterThanMaxFields_ThrowsException() { [EOL] try { [EOL] new TimeZoneOffset("Z", "+00:00", true, 3, 2); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testTimeZoneOffset_MinFieldsLessThanOne_ThrowsException() { [EOL] try { [EOL] new TimeZoneOffset("Z", "+00:00", true, 0, 2); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testTimeZoneOffset_MaxFieldsAdjusted() { [EOL] TimeZoneOffset tzo = new TimeZoneOffset("Z", "+00:00", true, 5, 6); [EOL] assertNotNull(tzo); [EOL] }
public void testEstimatePrintedLength_MinFieldsNoSeparatorsNoOffsetText() { [EOL] int estimatedLength = estimatePrintedLength(); [EOL] assertEquals(5, estimatedLength); // 1 + (2 << 1) = 5 [EOL] }
public void testEstimatePrintedLength_MinFieldsWithSeparatorsNoOffsetText() { [EOL] int estimatedLength = estimatePrintedLength(); [EOL] assertEquals(6, estimatedLength); // 1 + (2 << 1) + (2 - 1) = 6 [EOL] }
public void testEstimatePrintedLength_MinFieldsNoSeparatorsWithLongOffsetText() { [EOL] int estimatedLength = estimatePrintedLength(); [EOL] assertEquals(8, estimatedLength); // "LongText".length() = 8 [EOL] }
public void testEstimatePrintedLength_MinFieldsWithSeparatorsWithLongOffsetText() { [EOL] int estimatedLength = estimatePrintedLength(); [EOL] assertEquals(8, estimatedLength); // "LongText".length() = 8 [EOL] }
public void testEstimatePrintedLength_MinFieldsNoSeparatorsWithShortOffsetText() { [EOL] int estimatedLength = estimatePrintedLength(); [EOL] assertEquals(5, estimatedLength); // 1 + (2 << 1) = 5 since "Text".length() < 5 [EOL] }
public void testEstimatePrintedLength_MinFieldsWithSeparatorsWithShortOffsetText() { [EOL] int estimatedLength = estimatePrintedLength(); [EOL] assertEquals(6, estimatedLength); // 1 + (2 << 1) + (2 - 1) = 6 since "Text".length() < 6 [EOL] }
public void testPrintToWithNullDisplayZone() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] long instant = 0L; [EOL] Chronology chrono = null; [EOL] int displayOffset = 0; [EOL] DateTimeZone displayZone = null; [EOL] Locale locale = null; [EOL] printTo(buf, instant, chrono, displayOffset, displayZone, locale); [EOL] assertEquals("", buf.toString()); [EOL] }
public void testPrintToWithZeroOffsetAndSpecialText() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] long instant = 0L; [EOL] Chronology chrono = null; [EOL] int displayOffset = 0; [EOL] DateTimeZone displayZone = DateTimeZone.UTC; [EOL] Locale locale = null; [EOL] iZeroOffsetPrintText = "GMT"; [EOL] printTo(buf, instant, chrono, displayOffset, displayZone, locale); [EOL] assertEquals("GMT", buf.toString()); [EOL] }
public void testPrintToWithPositiveOffset() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] long instant = 0L; [EOL] Chronology chrono = null; [EOL] int displayOffset = DateTimeConstants.MILLIS_PER_HOUR; [EOL] DateTimeZone displayZone = DateTimeZone.forOffsetHours(1); [EOL] Locale locale = null; [EOL] iMaxFields = 2; [EOL] iMinFields = 0; [EOL] iShowSeparators = true; [EOL] printTo(buf, instant, chrono, displayOffset, displayZone, locale); [EOL] assertEquals("+01:00", buf.toString()); [EOL] }
public void testPrintToWithNegativeOffset() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] long instant = 0L; [EOL] Chronology chrono = null; [EOL] int displayOffset = -DateTimeConstants.MILLIS_PER_HOUR; [EOL] DateTimeZone displayZone = DateTimeZone.forOffsetHours(-1); [EOL] Locale locale = null; [EOL] iMaxFields = 2; [EOL] iMinFields = 0; [EOL] iShowSeparators = true; [EOL] printTo(buf, instant, chrono, displayOffset, displayZone, locale); [EOL] assertEquals("-01:00", buf.toString()); [EOL] }
public void testPrintToWithMaxFields() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] long instant = 0L; [EOL] Chronology chrono = null; [EOL] int displayOffset = DateTimeConstants.MILLIS_PER_HOUR + DateTimeConstants.MILLIS_PER_MINUTE; [EOL] DateTimeZone displayZone = DateTimeZone.forOffsetMillis(displayOffset); [EOL] Locale locale = null; [EOL] iMaxFields = 1; [EOL] iMinFields = 0; [EOL] iShowSeparators = false; [EOL] printTo(buf, instant, chrono, displayOffset, displayZone, locale); [EOL] assertEquals("+01", buf.toString()); [EOL] }
public void testPrintToWithMinFields() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] long instant = 0L; [EOL] Chronology chrono = null; [EOL] int displayOffset = DateTimeConstants.MILLIS_PER_HOUR + DateTimeConstants.MILLIS_PER_MINUTE; [EOL] DateTimeZone displayZone = DateTimeZone.forOffsetMillis(displayOffset); [EOL] Locale locale = null; [EOL] iMaxFields = 3; [EOL] iMinFields = 2; [EOL] iShowSeparators = false; [EOL] printTo(buf, instant, chrono, displayOffset, displayZone, locale); [EOL] assertEquals("+0100", buf.toString()); [EOL] }
public void testPrintToWithShowSeparators() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] long instant = 0L; [EOL] Chronology chrono = null; [EOL] int displayOffset = DateTimeConstants.MILLIS_PER_HOUR + DateTimeConstants.MILLIS_PER_MINUTE + DateTimeConstants.MILLIS_PER_SECOND; [EOL] DateTimeZone displayZone = DateTimeZone.forOffsetMillis(displayOffset); [EOL] Locale locale = null; [EOL] iMaxFields = 4; [EOL] iMinFields = 0; [EOL] iShowSeparators = true; [EOL] printTo(buf, instant, chrono, displayOffset, displayZone, locale); [EOL] assertEquals("+01:01:01.000", buf.toString()); [EOL] }
public int estimateParsedLength() { [EOL] return estimatePrintedLength(); [EOL] }
public void testParseInto_ZeroOffsetTextEmptyAndLimitGreaterThanZeroWithPlusSign() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, 0, 0); [EOL] String text = "+"; [EOL] int position = 0; [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals("Expected position to be unchanged for '+' with empty zero offset text", 0, result); [EOL] assertEquals("Expected offset to be set to zero", Integer.valueOf(0), bucket.getOffset()); [EOL] } [EOL] public void testParseInto_ZeroOffsetTextEmptyAndLimitGreaterThanZeroWithMinusSign() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, 0, 0); [EOL] String text = "-"; [EOL] int position = 0; [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals("Expected position to be unchanged for '-' with empty zero offset text", 0, result); [EOL] assertEquals("Expected offset to be set to zero", Integer.valueOf(0), bucket.getOffset()); [EOL] } [EOL] public void testParseInto_ZeroOffsetTextEmptyAndLimitZero() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, 0, 0); [EOL] String text = ""; [EOL] int position = 0; [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals("Expected position to be negated for empty text", ~0, result); [EOL] } [EOL] public void testParseInto_ZeroOffsetTextMatches() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, 0, 0); [EOL] String text = "Z"; [EOL] int position = 0; [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals("Expected position to be incremented by length of zero offset text", 1, result); [EOL] assertEquals("Expected offset to be set to zero", Integer.valueOf(0), bucket.getOffset()); [EOL] } [EOL] public void testParseInto_LimitLessThanOrEqualToOne() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, 0, 0); [EOL] String text = "+"; [EOL] int position = 0; [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals("Expected position to be negated for text with length less than or equal to 1", ~0, result); [EOL] } [EOL] public void testParseInto_InvalidFirstCharacter() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, 0, 0); [EOL] String text = "A"; [EOL] int position = 0; [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals("Expected position to be negated for invalid first character", ~0, result); [EOL] } [EOL] public void testParseInto_HoursGreaterThan23() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, 0, 0); [EOL] String text = "+24"; [EOL] int position = 0; [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals("Expected position to be negated for hours greater than 23", ~0, result); [EOL] } [EOL] public void testParseInto_ExpectSeparatorsWithInvalidSeparator() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, 0, 0); [EOL] String text = "+01A"; [EOL] int position = 0; [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals("Expected position to be negated for invalid separator after hours", ~0, result); [EOL] } [EOL] public void testParseInto_MinutesGreaterThan59() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, 0, 0); [EOL] String text = "+0160"; [EOL] int position = 0; [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals("Expected position to be negated for minutes greater than 59", ~0, result); [EOL] } [EOL] public void testParseInto_ExpectSeparatorsWithInvalidSecondSeparator() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, 0, 0); [EOL] String text = "+01:60A"; [EOL] int position = 0; [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals("Expected position to be negated for invalid separator after minutes", ~0, result); [EOL] } [EOL] public void testParseInto_SecondsGreaterThan59() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, 0, 0); [EOL] String text = "+01:0060"; [EOL] int position = 0; [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals("Expected position to be negated for seconds greater than 59", ~0, result); [EOL] } [EOL] public void testParseInto_ExpectSeparatorsWithInvalidMillisecondSeparator() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, 0, 0); [EOL] String text = "+01:00:60A"; [EOL] int position = 0; [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals("Expected position to be negated for invalid separator before milliseconds", ~0, result); [EOL] } [EOL] public void testParseInto_MillisecondsSingleDigit() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, 0, 0); [EOL] String text = "+01:00:00.1"; [EOL] int position = 0; [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals("Expected position to be incremented correctly for single millisecond digit", 11, result); [EOL] } [EOL] public void testParseInto_MillisecondsTwoDigits() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, 0, 0); [EOL] String text = "+01:00:00.12"; [EOL] int position = 0; [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals("Expected position to be incremented correctly for two millisecond digits", 12, result); [EOL] } [EOL] public void testParseInto_MillisecondsThreeDigits() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, 0, 0); [EOL] String text = "+01:00:00.123"; [EOL] int position = 0; [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals("Expected position to be incremented correctly for three millisecond digits", 13, result); [EOL] }
public void testDigitCountWithEmptyString() { [EOL] int result = digitCount("", 0, 5); [EOL] assertEquals(0, result); [EOL] } [EOL] public void testDigitCountWithAllDigits() { [EOL] int result = digitCount("12345", 0, 5); [EOL] assertEquals(5, result); [EOL] } [EOL] public void testDigitCountWithAllDigitsAndPositionOffset() { [EOL] int result = digitCount("12345", 2, 3); [EOL] assertEquals(3, result); [EOL] } [EOL] public void testDigitCountWithNonDigits() { [EOL] int result = digitCount("abcde", 0, 5); [EOL] assertEquals(0, result); [EOL] } [EOL] public void testDigitCountWithDigitsAndNonDigits() { [EOL] int result = digitCount("12ab34", 0, 6); [EOL] assertEquals(2, result); [EOL] } [EOL] public void testDigitCountWithDigitsAndNonDigitsAndPositionOffset() { [EOL] int result = digitCount("12ab34", 2, 4); [EOL] assertEquals(0, result); [EOL] } [EOL] public void testDigitCountWithAmountGreaterThanStringLength() { [EOL] int result = digitCount("123", 0, 5); [EOL] assertEquals(3, result); [EOL] } [EOL] public void testDigitCountWithPositionAndAmountCausingIndexOutOfBounds() { [EOL] int result = digitCount("123", 2, 5); [EOL] assertEquals(1, result); [EOL] } [EOL] public void testDigitCountWithNegativePosition() { [EOL] int result = digitCount("12345", -1, 5); [EOL] assertEquals(5, result); [EOL] } [EOL] public void testDigitCountWithNegativeAmount() { [EOL] int result = digitCount("12345", 0, -1); [EOL] assertEquals(0, result); [EOL] }
public void testCompositeWithEmptyLists() { [EOL] List<Object> elementPairs = new ArrayList<>(); [EOL] Composite(null); // Assuming Composite is the constructor or a method [EOL] assertNull(iPrinters); [EOL] assertEquals(0, iPrintedLengthEstimate); [EOL] assertNull(iParsers); [EOL] assertEquals(0, iParsedLengthEstimate); [EOL] }
public void testCompositeWithNonNullPrintersAndParsers() { [EOL] List<Object> elementPairs = new ArrayList<>(); [EOL] DateTimePrinter printer = mock(DateTimePrinter.class); [EOL] DateTimeParser parser = mock(DateTimeParser.class); [EOL] when(printer.estimatePrintedLength()).thenReturn(10); [EOL] when(parser.estimateParsedLength()).thenReturn(20); [EOL] elementPairs.add(printer); [EOL] elementPairs.add(parser); [EOL] Composite(elementPairs); [EOL] assertNotNull(iPrinters); [EOL] assertEquals(10, iPrintedLengthEstimate); [EOL] assertNotNull(iParsers); [EOL] assertEquals(20, iParsedLengthEstimate); [EOL] }
public void testCompositeWithNullPrinter() { [EOL] List<Object> elementPairs = new ArrayList<>(); [EOL] elementPairs.add(null); [EOL] DateTimeParser parser = mock(DateTimeParser.class); [EOL] when(parser.estimateParsedLength()).thenReturn(20); [EOL] elementPairs.add(parser); [EOL] Composite(elementPairs); [EOL] assertNull(iPrinters); [EOL] assertEquals(0, iPrintedLengthEstimate); [EOL] assertNotNull(iParsers); [EOL] assertEquals(20, iParsedLengthEstimate); [EOL] }
public void testCompositeWithNullParser() { [EOL] List<Object> elementPairs = new ArrayList<>(); [EOL] DateTimePrinter printer = mock(DateTimePrinter.class); [EOL] when(printer.estimatePrintedLength()).thenReturn(10); [EOL] elementPairs.add(printer); [EOL] elementPairs.add(null); [EOL] Composite(elementPairs); [EOL] assertNotNull(iPrinters); [EOL] assertEquals(10, iPrintedLengthEstimate); [EOL] assertNull(iParsers); [EOL] assertEquals(0, iParsedLengthEstimate); [EOL] }
public void testEstimatePrintedLength() { [EOL] Time time = new Time(); // Assuming there is a constructor available [EOL] int expected = 0; // Replace with the expected value based on the object's state [EOL] int actual = time.estimatePrintedLength(); [EOL] assertEquals(expected, actual); [EOL] }
public void testPrintToWithNullElements() { [EOL] try { [EOL] DateTimeFormatter formatter = new DateTimeFormatter(null, null); [EOL] formatter.printTo(new StringBuffer(), 0L, null, 0, null, null); [EOL] fail("Should have thrown UnsupportedOperationException"); [EOL] } catch (UnsupportedOperationException e) { [EOL] } [EOL] }
public void testPrintToWithNonNullElementsAndNullLocale() { [EOL] DateTimePrinter[] printers = new DateTimePrinter[] { /* mock printers */ }; [EOL] DateTimeFormatter formatter = new DateTimeFormatter(printers, null); [EOL] StringBuffer buf = new StringBuffer(); [EOL] formatter.printTo(buf, 0L, null, 0, null, null); [EOL] assertNotNull("Buffer should not be null", buf.toString()); [EOL] assertFalse("Buffer should not be empty", buf.length() == 0); [EOL] }
public void testPrintToWithAllParameters() { [EOL] DateTimePrinter[] printers = new DateTimePrinter[] { /* mock printers */ }; [EOL] DateTimeFormatter formatter = new DateTimeFormatter(printers, null); [EOL] StringBuffer buf = new StringBuffer(); [EOL] Locale locale = new Locale("en"); [EOL] formatter.printTo(buf, 0L, null, 0, null, locale); [EOL] assertNotNull("Buffer should not be null", buf.toString()); [EOL] assertFalse("Buffer should not be empty", buf.length() == 0); [EOL] }
public void testParseInto_WithNullElements_ThrowsUnsupportedOperationException() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, null); [EOL] String text = "test"; [EOL] int position = 0; [EOL] try { [EOL] parseInto(bucket, text, position); [EOL] fail("Should have thrown UnsupportedOperationException"); [EOL] } catch (UnsupportedOperationException e) { [EOL] } [EOL] }
public void testParseInto_WithEmptyElements_ReturnsInitialPosition() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, null); [EOL] String text = "test"; [EOL] int position = 0; [EOL] iParsers = new DateTimeParser[0]; [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals("Expected initial position to be returned", position, result); [EOL] }
public void testParseInto_WithValidElements_ParsesSuccessfully() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, null); [EOL] String text = "test"; [EOL] int position = 0; [EOL] DateTimeParser parser1 = mock(DateTimeParser.class); [EOL] DateTimeParser parser2 = mock(DateTimeParser.class); [EOL] when(parser1.parseInto(any(DateTimeParserBucket.class), anyString(), anyInt())).thenReturn(1); [EOL] when(parser2.parseInto(any(DateTimeParserBucket.class), anyString(), anyInt())).thenReturn(2); [EOL] iParsers = new DateTimeParser[] { parser1, parser2 }; [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals("Expected final position to be updated by parsers", 2, result); [EOL] }
public void testParseInto_WithParserReturningNegative_ParsesUntilNegative() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, null); [EOL] String text = "test"; [EOL] int position = 0; [EOL] DateTimeParser parser1 = mock(DateTimeParser.class); [EOL] DateTimeParser parser2 = mock(DateTimeParser.class); [EOL] when(parser1.parseInto(any(DateTimeParserBucket.class), anyString(), anyInt())).thenReturn(1); [EOL] when(parser2.parseInto(any(DateTimeParserBucket.class), anyString(), anyInt())).thenReturn(-1); [EOL] iParsers = new DateTimeParser[] { parser1, parser2 }; [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals("Expected position to be negative after parser2", -1, result); [EOL] }
public void testIsPrinterWhenIPrintersIsNull() { [EOL] Time time = new Time(); [EOL] time.iPrinters = null; [EOL] assertFalse(time.isPrinter()); [EOL] }
public void testIsPrinterWhenIPrintersIsNotNull() { [EOL] Time time = new Time(); [EOL] time.iPrinters = new Object(); // Assuming iPrinters is of type Object [EOL] assertTrue(time.isPrinter()); [EOL] }
public void testIsParserWhenParsersIsNull() { [EOL] Time time = new Time(); [EOL] time.iParsers = null; [EOL] assertFalse(time.isParser()); [EOL] }
public void testIsParserWhenParsersIsNotNull() { [EOL] Time time = new Time(); [EOL] time.iParsers = new Parser[] {}; // Assuming Parser is a class and iParsers is an array of Parser [EOL] assertTrue(time.isParser()); [EOL] }
public void testDecomposeWithEmptyList() { [EOL] List<Object> elementPairs = new ArrayList<>(); [EOL] List<Object> printerList = new ArrayList<>(); [EOL] List<Object> parserList = new ArrayList<>(); [EOL] decompose(elementPairs, printerList, parserList); [EOL] assertTrue(printerList.isEmpty()); [EOL] assertTrue(parserList.isEmpty()); [EOL] }
public void testDecomposeWithNonCompositeElements() { [EOL] List<Object> elementPairs = Arrays.asList("Printer1", "Parser1", "Printer2", "Parser2"); [EOL] List<Object> printerList = new ArrayList<>(); [EOL] List<Object> parserList = new ArrayList<>(); [EOL] decompose(elementPairs, printerList, parserList); [EOL] assertEquals(Arrays.asList("Printer1", "Printer2"), printerList); [EOL] assertEquals(Arrays.asList("Parser1", "Parser2"), parserList); [EOL] }
public void testDecomposeWithCompositeElements() { [EOL] Composite compositePrinter = new Composite(); [EOL] compositePrinter.iPrinters = new Object[]{"CompositePrinter"}; [EOL] Composite compositeParser = new Composite(); [EOL] compositeParser.iParsers = new Object[]{"CompositeParser"}; [EOL] List<Object> elementPairs = Arrays.asList(compositePrinter, compositeParser); [EOL] List<Object> printerList = new ArrayList<>(); [EOL] List<Object> parserList = new ArrayList<>(); [EOL] decompose(elementPairs, printerList, parserList); [EOL] assertEquals(Arrays.asList("CompositePrinter"), printerList); [EOL] assertEquals(Arrays.asList("CompositeParser"), parserList); [EOL] }
public void testDecomposeWithMixedElements() { [EOL] Composite compositePrinter = new Composite(); [EOL] compositePrinter.iPrinters = new Object[]{"CompositePrinter"}; [EOL] Composite compositeParser = new Composite(); [EOL] compositeParser.iParsers = new Object[]{"CompositeParser"}; [EOL] List<Object> elementPairs = Arrays.asList("Printer", compositePrinter, compositeParser, "Parser"); [EOL] List<Object> printerList = new ArrayList<>(); [EOL] List<Object> parserList = new ArrayList<>(); [EOL] decompose(elementPairs, printerList, parserList); [EOL] assertEquals(Arrays.asList("Printer", "CompositePrinter"), printerList); [EOL] assertEquals(Arrays.asList("CompositeParser", "Parser"), parserList); [EOL] }
public void testAddArrayToListWithNonNullArray() { [EOL] List<Object> list = new ArrayList<>(); [EOL] Object[] array = {1, 2, 3}; [EOL] addArrayToList(list, array); [EOL] assertEquals(3, list.size()); [EOL] assertEquals(1, list.get(0)); [EOL] assertEquals(2, list.get(1)); [EOL] assertEquals(3, list.get(2)); [EOL] }
public void testAddArrayToListWithNullArray() { [EOL] List<Object> list = new ArrayList<>(); [EOL] addArrayToList(list, null); [EOL] assertTrue(list.isEmpty()); [EOL] }
public void testFromCalendarFields_withNullCalendar() { [EOL] try { [EOL] TimeOfDay.fromCalendarFields(null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("The calendar must not be null", ex.getMessage()); [EOL] } [EOL] }
public void testFromCalendarFields_withValidCalendar() { [EOL] Calendar calendar = Calendar.getInstance(); [EOL] calendar.set(Calendar.HOUR_OF_DAY, 10); [EOL] calendar.set(Calendar.MINUTE, 20); [EOL] calendar.set(Calendar.SECOND, 30); [EOL] calendar.set(Calendar.MILLISECOND, 40); [EOL] TimeOfDay result = TimeOfDay.fromCalendarFields(calendar); [EOL] assertNotNull(result); [EOL] assertEquals(10, result.getHourOfDay()); [EOL] assertEquals(20, result.getMinuteOfHour()); [EOL] assertEquals(30, result.getSecondOfMinute()); [EOL] assertEquals(40, result.getMillisOfSecond()); [EOL] }
public void testTimeOfDayWithDateTimeZone() { [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/London"); [EOL] TimeOfDay timeOfDay = new TimeOfDay(zone); [EOL] assertNotNull(timeOfDay); [EOL] } [EOL] public void testTimeOfDayWithChronology() { [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] TimeOfDay timeOfDay = new TimeOfDay(chronology); [EOL] assertNotNull(timeOfDay); [EOL] } [EOL] public void testTimeOfDayWithLong() { [EOL] long instant = System.currentTimeMillis(); [EOL] TimeOfDay timeOfDay = new TimeOfDay(instant); [EOL] assertNotNull(timeOfDay); [EOL] } [EOL] public void testTimeOfDayWithLongAndChronology() { [EOL] long instant = System.currentTimeMillis(); [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] TimeOfDay timeOfDay = new TimeOfDay(instant, chronology); [EOL] assertNotNull(timeOfDay); [EOL] } [EOL] public void testTimeOfDayWithObject() { [EOL] Object instant = new Date(); [EOL] TimeOfDay timeOfDay = new TimeOfDay(instant); [EOL] assertNotNull(timeOfDay); [EOL] } [EOL] public void testTimeOfDayWithObjectAndChronology() { [EOL] Object instant = new Date(); [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] TimeOfDay timeOfDay = new TimeOfDay(instant, chronology); [EOL] assertNotNull(timeOfDay); [EOL] } [EOL] public void testTimeOfDayWithHourAndMinute() { [EOL] int hourOfDay = 13; [EOL] int minuteOfHour = 30; [EOL] TimeOfDay timeOfDay = new TimeOfDay(hourOfDay, minuteOfHour); [EOL] assertEquals(hourOfDay, timeOfDay.getHourOfDay()); [EOL] assertEquals(minuteOfHour, timeOfDay.getMinuteOfHour()); [EOL] } [EOL] public void testTimeOfDayWithHourMinuteAndChronology() { [EOL] int hourOfDay = 13; [EOL] int minuteOfHour = 30; [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] TimeOfDay timeOfDay = new TimeOfDay(hourOfDay, minuteOfHour, chronology); [EOL] assertEquals(hourOfDay, timeOfDay.getHourOfDay()); [EOL] assertEquals(minuteOfHour, timeOfDay.getMinuteOfHour()); [EOL] } [EOL] public void testTimeOfDayWithHourMinuteSecond() { [EOL] int hourOfDay = 13; [EOL] int minuteOfHour = 30; [EOL] int secondOfMinute = 15; [EOL] TimeOfDay timeOfDay = new TimeOfDay(hourOfDay, minuteOfHour, secondOfMinute); [EOL] assertEquals(hourOfDay, timeOfDay.getHourOfDay()); [EOL] assertEquals(minuteOfHour, timeOfDay.getMinuteOfHour()); [EOL] assertEquals(secondOfMinute, timeOfDay.getSecondOfMinute()); [EOL] } [EOL] public void testTimeOfDayWithHourMinuteSecondAndChronology() { [EOL] int hourOfDay = 13; [EOL] int minuteOfHour = 30; [EOL] int secondOfMinute = 15; [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] TimeOfDay timeOfDay = new TimeOfDay(hourOfDay, minuteOfHour, secondOfMinute, chronology); [EOL] assertEquals(hourOfDay, timeOfDay.getHourOfDay()); [EOL] assertEquals(minuteOfHour, timeOfDay.getMinuteOfHour()); [EOL] assertEquals(secondOfMinute, timeOfDay.getSecondOfMinute()); [EOL] } [EOL] public void testTimeOfDayWithHourMinuteSecondMillis() { [EOL] int hourOfDay = 13; [EOL] int minuteOfHour = 30; [EOL] int secondOfMinute = 15; [EOL] int millisOfSecond = 200; [EOL] TimeOfDay timeOfDay = new TimeOfDay(hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL] assertEquals(hourOfDay, timeOfDay.getHourOfDay()); [EOL] assertEquals(minuteOfHour, timeOfDay.getMinuteOfHour()); [EOL] assertEquals(secondOfMinute, timeOfDay.getSecondOfMinute()); [EOL] assertEquals(millisOfSecond, timeOfDay.getMillisOfSecond()); [EOL] } [EOL] public void testTimeOfDayWithHourMinuteSecondMillisAndChronology() { [EOL] int hourOfDay = 13; [EOL] int minuteOfHour = 30; [EOL] int secondOfMinute = 15; [EOL] int millisOfSecond = 200; [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] TimeOfDay timeOfDay = new TimeOfDay(hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond, chronology); [EOL] assertEquals(hourOfDay, timeOfDay.getHourOfDay()); [EOL] assertEquals(minuteOfHour, timeOfDay.getMinuteOfHour()); [EOL] assertEquals(secondOfMinute, timeOfDay.getSecondOfMinute()); [EOL] assertEquals(millisOfSecond, timeOfDay.getMillisOfSecond()); [EOL] }
public void testTimeOfDayWithInstantAndChronology() { [EOL] Object instant = new Instant(); [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] TimeOfDay timeOfDay = new TimeOfDay(instant, chronology); [EOL] assertNotNull(timeOfDay); [EOL] }
public void testTimeOfDayDefaultConstructor() { [EOL] TimeOfDay timeOfDay = new TimeOfDay(); [EOL] assertNotNull(timeOfDay); [EOL] }
public void testTimeOfDayWithZone() { [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/London"); [EOL] TimeOfDay timeOfDay = new TimeOfDay(zone); [EOL] assertNotNull(timeOfDay); [EOL] }
public void testTimeOfDayWithChronology() { [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] TimeOfDay timeOfDay = new TimeOfDay(chronology); [EOL] assertNotNull(timeOfDay); [EOL] }
public void testTimeOfDayWithInstant() { [EOL] long instant = System.currentTimeMillis(); [EOL] TimeOfDay timeOfDay = new TimeOfDay(instant); [EOL] assertNotNull(timeOfDay); [EOL] }
public void testTimeOfDayWithInstantAndChronology2() { [EOL] long instant = System.currentTimeMillis(); [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] TimeOfDay timeOfDay = new TimeOfDay(instant, chronology); [EOL] assertNotNull(timeOfDay); [EOL] }
public void testTimeOfDayWithObjectInstant() { [EOL] Object instant = new Instant(); [EOL] TimeOfDay timeOfDay = new TimeOfDay(instant); [EOL] assertNotNull(timeOfDay); [EOL] }
public void testTimeOfDayWithHourAndMinute() { [EOL] int hourOfDay = 13; [EOL] int minuteOfHour = 30; [EOL] TimeOfDay timeOfDay = new TimeOfDay(hourOfDay, minuteOfHour); [EOL] assertNotNull(timeOfDay); [EOL] }
public void testTimeOfDayWithHourMinuteAndChronology() { [EOL] int hourOfDay = 13; [EOL] int minuteOfHour = 30; [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] TimeOfDay timeOfDay = new TimeOfDay(hourOfDay, minuteOfHour, chronology); [EOL] assertNotNull(timeOfDay); [EOL] }
public void testTimeOfDayWithHourMinuteSecond() { [EOL] int hourOfDay = 13; [EOL] int minuteOfHour = 30; [EOL] int secondOfMinute = 45; [EOL] TimeOfDay timeOfDay = new TimeOfDay(hourOfDay, minuteOfHour, secondOfMinute); [EOL] assertNotNull(timeOfDay); [EOL] }
public void testTimeOfDayWithHourMinuteSecondAndChronology() { [EOL] int hourOfDay = 13; [EOL] int minuteOfHour = 30; [EOL] int secondOfMinute = 45; [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] TimeOfDay timeOfDay = new TimeOfDay(hourOfDay, minuteOfHour, secondOfMinute, chronology); [EOL] assertNotNull(timeOfDay); [EOL] }
public void testTimeOfDayWithHourMinuteSecondMillis() { [EOL] int hourOfDay = 13; [EOL] int minuteOfHour = 30; [EOL] int secondOfMinute = 45; [EOL] int millisOfSecond = 500; [EOL] TimeOfDay timeOfDay = new TimeOfDay(hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL] assertNotNull(timeOfDay); [EOL] }
public void testTimeOfDayWithHourMinuteSecondMillisAndChronology() { [EOL] int hourOfDay = 13; [EOL] int minuteOfHour = 30; [EOL] int secondOfMinute = 45; [EOL] int millisOfSecond = 500; [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] TimeOfDay timeOfDay = new TimeOfDay(hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond, chronology); [EOL] assertNotNull(timeOfDay); [EOL] }
public void testTimeOfDayWithPartialAndValues() { [EOL] TimeOfDay partial = new TimeOfDay(13, 30, 45, 500); [EOL] int[] values = new int[] {14, 40, 50, 600}; [EOL] TimeOfDay timeOfDay = new TimeOfDay(partial, values); [EOL] assertNotNull(timeOfDay); [EOL] }
public void testTimeOfDayWithPartialAndChronology() { [EOL] TimeOfDay partial = new TimeOfDay(13, 30, 45, 500); [EOL] Chronology chrono = ISOChronology.getInstance(); [EOL] TimeOfDay timeOfDay = new TimeOfDay(partial, chrono); [EOL] assertNotNull(timeOfDay); [EOL] }
public void testTimeOfDayFromCalendarFields() { [EOL] Calendar calendar = Calendar.getInstance(); [EOL] TimeOfDay timeOfDay = TimeOfDay.fromCalendarFields(calendar); [EOL] assertNotNull(timeOfDay); [EOL] }
public void testTimeOfDayFromDateFields() { [EOL] Date date = new Date(); [EOL] TimeOfDay timeOfDay = TimeOfDay.fromDateFields(date); [EOL] assertNotNull(timeOfDay); [EOL] }
public void testTimeOfDayFromMillisOfDay() { [EOL] long millisOfDay = System.currentTimeMillis() % DateTimeConstants.MILLIS_PER_DAY; [EOL] TimeOfDay timeOfDay = TimeOfDay.fromMillisOfDay(millisOfDay); [EOL] assertNotNull(timeOfDay); [EOL] }
public void testTimeOfDayFromMillisOfDayWithChronology() { [EOL] long millisOfDay = System.currentTimeMillis() % DateTimeConstants.MILLIS_PER_DAY; [EOL] Chronology chrono = ISOChronology.getInstance(); [EOL] TimeOfDay timeOfDay = TimeOfDay.fromMillisOfDay(millisOfDay, chrono); [EOL] assertNotNull(timeOfDay); [EOL] }
public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology) { [EOL] this(hourOfDay, minuteOfHour, 0, 0, chronology); [EOL] } [EOL] public TimeOfDay(); [EOL] public TimeOfDay(DateTimeZone zone); [EOL] public TimeOfDay(Chronology chronology); [EOL] public TimeOfDay(long instant); [EOL] public TimeOfDay(long instant, Chronology chronology); [EOL] public TimeOfDay(Object instant); [EOL] public TimeOfDay(Object instant, Chronology chronology); [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour); [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology); [EOL] TimeOfDay(TimeOfDay partial, int[] values); [EOL] TimeOfDay(TimeOfDay partial, Chronology chrono); [EOL] Property(TimeOfDay partial, int fieldIndex); [EOL] public static TimeOfDay fromCalendarFields(Calendar calendar); [EOL] public static TimeOfDay fromDateFields(Date date); [EOL] public static TimeOfDay fromMillisOfDay(long millisOfDay); [EOL] public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); [EOL] public int size(); [EOL] protected DateTimeField getField(int index, Chronology chrono); [EOL] public DateTimeFieldType getFieldType(int index); [EOL] public DateTimeFieldType[] getFieldTypes(); [EOL] public TimeOfDay withChronologyRetainFields(Chronology newChronology); [EOL] public TimeOfDay withField(DateTimeFieldType fieldType, int value); [EOL] public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); [EOL] public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); [EOL] public TimeOfDay plus(ReadablePeriod period); [EOL] public TimeOfDay plusHours(int hours); [EOL] public TimeOfDay plusMinutes(int minutes); [EOL] public TimeOfDay plusSeconds(int seconds); [EOL] public TimeOfDay plusMillis(int millis); [EOL] public TimeOfDay minus(ReadablePeriod period); [EOL] public TimeOfDay minusHours(int hours); [EOL] public TimeOfDay minusMinutes(int minutes); [EOL] public TimeOfDay minusSeconds(int seconds); [EOL] public TimeOfDay minusMillis(int millis); [EOL] public Property property(DateTimeFieldType type); [EOL] public LocalTime toLocalTime(); [EOL] public DateTime toDateTimeToday(); [EOL] public DateTime toDateTimeToday(DateTimeZone zone); [EOL] public int getHourOfDay(); [EOL] public int getMinuteOfHour(); [EOL] public int getSecondOfMinute(); [EOL] public int getMillisOfSecond(); [EOL] public TimeOfDay withHourOfDay(int hour); [EOL] public TimeOfDay withMinuteOfHour(int minute); [EOL] public TimeOfDay withSecondOfMinute(int second); [EOL] public TimeOfDay withMillisOfSecond(int millis); [EOL] public Property hourOfDay(); [EOL] public Property minuteOfHour(); [EOL] public Property secondOfMinute(); [EOL] public Property millisOfSecond(); [EOL] public String toString(); [EOL] public DateTimeField getField(); [EOL] protected ReadablePartial getReadablePartial(); [EOL] public TimeOfDay getTimeOfDay(); [EOL] public int get(); [EOL] public TimeOfDay addToCopy(int valueToAdd); [EOL] public TimeOfDay addNoWrapToCopy(int valueToAdd); [EOL] public TimeOfDay addWrapFieldToCopy(int valueToAdd); [EOL] public TimeOfDay setCopy(int value); [EOL] public TimeOfDay setCopy(String text, Locale locale); [EOL] public TimeOfDay setCopy(String text); [EOL] public TimeOfDay withMaximumValue(); [EOL] public TimeOfDay withMinimumValue(); [EOL] long serialVersionUID=3633353405803318660L; [EOL] DateTimeFieldType[] FIELD_TYPES=new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() };
public void testGetFieldType_ValidIndex() { [EOL] TimeOfDay timeOfDay = new TimeOfDay(); [EOL] assertEquals(DateTimeFieldType.hourOfDay(), timeOfDay.getFieldType(0)); [EOL] assertEquals(DateTimeFieldType.minuteOfHour(), timeOfDay.getFieldType(1)); [EOL] assertEquals(DateTimeFieldType.secondOfMinute(), timeOfDay.getFieldType(2)); [EOL] assertEquals(DateTimeFieldType.millisOfSecond(), timeOfDay.getFieldType(3)); [EOL] } [EOL] public void testGetFieldType_InvalidIndex() { [EOL] TimeOfDay timeOfDay = new TimeOfDay(); [EOL] try { [EOL] timeOfDay.getFieldType(-1); [EOL] fail("Should have thrown ArrayIndexOutOfBoundsException"); [EOL] } catch (ArrayIndexOutOfBoundsException e) { [EOL] } [EOL] try { [EOL] timeOfDay.getFieldType(4); [EOL] fail("Should have thrown ArrayIndexOutOfBoundsException"); [EOL] } catch (ArrayIndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testWithChronologyRetainFields_SameChronology() { [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] TimeOfDay time = new TimeOfDay(chronology); [EOL] TimeOfDay result = time.withChronologyRetainFields(chronology); [EOL] assertSame("Should be the same object as the chronology is the same", time, result); [EOL] }
public void testWithChronologyRetainFields_DifferentChronology() { [EOL] Chronology initialChronology = ISOChronology.getInstance(); [EOL] Chronology newChronology = GregorianChronology.getInstance(); [EOL] TimeOfDay time = new TimeOfDay(initialChronology); [EOL] TimeOfDay result = time.withChronologyRetainFields(newChronology); [EOL] assertNotSame("Should not be the same object as the chronology is different", time, result); [EOL] assertEquals("New TimeOfDay should have the new chronology", newChronology, result.getChronology()); [EOL] }
public TimeOfDay withField(DateTimeFieldType fieldType, int value) { [EOL] int index = indexOfSupported(fieldType); [EOL] if (value == getValue(index)) { [EOL] return this; [EOL] } [EOL] int[] newValues = getValues(); [EOL] newValues = getField(index).set(this, index, newValues, value); [EOL] return new TimeOfDay(this, newValues); [EOL] }
public void testPlus_withPeriod() { [EOL] TimeOfDay time = new TimeOfDay(10, 20, 30, 400); [EOL] ReadablePeriod period = new Period(1, 2, 3, 4); [EOL] TimeOfDay result = time.plus(period); [EOL] assertEquals(new TimeOfDay(11, 22, 33, 404), result); [EOL] }
public void testPlus_withNullPeriod() { [EOL] TimeOfDay time = new TimeOfDay(10, 20, 30, 400); [EOL] TimeOfDay result = time.plus(null); [EOL] assertEquals(time, result); [EOL] }
public void testPlusHours_Normal() { [EOL] TimeOfDay time = new TimeOfDay(10, 0); // 10:00 AM [EOL] TimeOfDay newTime = time.plusHours(2); [EOL] assertEquals(12, newTime.getHourOfDay()); [EOL] assertEquals(0, newTime.getMinuteOfHour()); [EOL] } [EOL] public void testPlusHours_Negative() { [EOL] TimeOfDay time = new TimeOfDay(10, 0); // 10:00 AM [EOL] TimeOfDay newTime = time.plusHours(-3); [EOL] assertEquals(7, newTime.getHourOfDay()); [EOL] assertEquals(0, newTime.getMinuteOfHour()); [EOL] } [EOL] public void testPlusHours_Overflow() { [EOL] TimeOfDay time = new TimeOfDay(23, 0); // 11:00 PM [EOL] TimeOfDay newTime = time.plusHours(2); [EOL] assertEquals(1, newTime.getHourOfDay()); [EOL] assertEquals(0, newTime.getMinuteOfHour()); [EOL] } [EOL] public void testPlusHours_Underflow() { [EOL] TimeOfDay time = new TimeOfDay(0, 0); // 12:00 AM [EOL] TimeOfDay newTime = time.plusHours(-1); [EOL] assertEquals(23, newTime.getHourOfDay()); [EOL] assertEquals(0, newTime.getMinuteOfHour()); [EOL] }
public void testPlusHours_MaxInt() { [EOL] TimeOfDay time = new TimeOfDay(1, 0); // 1:00 AM [EOL] TimeOfDay newTime = time.plusHours(Integer.MAX_VALUE); [EOL] } [EOL] public void testPlusHours_MinInt() { [EOL] TimeOfDay time = new TimeOfDay(1, 0); // 1:00 AM [EOL] TimeOfDay newTime = time.plusHours(Integer.MIN_VALUE); [EOL] }
public void testPlusMinutes_CoverNewLines() { [EOL] TimeOfDay time = new TimeOfDay(); [EOL] TimeOfDay newTime = time.plusMinutes(30); [EOL] assertEquals("Hour should remain the same when adding minutes less than 60", time.getHourOfDay(), newTime.getHourOfDay()); [EOL] assertEquals("Minutes should be correctly added", time.getMinuteOfHour() + 30, newTime.getMinuteOfHour()); [EOL] time = new TimeOfDay(23, 30); [EOL] newTime = time.plusMinutes(45); [EOL] assertEquals("Hour should increment when minutes exceed 60", 0, newTime.getHourOfDay()); [EOL] assertEquals("Minutes should wrap around correctly", 15, newTime.getMinuteOfHour()); [EOL] time = new TimeOfDay(10, 30); [EOL] newTime = time.plusMinutes(-45); [EOL] assertEquals("Hour should decrement when negative minutes are subtracted", 9, newTime.getHourOfDay()); [EOL] assertEquals("Minutes should subtract correctly", 45, newTime.getMinuteOfHour()); [EOL] }
public void testMinusHours_CoverNewLines() { [EOL] TimeOfDay time = new TimeOfDay(10, 0); // 10:00 AM [EOL] TimeOfDay result = time.minusHours(2); [EOL] assertEquals(new TimeOfDay(8, 0), result); // Should be 8:00 AM after subtracting 2 hours [EOL] result = time.minusHours(-22); [EOL] assertEquals(new TimeOfDay(8, 0), result); // Should be 8:00 AM next day [EOL] result = time.minusHours(0); [EOL] assertEquals(time, result); // Should be the same time [EOL] result = time.minusHours(26); [EOL] assertEquals(new TimeOfDay(8, 0), result); // Should wrap around and still be 8:00 AM [EOL] }
public DateTime toDateTimeToday(DateTimeZone zone) { [EOL] Chronology chrono = getChronology().withZone(zone); [EOL] long instantMillis = DateTimeUtils.currentTimeMillis(); [EOL] long resolved = chrono.set(this, instantMillis); [EOL] return new DateTime(resolved, chrono); [EOL] } [EOL] public TimeOfDay() { } [EOL] public TimeOfDay(DateTimeZone zone) { } [EOL] public TimeOfDay(Chronology chronology) { } [EOL] public TimeOfDay(long instant) { } [EOL] public TimeOfDay(long instant, Chronology chronology) { } [EOL] public TimeOfDay(Object instant) { } [EOL] public TimeOfDay(Object instant, Chronology chronology) { } [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour) { } [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology) { } [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute) { } [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology) { } [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) { } [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology) { } [EOL] TimeOfDay(TimeOfDay partial, int[] values) { } [EOL] TimeOfDay(TimeOfDay partial, Chronology chrono) { } [EOL] Property(TimeOfDay partial, int fieldIndex) { } [EOL] public static TimeOfDay fromCalendarFields(Calendar calendar) { } [EOL] public static TimeOfDay fromDateFields(Date date) { } [EOL] public static TimeOfDay fromMillisOfDay(long millisOfDay) { } [EOL] public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono) { } [EOL] public int size() { } [EOL] protected DateTimeField getField(int index, Chronology chrono) { } [EOL] public DateTimeFieldType getFieldType(int index) { } [EOL] public DateTimeFieldType[] getFieldTypes() { } [EOL] public TimeOfDay withChronologyRetainFields(Chronology newChronology) { } [EOL] public TimeOfDay withField(DateTimeFieldType fieldType, int value) { } [EOL] public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount) { } [EOL] public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar) { } [EOL] public TimeOfDay plus(ReadablePeriod period) { } [EOL] public TimeOfDay plusHours(int hours) { } [EOL] public TimeOfDay plusMinutes(int minutes) { } [EOL] public TimeOfDay plusSeconds(int seconds) { } [EOL] public TimeOfDay plusMillis(int millis) { } [EOL] public TimeOfDay minus(ReadablePeriod period) { } [EOL] public TimeOfDay minusHours(int hours) { } [EOL] public TimeOfDay minusMinutes(int minutes) { } [EOL] public TimeOfDay minusSeconds(int seconds) { } [EOL] public TimeOfDay minusMillis(int millis) { } [EOL] public Property property(DateTimeFieldType type) { } [EOL] public LocalTime toLocalTime() { } [EOL] public DateTime toDateTimeToday() { } [EOL] public int getHourOfDay() { } [EOL] public int getMinuteOfHour() { } [EOL] public int getSecondOfMinute() { } [EOL] public int getMillisOfSecond() { } [EOL] public TimeOfDay withHourOfDay(int hour) { } [EOL] public TimeOfDay withMinuteOfHour(int minute) { } [EOL] public TimeOfDay withSecondOfMinute(int second) { } [EOL] public TimeOfDay withMillisOfSecond(int millis) { } [EOL] public Property hourOfDay() { } [EOL] public Property minuteOfHour() { } [EOL] public Property secondOfMinute() { } [EOL] public Property millisOfSecond() { } [EOL] public String toString() { } [EOL] public DateTimeField getField() { } [EOL] protected ReadablePartial getReadablePartial() { } [EOL] public TimeOfDay getTimeOfDay() { } [EOL] public int get() { } [EOL] public TimeOfDay addToCopy(int valueToAdd) { } [EOL] public TimeOfDay addNoWrapToCopy(int valueToAdd) { } [EOL] public TimeOfDay addWrapFieldToCopy(int valueToAdd) { } [EOL] public TimeOfDay setCopy(int value) { } [EOL] public TimeOfDay setCopy(String text, Locale locale) { } [EOL] public TimeOfDay setCopy(String text) { } [EOL] public TimeOfDay withMaximumValue() { } [EOL] public TimeOfDay withMinimumValue() { } [EOL] long serialVersionUID=3633353405803318660L; [EOL] DateTimeFieldType[] FIELD_TYPES=new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() };
public void testContains_withNullInstant() { [EOL] YourClassUnderTest instance = new YourClassUnderTest(); [EOL] boolean result = instance.contains(null); [EOL] boolean expected = instance.containsNow(); [EOL] assertEquals(expected, result); [EOL] }
public void testContains_withNonNullInstant() { [EOL] YourClassUnderTest instance = new YourClassUnderTest(); [EOL] ReadableInstant mockInstant = mock(ReadableInstant.class); [EOL] when(mockInstant.getMillis()).thenReturn(1234567890L); // Use a sample timestamp [EOL] boolean result = instance.contains(mockInstant); [EOL] boolean expected = instance.contains(1234567890L); [EOL] assertEquals(expected, result); [EOL] }
public void testIsEqual_BothIntervalsEqual() { [EOL] ReadableInterval interval1 = new MockReadableInterval(1000L, 2000L); [EOL] ReadableInterval interval2 = new MockReadableInterval(1000L, 2000L); [EOL] boolean result = interval1.isEqual(interval2); [EOL] assertTrue(result); [EOL] }
public void testIsEqual_StartMillisNotEqual() { [EOL] ReadableInterval interval1 = new MockReadableInterval(1000L, 2000L); [EOL] ReadableInterval interval2 = new MockReadableInterval(1001L, 2000L); [EOL] boolean result = interval1.isEqual(interval2); [EOL] assertFalse(result); [EOL] }
public void testIsEqual_EndMillisNotEqual() { [EOL] ReadableInterval interval1 = new MockReadableInterval(1000L, 2000L); [EOL] ReadableInterval interval2 = new MockReadableInterval(1000L, 2001L); [EOL] boolean result = interval1.isEqual(interval2); [EOL] assertFalse(result); [EOL] }
public void testIsEqual_BothIntervalsNotEqual() { [EOL] ReadableInterval interval1 = new MockReadableInterval(1000L, 2000L); [EOL] ReadableInterval interval2 = new MockReadableInterval(1001L, 2001L); [EOL] boolean result = interval1.isEqual(interval2); [EOL] assertFalse(result); [EOL] }
public void testIsBefore_EndMillisIsLessThanMillisInstant() { [EOL] long millisInstant = 1000L; [EOL] TimePeriod instance = new TimePeriod(500L, 999L); [EOL] boolean result = instance.isBefore(millisInstant); [EOL] assertTrue(result); [EOL] }
public void testIsBefore_EndMillisIsEqualToMillisInstant() { [EOL] long millisInstant = 1000L; [EOL] TimePeriod instance = new TimePeriod(500L, 1000L); [EOL] boolean result = instance.isBefore(millisInstant); [EOL] assertTrue(result); [EOL] }
public void testIsBefore_EndMillisIsGreaterThanMillisInstant() { [EOL] long millisInstant = 1000L; [EOL] TimePeriod instance = new TimePeriod(500L, 1001L); [EOL] boolean result = instance.isBefore(millisInstant); [EOL] assertFalse(result); [EOL] }
public boolean isBeforeNow() { [EOL] return isBefore(DateTimeUtils.currentTimeMillis()); [EOL] }
public void testIsBeforeWithNullInstant() { [EOL] Time time = new Time(); [EOL] boolean result = time.isBefore(null); [EOL] assertTrue(result); [EOL] }
public void testIsBeforeWithPastInstant() { [EOL] Time time = new Time(); [EOL] ReadableInstant pastInstant = new MockReadableInstant(System.currentTimeMillis() - 1000); [EOL] boolean result = time.isBefore(pastInstant); [EOL] assertTrue(result); [EOL] }
public void testIsBeforeWithFutureInstant() { [EOL] Time time = new Time(); [EOL] ReadableInstant futureInstant = new MockReadableInstant(System.currentTimeMillis() + 1000); [EOL] boolean result = time.isBefore(futureInstant); [EOL] assertFalse(result); [EOL] }
public void testIsAfter_WithTimeBeforeStart() { [EOL] long testMillisBefore = getStartMillis() - 1; [EOL] assertFalse(isAfter(testMillisBefore)); [EOL] }
public void testIsAfter_WithTimeEqualToStart() { [EOL] long testMillisAtStart = getStartMillis(); [EOL] assertFalse(isAfter(testMillisAtStart)); [EOL] }
public void testIsAfter_WithTimeAfterStart() { [EOL] long testMillisAfter = getStartMillis() + 1; [EOL] assertTrue(isAfter(testMillisAfter)); [EOL] }
public void testIsAfterNow_WhenNow_ReturnsFalse() { [EOL] DateTime testDateTime = new DateTime(DateTimeUtils.currentTimeMillis()); [EOL] assertFalse(testDateTime.isAfterNow()); [EOL] }
public void testIsAfterNow_WhenFuture_ReturnsTrue() { [EOL] DateTime testDateTime = new DateTime(DateTimeUtils.currentTimeMillis() + 1000); [EOL] assertTrue(testDateTime.isAfterNow()); [EOL] }
public void testIsAfterNow_WhenPast_ReturnsFalse() { [EOL] DateTime testDateTime = new DateTime(DateTimeUtils.currentTimeMillis() - 1000); [EOL] assertFalse(testDateTime.isAfterNow()); [EOL] }
public void testIsAfterWithNullInstant() { [EOL] Time time = new Time() { [EOL] public boolean isAfterNow() { [EOL] return true; [EOL] } [EOL] }; [EOL] boolean result = time.isAfter(null); [EOL] assertTrue(result); [EOL] }
public void testIsAfterWithInstantBefore() { [EOL] ReadableInstant instant = new ReadableInstant() { [EOL] public long getMillis() { [EOL] return System.currentTimeMillis() - 10000; // 10 seconds before now [EOL] } [EOL] }; [EOL] Time time = new Time() { [EOL] public boolean isAfter(long millis) { [EOL] return System.currentTimeMillis() > millis; [EOL] } [EOL] }; [EOL] boolean result = time.isAfter(instant); [EOL] assertTrue(result); [EOL] }
public void testIsAfterWithInstantAfter() { [EOL] ReadableInstant instant = new ReadableInstant() { [EOL] public long getMillis() { [EOL] return System.currentTimeMillis() + 10000; // 10 seconds after now [EOL] } [EOL] }; [EOL] Time time = new Time() { [EOL] public boolean isAfter(long millis) { [EOL] return System.currentTimeMillis() > millis; [EOL] } [EOL] }; [EOL] boolean result = time.isAfter(instant); [EOL] assertFalse(result); [EOL] }
public void testIsAfter_WithNullInterval() { [EOL] long currentMillis = DateTimeUtils.currentTimeMillis(); [EOL] long startMillis = currentMillis + 1000; // 1 second after [EOL] ReadableInterval testInterval = new MockReadableInterval(startMillis, startMillis + 1000); [EOL] boolean result = testInterval.isAfter(null); [EOL] assertFalse(result); [EOL] }
public void testIsAfter_WithIntervalBefore() { [EOL] long startMillis = 1000; [EOL] long endMillis = 2000; [EOL] ReadableInterval beforeInterval = new MockReadableInterval(startMillis, endMillis); [EOL] long testStartMillis = 3000; [EOL] ReadableInterval testInterval = new MockReadableInterval(testStartMillis, testStartMillis + 1000); [EOL] boolean result = testInterval.isAfter(beforeInterval); [EOL] assertTrue(result); [EOL] }
public void testIsAfter_WithIntervalAfter() { [EOL] long startMillis = 3000; [EOL] long endMillis = 4000; [EOL] ReadableInterval afterInterval = new MockReadableInterval(startMillis, endMillis); [EOL] long testStartMillis = 2000; [EOL] ReadableInterval testInterval = new MockReadableInterval(testStartMillis, testStartMillis + 1000); [EOL] boolean result = testInterval.isAfter(afterInterval); [EOL] assertFalse(result); [EOL] }
public void testToInterval() { [EOL] DateTime start = new DateTime(2021, 3, 10, 0, 0, 0); [EOL] DateTime end = new DateTime(2021, 3, 11, 0, 0, 0); [EOL] Interval interval = new Interval(start, end); [EOL] Interval result = interval.toInterval(); [EOL] assertNotNull(result); [EOL] assertEquals(start.getMillis(), result.getStartMillis()); [EOL] assertEquals(end.getMillis(), result.getEndMillis()); [EOL] assertEquals(interval.getChronology(), result.getChronology()); [EOL] }
public void testToPeriodWithNullType() { [EOL] DateTime start = new DateTime(); [EOL] DateTime end = start.plusHours(1); [EOL] Interval interval = new Interval(start, end); [EOL] Period result = interval.toPeriod(null); [EOL] assertNotNull(result); [EOL] assertEquals(start.getMillis(), result.getStartMillis()); [EOL] assertEquals(end.getMillis(), result.getEndMillis()); [EOL] assertNull(result.getPeriodType()); [EOL] }
public void testToPeriodWithSpecificType() { [EOL] DateTime start = new DateTime(); [EOL] DateTime end = start.plusHours(1); [EOL] Interval interval = new Interval(start, end); [EOL] PeriodType type = PeriodType.yearMonthDayTime(); [EOL] Period result = interval.toPeriod(type); [EOL] assertNotNull(result); [EOL] assertEquals(start.getMillis(), result.getStartMillis()); [EOL] assertEquals(end.getMillis(), result.getEndMillis()); [EOL] assertEquals(type, result.getPeriodType()); [EOL] }
public void testEquals_SameObject() { [EOL] ReadableInterval interval = new MockReadableInterval(); [EOL] assertTrue(interval.equals(interval)); [EOL] }
public void testEquals_Null() { [EOL] ReadableInterval interval = new MockReadableInterval(); [EOL] assertFalse(interval.equals(null)); [EOL] }
public void testEquals_DifferentType() { [EOL] ReadableInterval interval = new MockReadableInterval(); [EOL] assertFalse(interval.equals(new Object())); [EOL] }
public void testEquals_EqualIntervals() { [EOL] ReadableInterval interval1 = new MockReadableInterval(10, 20, null); [EOL] ReadableInterval interval2 = new MockReadableInterval(10, 20, null); [EOL] assertTrue(interval1.equals(interval2)); [EOL] }
public void testEquals_DifferentStartMillis() { [EOL] ReadableInterval interval1 = new MockReadableInterval(10, 20, null); [EOL] ReadableInterval interval2 = new MockReadableInterval(15, 20, null); [EOL] assertFalse(interval1.equals(interval2)); [EOL] }
public void testEquals_DifferentEndMillis() { [EOL] ReadableInterval interval1 = new MockReadableInterval(10, 20, null); [EOL] ReadableInterval interval2 = new MockReadableInterval(10, 25, null); [EOL] assertFalse(interval1.equals(interval2)); [EOL] }
public void testEquals_DifferentChronology() { [EOL] Chronology chrono1 = ISOChronology.getInstanceUTC(); [EOL] Chronology chrono2 = GregorianChronology.getInstanceUTC(); [EOL] ReadableInterval interval1 = new MockReadableInterval(10, 20, chrono1); [EOL] ReadableInterval interval2 = new MockReadableInterval(10, 20, chrono2); [EOL] assertFalse(interval1.equals(interval2)); [EOL] }
public void testToString() { [EOL] long startMillis = 0L; // Example start time [EOL] long endMillis = 1000L; // Example end time [EOL] TimePeriod timePeriod = new TimePeriod(startMillis, endMillis); // Replace with actual constructor [EOL] String result = timePeriod.toString(); [EOL] DateTimeFormatter formatter = ISODateTimeFormat.dateTime(); [EOL] String expectedStart = formatter.withChronology(timePeriod.getChronology()).print(startMillis); [EOL] String expectedEnd = formatter.withChronology(timePeriod.getChronology()).print(endMillis); [EOL] String expected = expectedStart + "/" + expectedEnd; [EOL] assertEquals("The toString method should match the expected ISODateTimeFormat", expected, result); [EOL] }
public void testGetValues_Empty() { [EOL] Time time = new Time(); [EOL] int[] expected = new int[0]; [EOL] int[] actual = time.getValues(); [EOL] assertArrayEquals(expected, actual); [EOL] }
public void testGetValues_NonEmpty() { [EOL] Time time = new Time(); [EOL] time.add(10); // Assuming there is a method to add values [EOL] time.add(20); [EOL] int[] expected = {10, 20}; [EOL] int[] actual = time.getValues(); [EOL] assertArrayEquals(expected, actual); [EOL] }
public void testGetWithInvalidType() { [EOL] Duration duration = new Duration(12345678L); [EOL] int result = duration.get(null); [EOL] assertEquals(0, result); [EOL] }
public void testGetWithValidType() { [EOL] Duration duration = new Duration(12345678L); [EOL] DurationFieldType type = DurationFieldType.seconds(); [EOL] int result = duration.get(type); [EOL] assertTrue(result > 0); [EOL] }
public void testToString() { [EOL] Period period = new Period(1, 2, 3, 4, 5, 6, 7, 8); [EOL] String result = period.toString(); [EOL] assertNotNull(result); [EOL] assertEquals("P1Y2M3W4DT5H6M7.008S", result); [EOL] }
public void testToStringWithNullFormatter() { [EOL] Period testPeriod = new Period(); [EOL] String result = testPeriod.toString(null); [EOL] assertNotNull(result); [EOL] assertEquals(testPeriod.toString(), result); [EOL] }
public void testToStringWithNonNullFormatter() { [EOL] Period testPeriod = new Period(); [EOL] PeriodFormatter formatter = new PeriodFormatter(); [EOL] String result = testPeriod.toString(formatter); [EOL] assertNotNull(result); [EOL] assertEquals(formatter.print(testPeriod), result); [EOL] }
public void testMutablePeriodWithNullType() { [EOL] MutablePeriod mp = new MutablePeriod((PeriodType) null); [EOL] assertNull(mp.getPeriodType()); [EOL] }
public void testMutablePeriodWithNonNullType() { [EOL] PeriodType type = PeriodType.standard(); [EOL] MutablePeriod mp = new MutablePeriod(type); [EOL] assertEquals(type, mp.getPeriodType()); [EOL] }
public void testMutablePeriod_AllFields() { [EOL] PeriodType type = PeriodType.standard(); [EOL] MutablePeriod period = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8, type); [EOL] assertEquals(1, period.getYears()); [EOL] assertEquals(2, period.getMonths()); [EOL] assertEquals(3, period.getWeeks()); [EOL] assertEquals(4, period.getDays()); [EOL] assertEquals(5, period.getHours()); [EOL] assertEquals(6, period.getMinutes()); [EOL] assertEquals(7, period.getSeconds()); [EOL] assertEquals(8, period.getMillis()); [EOL] assertEquals(type, period.getPeriodType()); [EOL] }
public void testMutablePeriodWithPositiveDuration() { [EOL] long duration = 1000L; // 1 second [EOL] MutablePeriod period = new MutablePeriod(duration); [EOL] assertEquals(duration, period.toDurationMillis()); [EOL] }
public void testMutablePeriodWithZeroDuration() { [EOL] long duration = 0L; [EOL] MutablePeriod period = new MutablePeriod(duration); [EOL] assertEquals(duration, period.toDurationMillis()); [EOL] }
public void testMutablePeriodWithNegativeDuration() { [EOL] long duration = -1000L; // -1 second [EOL] MutablePeriod period = new MutablePeriod(duration); [EOL] assertEquals(duration, period.toDurationMillis()); [EOL] }
public void testMutablePeriodWithStartAndEndInstantAndType() { [EOL] ReadableInstant startInstant = new DateTime(2020, 1, 1, 0, 0); [EOL] ReadableInstant endInstant = new DateTime(2020, 12, 31, 23, 59); [EOL] PeriodType type = PeriodType.standard(); [EOL] MutablePeriod period = new MutablePeriod(startInstant, endInstant, type); [EOL] assertNotNull(period); [EOL] assertEquals(type, period.getPeriodType()); [EOL] assertEquals(new Period(startInstant, endInstant, type), period); [EOL] }
public void testMutablePeriodWithNullStartInstant() { [EOL] ReadableInstant startInstant = null; [EOL] ReadableInstant endInstant = new DateTime(2020, 12, 31, 23, 59); [EOL] PeriodType type = PeriodType.standard(); [EOL] try { [EOL] new MutablePeriod(startInstant, endInstant, type); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testMutablePeriodWithNullEndInstant() { [EOL] ReadableInstant startInstant = new DateTime(2020, 1, 1, 0, 0); [EOL] ReadableInstant endInstant = null; [EOL] PeriodType type = PeriodType.standard(); [EOL] try { [EOL] new MutablePeriod(startInstant, endInstant, type); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testMutablePeriodWithNullType() { [EOL] ReadableInstant startInstant = new DateTime(2020, 1, 1, 0, 0); [EOL] ReadableInstant endInstant = new DateTime(2020, 12, 31, 23, 59); [EOL] PeriodType type = null; [EOL] MutablePeriod period = new MutablePeriod(startInstant, endInstant, type); [EOL] assertNotNull(period); [EOL] assertEquals(PeriodType.standard(), period.getPeriodType()); [EOL] assertEquals(new Period(startInstant, endInstant, PeriodType.standard()), period); [EOL] }
public void testMutablePeriodWithStartInstantAndDuration() { [EOL] DateTime startInstant = new DateTime(2023, 4, 1, 12, 0); [EOL] Duration duration = new Duration(7200000); // 2 hours [EOL] MutablePeriod period = new MutablePeriod(startInstant, duration); [EOL] assertNotNull(period); [EOL] assertEquals(2, period.getHours()); [EOL] }
public void testMutablePeriodWithNullStartInstantAndDuration() { [EOL] Duration duration = new Duration(7200000); // 2 hours [EOL] MutablePeriod period = new MutablePeriod(null, duration); [EOL] assertNotNull(period); [EOL] assertEquals(2, period.getHours()); [EOL] }
public void testMutablePeriodWithStartInstantAndNullDuration() { [EOL] DateTime startInstant = new DateTime(2023, 4, 1, 12, 0); [EOL] MutablePeriod period = new MutablePeriod(startInstant, null); [EOL] assertNotNull(period); [EOL] assertEquals(0, period.getHours()); [EOL] }
public void testMutablePeriodWithNullPeriodAndChronology() { [EOL] Chronology chrono = ISOChronology.getInstance(); [EOL] MutablePeriod mutablePeriod = new MutablePeriod((Object) null, chrono); [EOL] assertNotNull(mutablePeriod); [EOL] assertEquals(chrono, mutablePeriod.getChronology()); [EOL] }
public void testMutablePeriodWithNonNullPeriodAndNullChronology() { [EOL] Period period = new Period(1, 2, 3, 4, 5, 6, 7, 8); [EOL] MutablePeriod mutablePeriod = new MutablePeriod((Object) period, null); [EOL] assertNotNull(mutablePeriod); [EOL] assertEquals(PeriodType.standard(), mutablePeriod.getPeriodType()); [EOL] assertEquals(1, mutablePeriod.getYears()); [EOL] assertEquals(2, mutablePeriod.getMonths()); [EOL] assertEquals(3, mutablePeriod.getWeeks()); [EOL] assertEquals(4, mutablePeriod.getDays()); [EOL] assertEquals(5, mutablePeriod.getHours()); [EOL] assertEquals(6, mutablePeriod.getMinutes()); [EOL] assertEquals(7, mutablePeriod.getSeconds()); [EOL] assertEquals(8, mutablePeriod.getMillis()); [EOL] }
public void testMutablePeriodWithNonNullPeriodAndNonNullChronology() { [EOL] Period period = new Period(1, 2, 3, 4, 5, 6, 7, 8); [EOL] Chronology chrono = ISOChronology.getInstanceUTC(); [EOL] MutablePeriod mutablePeriod = new MutablePeriod((Object) period, chrono); [EOL] assertNotNull(mutablePeriod); [EOL] assertEquals(chrono, mutablePeriod.getChronology()); [EOL] assertEquals(1, mutablePeriod.getYears()); [EOL] assertEquals(2, mutablePeriod.getMonths()); [EOL] assertEquals(3, mutablePeriod.getWeeks()); [EOL] assertEquals(4, mutablePeriod.getDays()); [EOL] assertEquals(5, mutablePeriod.getHours()); [EOL] assertEquals(6, mutablePeriod.getMinutes()); [EOL] assertEquals(7, mutablePeriod.getSeconds()); [EOL] assertEquals(8, mutablePeriod.getMillis()); [EOL] }
public void testSetValue() { [EOL] int index = 0; // Example index [EOL] int value = 123; // Example value [EOL] setValue(index, value); [EOL] }
public void testSetWithValidField() { [EOL] DurationFieldType fieldType = DurationFieldType.minutes(); [EOL] int value = 10; [EOL] TimePeriod instance = new TimePeriod(); [EOL] instance.set(fieldType, value); [EOL] assertEquals(value, instance.get(fieldType)); [EOL] }
public void testSetWithNullField() { [EOL] int value = 10; [EOL] TimePeriod instance = new TimePeriod(); [EOL] try { [EOL] instance.set(null, value); [EOL] fail("Should have thrown IllegalArgumentException for null field"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testSetPeriodWithSameStartAndEnd() { [EOL] TimePeriod period = new TimePeriod(); [EOL] ReadableInstant instant = new DateTime(); [EOL] period.setPeriod(instant, instant); [EOL] assertEquals(0, period.getPeriod()); [EOL] }
public void testSetPeriodWithDifferentStartAndEnd() { [EOL] TimePeriod period = new TimePeriod(); [EOL] ReadableInstant start = new DateTime(); [EOL] ReadableInstant end = start.plusHours(1); [EOL] period.setPeriod(start, end); [EOL] long expectedMillis = end.getMillis() - start.getMillis(); [EOL] assertEquals(expectedMillis, period.getPeriod()); [EOL] }
public void testSetPeriodWithValidArguments() { [EOL] DateTime testDateTime = new DateTime(); [EOL] testDateTime.setPeriod(1000L, 2000L); [EOL] }
public void add_withNullPeriod() { [EOL] TimePeriod instance = new TimePeriod(); [EOL] instance.add(null); [EOL] }
public void add_withNonNullPeriod() { [EOL] TimePeriod instance = new TimePeriod(); [EOL] ReadablePeriod period = new MockReadablePeriod(); [EOL] instance.add(period); [EOL] }
public void testAddWithNonNullInterval() { [EOL] MutablePeriod period = new MutablePeriod(); [EOL] ReadableInterval interval = new Interval(0, 10000); [EOL] period.add(interval); [EOL] assertNotEquals(new MutablePeriod(), period); [EOL] }
public void testAddWithNullInterval() { [EOL] MutablePeriod period = new MutablePeriod(); [EOL] period.add((ReadableInterval) null); [EOL] assertEquals(new MutablePeriod(), period); [EOL] }
public void add_withNonNullDuration_addsPeriod() { [EOL] MockReadableDuration duration = new MockReadableDuration(1000); // Assuming MockReadableDuration implements ReadableDuration [EOL] TimePeriod timePeriod = new TimePeriod(getPeriodType()); // Assuming TimePeriod is the class where add method is and getPeriodType() is a valid method [EOL] timePeriod.add(duration); [EOL] assertEquals(new Period(1000, getPeriodType()), timePeriod.getPeriod()); // Assuming getPeriod() is a method to retrieve the current period [EOL] }
public void add_withNullDuration_doesNotAddPeriod() { [EOL] TimePeriod timePeriod = new TimePeriod(getPeriodType()); // Assuming TimePeriod is the class where add method is and getPeriodType() is a valid method [EOL] Period initialPeriod = timePeriod.getPeriod(); // Capture the initial state [EOL] timePeriod.add(null); [EOL] assertEquals(initialPeriod, timePeriod.getPeriod()); // The period should not change [EOL] }
public void testSetYears_ValidYears() { [EOL] Duration testDuration = new Duration(); [EOL] testDuration.setYears(5); [EOL] assertEquals(5, testDuration.getField(DurationFieldType.years())); [EOL] }
public void testSetYears_ZeroYears() { [EOL] Duration testDuration = new Duration(); [EOL] testDuration.setYears(0); [EOL] assertEquals(0, testDuration.getField(DurationFieldType.years())); [EOL] }
public void testSetYears_NegativeYears() { [EOL] Duration testDuration = new Duration(); [EOL] testDuration.setYears(-3); [EOL] assertEquals(-3, testDuration.getField(DurationFieldType.years())); [EOL] }
public void addMonths_addOneMonth() { [EOL] DateTime testDateTime = new DateTime(); [EOL] testDateTime.addMonths(1); [EOL] assertEquals(testDateTime.getMonthOfYear(), new DateTime().getMonthOfYear() + 1); [EOL] }
public void addMonths_addZeroMonths() { [EOL] DateTime testDateTime = new DateTime(); [EOL] testDateTime.addMonths(0); [EOL] assertEquals(testDateTime.getMonthOfYear(), new DateTime().getMonthOfYear()); [EOL] }
public void addMonths_addNegativeMonths() { [EOL] DateTime testDateTime = new DateTime(); [EOL] testDateTime.addMonths(-1); [EOL] assertEquals(testDateTime.getMonthOfYear(), new DateTime().getMonthOfYear() - 1); [EOL] }
public void addWeeksTestWithZeroWeeks() { [EOL] DateTime testDateTime = new DateTime(); [EOL] testDateTime.addWeeks(0); [EOL] assertEquals(new DateTime(), testDateTime); [EOL] }
public void addWeeksTestWithPositiveWeeks() { [EOL] DateTime testDateTime = new DateTime(); [EOL] DateTime expectedDateTime = testDateTime.plusWeeks(1); [EOL] testDateTime.addWeeks(1); [EOL] assertEquals(expectedDateTime, testDateTime); [EOL] }
public void addWeeksTestWithNegativeWeeks() { [EOL] DateTime testDateTime = new DateTime(); [EOL] DateTime expectedDateTime = testDateTime.minusWeeks(1); [EOL] testDateTime.addWeeks(-1); [EOL] assertEquals(expectedDateTime, testDateTime); [EOL] }
public void testAddMillis() { [EOL] int millisToAdd = 1000; [EOL] addMillis(millisToAdd); [EOL] }
public void testSetWithMinimumValue() { [EOL] long instant = System.currentTimeMillis(); [EOL] int minimumValue = getMinimumValue(); [EOL] long expected = instant + (minimumValue - get(instant)) * iUnitMillis; [EOL] long actual = set(instant, minimumValue); [EOL] assertEquals(expected, actual); [EOL] }
public void testSetWithMaximumValue() { [EOL] long instant = System.currentTimeMillis(); [EOL] int maximumValue = getMaximumValueForSet(instant, Integer.MAX_VALUE); [EOL] long expected = instant + (maximumValue - get(instant)) * iUnitMillis; [EOL] long actual = set(instant, maximumValue); [EOL] assertEquals(expected, actual); [EOL] }
public void testSetWithOutOfBoundsValue() { [EOL] long instant = System.currentTimeMillis(); [EOL] int invalidValue = getMaximumValueForSet(instant, Integer.MAX_VALUE) + 1; [EOL] try { [EOL] set(instant, invalidValue); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testGetDurationField() { [EOL] DurationField durationField = new DurationField(); [EOL] assertNotNull(durationField.getDurationField()); [EOL] }
public int getMinimumValue() { [EOL] return 0; [EOL] }
public void testGetUnitMillis() { [EOL] long expectedValue = 12345L; // Example value [EOL] Time time = new Time(expectedValue); // Time is the class containing getUnitMillis method [EOL] long actualValue = time.getUnitMillis(); [EOL] assertEquals("The getUnitMillis method should return the correct value", expectedValue, actualValue); [EOL] }
protected int getMaximumValueForSet(long instant, int value) { [EOL] return getMaximumValue(instant); [EOL] }
public void testAddWrapField_ZeroYears() { [EOL] long instant = SOME_INSTANT; // Replace with an actual instant value [EOL] int years = 0; [EOL] long result = addWrapField(instant, years); [EOL] assertEquals(instant, result); [EOL] }
public void testAddWrapField_PositiveYears() { [EOL] long instant = SOME_INSTANT; // Replace with an actual instant value [EOL] int years = 5; // Replace with a value that when wrapped doesn't exceed max year [EOL] long expected = SOME_EXPECTED_INSTANT; // Replace with the expected instant after adding years [EOL] long result = addWrapField(instant, years); [EOL] assertEquals(expected, result); [EOL] }
public void testAddWrapField_NegativeYears() { [EOL] long instant = SOME_INSTANT; // Replace with an actual instant value [EOL] int years = -5; // Replace with a value that when wrapped doesn't go below min year [EOL] long expected = SOME_EXPECTED_INSTANT; // Replace with the expected instant after subtracting years [EOL] long result = addWrapField(instant, years); [EOL] assertEquals(expected, result); [EOL] }
public void testAddWrapField_MaxYearWrap() { [EOL] long instant = SOME_INSTANT; // Replace with an actual instant value [EOL] int years = MAX_YEAR_VALUE; // Replace with a value that causes wrapping to max year [EOL] long expected = SOME_EXPECTED_INSTANT; // Replace with the expected instant after wrapping to max year [EOL] long result = addWrapField(instant, years); [EOL] assertEquals(expected, result); [EOL] }
public void testAddWrapField_MinYearWrap() { [EOL] long instant = SOME_INSTANT; // Replace with an actual instant value [EOL] int years = MIN_YEAR_VALUE; // Replace with a value that causes wrapping to min year [EOL] long expected = SOME_EXPECTED_INSTANT; // Replace with the expected instant after wrapping to min year [EOL] long result = addWrapField(instant, years); [EOL] assertEquals(expected, result); [EOL] }
public void testGetMinimumValue() { [EOL] int expectedValue = /* some expected min year value */; [EOL] int actualValue = iChronology.getMinYear(); [EOL] assertEquals(expectedValue, actualValue); [EOL] }
public void testGetMaximumValue() { [EOL] int expectedMaxValue = 9999; // Assuming 9999 is the max year value for the chronology used [EOL] Chronology chronology = IsoChronology.INSTANCE; // Replace with the actual chronology used [EOL] Time time = new Time(chronology); [EOL] int maxValue = time.getMaximumValue(); [EOL] assertEquals(expectedMaxValue, maxValue); [EOL] }
public void testCompareReverseBothNull() { [EOL] DurationField a = null; [EOL] DurationField b = null; [EOL] int result = compareReverse(a, b); [EOL] assertEquals(0, result); [EOL] } [EOL] public void testCompareReverseAIsNotSupported() { [EOL] DurationField a = new UnsupportedDurationField(); [EOL] DurationField b = new SupportedDurationField(); [EOL] int result = compareReverse(a, b); [EOL] assertEquals(-1, result); [EOL] } [EOL] public void testCompareReverseBIsNotSupported() { [EOL] DurationField a = new SupportedDurationField(); [EOL] DurationField b = new UnsupportedDurationField(); [EOL] int result = compareReverse(a, b); [EOL] assertEquals(1, result); [EOL] } [EOL] public void testCompareReverseBothSupported() { [EOL] DurationField a = new SupportedDurationField(); [EOL] DurationField b = new SupportedDurationField(); [EOL] when(a.compareTo(b)).thenReturn(1); [EOL] int result = compareReverse(a, b); [EOL] assertEquals(-1, result); [EOL] }
public void testRoundCeiling() { [EOL] long instant = SOME_INSTANT; // Replace SOME_INSTANT with an actual timestamp [EOL] long expected = SOME_EXPECTED_VALUE; // Replace SOME_EXPECTED_VALUE with the expected result [EOL] long actual = roundCeiling(instant); [EOL] assertEquals(expected, actual); [EOL] }
public void testRoundCeilingWithNegativeInstant() { [EOL] long instant = SOME_NEGATIVE_INSTANT; // Replace SOME_NEGATIVE_INSTANT with an actual negative timestamp [EOL] long expected = SOME_EXPECTED_NEGATIVE_VALUE; // Replace SOME_EXPECTED_NEGATIVE_VALUE with the expected result [EOL] long actual = roundCeiling(instant); [EOL] assertEquals(expected, actual); [EOL] }
public void testRemainder_PositiveInstant() { [EOL] long instant = 5L; [EOL] long expected = super.remainder(instant + 3 * DateTimeConstants.MILLIS_PER_DAY); [EOL] assertEquals(expected, remainder(instant)); [EOL] }
public void testRemainder_NegativeInstant() { [EOL] long instant = -5L; [EOL] long expected = super.remainder(instant + 3 * DateTimeConstants.MILLIS_PER_DAY); [EOL] assertEquals(expected, remainder(instant)); [EOL] }
public void testDays_Zero() { [EOL] Days result = Time.days(0); [EOL] assertSame(Days.ZERO, result); [EOL] }
public void testDays_One() { [EOL] Days result = Time.days(1); [EOL] assertSame(Days.ONE, result); [EOL] }
public void testDays_Two() { [EOL] Days result = Time.days(2); [EOL] assertSame(Days.TWO, result); [EOL] }
public void testDays_Three() { [EOL] Days result = Time.days(3); [EOL] assertSame(Days.THREE, result); [EOL] }
public void testDays_Four() { [EOL] Days result = Time.days(4); [EOL] assertSame(Days.FOUR, result); [EOL] }
public void testDays_Five() { [EOL] Days result = Time.days(5); [EOL] assertSame(Days.FIVE, result); [EOL] }
public void testDays_Six() { [EOL] Days result = Time.days(6); [EOL] assertSame(Days.SIX, result); [EOL] }
public void testDays_Seven() { [EOL] Days result = Time.days(7); [EOL] assertSame(Days.SEVEN, result); [EOL] }
public void testDays_MaxValue() { [EOL] Days result = Time.days(Integer.MAX_VALUE); [EOL] assertSame(Days.MAX_VALUE, result); [EOL] }
public void testDays_MinValue() { [EOL] Days result = Time.days(Integer.MIN_VALUE); [EOL] assertSame(Days.MIN_VALUE, result); [EOL] }
public void testDays_Default() { [EOL] int anyOtherValue = 8; // Any value other than the ones explicitly handled in the switch case [EOL] Days result = Time.days(anyOtherValue); [EOL] assertNotNull(result); [EOL] assertEquals(anyOtherValue, result.getValue()); [EOL] }
public void testDaysBetween_LocalDates() { [EOL] LocalDate start = new LocalDate(2020, 1, 1); [EOL] LocalDate end = new LocalDate(2020, 1, 10); [EOL] Days result = time.daysBetween(start, end); [EOL] assertEquals(9, result.getDays()); [EOL] }
public void testDaysBetween_NonLocalDates() { [EOL] ReadablePartial start = new YearMonth(2020, 1); [EOL] ReadablePartial end = new YearMonth(2020, 2); [EOL] Days result = time.daysBetween(start, end); [EOL] assertTrue(result.getDays() > 0); [EOL] }
public void testGetFieldType() { [EOL] DurationFieldType type = new Duration().getFieldType(); [EOL] assertEquals(DurationFieldType.days(), type); [EOL] }
public void testToStandardSeconds_PositiveDays() { [EOL] Days days = Days.days(1); [EOL] Seconds result = days.toStandardSeconds(); [EOL] assertEquals(86400, result.getSeconds()); [EOL] }
public void testToStandardSeconds_NegativeDays() { [EOL] Days days = Days.days(-1); [EOL] Seconds result = days.toStandardSeconds(); [EOL] assertEquals(-86400, result.getSeconds()); [EOL] }
public void testToStandardSeconds_ZeroDays() { [EOL] Days days = Days.days(0); [EOL] Seconds result = days.toStandardSeconds(); [EOL] assertEquals(0, result.getSeconds()); [EOL] }
public void testPlus_ZeroDays() { [EOL] Days originalDays = Days.days(5); [EOL] Days resultDays = originalDays.plus(0); [EOL] assertSame("Expected the same object to be returned", originalDays, resultDays); [EOL] }
public void testPlus_NonZeroDays() { [EOL] Days originalDays = Days.days(5); [EOL] Days resultDays = originalDays.plus(10); [EOL] assertEquals("Expected the sum of days", 15, resultDays.getValue()); [EOL] }
public void testDividedBy_DivisorIsOne() { [EOL] Days originalDays = Days.days(10); [EOL] Days resultDays = originalDays.dividedBy(1); [EOL] assertEquals(originalDays, resultDays); [EOL] }
public void testDividedBy_DivisorIsNotOne() { [EOL] Days originalDays = Days.days(10); [EOL] Days resultDays = originalDays.dividedBy(2); [EOL] assertEquals(Days.days(5), resultDays); [EOL] }
public void testDividedBy_DivisorIsZero() { [EOL] Days originalDays = Days.days(10); [EOL] try { [EOL] originalDays.dividedBy(0); [EOL] fail("Should have thrown ArithmeticException due to division by zero"); [EOL] } catch (ArithmeticException e) { [EOL] } [EOL] }
public void testToString_PositiveValue() { [EOL] Time time = new Time(); [EOL] time.setValue(5); [EOL] String result = time.toString(); [EOL] assert result.equals("P5D"); [EOL] }
public void testToString_NegativeValue() { [EOL] Time time = new Time(); [EOL] time.setValue(-5); [EOL] String result = time.toString(); [EOL] assert result.equals("P-5D"); [EOL] }
public void testToString_ZeroValue() { [EOL] Time time = new Time(); [EOL] time.setValue(0); [EOL] String result = time.toString(); [EOL] assert result.equals("P0D"); [EOL] }
public long addTestWithPositiveYears() { [EOL] long instant = System.currentTimeMillis(); [EOL] int years = 5; [EOL] long expected = getWrappedField().add(instant, years); [EOL] long actual = add(instant, years); [EOL] assertEquals(expected, actual); [EOL] } [EOL] public long addTestWithNegativeYears() { [EOL] long instant = System.currentTimeMillis(); [EOL] int years = -5; [EOL] long expected = getWrappedField().add(instant, years); [EOL] long actual = add(instant, years); [EOL] assertEquals(expected, actual); [EOL] } [EOL] public long addTestWithZeroYears() { [EOL] long instant = System.currentTimeMillis(); [EOL] int years = 0; [EOL] long expected = getWrappedField().add(instant, years); [EOL] long actual = add(instant, years); [EOL] assertEquals(expected, actual); [EOL] }
public void testRoundFloor() { [EOL] MyClass myClassInstance = new MyClass(); [EOL] Field field = mock(Field.class); [EOL] when(myClassInstance.getWrappedField()).thenReturn(field); [EOL] long instant = 123456789L; // Example instant value [EOL] long expected = 123456000L; // Expected result after rounding (this is just an example) [EOL] when(field.roundFloor(instant)).thenReturn(expected); [EOL] long actual = myClassInstance.roundFloor(instant); [EOL] assertEquals(expected, actual); [EOL] }
public void testNowWithNullChronology() { [EOL] try { [EOL] MonthDay.now(null); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException e) { [EOL] assertEquals("Chronology must not be null", e.getMessage()); [EOL] } [EOL] }
public void testNowWithNonNullChronology() { [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] MonthDay actual = MonthDay.now(chronology); [EOL] assertNotNull(actual); [EOL] assertEquals(chronology, actual.getChronology()); [EOL] }
public void testMonthDayWithPartialAndValues() { [EOL] MonthDay partial = new MonthDay(5, 1); [EOL] int[] values = new int[] {7, 2}; [EOL] MonthDay result = new MonthDay(partial, values); [EOL] assertEquals(7, result.getMonthOfYear()); [EOL] assertEquals(2, result.getDayOfMonth()); [EOL] }
public void testMonthDayDefaultConstructor() { [EOL] MonthDay result = new MonthDay(); [EOL] assertNotNull(result); [EOL] }
public void testMonthDayZoneConstructor() { [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/Paris"); [EOL] MonthDay result = new MonthDay(zone); [EOL] assertNotNull(result); [EOL] assertEquals(zone, result.getChronology().getZone()); [EOL] }
public void testMonthDayChronologyConstructor() { [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] MonthDay result = new MonthDay(chronology); [EOL] assertNotNull(result); [EOL] assertEquals(chronology, result.getChronology()); [EOL] }
public void testMonthDayInstantConstructor() { [EOL] long instant = System.currentTimeMillis(); [EOL] MonthDay result = new MonthDay(instant); [EOL] assertNotNull(result); [EOL] }
public void testMonthDayInstantChronologyConstructor() { [EOL] long instant = System.currentTimeMillis(); [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] MonthDay result = new MonthDay(instant, chronology); [EOL] assertNotNull(result); [EOL] assertEquals(chronology, result.getChronology()); [EOL] }
public void testMonthDayObjectConstructor() { [EOL] Object instant = new Date(); [EOL] MonthDay result = new MonthDay(instant); [EOL] assertNotNull(result); [EOL] }
public void testMonthDayObjectChronologyConstructor() { [EOL] Object instant = new Date(); [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] MonthDay result = new MonthDay(instant, chronology); [EOL] assertNotNull(result); [EOL] assertEquals(chronology, result.getChronology()); [EOL] }
public void testMonthDayIntIntConstructor() { [EOL] int monthOfYear = 6; [EOL] int dayOfMonth = 15; [EOL] MonthDay result = new MonthDay(monthOfYear, dayOfMonth); [EOL] assertEquals(monthOfYear, result.getMonthOfYear()); [EOL] assertEquals(dayOfMonth, result.getDayOfMonth()); [EOL] }
public void testMonthDayIntIntChronologyConstructor() { [EOL] int monthOfYear = 6; [EOL] int dayOfMonth = 15; [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] MonthDay result = new MonthDay(monthOfYear, dayOfMonth, chronology); [EOL] assertEquals(monthOfYear, result.getMonthOfYear()); [EOL] assertEquals(dayOfMonth, result.getDayOfMonth()); [EOL] assertEquals(chronology, result.getChronology()); [EOL] }

public void testPlusMonths_Normal() { [EOL] MonthDay original = new MonthDay(5, 1); // May 1st [EOL] MonthDay expected = new MonthDay(7, 1); // July 1st [EOL] MonthDay result = original.plusMonths(2); [EOL] assertEquals(expected, result); [EOL] }
public void testPlusMonths_Overflow() { [EOL] MonthDay original = new MonthDay(10, 31); // October 31st [EOL] MonthDay expected = new MonthDay(1, 31); // January 31st of the next year [EOL] MonthDay result = original.plusMonths(3); [EOL] assertEquals(expected, result); [EOL] }
public void testPlusMonths_Underflow() { [EOL] MonthDay original = new MonthDay(3, 30); // March 30th [EOL] MonthDay expected = new MonthDay(12, 30); // December 30th of the previous year [EOL] MonthDay result = original.plusMonths(-3); [EOL] assertEquals(expected, result); [EOL] }
public void testPlusMonths_Zero() { [EOL] MonthDay original = new MonthDay(6, 15); // June 15th [EOL] MonthDay result = original.plusMonths(0); [EOL] assertEquals(original, result); [EOL] }
public LocalDate toLocalDate(int year) { [EOL] return new LocalDate(year, getMonthOfYear(), getDayOfMonth(), getChronology()); [EOL] } [EOL] public MonthDay() { } [EOL] public MonthDay(DateTimeZone zone) { } [EOL] public MonthDay(Chronology chronology) { } [EOL] public MonthDay(long instant) { } [EOL] public MonthDay(long instant, Chronology chronology) { } [EOL] public MonthDay(Object instant) { } [EOL] public MonthDay(Object instant, Chronology chronology) { } [EOL] public MonthDay(int monthOfYear, int dayOfMonth) { } [EOL] public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology) { } [EOL] MonthDay(MonthDay partial, int[] values) { } [EOL] MonthDay(MonthDay partial, Chronology chrono) { } [EOL] Property(MonthDay partial, int fieldIndex) { } [EOL] public static MonthDay now() { } [EOL] public static MonthDay now(DateTimeZone zone) { } [EOL] public static MonthDay now(Chronology chronology) { } [EOL] public static MonthDay parse(String str) { } [EOL] public static MonthDay parse(String str, DateTimeFormatter formatter) { } [EOL] public static MonthDay fromCalendarFields(Calendar calendar) { } [EOL] public static MonthDay fromDateFields(Date date) { } [EOL] private Object readResolve() { } [EOL] public int size() { } [EOL] protected DateTimeField getField(int index, Chronology chrono) { } [EOL] public DateTimeFieldType getFieldType(int index) { } [EOL] public DateTimeFieldType[] getFieldTypes() { } [EOL] public MonthDay withChronologyRetainFields(Chronology newChronology) { } [EOL] public MonthDay withField(DateTimeFieldType fieldType, int value) { } [EOL] public MonthDay withFieldAdded(DurationFieldType fieldType, int amount) { } [EOL] public MonthDay withPeriodAdded(ReadablePeriod period, int scalar) { } [EOL] public MonthDay plus(ReadablePeriod period) { } [EOL] public MonthDay plusMonths(int months) { } [EOL] public MonthDay plusDays(int days) { } [EOL] public MonthDay minus(ReadablePeriod period) { } [EOL] public MonthDay minusMonths(int months) { } [EOL] public MonthDay minusDays(int days) { } [EOL] public int getMonthOfYear() { } [EOL] public int getDayOfMonth() { } [EOL] public MonthDay withMonthOfYear(int monthOfYear) { } [EOL] public MonthDay withDayOfMonth(int dayOfMonth) { } [EOL] public Property property(DateTimeFieldType type) { } [EOL] public Property monthOfYear() { } [EOL] public Property dayOfMonth() { } [EOL] public String toString() { } [EOL] public String toString(String pattern) { } [EOL] public String toString(String pattern, Locale locale) throws IllegalArgumentException { } [EOL] public DateTimeField getField() { } [EOL] protected ReadablePartial getReadablePartial() { } [EOL] public MonthDay getMonthDay() { } [EOL] public int get() { } [EOL] public MonthDay addToCopy(int valueToAdd) { } [EOL] public MonthDay addWrapFieldToCopy(int valueToAdd) { } [EOL] public MonthDay setCopy(int value) { } [EOL] public MonthDay setCopy(String text, Locale locale) { } [EOL] public MonthDay setCopy(String text) { } [EOL] long serialVersionUID=2954560699050434609L; [EOL] DateTimeFieldType[] FIELD_TYPES=new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() };
public int getMonthOfYear() { [EOL] return getValue(MONTH_OF_YEAR); [EOL] } [EOL] public MonthDay(); [EOL] public MonthDay(DateTimeZone zone); [EOL] public MonthDay(Chronology chronology); [EOL] public MonthDay(long instant); [EOL] public MonthDay(long instant, Chronology chronology); [EOL] public MonthDay(Object instant); [EOL] public MonthDay(Object instant, Chronology chronology); [EOL] public MonthDay(int monthOfYear, int dayOfMonth); [EOL] public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology); [EOL] MonthDay(MonthDay partial, int[] values); [EOL] MonthDay(MonthDay partial, Chronology chrono); [EOL] Property(MonthDay partial, int fieldIndex); [EOL] public static MonthDay now(); [EOL] public static MonthDay now(DateTimeZone zone); [EOL] public static MonthDay now(Chronology chronology); [EOL] public static MonthDay parse(String str); [EOL] public static MonthDay parse(String str, DateTimeFormatter formatter); [EOL] public static MonthDay fromCalendarFields(Calendar calendar); [EOL] public static MonthDay fromDateFields(Date date); [EOL] private Object readResolve(); [EOL] public int size(); [EOL] protected DateTimeField getField(int index, Chronology chrono); [EOL] public DateTimeFieldType getFieldType(int index); [EOL] public DateTimeFieldType[] getFieldTypes(); [EOL] public MonthDay withChronologyRetainFields(Chronology newChronology); [EOL] public MonthDay withField(DateTimeFieldType fieldType, int value); [EOL] public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); [EOL] public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); [EOL] public MonthDay plus(ReadablePeriod period); [EOL] public MonthDay plusMonths(int months); [EOL] public MonthDay plusDays(int days); [EOL] public MonthDay minus(ReadablePeriod period); [EOL] public MonthDay minusMonths(int months); [EOL] public MonthDay minusDays(int days); [EOL] public LocalDate toLocalDate(int year); [EOL] public int getMonthOfYear(); [EOL] public int getDayOfMonth(); [EOL] public MonthDay withMonthOfYear(int monthOfYear); [EOL] public MonthDay withDayOfMonth(int dayOfMonth); [EOL] public Property property(DateTimeFieldType type); [EOL] public Property monthOfYear(); [EOL] public Property dayOfMonth(); [EOL] public String toString(); [EOL] public String toString(String pattern); [EOL] public String toString(String pattern, Locale locale) throws IllegalArgumentException; [EOL] public DateTimeField getField(); [EOL] protected ReadablePartial getReadablePartial(); [EOL] public MonthDay getMonthDay(); [EOL] public int get(); [EOL] public MonthDay addToCopy(int valueToAdd); [EOL] public MonthDay addWrapFieldToCopy(int valueToAdd); [EOL] public MonthDay setCopy(int value); [EOL] public MonthDay setCopy(String text, Locale locale); [EOL] public MonthDay setCopy(String text); [EOL] long serialVersionUID=2954560699050434609L; [EOL] DateTimeFieldType[] FIELD_TYPES=new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() };
public int getDayOfMonth() { [EOL] return getValue(DAY_OF_MONTH); [EOL] } [EOL] public MonthDay(); [EOL] public MonthDay(DateTimeZone zone); [EOL] public MonthDay(Chronology chronology); [EOL] public MonthDay(long instant); [EOL] public MonthDay(long instant, Chronology chronology); [EOL] public MonthDay(Object instant); [EOL] public MonthDay(Object instant, Chronology chronology); [EOL] public MonthDay(int monthOfYear, int dayOfMonth); [EOL] public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology); [EOL] MonthDay(MonthDay partial, int[] values); [EOL] MonthDay(MonthDay partial, Chronology chrono); [EOL] Property(MonthDay partial, int fieldIndex); [EOL] public static MonthDay now(); [EOL] public static MonthDay now(DateTimeZone zone); [EOL] public static MonthDay now(Chronology chronology); [EOL] public static MonthDay parse(String str); [EOL] public static MonthDay parse(String str, DateTimeFormatter formatter); [EOL] public static MonthDay fromCalendarFields(Calendar calendar); [EOL] public static MonthDay fromDateFields(Date date); [EOL] private Object readResolve(); [EOL] public int size(); [EOL] protected DateTimeField getField(int index, Chronology chrono); [EOL] public DateTimeFieldType getFieldType(int index); [EOL] public DateTimeFieldType[] getFieldTypes(); [EOL] public MonthDay withChronologyRetainFields(Chronology newChronology); [EOL] public MonthDay withField(DateTimeFieldType fieldType, int value); [EOL] public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); [EOL] public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); [EOL] public MonthDay plus(ReadablePeriod period); [EOL] public MonthDay plusMonths(int months); [EOL] public MonthDay plusDays(int days); [EOL] public MonthDay minus(ReadablePeriod period); [EOL] public MonthDay minusMonths(int months); [EOL] public MonthDay minusDays(int days); [EOL] public LocalDate toLocalDate(int year); [EOL] public int getMonthOfYear(); [EOL] public int getDayOfMonth(); [EOL] public MonthDay withMonthOfYear(int monthOfYear); [EOL] public MonthDay withDayOfMonth(int dayOfMonth); [EOL] public Property property(DateTimeFieldType type); [EOL] public Property monthOfYear(); [EOL] public Property dayOfMonth(); [EOL] public String toString(); [EOL] public String toString(String pattern); [EOL] public String toString(String pattern, Locale locale) throws IllegalArgumentException; [EOL] public DateTimeField getField(); [EOL] protected ReadablePartial getReadablePartial(); [EOL] public MonthDay getMonthDay(); [EOL] public int get(); [EOL] public MonthDay addToCopy(int valueToAdd); [EOL] public MonthDay addWrapFieldToCopy(int valueToAdd); [EOL] public MonthDay setCopy(int value); [EOL] public MonthDay setCopy(String text, Locale locale); [EOL] public MonthDay setCopy(String text); [EOL] long serialVersionUID=2954560699050434609L; [EOL] DateTimeFieldType[] FIELD_TYPES=new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() };
public void testWithMonthOfYear_ValidMonth() { [EOL] MonthDay monthDay = new MonthDay(); [EOL] int validMonth = 5; [EOL] MonthDay updatedMonthDay = monthDay.withMonthOfYear(validMonth); [EOL] assertEquals(validMonth, updatedMonthDay.getMonthOfYear()); [EOL] }
public void testWithMonthOfYear_InvalidMonth() { [EOL] MonthDay monthDay = new MonthDay(); [EOL] int invalidMonth = 13; [EOL] try { [EOL] monthDay.withMonthOfYear(invalidMonth); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testWithMonthOfYear_ZeroMonth() { [EOL] MonthDay monthDay = new MonthDay(); [EOL] int zeroMonth = 0; [EOL] try { [EOL] monthDay.withMonthOfYear(zeroMonth); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testWithDayOfMonth_ValidDay() { [EOL] MonthDay monthDay = new MonthDay(5, 1); [EOL] MonthDay updatedMonthDay = monthDay.withDayOfMonth(15); [EOL] assertEquals(15, updatedMonthDay.getDayOfMonth()); [EOL] }
public void testWithDayOfMonth_InvalidDay() { [EOL] try { [EOL] MonthDay monthDay = new MonthDay(4, 1); [EOL] monthDay.withDayOfMonth(31); [EOL] fail("Should have thrown an exception for an invalid day of month"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testWithDayOfMonth_ChangeMonth() { [EOL] MonthDay monthDay = new MonthDay(2, 28); [EOL] MonthDay updatedMonthDay = monthDay.withDayOfMonth(1); [EOL] assertEquals(1, updatedMonthDay.getDayOfMonth()); [EOL] assertEquals(2, updatedMonthDay.getMonthOfYear()); [EOL] }
public void testWithDayOfMonth_SameDay() { [EOL] MonthDay monthDay = new MonthDay(3, 15); [EOL] MonthDay updatedMonthDay = monthDay.withDayOfMonth(15); [EOL] assertSame(monthDay, updatedMonthDay); [EOL] }
public Property property(DateTimeFieldType type) { [EOL] return new Property(this, indexOfSupported(type)); [EOL] } [EOL] public MonthDay(); [EOL] public MonthDay(DateTimeZone zone); [EOL] public MonthDay(Chronology chronology); [EOL] public MonthDay(long instant); [EOL] public MonthDay(long instant, Chronology chronology); [EOL] public MonthDay(Object instant); [EOL] public MonthDay(Object instant, Chronology chronology); [EOL] public MonthDay(int monthOfYear, int dayOfMonth); [EOL] public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology); [EOL] MonthDay(MonthDay partial, int[] values); [EOL] MonthDay(MonthDay partial, Chronology chrono); [EOL] Property(MonthDay partial, int fieldIndex); [EOL] public static MonthDay now(); [EOL] public static MonthDay now(DateTimeZone zone); [EOL] public static MonthDay now(Chronology chronology); [EOL] public static MonthDay parse(String str); [EOL] public static MonthDay parse(String str, DateTimeFormatter formatter); [EOL] public static MonthDay fromCalendarFields(Calendar calendar); [EOL] public static MonthDay fromDateFields(Date date); [EOL] private Object readResolve(); [EOL] public int size(); [EOL] protected DateTimeField getField(int index, Chronology chrono); [EOL] public DateTimeFieldType getFieldType(int index); [EOL] public DateTimeFieldType[] getFieldTypes(); [EOL] public MonthDay withChronologyRetainFields(Chronology newChronology); [EOL] public MonthDay withField(DateTimeFieldType fieldType, int value); [EOL] public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); [EOL] public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); [EOL] public MonthDay plus(ReadablePeriod period); [EOL] public MonthDay plusMonths(int months); [EOL] public MonthDay plusDays(int days); [EOL] public MonthDay minus(ReadablePeriod period); [EOL] public MonthDay minusMonths(int months); [EOL] public MonthDay minusDays(int days); [EOL] public LocalDate toLocalDate(int year); [EOL] public int getMonthOfYear(); [EOL] public int getDayOfMonth(); [EOL] public MonthDay withMonthOfYear(int monthOfYear); [EOL] public MonthDay withDayOfMonth(int dayOfMonth); [EOL] public Property monthOfYear(); [EOL] public Property dayOfMonth(); [EOL] public String toString(); [EOL] public String toString(String pattern); [EOL] public String toString(String pattern, Locale locale) throws IllegalArgumentException; [EOL] public DateTimeField getField(); [EOL] protected ReadablePartial getReadablePartial(); [EOL] public MonthDay getMonthDay(); [EOL] public int get(); [EOL] public MonthDay addToCopy(int valueToAdd); [EOL] public MonthDay addWrapFieldToCopy(int valueToAdd); [EOL] public MonthDay setCopy(int value); [EOL] public MonthDay setCopy(String text, Locale locale); [EOL] public MonthDay setCopy(String text); [EOL] long serialVersionUID=2954560699050434609L; [EOL] DateTimeFieldType[] FIELD_TYPES=new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() };
public Property monthOfYear() { [EOL] return new Property(this, MONTH_OF_YEAR); [EOL] } [EOL] public MonthDay(); [EOL] public MonthDay(DateTimeZone zone); [EOL] public MonthDay(Chronology chronology); [EOL] public MonthDay(long instant); [EOL] public MonthDay(long instant, Chronology chronology); [EOL] public MonthDay(Object instant); [EOL] public MonthDay(Object instant, Chronology chronology); [EOL] public MonthDay(int monthOfYear, int dayOfMonth); [EOL] public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology); [EOL] MonthDay(MonthDay partial, int[] values); [EOL] MonthDay(MonthDay partial, Chronology chrono); [EOL] Property(MonthDay partial, int fieldIndex); [EOL] public static MonthDay now(); [EOL] public static MonthDay now(DateTimeZone zone); [EOL] public static MonthDay now(Chronology chronology); [EOL] public static MonthDay parse(String str); [EOL] public static MonthDay parse(String str, DateTimeFormatter formatter); [EOL] public static MonthDay fromCalendarFields(Calendar calendar); [EOL] public static MonthDay fromDateFields(Date date); [EOL] private Object readResolve(); [EOL] public int size(); [EOL] protected DateTimeField getField(int index, Chronology chrono); [EOL] public DateTimeFieldType getFieldType(int index); [EOL] public DateTimeFieldType[] getFieldTypes(); [EOL] public MonthDay withChronologyRetainFields(Chronology newChronology); [EOL] public MonthDay withField(DateTimeFieldType fieldType, int value); [EOL] public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); [EOL] public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); [EOL] public MonthDay plus(ReadablePeriod period); [EOL] public MonthDay plusMonths(int months); [EOL] public MonthDay plusDays(int days); [EOL] public MonthDay minus(ReadablePeriod period); [EOL] public MonthDay minusMonths(int months); [EOL] public MonthDay minusDays(int days); [EOL] public LocalDate toLocalDate(int year); [EOL] public int getMonthOfYear(); [EOL] public int getDayOfMonth(); [EOL] public MonthDay withMonthOfYear(int monthOfYear); [EOL] public MonthDay withDayOfMonth(int dayOfMonth); [EOL] public Property property(DateTimeFieldType type); [EOL] public Property dayOfMonth(); [EOL] public String toString(); [EOL] public String toString(String pattern); [EOL] public String toString(String pattern, Locale locale) throws IllegalArgumentException; [EOL] public DateTimeField getField(); [EOL] protected ReadablePartial getReadablePartial(); [EOL] public MonthDay getMonthDay(); [EOL] public int get(); [EOL] public MonthDay addToCopy(int valueToAdd); [EOL] public MonthDay addWrapFieldToCopy(int valueToAdd); [EOL] public MonthDay setCopy(int value); [EOL] public MonthDay setCopy(String text, Locale locale); [EOL] public MonthDay setCopy(String text); [EOL] long serialVersionUID=2954560699050434609L; [EOL] DateTimeFieldType[] FIELD_TYPES=new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() };
public Property dayOfMonth() { [EOL] return new Property(this, DAY_OF_MONTH); [EOL] } [EOL] public MonthDay(); [EOL] public MonthDay(DateTimeZone zone); [EOL] public MonthDay(Chronology chronology); [EOL] public MonthDay(long instant); [EOL] public MonthDay(long instant, Chronology chronology); [EOL] public MonthDay(Object instant); [EOL] public MonthDay(Object instant, Chronology chronology); [EOL] public MonthDay(int monthOfYear, int dayOfMonth); [EOL] public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology); [EOL] MonthDay(MonthDay partial, int[] values); [EOL] MonthDay(MonthDay partial, Chronology chrono); [EOL] Property(MonthDay partial, int fieldIndex); [EOL] public static MonthDay now(); [EOL] public static MonthDay now(DateTimeZone zone); [EOL] public static MonthDay now(Chronology chronology); [EOL] public static MonthDay parse(String str); [EOL] public static MonthDay parse(String str, DateTimeFormatter formatter); [EOL] public static MonthDay fromCalendarFields(Calendar calendar); [EOL] public static MonthDay fromDateFields(Date date); [EOL] private Object readResolve(); [EOL] public int size(); [EOL] protected DateTimeField getField(int index, Chronology chrono); [EOL] public DateTimeFieldType getFieldType(int index); [EOL] public DateTimeFieldType[] getFieldTypes(); [EOL] public MonthDay withChronologyRetainFields(Chronology newChronology); [EOL] public MonthDay withField(DateTimeFieldType fieldType, int value); [EOL] public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); [EOL] public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); [EOL] public MonthDay plus(ReadablePeriod period); [EOL] public MonthDay plusMonths(int months); [EOL] public MonthDay plusDays(int days); [EOL] public MonthDay minus(ReadablePeriod period); [EOL] public MonthDay minusMonths(int months); [EOL] public MonthDay minusDays(int days); [EOL] public LocalDate toLocalDate(int year); [EOL] public int getMonthOfYear(); [EOL] public int getDayOfMonth(); [EOL] public MonthDay withMonthOfYear(int monthOfYear); [EOL] public MonthDay withDayOfMonth(int dayOfMonth); [EOL] public Property property(DateTimeFieldType type); [EOL] public Property monthOfYear(); [EOL] public Property dayOfMonth(); [EOL] public String toString(); [EOL] public String toString(String pattern); [EOL] public String toString(String pattern, Locale locale) throws IllegalArgumentException; [EOL] public DateTimeField getField(); [EOL] protected ReadablePartial getReadablePartial(); [EOL] public MonthDay getMonthDay(); [EOL] public int get(); [EOL] public MonthDay addToCopy(int valueToAdd); [EOL] public MonthDay addWrapFieldToCopy(int valueToAdd); [EOL] public MonthDay setCopy(int value); [EOL] public MonthDay setCopy(String text, Locale locale); [EOL] public MonthDay setCopy(String text); [EOL] long serialVersionUID=2954560699050434609L; [EOL] DateTimeFieldType[] FIELD_TYPES=new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public void testToStringWithNullPattern() { [EOL] MonthDay monthDay = new MonthDay(); [EOL] String defaultToString = monthDay.toString(); [EOL] String result = monthDay.toString(null); [EOL] assertEquals(defaultToString, result); [EOL] }
public void testToStringWithValidPattern() { [EOL] MonthDay monthDay = new MonthDay(); [EOL] String pattern = "MM-dd"; [EOL] String expected = DateTimeFormat.forPattern(pattern).print(monthDay); [EOL] String result = monthDay.toString(pattern); [EOL] assertEquals(expected, result); [EOL] }
public void testToStringWithInvalidPattern() { [EOL] MonthDay monthDay = new MonthDay(); [EOL] String pattern = "invalid-pattern"; [EOL] try { [EOL] monthDay.toString(pattern); [EOL] fail("Should have thrown IllegalArgumentException for invalid pattern"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
Property(MonthDay partial, int fieldIndex) { [EOL] super(); [EOL] iBase = partial; [EOL] iFieldIndex = fieldIndex; [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=2954560699050434609L; DateTimeFieldType[] FIELD_TYPES=new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() };
public DateTimeField getField() { [EOL] return iBase.getField(iFieldIndex); [EOL] } [EOL] public MonthDay(); [EOL] public MonthDay(DateTimeZone zone); [EOL] public MonthDay(Chronology chronology); [EOL] public MonthDay(long instant); [EOL] public MonthDay(long instant, Chronology chronology); [EOL] public MonthDay(Object instant); [EOL] public MonthDay(Object instant, Chronology chronology); [EOL] public MonthDay(int monthOfYear, int dayOfMonth); [EOL] public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology); [EOL] MonthDay(MonthDay partial, int[] values); [EOL] MonthDay(MonthDay partial, Chronology chrono); [EOL] Property(MonthDay partial, int fieldIndex); [EOL] public static MonthDay now(); [EOL] public static MonthDay now(DateTimeZone zone); [EOL] public static MonthDay now(Chronology chronology); [EOL] public static MonthDay parse(String str); [EOL] public static MonthDay parse(String str, DateTimeFormatter formatter); [EOL] public static MonthDay fromCalendarFields(Calendar calendar); [EOL] public static MonthDay fromDateFields(Date date); [EOL] private Object readResolve(); [EOL] public int size(); [EOL] protected DateTimeField getField(int index, Chronology chrono); [EOL] public DateTimeFieldType getFieldType(int index); [EOL] public DateTimeFieldType[] getFieldTypes(); [EOL] public MonthDay withChronologyRetainFields(Chronology newChronology); [EOL] public MonthDay withField(DateTimeFieldType fieldType, int value); [EOL] public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); [EOL] public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); [EOL] public MonthDay plus(ReadablePeriod period); [EOL] public MonthDay plusMonths(int months); [EOL] public MonthDay plusDays(int days); [EOL] public MonthDay minus(ReadablePeriod period); [EOL] public MonthDay minusMonths(int months); [EOL] public MonthDay minusDays(int days); [EOL] public LocalDate toLocalDate(int year); [EOL] public int getMonthOfYear(); [EOL] public int getDayOfMonth(); [EOL] public MonthDay withMonthOfYear(int monthOfYear); [EOL] public MonthDay withDayOfMonth(int dayOfMonth); [EOL] public Property property(DateTimeFieldType type); [EOL] public Property monthOfYear(); [EOL] public Property dayOfMonth(); [EOL] public String toString(); [EOL] public String toString(String pattern); [EOL] public String toString(String pattern, Locale locale) throws IllegalArgumentException; [EOL] public DateTimeField getField(); [EOL] protected ReadablePartial getReadablePartial(); [EOL] public MonthDay getMonthDay(); [EOL] public int get(); [EOL] public MonthDay addToCopy(int valueToAdd); [EOL] public MonthDay addWrapFieldToCopy(int valueToAdd); [EOL] public MonthDay setCopy(int value); [EOL] public MonthDay setCopy(String text, Locale locale); [EOL] public MonthDay setCopy(String text); [EOL] long serialVersionUID=2954560699050434609L; [EOL] DateTimeFieldType[] FIELD_TYPES=new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() };
protected ReadablePartial getReadablePartial() { [EOL] return iBase; [EOL] } [EOL] public MonthDay(); [EOL] public MonthDay(DateTimeZone zone); [EOL] public MonthDay(Chronology chronology); [EOL] public MonthDay(long instant); [EOL] public MonthDay(long instant, Chronology chronology); [EOL] public MonthDay(Object instant); [EOL] public MonthDay(Object instant, Chronology chronology); [EOL] public MonthDay(int monthOfYear, int dayOfMonth); [EOL] public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology); [EOL] MonthDay(MonthDay partial, int[] values); [EOL] MonthDay(MonthDay partial, Chronology chrono); [EOL] Property(MonthDay partial, int fieldIndex); [EOL] public static MonthDay now(); [EOL] public static MonthDay now(DateTimeZone zone); [EOL] public static MonthDay now(Chronology chronology); [EOL] public static MonthDay parse(String str); [EOL] public static MonthDay parse(String str, DateTimeFormatter formatter); [EOL] public static MonthDay fromCalendarFields(Calendar calendar); [EOL] public static MonthDay fromDateFields(Date date); [EOL] private Object readResolve(); [EOL] public int size(); [EOL] protected DateTimeField getField(int index, Chronology chrono); [EOL] public DateTimeFieldType getFieldType(int index); [EOL] public DateTimeFieldType[] getFieldTypes(); [EOL] public MonthDay withChronologyRetainFields(Chronology newChronology); [EOL] public MonthDay withField(DateTimeFieldType fieldType, int value); [EOL] public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); [EOL] public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); [EOL] public MonthDay plus(ReadablePeriod period); [EOL] public MonthDay plusMonths(int months); [EOL] public MonthDay plusDays(int days); [EOL] public MonthDay minus(ReadablePeriod period); [EOL] public MonthDay minusMonths(int months); [EOL] public MonthDay minusDays(int days); [EOL] public LocalDate toLocalDate(int year); [EOL] public int getMonthOfYear(); [EOL] public int getDayOfMonth(); [EOL] public MonthDay withMonthOfYear(int monthOfYear); [EOL] public MonthDay withDayOfMonth(int dayOfMonth); [EOL] public Property property(DateTimeFieldType type); [EOL] public Property monthOfYear(); [EOL] public Property dayOfMonth(); [EOL] public String toString(); [EOL] public String toString(String pattern); [EOL] public String toString(String pattern, Locale locale) throws IllegalArgumentException; [EOL] public DateTimeField getField(); [EOL] protected ReadablePartial getReadablePartial(); [EOL] public MonthDay getMonthDay(); [EOL] public int get(); [EOL] public MonthDay addToCopy(int valueToAdd); [EOL] public MonthDay addWrapFieldToCopy(int valueToAdd); [EOL] public MonthDay setCopy(int value); [EOL] public MonthDay setCopy(String text, Locale locale); [EOL] public MonthDay setCopy(String text); [EOL] long serialVersionUID=Optional[2954560699050434609L]; [EOL] DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }];
public int get() { [EOL] return iBase.getValue(iFieldIndex); [EOL] } [EOL] public MonthDay() { [EOL] } [EOL] public MonthDay(DateTimeZone zone) { [EOL] } [EOL] public MonthDay(Chronology chronology) { [EOL] } [EOL] public MonthDay(long instant) { [EOL] } [EOL] public MonthDay(long instant, Chronology chronology) { [EOL] } [EOL] public MonthDay(Object instant) { [EOL] } [EOL] public MonthDay(Object instant, Chronology chronology) { [EOL] } [EOL] public MonthDay(int monthOfYear, int dayOfMonth) { [EOL] } [EOL] public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology) { [EOL] } [EOL] MonthDay(MonthDay partial, int[] values) { [EOL] } [EOL] MonthDay(MonthDay partial, Chronology chrono) { [EOL] } [EOL] Property(MonthDay partial, int fieldIndex) { [EOL] } [EOL] public static MonthDay now() { [EOL] } [EOL] public static MonthDay now(DateTimeZone zone) { [EOL] } [EOL] public static MonthDay now(Chronology chronology) { [EOL] } [EOL] public static MonthDay parse(String str) { [EOL] } [EOL] public static MonthDay parse(String str, DateTimeFormatter formatter) { [EOL] } [EOL] public static MonthDay fromCalendarFields(Calendar calendar) { [EOL] } [EOL] public static MonthDay fromDateFields(Date date) { [EOL] } [EOL] private Object readResolve() { [EOL] } [EOL] public int size() { [EOL] } [EOL] protected DateTimeField getField(int index, Chronology chrono) { [EOL] } [EOL] public DateTimeFieldType getFieldType(int index) { [EOL] } [EOL] public DateTimeFieldType[] getFieldTypes() { [EOL] } [EOL] public MonthDay withChronologyRetainFields(Chronology newChronology) { [EOL] } [EOL] public MonthDay withField(DateTimeFieldType fieldType, int value) { [EOL] } [EOL] public MonthDay withFieldAdded(DurationFieldType fieldType, int amount) { [EOL] } [EOL] public MonthDay withPeriodAdded(ReadablePeriod period, int scalar) { [EOL] } [EOL] public MonthDay plus(ReadablePeriod period) { [EOL] } [EOL] public MonthDay plusMonths(int months) { [EOL] } [EOL] public MonthDay plusDays(int days) { [EOL] } [EOL] public MonthDay minus(ReadablePeriod period) { [EOL] } [EOL] public MonthDay minusMonths(int months) { [EOL] } [EOL] public MonthDay minusDays(int days) { [EOL] } [EOL] public LocalDate toLocalDate(int year) { [EOL] } [EOL] public int getMonthOfYear() { [EOL] } [EOL] public int getDayOfMonth() { [EOL] } [EOL] public MonthDay withMonthOfYear(int monthOfYear) { [EOL] } [EOL] public MonthDay withDayOfMonth(int dayOfMonth) { [EOL] } [EOL] public Property property(DateTimeFieldType type) { [EOL] } [EOL] public Property monthOfYear() { [EOL] } [EOL] public Property dayOfMonth() { [EOL] } [EOL] public String toString() { [EOL] } [EOL] public String toString(String pattern) { [EOL] } [EOL] public String toString(String pattern, Locale locale) throws IllegalArgumentException { [EOL] } [EOL] public DateTimeField getField() { [EOL] } [EOL] protected ReadablePartial getReadablePartial() { [EOL] } [EOL] public MonthDay getMonthDay() { [EOL] } [EOL] public int get() { [EOL] } [EOL] public MonthDay addToCopy(int valueToAdd) { [EOL] } [EOL] public MonthDay addWrapFieldToCopy(int valueToAdd) { [EOL] } [EOL] public MonthDay setCopy(int value) { [EOL] } [EOL] public MonthDay setCopy(String text, Locale locale) { [EOL] } [EOL] public MonthDay setCopy(String text) { [EOL] } [EOL] long serialVersionUID=2954560699050434609L; [EOL] DateTimeFieldType[] FIELD_TYPES=new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() };
public void testNowWithNullChronology() { [EOL] try { [EOL] Time.now(null); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException e) { [EOL] assertEquals("Chronology must not be null", e.getMessage()); [EOL] } [EOL] }
public void testNowWithNonNullChronology() { [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] LocalDateTime result = Time.now(chronology); [EOL] assertNotNull(result); [EOL] assertEquals(chronology, result.getChronology()); [EOL] }
public void testParseWithValidString() { [EOL] String validDateTimeString = "2023-03-10T15:30:00"; [EOL] LocalDateTime result = parse(validDateTimeString); [EOL] assertNotNull(result); [EOL] assertEquals(LocalDateTime.of(2023, 3, 10, 15, 30), result); [EOL] }
public void testParseWithValidDateString() { [EOL] String validDateString = "2023-03-10"; [EOL] LocalDateTime result = parse(validDateString); [EOL] assertNotNull(result); [EOL] assertEquals(LocalDateTime.of(2023, 3, 10, 0, 0), result); [EOL] }
public void testParseWithInvalidString() { [EOL] String invalidDateTimeString = "invalid-date-time"; [EOL] try { [EOL] parse(invalidDateTimeString); [EOL] fail("Should have thrown an exception for invalid date time string"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testParseValidDateTime() { [EOL] String validDateTimeStr = "2023-03-15T10:15:30"; [EOL] DateTimeFormatter formatter = DateTimeFormatter.ISO_LOCAL_DATE_TIME; [EOL] LocalDateTime result = parse(validDateTimeStr, formatter); [EOL] assertEquals(LocalDateTime.of(2023, 3, 15, 10, 15, 30), result); [EOL] }
public void testParseInvalidDateTime() { [EOL] String invalidDateTimeStr = "invalid-date-time"; [EOL] DateTimeFormatter formatter = DateTimeFormatter.ISO_LOCAL_DATE_TIME; [EOL] try { [EOL] parse(invalidDateTimeStr, formatter); [EOL] fail("Should have thrown DateTimeParseException"); [EOL] } catch (DateTimeParseException e) { [EOL] } [EOL] }
public void testParseWithCustomFormatter() { [EOL] String customFormattedDateTimeStr = "15 Mar 2023 10:15 AM"; [EOL] DateTimeFormatter formatter = DateTimeFormatter.ofPattern("dd MMM yyyy hh:mm a"); [EOL] LocalDateTime result = parse(customFormattedDateTimeStr, formatter); [EOL] assertEquals(LocalDateTime.of(2023, 3, 15, 10, 15), result); [EOL] }
public void testFromDateFieldsWithNullDate() { [EOL] try { [EOL] LocalDateTime.fromDateFields(null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("The date must not be null", e.getMessage()); [EOL] } [EOL] }
public void testFromDateFieldsWithNegativeTime() { [EOL] Date date = new Date(-1); [EOL] LocalDateTime result = LocalDateTime.fromDateFields(date); [EOL] assertNotNull(result); [EOL] assertEquals(1969, result.getYear()); [EOL] }
public void testFromDateFieldsWithPositiveTime() { [EOL] Date date = new Date(1); [EOL] LocalDateTime result = LocalDateTime.fromDateFields(date); [EOL] assertNotNull(result); [EOL] assertEquals(1970, result.getYear()); [EOL] assertEquals(1, result.getMonthOfYear()); [EOL] assertEquals(1, result.getDayOfMonth()); [EOL] assertEquals(0, result.getHourOfDay()); [EOL] assertEquals(0, result.getMinuteOfHour()); [EOL] assertEquals(0, result.getSecondOfMinute()); [EOL] assertEquals(1, result.getMillisOfSecond()); [EOL] }
public void testReadResolve_ChronologyNull() { [EOL] YourClass obj = new YourClass(localMillisValue, null); [EOL] Object result = obj.readResolve(); [EOL] assertTrue(result instanceof LocalDateTime); [EOL] assertEquals(ISOChronology.getInstanceUTC(), ((LocalDateTime) result).getChronology()); [EOL] }
public void testReadResolve_ChronologyNotUTC() { [EOL] YourClass obj = new YourClass(localMillisValue, nonUTCChronology); [EOL] Object result = obj.readResolve(); [EOL] assertTrue(result instanceof LocalDateTime); [EOL] assertEquals(nonUTCChronology.withUTC(), ((LocalDateTime) result).getChronology()); [EOL] }
public void testReadResolve_ChronologyUTC() { [EOL] YourClass obj = new YourClass(localMillisValue, ISOChronology.getInstanceUTC()); [EOL] Object result = obj.readResolve(); [EOL] assertSame(obj, result); [EOL] }
public void testGetWithNullType() { [EOL] try { [EOL] DateTime testDateTime = new DateTime(); [EOL] testDateTime.get(null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("The DateTimeFieldType must not be null", ex.getMessage()); [EOL] } [EOL] }
public void testGetWithValidType() { [EOL] DateTime testDateTime = new DateTime(); [EOL] DateTimeFieldType type = DateTimeFieldType.dayOfMonth(); [EOL] int value = testDateTime.get(type); [EOL] assertEquals(testDateTime.getDayOfMonth(), value); [EOL] }
public void testIsSupported_NullType() { [EOL] DateTime testDateTime = new DateTime(); [EOL] boolean result = testDateTime.isSupported(null); [EOL] assertFalse(result); [EOL] }
public void testIsSupported_SupportedType() { [EOL] DateTime testDateTime = new DateTime(); [EOL] DateTimeFieldType type = DateTimeFieldType.dayOfMonth(); [EOL] boolean result = testDateTime.isSupported(type); [EOL] assertTrue(result); [EOL] }
public void testIsSupported_UnsupportedType() { [EOL] DateTime testDateTime = new DateTime(); [EOL] DateTimeFieldType type = new DateTimeFieldType("unsupported") { [EOL] private static final long serialVersionUID = 1L; [EOL] public DurationFieldType getDurationType() { [EOL] return DurationFieldType.days(); [EOL] } [EOL] public DurationFieldType getRangeDurationType() { [EOL] return null; [EOL] } [EOL] public DateTimeField getField(Chronology chronology) { [EOL] return UnsupportedDateTimeField.getInstance(this, UnsupportedDurationField.getInstance(getDurationType())); [EOL] } [EOL] }; [EOL] boolean result = testDateTime.isSupported(type); [EOL] assertFalse(result); [EOL] }
public void testEquals_SameObject() { [EOL] LocalDateTime dateTime = new LocalDateTime(); [EOL] assertTrue(dateTime.equals(dateTime)); [EOL] }
public void testEquals_DifferentObjectSameValues() { [EOL] LocalDateTime dateTime1 = new LocalDateTime(12345678L, new ChronologyStub()); [EOL] LocalDateTime dateTime2 = new LocalDateTime(12345678L, new ChronologyStub()); [EOL] assertTrue(dateTime1.equals(dateTime2)); [EOL] }
public void testEquals_DifferentObjectDifferentValues() { [EOL] LocalDateTime dateTime1 = new LocalDateTime(12345678L, new ChronologyStub()); [EOL] LocalDateTime dateTime2 = new LocalDateTime(87654321L, new ChronologyStub()); [EOL] assertFalse(dateTime1.equals(dateTime2)); [EOL] }
public void testEquals_DifferentChronology() { [EOL] LocalDateTime dateTime1 = new LocalDateTime(12345678L, new ChronologyStub()); [EOL] LocalDateTime dateTime2 = new LocalDateTime(12345678L, new DifferentChronologyStub()); [EOL] assertFalse(dateTime1.equals(dateTime2)); [EOL] }
public void testEquals_NonLocalDateTime() { [EOL] LocalDateTime dateTime = new LocalDateTime(); [EOL] String nonDateTime = "Not a LocalDateTime"; [EOL] assertFalse(dateTime.equals(nonDateTime)); [EOL] }
public void testEquals_Null() { [EOL] LocalDateTime dateTime = new LocalDateTime(); [EOL] assertFalse(dateTime.equals(null)); [EOL] }
public void testToDateTime() { [EOL] LocalDate localDate = new LocalDate(); [EOL] DateTime result = localDate.toDateTime(); [EOL] assertNotNull(result); [EOL] assertEquals(localDate.toDateTime(DateTimeZone.UTC).getZone(), result.getZone()); [EOL] }
public void testWithDate_Normal() { [EOL] LocalDateTime dateTime = new LocalDateTime(2023, 3, 25, 10, 0); // Example initial date [EOL] int year = 2024; [EOL] int monthOfYear = 6; [EOL] int dayOfMonth = 15; [EOL] LocalDateTime updatedDateTime = dateTime.withDate(year, monthOfYear, dayOfMonth); [EOL] assertEquals(year, updatedDateTime.getYear()); [EOL] assertEquals(monthOfYear, updatedDateTime.getMonthOfYear()); [EOL] assertEquals(dayOfMonth, updatedDateTime.getDayOfMonth()); [EOL] }
public void testWithDate_LeapYear() { [EOL] LocalDateTime dateTime = new LocalDateTime(2023, 3, 25, 10, 0); // Example initial date [EOL] int year = 2024; // Leap year [EOL] int monthOfYear = 2; [EOL] int dayOfMonth = 29; // Valid day in a leap year [EOL] LocalDateTime updatedDateTime = dateTime.withDate(year, monthOfYear, dayOfMonth); [EOL] assertEquals(year, updatedDateTime.getYear()); [EOL] assertEquals(monthOfYear, updatedDateTime.getMonthOfYear()); [EOL] assertEquals(dayOfMonth, updatedDateTime.getDayOfMonth()); [EOL] }
public void testWithDate_InvalidMonth() { [EOL] LocalDateTime dateTime = new LocalDateTime(2023, 3, 25, 10, 0); // Example initial date [EOL] int year = 2023; [EOL] int monthOfYear = 13; // Invalid month [EOL] int dayOfMonth = 1; [EOL] try { [EOL] dateTime.withDate(year, monthOfYear, dayOfMonth); [EOL] fail("Should have thrown an exception for invalid month"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testWithDate_InvalidDay() { [EOL] LocalDateTime dateTime = new LocalDateTime(2023, 3, 25, 10, 0); // Example initial date [EOL] int year = 2023; [EOL] int monthOfYear = 2; [EOL] int dayOfMonth = 30; // Invalid day for February [EOL] try { [EOL] dateTime.withDate(year, monthOfYear, dayOfMonth); [EOL] fail("Should have thrown an exception for invalid day"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testPlusWeeks_ZeroWeeks() { [EOL] LocalDateTime dateTime = LocalDateTime.now(); [EOL] LocalDateTime sameDateTime = dateTime.plusWeeks(0); [EOL] assertEquals(dateTime, sameDateTime); [EOL] }
public void testPlusWeeks_PositiveWeeks() { [EOL] LocalDateTime dateTime = LocalDateTime.now(); [EOL] LocalDateTime futureDateTime = dateTime.plusWeeks(3); [EOL] assertNotEquals(dateTime, futureDateTime); [EOL] assertEquals(3, Weeks.weeksBetween(dateTime, futureDateTime).getWeeks()); [EOL] }
public void testPlusWeeks_NegativeWeeks() { [EOL] LocalDateTime dateTime = LocalDateTime.now(); [EOL] LocalDateTime pastDateTime = dateTime.plusWeeks(-2); [EOL] assertNotEquals(dateTime, pastDateTime); [EOL] assertEquals(-2, Weeks.weeksBetween(dateTime, pastDateTime).getWeeks()); [EOL] }
public void testMinusMillis_Zero() { [EOL] LocalDateTime dateTime = LocalDateTime.now(); [EOL] LocalDateTime result = dateTime.minusMillis(0); [EOL] assertEquals(dateTime, result); [EOL] }
public void testMinusMillis_Negative() { [EOL] LocalDateTime dateTime = LocalDateTime.now(); [EOL] long initialMillis = dateTime.getChronology().millis().get(dateTime.getLocalMillis()); [EOL] LocalDateTime result = dateTime.minusMillis(-1); [EOL] long resultMillis = result.getChronology().millis().get(result.getLocalMillis()); [EOL] assertTrue(initialMillis > resultMillis); [EOL] }
public void testMinusMillis_Positive() { [EOL] LocalDateTime dateTime = LocalDateTime.now(); [EOL] long initialMillis = dateTime.getChronology().millis().get(dateTime.getLocalMillis()); [EOL] LocalDateTime result = dateTime.minusMillis(1); [EOL] long resultMillis = result.getChronology().millis().get(result.getLocalMillis()); [EOL] assertTrue(initialMillis < resultMillis); [EOL] }
public void testPropertyWithNullFieldType() { [EOL] try { [EOL] DateTime testDateTime = new DateTime(); [EOL] testDateTime.property(null); [EOL] fail("Should have thrown IllegalArgumentException for null DateTimeFieldType"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("The DateTimeFieldType must not be null", ex.getMessage()); [EOL] } [EOL] }
public void testPropertyWithUnsupportedFieldType() { [EOL] try { [EOL] DateTime testDateTime = new DateTime(); [EOL] DateTimeFieldType fieldType = DateTimeFieldType.centuryOfEra(); [EOL] if (!testDateTime.isSupported(fieldType)) { [EOL] testDateTime.property(fieldType); [EOL] fail("Should have thrown IllegalArgumentException for unsupported DateTimeFieldType"); [EOL] } [EOL] } catch (IllegalArgumentException ex) { [EOL] assertTrue(ex.getMessage().contains("Field '")); [EOL] assertTrue(ex.getMessage().contains("' is not supported")); [EOL] } [EOL] }
public void testPropertyWithSupportedFieldType() { [EOL] DateTime testDateTime = new DateTime(); [EOL] DateTimeFieldType fieldType = DateTimeFieldType.year(); [EOL] if (testDateTime.isSupported(fieldType)) { [EOL] Property property = testDateTime.property(fieldType); [EOL] assertNotNull(property); [EOL] assertEquals(fieldType.getField(testDateTime.getChronology()), property.getField()); [EOL] } [EOL] }
public void testEraProperty() { [EOL] DateTime dateTime = new DateTime(); [EOL] Property eraProperty = dateTime.era(); [EOL] assertNotNull("Era property should not be null", eraProperty); [EOL] assertSame("Chronology era should be the same as the property's era", dateTime.getChronology().era(), eraProperty.getField()); [EOL] assertSame("DateTime should be the same as the property's DateTime", dateTime, eraProperty.getDateTime()); [EOL] }
public void testYearOfCentury() { [EOL] Time time = new Time(); // Assuming Time is the class where yearOfCentury() is defined [EOL] Property result = time.yearOfCentury(); [EOL] assertNotNull("Property should not be null", result); [EOL] assertEquals("Incorrect year of century", expectedYearOfCentury, result.get()); [EOL] }
public void testWeekOfWeekyear() { [EOL] DateTime dateTime = new DateTime(); [EOL] Property property = dateTime.weekOfWeekyear(); [EOL] assertNotNull(property); [EOL] assertEquals(dateTime.getChronology().weekOfWeekyear(), property.getField()); [EOL] assertEquals(dateTime.getWeekOfWeekyear(), property.get()); [EOL] }
public void testDayOfYear() { [EOL] DateTime dateTime = new DateTime(); [EOL] Property property = dateTime.dayOfYear(); [EOL] assertNotNull(property); [EOL] assertEquals(dateTime.getChronology().dayOfYear(), property.getField()); [EOL] assertEquals(dateTime.get(DateTimeFieldType.dayOfYear()), property.get()); [EOL] }
public void testDayOfWeek() { [EOL] DateTime dateTime = new DateTime(); [EOL] Property property = dateTime.dayOfWeek(); [EOL] assertNotNull(property); [EOL] assertEquals(dateTime.getChronology().dayOfWeek(), property.getField()); [EOL] assertEquals(dateTime, property.getReadableInstant()); [EOL] }
public void testMillisOfDay() { [EOL] DateTime dateTime = new DateTime(); [EOL] Property property = dateTime.millisOfDay(); [EOL] assertNotNull(property); [EOL] assertEquals(dateTime.getChronology().millisOfDay(), property.getField()); [EOL] assertEquals(dateTime.getMillis(), property.getMillis()); [EOL] }
public void testToString() { [EOL] DateTime dateTime = new DateTime(2023, 4, 1, 12, 0); [EOL] String expected = ISODateTimeFormat.dateTime().print(dateTime); [EOL] assertEquals(expected, dateTime.toString()); [EOL] }
public void testRoundFloorCopy() { [EOL] DateTimeField mockField = Mockito.mock(DateTimeField.class); [EOL] LocalDateTime testInstant = new LocalDateTime(2023, 3, 25, 10, 15, 20, 250); [EOL] LocalDateTime.Property property = new LocalDateTime.Property(testInstant, mockField); [EOL] long testMillis = testInstant.getLocalMillis(); [EOL] Mockito.when(mockField.roundFloor(testMillis)).thenReturn(testMillis); [EOL] LocalDateTime rounded = property.roundFloorCopy(); [EOL] assertNotNull(rounded); [EOL] assertEquals(testInstant, rounded); [EOL] }
public void testRoundCeilingCopy() { [EOL] DateTimeField mockField = Mockito.mock(DateTimeField.class); [EOL] LocalDateTime testInstant = new LocalDateTime(2023, 3, 25, 10, 15, 20, 250); [EOL] LocalDateTime.Property property = new LocalDateTime.Property(testInstant, mockField); [EOL] long testMillis = testInstant.getLocalMillis(); [EOL] Mockito.when(mockField.roundCeiling(testMillis)).thenReturn(testMillis); [EOL] LocalDateTime result = property.roundCeilingCopy(); [EOL] assertEquals(testInstant, result); [EOL] }
public void testRoundCeilingCopyWithDifferentMillis() { [EOL] DateTimeField mockField = Mockito.mock(DateTimeField.class); [EOL] LocalDateTime testInstant = new LocalDateTime(2023, 3, 25, 10, 15, 20, 250); [EOL] LocalDateTime.Property property = new LocalDateTime.Property(testInstant, mockField); [EOL] long testMillis = testInstant.getLocalMillis(); [EOL] long roundedMillis = testMillis + 1000; // Assuming the ceiling would add 1 second [EOL] Mockito.when(mockField.roundCeiling(testMillis)).thenReturn(roundedMillis); [EOL] LocalDateTime result = property.roundCeilingCopy(); [EOL] assertNotEquals(testInstant, result); [EOL] assertEquals(new LocalDateTime(roundedMillis), result); [EOL] }
public void testRoundHalfFloorCopy() { [EOL] DateTimeField mockField = Mockito.mock(DateTimeField.class); [EOL] LocalDateTime testInstant = new LocalDateTime(2023, 4, 15, 10, 30); [EOL] LocalDateTime expected = new LocalDateTime(2023, 4, 15, 10, 0); [EOL] Mockito.when(mockField.roundHalfFloor(testInstant.getLocalMillis())).thenReturn(expected.getLocalMillis()); [EOL] LocalDateTime.Property property = new LocalDateTime.Property(testInstant, mockField); [EOL] LocalDateTime result = property.roundHalfFloorCopy(); [EOL] assertEquals(expected, result); [EOL] }
public void testRoundHalfCeilingCopy() { [EOL] DateTimeFieldType fieldType = DateTimeFieldType.minuteOfHour(); [EOL] DateTimeField field = fieldType.getField(DateTimeZone.UTC); [EOL] LocalDateTime instant = new LocalDateTime(2023, 3, 15, 12, 34, 56, 123); [EOL] LocalDateTime.Property property = new LocalDateTime.Property(instant, field); [EOL] LocalDateTime rounded = property.roundHalfCeilingCopy(); [EOL] assertEquals(new LocalDateTime(2023, 3, 15, 12, 35, 0, 0), rounded); [EOL] }
public void testRoundHalfEvenCopy() { [EOL] DateTimeField mockField = Mockito.mock(DateTimeField.class); [EOL] LocalDateTime testInstant = new LocalDateTime(2023, 4, 1, 12, 0); [EOL] LocalDateTime expected = new LocalDateTime(2023, 4, 1, 12, 0); [EOL] when(mockField.roundHalfEven(testInstant.getLocalMillis())).thenReturn(expected.getLocalMillis()); [EOL] LocalDateTime.Property property = new LocalDateTime.Property(testInstant, mockField); [EOL] LocalDateTime result = property.roundHalfEvenCopy(); [EOL] assertEquals(expected, result); [EOL] }
public void testDateTimeFormatterConstructorWithValidPrinterAndParser() { [EOL] DateTimePrinter printer = new MockDateTimePrinter(); [EOL] DateTimeParser parser = new MockDateTimeParser(); [EOL] DateTimeFormatter formatter = new DateTimeFormatter(printer, parser); [EOL] assertNotNull(formatter); [EOL] assertEquals(printer, formatter.getPrinter()); [EOL] assertEquals(parser, formatter.getParser()); [EOL] assertNull(formatter.getLocale()); [EOL] assertFalse(formatter.isOffsetParsed()); [EOL] assertNull(formatter.getChronology()); [EOL] assertNull(formatter.getZone()); [EOL] assertNull(formatter.getPivotYear()); [EOL] assertEquals(2000, formatter.getDefaultYear()); [EOL] }
public void testIsPrinterWhenIPrinterIsNull() { [EOL] Time time = new Time(); [EOL] time.iPrinter = null; [EOL] assertFalse(time.isPrinter()); [EOL] }
public void testIsPrinterWhenIPrinterIsNotNull() { [EOL] Time time = new Time(); [EOL] time.iPrinter = new Printer(); // Assuming Printer is a valid class that can be instantiated [EOL] assertTrue(time.isPrinter()); [EOL] }
public void testIsParserWhenParserIsNull() { [EOL] Time time = new Time(); [EOL] time.iParser = null; [EOL] assertFalse(time.isParser()); [EOL] }
public void testIsParserWhenParserIsNotNull() { [EOL] Time time = new Time(); [EOL] time.iParser = new Parser(); [EOL] assertTrue(time.isParser()); [EOL] }
public void printTo_withNullInstant() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] ReadableInstant instant = null; [EOL] printTo(buf, instant); [EOL] } [EOL] public void printTo_withNonNullInstant() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] ReadableInstant instant = new DateTime(); // Using current time for the test [EOL] printTo(buf, instant); [EOL] }
public void testPrintWithNullInstant() { [EOL] try { [EOL] String result = print(null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] } [EOL] public void testPrintWithValidInstant() { [EOL] ReadableInstant instant = new Instant(); [EOL] String result = print(instant); [EOL] assertNotNull("The print result should not be null", result); [EOL] assertFalse("The print result should not be empty", result.isEmpty()); [EOL] }
public void testPrintToWithPositiveOffset() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] long instant = System.currentTimeMillis(); [EOL] Chronology chrono = ISOChronology.getInstance(); [EOL] printTo(buf, instant, chrono); [EOL] } [EOL] public void testPrintToWithNegativeOffset() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] long instant = System.currentTimeMillis(); [EOL] Chronology chrono = ISOChronology.getInstanceUTC(); [EOL] DateTimeZone fixedOffsetZone = DateTimeZone.forOffsetHours(-1); [EOL] Chronology chronoWithFixedOffset = chrono.withZone(fixedOffsetZone); [EOL] printTo(buf, instant, chronoWithFixedOffset); [EOL] } [EOL] public void testPrintToWithZeroOffset() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] long instant = System.currentTimeMillis(); [EOL] Chronology chrono = ISOChronology.getInstanceUTC(); [EOL] DateTimeZone zeroOffsetZone = DateTimeZone.forOffsetHours(0); [EOL] Chronology chronoWithZeroOffset = chrono.withZone(zeroOffsetZone); [EOL] printTo(buf, instant, chronoWithZeroOffset); [EOL] } [EOL] public void testPrintToWithOffsetChangeCausingNegativeAdjustedInstant() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] long instant = -1; // A value that will cause overflow when offset is added [EOL] Chronology chrono = ISOChronology.getInstance(); [EOL] DateTimeZone largeOffsetZone = DateTimeZone.forOffsetHours(24); [EOL] Chronology chronoWithLargeOffset = chrono.withZone(largeOffsetZone); [EOL] printTo(buf, instant, chronoWithLargeOffset); [EOL] }
public void testRequirePrinterWithNonNullPrinter() { [EOL] DateTimePrinter printer = new DateTimePrinter(); // Assuming DateTimePrinter is a valid class [EOL] Time time = new Time(printer); // Assuming Time is the class where requirePrinter is defined and it has a constructor that accepts a DateTimePrinter [EOL] DateTimePrinter result = time.requirePrinter(); [EOL] assertNotNull(result); [EOL] }
public void testRequirePrinterWithNullPrinter() { [EOL] Time time = new Time(null); // Assuming Time has a constructor that accepts a null printer [EOL] try { [EOL] time.requirePrinter(); [EOL] fail("Should have thrown UnsupportedOperationException"); [EOL] } catch (UnsupportedOperationException e) { [EOL] assertEquals("Printing not supported", e.getMessage()); [EOL] } [EOL] }
public void testParseDateTimeWithFullParse() { [EOL] String text = "2023-03-20T10:15:30"; [EOL] DateTime result = parseDateTime(text); [EOL] assertNotNull(result); [EOL] assertEquals("Parsed DateTime does not match expected value", new DateTime(2023, 3, 20, 10, 15, 30, 0), result); [EOL] } [EOL] public void testParseDateTimeWithPartialParse() { [EOL] String text = "2023-03-20T"; [EOL] try { [EOL] parseDateTime(text); [EOL] fail("Should have thrown IllegalArgumentException due to partial parse"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] } [EOL] public void testParseDateTimeWithInvalidFormat() { [EOL] String text = "invalid-date-time"; [EOL] try { [EOL] parseDateTime(text); [EOL] fail("Should have thrown IllegalArgumentException due to invalid format"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] } [EOL] public void testParseDateTimeWithOffsetParsed() { [EOL] String text = "2023-03-20T10:15:30+04:00"; [EOL] iOffsetParsed = true; [EOL] DateTime result = parseDateTime(text); [EOL] assertNotNull(result); [EOL] int expectedOffsetMillis = 4 * 60 * 60 * 1000; [EOL] assertEquals("Parsed DateTime with offset does not have the correct offset", expectedOffsetMillis, result.getZone().getOffset(result)); [EOL] } [EOL] public void testParseDateTimeWithZone() { [EOL] String text = "2023-03-20T10:15:30"; [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/London"); [EOL] iZone = zone; [EOL] DateTime result = parseDateTime(text); [EOL] assertNotNull(result); [EOL] assertEquals("Parsed DateTime does not have the correct zone", zone, result.getZone()); [EOL] } [EOL] public void testParseDateTimeWithBucketZone() { [EOL] String text = "2023-03-20T10:15:30"; [EOL] DateTimeZone bucketZone = DateTimeZone.forID("America/New_York"); [EOL] DateTime result = parseDateTime(text); [EOL] assertNotNull(result); [EOL] assertEquals("Parsed DateTime does not have the correct zone from the bucket", bucketZone, result.getZone()); [EOL] }
public void testRequireParser_WithNonNullParser() { [EOL] DateTimeFormatter dtf = new DateTimeFormatterBuilder().appendLiteral("test").toFormatter(); [EOL] DateTimeParser parser = dtf.getParser(); [EOL] assertNotNull("Expected non-null parser", parser); [EOL] assertEquals("Expected the same parser", parser, dtf.requireParser()); [EOL] }
public void testRequireParser_WithNullParser() { [EOL] DateTimeFormatter dtf = new DateTimeFormatterBuilder().toFormatter(); [EOL] try { [EOL] dtf.requireParser(); [EOL] fail("Expected UnsupportedOperationException"); [EOL] } catch (UnsupportedOperationException e) { [EOL] } [EOL] }
public void testSetWithEmptyPartial() { [EOL] ReadablePartial emptyPartial = new Partial(); // Assuming Partial implements ReadablePartial [EOL] long instant = System.currentTimeMillis(); [EOL] long result = set(emptyPartial, instant); [EOL] assertEquals(instant, result); [EOL] } [EOL] public void testSetWithNonEmptyPartial() { [EOL] ReadablePartial nonEmptyPartial = new Partial( [EOL] new DateTimeFieldType[] {DateTimeFieldType.year(), DateTimeFieldType.monthOfYear()}, [EOL] new int[] {2023, 4} [EOL] ); // Assuming Partial implements ReadablePartial and is constructed with DateTimeFieldType and values [EOL] long instant = System.currentTimeMillis(); [EOL] long result = set(nonEmptyPartial, instant); [EOL] assertNotEquals(instant, result); // Assuming that setting the fields will change the instant [EOL] }
public void testGetWithNonZeroDurationAndPreciseFields() { [EOL] ReadablePeriod mockPeriod = mock(ReadablePeriod.class); [EOL] DurationField mockField = mock(DurationField.class); [EOL] when(mockPeriod.size()).thenReturn(2); [EOL] when(mockPeriod.getFieldType(0)).thenReturn(DurationFieldType.seconds()); [EOL] when(mockPeriod.getFieldType(1)).thenReturn(DurationFieldType.minutes()); [EOL] when(mockField.isPrecise()).thenReturn(true); [EOL] when(mockField.getDifference(anyLong(), anyLong())).thenReturn(1); [EOL] when(mockField.add(anyLong(), anyInt())).thenReturn(1L); [EOL] when(DurationFieldType.seconds().getField(this)).thenReturn(mockField); [EOL] when(DurationFieldType.minutes().getField(this)).thenReturn(mockField); [EOL] int[] result = get(mockPeriod, 1000L); [EOL] verify(mockField, times(2)).isPrecise(); [EOL] verify(mockField, times(2)).getDifference(anyLong(), anyLong()); [EOL] verify(mockField, times(2)).add(anyLong(), anyInt()); [EOL] assertEquals(2, result.length); [EOL] assertEquals(1, result[0]); [EOL] assertEquals(1, result[1]); [EOL] }
public void testGetWithZeroDuration() { [EOL] ReadablePeriod mockPeriod = mock(ReadablePeriod.class); [EOL] when(mockPeriod.size()).thenReturn(2); [EOL] int[] result = get(mockPeriod, 0L); [EOL] assertEquals(2, result.length); [EOL] assertEquals(0, result[0]); [EOL] assertEquals(0, result[1]); [EOL] }
public void testGetWithNonZeroDurationAndImpreciseFields() { [EOL] ReadablePeriod mockPeriod = mock(ReadablePeriod.class); [EOL] DurationField mockField = mock(DurationField.class); [EOL] when(mockPeriod.size()).thenReturn(2); [EOL] when(mockPeriod.getFieldType(0)).thenReturn(DurationFieldType.seconds()); [EOL] when(mockPeriod.getFieldType(1)).thenReturn(DurationFieldType.minutes()); [EOL] when(mockField.isPrecise()).thenReturn(false); [EOL] when(DurationFieldType.seconds().getField(this)).thenReturn(mockField); [EOL] when(DurationFieldType.minutes().getField(this)).thenReturn(mockField); [EOL] int[] result = get(mockPeriod, 1000L); [EOL] verify(mockField, times(2)).isPrecise(); [EOL] assertEquals(2, result.length); [EOL] assertEquals(0, result[0]); [EOL] assertEquals(0, result[1]); [EOL] }
public void testAdd_ZeroDuration() { [EOL] long instant = 123456789L; [EOL] long duration = 0L; [EOL] int scalar = 5; [EOL] long result = add(instant, duration, scalar); [EOL] assertEquals(instant, result); [EOL] }
public void testAdd_ZeroScalar() { [EOL] long instant = 123456789L; [EOL] long duration = 100L; [EOL] int scalar = 0; [EOL] long result = add(instant, duration, scalar); [EOL] assertEquals(instant, result); [EOL] }
public void testAdd_NonZeroDurationScalar() { [EOL] long instant = 123456789L; [EOL] long duration = 100L; [EOL] int scalar = 5; [EOL] long result = add(instant, duration, scalar); [EOL] assertEquals(123456789L + 100L * 5, result); [EOL] }
public void testIsSupported() { [EOL] Time time = new Time(); [EOL] assertTrue(time.isSupported()); [EOL] }
public final long getUnitMillis() { [EOL] return 1; [EOL] }
public void testGetValueWithZeroDuration() { [EOL] int result = getValue(0L, 0L); [EOL] assertEquals(0, result); [EOL] }
public void testGetValueWithPositiveDuration() { [EOL] int result = getValue(123456789L, 0L); [EOL] assertEquals(123456789, result); [EOL] }
public void testGetValueWithNegativeDuration() { [EOL] int result = getValue(-123456789L, 0L); [EOL] assertEquals(-123456789, result); [EOL] }
public void testGetValueWithMaxIntDuration() { [EOL] int result = getValue(Integer.MAX_VALUE, 0L); [EOL] assertEquals(Integer.MAX_VALUE, result); [EOL] }
public void testGetValueWithMinIntDuration() { [EOL] int result = getValue(Integer.MIN_VALUE, 0L); [EOL] assertEquals(Integer.MIN_VALUE, result); [EOL] }
public long getValueAsLongTest() { [EOL] long expected = 12345L; [EOL] long duration = 12345L; [EOL] long instant = 67890L; [EOL] long result = getValueAsLong(duration, instant); [EOL] assert result == expected; [EOL] }
public long addTestWithPositiveValues() { [EOL] long instant = 1000L; [EOL] long value = 500L; [EOL] long expected = 1500L; [EOL] long result = add(instant, value); [EOL] assertEquals(expected, result); [EOL] } [EOL] public long addTestWithNegativeValues() { [EOL] long instant = 1000L; [EOL] long value = -500L; [EOL] long expected = 500L; [EOL] long result = add(instant, value); [EOL] assertEquals(expected, result); [EOL] } [EOL] public long addTestWithZero() { [EOL] long instant = 1000L; [EOL] long value = 0L; [EOL] long expected = 1000L; [EOL] long result = add(instant, value); [EOL] assertEquals(expected, result); [EOL] } [EOL] public long addTestWithMaxLong() { [EOL] long instant = Long.MAX_VALUE; [EOL] long value = 0L; [EOL] long expected = Long.MAX_VALUE; [EOL] long result = add(instant, value); [EOL] assertEquals(expected, result); [EOL] } [EOL] public long addTestWithMinLong() { [EOL] long instant = Long.MIN_VALUE; [EOL] long value = 0L; [EOL] long expected = Long.MIN_VALUE; [EOL] long result = add(instant, value); [EOL] assertEquals(expected, result); [EOL] } [EOL] public long addTestWithOverflow() { [EOL] long instant = Long.MAX_VALUE; [EOL] long value = 1L; [EOL] try { [EOL] add(instant, value); [EOL] fail("Should have thrown ArithmeticException due to overflow"); [EOL] } catch (ArithmeticException e) { [EOL] } [EOL] } [EOL] public long addTestWithUnderflow() { [EOL] long instant = Long.MIN_VALUE; [EOL] long value = -1L; [EOL] try { [EOL] add(instant, value); [EOL] fail("Should have thrown ArithmeticException due to underflow"); [EOL] } catch (ArithmeticException e) { [EOL] } [EOL] }
public void testCompareTo_SameUnitMillis() { [EOL] DurationField field1 = new DurationField(1000); [EOL] DurationField field2 = new DurationField(1000); [EOL] int result = field1.compareTo(field2); [EOL] assertEquals(0, result); [EOL] }
public void testCompareTo_LessUnitMillis() { [EOL] DurationField field1 = new DurationField(500); [EOL] DurationField field2 = new DurationField(1000); [EOL] int result = field1.compareTo(field2); [EOL] assertEquals(-1, result); [EOL] }
public void testCompareTo_GreaterUnitMillis() { [EOL] DurationField field1 = new DurationField(1500); [EOL] DurationField field2 = new DurationField(1000); [EOL] int result = field1.compareTo(field2); [EOL] assertEquals(1, result); [EOL] }
public void testWeekyearOfCentury() { [EOL] DateTimeFieldType type = ClassName.weekyearOfCentury(); [EOL] assertNotNull("WeekyearOfCentury should not be null", type); [EOL] assertEquals("Type should be equal to WEEKYEAR_OF_CENTURY_TYPE", ClassName.WEEKYEAR_OF_CENTURY_TYPE, type); [EOL] }
public void testYearOfCentury() { [EOL] DateTimeFieldType type = ClassName.yearOfCentury(); [EOL] assertNotNull(type); [EOL] assertEquals("yearOfCentury", type.getName()); [EOL] }
public void testEquals_Reflexive() { [EOL] StandardDateTimeFieldType fieldType = StandardDateTimeFieldType.year(); [EOL] assertTrue(fieldType.equals(fieldType)); [EOL] }
public void testEquals_SameOrdinal() { [EOL] StandardDateTimeFieldType fieldType1 = StandardDateTimeFieldType.year(); [EOL] StandardDateTimeFieldType fieldType2 = StandardDateTimeFieldType.year(); [EOL] assertTrue(fieldType1.equals(fieldType2)); [EOL] }
public void testEquals_DifferentOrdinal() { [EOL] StandardDateTimeFieldType fieldType1 = StandardDateTimeFieldType.year(); [EOL] StandardDateTimeFieldType fieldType2 = StandardDateTimeFieldType.monthOfYear(); [EOL] assertFalse(fieldType1.equals(fieldType2)); [EOL] }
public void testEquals_Null() { [EOL] StandardDateTimeFieldType fieldType = StandardDateTimeFieldType.year(); [EOL] assertFalse(fieldType.equals(null)); [EOL] }
public void testEquals_DifferentClass() { [EOL] StandardDateTimeFieldType fieldType = StandardDateTimeFieldType.year(); [EOL] Object obj = new Object(); [EOL] assertFalse(fieldType.equals(obj)); [EOL] }
public void testGetFieldWithEra() { [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] int iOrdinal = ERA; [EOL] DateTimeField field = getField(chronology, iOrdinal); [EOL] assertEquals(chronology.era(), field); [EOL] }
public void testGetFieldWithYearOfEra() { [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] int iOrdinal = YEAR_OF_ERA; [EOL] DateTimeField field = getField(chronology, iOrdinal); [EOL] assertEquals(chronology.yearOfEra(), field); [EOL] }
public void testGetFieldWithCenturyOfEra() { [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] int iOrdinal = CENTURY_OF_ERA; [EOL] DateTimeField field = getField(chronology, iOrdinal); [EOL] assertEquals(chronology.centuryOfEra(), field); [EOL] }
public void testGetFieldWithYearOfCentury() { [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] int iOrdinal = YEAR_OF_CENTURY; [EOL] DateTimeField field = getField(chronology, iOrdinal); [EOL] assertEquals(chronology.yearOfCentury(), field); [EOL] }
public void testGetFieldWithYear() { [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] int iOrdinal = YEAR; [EOL] DateTimeField field = getField(chronology, iOrdinal); [EOL] assertEquals(chronology.year(), field); [EOL] }
public void testGetFieldWithDayOfYear() { [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] int iOrdinal = DAY_OF_YEAR; [EOL] DateTimeField field = getField(chronology, iOrdinal); [EOL] assertEquals(chronology.dayOfYear(), field); [EOL] }
public void testGetFieldWithMonthOfYear() { [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] int iOrdinal = MONTH_OF_YEAR; [EOL] DateTimeField field = getField(chronology, iOrdinal); [EOL] assertEquals(chronology.monthOfYear(), field); [EOL] }
public void testGetFieldWithDayOfMonth() { [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] int iOrdinal = DAY_OF_MONTH; [EOL] DateTimeField field = getField(chronology, iOrdinal); [EOL] assertEquals(chronology.dayOfMonth(), field); [EOL] }
public void testGetFieldWithWeekyearOfCentury() { [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] int iOrdinal = WEEKYEAR_OF_CENTURY; [EOL] DateTimeField field = getField(chronology, iOrdinal); [EOL] assertEquals(chronology.weekyearOfCentury(), field); [EOL] }
public void testGetFieldWithWeekyear() { [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] int iOrdinal = WEEKYEAR; [EOL] DateTimeField field = getField(chronology, iOrdinal); [EOL] assertEquals(chronology.weekyear(), field); [EOL] }
public void testGetFieldWithWeekOfWeekyear() { [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] int iOrdinal = WEEK_OF_WEEKYEAR; [EOL] DateTimeField field = getField(chronology, iOrdinal); [EOL] assertEquals(chronology.weekOfWeekyear(), field); [EOL] }
public void testGetFieldWithDayOfWeek() { [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] int iOrdinal = DAY_OF_WEEK; [EOL] DateTimeField field = getField(chronology, iOrdinal); [EOL] assertEquals(chronology.dayOfWeek(), field); [EOL] }
public void testGetFieldWithHalfdayOfDay() { [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] int iOrdinal = HALFDAY_OF_DAY; [EOL] DateTimeField field = getField(chronology, iOrdinal); [EOL] assertEquals(chronology.halfdayOfDay(), field); [EOL] }
public void testGetFieldWithHourOfHalfday() { [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] int iOrdinal = HOUR_OF_HALFDAY; [EOL] DateTimeField field = getField(chronology, iOrdinal); [EOL] assertEquals(chronology.hourOfHalfday(), field); [EOL] }
public void testGetFieldWithClockhourOfHalfday() { [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] int iOrdinal = CLOCKHOUR_OF_HALFDAY; [EOL] DateTimeField field = getField(chronology, iOrdinal); [EOL] assertEquals(chronology.clockhourOfHalfday(), field); [EOL] }
public void testGetFieldWithClockhourOfDay() { [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] int iOrdinal = CLOCKHOUR_OF_DAY; [EOL] DateTimeField field = getField(chronology, iOrdinal); [EOL] assertEquals(chronology.clockhourOfDay(), field); [EOL] }
public void testGetFieldWithHourOfDay() { [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] int iOrdinal = HOUR_OF_DAY; [EOL] DateTimeField field = getField(chronology, iOrdinal); [EOL] assertEquals(chronology.hourOfDay(), field); [EOL] }
public void testGetFieldWithMinuteOfDay() { [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] int iOrdinal = MINUTE_OF_DAY; [EOL] DateTimeField field = getField(chronology, iOrdinal); [EOL] assertEquals(chronology.minuteOfDay(), field); [EOL] }
public void testGetFieldWithMinuteOfHour() { [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] int iOrdinal = MINUTE_OF_HOUR; [EOL] DateTimeField field = getField(chronology, iOrdinal); [EOL] assertEquals(chronology.minuteOfHour(), field); [EOL] }
public void testGetFieldWithSecondOfDay() { [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] int iOrdinal = SECOND_OF_DAY; [EOL] DateTimeField field = getField(chronology, iOrdinal); [EOL] assertEquals(chronology.secondOfDay(), field); [EOL] }
public void testGetFieldWithSecondOfMinute() { [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] int iOrdinal = SECOND_OF_MINUTE; [EOL] DateTimeField field = getField(chronology, iOrdinal); [EOL] assertEquals(chronology.secondOfMinute(), field); [EOL] }
public void testGetFieldWithMillisOfDay() { [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] int iOrdinal = MILLIS_OF_DAY; [EOL] DateTimeField field = getField(chronology, iOrdinal); [EOL] assertEquals(chronology.millisOfDay(), field); [EOL] }
public void testGetFieldWithMillisOfSecond() { [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] int iOrdinal = MILLIS_OF_SECOND; [EOL] DateTimeField field = getField(chronology, iOrdinal); [EOL] assertEquals(chronology.millisOfSecond(), field); [EOL] }
public void testGetFieldWithInvalidOrdinal() { [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] int iOrdinal = INVALID_ORDINAL; // This should be a constant representing an invalid ordinal value [EOL] try { [EOL] getField(chronology, iOrdinal); [EOL] fail("Should have thrown an InternalError"); [EOL] } catch (InternalError e) { [EOL] } [EOL] }
public void testReadResolveWithERA() { [EOL] MyTimeEnum instance = MyTimeEnum.ERA; [EOL] Object result = instance.readResolve(); [EOL] assertEquals(ERA_TYPE, result); [EOL] } [EOL] public void testReadResolveWithYEAR_OF_ERA() { [EOL] MyTimeEnum instance = MyTimeEnum.YEAR_OF_ERA; [EOL] Object result = instance.readResolve(); [EOL] assertEquals(YEAR_OF_ERA_TYPE, result); [EOL] } [EOL] public void testReadResolveWithCENTURY_OF_ERA() { [EOL] MyTimeEnum instance = MyTimeEnum.CENTURY_OF_ERA; [EOL] Object result = instance.readResolve(); [EOL] assertEquals(CENTURY_OF_ERA_TYPE, result); [EOL] } [EOL] public void testReadResolveWithYEAR_OF_CENTURY() { [EOL] MyTimeEnum instance = MyTimeEnum.YEAR_OF_CENTURY; [EOL] Object result = instance.readResolve(); [EOL] assertEquals(YEAR_OF_CENTURY_TYPE, result); [EOL] } [EOL] public void testReadResolveWithYEAR() { [EOL] MyTimeEnum instance = MyTimeEnum.YEAR; [EOL] Object result = instance.readResolve(); [EOL] assertEquals(YEAR_TYPE, result); [EOL] } [EOL] public void testReadResolveWithDAY_OF_YEAR() { [EOL] MyTimeEnum instance = MyTimeEnum.DAY_OF_YEAR; [EOL] Object result = instance.readResolve(); [EOL] assertEquals(DAY_OF_YEAR_TYPE, result); [EOL] } [EOL] public void testReadResolveWithMONTH_OF_YEAR() { [EOL] MyTimeEnum instance = MyTimeEnum.MONTH_OF_YEAR; [EOL] Object result = instance.readResolve(); [EOL] assertEquals(MONTH_OF_YEAR_TYPE, result); [EOL] } [EOL] public void testReadResolveWithDAY_OF_MONTH() { [EOL] MyTimeEnum instance = MyTimeEnum.DAY_OF_MONTH; [EOL] Object result = instance.readResolve(); [EOL] assertEquals(DAY_OF_MONTH_TYPE, result); [EOL] } [EOL] public void testReadResolveWithWEEKYEAR_OF_CENTURY() { [EOL] MyTimeEnum instance = MyTimeEnum.WEEKYEAR_OF_CENTURY; [EOL] Object result = instance.readResolve(); [EOL] assertEquals(WEEKYEAR_OF_CENTURY_TYPE, result); [EOL] } [EOL] public void testReadResolveWithWEEKYEAR() { [EOL] MyTimeEnum instance = MyTimeEnum.WEEKYEAR; [EOL] Object result = instance.readResolve(); [EOL] assertEquals(WEEKYEAR_TYPE, result); [EOL] } [EOL] public void testReadResolveWithWEEK_OF_WEEKYEAR() { [EOL] MyTimeEnum instance = MyTimeEnum.WEEK_OF_WEEKYEAR; [EOL] Object result = instance.readResolve(); [EOL] assertEquals(WEEK_OF_WEEKYEAR_TYPE, result); [EOL] } [EOL] public void testReadResolveWithDAY_OF_WEEK() { [EOL] MyTimeEnum instance = MyTimeEnum.DAY_OF_WEEK; [EOL] Object result = instance.readResolve(); [EOL] assertEquals(DAY_OF_WEEK_TYPE, result); [EOL] } [EOL] public void testReadResolveWithHALFDAY_OF_DAY() { [EOL] MyTimeEnum instance = MyTimeEnum.HALFDAY_OF_DAY; [EOL] Object result = instance.readResolve(); [EOL] assertEquals(HALFDAY_OF_DAY_TYPE, result); [EOL] } [EOL] public void testReadResolveWithHOUR_OF_HALFDAY() { [EOL] MyTimeEnum instance = MyTimeEnum.HOUR_OF_HALFDAY; [EOL] Object result = instance.readResolve(); [EOL] assertEquals(HOUR_OF_HALFDAY_TYPE, result); [EOL] } [EOL] public void testReadResolveWithCLOCKHOUR_OF_HALFDAY() { [EOL] MyTimeEnum instance = MyTimeEnum.CLOCKHOUR_OF_HALFDAY; [EOL] Object result = instance.readResolve(); [EOL] assertEquals(CLOCKHOUR_OF_HALFDAY_TYPE, result); [EOL] } [EOL] public void testReadResolveWithCLOCKHOUR_OF_DAY() { [EOL] MyTimeEnum instance = MyTimeEnum.CLOCKHOUR_OF_DAY; [EOL] Object result = instance.readResolve(); [EOL] assertEquals(CLOCKHOUR_OF_DAY_TYPE, result); [EOL] } [EOL] public void testReadResolveWithHOUR_OF_DAY() { [EOL] MyTimeEnum instance = MyTimeEnum.HOUR_OF_DAY; [EOL] Object result = instance.readResolve(); [EOL] assertEquals(HOUR_OF_DAY_TYPE, result); [EOL] } [EOL] public void testReadResolveWithMINUTE_OF_DAY() { [EOL] MyTimeEnum instance = MyTimeEnum.MINUTE_OF_DAY; [EOL] Object result = instance.readResolve(); [EOL] assertEquals(MINUTE_OF_DAY_TYPE, result); [EOL] } [EOL] public void testReadResolveWithMINUTE_OF_HOUR() { [EOL] MyTimeEnum instance = MyTimeEnum.MINUTE_OF_HOUR; [EOL] Object result = instance.readResolve(); [EOL] assertEquals(MINUTE_OF_HOUR_TYPE, result); [EOL] } [EOL] public void testReadResolveWithSECOND_OF_DAY() { [EOL] MyTimeEnum instance = MyTimeEnum.SECOND_OF_DAY; [EOL] Object result = instance.readResolve(); [EOL] assertEquals(SECOND_OF_DAY_TYPE, result); [EOL] } [EOL] public void testReadResolveWithSECOND_OF_MINUTE() { [EOL] MyTimeEnum instance = MyTimeEnum.SECOND_OF_MINUTE; [EOL] Object result = instance.readResolve(); [EOL] assertEquals(SECOND_OF_MINUTE_TYPE, result); [EOL] } [EOL] public void testReadResolveWithMILLIS_OF_DAY() { [EOL] MyTimeEnum instance = MyTimeEnum.MILLIS_OF_DAY; [EOL] Object result = instance.readResolve(); [EOL] assertEquals(MILLIS_OF_DAY_TYPE, result); [EOL] } [EOL] public void testReadResolveWithMILLIS_OF_SECOND() { [EOL] MyTimeEnum instance = MyTimeEnum.MILLIS_OF_SECOND; [EOL] Object result = instance.readResolve(); [EOL] assertEquals(MILLIS_OF_SECOND_TYPE, result); [EOL] } [EOL] public void testReadResolveWithDefault() { [EOL] MyTimeEnum instance = MyTimeEnum.UNSUPPORTED; [EOL] Object result = instance.readResolve(); [EOL] assertSame(instance, result); [EOL] }
public class AbstractDurationTest { [EOL] private static class ConcreteDuration extends AbstractDuration { [EOL] } [EOL] public void testAbstractDurationConstructor() { [EOL] ConcreteDuration duration = new ConcreteDuration(); [EOL] } [EOL] }
public void testSetIntoWithNonNullChronology() { [EOL] ReadWritablePeriod mockWritablePeriod = createMockWritablePeriod(); [EOL] ReadableInterval mockInterval = createMockReadableInterval(); [EOL] Chronology mockChronology = createMockChronology(); [EOL] Object intervalAsObject = mockInterval; [EOL] setInto(mockWritablePeriod, intervalAsObject, mockChronology); [EOL] verifyWritablePeriodValues(mockWritablePeriod, mockChronology, mockInterval); [EOL] }
public void testSetIntoWithNullChronology() { [EOL] ReadWritablePeriod mockWritablePeriod = createMockWritablePeriod(); [EOL] ReadableInterval mockInterval = createMockReadableInterval(); [EOL] Chronology mockChronology = null; [EOL] Object intervalAsObject = mockInterval; [EOL] setInto(mockWritablePeriod, intervalAsObject, mockChronology); [EOL] verifyWritablePeriodValues(mockWritablePeriod, DateTimeUtils.getIntervalChronology(mockInterval), mockInterval); [EOL] }
public void testIsReadableIntervalWithNonNullObjectAndChronology() { [EOL] boolean result = isReadableInterval(new Object(), Chronology.getInstance()); [EOL] assertTrue(result); [EOL] }
public void testIsReadableIntervalWithNullObject() { [EOL] boolean result = isReadableInterval(null, Chronology.getInstance()); [EOL] assertTrue(result); [EOL] }
public void testIsReadableIntervalWithNullChronology() { [EOL] boolean result = isReadableInterval(new Object(), null); [EOL] assertTrue(result); [EOL] }
public void testIsReadableIntervalWithNullObjectAndChronology() { [EOL] boolean result = isReadableInterval(null, null); [EOL] assertTrue(result); [EOL] }
public void testSetIntoWithNonNullChronology() { [EOL] ReadWritableInterval writableInterval = mock(ReadWritableInterval.class); [EOL] ReadableInterval inputInterval = mock(ReadableInterval.class); [EOL] Chronology chrono = mock(Chronology.class); [EOL] setInto(writableInterval, inputInterval, chrono); [EOL] verify(writableInterval).setInterval(inputInterval); [EOL] verify(writableInterval).setChronology(chrono); [EOL] }
public void testSetIntoWithNullChronology() { [EOL] ReadWritableInterval writableInterval = mock(ReadWritableInterval.class); [EOL] ReadableInterval inputInterval = mock(ReadableInterval.class); [EOL] Chronology inputChronology = mock(Chronology.class); [EOL] when(inputInterval.getChronology()).thenReturn(inputChronology); [EOL] setInto(writableInterval, inputInterval, null); [EOL] verify(writableInterval).setInterval(inputInterval); [EOL] verify(writableInterval).setChronology(inputChronology); [EOL] }
public void testGetSupportedType() { [EOL] Time time = new Time(); [EOL] Class<?> supportedType = time.getSupportedType(); [EOL] assertEquals(ReadableInterval.class, supportedType); [EOL] }
public void testGetName_NullNameSet() { [EOL] String result = getName(new Locale("en"), "id", "nameKey"); [EOL] assertNull(result); [EOL] }
public void testGetName_NonNullNameSet() { [EOL] String[] mockNameSet = {"first", "second"}; [EOL] when(getNameSet(new Locale("en"), "id", "nameKey")).thenReturn(mockNameSet); [EOL] String result = getName(new Locale("en"), "id", "nameKey"); [EOL] assertEquals("second", result); [EOL] }
public void testGetNameSetWithNullParameters() { [EOL] String[] result = getNameSet(null, null, null); [EOL] assertNull("The result should be null when any parameter is null", result); [EOL] }
public void testGetNameSetWithNewLocaleAndId() { [EOL] Locale locale = new Locale("en"); [EOL] String id = "ID_NEW"; [EOL] String nameKey = "NAME_KEY"; [EOL] String[] result = getNameSet(locale, id, nameKey); [EOL] assertNull("The result should be null when the id is not found", result); [EOL] }
public void testGetNameSetWithExistingLocaleAndId() { [EOL] Locale locale = Locale.ENGLISH; [EOL] String id = "ID_EXISTING"; [EOL] String nameKey = "NAME_KEY_EXISTING"; [EOL] String[] result = getNameSet(locale, id, nameKey); [EOL] assertNotNull("The result should not be null when the id and nameKey exist", result); [EOL] assertEquals("The result should match the expected name key value", "EXPECTED_VALUE", result[0]); [EOL] }
public void testGetNameSetWithDifferentNameKey() { [EOL] Locale locale = Locale.ENGLISH; [EOL] String id = "ID_EXISTING"; [EOL] String nameKey = "NAME_KEY_DIFFERENT"; [EOL] String[] result = getNameSet(locale, id, nameKey); [EOL] assertNull("The result should be null when the nameKey does not exist", result); [EOL] }
public void testGetNameSetWithSummerTimeNameKey() { [EOL] Locale locale = Locale.ENGLISH; [EOL] String id = "ID_EXISTING"; [EOL] String nameKey = "NAME_KEY_SUMMER"; [EOL] String[] result = getNameSet(locale, id, nameKey); [EOL] assertNotNull("The result should not be null when the nameKey exists for summer time", result); [EOL] assertEquals("The result should match the expected summer time name key value", "EXPECTED_SUMMER_VALUE", result[0]); [EOL] }
public void testCreateCache() { [EOL] HashMap cache = createCache(); [EOL] assertNotNull(cache); [EOL] assertEquals(7, cache.size()); [EOL] }
public void testEraTextToValueWithValidEra() { [EOL] String validEraText = "ValidEra"; // Assume this is a valid era text in iParseEras [EOL] int expectedValue = 1; // Assume this is the value associated with the valid era text [EOL] int actualValue = eraTextToValue(validEraText); [EOL] assertEquals(expectedValue, actualValue); [EOL] }
public void testEraTextToValueWithInvalidEra() { [EOL] String invalidEraText = "InvalidEra"; [EOL] try { [EOL] eraTextToValue(invalidEraText); [EOL] fail("Should have thrown IllegalFieldValueException"); [EOL] } catch (IllegalFieldValueException ex) { [EOL] assertEquals(DateTimeFieldType.era(), ex.getFieldType()); [EOL] assertEquals(invalidEraText, ex.getIllegalValue()); [EOL] } [EOL] }
public void testDayOfWeekValueToShortText_ValidValue() { [EOL] Time time = new Time(); [EOL] String result = time.dayOfWeekValueToShortText(1); [EOL] assertEquals("Expected short text for day 1", "Mon", result); [EOL] }
public void testDayOfWeekValueToShortText_InvalidValueLowerBound() { [EOL] Time time = new Time(); [EOL] try { [EOL] time.dayOfWeekValueToShortText(0); [EOL] fail("Should have thrown an exception for value below valid range"); [EOL] } catch (ArrayIndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testDayOfWeekValueToShortText_InvalidValueUpperBound() { [EOL] Time time = new Time(); [EOL] try { [EOL] time.dayOfWeekValueToShortText(8); [EOL] fail("Should have thrown an exception for value above valid range"); [EOL] } catch (ArrayIndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testDayOfWeekTextToValue_ValidDay() { [EOL] int result = dayOfWeekTextToValue("Monday"); [EOL] assertEquals(1, result); [EOL] }
public void testDayOfWeekTextToValue_InvalidDay() { [EOL] try { [EOL] dayOfWeekTextToValue("NotADay"); [EOL] fail("Expected an IllegalFieldValueException to be thrown"); [EOL] } catch (IllegalFieldValueException e) { [EOL] assertEquals(DateTimeFieldType.dayOfWeek(), e.getFieldType()); [EOL] assertEquals("NotADay", e.getIllegalValue()); [EOL] } [EOL] }
public void testToMutableDateTime() { [EOL] DateTime dateTime = new DateTime(0L, DateTimeZone.UTC); [EOL] MutableDateTime mutableDateTime = dateTime.toMutableDateTime(); [EOL] assertNotNull(mutableDateTime); [EOL] assertEquals(0L, mutableDateTime.getMillis()); [EOL] assertEquals(DateTimeZone.UTC, mutableDateTime.getZone()); [EOL] }
public void testToMutableDateTime_WithNonNullZone() { [EOL] DateTime dateTime = new DateTime(2023, 4, 1, 12, 0, DateTimeZone.UTC); [EOL] DateTimeZone newZone = DateTimeZone.forID("Europe/Paris"); [EOL] MutableDateTime mutableDateTime = dateTime.toMutableDateTime(newZone); [EOL] assertNotNull(mutableDateTime); [EOL] assertEquals(newZone, mutableDateTime.getZone()); [EOL] assertEquals(dateTime.getMillis(), mutableDateTime.getMillis()); [EOL] }
public void testToMutableDateTime_WithNullZone() { [EOL] DateTime dateTime = new DateTime(2023, 4, 1, 12, 0, DateTimeZone.UTC); [EOL] MutableDateTime mutableDateTime = dateTime.toMutableDateTime(null); [EOL] assertNotNull(mutableDateTime); [EOL] assertEquals(DateTimeZone.UTC, mutableDateTime.getZone()); [EOL] assertEquals(dateTime.getMillis(), mutableDateTime.getMillis()); [EOL] }
public void testEquals_sameObject() { [EOL] ReadableInstant instant1 = new DateTime(); [EOL] assertTrue(instant1.equals(instant1)); [EOL] }
public void testEquals_differentType() { [EOL] ReadableInstant instant1 = new DateTime(); [EOL] assertFalse(instant1.equals(new Object())); [EOL] }
public void testEquals_null() { [EOL] ReadableInstant instant1 = new DateTime(); [EOL] assertFalse(instant1.equals(null)); [EOL] }
public void testEquals_differentMillis() { [EOL] ReadableInstant instant1 = new DateTime(123456L); [EOL] ReadableInstant instant2 = new DateTime(654321L); [EOL] assertFalse(instant1.equals(instant2)); [EOL] }
public void testEquals_differentChronology() { [EOL] ReadableInstant instant1 = new DateTime(123456L, GregorianChronology.getInstance()); [EOL] ReadableInstant instant2 = new DateTime(123456L, JulianChronology.getInstance()); [EOL] assertFalse(instant1.equals(instant2)); [EOL] }
public void testEquals_sameMillisAndChronology() { [EOL] ReadableInstant instant1 = new DateTime(123456L, GregorianChronology.getInstance()); [EOL] ReadableInstant instant2 = new DateTime(123456L, GregorianChronology.getInstance()); [EOL] assertTrue(instant1.equals(instant2)); [EOL] }
public void testIsBefore_WhenMillisIsLessThanInstant_ShouldReturnTrue() { [EOL] long instant = 1000L; [EOL] Time time = new Time(500L); // Assuming Time is the class and getMillis() returns 500L [EOL] boolean result = time.isBefore(instant); [EOL] assertTrue(result); [EOL] }
public void testIsBefore_WhenMillisIsEqualToInstant_ShouldReturnFalse() { [EOL] long instant = 1000L; [EOL] Time time = new Time(1000L); // Assuming Time is the class and getMillis() returns 1000L [EOL] boolean result = time.isBefore(instant); [EOL] assertFalse(result); [EOL] }
public void testIsBefore_WhenMillisIsGreaterThanInstant_ShouldReturnFalse() { [EOL] long instant = 1000L; [EOL] Time time = new Time(1500L); // Assuming Time is the class and getMillis() returns 1500L [EOL] boolean result = time.isBefore(instant); [EOL] assertFalse(result); [EOL] }
public void testIsBeforeWithNullInstant() { [EOL] DateTime testDateTime = new DateTime(); [EOL] try { [EOL] testDateTime.isBefore((ReadableInstant) null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public void testIsBeforeWithEarlierInstant() { [EOL] DateTime testDateTime = new DateTime(); [EOL] ReadableInstant earlierInstant = new Instant(testDateTime.getMillis() - 1); [EOL] assertTrue(testDateTime.isBefore(earlierInstant)); [EOL] }
public void testIsBeforeWithLaterInstant() { [EOL] DateTime testDateTime = new DateTime(); [EOL] ReadableInstant laterInstant = new Instant(testDateTime.getMillis() + 1); [EOL] assertFalse(testDateTime.isBefore(laterInstant)); [EOL] }
public void testIsBeforeWithSameInstant() { [EOL] DateTime testDateTime = new DateTime(); [EOL] ReadableInstant sameInstant = new Instant(testDateTime.getMillis()); [EOL] assertFalse(testDateTime.isBefore(sameInstant)); [EOL] }
public void testIsEqualWithNull() { [EOL] DateTime dateTime = new DateTime(); [EOL] boolean result = dateTime.isEqual(null); [EOL] assertFalse(result); [EOL] }
public void testIsEqualWithSameInstant() { [EOL] DateTime dateTime = new DateTime(); [EOL] long instantMillis = dateTime.getMillis(); [EOL] ReadableInstant instant = new Instant(instantMillis); [EOL] boolean result = dateTime.isEqual(instant); [EOL] assertTrue(result); [EOL] }
public void testIsEqualWithDifferentInstant() { [EOL] DateTime dateTime = new DateTime(); [EOL] ReadableInstant instant = new Instant(dateTime.getMillis() + 1); [EOL] boolean result = dateTime.isEqual(instant); [EOL] assertFalse(result); [EOL] }
public void testSetIntervalWithBothNull() { [EOL] setInterval(null, null); [EOL] }
public void testSetIntervalWithStartNotNullAndEndNotNull() { [EOL] ReadableInstant start = new DateTime(2020, 1, 1, 0, 0); [EOL] ReadableInstant end = new DateTime(2020, 12, 31, 23, 59); [EOL] setInterval(start, end); [EOL] }
public void testSetIntervalWithStartNullAndEndNotNull() { [EOL] ReadableInstant end = new DateTime(2020, 12, 31, 23, 59); [EOL] setInterval(null, end); [EOL] }
public void testSetIntervalWithStartNotNullAndEndNull() { [EOL] ReadableInstant start = new DateTime(2020, 1, 1, 0, 0); [EOL] setInterval(start, null); [EOL] }
public void setPeriodBeforeEnd_NullPeriod_SetsStartToEnd() { [EOL] TimePeriod testPeriod = new TimePeriod(); [EOL] ReadablePeriod nullPeriod = null; [EOL] long expectedStartMillis = testPeriod.getEndMillis(); [EOL] testPeriod.setPeriodBeforeEnd(nullPeriod); [EOL] assertEquals(expectedStartMillis, testPeriod.getStartMillis()); [EOL] }
public void setPeriodBeforeEnd_NonNullPeriod_SetsStartCorrectly() { [EOL] TimePeriod testPeriod = new TimePeriod(); [EOL] ReadablePeriod nonNullPeriod = new MockReadablePeriod(); [EOL] long expectedStartMillis = testPeriod.getChronology().add(nonNullPeriod, testPeriod.getEndMillis(), -1); [EOL] testPeriod.setPeriodBeforeEnd(nonNullPeriod); [EOL] assertEquals(expectedStartMillis, testPeriod.getStartMillis()); [EOL] }
public void testParseWithValidFormatterAndValidString() { [EOL] DateTimeFormatter formatter = DateTimeFormat.forPattern("yyyy-MM-dd"); [EOL] String validDateString = "2023-01-01"; [EOL] DateMidnight expected = new DateMidnight(2023, 1, 1); [EOL] DateMidnight result = Time.parse(validDateString, formatter); [EOL] assertEquals(expected, result); [EOL] }
public void testParseWithValidFormatterAndInvalidString() { [EOL] DateTimeFormatter formatter = DateTimeFormat.forPattern("yyyy-MM-dd"); [EOL] String invalidDateString = "invalid-date"; [EOL] try { [EOL] Time.parse(invalidDateString, formatter); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testParseWithNullFormatter() { [EOL] String validDateString = "2023-01-01"; [EOL] try { [EOL] Time.parse(validDateString, null); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testDateMidnightWithInstantAndZone() { [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/London"); [EOL] Instant instant = new Instant(); [EOL] DateMidnight dateMidnight = new DateMidnight(instant, zone); [EOL] assertNotNull(dateMidnight); [EOL] assertEquals(zone, dateMidnight.getZone()); [EOL] assertEquals(instant.getMillis(), dateMidnight.getMillis()); [EOL] }
public void testDateMidnightWithNullInstantAndZone() { [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/London"); [EOL] DateMidnight dateMidnight = new DateMidnight((Object) null, zone); [EOL] assertNotNull(dateMidnight); [EOL] assertEquals(zone, dateMidnight.getZone()); [EOL] }
public void testDateMidnightWithNullZone() { [EOL] Instant instant = new Instant(); [EOL] DateMidnight dateMidnight = new DateMidnight(instant, null); [EOL] assertNotNull(dateMidnight); [EOL] assertEquals(DateTimeZone.getDefault(), dateMidnight.getZone()); [EOL] }
public void testDateMidnightWithNullInstantAndNullZone() { [EOL] DateMidnight dateMidnight = new DateMidnight((Object) null, null); [EOL] assertNotNull(dateMidnight); [EOL] assertEquals(DateTimeZone.getDefault(), dateMidnight.getZone()); [EOL] }
public void testDateMidnightWithValidArguments() { [EOL] int year = 2023; [EOL] int monthOfYear = 4; [EOL] int dayOfMonth = 1; [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] DateMidnight dateMidnight = new DateMidnight(year, monthOfYear, dayOfMonth, chronology); [EOL] assertNotNull(dateMidnight); [EOL] assertEquals(year, dateMidnight.getYear()); [EOL] assertEquals(monthOfYear, dateMidnight.getMonthOfYear()); [EOL] assertEquals(dayOfMonth, dateMidnight.getDayOfMonth()); [EOL] assertEquals(chronology, dateMidnight.getChronology()); [EOL] }
public void testDateMidnightWithNullChronology() { [EOL] int year = 2023; [EOL] int monthOfYear = 4; [EOL] int dayOfMonth = 1; [EOL] DateMidnight dateMidnight = new DateMidnight(year, monthOfYear, dayOfMonth, null); [EOL] assertNotNull(dateMidnight); [EOL] assertEquals(year, dateMidnight.getYear()); [EOL] assertEquals(monthOfYear, dateMidnight.getMonthOfYear()); [EOL] assertEquals(dayOfMonth, dateMidnight.getDayOfMonth()); [EOL] assertNotNull(dateMidnight.getChronology()); [EOL] assertTrue(dateMidnight.getChronology() instanceof ISOChronology); [EOL] }
public void testWithMillis_SameMillis() { [EOL] long currentMillis = System.currentTimeMillis(); [EOL] DateMidnight dateMidnight = new DateMidnight(currentMillis); [EOL] DateMidnight result = dateMidnight.withMillis(currentMillis); [EOL] assertSame("Should be the same object as no change in millis", dateMidnight, result); [EOL] }
public void testWithMillis_DifferentMillis() { [EOL] long currentMillis = System.currentTimeMillis(); [EOL] DateMidnight dateMidnight = new DateMidnight(currentMillis); [EOL] long newMillis = currentMillis + 1000; // Adding 1 second [EOL] DateMidnight result = dateMidnight.withMillis(newMillis); [EOL] assertNotSame("Should not be the same object as millis changed", dateMidnight, result); [EOL] assertEquals("The time in milliseconds should be updated", newMillis, result.getMillis()); [EOL] }
public void testWithField_NullFieldType() { [EOL] DateMidnight dateMidnight = new DateMidnight(); [EOL] try { [EOL] dateMidnight.withField(null, 1); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Field must not be null", e.getMessage()); [EOL] } [EOL] }
public void testWithField_ValidField() { [EOL] DateMidnight dateMidnight = new DateMidnight(); [EOL] DateTimeFieldType fieldType = DateTimeFieldType.dayOfMonth(); [EOL] int value = 15; [EOL] DateMidnight updatedDateMidnight = dateMidnight.withField(fieldType, value); [EOL] assertNotNull(updatedDateMidnight); [EOL] assertEquals(value, updatedDateMidnight.getDayOfMonth()); [EOL] }
public void testWithFieldAdded_NullFieldType() { [EOL] try { [EOL] DateMidnight dateMidnight = new DateMidnight(); [EOL] dateMidnight.withFieldAdded(null, 1); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public void testWithFieldAdded_ZeroAmount() { [EOL] DateMidnight dateMidnight = new DateMidnight(); [EOL] DateMidnight result = dateMidnight.withFieldAdded(DurationFieldType.days(), 0); [EOL] assertSame("The same DateMidnight instance should be returned", dateMidnight, result); [EOL] }
public void testWithFieldAdded_NonZeroAmount() { [EOL] DateMidnight dateMidnight = new DateMidnight(); [EOL] DateMidnight result = dateMidnight.withFieldAdded(DurationFieldType.days(), 1); [EOL] assertNotSame("A different DateMidnight instance should be returned", dateMidnight, result); [EOL] assertTrue("The new DateMidnight should have a different millis value", dateMidnight.getMillis() != result.getMillis()); [EOL] }
public void testWithDurationAdded_ZeroDuration() { [EOL] DateMidnight dateMidnight = new DateMidnight(); [EOL] DateMidnight result = dateMidnight.withDurationAdded(0, 1); [EOL] assertSame("Duration added is zero, should return the same object", dateMidnight, result); [EOL] }
public void testWithDurationAdded_ZeroScalar() { [EOL] DateMidnight dateMidnight = new DateMidnight(); [EOL] DateMidnight result = dateMidnight.withDurationAdded(10, 0); [EOL] assertSame("Scalar is zero, should return the same object", dateMidnight, result); [EOL] }
public void testWithDurationAdded_NonZeroDurationAndScalar() { [EOL] DateMidnight dateMidnight = new DateMidnight(); [EOL] DateMidnight result = dateMidnight.withDurationAdded(10, 1); [EOL] assertNotSame("Duration and scalar are non-zero, should return a new object", dateMidnight, result); [EOL] assertNotNull("Resulting DateMidnight should not be null", result); [EOL] assertTrue("Resulting DateMidnight should be after the original", result.isAfter(dateMidnight)); [EOL] }
public void testWithDurationAdded_NullDuration() { [EOL] DateMidnight dateMidnight = new DateMidnight(); [EOL] DateMidnight result = dateMidnight.withDurationAdded(null, 1); [EOL] assertSame(dateMidnight, result); [EOL] }
public void testWithDurationAdded_ZeroScalar() { [EOL] DateMidnight dateMidnight = new DateMidnight(); [EOL] ReadableDuration duration = new Duration(1234); [EOL] DateMidnight result = dateMidnight.withDurationAdded(duration, 0); [EOL] assertSame(dateMidnight, result); [EOL] }
public void testWithDurationAdded_NonNullDurationNonZeroScalar() { [EOL] DateMidnight dateMidnight = new DateMidnight(); [EOL] ReadableDuration duration = new Duration(1234); [EOL] DateMidnight result = dateMidnight.withDurationAdded(duration, 1); [EOL] assertNotSame(dateMidnight, result); [EOL] assertEquals(dateMidnight.getMillis() + duration.getMillis(), result.getMillis()); [EOL] }
public DateMidnight plus(long duration) { [EOL] return withDurationAdded(duration, 1); [EOL] }
public DateMidnight plus(ReadableDuration duration) { [EOL] return withDurationAdded(duration, 1); [EOL] }
public void testMinusYears_ZeroYears() { [EOL] DateMidnight originalDateMidnight = new DateMidnight(); [EOL] DateMidnight resultDateMidnight = originalDateMidnight.minusYears(0); [EOL] assertEquals("Subtracting zero years should not change the date", originalDateMidnight, resultDateMidnight); [EOL] }
public void testMinusYears_NegativeYears() { [EOL] DateMidnight originalDateMidnight = new DateMidnight(); [EOL] DateMidnight resultDateMidnight = originalDateMidnight.minusYears(-1); [EOL] assertNotEquals("Subtracting negative years should change the date", originalDateMidnight, resultDateMidnight); [EOL] }
public void testMinusYears_PositiveYears() { [EOL] DateMidnight originalDateMidnight = new DateMidnight(); [EOL] DateMidnight resultDateMidnight = originalDateMidnight.minusYears(1); [EOL] assertNotEquals("Subtracting positive years should change the date", originalDateMidnight, resultDateMidnight); [EOL] }
public void testPropertyWithNullType() { [EOL] try { [EOL] someObject.property(null); [EOL] fail("Should have thrown IllegalArgumentException for null DateTimeFieldType"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("The DateTimeFieldType must not be null", e.getMessage()); [EOL] } [EOL] }
public void testPropertyWithUnsupportedType() { [EOL] DateTimeFieldType unsupportedType = // create an unsupported DateTimeFieldType [EOL] try { [EOL] someObject.property(unsupportedType); [EOL] fail("Should have thrown IllegalArgumentException for unsupported DateTimeFieldType"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertTrue(e.getMessage().contains("Field '")); [EOL] assertTrue(e.getMessage().contains("' is not supported")); [EOL] } [EOL] }
public void testPropertyWithSupportedType() { [EOL] DateTimeFieldType supportedType = // create a supported DateTimeFieldType [EOL] Property result = someObject.property(supportedType); [EOL] assertNotNull(result); [EOL] }
public void testToLocalDate() { [EOL] DateTime dateTime = new DateTime(2023, 4, 1, 12, 0, 0, 0); [EOL] LocalDate localDate = dateTime.toLocalDate(); [EOL] assertEquals(new LocalDate(2023, 4, 1), localDate); [EOL] }
public void testToIntervalWithDefaultChronology() { [EOL] MyTime time = new MyTime(); // Assuming MyTime is the class containing toInterval() [EOL] Interval result = time.toInterval(); [EOL] assertNotNull(result); [EOL] assertEquals(time.getMillis(), result.getStartMillis()); [EOL] assertEquals(time.getChronology(), result.getChronology()); [EOL] long expectedEndMillis = DurationFieldType.days().getField(time.getChronology()).add(time.getMillis(), 1); [EOL] assertEquals(expectedEndMillis, result.getEndMillis()); [EOL] }
public void testToIntervalWithSpecificChronology() { [EOL] Chronology specificChrono = ISOChronology.getInstanceUTC(); // Example of a specific chronology [EOL] MyTime time = new MyTime(specificChrono); // Assuming MyTime can take a Chronology [EOL] Interval result = time.toInterval(); [EOL] assertNotNull(result); [EOL] assertEquals(time.getMillis(), result.getStartMillis()); [EOL] assertEquals(specificChrono, result.getChronology()); [EOL] long expectedEndMillis = DurationFieldType.days().getField(specificChrono).add(time.getMillis(), 1); [EOL] assertEquals(expectedEndMillis, result.getEndMillis()); [EOL] }
public void testDayOfMonth() { [EOL] LocalDate date = LocalDate.now(); [EOL] Property dom = date.dayOfMonth(); [EOL] assertNotNull(dom); [EOL] assertEquals(date.getChronology().dayOfMonth(), dom.getField()); [EOL] assertEquals(date, dom.getLocalDate()); [EOL] }
protected long getMillis() { [EOL] return iInstant.getMillis(); [EOL] }
public DateMidnight getDateMidnight() { [EOL] return iInstant; [EOL] }
public void testAddToCopy_Zero() { [EOL] DateMidnight initialDateMidnight = new DateMidnight(); [EOL] DateMidnight resultDateMidnight = initialDateMidnight.addToCopy(0); [EOL] assertEquals(initialDateMidnight, resultDateMidnight); [EOL] }
public void testAddToCopy_Positive() { [EOL] DateMidnight initialDateMidnight = new DateMidnight(); [EOL] DateMidnight resultDateMidnight = initialDateMidnight.addToCopy(1); [EOL] assertNotEquals(initialDateMidnight, resultDateMidnight); [EOL] assertEquals(initialDateMidnight.plusDays(1), resultDateMidnight); [EOL] }
public void testAddToCopy_Negative() { [EOL] DateMidnight initialDateMidnight = new DateMidnight(); [EOL] DateMidnight resultDateMidnight = initialDateMidnight.addToCopy(-1); [EOL] assertNotEquals(initialDateMidnight, resultDateMidnight); [EOL] assertEquals(initialDateMidnight.minusDays(1), resultDateMidnight); [EOL] }
public void testSetCopy_ValidValue() { [EOL] DateTimeField mockField = Mockito.mock(DateTimeField.class); [EOL] Instant mockInstant = Mockito.mock(Instant.class); [EOL] long currentMillis = System.currentTimeMillis(); [EOL] int newValue = 5; [EOL] Mockito.when(mockInstant.getMillis()).thenReturn(currentMillis); [EOL] Mockito.when(mockField.set(currentMillis, newValue)).thenReturn(currentMillis + 1000); [EOL] DateMidnight dateMidnight = new DateMidnight(mockInstant, mockField); [EOL] DateMidnight result = dateMidnight.setCopy(newValue); [EOL] assertNotNull(result); [EOL] Mockito.verify(mockField).set(currentMillis, newValue); [EOL] assertEquals(currentMillis + 1000, result.getMillis()); [EOL] }

public DateMidnight withMaximumValue() { [EOL] return setCopy(getMaximumValue()); [EOL] }
public void testWithMinimumValue() { [EOL] DateMidnight dateMidnight = new DateMidnight(); [EOL] DateMidnight minDateMidnight = dateMidnight.withMinimumValue(); [EOL] assertNotNull(minDateMidnight); [EOL] assertEquals(minDateMidnight, dateMidnight.getMinimumValue()); [EOL] }
public void testRoundFloorCopy() { [EOL] DateTimeField mockField = Mockito.mock(DateTimeField.class); [EOL] Instant mockInstant = Mockito.mock(Instant.class); [EOL] long testMillis = 1234567890L; [EOL] Mockito.when(mockInstant.getMillis()).thenReturn(testMillis); [EOL] Mockito.when(mockField.roundFloor(testMillis)).thenReturn(testMillis); [EOL] DateMidnight testDateMidnight = new DateMidnight(mockInstant, mockField); [EOL] DateMidnight roundedDateMidnight = testDateMidnight.roundFloorCopy(); [EOL] assertNotNull("The rounded DateMidnight should not be null", roundedDateMidnight); [EOL] assertEquals("The rounded DateMidnight should have the same millis as the test millis", testMillis, roundedDateMidnight.getMillis()); [EOL] }
public void testRoundCeilingCopy() { [EOL] DateTimeField mockField = Mockito.mock(DateTimeField.class); [EOL] long testMillis = 1234567890L; [EOL] long expectedMillis = 1234567900L; [EOL] Mockito.when(mockField.roundCeiling(testMillis)).thenReturn(expectedMillis); [EOL] DateTime mockInstant = Mockito.mock(DateTime.class); [EOL] Mockito.when(mockInstant.getMillis()).thenReturn(testMillis); [EOL] DateMidnight testDateMidnight = new DateMidnight(mockInstant, mockField); [EOL] DateMidnight result = testDateMidnight.roundCeilingCopy(); [EOL] assertEquals(new DateMidnight(expectedMillis), result); [EOL] }
protected BasePartial(Chronology chronology) { [EOL] this(DateTimeUtils.currentTimeMillis(), chronology); [EOL] }
