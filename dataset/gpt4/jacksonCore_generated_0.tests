public void testVersion() { [EOL] MyClass obj = new MyClass(); [EOL] Version result = obj.version(); [EOL] assertNotNull(result); [EOL] assertEquals(PackageVersion.VERSION, result); [EOL] }
public void testGetParsingContext() { [EOL] JsonReadContext expectedContext = new JsonReadContext(null, null, 1); [EOL] SomeClass instance = new SomeClass(expectedContext); [EOL] JsonReadContext actualContext = instance.getParsingContext(); [EOL] assertEquals(expectedContext, actualContext); [EOL] }
public void testGetTokenLocationWithValidToken() { [EOL] JsonParser parser = createParserWithContent("{ \"key\": \"value\" }"); [EOL] parser.nextToken(); // Move to START_OBJECT [EOL] JsonLocation location = parser.getTokenLocation(); [EOL] assertNotNull(location); [EOL] assertEquals(1, location.getLineNr()); [EOL] assertEquals(1, location.getColumnNr()); [EOL] } [EOL] public void testGetTokenLocationAtEndOfInput() { [EOL] JsonParser parser = createParserWithContent(""); [EOL] JsonLocation location = parser.getTokenLocation(); [EOL] assertNotNull(location); [EOL] assertEquals(-1, location.getLineNr()); [EOL] assertEquals(-1, location.getColumnNr()); [EOL] } [EOL] public void testGetTokenLocationAfterSkippingChildren() { [EOL] JsonParser parser = createParserWithContent("{ \"key\": [1, 2, 3] }"); [EOL] parser.nextToken(); // Move to START_OBJECT [EOL] parser.skipChildren(); // Skip the array [EOL] JsonLocation location = parser.getTokenLocation(); [EOL] assertNotNull(location); [EOL] assertTrue(location.getLineNr() > 1); [EOL] assertTrue(location.getColumnNr() > 1); [EOL] }
public void testGetEmbeddedObjectReturnsNull() throws IOException, JsonParseException { [EOL] JsonParser jp = createJsonParser(); // Assuming createJsonParser() is a method that creates an instance of JsonParser [EOL] Object embeddedObject = jp.getEmbeddedObject(); [EOL] assertNull(embeddedObject); [EOL] }
public void testGetTokenCharacterOffset() { [EOL] JsonParser parser = createParserWithContent("some content"); [EOL] long offset = parser.getTokenCharacterOffset(); [EOL] assertEquals("The token character offset should be correct", expectedOffset, offset); [EOL] }
public void testGetTokenLineNr() { [EOL] JsonParser parser = createParserWithToken(" [EOL] int lineNr = parser.getTokenLineNr(); [EOL] assertEquals("The line number should match", EXPECTED_LINE_NUMBER, lineNr); [EOL] }
public void testGetTokenColumnNr_Positive() { [EOL] JsonParser parser = createParserWithTokenInputCol(5); // Assuming createParserWithTokenInputCol is a helper method [EOL] int columnNr = parser.getTokenColumnNr(); [EOL] assertEquals(6, columnNr); [EOL] }
public void testGetTokenColumnNr_Negative() { [EOL] JsonParser parser = createParserWithTokenInputCol(-1); // Assuming createParserWithTokenInputCol is a helper method [EOL] int columnNr = parser.getTokenColumnNr(); [EOL] assertEquals(-1, columnNr); [EOL] }
protected final void loadMoreGuaranteed() throws IOException { [EOL] if (!loadMore()) { [EOL] _reportInvalidEOF(); [EOL] } [EOL] }
public void testHandleEOFInRootContext() throws JsonParseException { [EOL] JsonParser parser = createParserWithRootContext(); [EOL] parser._handleEOF(); [EOL] } [EOL] public void testHandleEOFNotInRootContext() throws JsonParseException { [EOL] JsonParser parser = createParserWithNonRootContext(); [EOL] try { [EOL] parser._handleEOF(); [EOL] fail("Expected JsonParseException"); [EOL] } catch (JsonParseException e) { [EOL] assertEquals("expected close marker for " + parser.getParsingContext().getTypeDesc() + " (from " + parser.getParsingContext().getStartLocation(parser.getIoContext().getSourceReference()) + ")", e.getMessage()); [EOL] } [EOL] }

public void testGetNumberValue_UnknownNumberType() throws IOException, JsonParseException { [EOL] _numTypesValid = NR_UNKNOWN; [EOL] _numTypesValid = NR_INT; [EOL] _numberInt = 42; // example integer value [EOL] Number result = getNumberValue(); [EOL] assertEquals(42, result.intValue()); [EOL] }
public void testGetNumberValue_IntegerType() throws IOException, JsonParseException { [EOL] _numTypesValid = NR_INT; [EOL] _numberInt = 42; // example integer value [EOL] _currToken = JsonToken.VALUE_NUMBER_INT; [EOL] Number result = getNumberValue(); [EOL] assertEquals(42, result.intValue()); [EOL] }
public void testGetNumberValue_LongType() throws IOException, JsonParseException { [EOL] _numTypesValid = NR_LONG; [EOL] _numberLong = 42L; // example long value [EOL] _currToken = JsonToken.VALUE_NUMBER_INT; [EOL] Number result = getNumberValue(); [EOL] assertEquals(42L, result.longValue()); [EOL] }
public void testGetNumberValue_BigIntType() throws IOException, JsonParseException { [EOL] _numTypesValid = NR_BIGINT; [EOL] _numberBigInt = new BigInteger("42"); // example BigInteger value [EOL] _currToken = JsonToken.VALUE_NUMBER_INT; [EOL] Number result = getNumberValue(); [EOL] assertEquals(new BigInteger("42"), result); [EOL] }
public void testGetNumberValue_BigDecimalType() throws IOException, JsonParseException { [EOL] _numTypesValid = NR_BIGDECIMAL; [EOL] _numberBigDecimal = new BigDecimal("42.0"); // example BigDecimal value [EOL] Number result = getNumberValue(); [EOL] assertEquals(new BigDecimal("42.0"), result); [EOL] }
public void testGetNumberValue_DoubleType() throws IOException, JsonParseException { [EOL] _numTypesValid = NR_DOUBLE; [EOL] _numberDouble = 42.0; // example double value [EOL] Number result = getNumberValue(); [EOL] assertEquals(42.0, result.doubleValue(), 0.0); [EOL] }
public void testGetNumberValue_ThrowInternal() throws IOException, JsonParseException { [EOL] _numTypesValid = 0; // No valid number types [EOL] try { [EOL] getNumberValue(); [EOL] fail("Expected an exception to be thrown"); [EOL] } catch (Exception e) { [EOL] } [EOL] }
public void testParseNumericValueWithIntTokenAndNegativeNumberWithinIntRange() throws IOException, JsonParseException { [EOL] _currToken = JsonToken.VALUE_NUMBER_INT; [EOL] _numberNegative = true; [EOL] _intLength = 9; [EOL] _textBuffer.resetWithShared(new char[]{'-', '2', '1', '4', '7', '4', '8', '3', '6', '4', '8'}, 1, 10); [EOL] _parseNumericValue(NR_INT); [EOL] assertEquals(-214748364, _numberInt); [EOL] assertEquals(NR_INT, _numTypesValid); [EOL] }
public void testParseNumericValueWithIntTokenAndPositiveNumberWithinIntRange() throws IOException, JsonParseException { [EOL] _currToken = JsonToken.VALUE_NUMBER_INT; [EOL] _numberNegative = false; [EOL] _intLength = 9; [EOL] _textBuffer.resetWithShared(new char[]{'2', '1', '4', '7', '4', '8', '3', '6', '4', '7'}, 0, 10); [EOL] _parseNumericValue(NR_INT); [EOL] assertEquals(2147483647, _numberInt); [EOL] assertEquals(NR_INT, _numTypesValid); [EOL] }
public void testParseNumericValueWithIntTokenAndNegativeLong() throws IOException, JsonParseException { [EOL] _currToken = JsonToken.VALUE_NUMBER_INT; [EOL] _numberNegative = true; [EOL] _intLength = 18; [EOL] _textBuffer.resetWithShared(new char[]{'-', '9', '2', '2', '3', '3', '7', '2', '0', '3', '6', '8', '5', '4', '7', '7', '5', '8', '0', '8'}, 1, 19); [EOL] _parseNumericValue(NR_INT); [EOL] assertEquals(-9223372036854775808L, _numberLong); [EOL] assertEquals(NR_LONG, _numTypesValid); [EOL] }
public void testParseNumericValueWithIntTokenAndPositiveLong() throws IOException, JsonParseException { [EOL] _currToken = JsonToken.VALUE_NUMBER_INT; [EOL] _numberNegative = false; [EOL] _intLength = 18; [EOL] _textBuffer.resetWithShared(new char[]{'9', '2', '2', '3', '3', '7', '2', '0', '3', '6', '8', '5', '4', '7', '7', '5', '8', '0', '7'}, 0, 19); [EOL] _parseNumericValue(NR_INT); [EOL] assertEquals(9223372036854775807L, _numberLong); [EOL] assertEquals(NR_LONG, _numTypesValid); [EOL] }
public void testParseNumericValueWithIntTokenAndNumberExceedingLong() throws IOException, JsonParseException { [EOL] _currToken = JsonToken.VALUE_NUMBER_INT; [EOL] _numberNegative = false; [EOL] _intLength = 19; [EOL] _textBuffer.resetWithShared(new char[]{'1', '9', '2', '2', '3', '3', '7', '2', '0', '3', '6', '8', '5', '4', '7', '7', '5', '8', '0', '7'}, 0, 20); [EOL] _parseNumericValue(NR_INT); [EOL] }
public void testParseNumericValueWithFloatToken() throws IOException, JsonParseException { [EOL] _currToken = JsonToken.VALUE_NUMBER_FLOAT; [EOL] _parseNumericValue(NR_INT); [EOL] }
public void testParseNumericValueWithInvalidToken() throws IOException, JsonParseException { [EOL] _currToken = JsonToken.NOT_AVAILABLE; [EOL] Exception exception = assertThrows(JsonParseException.class, () -> { [EOL] _parseNumericValue(NR_INT); [EOL] }); [EOL] assertTrue(exception.getMessage().contains("Current token (NOT_AVAILABLE) not numeric, can not use numeric value accessors")); [EOL] }
public void testConvertNumberToIntWithLongWithinRange() throws IOException, JsonParseException { [EOL] _numTypesValid = NR_LONG; [EOL] _numberLong = (long) Integer.MAX_VALUE; [EOL] convertNumberToInt(); [EOL] assertEquals(_numberInt, (int) _numberLong); [EOL] }
public void testConvertNumberToIntWithLongOutOfRange() throws IOException, JsonParseException { [EOL] _numTypesValid = NR_LONG; [EOL] _numberLong = ((long) Integer.MAX_VALUE) + 1; [EOL] try { [EOL] convertNumberToInt(); [EOL] fail("Should have thrown JsonParseException due to int overflow"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testConvertNumberToIntWithBigIntWithinRange() throws IOException, JsonParseException { [EOL] _numTypesValid = NR_BIGINT; [EOL] _numberBigInt = BigInteger.valueOf(Integer.MAX_VALUE); [EOL] convertNumberToInt(); [EOL] assertEquals(_numberInt, _numberBigInt.intValue()); [EOL] }
public void testConvertNumberToIntWithBigIntOutOfRange() throws IOException, JsonParseException { [EOL] _numTypesValid = NR_BIGINT; [EOL] _numberBigInt = BigInteger.valueOf(((long) Integer.MAX_VALUE) + 1); [EOL] try { [EOL] convertNumberToInt(); [EOL] fail("Should have thrown JsonParseException due to int overflow"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testConvertNumberToIntWithDoubleWithinRange() throws IOException, JsonParseException { [EOL] _numTypesValid = NR_DOUBLE; [EOL] _numberDouble = (double) Integer.MAX_VALUE; [EOL] convertNumberToInt(); [EOL] assertEquals(_numberInt, (int) _numberDouble); [EOL] }
public void testConvertNumberToIntWithDoubleOutOfRange() throws IOException, JsonParseException { [EOL] _numTypesValid = NR_DOUBLE; [EOL] _numberDouble = (double) Integer.MAX_VALUE + 1.0; [EOL] try { [EOL] convertNumberToInt(); [EOL] fail("Should have thrown JsonParseException due to int overflow"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testConvertNumberToIntWithBigDecimalWithinRange() throws IOException, JsonParseException { [EOL] _numTypesValid = NR_BIGDECIMAL; [EOL] _numberBigDecimal = new BigDecimal(Integer.MAX_VALUE); [EOL] convertNumberToInt(); [EOL] assertEquals(_numberInt, _numberBigDecimal.intValue()); [EOL] }
public void testConvertNumberToIntWithBigDecimalOutOfRange() throws IOException, JsonParseException { [EOL] _numTypesValid = NR_BIGDECIMAL; [EOL] _numberBigDecimal = new BigDecimal(((long) Integer.MAX_VALUE) + 1); [EOL] try { [EOL] convertNumberToInt(); [EOL] fail("Should have thrown JsonParseException due to int overflow"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testConvertNumberToIntWithInvalidType() throws IOException, JsonParseException { [EOL] _numTypesValid = 0; // No valid types set [EOL] try { [EOL] convertNumberToInt(); [EOL] fail("Should have thrown IOException due to invalid type"); [EOL] } catch (IOException e) { [EOL] } [EOL] }
protected void convertNumberToLong() throws IOException, JsonParseException { [EOL] if ((_numTypesValid & NR_INT) != 0) { [EOL] _numberLong = (long) _numberInt; [EOL] } else if ((_numTypesValid & NR_BIGINT) != 0) { [EOL] if (BI_MIN_LONG.compareTo(_numberBigInt) > 0 || BI_MAX_LONG.compareTo(_numberBigInt) < 0) { [EOL] reportOverflowLong(); [EOL] } [EOL] _numberLong = _numberBigInt.longValue(); [EOL] } else if ((_numTypesValid & NR_DOUBLE) != 0) { [EOL] if (_numberDouble < MIN_LONG_D || _numberDouble > MAX_LONG_D) { [EOL] reportOverflowLong(); [EOL] } [EOL] _numberLong = (long) _numberDouble; [EOL] } else if ((_numTypesValid & NR_BIGDECIMAL) != 0) { [EOL] if (BD_MIN_LONG.compareTo(_numberBigDecimal) > 0 || BD_MAX_LONG.compareTo(_numberBigDecimal) < 0) { [EOL] reportOverflowLong(); [EOL] } [EOL] _numberLong = _numberBigDecimal.longValue(); [EOL] } else { [EOL] _throwInternal(); [EOL] } [EOL] _numTypesValid |= NR_LONG; [EOL] }
protected void _reportError(String msg) throws JsonParseException { [EOL] throw new JsonParseException(msg, JsonLocation.NA); [EOL] } [EOL] public void testReportInvalidNumber() throws JsonParseException { [EOL] try { [EOL] reportInvalidNumber("Test invalid number message"); [EOL] } catch (JsonParseException e) { [EOL] assertEquals("Invalid numeric value: Test invalid number message", e.getMessage()); [EOL] } [EOL] }
protected void reportOverflowLong() throws IOException, JsonParseException { [EOL] _reportError("Numeric value (" + getText() + ") out of range of long (" + Long.MIN_VALUE + " - " + Long.MAX_VALUE + ")"); [EOL] }
public void testHasMoreBytes_PtrLessThanBufferedEnd() throws IOException { [EOL] _ptr = 0; [EOL] _bufferedEnd = 10; [EOL] boolean result = hasMoreBytes(); [EOL] assertTrue(result); [EOL] } [EOL] public void testHasMoreBytes_InIsNull() throws IOException { [EOL] _ptr = 10; [EOL] _bufferedEnd = 10; [EOL] _in = null; [EOL] boolean result = hasMoreBytes(); [EOL] assertFalse(result); [EOL] } [EOL] public void testHasMoreBytes_AmountLessThanOne() throws IOException { [EOL] _ptr = _buffer.length; [EOL] _bufferedEnd = _buffer.length; [EOL] _in = mock(InputStream.class); [EOL] boolean result = hasMoreBytes(); [EOL] assertFalse(result); [EOL] } [EOL] public void testHasMoreBytes_CountLessThanOrEqualToZero() throws IOException { [EOL] _ptr = _buffer.length - 1; [EOL] _bufferedEnd = _buffer.length - 1; [EOL] _in = mock(InputStream.class); [EOL] when(_in.read(_buffer, _ptr, 1)).thenReturn(0); [EOL] boolean result = hasMoreBytes(); [EOL] assertFalse(result); [EOL] } [EOL] public void testHasMoreBytes_CountGreaterThanZero() throws IOException { [EOL] _ptr = _buffer.length - 1; [EOL] _bufferedEnd = _buffer.length - 1; [EOL] _in = mock(InputStream.class); [EOL] when(_in.read(_buffer, _ptr, 1)).thenReturn(1); [EOL] boolean result = hasMoreBytes(); [EOL] assertTrue(result); [EOL] }
public void testAllocByteBufferWithNullBuffer() { [EOL] YourClassUnderTest instance = new YourClassUnderTest(); [EOL] ByteBufferType type = ByteBufferType.SOME_TYPE; // Replace SOME_TYPE with actual type name [EOL] byte[] result = instance.allocByteBuffer(type); [EOL] assertNotNull(result); [EOL] assertEquals(type.size, result.length); // Assuming size is a public field or there's a getter for it [EOL] }
public void testAllocByteBufferWithExistingBuffer() { [EOL] YourClassUnderTest instance = new YourClassUnderTest(); [EOL] ByteBufferType type = ByteBufferType.SOME_TYPE; // Replace SOME_TYPE with actual type name [EOL] byte[] existingBuffer = new byte[type.size]; // Assuming size is a public field or there's a getter for it [EOL] instance._byteBuffers[type.ordinal()] = existingBuffer; // Directly setting the buffer for the test [EOL] byte[] result = instance.allocByteBuffer(type); [EOL] assertSame(existingBuffer, result); // Check that the existing buffer was returned [EOL] assertNull(instance._byteBuffers[type.ordinal()]); // Check that the buffer slot was set to null [EOL] }
public void testBallocWithZeroSize() { [EOL] int size = 0; [EOL] byte[] result = balloc(size); [EOL] assertNotNull(result); [EOL] assertEquals(0, result.length); [EOL] }
public void testBallocWithPositiveSize() { [EOL] int size = 10; [EOL] byte[] result = balloc(size); [EOL] assertNotNull(result); [EOL] assertEquals(10, result.length); [EOL] }
public void testValueOfWithMime() { [EOL] Base64Variant result = Base64Variant.valueOf("MIME"); [EOL] assertNotNull(result); [EOL] assertEquals(Base64Variant.MIME, result); [EOL] }
public void testValueOfWithMimeNoLinefeeds() { [EOL] Base64Variant result = Base64Variant.valueOf("MIME_NO_LINEFEEDS"); [EOL] assertNotNull(result); [EOL] assertEquals(Base64Variant.MIME_NO_LINEFEEDS, result); [EOL] }
public void testValueOfWithPem() { [EOL] Base64Variant result = Base64Variant.valueOf("PEM"); [EOL] assertNotNull(result); [EOL] assertEquals(Base64Variant.PEM, result); [EOL] }
public void testValueOfWithModifiedForUrl() { [EOL] Base64Variant result = Base64Variant.valueOf("MODIFIED_FOR_URL"); [EOL] assertNotNull(result); [EOL] assertEquals(Base64Variant.MODIFIED_FOR_URL, result); [EOL] }
public void testValueOfWithInvalidName() { [EOL] try { [EOL] Base64Variant.valueOf("INVALID_NAME"); [EOL] fail("IllegalArgumentException expected"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("No Base64Variant with name 'INVALID_NAME'", e.getMessage()); [EOL] } [EOL] }
public void testValueOfWithNull() { [EOL] try { [EOL] Base64Variant.valueOf(null); [EOL] fail("IllegalArgumentException expected"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("No Base64Variant with name <null>", e.getMessage()); [EOL] } [EOL] }
public static int outputInt(int value, char[] buffer, int offset) { [EOL] if (value < 0) { [EOL] if (value == Integer.MIN_VALUE) { [EOL] return outputLong((long) value, buffer, offset); [EOL] } [EOL] buffer[offset++] = '-'; [EOL] value = -value; [EOL] } [EOL] if (value < MILLION) { [EOL] if (value < 1000) { [EOL] if (value < 10) { [EOL] buffer[offset++] = (char) ('0' + value); [EOL] } else { [EOL] offset = outputLeadingTriplet(value, buffer, offset); [EOL] } [EOL] } else { [EOL] int thousands = value / 1000; [EOL] value -= (thousands * 1000); [EOL] offset = outputLeadingTriplet(thousands, buffer, offset); [EOL] offset = outputFullTriplet(value, buffer, offset); [EOL] } [EOL] return offset; [EOL] } [EOL] boolean hasBillions = (value >= BILLION); [EOL] if (hasBillions) { [EOL] value -= BILLION; [EOL] if (value >= BILLION) { [EOL] value -= BILLION; [EOL] buffer[offset++] = '2'; [EOL] } else { [EOL] buffer[offset++] = '1'; [EOL] } [EOL] } [EOL] int newValue = value / 1000; [EOL] int ones = (value - (newValue * 1000)); [EOL] value = newValue; [EOL] newValue /= 1000; [EOL] int thousands = (value - (newValue * 1000)); [EOL] if (hasBillions) { [EOL] offset = outputFullTriplet(newValue, buffer, offset); [EOL] } else { [EOL] offset = outputLeadingTriplet(newValue, buffer, offset); [EOL] } [EOL] offset = outputFullTriplet(thousands, buffer, offset); [EOL] offset = outputFullTriplet(ones, buffer, offset); [EOL] return offset; [EOL] }
private static int outputLeadingTriplet(int triplet, char[] buffer, int offset) { [EOL] int digitOffset = (triplet << 2); [EOL] char c = LEADING_TRIPLETS[digitOffset++]; [EOL] if (c != NULL_CHAR) { [EOL] buffer[offset++] = c; [EOL] } [EOL] c = LEADING_TRIPLETS[digitOffset++]; [EOL] if (c != NULL_CHAR) { [EOL] buffer[offset++] = c; [EOL] } [EOL] buffer[offset++] = LEADING_TRIPLETS[digitOffset]; [EOL] return offset; [EOL] }
public void testResetWhenPastBlocksIsEmpty() { [EOL] TextBuffer textBuffer = new TextBuffer(); [EOL] textBuffer.reset(); [EOL] assertEquals(0, textBuffer._pastLen); [EOL] assertEquals(0, textBuffer._currBlockPtr); [EOL] assertTrue(textBuffer._pastBlocks.isEmpty()); [EOL] }
public void testResetWhenPastBlocksIsNotEmpty() { [EOL] TextBuffer textBuffer = new TextBuffer(); [EOL] textBuffer._pastBlocks.add(new char[10]); // Add a dummy block to simulate non-empty past blocks [EOL] textBuffer._pastLen = 10; // Set past length to a non-zero value [EOL] textBuffer._currBlockPtr = 5; // Set current block pointer to a non-zero value [EOL] textBuffer.reset(); [EOL] assertEquals(0, textBuffer._pastLen); [EOL] assertEquals(0, textBuffer._currBlockPtr); [EOL] assertTrue(textBuffer._pastBlocks.isEmpty()); [EOL] }
public void testToByteArrayWithEmptyBlocks() { [EOL] YourClass instance = new YourClass(); [EOL] byte[] result = instance.toByteArray(); [EOL] assertArrayEquals(YourClass.NO_BYTES, result); [EOL] }
public void testToByteArrayWithNonEmptyBlocks() { [EOL] YourClass instance = new YourClass(); [EOL] instance.setPastLen(10); [EOL] instance.setCurrBlockPtr(5); [EOL] byte[] pastBlock = new byte[10]; [EOL] Arrays.fill(pastBlock, (byte)1); [EOL] instance.addPastBlock(pastBlock); [EOL] byte[] currBlock = new byte[5]; [EOL] Arrays.fill(currBlock, (byte)2); [EOL] instance.setCurrBlock(currBlock); [EOL] byte[] result = instance.toByteArray(); [EOL] byte[] expected = new byte[15]; [EOL] Arrays.fill(expected, 0, 10, (byte)1); [EOL] Arrays.fill(expected, 10, 15, (byte)2); [EOL] assertArrayEquals(expected, result); [EOL] assertTrue(instance.getPastBlocks().isEmpty()); [EOL] }
public void testToByteArrayWithIncorrectTotalLength() { [EOL] YourClass instance = new YourClass(); [EOL] instance.setPastLen(10); [EOL] instance.setCurrBlockPtr(5); [EOL] byte[] pastBlock = new byte[10]; [EOL] Arrays.fill(pastBlock, (byte)1); [EOL] instance.addPastBlock(pastBlock); [EOL] byte[] currBlock = new byte[5]; [EOL] Arrays.fill(currBlock, (byte)2); [EOL] instance.setCurrBlock(currBlock); [EOL] instance.setOffset(20); // Assuming setOffset is a method that can set the internal offset to an incorrect value [EOL] try { [EOL] instance.toByteArray(); [EOL] fail("Expected an RuntimeException to be thrown"); [EOL] } catch (RuntimeException e) { [EOL] assertEquals("Internal error: total len assumed to be 15, copied 20 bytes", e.getMessage()); [EOL] } [EOL] }
public void testFinishCurrentSegment() { [EOL] SegmentFinisher finisher = new SegmentFinisher(); [EOL] byte[] result = finisher.finishCurrentSegment(); [EOL] assertTrue(finisher.isAllocMoreCalled()); [EOL] byte[] expectedBlock = finisher.getExpectedCurrentBlock(); [EOL] assertArrayEquals(expectedBlock, result); [EOL] }
public void testGetCurrentSegment() { [EOL] ByteArrayBuilder bab = new ByteArrayBuilder(); [EOL] byte[] segment = bab.getCurrentSegment(); [EOL] assertNotNull(segment); [EOL] assertEquals(ByteArrayBuilder.DEFAULT_BLOCK_ARRAY_SIZE, segment.length); [EOL] }
public void testSetCurrentSegmentLength() { [EOL] TextBuffer testBuffer = new TextBuffer(); [EOL] testBuffer.setCurrentSegmentLength(10); [EOL] assertEquals(10, testBuffer._currBlockPtr); [EOL] }
public void testGetCurrentSegmentLength() { [EOL] JsonFactory factory = new JsonFactory(); [EOL] JsonParser parser = factory.createParser("[1, 2, 3]"); [EOL] JsonToken token = parser.nextToken(); // Start array [EOL] token = parser.nextToken(); // Get number [EOL] int length = parser.getCurrentSegmentLength(); [EOL] assertEquals(1, length); // Assuming _currBlockPtr starts at 1 [EOL] }
public void test_allocMore_NewSizeGreaterThanMaxBlock() { [EOL] _pastLen = MAX_BLOCK_SIZE; [EOL] _currBlock = new byte[INITIAL_BLOCK_SIZE]; [EOL] _allocMore(); [EOL] assertEquals(MAX_BLOCK_SIZE, _currBlock.length); [EOL] assertEquals(0, _currBlockPtr); [EOL] assertTrue(_pastBlocks.contains(_currBlock)); [EOL] }
public void test_allocMore_NewSizeLessThanMaxBlock() { [EOL] _pastLen = INITIAL_BLOCK_SIZE; [EOL] _currBlock = new byte[INITIAL_BLOCK_SIZE]; [EOL] _allocMore(); [EOL] int expectedNewSize = Math.max((_pastLen >> 1), (INITIAL_BLOCK_SIZE + INITIAL_BLOCK_SIZE)); [EOL] assertEquals(expectedNewSize, _currBlock.length); [EOL] assertEquals(0, _currBlockPtr); [EOL] assertTrue(_pastBlocks.contains(_currBlock)); [EOL] }
public void testParseIntSingleDigit() { [EOL] char[] digitChars = {'3'}; [EOL] int result = JacksonCore.parseInt(digitChars, 0, 1); [EOL] assertEquals(3, result); [EOL] }
public void testParseIntMultipleDigits() { [EOL] char[] digitChars = {'1', '2', '3', '4', '5', '6', '7', '8', '9'}; [EOL] int result = JacksonCore.parseInt(digitChars, 0, 9); [EOL] assertEquals(123456789, result); [EOL] }
public void testParseIntWithOffset() { [EOL] char[] digitChars = {'0', '0', '1', '2', '3'}; [EOL] int result = JacksonCore.parseInt(digitChars, 2, 3); [EOL] assertEquals(123, result); [EOL] }
public void testParseIntWithLeadingZeros() { [EOL] char[] digitChars = {'0', '0', '0', '1', '2', '3'}; [EOL] int result = JacksonCore.parseInt(digitChars, 0, 6); [EOL] assertEquals(123, result); [EOL] }
public void testParseIntWithOffsetAndLength() { [EOL] char[] digitChars = {'0', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'}; [EOL] int result = JacksonCore.parseInt(digitChars, 2, 7); [EOL] assertEquals(1234567, result); [EOL] }
public void testParseIntWithMaxLength() { [EOL] char[] digitChars = {'1', '2', '3', '4', '5', '6', '7', '8', '9', '0'}; [EOL] int result = JacksonCore.parseInt(digitChars, 0, 10); [EOL] assertEquals(1234567890, result); [EOL] }
public void testParseIntPositiveNumber() { [EOL] int result = YourClass.parseInt("123"); [EOL] assertEquals(123, result); [EOL] }
public void testParseIntNegativeNumber() { [EOL] int result = YourClass.parseInt("-123"); [EOL] assertEquals(-123, result); [EOL] }
public void testParseIntSingleDigit() { [EOL] int result = YourClass.parseInt("5"); [EOL] assertEquals(5, result); [EOL] }
public void testParseIntNegativeSingleDigit() { [EOL] int result = YourClass.parseInt("-5"); [EOL] assertEquals(-5, result); [EOL] }
public void testParseIntMaxInt() { [EOL] int result = YourClass.parseInt("2147483647"); [EOL] assertEquals(2147483647, result); [EOL] }
public void testParseIntMinInt() { [EOL] int result = YourClass.parseInt("-2147483648"); [EOL] assertEquals(-2147483648, result); [EOL] }
public void testParseIntInvalidLengthPositive() { [EOL] try { [EOL] YourClass.parseInt("12345678901"); [EOL] fail("Should have thrown NumberFormatException"); [EOL] } catch (NumberFormatException e) { [EOL] } [EOL] }
public void testParseIntInvalidLengthNegative() { [EOL] try { [EOL] YourClass.parseInt("-12345678901"); [EOL] fail("Should have thrown NumberFormatException"); [EOL] } catch (NumberFormatException e) { [EOL] } [EOL] }
public void testParseIntNonNumeric() { [EOL] try { [EOL] YourClass.parseInt("abc"); [EOL] fail("Should have thrown NumberFormatException"); [EOL] } catch (NumberFormatException e) { [EOL] } [EOL] }
public void testParseIntEmptyString() { [EOL] try { [EOL] YourClass.parseInt(""); [EOL] fail("Should have thrown StringIndexOutOfBoundsException"); [EOL] } catch (StringIndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testParseIntPlusSign() { [EOL] try { [EOL] YourClass.parseInt("+123"); [EOL] fail("Should have thrown NumberFormatException"); [EOL] } catch (NumberFormatException e) { [EOL] } [EOL] }
public void testParseLongWithShortLength() { [EOL] char[] digitChars = {'1', '2', '3', '4', '5', '6', '7', '8'}; [EOL] int offset = 0; [EOL] int len = 8; [EOL] long expected = 12345678L; [EOL] long actual = parseLong(digitChars, offset, len); [EOL] assertEquals(expected, actual); [EOL] }
public void testParseLongWithMaxLength() { [EOL] char[] digitChars = {'1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '1', '2', '3', '4', '5', '6', '7', '8'}; [EOL] int offset = 0; [EOL] int len = 18; [EOL] long expected = 123456789012345678L; [EOL] long actual = parseLong(digitChars, offset, len); [EOL] assertEquals(expected, actual); [EOL] }
public void testParseLongWithOffsetAndLength() { [EOL] char[] digitChars = {'0', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '1', '2', '3', '4', '5', '6', '7', '8'}; [EOL] int offset = 2; [EOL] int len = 18; [EOL] long expected = 123456789012345678L; [EOL] long actual = parseLong(digitChars, offset, len); [EOL] assertEquals(expected, actual); [EOL] }
public void testInLongRangeWithShorterLengthPositive() { [EOL] char[] digitChars = {'1', '2', '3'}; [EOL] int offset = 0; [EOL] int len = 3; [EOL] boolean negative = false; [EOL] boolean result = YourClass.inLongRange(digitChars, offset, len, negative); [EOL] assertTrue(result); [EOL] }
public void testInLongRangeWithShorterLengthNegative() { [EOL] char[] digitChars = {'1', '2', '3'}; [EOL] int offset = 0; [EOL] int len = 3; [EOL] boolean negative = true; [EOL] boolean result = YourClass.inLongRange(digitChars, offset, len, negative); [EOL] assertTrue(result); [EOL] }
public void testInLongRangeWithLongerLengthPositive() { [EOL] char[] digitChars = {'9', '2', '3', '4', '5', '6', '7', '8', '9', '0', '1'}; [EOL] int offset = 0; [EOL] int len = 11; [EOL] boolean negative = false; [EOL] boolean result = YourClass.inLongRange(digitChars, offset, len, negative); [EOL] assertFalse(result); [EOL] }
public void testInLongRangeWithLongerLengthNegative() { [EOL] char[] digitChars = {'9', '2', '3', '4', '5', '6', '7', '8', '9', '0', '1'}; [EOL] int offset = 0; [EOL] int len = 11; [EOL] boolean negative = true; [EOL] boolean result = YourClass.inLongRange(digitChars, offset, len, negative); [EOL] assertFalse(result); [EOL] }
public void testInLongRangeWithEqualLengthPositiveLessThanMax() { [EOL] char[] digitChars = {'1', '2', '3', '4', '5', '6', '7', '8', '9', '0'}; [EOL] int offset = 0; [EOL] int len = 10; [EOL] boolean negative = false; [EOL] boolean result = YourClass.inLongRange(digitChars, offset, len, negative); [EOL] assertTrue(result); [EOL] }
public void testInLongRangeWithEqualLengthPositiveGreaterThanMax() { [EOL] char[] digitChars = {'9', '2', '3', '4', '5', '6', '7', '8', '9', '1'}; [EOL] int offset = 0; [EOL] int len = 10; [EOL] boolean negative = false; [EOL] boolean result = YourClass.inLongRange(digitChars, offset, len, negative); [EOL] assertFalse(result); [EOL] }
public void testInLongRangeWithEqualLengthNegativeLessThanMin() { [EOL] char[] digitChars = {'-', '8', '2', '3', '4', '5', '6', '7', '8', '9', '0'}; [EOL] int offset = 1; [EOL] int len = 10; [EOL] boolean negative = true; [EOL] boolean result = YourClass.inLongRange(digitChars, offset, len, negative); [EOL] assertTrue(result); [EOL] }
public void testInLongRangeWithEqualLengthNegativeGreaterThanMin() { [EOL] char[] digitChars = {'-', '9', '2', '3', '4', '5', '6', '7', '8', '9', '2'}; [EOL] int offset = 1; [EOL] int len = 10; [EOL] boolean negative = true; [EOL] boolean result = YourClass.inLongRange(digitChars, offset, len, negative); [EOL] assertFalse(result); [EOL] }
public void testGetCodecWhenCodecIsNull() { [EOL] JsonParser jp = new JsonParserSubClass(null); [EOL] assertNull(jp.getCodec()); [EOL] }
public void testGetCodecWhenCodecIsNotNull() { [EOL] ObjectCodec codec = new ObjectCodecSubClass(); [EOL] JsonParser jp = new JsonParserSubClass(codec); [EOL] assertSame(codec, jp.getCodec()); [EOL] }
public void testReleaseBufferedWithNoContent() throws IOException { [EOL] OutputStream out = new ByteArrayOutputStream(); [EOL] int released = releaseBuffered(out); [EOL] assertEquals(0, released); [EOL] }
public void testReleaseBufferedWithContent() throws IOException { [EOL] OutputStream out = new ByteArrayOutputStream(); [EOL] _inputEnd = 10; [EOL] _inputPtr = 5; [EOL] _inputBuffer = new byte[]{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; [EOL] int released = releaseBuffered(out); [EOL] assertEquals(5, released); [EOL] byte[] outContent = out.toByteArray(); [EOL] byte[] expectedContent = new byte[]{5, 6, 7, 8, 9}; [EOL] assertArrayEquals(expectedContent, outContent); [EOL] }
public void testGetText2WithNullToken() { [EOL] String result = _getText2(null); [EOL] assertNull(result); [EOL] }
public void testGetText2WithFieldNameToken() { [EOL] JsonToken token = JsonToken.FIELD_NAME; [EOL] when(_parsingContext.getCurrentName()).thenReturn("fieldName"); [EOL] String result = _getText2(token); [EOL] assertEquals("fieldName", result); [EOL] }
public void testGetText2WithValueStringToken() { [EOL] JsonToken token = JsonToken.VALUE_STRING; [EOL] when(_textBuffer.contentsAsString()).thenReturn("stringValue"); [EOL] String result = _getText2(token); [EOL] assertEquals("stringValue", result); [EOL] }
public void testGetText2WithValueNumberIntToken() { [EOL] JsonToken token = JsonToken.VALUE_NUMBER_INT; [EOL] when(_textBuffer.contentsAsString()).thenReturn("intValue"); [EOL] String result = _getText2(token); [EOL] assertEquals("intValue", result); [EOL] }
public void testGetText2WithValueNumberFloatToken() { [EOL] JsonToken token = JsonToken.VALUE_NUMBER_FLOAT; [EOL] when(_textBuffer.contentsAsString()).thenReturn("floatValue"); [EOL] String result = _getText2(token); [EOL] assertEquals("floatValue", result); [EOL] }
public void testGetText2WithDefaultToken() { [EOL] JsonToken token = JsonToken.VALUE_TRUE; // Assuming VALUE_TRUE is a valid default case [EOL] String result = _getText2(token); [EOL] assertEquals("true", result); [EOL] }
public void testGetTextCharactersWithFieldNameAndNameNotCopied() throws IOException, JsonParseException { [EOL] _currToken = JsonToken.FIELD_NAME; [EOL] _nameCopied = false; [EOL] _parsingContext = mock(ParsingContext.class); [EOL] when(_parsingContext.getCurrentName()).thenReturn("testName"); [EOL] _ioContext = mock(IOContext.class); [EOL] _nameCopyBuffer = null; // Ensure the buffer is null to test allocation [EOL] char[] result = getTextCharacters(); [EOL] assertNotNull(result); [EOL] assertEquals("testName", new String(result)); [EOL] assertTrue(_nameCopied); [EOL] }
public void testGetTextCharactersWithFieldNameAndNameCopied() throws IOException, JsonParseException { [EOL] _currToken = JsonToken.FIELD_NAME; [EOL] _nameCopied = true; [EOL] _nameCopyBuffer = new char[]{'t', 'e', 's', 't', 'N', 'a', 'm', 'e'}; [EOL] char[] result = getTextCharacters(); [EOL] assertNotNull(result); [EOL] assertEquals("testName", new String(result)); [EOL] }
public void testGetTextCharactersWithValueStringAndTokenIncomplete() throws IOException, JsonParseException { [EOL] _currToken = JsonToken.VALUE_STRING; [EOL] _tokenIncomplete = true; [EOL] _textBuffer = mock(TextBuffer.class); [EOL] when(_textBuffer.getTextBuffer()).thenReturn(new char[]{'s', 't', 'r', 'i', 'n', 'g'}); [EOL] char[] result = getTextCharacters(); [EOL] assertNotNull(result); [EOL] assertEquals("string", new String(result)); [EOL] assertFalse(_tokenIncomplete); [EOL] }
public void testGetTextCharactersWithValueNumberInt() throws IOException, JsonParseException { [EOL] _currToken = JsonToken.VALUE_NUMBER_INT; [EOL] _textBuffer = mock(TextBuffer.class); [EOL] when(_textBuffer.getTextBuffer()).thenReturn(new char[]{'1', '2', '3'}); [EOL] char[] result = getTextCharacters(); [EOL] assertNotNull(result); [EOL] assertEquals("123", new String(result)); [EOL] }
public void testGetTextCharactersWithDefaultCase() throws IOException, JsonParseException { [EOL] _currToken = JsonToken.VALUE_TRUE; // Assuming VALUE_TRUE is not handled explicitly [EOL] char[] result = getTextCharacters(); [EOL] assertNotNull(result); [EOL] assertArrayEquals(new char[]{'t', 'r', 'u', 'e'}, result); [EOL] }
public void testGetTextCharactersWithNullToken() throws IOException, JsonParseException { [EOL] _currToken = null; [EOL] char[] result = getTextCharacters(); [EOL] assertNull(result); [EOL] }
public void testGetTextLengthWithFieldNameToken() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserWithToken(JsonToken.FIELD_NAME); [EOL] setParsingContext(parser, "fieldName"); [EOL] int length = parser.getTextLength(); [EOL] assertEquals("fieldName".length(), length); [EOL] }
public void testGetTextLengthWithValueStringTokenIncomplete() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserWithToken(JsonToken.VALUE_STRING); [EOL] setTokenIncomplete(parser, true); [EOL] int length = parser.getTextLength(); [EOL] assertEquals(expectedStringSizeAfterFinishing(), length); [EOL] }
public void testGetTextLengthWithValueStringTokenComplete() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserWithToken(JsonToken.VALUE_STRING); [EOL] setTokenIncomplete(parser, false); [EOL] int length = parser.getTextLength(); [EOL] assertEquals(expectedStringSize(), length); [EOL] }
public void testGetTextLengthWithValueNumberIntToken() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserWithToken(JsonToken.VALUE_NUMBER_INT); [EOL] setTextBuffer(parser, "123"); [EOL] int length = parser.getTextLength(); [EOL] assertEquals("123".length(), length); [EOL] }
public void testGetTextLengthWithValueNumberFloatToken() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserWithToken(JsonToken.VALUE_NUMBER_FLOAT); [EOL] setTextBuffer(parser, "123.45"); [EOL] int length = parser.getTextLength(); [EOL] assertEquals("123.45".length(), length); [EOL] }
public void testGetTextLengthWithOtherToken() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserWithToken(JsonToken.VALUE_TRUE); [EOL] int length = parser.getTextLength(); [EOL] assertEquals(JsonToken.VALUE_TRUE.asCharArray().length, length); [EOL] }
public void testGetTextLengthWithNullToken() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserWithToken(null); [EOL] int length = parser.getTextLength(); [EOL] assertEquals(0, length); [EOL] }
public void testGetTextOffsetWithFieldName() throws IOException, JsonParseException { [EOL] JsonParser jp = createParserWithToken(JsonToken.FIELD_NAME); [EOL] int offset = jp.getTextOffset(); [EOL] assertEquals(0, offset); [EOL] }
public void testGetTextOffsetWithValueStringIncomplete() throws IOException, JsonParseException { [EOL] JsonParser jp = createParserWithToken(JsonToken.VALUE_STRING, true); [EOL] int offset = jp.getTextOffset(); [EOL] assertFalse(jp.isTokenIncomplete()); [EOL] assertEquals(expectedOffsetAfterFinishString, offset); [EOL] }
public void testGetTextOffsetWithValueStringComplete() throws IOException, JsonParseException { [EOL] JsonParser jp = createParserWithToken(JsonToken.VALUE_STRING, false); [EOL] int offset = jp.getTextOffset(); [EOL] assertEquals(expectedOffset, offset); [EOL] }
public void testGetTextOffsetWithValueNumberInt() throws IOException, JsonParseException { [EOL] JsonParser jp = createParserWithToken(JsonToken.VALUE_NUMBER_INT); [EOL] int offset = jp.getTextOffset(); [EOL] assertEquals(expectedOffset, offset); [EOL] }
public void testGetTextOffsetWithValueNumberFloat() throws IOException, JsonParseException { [EOL] JsonParser jp = createParserWithToken(JsonToken.VALUE_NUMBER_FLOAT); [EOL] int offset = jp.getTextOffset(); [EOL] assertEquals(expectedOffset, offset); [EOL] }
public void testGetTextOffsetWithNullToken() throws IOException, JsonParseException { [EOL] JsonParser jp = createParserWithToken(null); [EOL] int offset = jp.getTextOffset(); [EOL] assertEquals(0, offset); [EOL] }
public void testNextTokenNotInObjectWithQuote() throws IOException, JsonParseException { [EOL] int i = INT_QUOTE; [EOL] JsonToken result = _nextTokenNotInObject(i); [EOL] assertTrue(_tokenIncomplete); [EOL] assertEquals(JsonToken.VALUE_STRING, result); [EOL] }
public void testNextTokenNotInObjectWithLBracket() throws IOException, JsonParseException { [EOL] int i = INT_LBRACKET; [EOL] JsonToken result = _nextTokenNotInObject(i); [EOL] assertNotNull(_parsingContext); [EOL] assertEquals(JsonToken.START_ARRAY, result); [EOL] }
public void testNextTokenNotInObjectWithLCurly() throws IOException, JsonParseException { [EOL] int i = INT_LCURLY; [EOL] JsonToken result = _nextTokenNotInObject(i); [EOL] assertNotNull(_parsingContext); [EOL] assertEquals(JsonToken.START_OBJECT, result); [EOL] }
public void testNextTokenNotInObjectWithRBracket() { [EOL] int i = INT_RBRACKET; [EOL] try { [EOL] _nextTokenNotInObject(i); [EOL] fail("Expected JsonParseException"); [EOL] } catch (JsonParseException e) { [EOL] } catch (IOException e) { [EOL] fail("IOException should not be thrown"); [EOL] } [EOL] }
public void testNextTokenNotInObjectWithRCurly() { [EOL] int i = INT_RCURLY; [EOL] try { [EOL] _nextTokenNotInObject(i); [EOL] fail("Expected JsonParseException"); [EOL] } catch (JsonParseException e) { [EOL] } catch (IOException e) { [EOL] fail("IOException should not be thrown"); [EOL] } [EOL] }
public void testNextTokenNotInObjectWithTrue() throws IOException, JsonParseException { [EOL] int i = INT_t; [EOL] JsonToken result = _nextTokenNotInObject(i); [EOL] assertEquals(JsonToken.VALUE_TRUE, result); [EOL] }
public void testNextTokenNotInObjectWithFalse() throws IOException, JsonParseException { [EOL] int i = INT_f; [EOL] JsonToken result = _nextTokenNotInObject(i); [EOL] assertEquals(JsonToken.VALUE_FALSE, result); [EOL] }
public void testNextTokenNotInObjectWithNull() throws IOException, JsonParseException { [EOL] int i = INT_n; [EOL] JsonToken result = _nextTokenNotInObject(i); [EOL] assertEquals(JsonToken.VALUE_NULL, result); [EOL] }
public void testNextTokenNotInObjectWithNumber() throws IOException, JsonParseException { [EOL] int[] numbers = {INT_MINUS, INT_0, INT_1, INT_2, INT_3, INT_4, INT_5, INT_6, INT_7, INT_8, INT_9}; [EOL] for (int i : numbers) { [EOL] JsonToken result = _nextTokenNotInObject(i); [EOL] assertNotNull(result); [EOL] assertTrue(result.isNumeric()); [EOL] } [EOL] }
public void testNextTokenNotInObjectWithUnexpectedValue() throws IOException, JsonParseException { [EOL] int i = INT_UNKNOWN; // Assuming INT_UNKNOWN is a constant for an unexpected value [EOL] JsonToken result = _nextTokenNotInObject(i); [EOL] assertEquals(_handleUnexpectedValue(i), result); [EOL] }
public void testVerifyNoLeadingZeroesAtEndOfInput() throws IOException, JsonParseException { [EOL] _inputPtr = 10; [EOL] _inputEnd = 10; [EOL] assertFalse(loadMore()); [EOL] int result = _verifyNoLeadingZeroes(); [EOL] assertEquals(INT_0, result); [EOL] }
public void testVerifyNoLeadingZeroesWithNonDigit() throws IOException, JsonParseException { [EOL] _inputPtr = 0; [EOL] _inputEnd = 1; [EOL] _inputBuffer = new byte[]{(byte) 'a'}; [EOL] int result = _verifyNoLeadingZeroes(); [EOL] assertEquals(INT_0, result); [EOL] }
public void testVerifyNoLeadingZeroesWithLeadingZeroesNotAllowed() throws IOException, JsonParseException { [EOL] _inputPtr = 0; [EOL] _inputEnd = 2; [EOL] _inputBuffer = new byte[]{(byte) '0', (byte) '1'}; [EOL] when(isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)).thenReturn(false); [EOL] try { [EOL] _verifyNoLeadingZeroes(); [EOL] fail("Expected JsonParseException"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testVerifyNoLeadingZeroesWithLeadingZeroesAllowed() throws IOException, JsonParseException { [EOL] _inputPtr = 0; [EOL] _inputEnd = 2; [EOL] _inputBuffer = new byte[]{(byte) '0', (byte) '1'}; [EOL] when(isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)).thenReturn(true); [EOL] int result = _verifyNoLeadingZeroes(); [EOL] assertEquals('1', result); [EOL] }
public void testVerifyNoLeadingZeroesWithMultipleLeadingZeroes() throws IOException, JsonParseException { [EOL] _inputPtr = 0; [EOL] _inputEnd = 3; [EOL] _inputBuffer = new byte[]{(byte) '0', (byte) '0', (byte) '2'}; [EOL] when(isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)).thenReturn(true); [EOL] when(loadMore()).thenReturn(true); [EOL] int result = _verifyNoLeadingZeroes(); [EOL] assertEquals('2', result); [EOL] }
protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException { [EOL] int i = _inputBuffer[_inputPtr++] & 0xFF; [EOL] if (codes[i] != 0) { [EOL] if (i == INT_QUOTE) { [EOL] return findName(_quad1, q2, 1); [EOL] } [EOL] return parseFieldName(_quad1, q2, i, 1); [EOL] } [EOL] q2 = (q2 << 8) | i; [EOL] i = _inputBuffer[_inputPtr++] & 0xFF; [EOL] if (codes[i] != 0) { [EOL] if (i == INT_QUOTE) { [EOL] return findName(_quad1, q2, 2); [EOL] } [EOL] return parseFieldName(_quad1, q2, i, 2); [EOL] } [EOL] q2 = (q2 << 8) | i; [EOL] i = _inputBuffer[_inputPtr++] & 0xFF; [EOL] if (codes[i] != 0) { [EOL] if (i == INT_QUOTE) { [EOL] return findName(_quad1, q2, 3); [EOL] } [EOL] return parseFieldName(_quad1, q2, i, 3); [EOL] } [EOL] q2 = (q2 << 8) | i; [EOL] i = _inputBuffer[_inputPtr++] & 0xFF; [EOL] if (codes[i] != 0) { [EOL] if (i == INT_QUOTE) { [EOL] return findName(_quad1, q2, 4); [EOL] } [EOL] return parseFieldName(_quad1, q2, i, 4); [EOL] } [EOL] _quadBuffer[0] = _quad1; [EOL] _quadBuffer[1] = q2; [EOL] return parseLongFieldName(i); [EOL] }
protected Name parseLongFieldName(int q) throws IOException, JsonParseException { [EOL] final int[] codes = sInputCodesLatin1; [EOL] int qlen = 2; [EOL] while (true) { [EOL] if ((_inputEnd - _inputPtr) < 4) { [EOL] return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0); [EOL] } [EOL] int i = _inputBuffer[_inputPtr++] & 0xFF; [EOL] if (codes[i] != 0) { [EOL] if (i == INT_QUOTE) { [EOL] return findName(_quadBuffer, qlen, q, 1); [EOL] } [EOL] return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1); [EOL] } [EOL] q = (q << 8) | i; [EOL] i = _inputBuffer[_inputPtr++] & 0xFF; [EOL] if (codes[i] != 0) { [EOL] if (i == INT_QUOTE) { [EOL] return findName(_quadBuffer, qlen, q, 2); [EOL] } [EOL] return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2); [EOL] } [EOL] q = (q << 8) | i; [EOL] i = _inputBuffer[_inputPtr++] & 0xFF; [EOL] if (codes[i] != 0) { [EOL] if (i == INT_QUOTE) { [EOL] return findName(_quadBuffer, qlen, q, 3); [EOL] } [EOL] return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3); [EOL] } [EOL] q = (q << 8) | i; [EOL] i = _inputBuffer[_inputPtr++] & 0xFF; [EOL] if (codes[i] != 0) { [EOL] if (i == INT_QUOTE) { [EOL] return findName(_quadBuffer, qlen, q, 4); [EOL] } [EOL] return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4); [EOL] } [EOL] if (qlen >= _quadBuffer.length) { [EOL] _quadBuffer = growArrayBy(_quadBuffer, qlen); [EOL] } [EOL] _quadBuffer[qlen++] = q; [EOL] q = i; [EOL] } [EOL] }
private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException { [EOL] int byteLen = (qlen << 2) - 4 + lastQuadBytes; [EOL] int lastQuad; [EOL] if (lastQuadBytes < 4) { [EOL] lastQuad = quads[qlen - 1]; [EOL] quads[qlen - 1] = (lastQuad << ((4 - lastQuadBytes) << 3)); [EOL] } else { [EOL] lastQuad = 0; [EOL] } [EOL] char[] cbuf = _textBuffer.emptyAndGetCurrentSegment(); [EOL] int cix = 0; [EOL] for (int ix = 0; ix < byteLen; ) { [EOL] int ch = quads[ix >> 2]; [EOL] int byteIx = (ix & 3); [EOL] ch = (ch >> ((3 - byteIx) << 3)) & 0xFF; [EOL] ++ix; [EOL] if (ch > 127) { [EOL] int needed; [EOL] if ((ch & 0xE0) == 0xC0) { [EOL] ch &= 0x1F; [EOL] needed = 1; [EOL] } else if ((ch & 0xF0) == 0xE0) { [EOL] ch &= 0x0F; [EOL] needed = 2; [EOL] } else if ((ch & 0xF8) == 0xF0) { [EOL] ch &= 0x07; [EOL] needed = 3; [EOL] } else { [EOL] _reportInvalidInitial(ch); [EOL] needed = ch = 1; [EOL] } [EOL] if ((ix + needed) > byteLen) { [EOL] _reportInvalidEOF(" in field name"); [EOL] } [EOL] int ch2 = quads[ix >> 2]; [EOL] byteIx = (ix & 3); [EOL] ch2 = (ch2 >> ((3 - byteIx) << 3)); [EOL] ++ix; [EOL] if ((ch2 & 0xC0) != 0x080) { [EOL] _reportInvalidOther(ch2); [EOL] } [EOL] ch = (ch << 6) | (ch2 & 0x3F); [EOL] if (needed > 1) { [EOL] ch2 = quads[ix >> 2]; [EOL] byteIx = (ix & 3); [EOL] ch2 = (ch2 >> ((3 - byteIx) << 3)); [EOL] ++ix; [EOL] if ((ch2 & 0xC0) != 0x080) { [EOL] _reportInvalidOther(ch2); [EOL] } [EOL] ch = (ch << 6) | (ch2 & 0x3F); [EOL] if (needed > 2) { [EOL] ch2 = quads[ix >> 2]; [EOL] byteIx = (ix & 3); [EOL] ch2 = (ch2 >> ((3 - byteIx) << 3)); [EOL] ++ix; [EOL] if ((ch2 & 0xC0) != 0x080) { [EOL] _reportInvalidOther(ch2 & 0xFF); [EOL] } [EOL] ch = (ch << 6) | (ch2 & 0x3F); [EOL] } [EOL] } [EOL] if (needed > 2) { [EOL] ch -= 0x10000; [EOL] if (cix >= cbuf.length) { [EOL] cbuf = _textBuffer.expandCurrentSegment(); [EOL] } [EOL] cbuf[cix++] = (char) (0xD800 + (ch >> 10)); [EOL] ch = 0xDC00 | (ch & 0x03FF); [EOL] } [EOL] } [EOL] if (cix >= cbuf.length) { [EOL] cbuf = _textBuffer.expandCurrentSegment(); [EOL] } [EOL] cbuf[cix++] = (char) ch; [EOL] } [EOL] String baseName = new String(cbuf, 0, cix); [EOL] if (lastQuadBytes < 4) { [EOL] quads[qlen - 1] = lastQuad; [EOL] } [EOL] return _symbols.addName(baseName, quads, qlen); [EOL] }
private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException { [EOL] int c; [EOL] final int[] codes = sInputCodesUtf8; [EOL] final byte[] inputBuffer = _inputBuffer; [EOL] main_loop: while (true) { [EOL] ascii_loop: while (true) { [EOL] int ptr = _inputPtr; [EOL] if (ptr >= _inputEnd) { [EOL] loadMoreGuaranteed(); [EOL] ptr = _inputPtr; [EOL] } [EOL] if (outPtr >= outBuf.length) { [EOL] outBuf = _textBuffer.finishCurrentSegment(); [EOL] outPtr = 0; [EOL] } [EOL] final int max = Math.min(_inputEnd, (ptr + (outBuf.length - outPtr))); [EOL] while (ptr < max) { [EOL] c = (int) inputBuffer[ptr++] & 0xFF; [EOL] if (codes[c] != 0) { [EOL] _inputPtr = ptr; [EOL] break ascii_loop; [EOL] } [EOL] outBuf[outPtr++] = (char) c; [EOL] } [EOL] _inputPtr = ptr; [EOL] } [EOL] if (c == INT_QUOTE) { [EOL] break main_loop; [EOL] } [EOL] switch(codes[c]) { [EOL] case 1: [EOL] c = _decodeEscaped(); [EOL] break; [EOL] case 2: [EOL] c = _decodeUtf8_2(c); [EOL] break; [EOL] case 3: [EOL] if ((_inputEnd - _inputPtr) >= 2) { [EOL] c = _decodeUtf8_3fast(c); [EOL] } else { [EOL] c = _decodeUtf8_3(c); [EOL] } [EOL] break; [EOL] case 4: [EOL] c = _decodeUtf8_4(c); [EOL] outBuf[outPtr++] = (char) (0xD800 | (c >> 10)); [EOL] if (outPtr >= outBuf.length) { [EOL] outBuf = _textBuffer.finishCurrentSegment(); [EOL] outPtr = 0; [EOL] } [EOL] c = 0xDC00 | (c & 0x3FF); [EOL] break; [EOL] default: [EOL] if (c < INT_SPACE) { [EOL] _throwUnquotedSpace(c, "string value"); [EOL] } else { [EOL] _reportInvalidChar(c); [EOL] } [EOL] } [EOL] if (outPtr >= outBuf.length) { [EOL] outBuf = _textBuffer.finishCurrentSegment(); [EOL] outPtr = 0; [EOL] } [EOL] outBuf[outPtr++] = (char) c; [EOL] } [EOL] _textBuffer.setCurrentLength(outPtr); [EOL] }
public void testHandleUnexpectedValueWithSingleQuote() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserWithFeatureEnabled(Feature.ALLOW_SINGLE_QUOTES); [EOL] JsonToken result = parser._handleUnexpectedValue('\''); [EOL] assertEquals(JsonToken.VALUE_STRING, result); [EOL] }
public void testHandleUnexpectedValueWithN() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserWithFeatureEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS); [EOL] JsonToken result = parser._handleUnexpectedValue('N'); [EOL] assertEquals(JsonToken.VALUE_NUMBER_FLOAT, result); [EOL] }
public void testHandleUnexpectedValueWithNWithoutFeature() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserWithFeatureDisabled(Feature.ALLOW_NON_NUMERIC_NUMBERS); [EOL] try { [EOL] parser._handleUnexpectedValue('N'); [EOL] fail("Expected JsonParseException"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testHandleUnexpectedValueWithI() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserWithFeatureEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS); [EOL] JsonToken result = parser._handleUnexpectedValue('I'); [EOL] assertEquals(JsonToken.VALUE_NUMBER_FLOAT, result); [EOL] }
public void testHandleUnexpectedValueWithIWithoutFeature() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserWithFeatureDisabled(Feature.ALLOW_NON_NUMERIC_NUMBERS); [EOL] try { [EOL] parser._handleUnexpectedValue('I'); [EOL] fail("Expected JsonParseException"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testHandleUnexpectedValueWithPlusAtBufferEnd() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserAtBufferEnd(); [EOL] try { [EOL] parser._handleUnexpectedValue('+'); [EOL] fail("Expected JsonParseException for end of input"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testHandleUnexpectedValueWithPlusNotAtBufferEnd() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserNotAtBufferEnd(); [EOL] JsonToken result = parser._handleUnexpectedValue('+'); [EOL] assertEquals(JsonToken.VALUE_NUMBER_INT, result); [EOL] }
public void testHandleUnexpectedValueWithJavaIdentifierStart() throws IOException, JsonParseException { [EOL] JsonParser parser = createParser(); [EOL] try { [EOL] parser._handleUnexpectedValue('a'); [EOL] fail("Expected JsonParseException for invalid token"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testHandleUnexpectedValueWithInvalidChar() throws IOException, JsonParseException { [EOL] JsonParser parser = createParser(); [EOL] try { [EOL] parser._handleUnexpectedValue('%'); [EOL] fail("Expected JsonParseException for unexpected character"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testSkipWSOrEndWithNonSpaceChar() throws IOException, JsonParseException { [EOL] _inputBuffer[_inputPtr] = (byte) 'a'; // 'a' is a non-space character [EOL] int result = _skipWSOrEnd(); [EOL] assertNotEquals(-1, result); // Assert that the result is not end of input [EOL] assertEquals('a', result); // Assert that the correct character is returned [EOL] }
public void testSkipWSOrEndWithSlash() throws IOException, JsonParseException { [EOL] _inputBuffer[_inputPtr] = (byte) '/'; // '/' is INT_SLASH [EOL] int result = _skipWSOrEnd(); [EOL] }
public void testSkipWSOrEndWithSpace() throws IOException, JsonParseException { [EOL] _inputBuffer[_inputPtr] = (byte) ' '; // ' ' is INT_SPACE [EOL] int result = _skipWSOrEnd(); [EOL] assertNotEquals(' ', result); [EOL] }
public void testSkipWSOrEndWithNewLine() throws IOException, JsonParseException { [EOL] _inputBuffer[_inputPtr] = (byte) '\n'; // '\n' is INT_LF [EOL] int result = _skipWSOrEnd(); [EOL] }
public void testSkipWSOrEndWithCarriageReturn() throws IOException, JsonParseException { [EOL] _inputBuffer[_inputPtr] = (byte) '\r'; // '\r' is INT_CR [EOL] int result = _skipWSOrEnd(); [EOL] }
public void testSkipWSOrEndWithTab() throws IOException, JsonParseException { [EOL] _inputBuffer[_inputPtr] = (byte) '\t'; // '\t' is INT_TAB [EOL] int result = _skipWSOrEnd(); [EOL] assertNotEquals('\t', result); [EOL] }
public void testSkipWSOrEndWithInvalidSpace() throws IOException, JsonParseException { [EOL] _inputBuffer[_inputPtr] = (byte) 0x01; // An invalid space character [EOL] try { [EOL] _skipWSOrEnd(); [EOL] fail("Should have thrown an exception for invalid space character"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testSkipWSOrEndAtEndOfInput() throws IOException, JsonParseException { [EOL] _inputPtr = _inputEnd; [EOL] int result = _skipWSOrEnd(); [EOL] assertEquals(-1, result); // Assert that the end of input is correctly handled [EOL] }
public void testSkipCommentWithCommentsNotAllowed() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserWithFeature(ALLOW_COMMENTS, false); [EOL] try { [EOL] parser._skipComment(); [EOL] fail("Expected JsonParseException for not allowed comments"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testSkipCommentAtEndOfFile() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserWithContent("/"); [EOL] parser._inputPtr = parser._inputEnd; // Simulate end of file [EOL] try { [EOL] parser._skipComment(); [EOL] fail("Expected JsonParseException for EOF in a comment"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testSkipCommentWithCppStyle() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserWithContent("// cpp comment"); [EOL] parser._inputPtr = 1; // Position the pointer at the '/' of the "//" [EOL] parser._skipComment(); // Should successfully skip the C++ style comment [EOL] assertEquals("Pointer should be at the end of the comment", parser._inputEnd, parser._inputPtr); [EOL] }
public void testSkipCommentWithCStyle() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserWithContent("/* c style comment */"); [EOL] parser._inputPtr = 1; // Position the pointer at the '*' of the "/*" [EOL] parser._skipComment(); // Should successfully skip the C style comment [EOL] assertEquals("Pointer should be at the end of the comment", parser._inputEnd, parser._inputPtr); [EOL] }
public void testSkipCommentWithInvalidChar() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserWithContent("/a"); [EOL] parser._inputPtr = 1; // Position the pointer at the 'a' [EOL] try { [EOL] parser._skipComment(); [EOL] fail("Expected JsonParseException for invalid comment start"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testSkipCCommentWithAsteriskEnding() throws IOException, JsonParseException { [EOL] _inputBuffer = new char[]{'/', '*', 'a', '*', '/'}; [EOL] _inputPtr = 0; [EOL] _inputEnd = _inputBuffer.length; [EOL] _skipCComment(); [EOL] assertEquals("The input pointer should be at the end of the buffer after skipping a comment", _inputEnd, _inputPtr); [EOL] }
public void testSkipCCommentWithEOFBeforeCommentEnds() throws IOException, JsonParseException { [EOL] _inputBuffer = new char[]{'/', '*', 'a'}; [EOL] _inputPtr = 0; [EOL] _inputEnd = _inputBuffer.length; [EOL] try { [EOL] _skipCComment(); [EOL] fail("Should throw JsonParseException because of EOF before comment ends"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testSkipCCommentWithLineFeed() throws IOException, JsonParseException { [EOL] _inputBuffer = new char[]{'/', '*', '\n', '*', '/'}; [EOL] _inputPtr = 0; [EOL] _inputEnd = _inputBuffer.length; [EOL] _skipCComment(); [EOL] assertEquals("The input pointer should be after the line feed", 3, _inputPtr); [EOL] }
public void testSkipCCommentWithCarriageReturn() throws IOException, JsonParseException { [EOL] _inputBuffer = new char[]{'/', '*', '\r', '*', '/'}; [EOL] _inputPtr = 0; [EOL] _inputEnd = _inputBuffer.length; [EOL] _skipCComment(); [EOL] assertEquals("The input pointer should be after the carriage return", 3, _inputPtr); [EOL] }
public void testSkipCCommentWithUtf8_2() throws IOException, JsonParseException { [EOL] _inputBuffer = new char[]{'/', '*', (char) 0xC2, (char) 0xA2, '*', '/'}; [EOL] _inputPtr = 0; [EOL] _inputEnd = _inputBuffer.length; [EOL] _skipCComment(); [EOL] assertEquals("The input pointer should skip the UTF-8 2-byte character", 4, _inputPtr); [EOL] }
public void testSkipCCommentWithUtf8_3() throws IOException, JsonParseException { [EOL] _inputBuffer = new char[]{'/', '*', (char) 0xE2, (char) 0x82, (char) 0xAC, '*', '/'}; [EOL] _inputPtr = 0; [EOL] _inputEnd = _inputBuffer.length; [EOL] _skipCComment(); [EOL] assertEquals("The input pointer should skip the UTF-8 3-byte character", 5, _inputPtr); [EOL] }
public void testSkipCCommentWithUtf8_4() throws IOException, JsonParseException { [EOL] _inputBuffer = new char[]{'/', '*', (char) 0xF0, (char) 0x90, (char) 0x8D, (char) 0x88, '*', '/'}; [EOL] _inputPtr = 0; [EOL] _inputEnd = _inputBuffer.length; [EOL] _skipCComment(); [EOL] assertEquals("The input pointer should skip the UTF-8 4-byte character", 6, _inputPtr); [EOL] }
public void testSkipCCommentWithInvalidChar() throws IOException, JsonParseException { [EOL] _inputBuffer = new char[]{'/', '*', (char) 0xFF, '*', '/'}; [EOL] _inputPtr = 0; [EOL] _inputEnd = _inputBuffer.length; [EOL] try { [EOL] _skipCComment(); [EOL] fail("Should throw JsonParseException because of invalid character"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testSkipCppCommentWithLF() throws IOException, JsonParseException { [EOL] _inputBuffer = new char[] {'\n'}; [EOL] _inputPtr = 0; [EOL] _inputEnd = 1; [EOL] _skipCppComment(); [EOL] assertEquals(1, _inputPtr); [EOL] }
public void testSkipCppCommentWithCR() throws IOException, JsonParseException { [EOL] _inputBuffer = new char[] {'\r'}; [EOL] _inputPtr = 0; [EOL] _inputEnd = 1; [EOL] _skipCppComment(); [EOL] assertEquals(1, _inputPtr); [EOL] }
public void testSkipCppCommentWithAsterisk() throws IOException, JsonParseException { [EOL] _inputBuffer = new char[] {'*'}; [EOL] _inputPtr = 0; [EOL] _inputEnd = 1; [EOL] _skipCppComment(); [EOL] assertEquals(1, _inputPtr); [EOL] }
public void testSkipCppCommentWithUtf8_2() throws IOException, JsonParseException { [EOL] _inputBuffer = new char[] {(char) 0xC2, (char) 0xA2}; [EOL] _inputPtr = 0; [EOL] _inputEnd = 2; [EOL] _skipCppComment(); [EOL] assertEquals(2, _inputPtr); [EOL] }
public void testSkipCppCommentWithUtf8_3() throws IOException, JsonParseException { [EOL] _inputBuffer = new char[] {(char) 0xE2, (char) 0x82, (char) 0xAC}; [EOL] _inputPtr = 0; [EOL] _inputEnd = 3; [EOL] _skipCppComment(); [EOL] assertEquals(3, _inputPtr); [EOL] }
public void testSkipCppCommentWithUtf8_4() throws IOException, JsonParseException { [EOL] _inputBuffer = new char[] {(char) 0xF0, (char) 0x90, (char) 0x8D, (char) 0x88}; [EOL] _inputPtr = 0; [EOL] _inputEnd = 4; [EOL] _skipCppComment(); [EOL] assertEquals(4, _inputPtr); [EOL] }
public void testSkipCppCommentWithInvalidChar() throws IOException, JsonParseException { [EOL] _inputBuffer = new char[] {(char) 0xFF}; [EOL] _inputPtr = 0; [EOL] _inputEnd = 1; [EOL] try { [EOL] _skipCppComment(); [EOL] fail("Should not pass, as invalid char should throw an exception"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testSkipCppCommentWithEndOfInput() throws IOException, JsonParseException { [EOL] _inputBuffer = new char[] {'/'}; [EOL] _inputPtr = 0; [EOL] _inputEnd = 0; [EOL] assertFalse("Should return false as there is no more input", loadMore()); [EOL] }
public void testDecodeEscapedInputPtrAtInputEndAndLoadMoreFails() throws IOException { [EOL] _inputPtr = 0; [EOL] _inputEnd = 0; [EOL] when(loadMore()).thenReturn(false); [EOL] try { [EOL] _decodeEscaped(); [EOL] fail("Expected an IOException to be thrown"); [EOL] } catch (IOException e) { [EOL] assertEquals(" in character escape sequence", e.getMessage()); [EOL] } [EOL] }
public void testDecodeEscapedInputPtrBeforeInputEnd() throws IOException { [EOL] _inputPtr = 0; [EOL] _inputEnd = 1; [EOL] _inputBuffer = new char[]{'b'}; [EOL] char result = _decodeEscaped(); [EOL] assertEquals('\b', result); [EOL] }
public void testDecodeEscapedWithUnrecognizedCharacter() throws IOException { [EOL] _inputPtr = 0; [EOL] _inputEnd = 1; [EOL] _inputBuffer = new char[]{'x'}; [EOL] when(_handleUnrecognizedCharacterEscape(anyChar())).thenReturn('X'); [EOL] char result = _decodeEscaped(); [EOL] assertEquals('X', result); [EOL] }
public void testDecodeEscapedWithUnicodeSequence() throws IOException { [EOL] _inputPtr = 0; [EOL] _inputEnd = 5; [EOL] _inputBuffer = new char[]{'u', '0', '0', '1', 'f'}; [EOL] char result = _decodeEscaped(); [EOL] assertEquals('\u001f', result); [EOL] }
public void testDecodeEscapedWithInvalidHexDigitInUnicodeSequence() throws IOException { [EOL] _inputPtr = 0; [EOL] _inputEnd = 5; [EOL] _inputBuffer = new char[]{'u', '0', '0', 'G', '1'}; [EOL] doThrow(new IOException()).when(_reportUnexpectedChar(anyInt(), anyString())); [EOL] try { [EOL] _decodeEscaped(); [EOL] fail("Expected an IOException to be thrown"); [EOL] } catch (IOException e) { [EOL] verify(_reportUnexpectedChar).invoke(anyInt(), eq("expected a hex-digit for character escape sequence")); [EOL] } [EOL] }
public void testDecodeUtf8_2WithSufficientBuffer() throws IOException, JsonParseException { [EOL] _inputPtr = 0; [EOL] _inputEnd = 2; [EOL] _inputBuffer = new byte[] {(byte) 0xC2, (byte) 0xA2}; // valid 2-byte UTF-8 sequence [EOL] int c = 0xC2; [EOL] int result = _decodeUtf8_2(c); [EOL] assertEquals(0x22, result); // Assert that the decoded value is correct [EOL] }
public void testDecodeUtf8_2WithInsufficientBuffer() throws IOException, JsonParseException { [EOL] _inputPtr = 0; [EOL] _inputEnd = 0; // Set buffer end to simulate buffer end reached [EOL] _inputBuffer = new byte[] {}; // Empty buffer [EOL] int c = 0xC2; [EOL] try { [EOL] _decodeUtf8_2(c); [EOL] fail("Expected IOException for insufficient buffer"); [EOL] } catch (IOException e) { [EOL] } [EOL] }
public void testDecodeUtf8_2WithInvalidContinuationByte() throws IOException, JsonParseException { [EOL] _inputPtr = 0; [EOL] _inputEnd = 2; [EOL] _inputBuffer = new byte[] {(byte) 0xC2, (byte) 0xFF}; // Invalid 2-byte UTF-8 sequence (second byte not 0x80) [EOL] int c = 0xC2; [EOL] try { [EOL] _decodeUtf8_2(c); [EOL] fail("Expected JsonParseException for invalid continuation byte"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testDecodeUtf8_3WithInsufficientData() throws IOException, JsonParseException { [EOL] _inputPtr = 0; [EOL] _inputEnd = 0; [EOL] try { [EOL] _decodeUtf8_3(0x00); [EOL] fail("Should have thrown IOException due to insufficient data"); [EOL] } catch (IOException e) { [EOL] } [EOL] }
public void testDecodeUtf8_3WithInvalidSecondByte() throws IOException, JsonParseException { [EOL] _inputPtr = 0; [EOL] _inputEnd = 2; [EOL] _inputBuffer = new byte[] {(byte) 0x00, (byte) 0xFF}; // Invalid second byte [EOL] try { [EOL] _decodeUtf8_3(0x00); [EOL] fail("Should have thrown JsonParseException due to invalid second byte"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testDecodeUtf8_3WithInvalidThirdByte() throws IOException, JsonParseException { [EOL] _inputPtr = 0; [EOL] _inputEnd = 3; [EOL] _inputBuffer = new byte[] {(byte) 0x00, (byte) 0x80, (byte) 0xFF}; // Invalid third byte [EOL] try { [EOL] _decodeUtf8_3(0x00); [EOL] fail("Should have thrown JsonParseException due to invalid third byte"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testDecodeUtf8_3WithValidData() throws IOException, JsonParseException { [EOL] _inputPtr = 0; [EOL] _inputEnd = 3; [EOL] _inputBuffer = new byte[] {(byte) 0x00, (byte) 0x80, (byte) 0x80}; // Valid UTF-8 sequence [EOL] int result = _decodeUtf8_3(0x00); [EOL] int expectedResult = 0; // Replace with the actual expected result [EOL] assertEquals(expectedResult, result); [EOL] }
public void testDecodeUtf8_3fastValidInput() throws IOException, JsonParseException { [EOL] _inputBuffer = new byte[] { (byte) 0x88, (byte) 0x80 }; // Valid continuation bytes [EOL] _inputPtr = 0; [EOL] int c1 = 0xE0; // 0xE0 is the start of a 3-byte UTF-8 sequence [EOL] int result = _decodeUtf8_3fast(c1); [EOL] assertEquals(0x00000800, result); // 0x00000800 is the expected result for the input [EOL] }
public void testDecodeUtf8_3fastInvalidSecondByte() throws IOException, JsonParseException { [EOL] _inputBuffer = new byte[] { (byte) 0x48, (byte) 0x80 }; // Invalid second byte (not a continuation byte) [EOL] _inputPtr = 0; [EOL] int c1 = 0xE0; [EOL] try { [EOL] _decodeUtf8_3fast(c1); [EOL] fail("Should have thrown an exception due to invalid second byte"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testDecodeUtf8_3fastInvalidThirdByte() throws IOException, JsonParseException { [EOL] _inputBuffer = new byte[] { (byte) 0x80, (byte) 0x48 }; // Valid second byte, invalid third byte [EOL] _inputPtr = 0; [EOL] int c1 = 0xE0; [EOL] try { [EOL] _decodeUtf8_3fast(c1); [EOL] fail("Should have thrown an exception due to invalid third byte"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testSkipCRWithCRFollowedByLF() throws IOException { [EOL] JsonParser parser = createParserWithContent("\r\n"); [EOL] parser._skipCR(); [EOL] assertEquals("The input pointer should be incremented twice", 2, parser._inputPtr); [EOL] assertEquals("Current input row should be incremented", 1, parser._currInputRow); [EOL] assertEquals("Current input row start should be set to input pointer", parser._inputPtr, parser._currInputRowStart); [EOL] } [EOL] public void testSkipCRWithLFFollowed() throws IOException { [EOL] JsonParser parser = createParserWithContent("\n"); [EOL] parser._skipCR(); [EOL] assertEquals("The input pointer should not be incremented", 0, parser._inputPtr); [EOL] assertEquals("Current input row should be incremented", 1, parser._currInputRow); [EOL] assertEquals("Current input row start should be set to input pointer", parser._inputPtr, parser._currInputRowStart); [EOL] } [EOL] public void testSkipCRWithNoFollowingLF() throws IOException { [EOL] JsonParser parser = createParserWithContent("\r"); [EOL] parser._skipCR(); [EOL] assertEquals("The input pointer should be incremented once", 1, parser._inputPtr); [EOL] assertEquals("Current input row should be incremented", 1, parser._currInputRow); [EOL] assertEquals("Current input row start should be set to input pointer", parser._inputPtr, parser._currInputRowStart); [EOL] } [EOL] public void testSkipCRAtEndOfBuffer() throws IOException { [EOL] JsonParser parser = createParserWithContent(""); [EOL] parser._skipCR(); [EOL] assertEquals("The input pointer should remain the same", 0, parser._inputPtr); [EOL] assertEquals("Current input row should be incremented", 1, parser._currInputRow); [EOL] assertEquals("Current input row start should be set to input pointer", parser._inputPtr, parser._currInputRowStart); [EOL] }
private JsonParser createParserWithContent(String content) { [EOL] return new JsonParser(content.getBytes()); [EOL] }
public void testGrowArrayByWithNullArray() { [EOL] int more = 5; [EOL] int[] result = ClassName.growArrayBy(null, more); [EOL] assertNotNull(result); [EOL] assertEquals(more, result.length); [EOL] }
public void testGrowArrayByWithNonEmptyArray() { [EOL] int[] arr = {1, 2, 3}; [EOL] int more = 2; [EOL] int[] result = ClassName.growArrayBy(arr, more); [EOL] assertNotNull(result); [EOL] assertEquals(arr.length + more, result.length); [EOL] for (int i = 0; i < arr.length; i++) { [EOL] assertEquals(arr[i], result[i]); [EOL] } [EOL] }
public void testIOContextWithNullBufferRecycler() { [EOL] Object sourceRef = new Object(); [EOL] IOContext context = new IOContext(null, sourceRef, true); [EOL] assertNull(context.getBufferRecycler()); [EOL] assertSame(sourceRef, context.getSourceReference()); [EOL] assertTrue(context.isManagedResource()); [EOL] } [EOL] public void testIOContextWithNonNullBufferRecycler() { [EOL] BufferRecycler br = new BufferRecycler(); [EOL] Object sourceRef = new Object(); [EOL] IOContext context = new IOContext(br, sourceRef, false); [EOL] assertSame(br, context.getBufferRecycler()); [EOL] assertSame(sourceRef, context.getSourceReference()); [EOL] assertFalse(context.isManagedResource()); [EOL] }

public void testAllocReadIOBuffer_NewBuffer() { [EOL] BufferRecycler bufferRecycler = new BufferRecycler(); [EOL] IOContext ioContext = new IOContext(bufferRecycler, false); [EOL] byte[] result = ioContext.allocReadIOBuffer(); [EOL] assertNotNull(result); [EOL] assertEquals(BufferRecycler.ByteBufferType.READ_IO_BUFFER.length(), result.length); [EOL] }
public void testAllocReadIOBuffer_ExistingBuffer() { [EOL] BufferRecycler bufferRecycler = new BufferRecycler(); [EOL] IOContext ioContext = new IOContext(bufferRecycler, false); [EOL] byte[] existingBuffer = ioContext.allocReadIOBuffer(); [EOL] byte[] result = ioContext.allocReadIOBuffer(); [EOL] assertNotNull(result); [EOL] assertSame(existingBuffer, result); [EOL] }
public void testAllocWriteEncodingBuffer_NewBuffer() { [EOL] BufferRecycler recycler = new BufferRecycler(); [EOL] JsonFactory factory = new JsonFactory(); [EOL] IOContext context = new IOContext(recycler, new Object(), false); [EOL] byte[] buffer = context.allocWriteEncodingBuffer(); [EOL] assertNotNull(buffer); [EOL] assertTrue(buffer.length > 0); [EOL] }
public void testAllocWriteEncodingBuffer_ExistingBuffer() { [EOL] BufferRecycler recycler = new BufferRecycler(); [EOL] JsonFactory factory = new JsonFactory(); [EOL] IOContext context = new IOContext(recycler, new Object(), false); [EOL] byte[] existingBuffer = context.allocWriteEncodingBuffer(); [EOL] byte[] buffer = context.allocWriteEncodingBuffer(); [EOL] assertSame(existingBuffer, buffer); [EOL] }
public void testAllocTokenBufferWithUninitializedBuffer() { [EOL] JsonFactory factory = new JsonFactory(); [EOL] char[] tokenBuffer = factory.allocTokenBuffer(); [EOL] assertNotNull(tokenBuffer); [EOL] assertTrue(tokenBuffer.length > 0); [EOL] }
public void testAllocTokenBufferWithPreviouslyAllocatedBuffer() { [EOL] JsonFactory factory = new JsonFactory(); [EOL] char[] firstBuffer = factory.allocTokenBuffer(); [EOL] char[] secondBuffer = factory.allocTokenBuffer(); [EOL] assertNotSame(firstBuffer, secondBuffer); [EOL] }
public void testAllocConcatBuffer_WithUnallocatedBuffer() { [EOL] JsonFactory factory = new JsonFactory(); [EOL] BufferRecycler recycler = new BufferRecycler(); [EOL] JsonGenerator generator = factory.createGenerator(new StringWriter()); [EOL] generator._bufferRecycler = recycler; [EOL] char[] result = generator.allocConcatBuffer(); [EOL] assertNotNull(result); [EOL] assertEquals(BufferRecycler.CharBufferType.CONCAT_BUFFER.size(), result.length); [EOL] }
public void testAllocConcatBuffer_WithPreAllocatedBuffer() { [EOL] JsonFactory factory = new JsonFactory(); [EOL] BufferRecycler recycler = new BufferRecycler(); [EOL] JsonGenerator generator = factory.createGenerator(new StringWriter()); [EOL] generator._bufferRecycler = recycler; [EOL] char[] preAllocated = recycler.allocCharBuffer(BufferRecycler.CharBufferType.CONCAT_BUFFER); [EOL] generator._concatCBuffer = preAllocated; [EOL] char[] result = generator.allocConcatBuffer(); [EOL] assertSame(preAllocated, result); [EOL] }
public void testAllocNameCopyBuffer_MinSize() { [EOL] JsonFactory factory = new JsonFactory(); [EOL] BufferRecycler recycler = new BufferRecycler(); [EOL] JsonGenerator generator = factory.createGenerator(new StringWriter()); [EOL] generator._bufferRecycler = recycler; [EOL] int minSize = 10; [EOL] char[] result = generator.allocNameCopyBuffer(minSize); [EOL] assertNotNull(result); [EOL] assertTrue(result.length >= minSize); [EOL] }
public void testAllocNameCopyBuffer_VerifyAlloc() { [EOL] JsonFactory factory = new JsonFactory(); [EOL] BufferRecycler recycler = new BufferRecycler(); [EOL] JsonGenerator generator = factory.createGenerator(new StringWriter()); [EOL] generator._bufferRecycler = recycler; [EOL] generator._nameCopyBuffer = new char[0]; // Pre-allocate to trigger _verifyAlloc [EOL] int minSize = 10; [EOL] char[] result = generator.allocNameCopyBuffer(minSize); [EOL] assertNotNull(result); [EOL] assertTrue(result.length >= minSize); [EOL] assertNotSame(generator._nameCopyBuffer, result); // Ensure a new buffer is allocated [EOL] }
public void testReleaseReadIOBufferWithNonNullBuffer() { [EOL] JsonFactory factory = new JsonFactory(); [EOL] byte[] nonNullBuffer = new byte[10]; [EOL] factory._readIOBuffer = nonNullBuffer; [EOL] factory._bufferRecycler = new BufferRecycler(); [EOL] factory.releaseReadIOBuffer(nonNullBuffer); [EOL] assertNull(factory._readIOBuffer); [EOL] }
public void testReleaseReadIOBufferWithNullBuffer() { [EOL] JsonFactory factory = new JsonFactory(); [EOL] factory._readIOBuffer = new byte[10]; [EOL] factory._bufferRecycler = new BufferRecycler(); [EOL] factory.releaseReadIOBuffer(null); [EOL] assertNotNull(factory._readIOBuffer); [EOL] }
public void testReleaseWriteEncodingBufferWithNonNullBuffer() { [EOL] byte[] nonNullBuffer = new byte[10]; [EOL] BufferRecycler bufferRecycler = new BufferRecycler(); [EOL] JsonGeneratorImpl generator = new JsonGeneratorImpl(bufferRecycler); [EOL] byte[] dummyWriteEncodingBuffer = new byte[10]; [EOL] generator._writeEncodingBuffer = dummyWriteEncodingBuffer; [EOL] generator.releaseWriteEncodingBuffer(nonNullBuffer); [EOL] assertNull(generator._writeEncodingBuffer, "The write encoding buffer should be null after release."); [EOL] assertTrue(bufferRecycler.hasBeenReleased(BufferRecycler.ByteBufferType.WRITE_ENCODING_BUFFER, nonNullBuffer), [EOL] "The non-null buffer should be released to the buffer recycler."); [EOL] }
public void testReleaseWriteEncodingBufferWithNullBuffer() { [EOL] BufferRecycler bufferRecycler = new BufferRecycler(); [EOL] JsonGeneratorImpl generator = new JsonGeneratorImpl(bufferRecycler); [EOL] generator.releaseWriteEncodingBuffer(null); [EOL] assertNull(generator._writeEncodingBuffer, "The write encoding buffer should remain null as no buffer was released."); [EOL] assertFalse(bufferRecycler.hasBeenReleased(BufferRecycler.ByteBufferType.WRITE_ENCODING_BUFFER, null), [EOL] "No buffer should be released to the buffer recycler as the input buffer was null."); [EOL] }
public void testReleaseTokenBufferWithNonNullBuffer() { [EOL] char[] testBuffer = new char[10]; [EOL] JsonFactory factory = new JsonFactory(); [EOL] JsonParser parser = factory.createParser("test"); [EOL] JsonGenerator generator = factory.createGenerator(new StringWriter()); [EOL] generator.releaseTokenBuffer(testBuffer); [EOL] assertNull(generator._tokenCBuffer); [EOL] }
public void testReleaseTokenBufferWithNullBuffer() { [EOL] JsonFactory factory = new JsonFactory(); [EOL] JsonParser parser = factory.createParser("test"); [EOL] JsonGenerator generator = factory.createGenerator(new StringWriter()); [EOL] generator.releaseTokenBuffer(null); [EOL] assertNotNull(generator._tokenCBuffer); [EOL] }
public void testReleaseConcatBufferWithNonNullBuffer() { [EOL] char[] testBuffer = new char[10]; [EOL] JsonGeneratorImpl generator = new JsonGeneratorImpl(...); // provide necessary arguments [EOL] generator._concatCBuffer = testBuffer; [EOL] generator.releaseConcatBuffer(testBuffer); [EOL] assertNull(generator._concatCBuffer); [EOL] }
public void testReleaseConcatBufferWithNullBuffer() { [EOL] JsonGeneratorImpl generator = new JsonGeneratorImpl(...); // provide necessary arguments [EOL] generator._concatCBuffer = null; [EOL] generator.releaseConcatBuffer(null); [EOL] assertNull(generator._concatCBuffer); [EOL] }
public void testReleaseNameCopyBufferWithNonNullBuffer() { [EOL] JsonFactory factory = new JsonFactory(); [EOL] JsonParser parser = factory.createParser("{}"); [EOL] char[] testBuffer = new char[10]; [EOL] parser.releaseNameCopyBuffer(testBuffer); [EOL] assertNull(parser._nameCopyBuffer); [EOL] }
public void testReleaseNameCopyBufferWithNullBuffer() { [EOL] JsonFactory factory = new JsonFactory(); [EOL] JsonParser parser = factory.createParser("{}"); [EOL] char[] testBuffer = null; [EOL] parser.releaseNameCopyBuffer(testBuffer); [EOL] }
public void testVerifyAllocWithNonNullBuffer() { [EOL] try { [EOL] _verifyAlloc(new Object()); [EOL] fail("Expected an IllegalStateException to be thrown"); [EOL] } catch (IllegalStateException e) { [EOL] assertEquals("Trying to call same allocXxx() method second time", e.getMessage()); [EOL] } [EOL] }
public void testVerifyAllocWithNullBuffer() { [EOL] _verifyAlloc(null); // Should not throw an exception [EOL] }
public void testVerifyReleaseWithMatchingObjects() { [EOL] Object obj = new Object(); [EOL] try { [EOL] _verifyRelease(obj, obj); [EOL] } catch (IllegalArgumentException e) { [EOL] fail("No exception should be thrown if objects match"); [EOL] } [EOL] } [EOL] public void testVerifyReleaseWithDifferentObjects() { [EOL] Object toRelease = new Object(); [EOL] Object src = new Object(); [EOL] try { [EOL] _verifyRelease(toRelease, src); [EOL] fail("Exception should be thrown if objects do not match"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Trying to release buffer not owned by the context", e.getMessage()); [EOL] } [EOL] }
public void testFindFormat_NoDetectors() throws IOException { [EOL] InputAccessor.Std acc = mock(InputAccessor.Std.class); [EOL] DataFormatMatcher matcher = _findFormat(acc); [EOL] assertNull(matcher.getMatchedFormat()); [EOL] }
public void testFindFormat_WithDetectors_NoMatch() throws IOException { [EOL] InputAccessor.Std acc = mock(InputAccessor.Std.class); [EOL] JsonFactory factory = mock(JsonFactory.class); [EOL] when(factory.hasFormat(acc)).thenReturn(null); [EOL] _detectors.add(factory); [EOL] DataFormatMatcher matcher = _findFormat(acc); [EOL] assertNull(matcher.getMatchedFormat()); [EOL] }
public void testFindFormat_WithDetectors_BelowMinimalMatch() throws IOException { [EOL] InputAccessor.Std acc = mock(InputAccessor.Std.class); [EOL] JsonFactory factory = mock(JsonFactory.class); [EOL] when(factory.hasFormat(acc)).thenReturn(MatchStrength.WEAK); [EOL] _minimalMatch = MatchStrength.SOLID_MATCH; [EOL] _detectors.add(factory); [EOL] DataFormatMatcher matcher = _findFormat(acc); [EOL] assertNull(matcher.getMatchedFormat()); [EOL] }
public void testFindFormat_WithDetectors_ExactMinimalMatch() throws IOException { [EOL] InputAccessor.Std acc = mock(InputAccessor.Std.class); [EOL] JsonFactory factory = mock(JsonFactory.class); [EOL] when(factory.hasFormat(acc)).thenReturn(MatchStrength.SOLID_MATCH); [EOL] _minimalMatch = MatchStrength.SOLID_MATCH; [EOL] _detectors.add(factory); [EOL] DataFormatMatcher matcher = _findFormat(acc); [EOL] assertNotNull(matcher.getMatchedFormat()); [EOL] }
public void testFindFormat_WithDetectors_BestMatch() throws IOException { [EOL] InputAccessor.Std acc = mock(InputAccessor.Std.class); [EOL] JsonFactory factory1 = mock(JsonFactory.class); [EOL] JsonFactory factory2 = mock(JsonFactory.class); [EOL] when(factory1.hasFormat(acc)).thenReturn(MatchStrength.SOLID_MATCH); [EOL] when(factory2.hasFormat(acc)).thenReturn(MatchStrength.FULL_MATCH); [EOL] _minimalMatch = MatchStrength.SOLID_MATCH; [EOL] _optimalMatch = MatchStrength.FULL_MATCH; [EOL] _detectors.add(factory1); [EOL] _detectors.add(factory2); [EOL] DataFormatMatcher matcher = _findFormat(acc); [EOL] assertEquals(factory2, matcher.getMatchedFactory()); [EOL] }
public void testFindFormat_WithDetectors_OptimalMatch() throws IOException { [EOL] InputAccessor.Std acc = mock(InputAccessor.Std.class); [EOL] JsonFactory factory = mock(JsonFactory.class); [EOL] when(factory.hasFormat(acc)).thenReturn(MatchStrength.FULL_MATCH); [EOL] _minimalMatch = MatchStrength.SOLID_MATCH; [EOL] _optimalMatch = MatchStrength.FULL_MATCH; [EOL] _detectors.add(factory); [EOL] DataFormatMatcher matcher = _findFormat(acc); [EOL] assertEquals(MatchStrength.FULL_MATCH, matcher.getMatchStrength()); [EOL] }
public void testReadValueAsTreeWithNonNullCodec() throws IOException, JsonProcessingException { [EOL] JsonParser parser = mock(JsonParser.class); [EOL] ObjectCodec codec = mock(ObjectCodec.class); [EOL] TreeNode expectedNode = mock(TreeNode.class); [EOL] when(parser.getCodec()).thenReturn(codec); [EOL] when(codec.readTree(parser)).thenReturn(expectedNode); [EOL] TreeNode resultNode = parser.readValueAsTree(); [EOL] assertNotNull(resultNode); [EOL] assertSame(expectedNode, resultNode); [EOL] }
public void testReadValueAsTreeWithNullCodec() { [EOL] JsonParser parser = mock(JsonParser.class); [EOL] when(parser.getCodec()).thenReturn(null); [EOL] try { [EOL] parser.readValueAsTree(); [EOL] fail("Expected IllegalStateException"); [EOL] } catch (IllegalStateException e) { [EOL] assertEquals("No ObjectCodec defined for the parser, can not deserialize JSON into JsonNode tree", e.getMessage()); [EOL] } catch (Exception e) { [EOL] fail("Expected IllegalStateException, but got " + e.getClass().getSimpleName()); [EOL] } [EOL] }
public void testJsonGeneratorImplWithEscapeNonAscii() { [EOL] IOContext ctxt = new IOContext(new BufferRecycler(), new Object(), false); [EOL] int features = JsonGenerator.Feature.ESCAPE_NON_ASCII.getMask(); [EOL] ObjectCodec codec = new ObjectMapper(); [EOL] JsonGeneratorImpl generator = new JsonGeneratorImpl(ctxt, features, codec); [EOL] assertEquals(127, generator.getHighestNonEscapedChar()); [EOL] }
public void testJsonGeneratorImplWithoutEscapeNonAscii() { [EOL] IOContext ctxt = new IOContext(new BufferRecycler(), new Object(), false); [EOL] int features = 0; // Assuming no features are enabled [EOL] ObjectCodec codec = new ObjectMapper(); [EOL] JsonGeneratorImpl generator = new JsonGeneratorImpl(ctxt, features, codec); [EOL] assertEquals(0, generator.getHighestNonEscapedChar()); // Default should be 0 if ESCAPE_NON_ASCII is not enabled [EOL] }
public void testVersion() { [EOL] MyClass obj = new MyClass(); [EOL] Version result = obj.version(); [EOL] assertNotNull(result); [EOL] assertEquals(result, VersionUtil.versionFor(MyClass.class)); [EOL] }
public void testResetWithSharedWithoutSegments() { [EOL] YourClass instance = new YourClass(); [EOL] char[] buffer = new char[]{'a', 'b', 'c'}; [EOL] int start = 1; [EOL] int len = 2; [EOL] instance.setHasSegments(false); // Assuming there is a method to set _hasSegments [EOL] instance.resetWithShared(buffer, start, len); [EOL] assertNull(instance.getResultString()); [EOL] assertNull(instance.getResultArray()); [EOL] assertSame(buffer, instance.getInputBuffer()); [EOL] assertEquals(start, instance.getInputStart()); [EOL] assertEquals(len, instance.getInputLen()); [EOL] }
public void testResetWithSharedWithSegments() { [EOL] YourClass instance = new YourClass(); [EOL] char[] buffer = new char[]{'x', 'y', 'z'}; [EOL] int start = 0; [EOL] int len = 3; [EOL] instance.setHasSegments(true); // Assuming there is a method to set _hasSegments [EOL] instance.resetWithShared(buffer, start, len); [EOL] assertNull(instance.getResultString()); [EOL] assertNull(instance.getResultArray()); [EOL] assertSame(buffer, instance.getInputBuffer()); [EOL] assertEquals(start, instance.getInputStart()); [EOL] assertEquals(len, instance.getInputLen()); [EOL] assertTrue(instance.isSegmentsCleared()); // Assuming there is a method to check if segments were cleared [EOL] }
public void testResetWithCopy_HasSegments() { [EOL] TextBuffer testBuffer = new TextBuffer(); [EOL] testBuffer.resetWithCopy(new char[]{'a', 'b', 'c'}, 0, 3); [EOL] assertNull(testBuffer._inputBuffer); [EOL] assertEquals(-1, testBuffer._inputStart); [EOL] assertEquals(0, testBuffer._inputLen); [EOL] assertNull(testBuffer._resultString); [EOL] assertNull(testBuffer._resultArray); [EOL] assertTrue(testBuffer._hasSegments); [EOL] assertEquals(0, testBuffer._currentSize); [EOL] assertEquals(0, testBuffer._segmentSize); [EOL] assertEquals("abc", new String(testBuffer._currentSegment, 0, testBuffer._currentSize)); [EOL] }
public void testResetWithCopy_NoSegmentsNoCurrentSegment() { [EOL] TextBuffer testBuffer = new TextBuffer(); [EOL] testBuffer._hasSegments = false; [EOL] testBuffer._currentSegment = null; [EOL] testBuffer.resetWithCopy(new char[]{'x', 'y', 'z'}, 1, 2); [EOL] assertNull(testBuffer._inputBuffer); [EOL] assertEquals(-1, testBuffer._inputStart); [EOL] assertEquals(0, testBuffer._inputLen); [EOL] assertNull(testBuffer._resultString); [EOL] assertNull(testBuffer._resultArray); [EOL] assertFalse(testBuffer._hasSegments); [EOL] assertNotNull(testBuffer._currentSegment); [EOL] assertEquals(0, testBuffer._currentSize); [EOL] assertEquals(testBuffer._currentSegment.length, testBuffer._segmentSize); [EOL] assertEquals("yz", new String(testBuffer._currentSegment, 0, testBuffer._currentSize)); [EOL] }
public void testClearSegments() { [EOL] instance._hasSegments = true; [EOL] instance._segments.add(new Object()); // Assuming _segments is a List or similar [EOL] instance._currentSize = 10; [EOL] instance._segmentSize = 5; [EOL] instance.clearSegments(); [EOL] assertFalse(instance._hasSegments); [EOL] assertTrue(instance._segments.isEmpty()); [EOL] assertEquals(0, instance._currentSize); [EOL] assertEquals(0, instance._segmentSize); [EOL] }
public void testGetTextBuffer_InputStartGreaterThanOrEqualToZero() { [EOL] YourClassUnderTest instance = createInstanceWithInputStartSet(); [EOL] char[] result = instance.getTextBuffer(); [EOL] assertNotNull(result); [EOL] assertSame(instance._inputBuffer, result); // meaningful assertion [EOL] }
public void testGetTextBuffer_ResultArrayNotNull() { [EOL] YourClassUnderTest instance = createInstanceWithResultArraySet(); [EOL] char[] result = instance.getTextBuffer(); [EOL] assertNotNull(result); [EOL] assertSame(instance._resultArray, result); // meaningful assertion [EOL] }
public void testGetTextBuffer_ResultStringNotNull() { [EOL] YourClassUnderTest instance = createInstanceWithResultStringSet(); [EOL] char[] result = instance.getTextBuffer(); [EOL] assertNotNull(result); [EOL] assertSame(instance._resultArray, result); // meaningful assertion [EOL] assertTrue(Arrays.equals(instance._resultString.toCharArray(), result)); // meaningful assertion [EOL] }
public void testGetTextBuffer_HasNoSegments() { [EOL] YourClassUnderTest instance = createInstanceWithNoSegments(); [EOL] char[] result = instance.getTextBuffer(); [EOL] assertNotNull(result); [EOL] assertSame(instance._currentSegment, result); // meaningful assertion [EOL] }
public void testGetTextBuffer_ContentsAsArray() { [EOL] YourClassUnderTest instance = createInstanceForContentsAsArray(); [EOL] char[] result = instance.getTextBuffer(); [EOL] assertNotNull(result); [EOL] char[] expected = instance.contentsAsArray(); [EOL] assertTrue(Arrays.equals(expected, result)); // meaningful assertion [EOL] }
public void testContentsAsString_resultStringNullAndResultArrayNotNull() { [EOL] instance._resultString = null; [EOL] instance._resultArray = new char[]{'a', 'b', 'c'}; [EOL] String result = instance.contentsAsString(); [EOL] assertEquals("abc", result); [EOL] }
public void testContentsAsString_resultStringNullAndInputStartNotNegative() { [EOL] instance._resultString = null; [EOL] instance._resultArray = null; [EOL] instance._inputStart = 0; [EOL] instance._inputLen = 3; [EOL] instance._inputBuffer = new char[]{'x', 'y', 'z'}; [EOL] String result = instance.contentsAsString(); [EOL] assertEquals("xyz", result); [EOL] }
public void testContentsAsString_resultStringNullAndInputLenLessThanOne() { [EOL] instance._resultString = null; [EOL] instance._resultArray = null; [EOL] instance._inputStart = 0; [EOL] instance._inputLen = 0; [EOL] String result = instance.contentsAsString(); [EOL] assertEquals("", result); [EOL] }
public void testContentsAsString_resultStringNullAndSegmentSizeZeroAndCurrentSizeZero() { [EOL] instance._resultString = null; [EOL] instance._resultArray = null; [EOL] instance._inputStart = -1; [EOL] instance._segmentSize = 0; [EOL] instance._currentSize = 0; [EOL] String result = instance.contentsAsString(); [EOL] assertEquals("", result); [EOL] }
public void testContentsAsString_resultStringNullAndSegmentSizeZeroAndCurrentSizeNotZero() { [EOL] instance._resultString = null; [EOL] instance._resultArray = null; [EOL] instance._inputStart = -1; [EOL] instance._segmentSize = 0; [EOL] instance._currentSize = 2; [EOL] instance._currentSegment = new char[]{'u', 'v'}; [EOL] String result = instance.contentsAsString(); [EOL] assertEquals("uv", result); [EOL] }
public void testContentsAsString_resultStringNullAndSegmentsNotNull() { [EOL] instance._resultString = null; [EOL] instance._resultArray = null; [EOL] instance._inputStart = -1; [EOL] instance._segmentSize = 1; [EOL] instance._currentSize = 1; [EOL] instance._currentSegment = new char[]{'w'}; [EOL] instance._segments = new ArrayList<>(); [EOL] instance._segments.add(new char[]{'p', 'q'}); [EOL] instance._segments.add(new char[]{'r', 's'}); [EOL] String result = instance.contentsAsString(); [EOL] assertEquals("pqrsw", result); [EOL] }
public void testContentsAsString_resultStringNotNull() { [EOL] instance._resultString = "precomputed"; [EOL] String result = instance.contentsAsString(); [EOL] assertEquals("precomputed", result); [EOL] }
public void testAppendWithInputStartNegative() { [EOL] TextBuffer buffer = new TextBuffer(); [EOL] char[] input = new char[]{'a', 'b', 'c'}; [EOL] buffer.append(input, 0, 3); [EOL] assertEquals("abc", buffer.contentsAsString()); [EOL] }
public void testAppendWithInputStartNonNegativeAndEnoughSpace() { [EOL] TextBuffer buffer = new TextBuffer(); [EOL] buffer.setCurrentSegment(new char[10]); [EOL] buffer.setInputStart(0); [EOL] char[] input = new char[]{'a', 'b', 'c'}; [EOL] buffer.append(input, 0, 3); [EOL] assertEquals("abc", buffer.contentsAsString()); [EOL] }
public void testAppendWithInputStartNonNegativeAndPartialSpace() { [EOL] TextBuffer buffer = new TextBuffer(); [EOL] buffer.setCurrentSegment(new char[2]); [EOL] buffer.setInputStart(0); [EOL] char[] input = new char[]{'a', 'b', 'c'}; [EOL] buffer.append(input, 0, 3); [EOL] assertEquals("abc", buffer.contentsAsString()); [EOL] }
public void testAppendWithInputStartNonNegativeAndNoSpace() { [EOL] TextBuffer buffer = new TextBuffer(); [EOL] buffer.setCurrentSegment(new char[0]); [EOL] buffer.setInputStart(0); [EOL] char[] input = new char[]{'a', 'b', 'c'}; [EOL] buffer.append(input, 0, 3); [EOL] assertEquals("abc", buffer.contentsAsString()); [EOL] }
public void testAppendWithInputStartNegative() { [EOL] setupWithNegativeInputStart(); [EOL] String str = "test"; [EOL] int offset = 0; [EOL] int len = 4; [EOL] append(str, offset, len); [EOL] assertEquals("test", getCurrentSegmentAsString()); [EOL] assertEquals(4, getCurrentSize()); [EOL] }
public void testAppendWithEnoughRoomInCurrentSegment() { [EOL] setupWithEnoughRoom(); [EOL] String str = "test"; [EOL] int offset = 0; [EOL] int len = 2; [EOL] append(str, offset, len); [EOL] assertEquals("te", getCurrentSegmentAsString()); [EOL] assertEquals(2, getCurrentSize()); [EOL] }
public void testAppendWithPartialRoomInCurrentSegment() { [EOL] setupWithPartialRoom(); [EOL] String str = "test"; [EOL] int offset = 0; [EOL] int len = 4; [EOL] append(str, offset, len); [EOL] assertEquals("test", getCurrentSegmentAsString()); [EOL] assertEquals(4, getCurrentSize()); [EOL] }
public void testAppendWithNoRoomInCurrentSegment() { [EOL] setupWithNoRoom(); [EOL] String str = "test"; [EOL] int offset = 0; [EOL] int len = 4; [EOL] append(str, offset, len); [EOL] assertEquals("test", getCurrentSegmentAsString()); [EOL] assertEquals(4, getCurrentSize()); [EOL] }
public void testAppendWithExpansion() { [EOL] setupWithExpansionNeeded(); [EOL] String str = "test"; [EOL] int offset = 0; [EOL] int len = 4; [EOL] append(str, offset, len); [EOL] assertEquals("test", getCurrentSegmentAsString()); [EOL] assertEquals(4, getCurrentSize()); [EOL] }
public void testGetCurrentSegment_InputStartNotNegative() { [EOL] YourClass instance = new YourClass(); [EOL] instance._inputStart = 1; // assuming _inputStart is accessible, otherwise use a setter or constructor [EOL] instance._currentSegment = new char[]{'a', 'b', 'c'}; [EOL] instance._currentSize = 2; [EOL] char[] result = instance.getCurrentSegment(); [EOL] assertNotNull(result); [EOL] assertEquals(instance._currentSegment, result); [EOL] }
public void testGetCurrentSegment_CurrentSegmentNull() { [EOL] YourClass instance = new YourClass(); [EOL] instance._inputStart = -1; [EOL] instance._currentSegment = null; [EOL] instance._currentSize = 0; [EOL] char[] result = instance.getCurrentSegment(); [EOL] assertNotNull(result); [EOL] assertEquals(instance._currentSegment, result); [EOL] }
public void testGetCurrentSegment_CurrentSegmentNeedsExpansion() { [EOL] YourClass instance = new YourClass(); [EOL] instance._inputStart = -1; [EOL] instance._currentSegment = new char[]{'a', 'b'}; [EOL] instance._currentSize = 2; // assuming the length of _currentSegment is also 2 [EOL] char[] result = instance.getCurrentSegment(); [EOL] assertNotNull(result); [EOL] assertTrue(result.length > instance._currentSegment.length); [EOL] assertEquals(instance._currentSegment, result); [EOL] }
public void testGetCurrentSegmentSize_WhenCurrentSizeIsSet() { [EOL] JsonParser parser = createParserWithSegmentSize(10); [EOL] int currentSegmentSize = parser.getCurrentSegmentSize(); [EOL] assertEquals(10, currentSegmentSize); [EOL] }
public void testGetCurrentSegmentSize_WhenCurrentSizeIsDefault() { [EOL] JsonParser parser = createParserWithDefaultSettings(); [EOL] int currentSegmentSize = parser.getCurrentSegmentSize(); [EOL] assertEquals(0, currentSegmentSize); [EOL] }
public void testExpandWithNullSegments() { [EOL] int minNewSegmentSize = 1000; [EOL] expand(minNewSegmentSize); [EOL] assertNotNull(_segments); [EOL] assertTrue(_hasSegments); [EOL] assertEquals(1, _segments.size()); [EOL] assertTrue(_segmentSize > 0); [EOL] assertNotNull(_currentSegment); [EOL] assertEquals(Math.min(MAX_SEGMENT_LEN, _currentSegment.length), _currentSegment.length); [EOL] assertEquals(0, _currentSize); [EOL] }
public void testExpandWithSmallCurrentSegment() { [EOL] int minNewSegmentSize = 1000; [EOL] int initialSegmentSize = 500; // smaller than minNewSegmentSize [EOL] _currentSegment = new char[initialSegmentSize]; [EOL] _segments = new ArrayList<char[]>(); [EOL] _segments.add(_currentSegment); [EOL] _segmentSize = initialSegmentSize; [EOL] expand(minNewSegmentSize); [EOL] assertEquals(2, _segments.size()); [EOL] assertEquals(initialSegmentSize, _segmentSize); [EOL] assertTrue(_currentSegment.length >= minNewSegmentSize); [EOL] assertEquals(0, _currentSize); [EOL] }
public void testExpandWithLargeCurrentSegment() { [EOL] int minNewSegmentSize = 1000; [EOL] int initialSegmentSize = 2000; // larger than minNewSegmentSize [EOL] _currentSegment = new char[initialSegmentSize]; [EOL] _segments = new ArrayList<char[]>(); [EOL] _segments.add(_currentSegment); [EOL] _segmentSize = initialSegmentSize; [EOL] expand(minNewSegmentSize); [EOL] assertEquals(2, _segments.size()); [EOL] assertEquals(initialSegmentSize, _segmentSize); [EOL] assertTrue(_currentSegment.length >= (initialSegmentSize + (initialSegmentSize >> 1))); [EOL] assertEquals(0, _currentSize); [EOL] }
public void testBuildResultArray_ResultStringNotNull() { [EOL] TextBuffer testInstance = new TextBuffer(); [EOL] testInstance._resultString = "test"; [EOL] char[] result = testInstance.buildResultArray(); [EOL] assertArrayEquals("test".toCharArray(), result); [EOL] }
public void testBuildResultArray_InputStartNotNegativeAndInputLenZero() { [EOL] TextBuffer testInstance = new TextBuffer(); [EOL] testInstance._inputStart = 0; [EOL] testInstance._inputLen = 0; [EOL] char[] result = testInstance.buildResultArray(); [EOL] assertArrayEquals(TextBuffer.NO_CHARS, result); [EOL] }
public void testBuildResultArray_InputStartZero() { [EOL] TextBuffer testInstance = new TextBuffer(); [EOL] testInstance._inputStart = 0; [EOL] testInstance._inputLen = 3; [EOL] testInstance._inputBuffer = new char[]{'a', 'b', 'c'}; [EOL] char[] result = testInstance.buildResultArray(); [EOL] assertArrayEquals(new char[]{'a', 'b', 'c'}, result); [EOL] }
public void testBuildResultArray_InputStartPositive() { [EOL] TextBuffer testInstance = new TextBuffer(); [EOL] testInstance._inputStart = 1; [EOL] testInstance._inputLen = 2; [EOL] testInstance._inputBuffer = new char[]{'a', 'b', 'c'}; [EOL] char[] result = testInstance.buildResultArray(); [EOL] assertArrayEquals(new char[]{'b', 'c'}, result); [EOL] }
public void testBuildResultArray_SizeZero() { [EOL] TextBuffer testInstance = new TextBuffer(); [EOL] testInstance._inputStart = -1; [EOL] testInstance._inputLen = 0; [EOL] char[] result = testInstance.buildResultArray(); [EOL] assertArrayEquals(TextBuffer.NO_CHARS, result); [EOL] }
public void testBuildResultArray_SegmentsNotNull() { [EOL] TextBuffer testInstance = new TextBuffer(); [EOL] testInstance._inputStart = -1; [EOL] testInstance._segments = new ArrayList<>(); [EOL] testInstance._segments.add(new char[]{'a', 'b'}); [EOL] testInstance._segments.add(new char[]{'c', 'd'}); [EOL] testInstance._currentSegment = new char[]{'e', 'f'}; [EOL] testInstance._currentSize = 2; [EOL] char[] result = testInstance.buildResultArray(); [EOL] assertArrayEquals(new char[]{'a', 'b', 'c', 'd', 'e', 'f'}, result); [EOL] }
public void testGeneratorBaseWithDefaultCodec() { [EOL] int features = 0; // Assuming 0 is the default feature set [EOL] ObjectCodec codec = null; // Assuming null is the default codec [EOL] GeneratorBase generator = new GeneratorBase(features, codec) { [EOL] @Override [EOL] protected void _releaseBuffers() { [EOL] } [EOL] @Override [EOL] protected void _flushBuffer() { [EOL] } [EOL] }; [EOL] assertNotNull(generator); [EOL] assertEquals(features, generator._features); [EOL] assertNotNull(generator._writeContext); [EOL] assertNull(generator._objectCodec); [EOL] assertFalse(generator._cfgNumbersAsStrings); [EOL] }
public void testGeneratorBaseWithCustomCodec() { [EOL] int features = GeneratorBase.Feature.WRITE_NUMBERS_AS_STRINGS.getMask(); [EOL] ObjectCodec codec = new ObjectMapper(); // Using ObjectMapper as an example codec [EOL] GeneratorBase generator = new GeneratorBase(features, codec) { [EOL] @Override [EOL] protected void _releaseBuffers() { [EOL] } [EOL] @Override [EOL] protected void _flushBuffer() { [EOL] } [EOL] }; [EOL] assertNotNull(generator); [EOL] assertEquals(features, generator._features); [EOL] assertNotNull(generator._writeContext); [EOL] assertSame(codec, generator._objectCodec); [EOL] assertTrue(generator._cfgNumbersAsStrings); [EOL] }
public void testIsEnabledWithFeatureEnabled() { [EOL] JsonFactory factory = new JsonFactory(); [EOL] assertTrue(factory.isEnabled(Feature.ENABLED_FEATURE)); [EOL] }
public void testIsEnabledWithFeatureDisabled() { [EOL] JsonFactory factory = new JsonFactory(); [EOL] assertFalse(factory.isEnabled(Feature.DISABLED_FEATURE)); [EOL] }
public void testGetOutputContext() { [EOL] JsonWriteContext expectedContext = new JsonWriteContext(1, null, null); [EOL] JsonGenerator generator = new JsonGenerator(); // Assuming JsonGenerator is the class that contains getOutputContext [EOL] generator._writeContext = expectedContext; // Assuming _writeContext is accessible or can be set through a constructor or method [EOL] JsonWriteContext actualContext = generator.getOutputContext(); [EOL] assertEquals(expectedContext, actualContext); [EOL] }
public void testCloseSetsClosedToTrue() throws IOException { [EOL] JsonGenerator gen = createJsonGenerator(); // Assuming createJsonGenerator() is a method that creates an instance of the JsonGenerator [EOL] gen.close(); [EOL] assertTrue(gen.isClosed()); // Assuming isClosed() is a method that checks if the JsonGenerator is closed [EOL] }
public void testWriteStartArrayWithPrettyPrinter() throws IOException { [EOL] IOContext ctxt = new IOContext(new BufferRecycler(), new OutputStream() { [EOL] @Override [EOL] public void write(int b) throws IOException { [EOL] } [EOL] }, false); [EOL] UTF8JsonGenerator gen = new UTF8JsonGenerator(ctxt, 0, null, new ByteArrayOutputStream()); [EOL] gen.setPrettyPrinter(new MinimalPrettyPrinter()); [EOL] gen.writeStartArray(); [EOL] assertNotNull(gen.getOutputTarget()); [EOL] gen.close(); [EOL] }
public void testWriteStartArrayWithoutPrettyPrinterAndBufferNotEmpty() throws IOException { [EOL] IOContext ctxt = new IOContext(new BufferRecycler(), new OutputStream() { [EOL] @Override [EOL] public void write(int b) throws IOException { [EOL] } [EOL] }, false); [EOL] UTF8JsonGenerator gen = new UTF8JsonGenerator(ctxt, 0, null, new ByteArrayOutputStream(), new byte[200], 199, true); [EOL] gen.writeStartArray(); [EOL] assertNotNull(gen.getOutputTarget()); [EOL] gen.close(); [EOL] }
public void testWriteStartArrayWithoutPrettyPrinterAndBufferFull() throws IOException { [EOL] IOContext ctxt = new IOContext(new BufferRecycler(), new OutputStream() { [EOL] @Override [EOL] public void write(int b) throws IOException { [EOL] } [EOL] }, false); [EOL] UTF8JsonGenerator gen = new UTF8JsonGenerator(ctxt, 0, null, new ByteArrayOutputStream(), new byte[200], 200, true); [EOL] gen.writeStartArray(); [EOL] assertNotNull(gen.getOutputTarget()); [EOL] gen.close(); [EOL] }
public void testWriteEndArrayNotInArrayContext() throws IOException { [EOL] UTF8JsonGenerator generator = createGeneratorWithMockedContext(JsonStreamContext.TYPE_ROOT); [EOL] try { [EOL] generator.writeEndArray(); [EOL] fail("Expected JsonGenerationException"); [EOL] } catch (JsonGenerationException e) { [EOL] } [EOL] } [EOL] public void testWriteEndArrayWithPrettyPrinter() throws IOException { [EOL] UTF8JsonGenerator generator = createGeneratorWithMockedContext(JsonStreamContext.TYPE_ARRAY); [EOL] PrettyPrinter pp = mock(PrettyPrinter.class); [EOL] generator.setPrettyPrinter(pp); [EOL] generator.writeEndArray(); [EOL] verify(pp).writeEndArray(generator, 0); [EOL] } [EOL] public void testWriteEndArrayWithoutPrettyPrinter() throws IOException { [EOL] UTF8JsonGenerator generator = createGeneratorWithMockedContextAndOutputBuffer(JsonStreamContext.TYPE_ARRAY); [EOL] generator.writeEndArray(); [EOL] assertEquals(BYTE_RBRACKET, generator.getOutputBuffer()[0]); [EOL] } [EOL] public void testWriteEndArrayFlushBuffer() throws IOException { [EOL] UTF8JsonGenerator generator = createGeneratorWithMockedContextAndFullOutputBuffer(JsonStreamContext.TYPE_ARRAY); [EOL] generator.writeEndArray(); [EOL] assertEquals(BYTE_RBRACKET, generator.getOutputBuffer()[0]); [EOL] }
private UTF8JsonGenerator createGeneratorWithMockedContext(int contextType) { [EOL] IOContext ioContext = new IOContext(new BufferRecycler(), null, false); [EOL] OutputStream out = new ByteArrayOutputStream(); [EOL] UTF8JsonGenerator generator = new UTF8JsonGenerator(ioContext, 0, null, out); [EOL] JsonStreamContext context = new JsonStreamContext(contextType) { [EOL] @Override [EOL] public JsonStreamContext getParent() { [EOL] return null; [EOL] } [EOL] }; [EOL] generator.setContext(context); [EOL] return generator; [EOL] } [EOL] private UTF8JsonGenerator createGeneratorWithMockedContextAndOutputBuffer(int contextType) { [EOL] IOContext ioContext = new IOContext(new BufferRecycler(), null, false); [EOL] OutputStream out = new ByteArrayOutputStream(); [EOL] byte[] outputBuffer = new byte[1]; [EOL] UTF8JsonGenerator generator = new UTF8JsonGenerator(ioContext, 0, null, out, outputBuffer, 0, true); [EOL] JsonStreamContext context = new JsonStreamContext(contextType) { [EOL] @Override [EOL] public JsonStreamContext getParent() { [EOL] return null; [EOL] } [EOL] }; [EOL] generator.setContext(context); [EOL] return generator; [EOL] } [EOL] private UTF8JsonGenerator createGeneratorWithMockedContextAndFullOutputBuffer(int contextType) { [EOL] IOContext ioContext = new IOContext(new BufferRecycler(), null, false); [EOL] OutputStream out = new ByteArrayOutputStream(); [EOL] byte[] outputBuffer = new byte[0]; // Full buffer to trigger _flushBuffer [EOL] UTF8JsonGenerator generator = new UTF8JsonGenerator(ioContext, 0, null, out, outputBuffer, 0, true); [EOL] JsonStreamContext context = new JsonStreamContext(contextType) { [EOL] @Override [EOL] public JsonStreamContext getParent() { [EOL] return null; [EOL] } [EOL] }; [EOL] generator.setContext(context); [EOL] return generator; [EOL] }
public void testWriteStringWithNullText() throws IOException { [EOL] UTF8JsonGenerator generator = createGenerator(); [EOL] generator.writeString(null); [EOL] }
public void testWriteStringWithEmptyText() throws IOException { [EOL] UTF8JsonGenerator generator = createGenerator(); [EOL] generator.writeString(""); [EOL] }
public void testWriteStringWithLongText() throws IOException { [EOL] UTF8JsonGenerator generator = createGenerator(); [EOL] String longText = createLongText(); [EOL] generator.writeString(longText); [EOL] }
public void testWriteStringWithMaxLengthText() throws IOException { [EOL] UTF8JsonGenerator generator = createGenerator(); [EOL] String maxLengthText = createMaxLengthText(); [EOL] generator.writeString(maxLengthText); [EOL] }
public void testWriteStringWithTextCausingBufferFlush() throws IOException { [EOL] UTF8JsonGenerator generator = createGenerator(); [EOL] String textCausingFlush = createTextCausingFlush(); [EOL] generator.writeString(textCausingFlush); [EOL] }
public void testWriteStringWithRegularText() throws IOException { [EOL] UTF8JsonGenerator generator = createGenerator(); [EOL] generator.writeString("regular text"); [EOL] } [EOL] private UTF8JsonGenerator createGenerator() { [EOL] } [EOL] private String createLongText() { [EOL] } [EOL] private String createMaxLengthText() { [EOL] } [EOL] private String createTextCausingFlush() { [EOL] }
public void testWriteLongStringWithBufferFlush() throws IOException, JsonGenerationException { [EOL] UTF8JsonGenerator generator = createGeneratorWithSmallBuffer(); [EOL] char[] text = "longStringThatExceedsBufferCapacity".toCharArray(); [EOL] int offset = 0; [EOL] int len = text.length; [EOL] generator._writeLongString(text, offset, len); [EOL] assertEquals(BYTE_QUOTE, generator._outputBuffer[generator._outputTail - 1]); [EOL] assertTrue(generator._outputTail < generator._outputEnd); [EOL] }
public void testWriteLongStringWithoutBufferFlush() throws IOException, JsonGenerationException { [EOL] UTF8JsonGenerator generator = createGeneratorWithLargeBuffer(); [EOL] char[] text = "shortString".toCharArray(); [EOL] int offset = 0; [EOL] int len = text.length; [EOL] generator._writeLongString(text, offset, len); [EOL] assertEquals(BYTE_QUOTE, generator._outputBuffer[generator._outputTail - 1]); [EOL] assertTrue(generator._outputTail < generator._outputEnd); [EOL] }
@Override [EOL] public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException { [EOL] _verifyValueWrite("write text value"); [EOL] if (_outputTail >= _outputEnd) { [EOL] _flushBuffer(); [EOL] } [EOL] _outputBuffer[_outputTail++] = BYTE_QUOTE; [EOL] _writeBytes(text, offset, length); [EOL] if (_outputTail >= _outputEnd) { [EOL] _flushBuffer(); [EOL] } [EOL] _outputBuffer[_outputTail++] = BYTE_QUOTE; [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }];
@Override [EOL] protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException { [EOL] int status = _writeContext.writeValue(); [EOL] if (status == JsonWriteContext.STATUS_EXPECT_NAME) { [EOL] _reportError("Can not " + typeMsg + ", expecting field name"); [EOL] } [EOL] if (_cfgPrettyPrinter == null) { [EOL] byte b; [EOL] switch(status) { [EOL] case JsonWriteContext.STATUS_OK_AFTER_COMMA: [EOL] b = BYTE_COMMA; [EOL] break; [EOL] case JsonWriteContext.STATUS_OK_AFTER_COLON: [EOL] b = BYTE_COLON; [EOL] break; [EOL] case JsonWriteContext.STATUS_OK_AFTER_SPACE: [EOL] if (_rootValueSeparator != null) { [EOL] byte[] raw = _rootValueSeparator.asUnquotedUTF8(); [EOL] if (raw.length > 0) { [EOL] _writeBytes(raw); [EOL] } [EOL] } [EOL] return; [EOL] case JsonWriteContext.STATUS_OK_AS_IS: [EOL] default: [EOL] return; [EOL] } [EOL] if (_outputTail >= _outputEnd) { [EOL] _flushBuffer(); [EOL] } [EOL] _outputBuffer[_outputTail] = b; [EOL] ++_outputTail; [EOL] return; [EOL] } [EOL] _verifyPrettyValueWrite(typeMsg, status); [EOL] } [EOL] public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); [EOL] public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); [EOL] public Object getOutputTarget(); [EOL] public final void writeFieldName(String name) throws IOException, JsonGenerationException; [EOL] public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; [EOL] public final void writeStartArray() throws IOException, JsonGenerationException; [EOL] public final void writeEndArray() throws IOException, JsonGenerationException; [EOL] public final void writeStartObject() throws IOException, JsonGenerationException; [EOL] public final void writeEndObject() throws IOException, JsonGenerationException; [EOL] protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; [EOL] protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; [EOL] protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; [EOL] protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; [EOL] public void writeString(String text) throws IOException, JsonGenerationException; [EOL] private void _writeLongString(String text) throws IOException, JsonGenerationException; [EOL] private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; [EOL] public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; [EOL] public final void writeString(SerializableString text) throws IOException, JsonGenerationException; [EOL] public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; [EOL] public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; [EOL] public void writeRaw(String text) throws IOException, JsonGenerationException; [EOL] public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; [EOL] public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; [EOL] public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; [EOL] public void writeRaw(char ch) throws IOException, JsonGenerationException; [EOL] private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; [EOL] public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; [EOL] public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; [EOL] public void writeNumber(short s) throws IOException, JsonGenerationException; [EOL] private void _writeQuotedShort(short s) throws IOException; [EOL] public void writeNumber(int i) throws IOException, JsonGenerationException; [EOL] private void _writeQuotedInt(int i) throws IOException; [EOL] public void writeNumber(long l) throws IOException, JsonGenerationException; [EOL] private void _writeQuotedLong(long l) throws IOException; [EOL] public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; [EOL] public void writeNumber(double d) throws IOException, JsonGenerationException; [EOL] public void writeNumber(float f) throws IOException, JsonGenerationException; [EOL] public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; [EOL] public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; [EOL] private void _writeQuotedRaw(Object value) throws IOException; [EOL] public void writeBoolean(boolean state) throws IOException, JsonGenerationException; [EOL] public void writeNull() throws IOException, JsonGenerationException; [EOL] protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; [EOL] protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; [EOL] public final void flush() throws IOException; [EOL] public void close() throws IOException; [EOL] protected void _releaseBuffers(); [EOL] private final void _writeBytes(byte[] bytes) throws IOException; [EOL] private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; [EOL] private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; [EOL] private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; [EOL] private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; [EOL] private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; [EOL] private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; [EOL] private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; [EOL] private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; [EOL] private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; [EOL] private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; [EOL] private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; [EOL] private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; [EOL] protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; [EOL] protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; [EOL] protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; [EOL] private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; [EOL] private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; [EOL] protected final void _outputSurrogates(int surr1, int surr2) throws IOException; [EOL] private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; [EOL] protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; [EOL] private void _writeNull() throws IOException; [EOL] private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; [EOL] protected final void _flushBuffer() throws IOException; [EOL] byte BYTE_u=Optional[(byte) 'u']; [EOL] byte BYTE_0=Optional[(byte) '0']; [EOL] byte BYTE_LBRACKET=Optional[(byte) '[']; [EOL] byte BYTE_RBRACKET=Optional[(byte) ']']; [EOL] byte BYTE_LCURLY=Optional[(byte) '{']; [EOL] byte BYTE_RCURLY=Optional[(byte) '}']; [EOL] byte BYTE_BACKSLASH=Optional[(byte) '\\']; [EOL] byte BYTE_COMMA=Optional[(byte) ',']; [EOL] byte BYTE_COLON=Optional[(byte) ':']; [EOL] byte BYTE_QUOTE=Optional[(byte) '"']; [EOL] int SURR1_FIRST=Optional[0xD800]; [EOL] int SURR1_LAST=Optional[0xDBFF]; [EOL] int SURR2_FIRST=Optional[0xDC00]; [EOL] int SURR2_LAST=Optional[0xDFFF]; [EOL] int MAX_BYTES_TO_BUFFER=Optional[512]; [EOL] byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; [EOL] byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; [EOL] byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; [EOL] byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }];
public void testCloseWithAutoCloseJsonContentAndInArray() throws IOException { [EOL] IOContext ioContext = new IOContext(new BufferRecycler(), new Object(), false); [EOL] OutputStream out = new ByteArrayOutputStream(); [EOL] UTF8JsonGenerator generator = new UTF8JsonGenerator(ioContext, 0, null, out); [EOL] generator.writeStartArray(); // Will make the output context inArray [EOL] generator.close(); // Should auto-close the JSON content (writeEndArray) [EOL] assertTrue(out.toString().endsWith("]")); // Assert the array was closed [EOL] } [EOL] public void testCloseWithAutoCloseJsonContentAndInObject() throws IOException { [EOL] IOContext ioContext = new IOContext(new BufferRecycler(), new Object(), false); [EOL] OutputStream out = new ByteArrayOutputStream(); [EOL] UTF8JsonGenerator generator = new UTF8JsonGenerator(ioContext, 0, null, out); [EOL] generator.writeStartObject(); // Will make the output context inObject [EOL] generator.close(); // Should auto-close the JSON content (writeEndObject) [EOL] assertTrue(out.toString().endsWith("}")); // Assert the object was closed [EOL] } [EOL] public void testCloseWithoutAutoCloseJsonContent() throws IOException { [EOL] IOContext ioContext = new IOContext(new BufferRecycler(), new Object(), false); [EOL] OutputStream out = new ByteArrayOutputStream(); [EOL] UTF8JsonGenerator generator = new UTF8JsonGenerator(ioContext, 0, null, out); [EOL] generator.close(); // No auto-closing of JSON content [EOL] assertEquals("", out.toString()); // Assert nothing was written [EOL] } [EOL] public void testCloseWithAutoCloseTargetEnabled() throws IOException { [EOL] IOContext ioContext = new IOContext(new BufferRecycler(), new Object(), true); [EOL] OutputStream out = new MockOutputStream(); // MockOutputStream that tracks close() calls [EOL] UTF8JsonGenerator generator = new UTF8JsonGenerator(ioContext, Feature.AUTO_CLOSE_TARGET.getMask(), null, out); [EOL] generator.close(); [EOL] assertTrue(((MockOutputStream) out).isClosed()); // Assert that the output stream was closed [EOL] } [EOL] public void testCloseWithAutoCloseTargetDisabled() throws IOException { [EOL] IOContext ioContext = new IOContext(new BufferRecycler(), new Object(), false); [EOL] OutputStream out = new MockOutputStream(); // MockOutputStream that tracks close() calls [EOL] UTF8JsonGenerator generator = new UTF8JsonGenerator(ioContext, 0, null, out); [EOL] generator.close(); [EOL] assertFalse(((MockOutputStream) out).isClosed()); // Assert that the output stream was not closed [EOL] } [EOL] public void testCloseWithFlushPassedToStreamEnabled() throws IOException { [EOL] IOContext ioContext = new IOContext(new BufferRecycler(), new Object(), false); [EOL] OutputStream out = new MockOutputStream(); // MockOutputStream that tracks flush() calls [EOL] UTF8JsonGenerator generator = new UTF8JsonGenerator(ioContext, Feature.FLUSH_PASSED_TO_STREAM.getMask(), null, out); [EOL] generator.close(); [EOL] assertTrue(((MockOutputStream) out).isFlushed()); // Assert that the output stream was flushed [EOL] }
class MockOutputStream extends ByteArrayOutputStream { [EOL] private boolean isClosed = false; [EOL] private boolean isFlushed = false; [EOL] @Override [EOL] public void close() throws IOException { [EOL] super.close(); [EOL] isClosed = true; [EOL] } [EOL] @Override [EOL] public void flush() throws IOException { [EOL] super.flush(); [EOL] isFlushed = true; [EOL] } [EOL] public boolean isClosed() { [EOL] return isClosed; [EOL] } [EOL] public boolean isFlushed() { [EOL] return isFlushed; [EOL] } [EOL] }
private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException { [EOL] if ((_outputTail + len) > _outputEnd) { [EOL] _flushBuffer(); [EOL] if (len > MAX_BYTES_TO_BUFFER) { [EOL] _outputStream.write(bytes, offset, len); [EOL] return; [EOL] } [EOL] } [EOL] System.arraycopy(bytes, offset, _outputBuffer, _outputTail, len); [EOL] _outputTail += len; [EOL] }
private final void _writeStringSegments(String text) throws IOException, JsonGenerationException { [EOL] int left = text.length(); [EOL] int offset = 0; [EOL] final char[] cbuf = _charBuffer; [EOL] while (left > 0) { [EOL] int len = Math.min(_outputMaxContiguous, left); [EOL] text.getChars(offset, offset + len, cbuf, 0); [EOL] if ((_outputTail + len) > _outputEnd) { [EOL] _flushBuffer(); [EOL] } [EOL] _writeStringSegment(cbuf, 0, len); [EOL] offset += len; [EOL] left -= len; [EOL] } [EOL] }
private void testWriteStringSegmentsWithExactBufferLength() throws IOException { [EOL] UTF8JsonGenerator gen = createGeneratorWithBufferLength(10); [EOL] char[] input = "abcdefghij".toCharArray(); [EOL] gen._writeStringSegments(input, 0, input.length); [EOL] } [EOL] private void testWriteStringSegmentsWithBufferFlush() throws IOException { [EOL] UTF8JsonGenerator gen = createGeneratorWithBufferLength(5); [EOL] char[] input = "abcdefghij".toCharArray(); [EOL] gen._writeStringSegments(input, 0, input.length); [EOL] } [EOL] private void testWriteStringSegmentsWithPartialBufferUsage() throws IOException { [EOL] UTF8JsonGenerator gen = createGeneratorWithBufferLength(15); [EOL] char[] input = "abcdefghij".toCharArray(); [EOL] gen._writeStringSegments(input, 0, input.length); [EOL] } [EOL] private UTF8JsonGenerator createGeneratorWithBufferLength(int bufferLength) { [EOL] IOContext ctxt = new IOContext(new BufferRecycler(), new OutputStream() { [EOL] @Override [EOL] public void write(int b) throws IOException { [EOL] } [EOL] }, false); [EOL] return new UTF8JsonGenerator(ctxt, 0, null, new ByteArrayOutputStream(), new byte[bufferLength], 0, true); [EOL] }
public void testInRootWhenTypeIsRoot() { [EOL] JsonStreamContext context = new JsonStreamContext(TYPE_ROOT, -1); // Assuming JsonStreamContext is the class containing the inRoot method [EOL] assertTrue(context.inRoot()); [EOL] }
public void testInRootWhenTypeIsNotRoot() { [EOL] JsonStreamContext context = new JsonStreamContext(TYPE_ARRAY, -1); // Assuming TYPE_ARRAY is a different type constant [EOL] assertFalse(context.inRoot()); [EOL] }
public void testGetCurrentIndex_NegativeIndex() { [EOL] JsonParser jp = createParserWithNegativeIndex(); [EOL] int currentIndex = jp.getCurrentIndex(); [EOL] assertEquals(0, currentIndex); [EOL] } [EOL] public void testGetCurrentIndex_NonNegativeIndex() { [EOL] JsonParser jp = createParserWithNonNegativeIndex(); [EOL] int currentIndex = jp.getCurrentIndex(); [EOL] assertEquals(jp.getActualIndex(), currentIndex); [EOL] }
public void testHasJSONFormatWithNoMoreBytesInitially() throws IOException { [EOL] InputAccessor acc = mock(InputAccessor.class); [EOL] when(acc.hasMoreBytes()).thenReturn(false); [EOL] assertEquals(MatchStrength.INCONCLUSIVE, JsonFactory.hasJSONFormat(acc)); [EOL] }
public void testHasJSONFormatWithUTF8BOM() throws IOException { [EOL] InputAccessor acc = mock(InputAccessor.class); [EOL] when(acc.hasMoreBytes()).thenReturn(true).thenReturn(true).thenReturn(true).thenReturn(true); [EOL] when(acc.nextByte()).thenReturn((byte) 0xEF).thenReturn((byte) 0xBB).thenReturn((byte) 0xBF).thenReturn((byte) '{'); [EOL] assertEquals(MatchStrength.SOLID_MATCH, JsonFactory.hasJSONFormat(acc)); [EOL] }
public void testHasJSONFormatWithNoMatchOnBOM() throws IOException { [EOL] InputAccessor acc = mock(InputAccessor.class); [EOL] when(acc.hasMoreBytes()).thenReturn(true).thenReturn(true); [EOL] when(acc.nextByte()).thenReturn((byte) 0xEF).thenReturn((byte) 0xBB); [EOL] assertEquals(MatchStrength.NO_MATCH, JsonFactory.hasJSONFormat(acc)); [EOL] }
public void testHasJSONFormatWithInconclusiveAfterBOM() throws IOException { [EOL] InputAccessor acc = mock(InputAccessor.class); [EOL] when(acc.hasMoreBytes()).thenReturn(true).thenReturn(true).thenReturn(false); [EOL] when(acc.nextByte()).thenReturn((byte) 0xEF).thenReturn((byte) 0xBB); [EOL] assertEquals(MatchStrength.INCONCLUSIVE, JsonFactory.hasJSONFormat(acc)); [EOL] }
public void testHasJSONFormatWithNonBOMAndObject() throws IOException { [EOL] InputAccessor acc = mock(InputAccessor.class); [EOL] when(acc.hasMoreBytes()).thenReturn(true).thenReturn(true); [EOL] when(acc.nextByte()).thenReturn((byte) '{').thenReturn((byte) '"'); [EOL] assertEquals(MatchStrength.SOLID_MATCH, JsonFactory.hasJSONFormat(acc)); [EOL] }
public void testHasJSONFormatWithNonBOMAndArray() throws IOException { [EOL] InputAccessor acc = mock(InputAccessor.class); [EOL] when(acc.hasMoreBytes()).thenReturn(true).thenReturn(true); [EOL] when(acc.nextByte()).thenReturn((byte) '[').thenReturn((byte) ']'); [EOL] assertEquals(MatchStrength.SOLID_MATCH, JsonFactory.hasJSONFormat(acc)); [EOL] }
public void testHasJSONFormatWithNonBOMAndNumber() throws IOException { [EOL] InputAccessor acc = mock(InputAccessor.class); [EOL] when(acc.hasMoreBytes()).thenReturn(true); [EOL] when(acc.nextByte()).thenReturn((byte) '1'); [EOL] assertEquals(MatchStrength.WEAK_MATCH, JsonFactory.hasJSONFormat(acc)); [EOL] }
public void testHasJSONFormatWithNonBOMAndNegativeNumber() throws IOException { [EOL] InputAccessor acc = mock(InputAccessor.class); [EOL] when(acc.hasMoreBytes()).thenReturn(true).thenReturn(true); [EOL] when(acc.nextByte()).thenReturn((byte) '-').thenReturn((byte) '1'); [EOL] assertEquals(MatchStrength.WEAK_MATCH, JsonFactory.hasJSONFormat(acc)); [EOL] }
public void testHasJSONFormatWithNonBOMAndInvalidNegative() throws IOException { [EOL] InputAccessor acc = mock(InputAccessor.class); [EOL] when(acc.hasMoreBytes()).thenReturn(true).thenReturn(true); [EOL] when(acc.nextByte()).thenReturn((byte) '-').thenReturn((byte) 'a'); [EOL] assertEquals(MatchStrength.NO_MATCH, JsonFactory.hasJSONFormat(acc)); [EOL] }
public void testHasJSONFormatWithNonBOMAndTrueLiteral() throws IOException { [EOL] InputAccessor acc = mock(InputAccessor.class); [EOL] when(acc.hasMoreBytes()).thenReturn(true).thenReturn(true).thenReturn(true).thenReturn(true); [EOL] when(acc.nextByte()).thenReturn((byte) 't').thenReturn((byte) 'r').thenReturn((byte) 'u').thenReturn((byte) 'e'); [EOL] assertEquals(MatchStrength.WEAK_MATCH, JsonFactory.hasJSONFormat(acc)); [EOL] }
public void testHasJSONFormatWithNonBOMAndFalseLiteral() throws IOException { [EOL] InputAccessor acc = mock(InputAccessor.class); [EOL] when(acc.hasMoreBytes()).thenReturn(true).thenReturn(true).thenReturn(true).thenReturn(true).thenReturn(true); [EOL] when(acc.nextByte()).thenReturn((byte) 'f').thenReturn((byte) 'a').thenReturn((byte) 'l').thenReturn((byte) 's').thenReturn((byte) 'e'); [EOL] assertEquals(MatchStrength.WEAK_MATCH, JsonFactory.hasJSONFormat(acc)); [EOL] }
public void testHasJSONFormatWithNonBOMAndNullLiteral() throws IOException { [EOL] InputAccessor acc = mock(InputAccessor.class); [EOL] when(acc.hasMoreBytes()).thenReturn(true).thenReturn(true).thenReturn(true).thenReturn(true); [EOL] when(acc.nextByte()).thenReturn((byte) 'n').thenReturn((byte) 'u').thenReturn((byte) 'l').thenReturn((byte) 'l'); [EOL] assertEquals(MatchStrength.WEAK_MATCH, JsonFactory.hasJSONFormat(acc)); [EOL] }
public void testHasJSONFormatWithNoMatch() throws IOException { [EOL] InputAccessor acc = mock(InputAccessor.class); [EOL] when(acc.hasMoreBytes()).thenReturn(true); [EOL] when(acc.nextByte()).thenReturn((byte) 'a'); [EOL] assertEquals(MatchStrength.NO_MATCH, JsonFactory.hasJSONFormat(acc)); [EOL] }
private static int skipSpace(InputAccessor acc) throws IOException { [EOL] if (!acc.hasMoreBytes()) { [EOL] return -1; [EOL] } [EOL] return skipSpace(acc, acc.nextByte()); [EOL] }
public void testSkipSpaceWithNonSpaceByte() throws IOException { [EOL] InputAccessor acc = mock(InputAccessor.class); [EOL] byte nonSpaceByte = 'a'; [EOL] when(acc.hasMoreBytes()).thenReturn(false); [EOL] int result = skipSpace(acc, nonSpaceByte); [EOL] assertEquals('a', result); [EOL] }
public void testSkipSpaceWithSpaceByteAndNoMoreBytes() throws IOException { [EOL] InputAccessor acc = mock(InputAccessor.class); [EOL] byte spaceByte = ' '; [EOL] when(acc.hasMoreBytes()).thenReturn(false); [EOL] int result = skipSpace(acc, spaceByte); [EOL] assertEquals(-1, result); [EOL] }
public void testSkipSpaceWithSpaceByteAndMoreBytes() throws IOException { [EOL] InputAccessor acc = mock(InputAccessor.class); [EOL] byte spaceByte = ' '; [EOL] byte nextByte = 'b'; [EOL] when(acc.hasMoreBytes()).thenReturn(true).thenReturn(false); [EOL] when(acc.nextByte()).thenReturn(nextByte); [EOL] int result = skipSpace(acc, spaceByte); [EOL] assertEquals('b', result); [EOL] }
public void testSkipSpaceWithNewLineByteAndMoreBytes() throws IOException { [EOL] InputAccessor acc = mock(InputAccessor.class); [EOL] byte newLineByte = '\n'; [EOL] byte nextByte = 'c'; [EOL] when(acc.hasMoreBytes()).thenReturn(true).thenReturn(false); [EOL] when(acc.nextByte()).thenReturn(nextByte); [EOL] int result = skipSpace(acc, newLineByte); [EOL] assertEquals('c', result); [EOL] }
public void testSkipSpaceWithCarriageReturnByteAndMoreBytes() throws IOException { [EOL] InputAccessor acc = mock(InputAccessor.class); [EOL] byte carriageReturnByte = '\r'; [EOL] byte nextByte = 'd'; [EOL] when(acc.hasMoreBytes()).thenReturn(true).thenReturn(false); [EOL] when(acc.nextByte()).thenReturn(nextByte); [EOL] int result = skipSpace(acc, carriageReturnByte); [EOL] assertEquals('d', result); [EOL] }
public void testSkipSpaceWithTabByteAndMoreBytes() throws IOException { [EOL] InputAccessor acc = mock(InputAccessor.class); [EOL] byte tabByte = '\t'; [EOL] byte nextByte = 'e'; [EOL] when(acc.hasMoreBytes()).thenReturn(true).thenReturn(false); [EOL] when(acc.nextByte()).thenReturn(nextByte); [EOL] int result = skipSpace(acc, tabByte); [EOL] assertEquals('e', result); [EOL] }
public void testGetMask() { [EOL] int expectedValue = 10; [EOL] MyClass instance = new MyClass(expectedValue); [EOL] int result = instance.getMask(); [EOL] assertEquals(expectedValue, result); [EOL] }
public void testJsonGeneratorConstructor() { [EOL] JsonGenerator jsonGenerator = new JsonGeneratorSubclass(); [EOL] assertNotNull(jsonGenerator); [EOL] }
public void testBase64VariantValidAlphabet() { [EOL] String name = "validName"; [EOL] String base64Alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"; [EOL] boolean usesPadding = true; [EOL] char paddingChar = '='; [EOL] int maxLineLength = 76; [EOL] Base64Variant variant = new Base64Variant(name, base64Alphabet, usesPadding, paddingChar, maxLineLength); [EOL] assertEquals(name, variant.getName()); [EOL] assertEquals(usesPadding, variant.usesPadding()); [EOL] assertEquals(paddingChar, variant.getPaddingChar()); [EOL] assertEquals(maxLineLength, variant.getMaxLineLength()); [EOL] for (int i = 0; i < base64Alphabet.length(); i++) { [EOL] assertEquals(base64Alphabet.charAt(i), variant.encodeBase64BitsAsChar(i)); [EOL] } [EOL] }
public void testBase64VariantInvalidAlphabetLength() { [EOL] String name = "invalidName"; [EOL] String base64Alphabet = "ABC"; // Invalid length [EOL] boolean usesPadding = true; [EOL] char paddingChar = '='; [EOL] int maxLineLength = 76; [EOL] try { [EOL] new Base64Variant(name, base64Alphabet, usesPadding, paddingChar, maxLineLength); [EOL] fail("Should have thrown IllegalArgumentException due to invalid alphabet length"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testBase64VariantWithoutPadding() { [EOL] String name = "noPadding"; [EOL] String base64Alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"; [EOL] boolean usesPadding = false; [EOL] char paddingChar = '='; [EOL] int maxLineLength = 76; [EOL] Base64Variant variant = new Base64Variant(name, base64Alphabet, usesPadding, paddingChar, maxLineLength); [EOL] assertEquals(name, variant.getName()); [EOL] assertFalse(variant.usesPadding()); [EOL] assertEquals(maxLineLength, variant.getMaxLineLength()); [EOL] for (int i = 0; i < base64Alphabet.length(); i++) { [EOL] assertEquals(base64Alphabet.charAt(i), variant.encodeBase64BitsAsChar(i)); [EOL] } [EOL] }
public void testBase64VariantWithDifferentName() { [EOL] Base64Variant base = new Base64Variant(Base64Variants.MIME, "MIME", true); [EOL] Base64Variant variant = new Base64Variant(base, "MIME_MODIFIED", 76); [EOL] assertEquals("MIME_MODIFIED", variant.getName()); [EOL] assertEquals(76, variant.getMaxLineLength()); [EOL] assertEquals(base.usesPadding(), variant.usesPadding()); [EOL] assertEquals(base.getPaddingChar(), variant.getPaddingChar()); [EOL] }
public void testBase64VariantWithDifferentMaxLineLength() { [EOL] Base64Variant base = new Base64Variant(Base64Variants.MIME, "MIME", true); [EOL] Base64Variant variant = new Base64Variant(base, "MIME", 100); [EOL] assertEquals("MIME", variant.getName()); [EOL] assertEquals(100, variant.getMaxLineLength()); [EOL] assertEquals(base.usesPadding(), variant.usesPadding()); [EOL] assertEquals(base.getPaddingChar(), variant.getPaddingChar()); [EOL] }
public void testBase64VariantConstructorWithPadding() { [EOL] String name = "testVariant"; [EOL] boolean usesPadding = true; [EOL] char paddingChar = '='; [EOL] int maxLineLength = 76; [EOL] Base64Variant base = new Base64Variant("base", "M0", false, '0', 0); [EOL] Base64Variant variant = new Base64Variant(base, name, usesPadding, paddingChar, maxLineLength); [EOL] assertEquals(name, variant.getName()); [EOL] assertEquals(usesPadding, variant.usesPadding()); [EOL] assertEquals(paddingChar, variant.getPaddingChar()); [EOL] assertEquals(maxLineLength, variant.getMaxLineLength()); [EOL] assertArrayEquals(base.getBase64ToAsciiB(), variant.getBase64ToAsciiB()); [EOL] assertArrayEquals(base.getBase64ToAsciiC(), variant.getBase64ToAsciiC()); [EOL] assertArrayEquals(base.getAsciiToBase64(), variant.getAsciiToBase64()); [EOL] }
public void testBase64VariantConstructorWithoutPadding() { [EOL] String name = "testVariant"; [EOL] boolean usesPadding = false; [EOL] char paddingChar = '0'; // Arbitrary character since padding is not used [EOL] int maxLineLength = 0; [EOL] Base64Variant base = new Base64Variant("base", "M0", true, '=', 76); [EOL] Base64Variant variant = new Base64Variant(base, name, usesPadding, paddingChar, maxLineLength); [EOL] assertEquals(name, variant.getName()); [EOL] assertEquals(usesPadding, variant.usesPadding()); [EOL] assertEquals(paddingChar, variant.getPaddingChar()); [EOL] assertEquals(maxLineLength, variant.getMaxLineLength()); [EOL] assertArrayEquals(base.getBase64ToAsciiB(), variant.getBase64ToAsciiB()); [EOL] assertArrayEquals(base.getBase64ToAsciiC(), variant.getBase64ToAsciiC()); [EOL] assertArrayEquals(base.getAsciiToBase64(), variant.getAsciiToBase64()); [EOL] }
protected Object readResolve() throws ObjectStreamException { [EOL] return Base64Variants.valueOf(_name); [EOL] }
public void testGetNameWhenNameIsNotNull() { [EOL] MyClass obj = new MyClass("TestName"); [EOL] String name = obj.getName(); [EOL] assertNotNull(name); [EOL] assertEquals("TestName", name); [EOL] }
public void testGetNameWhenNameIsNull() { [EOL] MyClass obj = new MyClass(null); [EOL] String name = obj.getName(); [EOL] assertNull(name); [EOL] }
public void testUsesPaddingTrue() { [EOL] Base64Variant base64Variant = new Base64Variant("MIME", "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", true); [EOL] assertTrue(base64Variant.usesPadding()); [EOL] }
public void testUsesPaddingFalse() { [EOL] Base64Variant base64Variant = new Base64Variant("MIME_NO_PADDING", "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", false); [EOL] assertFalse(base64Variant.usesPadding()); [EOL] }
public void testUsesPaddingCharWithPaddingChar() { [EOL] Base64Variant base64Variant = new Base64Variant("test", "ABC=", true); [EOL] assertTrue(base64Variant.usesPaddingChar('=')); [EOL] }
public void testUsesPaddingCharWithNonPaddingChar() { [EOL] Base64Variant base64Variant = new Base64Variant("test", "ABC=", true); [EOL] assertFalse(base64Variant.usesPaddingChar('A')); [EOL] }
public void testGetPaddingChar() { [EOL] Base64Variant base64Variant = new Base64Variant("TEST", "ABCDEF==", true, 'P', 123); [EOL] char result = base64Variant.getPaddingChar(); [EOL] assertEquals('P', result); [EOL] }
public void testGetPaddingByte() { [EOL] JsonFactory factory = new JsonFactory(); [EOL] JsonGenerator generator = factory.createGenerator(new ByteArrayOutputStream()); [EOL] byte paddingByte = generator.getPaddingByte(); [EOL] assertEquals((byte) ' ', paddingByte); [EOL] }
public void testGetMaxLineLength() { [EOL] JsonFactory factory = new JsonFactory(); [EOL] int maxLineLength = factory.getMaxLineLength(); [EOL] assertEquals(0, maxLineLength); [EOL] }
public void testToStringReturnsCorrectName() { [EOL] String expectedName = "TestName"; [EOL] SomeClass instance = new SomeClass(expectedName); [EOL] String result = instance.toString(); [EOL] assert expectedName.equals(result); [EOL] }
public void testVerifyNoLeadingZeroesWithEmptyBuffer() throws IOException, JsonParseException { [EOL] assertEquals('0', _verifyNoLeadingZeroes()); [EOL] } [EOL] public void testVerifyNoLeadingZeroesWithNonDigit() throws IOException, JsonParseException { [EOL] assertEquals('0', _verifyNoLeadingZeroes()); [EOL] } [EOL] public void testVerifyNoLeadingZeroesWithLeadingZeroesNotAllowed() throws IOException, JsonParseException { [EOL] try { [EOL] _verifyNoLeadingZeroes(); [EOL] fail("Expected JsonParseException"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] } [EOL] public void testVerifyNoLeadingZeroesWithSingleZero() throws IOException, JsonParseException { [EOL] assertEquals('0', _verifyNoLeadingZeroes()); [EOL] } [EOL] public void testVerifyNoLeadingZeroesWithMultipleLeadingZeroes() throws IOException, JsonParseException { [EOL] char expected = '0'; // Replace with the expected non-zero digit after the leading zeroes [EOL] assertEquals(expected, _verifyNoLeadingZeroes()); [EOL] } [EOL] public void testVerifyNoLeadingZeroesWithNonZeroDigit() throws IOException, JsonParseException { [EOL] char expected = '1'; // Replace with the actual non-zero digit in _inputBuffer[_inputPtr] [EOL] assertEquals(expected, _verifyNoLeadingZeroes()); [EOL] }
public void testHandleUnusualFieldNameWithApostropheAllowed() throws IOException, JsonParseException { [EOL] final int INT_APOSTROPHE = '\''; [EOL] enableFeature(Feature.ALLOW_SINGLE_QUOTES); [EOL] String result = _handleUnusualFieldName(INT_APOSTROPHE); [EOL] assertEquals("Expected result from _parseApostropheFieldName", result); [EOL] }
public void testHandleUnusualFieldNameWithUnquotedNotAllowed() throws IOException, JsonParseException { [EOL] final int INT_APOSTROPHE = '\''; [EOL] disableFeature(Feature.ALLOW_UNQUOTED_FIELD_NAMES); [EOL] try { [EOL] _handleUnusualFieldName(INT_APOSTROPHE); [EOL] fail("Expected JsonParseException"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testHandleUnusualFieldNameWithUnquotedAllowedNonJavaIdentifier() throws IOException, JsonParseException { [EOL] final int INT_APOSTROPHE = '\''; [EOL] enableFeature(Feature.ALLOW_UNQUOTED_FIELD_NAMES); [EOL] final int INT_0 = '0'; [EOL] final int INT_9 = '9'; [EOL] for (int i = INT_0 - 1; i <= INT_9 + 1; i++) { [EOL] if (i != INT_APOSTROPHE) { [EOL] try { [EOL] _handleUnusualFieldName(i); [EOL] fail("Expected JsonParseException for char code: " + i); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] } [EOL] } [EOL] }
public void testHandleUnusualFieldNameWithUnquotedAllowedJavaIdentifier() throws IOException, JsonParseException { [EOL] final int INT_APOSTROPHE = '\''; [EOL] enableFeature(Feature.ALLOW_UNQUOTED_FIELD_NAMES); [EOL] final int INT_0 = '0'; [EOL] final int INT_9 = '9'; [EOL] final int[] codes = CharTypes.getInputCodeLatin1JsNames(); [EOL] final int maxCode = codes.length; [EOL] for (int i = 0; i < maxCode; i++) { [EOL] if (codes[i] == 0 && (i < INT_0 || i > INT_9)) { [EOL] String result = _handleUnusualFieldName(i); [EOL] assertEquals("Expected result from _parseUnusualFieldName2", result); [EOL] } [EOL] } [EOL] }
protected void testFinishStringWithQuoteEnding() throws IOException, JsonParseException { [EOL] _inputPtr = 0; [EOL] _inputEnd = 5; [EOL] _inputBuffer = new char[] {'H', 'e', 'l', 'l', 'o', '"'}; [EOL] _textBuffer = new TextBuffer(new BufferRecycler()); [EOL] _finishString(); [EOL] assertEquals("Hello", _textBuffer.contentsAsString()); [EOL] assertEquals(6, _inputPtr); [EOL] }
protected void testFinishStringWithoutQuoteEnding() throws IOException, JsonParseException { [EOL] _inputPtr = 0; [EOL] _inputEnd = 4; [EOL] _inputBuffer = new char[] {'H', 'e', 'l', 'l'}; [EOL] _textBuffer = new TextBuffer(new BufferRecycler()); [EOL] _finishString(); [EOL] assertEquals("Hell", _textBuffer.contentsAsString()); [EOL] assertEquals(4, _inputPtr); [EOL] }
protected void testFinishStringWithSpecialCharacter() throws IOException, JsonParseException { [EOL] _inputPtr = 0; [EOL] _inputEnd = 6; [EOL] _inputBuffer = new char[] {'H', 'e', 'l', 'l', 'o', '\n'}; [EOL] _textBuffer = new TextBuffer(new BufferRecycler()); [EOL] try { [EOL] _finishString(); [EOL] fail("Should not reach this point"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
protected void _finishString2() throws IOException, JsonParseException { [EOL] char[] outBuf = _textBuffer.getCurrentSegment(); [EOL] int outPtr = _textBuffer.getCurrentSegmentSize(); [EOL] while (true) { [EOL] if (_inputPtr >= _inputEnd) { [EOL] if (!loadMore()) { [EOL] _reportInvalidEOF(": was expecting closing quote for a string value"); [EOL] } [EOL] } [EOL] char c = _inputBuffer[_inputPtr++]; [EOL] int i = (int) c; [EOL] if (i <= INT_BACKSLASH) { [EOL] if (i == INT_BACKSLASH) { [EOL] c = _decodeEscaped(); [EOL] } else if (i <= INT_QUOTE) { [EOL] if (i == INT_QUOTE) { [EOL] break; [EOL] } [EOL] if (i < INT_SPACE) { [EOL] _throwUnquotedSpace(i, "string value"); [EOL] } [EOL] } [EOL] } [EOL] if (outPtr >= outBuf.length) { [EOL] outBuf = _textBuffer.finishCurrentSegment(); [EOL] outPtr = 0; [EOL] } [EOL] outBuf[outPtr++] = c; [EOL] } [EOL] _textBuffer.setCurrentLength(outPtr); [EOL] }
public void testSkipWSOrEndWithNonSpaceChar() throws IOException, JsonParseException { [EOL] _inputBuffer[_inputPtr] = 'a'; // 'a' is a non-space character [EOL] _inputEnd = _inputPtr + 1; // Set _inputEnd to simulate end of buffer [EOL] int result = _skipWSOrEnd(); [EOL] assertNotEquals("Non-space character should not return -1", -1, result); [EOL] }
public void testSkipWSOrEndWithSpaceChar() throws IOException, JsonParseException { [EOL] _inputBuffer[_inputPtr] = ' '; // ' ' is a space character [EOL] _inputEnd = _inputPtr + 1; // Set _inputEnd to simulate end of buffer [EOL] int result = _skipWSOrEnd(); [EOL] assertEquals("Space character should return space character", ' ', result); [EOL] }
public void testSkipWSOrEndWithSlash() throws IOException, JsonParseException { [EOL] _inputBuffer[_inputPtr] = '/'; // '/' to simulate a comment [EOL] _inputEnd = _inputPtr + 1; // Set _inputEnd to simulate end of buffer [EOL] int result = _skipWSOrEnd(); [EOL] assertNotEquals("Slash should not return -1 after comment is skipped", -1, result); [EOL] }
public void testSkipWSOrEndWithNewLine() throws IOException, JsonParseException { [EOL] _inputBuffer[_inputPtr] = '\n'; // '\n' to simulate a new line [EOL] _inputEnd = _inputPtr + 1; // Set _inputEnd to simulate end of buffer [EOL] int result = _skipWSOrEnd(); [EOL] assertEquals("New line should return new line character", '\n', result); [EOL] }
public void testSkipWSOrEndWithCarriageReturn() throws IOException, JsonParseException { [EOL] _inputBuffer[_inputPtr] = '\r'; // '\r' to simulate a carriage return [EOL] _inputEnd = _inputPtr + 1; // Set _inputEnd to simulate end of buffer [EOL] int result = _skipWSOrEnd(); [EOL] assertEquals("Carriage return should return carriage return character", '\r', result); [EOL] }
public void testSkipWSOrEndWithTab() throws IOException, JsonParseException { [EOL] _inputBuffer[_inputPtr] = '\t'; // '\t' to simulate a tab [EOL] _inputEnd = _inputPtr + 1; // Set _inputEnd to simulate end of buffer [EOL] int result = _skipWSOrEnd(); [EOL] assertEquals("Tab should return tab character", '\t', result); [EOL] }
public void testSkipWSOrEndWithEOF() throws IOException, JsonParseException { [EOL] _inputPtr = _inputEnd; // Set _inputPtr to simulate end of buffer [EOL] int result = _skipWSOrEnd(); [EOL] assertEquals("End of file should return -1", -1, result); [EOL] }
public void testSkipCommentWithCommentsDisabled() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserWithFeatureEnabled(false); [EOL] try { [EOL] parser._skipComment(); [EOL] fail("Expected JsonParseException"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] } [EOL] public void testSkipCommentAtEndOfFile() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserWithInput("/"); [EOL] try { [EOL] parser._skipComment(); [EOL] fail("Expected JsonParseException for end of file"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] } [EOL] public void testSkipCommentWithCppStyle() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserWithInput("//"); [EOL] parser._skipComment(); [EOL] } [EOL] public void testSkipCommentWithCStyle() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserWithInput("/* comment */"); [EOL] parser._skipComment(); [EOL] } [EOL] public void testSkipCommentWithUnexpectedChar() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserWithInput("/a"); [EOL] try { [EOL] parser._skipComment(); [EOL] fail("Expected JsonParseException for unexpected character"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }

public void testSkipCCommentEndOfFile() throws IOException, JsonParseException { [EOL] _inputPtr = 0; [EOL] _inputEnd = 0; [EOL] try { [EOL] _skipCComment(); [EOL] fail("Should throw JsonParseException due to end of file in a comment"); [EOL] } catch (JsonParseException e) { [EOL] assertEquals(" in a comment", e.getMessage()); [EOL] } [EOL] }
public void testSkipCCommentWithAsteriskSlash() throws IOException, JsonParseException { [EOL] _inputBuffer = new char[]{'*', '/'}; [EOL] _inputPtr = 0; [EOL] _inputEnd = 2; [EOL] _skipCComment(); [EOL] assertEquals(2, _inputPtr); [EOL] }
public void testSkipCCommentWithAsteriskWithoutSlash() throws IOException, JsonParseException { [EOL] _inputBuffer = new char[]{'*', 'a'}; [EOL] _inputPtr = 0; [EOL] _inputEnd = 2; [EOL] _skipCComment(); [EOL] assertEquals(1, _inputPtr); [EOL] }
public void testSkipCCommentWithLineFeed() throws IOException, JsonParseException { [EOL] _inputBuffer = new char[]{'\n'}; [EOL] _inputPtr = 0; [EOL] _inputEnd = 1; [EOL] _skipCComment(); [EOL] }
public void testSkipCCommentWithCarriageReturn() throws IOException, JsonParseException { [EOL] _inputBuffer = new char[]{'\r'}; [EOL] _inputPtr = 0; [EOL] _inputEnd = 1; [EOL] _skipCComment(); [EOL] }
public void testSkipCCommentWithInvalidSpace() throws IOException, JsonParseException { [EOL] _inputBuffer = new char[]{(char) 0x00}; // Assuming 0x00 is an invalid space character [EOL] _inputPtr = 0; [EOL] _inputEnd = 1; [EOL] try { [EOL] _skipCComment(); [EOL] fail("Should throw JsonParseException due to invalid space"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testSkipCppCommentWithLF() throws IOException, JsonParseException { [EOL] _inputPtr = 0; [EOL] _inputEnd = 1; [EOL] _inputBuffer = new char[] {'\n'}; [EOL] _skipCppComment(); [EOL] assertEquals(1, _inputPtr); [EOL] }
public void testSkipCppCommentWithCR() throws IOException, JsonParseException { [EOL] _inputPtr = 0; [EOL] _inputEnd = 1; [EOL] _inputBuffer = new char[] {'\r'}; [EOL] _skipCppComment(); [EOL] assertEquals(1, _inputPtr); [EOL] }
public void testSkipCppCommentWithTab() throws IOException, JsonParseException { [EOL] _inputPtr = 0; [EOL] _inputEnd = 1; [EOL] _inputBuffer = new char[] {'\t'}; [EOL] _skipCppComment(); [EOL] assertEquals(1, _inputPtr); [EOL] }
public void testSkipCppCommentWithInvalidSpace() throws IOException { [EOL] _inputPtr = 0; [EOL] _inputEnd = 1; [EOL] _inputBuffer = new char[] {0x01}; // Assuming 0x01 is a representation of an invalid space character [EOL] try { [EOL] _skipCppComment(); [EOL] fail("Should have thrown JsonParseException"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testSkipCppCommentWithLoadMore() throws IOException, JsonParseException { [EOL] _inputPtr = 0; [EOL] _inputEnd = 0; // Force loadMore to be called [EOL] _inputBuffer = new char[] {}; [EOL] when(loadMore()).thenReturn(true); [EOL] _inputBuffer = new char[] {' '}; // Space is a valid character to skip [EOL] _inputPtr = 0; [EOL] _inputEnd = 1; [EOL] _skipCppComment(); [EOL] assertEquals(1, _inputPtr); [EOL] }
public void testWriterBasedJsonGeneratorWithValidParams() { [EOL] IOContext ctxt = new IOContext(new BufferRecycler(), new Object(), false); [EOL] int features = 0; [EOL] ObjectCodec codec = null; [EOL] Writer w = new StringWriter(); [EOL] WriterBasedJsonGenerator generator = new WriterBasedJsonGenerator(ctxt, features, codec, w); [EOL] assertNotNull(generator); [EOL] assertEquals(w, generator.getWriter()); [EOL] assertNotNull(generator.getOutputBuffer()); [EOL] assertTrue(generator.getOutputBuffer().length > 0); [EOL] }
public void testWriterBasedJsonGeneratorWithNullWriter() { [EOL] IOContext ctxt = new IOContext(new BufferRecycler(), new Object(), false); [EOL] int features = 0; [EOL] ObjectCodec codec = null; [EOL] Writer w = null; [EOL] try { [EOL] WriterBasedJsonGenerator generator = new WriterBasedJsonGenerator(ctxt, features, codec, w); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testWriteEndObject_NotInObjectContext() throws IOException { [EOL] JsonGeneratorImpl generator = createJsonGenerator(); [EOL] try { [EOL] generator.writeEndObject(); [EOL] fail("Expected JsonGenerationException"); [EOL] } catch (JsonGenerationException e) { [EOL] } [EOL] } [EOL] public void testWriteEndObject_WithPrettyPrinter() throws IOException { [EOL] JsonGeneratorImpl generator = createJsonGeneratorWithPrettyPrinter(); [EOL] generator.writeStartObject(); [EOL] generator.writeEndObject(); [EOL] } [EOL] public void testWriteEndObject_WithoutPrettyPrinter() throws IOException { [EOL] JsonGeneratorImpl generator = createJsonGenerator(); [EOL] generator.writeStartObject(); [EOL] generator.writeEndObject(); [EOL] } [EOL] public void testWriteEndObject_OutputBufferFull() throws IOException { [EOL] JsonGeneratorImpl generator = createJsonGeneratorWithFullBuffer(); [EOL] generator.writeStartObject(); [EOL] generator.writeEndObject(); [EOL] }

public void testCloseWithAutoCloseJsonContentEnabledAndInArray() throws IOException { [EOL] JsonGenerator gen = createGeneratorWithAutoCloseJsonContentEnabled(); [EOL] gen.writeStartArray(); [EOL] gen.close(); [EOL] } [EOL] public void testCloseWithAutoCloseJsonContentEnabledAndInObject() throws IOException { [EOL] JsonGenerator gen = createGeneratorWithAutoCloseJsonContentEnabled(); [EOL] gen.writeStartObject(); [EOL] gen.close(); [EOL] } [EOL] public void testCloseWithAutoCloseJsonContentDisabled() throws IOException { [EOL] JsonGenerator gen = createGeneratorWithAutoCloseJsonContentDisabled(); [EOL] gen.writeStartArray(); [EOL] gen.close(); [EOL] } [EOL] public void testCloseWithAutoCloseTargetEnabled() throws IOException { [EOL] JsonGenerator gen = createGeneratorWithAutoCloseTargetEnabled(); [EOL] gen.close(); [EOL] } [EOL] public void testCloseWithAutoCloseTargetDisabledAndFlushPassedToStreamEnabled() throws IOException { [EOL] JsonGenerator gen = createGeneratorWithAutoCloseTargetDisabledAndFlushPassedToStreamEnabled(); [EOL] gen.close(); [EOL] } [EOL] public void testCloseWithAutoCloseTargetDisabledAndFlushPassedToStreamDisabled() throws IOException { [EOL] JsonGenerator gen = createGeneratorWithAutoCloseTargetDisabledAndFlushPassedToStreamDisabled(); [EOL] gen.close(); [EOL] }

public void test_releaseBuffers_withNonNullOutputBuffer() { [EOL] JsonGeneratorImpl generator = createGeneratorWithNonNullOutputBuffer(); [EOL] generator._releaseBuffers(); [EOL] assertNull(generator._outputBuffer); [EOL] } [EOL] public void test_releaseBuffers_withNullOutputBuffer() { [EOL] JsonGeneratorImpl generator = createGeneratorWithNullOutputBuffer(); [EOL] generator._releaseBuffers(); [EOL] }
public void testPrependOrWriteCharacterEscape_escCodePositive_bufferHasRoom() throws IOException, JsonGenerationException { [EOL] char[] buffer = new char[10]; [EOL] int ptr = 5; [EOL] int end = 10; [EOL] char ch = 'a'; [EOL] int escCode = 1; // Positive escCode, buffer has room [EOL] int result = _prependOrWriteCharacterEscape(buffer, ptr, end, ch, escCode); [EOL] assertEquals(3, result); [EOL] assertEquals('\\', buffer[3]); [EOL] assertEquals((char) escCode, buffer[4]); [EOL] }
public void testPrependOrWriteCharacterEscape_escCodePositive_bufferNoRoom() throws IOException, JsonGenerationException { [EOL] char[] buffer = new char[10]; [EOL] int ptr = 1; [EOL] int end = 10; [EOL] char ch = 'a'; [EOL] int escCode = 1; // Positive escCode, buffer doesn't have room [EOL] int result = _prependOrWriteCharacterEscape(buffer, ptr, end, ch, escCode); [EOL] }
public void testPrependOrWriteCharacterEscape_escCodeNotCustom_chLessThan256BufferHasRoom() throws IOException, JsonGenerationException { [EOL] char[] buffer = new char[10]; [EOL] int ptr = 7; [EOL] int end = 10; [EOL] char ch = 'a'; // ch < 256 [EOL] int escCode = -1; // Not ESCAPE_CUSTOM [EOL] int result = _prependOrWriteCharacterEscape(buffer, ptr, end, ch, escCode); [EOL] assertEquals(1, result); [EOL] assertEquals('\\', buffer[1]); [EOL] assertEquals('u', buffer[2]); [EOL] assertEquals('0', buffer[3]); [EOL] assertEquals('0', buffer[4]); [EOL] }
public void testPrependOrWriteCharacterEscape_escCodeNotCustom_chGreaterThan256BufferHasRoom() throws IOException, JsonGenerationException { [EOL] char[] buffer = new char[10]; [EOL] int ptr = 7; [EOL] int end = 10; [EOL] char ch = 300; // ch > 256 [EOL] int escCode = -1; // Not ESCAPE_CUSTOM [EOL] int result = _prependOrWriteCharacterEscape(buffer, ptr, end, ch, escCode); [EOL] assertEquals(1, result); [EOL] assertEquals('\\', buffer[1]); [EOL] assertEquals('u', buffer[2]); [EOL] }
public void testPrependOrWriteCharacterEscape_escCodeNotCustom_bufferNoRoom() throws IOException, JsonGenerationException { [EOL] char[] buffer = new char[10]; [EOL] int ptr = 5; [EOL] int end = 10; [EOL] char ch = 'a'; [EOL] int escCode = -1; // Not ESCAPE_CUSTOM, buffer doesn't have room [EOL] int result = _prependOrWriteCharacterEscape(buffer, ptr, end, ch, escCode); [EOL] }
public void testPrependOrWriteCharacterEscape_escCodeCustom_bufferHasRoom() throws IOException, JsonGenerationException { [EOL] char[] buffer = new char[10]; [EOL] int ptr = 8; [EOL] int end = 10; [EOL] char ch = 'a'; [EOL] int escCode = CharacterEscapes.ESCAPE_CUSTOM; // ESCAPE_CUSTOM, buffer has room [EOL] int result = _prependOrWriteCharacterEscape(buffer, ptr, end, ch, escCode); [EOL] }
public void testPrependOrWriteCharacterEscape_escCodeCustom_bufferNoRoom() throws IOException, JsonGenerationException { [EOL] char[] buffer = new char[10]; [EOL] int ptr = 1; [EOL] int end = 10; [EOL] char ch = 'a'; [EOL] int escCode = CharacterEscapes.ESCAPE_CUSTOM; // ESCAPE_CUSTOM, buffer doesn't have room [EOL] int result = _prependOrWriteCharacterEscape(buffer, ptr, end, ch, escCode); [EOL] }
public void testFlushBufferWithNonEmptyBuffer() throws IOException { [EOL] _outputTail = 10; [EOL] _outputHead = 5; [EOL] _flushBuffer(); [EOL] assertEquals("Buffer should be flushed", 0, _outputHead); [EOL] assertEquals("Buffer should be flushed", 0, _outputTail); [EOL] }
public void testFlushBufferWithEmptyBuffer() throws IOException { [EOL] _outputTail = 0; [EOL] _outputHead = 0; [EOL] _flushBuffer(); [EOL] assertEquals("Buffer should remain empty", 0, _outputHead); [EOL] assertEquals("Buffer should remain empty", 0, _outputTail); [EOL] }
public void testGetInputCodeUtf8() { [EOL] int[] result = JsonFactory.getInputCodeUtf8(); [EOL] assertNotNull(result); [EOL] assertTrue(result.length > 0); [EOL] }
public void testGetInputCodeComment() { [EOL] int[] result = JsonParser.getInputCodeComment(); [EOL] assertNotNull(result); [EOL] assertTrue(result.length > 0); [EOL] }
public void testCharToHex_ValidAsciiChar() { [EOL] int ch = 'A'; // ASCII value of 'A' is 65 [EOL] int expectedResult = sHexValues[65]; [EOL] int result = charToHex(ch); [EOL] assertEquals(expectedResult, result); [EOL] } [EOL] public void testCharToHex_NegativeAsciiChar() { [EOL] int ch = -1; [EOL] int result = charToHex(ch); [EOL] assertEquals(-1, result); [EOL] } [EOL] public void testCharToHex_NonAsciiChar() { [EOL] int ch = 128; [EOL] int result = charToHex(ch); [EOL] assertEquals(-1, result); [EOL] } [EOL] public void testCharToHex_BoundaryAsciiChar() { [EOL] int ch = 127; [EOL] int expectedResult = sHexValues[127]; [EOL] int result = charToHex(ch); [EOL] assertEquals(expectedResult, result); [EOL] }
public void testCharToHex_ZeroAsciiChar() { [EOL] int ch = 0; [EOL] int expectedResult = sHexValues[0]; [EOL] int result = charToHex(ch); [EOL] assertEquals(expectedResult, result); [EOL] }
public void testQuoteAsStringWithEmptyString() { [EOL] JacksonCoreClass instance = new JacksonCoreClass(); [EOL] String input = ""; [EOL] char[] result = instance.quoteAsString(input); [EOL] assertArrayEquals(new char[0], result); [EOL] }
public void testQuoteAsStringWithNoEscaping() { [EOL] JacksonCoreClass instance = new JacksonCoreClass(); [EOL] String input = "normalString"; [EOL] char[] result = instance.quoteAsString(input); [EOL] assertArrayEquals(input.toCharArray(), result); [EOL] }
public void testQuoteAsStringWithEscaping() { [EOL] JacksonCoreClass instance = new JacksonCoreClass(); [EOL] String input = "stringWith\"Quotes\""; [EOL] char[] expected = "stringWith\\\"Quotes\\\"".toCharArray(); [EOL] char[] result = instance.quoteAsString(input); [EOL] assertArrayEquals(expected, result); [EOL] }
public void testQuoteAsStringWithEscapingAndLargeInput() { [EOL] JacksonCoreClass instance = new JacksonCoreClass(); [EOL] StringBuilder inputBuilder = new StringBuilder(); [EOL] for (int i = 0; i < 10000; i++) { [EOL] inputBuilder.append("a"); [EOL] } [EOL] inputBuilder.append("\""); [EOL] String input = inputBuilder.toString(); [EOL] char[] result = instance.quoteAsString(input); [EOL] assertTrue(result.length > input.length()); [EOL] assertEquals('\"', result[result.length - 2]); [EOL] assertEquals('\\', result[result.length - 3]); [EOL] }
public void testQuoteAsUTF8WithEmptyString() { [EOL] JsonStringEncoder encoder = new JsonStringEncoder(); [EOL] byte[] output = encoder.quoteAsUTF8(""); [EOL] assertEquals(0, output.length); [EOL] }
public void testQuoteAsUTF8WithAscii() { [EOL] JsonStringEncoder encoder = new JsonStringEncoder(); [EOL] String input = "ASCII"; [EOL] byte[] output = encoder.quoteAsUTF8(input); [EOL] assertEquals(input.length(), output.length); [EOL] for (int i = 0; i < input.length(); i++) { [EOL] assertEquals((byte) input.charAt(i), output[i]); [EOL] } [EOL] }
public void testQuoteAsUTF8WithNonAscii() { [EOL] JsonStringEncoder encoder = new JsonStringEncoder(); [EOL] String input = "Non-ASCII: "; [EOL] byte[] output = encoder.quoteAsUTF8(input); [EOL] assertTrue(output.length > input.length()); [EOL] }
public void testQuoteAsUTF8WithEscapeChars() { [EOL] JsonStringEncoder encoder = new JsonStringEncoder(); [EOL] String input = "\"Quoted\""; [EOL] byte[] output = encoder.quoteAsUTF8(input); [EOL] assertTrue(output.length > input.length()); [EOL] }
public void testQuoteAsUTF8WithSurrogates() { [EOL] JsonStringEncoder encoder = new JsonStringEncoder(); [EOL] String input = ""; // This is a surrogate pair in UTF-16 [EOL] byte[] output = encoder.quoteAsUTF8(input); [EOL] assertTrue(output.length > input.length()); [EOL] }
public void testQuoteAsUTF8WithIllegalSurrogate() { [EOL] JsonStringEncoder encoder = new JsonStringEncoder(); [EOL] String input = "\uDC00"; // This is a low surrogate without its high pair [EOL] try { [EOL] encoder.quoteAsUTF8(input); [EOL] fail("Should have thrown an exception due to illegal surrogate character"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testAppendByteEscapeWithNegativeEscCode() { [EOL] ByteArrayBuilder byteBuilder = new ByteArrayBuilder(); [EOL] int ptr = 0; [EOL] int ch = 0x1234; [EOL] int escCode = -1; [EOL] int newPtr = _appendByteEscape(ch, escCode, byteBuilder, ptr); [EOL] assertEquals(6, newPtr); [EOL] byte[] result = byteBuilder.toByteArray(); [EOL] assertArrayEquals(new byte[]{92, 117, 49, 50, 51, 52}, result); [EOL] }
public void testAppendByteEscapeWithNonNegativeEscCode() { [EOL] ByteArrayBuilder byteBuilder = new ByteArrayBuilder(); [EOL] int ptr = 0; [EOL] int ch = 0x34; [EOL] int escCode = 65; // ASCII for 'A' [EOL] int newPtr = _appendByteEscape(ch, escCode, byteBuilder, ptr); [EOL] assertEquals(2, newPtr); [EOL] byte[] result = byteBuilder.toByteArray(); [EOL] assertArrayEquals(new byte[]{92, 65}, result); [EOL] }
public void testAppendByteEscapeWithSingleDigitChar() { [EOL] ByteArrayBuilder byteBuilder = new ByteArrayBuilder(); [EOL] int ptr = 0; [EOL] int ch = 0x1; [EOL] int escCode = -1; [EOL] int newPtr = _appendByteEscape(ch, escCode, byteBuilder, ptr); [EOL] assertEquals(6, newPtr); [EOL] byte[] result = byteBuilder.toByteArray(); [EOL] assertArrayEquals(new byte[]{92, 117, 48, 48, 48, 49}, result); [EOL] }
public void testHasCurrentToken_WhenCurrentTokenIsNull() { [EOL] ParserMinimalBase parser = new ParserMinimalBase() { [EOL] @Override [EOL] public Version version() { [EOL] return null; [EOL] } [EOL] @Override [EOL] public JsonToken nextToken() { [EOL] return null; [EOL] } [EOL] @Override [EOL] public String getCurrentName() { [EOL] return null; [EOL] } [EOL] @Override [EOL] public void close() { [EOL] } [EOL] @Override [EOL] public boolean isClosed() { [EOL] return false; [EOL] } [EOL] @Override [EOL] public JsonStreamContext getParsingContext() { [EOL] return null; [EOL] } [EOL] @Override [EOL] public void overrideCurrentName(String name) { [EOL] } [EOL] @Override [EOL] public String getText() { [EOL] return null; [EOL] } [EOL] @Override [EOL] public char[] getTextCharacters() { [EOL] return new char[0]; [EOL] } [EOL] @Override [EOL] public boolean hasTextCharacters() { [EOL] return false; [EOL] } [EOL] @Override [EOL] public int getTextLength() { [EOL] return 0; [EOL] } [EOL] @Override [EOL] public int getTextOffset() { [EOL] return 0; [EOL] } [EOL] @Override [EOL] public byte[] getBinaryValue(Base64Variant b64variant) { [EOL] return new byte[0]; [EOL] } [EOL] @Override [EOL] protected void _handleEOF() { [EOL] } [EOL] @Override [EOL] public void clearCurrentToken() { [EOL] } [EOL] @Override [EOL] public JsonToken getLastClearedToken() { [EOL] return null; [EOL] } [EOL] }; [EOL] assertFalse(parser.hasCurrentToken()); [EOL] }
public void testHasCurrentToken_WhenCurrentTokenIsNotNull() { [EOL] ParserMinimalBase parser = new ParserMinimalBase() { [EOL] @Override [EOL] public Version version() { [EOL] return null; [EOL] } [EOL] @Override [EOL] public JsonToken nextToken() { [EOL] return null; [EOL] } [EOL] @Override [EOL] public String getCurrentName() { [EOL] return null; [EOL] } [EOL] @Override [EOL] public void close() { [EOL] } [EOL] @Override [EOL] public boolean isClosed() { [EOL] return false; [EOL] } [EOL] @Override [EOL] public JsonStreamContext getParsingContext() { [EOL] return null; [EOL] } [EOL] @Override [EOL] public void overrideCurrentName(String name) { [EOL] } [EOL] @Override [EOL] public String getText() { [EOL] return null; [EOL] } [EOL] @Override [EOL] public char[] getTextCharacters() { [EOL] return new char[0]; [EOL] } [EOL] @Override [EOL] public boolean hasTextCharacters() { [EOL] return false; [EOL] } [EOL] @Override [EOL] public int getTextLength() { [EOL] return 0; [EOL] } [EOL] @Override [EOL] public int getTextOffset() { [EOL] return 0; [EOL] } [EOL] @Override [EOL] public byte[] getBinaryValue(Base64Variant b64variant) { [EOL] return new byte[0]; [EOL] } [EOL] @Override [EOL] protected void _handleEOF() { [EOL] } [EOL] @Override [EOL] public void clearCurrentToken() { [EOL] } [EOL] @Override [EOL] public JsonToken getLastClearedToken() { [EOL] return null; [EOL] } [EOL] @Override [EOL] public JsonToken getCurrentToken() { [EOL] return JsonToken.VALUE_STRING; [EOL] } [EOL] }; [EOL] assertTrue(parser.hasCurrentToken()); [EOL] }
public void testClearCurrentTokenWhenTokenIsNull() { [EOL] ParserMinimalBase parser = new ParserMinimalBase() { [EOL] @Override [EOL] public Version version() { [EOL] return null; [EOL] } [EOL] @Override [EOL] public JsonToken nextToken() { [EOL] return null; [EOL] } [EOL] @Override [EOL] protected void _handleEOF() { [EOL] } [EOL] @Override [EOL] public String getCurrentName() { [EOL] return null; [EOL] } [EOL] @Override [EOL] public void close() { [EOL] } [EOL] @Override [EOL] public boolean isClosed() { [EOL] return false; [EOL] } [EOL] @Override [EOL] public JsonStreamContext getParsingContext() { [EOL] return null; [EOL] } [EOL] @Override [EOL] public void overrideCurrentName(String name) { [EOL] } [EOL] @Override [EOL] public String getText() { [EOL] return null; [EOL] } [EOL] @Override [EOL] public char[] getTextCharacters() { [EOL] return new char[0]; [EOL] } [EOL] @Override [EOL] public boolean hasTextCharacters() { [EOL] return false; [EOL] } [EOL] @Override [EOL] public int getTextLength() { [EOL] return 0; [EOL] } [EOL] @Override [EOL] public int getTextOffset() { [EOL] return 0; [EOL] } [EOL] @Override [EOL] public byte[] getBinaryValue(Base64Variant b64variant) { [EOL] return new byte[0]; [EOL] } [EOL] }; [EOL] parser.clearCurrentToken(); [EOL] assertNull(parser.getLastClearedToken()); [EOL] }
public void testClearCurrentTokenWhenTokenIsNotNull() { [EOL] ParserMinimalBase parser = new ParserMinimalBase() { [EOL] private JsonToken currentToken = JsonToken.VALUE_STRING; [EOL] @Override [EOL] public Version version() { [EOL] return null; [EOL] } [EOL] @Override [EOL] public JsonToken nextToken() { [EOL] return null; [EOL] } [EOL] @Override [EOL] public JsonToken getCurrentToken() { [EOL] return currentToken; [EOL] } [EOL] @Override [EOL] protected void _handleEOF() { [EOL] } [EOL] @Override [EOL] public String getCurrentName() { [EOL] return null; [EOL] } [EOL] @Override [EOL] public void close() { [EOL] } [EOL] @Override [EOL] public boolean isClosed() { [EOL] return false; [EOL] } [EOL] @Override [EOL] public JsonStreamContext getParsingContext() { [EOL] return null; [EOL] } [EOL] @Override [EOL] public void overrideCurrentName(String name) { [EOL] } [EOL] @Override [EOL] public String getText() { [EOL] return null; [EOL] } [EOL] @Override [EOL] public char[] getTextCharacters() { [EOL] return new char[0]; [EOL] } [EOL] @Override [EOL] public boolean hasTextCharacters() { [EOL] return false; [EOL] } [EOL] @Override [EOL] public int getTextLength() { [EOL] return 0; [EOL] } [EOL] @Override [EOL] public int getTextOffset() { [EOL] return 0; [EOL] } [EOL] @Override [EOL] public byte[] getBinaryValue(Base64Variant b64variant) { [EOL] return new byte[0]; [EOL] } [EOL] }; [EOL] parser.clearCurrentToken(); [EOL] assertEquals(JsonToken.VALUE_STRING, parser.getLastClearedToken()); [EOL] assertNull(parser.getCurrentToken()); [EOL] }
protected void _reportUnexpectedChar(int ch, String comment) throws JsonParseException { [EOL] String msg = "Unexpected character (" + _getCharDesc(ch) + ")"; [EOL] if (comment != null) { [EOL] msg += ": " + comment; [EOL] } [EOL] _reportError(msg); [EOL] }
protected void _reportInvalidEOF(String msg) throws JsonParseException { [EOL] _reportError("Unexpected end-of-input" + msg); [EOL] } [EOL] protected ParserMinimalBase(); [EOL] protected ParserMinimalBase(int features); [EOL] public Version version(); [EOL] public abstract JsonToken nextToken() throws IOException, JsonParseException; [EOL] public JsonToken getCurrentToken(); [EOL] public boolean hasCurrentToken(); [EOL] public JsonToken nextValue() throws IOException, JsonParseException; [EOL] public JsonParser skipChildren() throws IOException, JsonParseException; [EOL] protected abstract void _handleEOF() throws JsonParseException; [EOL] public abstract String getCurrentName() throws IOException, JsonParseException; [EOL] public abstract void close() throws IOException; [EOL] public abstract boolean isClosed(); [EOL] public abstract JsonStreamContext getParsingContext(); [EOL] public void clearCurrentToken(); [EOL] public JsonToken getLastClearedToken(); [EOL] public abstract void overrideCurrentName(String name); [EOL] public abstract String getText() throws IOException, JsonParseException; [EOL] public abstract char[] getTextCharacters() throws IOException, JsonParseException; [EOL] public abstract boolean hasTextCharacters(); [EOL] public abstract int getTextLength() throws IOException, JsonParseException; [EOL] public abstract int getTextOffset() throws IOException, JsonParseException; [EOL] public abstract byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; [EOL] public boolean getValueAsBoolean(boolean defaultValue) throws IOException, JsonParseException; [EOL] public int getValueAsInt(int defaultValue) throws IOException, JsonParseException; [EOL] public long getValueAsLong(long defaultValue) throws IOException, JsonParseException; [EOL] public double getValueAsDouble(double defaultValue) throws IOException, JsonParseException; [EOL] public String getValueAsString(String defaultValue) throws IOException, JsonParseException; [EOL] protected void _decodeBase64(String str, ByteArrayBuilder builder, Base64Variant b64variant) throws IOException, JsonParseException; [EOL] protected void _reportInvalidBase64(Base64Variant b64variant, char ch, int bindex, String msg) throws JsonParseException; [EOL] protected void _reportBase64EOF() throws JsonParseException; [EOL] protected boolean _hasTextualNull(String value); [EOL] protected void _reportUnexpectedChar(int ch, String comment) throws JsonParseException; [EOL] protected void _reportInvalidEOF() throws JsonParseException; [EOL] protected void _reportInvalidEOF(String msg) throws JsonParseException; [EOL] protected void _reportInvalidEOFInValue() throws JsonParseException; [EOL] protected void _throwInvalidSpace(int i) throws JsonParseException; [EOL] protected void _throwUnquotedSpace(int i, String ctxtDesc) throws JsonParseException; [EOL] protected char _handleUnrecognizedCharacterEscape(char ch) throws JsonProcessingException; [EOL] protected static final String _getCharDesc(int ch); [EOL] protected final void _reportError(String msg) throws JsonParseException; [EOL] protected final void _wrapError(String msg, Throwable t) throws JsonParseException; [EOL] protected final void _throwInternal(); [EOL] protected final JsonParseException _constructError(String msg, Throwable t); [EOL] int INT_TAB=Optional['\t']; [EOL] int INT_LF=Optional['\n']; [EOL] int INT_CR=Optional['\r']; [EOL] int INT_SPACE=Optional[0x0020]; [EOL] int INT_LBRACKET=Optional['[']; [EOL] int INT_RBRACKET=Optional[']']; [EOL] int INT_LCURLY=Optional['{']; [EOL] int INT_RCURLY=Optional['}'];
protected void _throwUnquotedSpace(int i, String ctxtDesc) throws JsonParseException { [EOL] if (!isEnabled(Feature.ALLOW_UNQUOTED_CONTROL_CHARS) || i >= INT_SPACE) { [EOL] char c = (char) i; [EOL] String msg = "Illegal unquoted character (" + _getCharDesc(c) + "): has to be escaped using backslash to be included in " + ctxtDesc; [EOL] _reportError(msg); [EOL] } [EOL] } [EOL] protected ParserMinimalBase(); [EOL] protected ParserMinimalBase(int features); [EOL] public Version version(); [EOL] public abstract JsonToken nextToken() throws IOException, JsonParseException; [EOL] public JsonToken getCurrentToken(); [EOL] public boolean hasCurrentToken(); [EOL] public JsonToken nextValue() throws IOException, JsonParseException; [EOL] public JsonParser skipChildren() throws IOException, JsonParseException; [EOL] protected abstract void _handleEOF() throws JsonParseException; [EOL] public abstract String getCurrentName() throws IOException, JsonParseException; [EOL] public abstract void close() throws IOException; [EOL] public abstract boolean isClosed(); [EOL] public abstract JsonStreamContext getParsingContext(); [EOL] public void clearCurrentToken(); [EOL] public JsonToken getLastClearedToken(); [EOL] public abstract void overrideCurrentName(String name); [EOL] public abstract String getText() throws IOException, JsonParseException; [EOL] public abstract char[] getTextCharacters() throws IOException, JsonParseException; [EOL] public abstract boolean hasTextCharacters(); [EOL] public abstract int getTextLength() throws IOException, JsonParseException; [EOL] public abstract int getTextOffset() throws IOException, JsonParseException; [EOL] public abstract byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; [EOL] public boolean getValueAsBoolean(boolean defaultValue) throws IOException, JsonParseException; [EOL] public int getValueAsInt(int defaultValue) throws IOException, JsonParseException; [EOL] public long getValueAsLong(long defaultValue) throws IOException, JsonParseException; [EOL] public double getValueAsDouble(double defaultValue) throws IOException, JsonParseException; [EOL] public String getValueAsString(String defaultValue) throws IOException, JsonParseException; [EOL] protected void _decodeBase64(String str, ByteArrayBuilder builder, Base64Variant b64variant) throws IOException, JsonParseException; [EOL] protected void _reportInvalidBase64(Base64Variant b64variant, char ch, int bindex, String msg) throws JsonParseException; [EOL] protected void _reportBase64EOF() throws JsonParseException; [EOL] protected boolean _hasTextualNull(String value); [EOL] protected void _reportUnexpectedChar(int ch, String comment) throws JsonParseException; [EOL] protected void _reportInvalidEOF() throws JsonParseException; [EOL] protected void _reportInvalidEOF(String msg) throws JsonParseException; [EOL] protected void _reportInvalidEOFInValue() throws JsonParseException; [EOL] protected void _throwInvalidSpace(int i) throws JsonParseException; [EOL] protected void _throwUnquotedSpace(int i, String ctxtDesc) throws JsonParseException; [EOL] protected char _handleUnrecognizedCharacterEscape(char ch) throws JsonProcessingException; [EOL] protected static final String _getCharDesc(int ch); [EOL] protected final void _reportError(String msg) throws JsonParseException; [EOL] protected final void _wrapError(String msg, Throwable t) throws JsonParseException; [EOL] protected final void _throwInternal(); [EOL] protected final JsonParseException _constructError(String msg, Throwable t); [EOL] int INT_TAB=Optional['\t']; [EOL] int INT_LF=Optional['\n']; [EOL] int INT_CR=Optional['\r']; [EOL] int INT_SPACE=Optional[0x0020]; [EOL] int INT_LBRACKET=Optional['[']; [EOL] int INT_RBRACKET=Optional[']']; [EOL] int INT_LCURLY=Optional['{']; [EOL] int INT_RCURLY=Optional['}'];
protected final static String _getCharDesc(int ch) { [EOL] char c = (char) ch; [EOL] if (Character.isISOControl(c)) { [EOL] return "(CTRL-CHAR, code " + ch + ")"; [EOL] } [EOL] if (ch > 255) { [EOL] return "'" + c + "' (code " + ch + " / 0x" + Integer.toHexString(ch) + ")"; [EOL] } [EOL] return "'" + c + "' (code " + ch + ")"; [EOL] }
public void testJsonWriteContextConstructor() { [EOL] JsonWriteContext parentContext = JsonWriteContext.createRootContext(null); [EOL] int type = JsonWriteContext.TYPE_ROOT; [EOL] JsonWriteContext context = new JsonWriteContext(type, parentContext); [EOL] assertNotNull(context); [EOL] assertEquals(type, context.type()); [EOL] assertEquals(parentContext, context.getParent()); [EOL] assertEquals(-1, context.getCurrentIndex()); [EOL] }
public void testJsonWriteContextConstructorWithDifferentType() { [EOL] JsonWriteContext parentContext = JsonWriteContext.createRootContext(null); [EOL] int type = JsonWriteContext.TYPE_ARRAY; [EOL] JsonWriteContext context = new JsonWriteContext(type, parentContext); [EOL] assertNotNull(context); [EOL] assertEquals(type, context.type()); [EOL] assertEquals(parentContext, context.getParent()); [EOL] assertEquals(-1, context.getCurrentIndex()); [EOL] }
public void testJsonWriteContextConstructorWithNullParent() { [EOL] int type = JsonWriteContext.TYPE_OBJECT; [EOL] JsonWriteContext context = new JsonWriteContext(type, null); [EOL] assertNotNull(context); [EOL] assertEquals(type, context.type()); [EOL] assertNull(context.getParent()); [EOL] assertEquals(-1, context.getCurrentIndex()); [EOL] }
public void testCreateRootContext() { [EOL] JsonWriteContext context = JsonWriteContext.createRootContext(); [EOL] assertNotNull(context); [EOL] assertEquals(JsonWriteContext.TYPE_ROOT, context.getEntryType()); [EOL] }
public void testCopy() { [EOL] JsonFactory factory = new JsonFactory(); [EOL] JsonFactory copy = factory.copy(); [EOL] assertNotNull(copy); [EOL] assertNotSame(factory, copy); [EOL] }
public void testCheckInvalidCopyWithCorrectClass() { [EOL] MyClass instance = new MyClass(); [EOL] instance._checkInvalidCopy(MyClass.class); [EOL] }
public void testCheckInvalidCopyWithIncorrectClass() { [EOL] MyClass instance = new MyClass(); [EOL] try { [EOL] instance._checkInvalidCopy(OtherClass.class); [EOL] fail("Expected an IllegalStateException to be thrown"); [EOL] } catch (IllegalStateException e) { [EOL] assertEquals("Failed copy(): " + instance.getClass().getName() + " (version: " + instance.version() + ") does not override copy(); it has to", e.getMessage()); [EOL] } [EOL] }
public void testGetFormatName_JsonFactory() { [EOL] JsonFactory factory = new JsonFactory(); [EOL] String formatName = factory.getFormatName(); [EOL] assertEquals(JsonFactory.FORMAT_NAME_JSON, formatName); [EOL] }
public void testGetFormatName_NonJsonFactorySubclass() { [EOL] JsonFactory factory = new JsonFactory() {}; // Anonymous subclass [EOL] String formatName = factory.getFormatName(); [EOL] assertNull(formatName); [EOL] }
public void testHasFormatWithJsonFactoryClass() throws IOException { [EOL] JsonFactory factory = new JsonFactory(); [EOL] InputAccessor acc = mock(InputAccessor.class); [EOL] MatchStrength result = factory.hasFormat(acc); [EOL] assertNotNull(result); [EOL] } [EOL] public void testHasFormatWithNonJsonFactoryClass() throws IOException { [EOL] JsonFactory factory = new JsonFactory() { [EOL] }; [EOL] InputAccessor acc = mock(InputAccessor.class); [EOL] MatchStrength result = factory.hasFormat(acc); [EOL] assertNull(result); [EOL] }
public void testHasJSONFormatWithValidJSON() throws IOException { [EOL] InputAccessor acc = mock(InputAccessor.class); [EOL] when(acc.hasMoreBytes()).thenReturn(true); [EOL] when(acc.nextByte()).thenReturn((byte) '{'); [EOL] MatchStrength result = hasJSONFormat(acc); [EOL] assertEquals(MatchStrength.SOLID_MATCH, result); [EOL] }
public void testHasJSONFormatWithInvalidJSON() throws IOException { [EOL] InputAccessor acc = mock(InputAccessor.class); [EOL] when(acc.hasMoreBytes()).thenReturn(true); [EOL] when(acc.nextByte()).thenReturn((byte) 'a'); [EOL] MatchStrength result = hasJSONFormat(acc); [EOL] assertEquals(MatchStrength.INCONCLUSIVE, result); [EOL] }
public void testHasJSONFormatWithInsufficientData() throws IOException { [EOL] InputAccessor acc = mock(InputAccessor.class); [EOL] when(acc.hasMoreBytes()).thenReturn(false); [EOL] MatchStrength result = hasJSONFormat(acc); [EOL] assertEquals(MatchStrength.INCONCLUSIVE, result); [EOL] }
public void testEnableFeature() { [EOL] JsonFactory factory = new JsonFactory(); [EOL] int initialFeatures = factory.getParserFeatures(); [EOL] JsonParser.Feature featureToEnable = JsonParser.Feature.AUTO_CLOSE_SOURCE; [EOL] factory.enable(featureToEnable); [EOL] int newFeatures = factory.getParserFeatures(); [EOL] assertTrue((newFeatures & featureToEnable.getMask()) != 0); [EOL] assertTrue((initialFeatures & featureToEnable.getMask()) == 0); [EOL] }
public void testIsEnabled_FeatureEnabled() { [EOL] JsonFactory factory = new JsonFactory(); [EOL] JsonParser parser = factory.createParser("{}"); [EOL] parser.enable(JsonParser.Feature.ALLOW_COMMENTS); [EOL] assertTrue(parser.isEnabled(JsonParser.Feature.ALLOW_COMMENTS)); [EOL] }
public void testIsEnabled_FeatureDisabled() { [EOL] JsonFactory factory = new JsonFactory(); [EOL] JsonParser parser = factory.createParser("{}"); [EOL] assertFalse(parser.isEnabled(JsonParser.Feature.ALLOW_COMMENTS)); [EOL] }
public void testConfigureEnableFeature() { [EOL] JsonFactory factory = new JsonFactory(); [EOL] JsonGenerator.Feature feature = JsonGenerator.Feature.AUTO_CLOSE_TARGET; [EOL] JsonFactory result = factory.configure(feature, true); [EOL] assertTrue(result.isEnabled(feature)); [EOL] }
public void testConfigureDisableFeature() { [EOL] JsonFactory factory = new JsonFactory(); [EOL] JsonGenerator.Feature feature = JsonGenerator.Feature.AUTO_CLOSE_TARGET; [EOL] factory.enable(feature); [EOL] JsonFactory result = factory.configure(feature, false); [EOL] assertFalse(result.isEnabled(feature)); [EOL] }
public void testEnableFeature() { [EOL] JsonFactory factory = new JsonFactory(); [EOL] int initialFeatures = factory.getGeneratorFeatures(); [EOL] JsonGenerator.Feature featureToEnable = JsonGenerator.Feature.AUTO_CLOSE_TARGET; [EOL] factory.enable(featureToEnable); [EOL] int newFeatures = factory.getGeneratorFeatures(); [EOL] assertTrue((initialFeatures | featureToEnable.getMask()) == newFeatures); [EOL] }
public void testDisableFeature() { [EOL] JsonFactory factory = new JsonFactory(); [EOL] int originalFeatures = factory.getGeneratorFeatures(); [EOL] JsonGenerator.Feature featureToDisable = JsonGenerator.Feature.AUTO_CLOSE_TARGET; [EOL] factory.disable(featureToDisable); [EOL] int newFeatures = factory.getGeneratorFeatures(); [EOL] int featureMask = featureToDisable.getMask(); [EOL] assertTrue((originalFeatures & featureMask) != 0); [EOL] assertTrue((newFeatures & featureMask) == 0); [EOL] assertNotEquals(originalFeatures, newFeatures); [EOL] }
public void testDisableFeatureAlreadyDisabled() { [EOL] JsonFactory factory = new JsonFactory(); [EOL] JsonGenerator.Feature featureToDisable = JsonGenerator.Feature.AUTO_CLOSE_TARGET; [EOL] factory.disable(featureToDisable); [EOL] int featuresAfterFirstDisable = factory.getGeneratorFeatures(); [EOL] factory.disable(featureToDisable); [EOL] int featuresAfterSecondDisable = factory.getGeneratorFeatures(); [EOL] assertEquals(featuresAfterFirstDisable, featuresAfterSecondDisable); [EOL] }
public void testIsEnabledWithFeatureEnabled() { [EOL] JsonGenerator g = new JsonGeneratorImpl(); [EOL] g.enable(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN); [EOL] assertTrue(g.isEnabled(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN)); [EOL] }
public void testIsEnabledWithFeatureDisabled() { [EOL] JsonGenerator g = new JsonGeneratorImpl(); [EOL] g.disable(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN); [EOL] assertFalse(g.isEnabled(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN)); [EOL] }
public void testName2WithValidParameters() { [EOL] String expectedName = "testName"; [EOL] int expectedHash = 12345; [EOL] int expectedQuad1 = 1; [EOL] int expectedQuad2 = 2; [EOL] Name2 name2 = new Name2(expectedName, expectedHash, expectedQuad1, expectedQuad2); [EOL] assertEquals(expectedName, name2.getName()); [EOL] assertEquals(expectedHash, name2.getHash()); [EOL] assertEquals(expectedQuad1, name2.getQuad1()); [EOL] assertEquals(expectedQuad2, name2.getQuad2()); [EOL] }
